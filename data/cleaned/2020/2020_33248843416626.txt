demystifying loops in smart contracts benjamin mariano bmariano cs.utexas.edu university of texas at austinyanju chen yanju cs.ucsb.edu university of california santa barbarayu feng yufeng cs.ucsb.edu university of california santa barbara shuvendu k. lahiri shuvendu.lahiri mircrosoft.com microsoft researchisil dillig isil cs.utexas.edu university of texas at austin abstract this paper aims to shed light on how loops are used in smart contracts.
towards this goal we study various syntactic and semantic characteristics of loops used in over solidity contracts deployed on the ethereum blockchain with the goal of informing future research on program analysis for smart contracts.
based on ourfindings weproposeasmalldomain specificlanguage dsl that canbe used tosummarize common loopingpatterns in solidity.
to evaluate what percentage of smart contract loops can beexpressed in our proposed dsl we also design and implement a program synthesis toolchain called solis that can synthesize loop summariesinourdsl.ourevaluationshowsthatatleast56 of theanalyzedloopscanbesummarizedinourdsl and81 ofthese summaries are exactly equivalent to the original loop.
acm reference format benjaminmariano yanjuchen yufeng shuvenduk.lahiri andisildillig.
.demystifyingloopsinsmartcontracts.in 35thieee acminternationalconferenceonautomatedsoftwareengineering ase september virtualevent australia.
acm newyork ny usa 13pages.
introduction asprogramsthatrunonablockchain smartcontractsenablemultiparty transactions that involve the transfer of funds or other commodities.
due to their obvious security critical nature there has beenaflurryofinterest bothinthesecurity softwareengineering andformalverificationcommunities indevelopingtechniquesforautomaticallycheckingthatsmartcontractsbehaveasexpected.forexample someofthesetechniqueslookforcertainpatterns suchasre entrancy that are highly correlated with security vulnerabilities in practice .
other proposals aim for full functional correctness and propose verification tools for checking smart contracts against manually written formal specifications .
despitenumerousdifferencesbetweenexistingcontractanalysis techniques acommonunifyingthemebehindthesetechniquesis the assumption that loops occur rarely in smart contracts .
as permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
result most existing program analysis techniques in this space brush aside the classical problem of loop invariant generation and focus on challenges that are unique to smart contracts.
thegoalofthispaperistostudyhowloopsareusedinsmart contracts and examine how frequently they occur in practice.
our main motivation behind this study is to guide and inform future research on analysis techniques for smart contracts.
specifically we focus on solidity the most popular programming language for smart contract development and study over soliditycontracts deployed on the ethereum blockchain.
in addition to evaluatingloopfrequency wealsoinvestigateseveralinteresting syntactic and semantic properties of smart contract loops.
our primary goal in this study is to understand the nature of loops that occurinsmartcontractssothatsubsequentresearchcandevelopsuitableabstractdomainsandotheranalysistechniquesformore precise static reasoning about smart contracts.
as a first step towards achieving this goal we implement a basic static analysis to extract several interesting features of smart contract loops.
we then use the results of this analysis to clustersemantically similar loops and manually study the behavior ofdifferent clusters.
our manual investigation suggests that mostsmart contract loops can be summarized using a small domainspecific language dsl with familiar functional operators such as map fold and zip.
asanextsteptowardsprecisereasoningaboutsmartcontract loops we build a program synthesis toolchain for generating summaries of solidity loops in our proposed dsl.
our synthesizerperforms type directed search over the dsl constructs and uses properties of the loop body to significantly prune the search space ofcandidatesummaries.oncewegenerateacandidatesummary we then check for equivalence against the original solidity loop usinga bounded equivalencecheckerbuiltontopofrosette .
wehaveimplementedoursmartcontractloopsummarization techniqueinatoolcalledsolisandevaluateitonalargecollection of solidity loops.
our evaluation suggests that a majority of smart contract loops can be summarized either partially or precisely in our proposed dsl by leveraging program synthesis.
in summary this paper makes the following contributions we perform an empirical study of loops in over so liditycontractsdeployedontheethereumblockchainandstudy various syntactic and semantic properties of these loops.our studyshowsthathalf ofthecontracts withover lines of code contain at least one loop and that a typical contract contains one loop per lines of solidity code.
35th ieee acm international conference on automated software engineering ase we cluster smart contract loops according to their semantic featuresandmanuallyinvestigateeachclustertounderstand common behaviors of solidity loops.
weuse the results fromour manual investigation todesign a domain specific language called consul for summarizing smart contract loops using familiar functional operators.
weimplementaprogramsynthesistoolchaincalledsolis for summarizing solidity loops in consul which uses type informationandpropertiesoftheinputlooptoreducethe space of candidate loop summaries that it needs to consider.
we perform an evaluation of our synthesizer on loops and show that almost half of the loops can be precisely summarized in our dsl using the proposed synthesis technique.
astudyofloopsinsmartcontracts inthissection weprovidestatisticsaboutthefrequencyofloopsin smartcontractsandreportonthedistributionofloopsaccording to various features.
to perform this study we collected over smart contracts from etherscan and used the slither static analyzer to analyze their loops.
in this section we summarize our findings for the contracts that could be analyzed by slither.
.
frequency of loops since many program analyzers for smart contracts are based on the assumption that loops are rare we first study the frequency of loops in smart contracts written in solidity.
figure1presentsabarchartshowingthepercentageofcontracts thatcontainatleastoneloop inred .specifically eachbarcorresponds to a family of smart contracts grouped according to their linesofsoliditycode.acrossallcontracts wefindthatroughlyone infive contractshaveatleast oneloop suggestingthat loopsmay not be quite as rare as assumed in prior work .
however the percentageofcontractsthatcontainloopsincreasessignificantly asweconsiderlargercontracts.inparticular forcontractsbetween lines of code roughly four in five contracts contain at least one loop and almost no contract with over lines of code is loop free.
next we study the frequency of loops within a typical smart contract.
the blue bars in figure show the frequency of loops per lines of source code again grouped according to lines of solidity code.
across all contracts we encounter an average of one loopper250linesofsourcecode.however thisratioissignificantly higher for larger contracts.
in particular for contracts with over lines of code we encounter an average of one loop per lines of source code.
keyfinding1 roughlyoneinfivecontractscontainatleast oneloop andonlyhalfofthecontractswithover200linesof codeareloop free.acrossallcontracts wefindanaverage of one loop per every lines of source code.
.
nature of loops syntactically in this section we investigate various syntactic properties of loops insmartcontracts.inparticular table1presentsinformationabout 1slitherisunabletoanalyzesomeofthesecontractsduetounsupportedversionsor features of solidity.
figure percentage of smart contracts containing at leastoneloopandfrequencyofloopsperhundredlinesofsourcecode grouped according to contract lines of source code description avgmedian max loc size of the loop body .
nesting level .
number of variables .
loc size of the loop body .
nesting level .
number of variables .
loc size of the loop body .
nesting level .
number of variables .
loc size of the loop body .
nesting level .
number of variables .
overall size of the loop body .
nesting level .
number of variables .
table1 informationaboutloopsize nestinglevel andnumber of variables touched thesizeofloopsforafamilyofcontractsgroupedaccordingtotheir size.acrossallcontracts wefindthatthemediansizeoftheloop body istwo linesof code and unlike frequency figure we see that loop size does not seem to vary much according to contract size.asalsoshownintable1 itisveryuncommontoseenested loopsinsmartcontracts themediannestinglevel includingfor contracts over lines of code is just one i.e.
no nested loops .
furthermore a typical loop touches an average of roughly five 263program variables.
key finding a typical smart contract loop is quite small containing roughly two lines of code in their body.
furthermore nested loops are very uncommon.
next as summarized in table we study what percentage of loops exhibitvarious syntactic properties.
ourfirst finding isthat theoverwhelmingmajorityofsmartcontracts around88 involve collections meaning that they iterate over elements of arrays or mappings.furthermore roughlythreeoutoffourloopsperform writes meaning that they involve side effects on contract state the remaining quarter of loops contain only purely read statements suchasrequire transfer log andeventbroadcasts.anotherinteresting observation is that while the average loop body contains approximately two lines of code more than one in three loops contain at least one control flow construct e.g.
if statement continue etc.
in their body.
other salient findings from our study can be summarized as follows batch transfer loops that involve calls to built in solidityfunctionslike sendandtransfer typicallyperformsocalledbatchtransfer meaningthattheytransferethertoa set of recipients.
according to our findings .
of solidity loops perform batch transfer.
enforcing requirements programmers use the require constructinsoliditytoestablishsomepre condition.wefind that13 ofloopsinvolvea requirestatement suggesting that these loops establish some universally quantified precondition involving a data structure.
nested loops aswesaw earlier nestedloopsareuncommon and only .
of loops contain a nested loop.
safemath approximatly13 oftheloops involveacallto the safemath library for avoiding overflows.
events solidity programs can emit so called eventsthat faciliate the convenient usage of evm logging facilities.
we findthattheemissionofeventsisquiteuncommonwithin loops only .
of loops involve events.
function calls roughlyoneinfivesolidityloopscontain a call to a function excluding safemath calls and built in functions like transfer .
bounded loops approximately of the loops have a constant bound while the remaining ones all have symbolic bounds.
key finding the overwhelming majority of loops iterate overcollectionsandmodifycontractstate.however since functioncallswithinloopsarenotverycommon analysisof most loops does not require interprocedural reasoning.furthermore of solidity loops have symbolic bounds therefore analysistechniquesbasedonloopunrollingcannot soundly handle most smart contract loops.
.
nature of loops semantically inthissection weinvestigatesomeinterestingsemanticproperties ofsmartcontractloops.toperformthisstudy weusetheslither infrastructure toimplementabasicstaticanalysisforanalyzingdescription percentage loops that involve collections .
loops that involve writes .
loops that involve events .
loops that have function calls .
loops that have control flow constructs .
loops that have nested loops .
loops that have transfers .
loops that have requires .
loops involving safemath .
loops that have a constant bound .
table syntactic properties of loops type of dependence percentage scalar value depends on collection .
collection depends on collection .
collection depends on scalar .
collection key depends on collection value .
table semantic properties of loops datadependenciesbetweenvariables.theresultsofthisanalysis are summarized in table .
our first finding is that of the smart contract loops involve somedatadependencyfromcollectionstoscalars.suchdatadependencies typically arise when the loop performs some computation byiterating over adata structure suchascomputing thesum ofall elements in an array.
next wefindthat24 ofloopsinvolvedatadependencybetween a pair of collections including dependencies between different elementsofthesamecollection .forexample suchdependencies arisewhenshiftingarrayelementsorbuildinganewdatastructure based on values stored in other data structures.
on the other hand dependencies of collections on scalars is slightly less common roughly of loops exhibit such a dependency.
for instance aloop that sets some range of array elements to a constant value would exhibit such a collection on scalar dependency.
finally westudyhowoftencollectionelementsareusedtoindex intoothercollections.forinstance considerascenariowherean arrayastores all participants in an auction and another mapping mfromparticipantsto amountsstoresthebidof eachparticipant.
in this scenario one may need to loop over all elements in array aand usea to access the bid of a given participant in m.w e refertothistypeofdependencyas value to key dependencyand find that of loops involve such a pattern.
.
clustering loops by semantic properties in this section we identify common looping patterns in smart contractsusingacombinationofk meansclusteringandmanual sampling.
in particular we use the scikit learn python library tofacilitatesemanticclusteringofsolidityloops andthenmanually inspect samples from each cluster to determine common semantic behaviors per cluster.
264figure semantic clustering of smart contract loops projected into 3d space.
toperformthisclustering wefirstreducedtheloopstodependency graphs similar to droidsift and holmes .
as the fourpropertiesintable3areclearlynotsufficientforclustering webrokedownthesepropertiesintocommondependencygraph features such as the number of different types of nodes that are being read from or written to.
in total we used features that serve as refinements of the properties from table .
for a completelistofthefeaturesused seeappendixa2.toidentifyonly commonlooppatterns werestrictedthenumberofclusters to .
additionally toreduceoverlapinclusters welimitedloopstothose withsingle statementbodiesthatcontainonlycommonfunction calls transfers requires and safemath functions .
figure2showstheresultsofourclustering projectedontothree dimensions by performing a high dimensionality reduction in ascatter plot.
for each cluster we randomly sampled files and manually inspected each sample.
we will now explain some of the salient findings from our manual investigation.
fold pattern.
both cluster pictured in red in figure and cluster in green contain loops that perform an accumulating computation similar to a foldin functional programming.
in particular of the sampled loops from cluster sum the values of an array mapping while of from cluster perform a fold using a more complicated arithmetic function.
map pattern.
clusters in blue in orange and in purple containloopsthatmapvaluesontoaglobalarray mapping similar to the mapcombinator in functional programming.
in particular of the loops sampled from cluster write a constant value c to mapping mindexed by an array a i.e.
m cwhereiis the loop iterator .
of the sampled loops in cluster and of fromcluster4containawritefromonemapping m1toanother m2 2appendix is included in the supplementary material.
3initiallywetriedlessrestrictiveclustering butthisledtoclusterswhosecommon behaviors were hard to identify.e.g.
m1 m2 .
require.
in addition to the mapping pattern found in cluster in purple we also found that of the sampled loops contain callstothebuilt in requirefunction whichrevertsexecutionof the smart contract if a user defined condition is not met.
for all threeloops theuser definedconditionwasalinearconstrainton values of an array mapping.
arithmetic.
finally the loops sampled from cluster in grey allcontaincomplexarithmeticcomputationsoverglobalintegers.
furthermore alloftheseloopsusearithmeticfunctionsfromthe common safemath library whichmay bewhytheywereclustered together.however thisclusterissignificantly smallerthanallthe other clusters instancesin this cluster only constitute ofthe loops used for this analysis.
in addition to sampling instances from each cluster we also sampled larger loops to see if their behavior can be expressed asa combination of the behaviors observed in each of our clusters.
whilewefoundmanyofthesamebehaviors ourmanualinvestigation of larger loops revealed another operator namely zipwith that is useful for characterizing smart contract loops.
in particular loopsinvolvingthispatternperformpair wiseaggregationbetween twoarrays mappings.however wefoundseveralvariantsofthe zipwithpattern where one or both of the mappings are indexed by another mapping array.
a dsl for loop summarization based on our findings from the previoussection we now propose a small but expressive dsl called consul4that can be used to summarize common solidity loops.
we believe this dsl can aid analysis verification andoptimizationeffortsforsmartcontracts by capturing common loop behaviors and facilitating the design of suitable abstract domains for analyzing smart contract loops.
the syntax of the consul summarization language is shown in figure .
at a high level consul programs are compositions of assignments v e wherevisaprogramvariable requirements andethertransfers.specifically assignmentscapturesideeffectsof loops on program variables and multiple side effects are expressed via composition.
in addition to capturing side effects on explicit contract state our dsl also captures the semantics of loops that involve transferandrequire whichoccurinanon trivialportion of loops recall table .
intheremainderofthissection wegiveahigh leveldescription ofconsulsemanticsandrefertheinterestedreadertoappendixb for the formal semantics of each construct.
.
summarizing side effects on contract state consulprogramssummarizethesideeffectsofsolidityloopsusingthreefunctionaloperatorsandtheirvariants.alloftheseconstructs operate over mappings and produce either scalars or mappings.
4stands for concise summaries of loops 265core constructs stmts v e s s transfer m1 m2 f require m 1 2 requirenested m1 m2 1 2 expre m mappings map m f foldl m f i wheref max ... zip m1 m2 f wheref max ... mapnested m1 m2 f foldlnested m1 m2 f i wheref ... zipnestedsym m1 m2 m3 f f ... zipnestedasym m1 m2 m3 f f ... functions functionf x.t termt x i x iwhere inti c int e intprogexprs predicates predicate x y .
formula true inrange x t1 t2 v multicloseleftt1wherev x y multicloseleft 1 2 1 2 figure the consuldsl for expressing loop summaries map operator.
the most basic construct in consul is the map operator map m f which yields a new mapping m primewhich is the same as mexcept that any key value pair k v satisfying is changed to k f v .
for instance a loop that increments the firstnelements in an array aby one can be summarized using the following consul statement a map a x y .inrange x n x.x foldloperator.
asmentionedinsection2.
roughlyoneinfive solidityloopsperformsomesortofaggregationoveradatastructure.tocapturethiscommonpattern consulprovidesaconstruct oftheform foldl m f i thataggregatesallvaluesin msatisfying by using function fand initial value i. as an example the statement x foldl a true captures the behavior of a loop thatcomputesthesumofallelementsinarray aandassignsitto variablex.
zip operator.
another common pattern we observed in solidity loopsistoperformpair wiseaggregationbetweentwo mappings.
consul captures this common behavior using the zipconstruct.
for example the statement c zip a b true captures the effect of aloop that constructsa new array cwhere eachelement c is the sum of a andb .
nested family of operators.
as discussed in section .
many solidity loops iterate over a mapping m1and use values in m1to access values in another mapping m2.
furthermore we found this patterntooccurfrequentlybothforperformingaggregationaswell asbuildingnewdatastructures.therefore theconsullanguageprovidesavariantofeachofthe map zipandfoldlconstructsfor expressing such behaviors.
specifically the construct mapnested m1 m2 f is similar tomapexcept that lambda expression fis applied to elements m1 ratherthan m1 forkeys indices isatisfyingpredicate .forinstance considerasmartcontractthathasanarraycalled a that stores a designated set of addresses as well as another array calledbthat maps each address to some amount.
now consider a loop that increments the amount of money for each address in abysomeamount amt.thiscomplexpatterncanbesummarized concisely using the mapnested pattern as follows b mapnested b a true x.x amt next thenestedvariantof foldl called foldlnested allowsperformingnestedaggregation.inparticular foldlnested m1 m2 f i aggregatesusingfunction fallelements m1 forkeys indices isatisfying predicate .
for instance the statement foldlnested a b x y .inrange x computes the sum a a a .
finally the two zipnested constructs provide nested variants of zip.
specifically consider three mappings m1 1 2m2 1 2m3 3 1 then zipnestedsym m1 m2 m3 f creates a new mapping m4 oftype 1 2wherem4 isequalto f m1 m2 for those indices isatisfying .
the other variant zipnestedasym is similar except that it is asymmetric.
specifically it operates over mappings with the following types m1 1 2m2 3 2m3 3 1 then theconstruct zipnestedasym m1 m2 m3 f createsanew mappingm4of type 1 2where m4 f m1 m2 for those indices isatisfying .
in practice we found this asymmetricvariantof zipnested tooccurmorefrequentlythanitssymmetric variant.
.
summarizing transfers and requirements recall fromsection .
thatroughly one infivesolidity loopsinvolvecallstobuilt insolidityfunctionssuchas requireandtransfer.
thus our summarization language also provides constructs for capturingthebehaviorofsuchloops.forinstance theconstruct transfer m1 m2 f isusedtosummarizebatchtransferswhere m1is a mapping addressandm2is a mapping int.
inparticular transfer m1 m2 f indicatesthebatchtransferof amountm2 fromthereceiverobjecttoaddress m1 forallkeys isatisfying predicate .
finally our dsl provides two variants of requirefor summarizing loops that enforce some pre condition.
in particular the construct require m 1 2 checksthatpredicate 2issatisfiedfor allelements m whereisatisfies 1.the requirenested construct is similar and corresponds to the nested variant of require.
specifically require m1 m2 1 2 checks that predicate 2is satisfied for all elements m1 whereisatisfies 1.
266solidity loop consul equivalent for j j addrs.length j bal amts bal zipnestedasym bal amts addrs inrange x addrs.length for i i addrs.length i if !wlst wlst true wlst mapnested wlst addrs inrange x a ddrs.length y true for j j addrs.length j cur addrs require cur !
0x0 require now utime amts 1e8 total amts require addrs inrange x addrs.length x!
0x0 requirenested utime addrs inrange x addrs.length x now amts map amts inrange x addrs.length x 1e8 total foldl amts inrange x addrs.length total table examples of solidity loops and their consulequivalent.
we omit lambdas to improve readability.
.
examples in this section we provide some sample solidity loops and show how they can be summarized in the consul dsl.
example3.
.
thefirstrowintable4showsasinglelinesolidity loopthatincrementsthebalanceofalistofaddressesbyagiven amount.thisloopcanbesummarizedusingtheasymmetricversion of the zipnested construct as shown on the right hand side of table .
example .
.
the second row of table shows a loop that whitelists certain addresses if that address is not already on the whitelist.thisloopcanbesummarizedusingthe mapnested construct as shown in the second column of table .
observe that the predicateensuresthat foranyupdatedelement thekeymustbe intherange addrs.length andthecorrespondingvaluemust be false.
example .
.
the last row in table shows a more complex loop that establishes a pair of pre conditions while also having sideeffectsoncontractstate.asshownontherighthandsideof the table the summary of this loop involves the requirenested construct since therequirement onthe thirdline ofthe loopbody involves a nested data structure access.
the update to the amts arrayiscapturedusingthe mapconstructandthecomputationof total amount is captured using foldlwith the operator.
synthesis of loop summaries as a first step towards reasoning about loops in smart contracts we implemented a tool called solis for automatically synthesizing loop summaries.
our tool is based on the syntax guided synthesis paradigm and as shown in figure it leverages both an type directed search engine and a bounded equivalence checker.
specifically the search engine enumerates candidate consul summaries for thegiven loop and uses theverifier to test equivalence betweentheloopandcandidatesummary.thesearchenginecontinues this enumeration process until we either exhaust all candidate consul programs forthe givenloopor until wegenerate an equivalent summary.
in the remainder of this section we provide a briefoverview of the search engine and equivalence checker underlying the solis summary synthesis engine.
.
type directed search engine similar to several other synthesizers solis enumerates dslprogramsinincreasingorderofcomplexityandleveragesproperties of the input loop to avoid enumerating useless summaries.specifically our search engine utilizes both type information as wellasbasicstaticanalysisoftheloopbodytoprunelargepartsof the search space.
in more detail table presents necessary conditions for our search engine to enumerate a given consul statement.
these preconditions make use of two main types of information variable types given a variable v we write v 1to indicate that the type of variable vis 1.i f 1 map the notation 2 3indicates that the key type of the map is 2and value type is 3. read write sets for each loop lin the original contract we compute the set of variables it reads from and the set ofvariablesitwritesto.weusethenotation v reads l resp.v writes l to indicate that vis read from resp.
written to in loop l. since the pre conditions in table are fairly self explanatory we do not describe all of them in detail but focus on a few example constructs map according to the second row of table solis only enumeratesthestatement v1 map v2 f ifbothv1and v2have type mapping and v1is written to by the input loop whereasv2is read from.
foldlnested foraninputloop l thesummaryshouldonly containthestatement v1 foldlnested v2 v3 f i ifv1has type intand the value type of v3is the same as the key type ofv2.
in addition v1must be written to and v2 v3must be read from.
composition according to the first row of table differentstatementsinthesummaryshouldnotwritetothesame variable.
this rule prevents solis from enumerating useless 267solis type directed searchequivalence checker loop consul summary figure overview of solis statement pre condition s1 s2 writes s1 writes s2 v1 map v2 f v1 v2 map v1 writes l v2 reads l v1 foldl v2 f i v1 int v2 map v1 writes l v2 reads l v1 zip v2 v3 f v1 v2 v3 map v1 writes l v2 v3 reads l v1 mapnested v2 v3 f v1 map v2 1 2 v3 3 1 v1 writes l v2 v3 reads l v1 foldlnested v2 v3 f i v1 int v2 1 2 v3 3 1 v1 writes l v2 v3 reads l v1 zipnestedsym v2 v3 v4 f v1 map v2 v3 1 2 v4 3 1 v1 writes l v2 v3 v4 reads l v1 zipnestedasym v2 v3 v4 f v1 map v2 1 2 v4 3 1 v3 3 2 v1 writes l v2 v3 v4 reads l require v 1 2 containsrequire l v reads l requirenested v1 v2 1 2 containsrequire l v1 v2 reads l v1 1 2 v2 3 1 transfer v1 v2 f containstransfer l v1 1 address v2 2 int v1 v2 reads l table pruning rules used by the search engine of solis define check eq fun1 fun2 input k define i state initial state input define o1 interpret fun1 i state k define o2 interpret fun2 i state k verify assert equal?
o1 o2 figure core idea behind equivalence checker summaries where the effect of one summary statement is overridden by a subsequent one.
foragivensolidityloop l therearetypicallynottoomanyconsul statements that meet the pre conditions from table thus our pre conditions are effective at pruning a large part of the search space during enumeration.
in addition to the rules shown in table solis uses several othertype directedrulestoprunethespaceoffunctionsitneeds to consider.
for example consider again the statement v1 map v2 x.t clearly forthisprogramtotype check thetypeof tmustbethe sameasthevaluetypeof v1.thus soliscanalsousetype based reasoning when filling in lambda expressions used in consul constructs.
.
equivalence checker once solis generates a candidate summary it needs to check whether the summary is equivalent to the original loop l. towards this goal we first convert the consul summary sinto equivalent solidity code s primeusing syntax directed translation see appendixb .
however since there is no off the shelf equivalence checker for solidity programs we also implemented a bounded verifier for checking equivalence between a pair of solidity programs.
thekeyideaunderlyingourequivalencecheckerisillustrated in the code shown in figure .
specifically the checker takes as inputtwosolidityprograms fun1andfun2aswellasasymbolic input called inputand verification bound kthat controls how many times the loops are unrolled.
then we symbolically evaluate both fun1andfun2on the symbolic input state to obtain a pair ofsymbolicoutputstates o1ando2.iftheresultingoutputstates are equal this constitutes a proof up to bound k that the consul summary is equivalent to the original loop.
we have implemented our equivalence checker on top of the rosetteframework andleverageitssmtencodingfacilitiesas wellasitssymbolicevaluationengine.specifically weimplemented atranslatorfromsoliditycodetoanintermediaterepresentation that can be symbolically evaluated by rosette.
.
compositional synthesis as is common in program synthesis the search space of programs wemustconsiderinconsulincreasesexponentiallyinthenumber ofstatements.toscaleoursynthesisproceduretolargerconsul programs we introduce compositional synthesis which enables synthesis of complex summaries by synthesizing their constituent parts and then composing them together.
in particular compositional synthesis works by independently synthesizing partial summaries for each variable written in the loop andthencomposingthemtogetherwithconsul ssequencing operator.considerthefollowingloop whichcanbeexpressedin 268size loops time outs precise sum.
partial sum.
overall incl.
t o overall excl.
t o all loops table evaluation results consulasa foldover arr storedin acc followedbya mapover arr stored in arr .
for uint i i len i acc arr arr westartbysynthesizingasingle statementsummaryforeach variablewhichiswrittenintheloop inthiscasewesynthesizethe following two summaries acc foldl arr inrange x len acc arr map arr inrange x len x finally wecomposetogetherthetwosummariesusingthesequencing operator which gives us the complete summary.
while this optimization does not affect the soundness of our synthesisalgorithm itdoesmakeitincomplete.inparticular this algorithm will not be able to synthesize a consul program p s1 s2where statement s2dependson statement s1 that is where variables read in s2are written in s1.
this is because there is no valid single statement partial summary which captures s2without s1.
in practice we observed relatively few loops with dependent statements and thus found it worth sacrificing completeness for scalability.
evaluation toevaluate whatpercentageofsolidityloopscanbesummarized in our proposed consul language we used solis to synthesize summaries for real world solidity loops.
the main goal of our evaluation is to answer the following research questions rq1what percentage of loops can be precisely or at least partially summarized in the consul language?
rq2whatistherelativefrequencyofconsulconstructsthatare used in solidity loop summaries?
rq3what types of loops cannot be summarized using solis?
.
experimental set up we conduct this experiment on approximately contracts that containloops.specifically toperformthisexperiment weextract allloopscontainedinthese1200contractsandthenfilteroutloopsthatcontainsolidityfeaturesthatcannotbehandledbysolis.such features include user defined constructs multi dimensional arrays and calls to functions that cannot be analyzed by solis.
using this methodology we obtained a total of benchmarks which corresponds to approximately of all loops found within the original solidity contracts.all experiments reported in this section are conducted on a t3.2xlarge machine on microsoft azure with an intel xeon platinum cpu and 32g of memory running the ubuntu .
operating system and using a timeout of minutes for each loop.
.
key results we now summarize our key findings as they relate to the research questions posed earlier.
table6presentstheresultofrunningsolisoverour1220benchmarks.
here the first column shows the size of the loop body in termsoflinesofsoliditycode andthesecondcolumnshowsthe total number of loops of that size.
the next column labeled timeouts shows the number of benchmarks for which solis fails tofinish its exploration within the given time limit.
next the columnlabeled precisesum.
showsthenumberofloopsforwhich solis is able to find a precise summary that is the generatedsummary is exactly equivalent to the original loop.
on the other hand the column labeled partial sum.
shows the number of loops forwhichsoliscangenerateapartial butnotprecise summary that is a summary which over approximates the loop s actual post condition.
finally the column labeled overall incl.
t o shows the percentage of loops for which solis can generate anysummary either precise or partial including those benchmarks where we encounter a time out.
the last column reports the same information but excludesthose benchmarks on which solis timesout.intheremainderofthisdiscussion wemostlyfocusonthose benchmarksonwhichsolisdoesnottimeout asourprimarygoal is to investigate solidity loops rather than the solis synthesizer.
aswecanseefromtable6 soliscangenerateasummaryfor ofthebenchmarks andwefindthatthesesummariesareequivalenttotheoriginalloopfor53 ofthebenchmarksonwhichwe do not observe a time out.
as we can also see from table the percentage of loops that can be summarized by solis is smaller for largerloops.however uponmanualinspection wefindthatthis is often due to the incomplete decomposition strategy describedin section .
.
in particular while this decomposition allows our synthesis technique to be more scalable it sacrifices completeness insituationswhereonesideeffectoftheloopisdependentupon anotherone.thus inreality thepercentageofloopsthathavea consulsummaryismuchhigherthanthedatapresentedintable6.
result for rq1 at least of the loops in solidity contracts have a summary that is expressible in the consulloop summarization dsl and of these summaries are equivalent to the original loop.
269figure frequency of consulconstructs next toansweroursecondresearchquestion figure6shows therelativefrequencyofeachconsulconstructinthegenerated summaries.
for each dsl operator map foldetc we group together its nested and non nested version e.g.
the bar labeled zip includes all three variants of the zipconstruct.
finally the last two columnsdifferentiatebetweenthenestedandnon nestedversion of the dsl operators.
for example the bar labeled nested includes mapnested foldlnested requirenested and the two nested variants of zip.
as we can see from figure mapis the most commonly occurringdslconstruct followedbythe requireoperator.5thenexttwo most common operators are foldlandzip and by far the least common construct is transfer.
another interesting observation from figure is that the nested versions of the operators occur more frequently than the non nested versions vs. .
result for rq2 the most commonly occurring consul constructinthesynthesizedsummariesis map.furthermore the nested variants of consul operators occur more commonly than their non nested variants.
finally to answer our third research question we give some examples of solidity loops for which solis was unable to generate a useful summary despite exploring the whole search space i.e.
no time out .
as expected there are two reasons why solis fails to summarizealoop sbehavior thesemanticsoftheloopcannot be captured by the consul dsl or synthesis fails due to the incomplete decomposition heuristics employed by solis.
to understand the latter issue consider the last example from table4.here becausethereisadependencybetweentheloop smultiplesideeffects e.g.
thelast foldloperationdependsontheearlier mapoperation we cannot generate the summary in a compositional way so the decomposition strategy described in section .
failstowork.asaresult solisisunabletocapturetheloop seffect 5part of the reason that requireis so common is due to the fact that solis summarizes requirestatements with conjunctions in the solidity code with multiple require statements.
for uint i i len i sig bytes4 uint sig uint data len i while first last uint256 check first last if n check last check else first check for uint256 j j i j if topwinners !
msg.sender topwinners topwinners else for uint256 k j k k topwinners topwinners figure7 examplesolidityloopswhichcannotbeexpressed inconsul onthevariablecalled totaleventhoughtheloop sbehaviorcan be precisely summarized in the consul dsl.
beyondlimitationsofthesolistoolchain thereare ofcourse also solidity loops that fundamentally cannot be expressed in consul.
we show three such examples in figure .
forinstance considerthefirstloopfromfigure7.atfirstglance theloopappearstodoa foldoverthearraycalled data.
however theexpressionontheright handsideincludessubtractionofthe iterator i which cannot be captured by any of the accumulator functions in consul.
the second loop in figure does not access a collection as most loops do see section but instead performs complicated arith metic operations on the two integers firstandlast.
however we intentionally did not try to capture such numeric summaries in the consul dsl because a such behavior is not as common and b there is already a rich literature of program analysis techniques for inferring numeric invariants e.g.
based on abstract interpretation constraintsolving craiginterpolation abduction etc.
.
the third loop in figure involves a conditional whose else branchcontainsanestedloop.whilethenestedloophasasummary thatisexpressibleinconsul andwhichcanalsobesynthesized by solis the behavior of the outer loop does not appear to be expressible in our summarization language.
result forrq3 there are two reasons why solis may fail to generate a useful loop summary.
one reason is due to the incomplete decomposition heuristic described in section .
.
another reason is the presence of complex arithmetic or nestedloopsthatresultinbehaviorthatisnoteasilyexpressible in the consul dsl.
.
threats to validity webelievetherearetwomajorthreatstothevalidityofourconclusions which we explain below.
benchmarkselection.
asmentionedearlier wewereabletoevaluatesolison1220ofthe22 685loopsconsideredinsection2dueto limitations of our implementation and time restrictions.
however webelievethatourbenchmarksarerepresentativeenoughinterms of both complexity and diversity.
validity of summaries.
as mentioned in section solis uses bounded verification when checking equivalence.
in theory this meansthatsomeofthesummariessynthesizedbysolismaynot actually be equivalent to the original loop.
however based on our manualinspectionofrandomlysampledsummaries wefindthat theloopssynthesizedbysolisareindeedequivalenttotheoriginal loop.
dslconstruction.
sincetheconstructsofconsulinfigure3are designedmanuallybyus theymaynotberepresentativeenoughto coverallofthecommonlooppatternsfoundinsolidity.tomitigatethisconcern ourdsldesignwasguidedbystaticanalysis semantic clustering and random sampling as detailed in section .
related work programanalysisforsmartcontractshasbeenanactiveresearch topicinrecentyears.inwhatfollows wesurveyrecentresearch on smart contract analysis as well as a few other topics relevant to this work.
program analyzers for smart contracts.
existing tools for vetting smart contracts are based on a variety of different approaches including symbolic execution abstract interpretation interactive theorem proving and testing .
to the best of our knowledge none of these existing techniques aimtoinferpreciseloopinvariantsthatcapturealoop ssideeffects oncontract state.thus existingtechniquesare eitherunsoundor grosslyimpreciseinthepresenceofloops ortheyrequiremanually provided invariants from the user.
we view this work as being complementary to existing efforts in the space of program analysis for smart contracts.
in particular our work brings clarity about the nature of loops that occur in smart contracts and takes a first step towards automatically inferring their semantics.
loopsummarization.
generallyspeaking loopsummarization referstothetaskofreplacingaloop lwithaloop freecodesnippet s e.g.
that over approximates the actual behavior of theloop .
loop summarization has been shown to be very helpful in program analysis both in the context of verification as well as symbolicexecution .loopsummarizationhasalsobeenshown tobeeffectiveforprogramoptimization.forexample theqbstool bycheungetal.improvesprogramperformancebysummarizing javaloopsusingsqlstatements .thisworkisparticularlyrelated to ours in that they take a program synthesis based approach towards loopsummarization however they perform synthesisusing constraint solving as opposed to type directed search.
moregenerally compared to all existing work on loop summarization the key contribution of this paper is to provide a formalism i.e.
domain specificlanguage thatcanbeusedtosummarizebehaviorsof solidity loops.
in addition we also take a first step towards loop summarization for smart contracts.
equivalencechecking.
checkingequivalencebetweenapairof programs is a classical relational verification problem and arises in many different contexts including translation validation differentialprogramanalysis andregressionverification .
generally speaking there are two different approaches to checking equivalence.
oneapproachis to construct a so calledproduct programpsuch that two programs p1andp2are equivalent if and onlyifpdoesnothavefailingassertions .analternative approachistoutilizeprogramlogics suchasrelationalhoarelogic that can be used to directly prove equivalence .
in this work we taketheformer approachand constructa verysimple product program through sequential composition.
this simple approach is sufficientinoursettingbecauseourequivalencecheckerisbased on bounded verification.
while more sophisticated product construction mechanisms may better facilitate unbounded verification ofsolidityprograms thisisanorthogonalproblemthatweleave to future work.
program synthesis.
this work is related to a long list of research papers on program synthesis in that we automatically synthesize a dsl program that satisfies the given specification in our case the original solidity loop .
while program synthesis is a very activeresearch area with a multitude of different techniques and applications our work is most similar to inductive synthesizersbasedonexplicitsearch .moreconcretely similar to prior efforts in this space our synthesis techniqueusestype basedreasoningtosignificantlyprunethesearch spacebut alsoutilizesbasicstatic analysisoftheoriginal loop to further reduce the space of candidate summaries.
conclusion and future work in this paper we performed a large scale investigation of loops foundinsoliditysmartcontracts includingboththeirsyntacticand semantic features.
based on these findings we proposed a dsl for capturing common behaviors of solidity loops and built a program synthesis toolchain called solis for automatic loop summarization in smart contracts.
our experiments indicate that at least of loopscanbesummarizedusingourproposeddsland81 ofthese summaries are equivalent to the original loop.
thereareseveraldirectionsforfuturework.first whilewehave takenafirststeptowardsloopsummarizationinsmartcontracts our proposed tool chain sacrifices completeness for better scalabil ity and therefore fails to generate summaries for larger loops even though an equivalent consul summary exists.
thus we plan to investigatebetterloopsummarizationtechniquesinfuturework.
second weareinterestedinintegratingourloopsummarization method with existing verification tools such as verisol to further automate the process of proving functional correctness of smart contracts.