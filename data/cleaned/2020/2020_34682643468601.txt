swarmbug debugging configuration bugs in swarm robotics chijung jung university of virginia charlottesville virginia usa cj5kd virginia.eduali ahad university of virginia charlottesville virginia usa aa5rn virginia.edujinho jung georgia institute of technology atlanta georgia usa jinho.jung gatech.edu sebastian elbaum university of virginia charlottesville virginia usa selbaum virginia.eduyonghwi kwon university of virginia charlottesville virginia usa yongkwon virginia.edu abstract swarm robotics collectively solve problems that are challenging for individual robots from environmental monitoring to entertainment.
the algorithms enabling swarms allow individual robots of the swarm to plan share and coordinate their trajectories and tasks to achieve a common goal.
such algorithms rely on a large number of configurable parameters that can be tailored to target particular scenarios.
this large configuration space the complexity of the algorithms and the dependencies with the robots setup and performance make debugging and fixing swarms configuration bugs extremely challenging.
this paper proposes swarmbug a swarm debugging system that automatically diagnoses and fixes buggy behaviors caused by misconfiguration.
the essence of swarmbug is the novel concept called the degree of causal contribution dcc which abstracts impacts of environment configurations e.g.
obstacles to the drones in a swarm via behavior causal analysis.
swarmbug automatically generates validates and ranks fixes for configuration bugs.
we evaluate swarmbug on four diverse swarm algorithms.
swarmbug successfully fixes four configuration bugs in the evaluated algorithms showing that it is generic and effective.
we also conduct a real world experiment with physical drones to show the swarmbug s fix is effective in the real world.
ccs concepts computer systems organization robotics software and its engineering development frameworks and environments .
keywords debugging configuration bug swarm robotics acm reference format chijung jung ali ahad jinho jung sebastian elbaum and yonghwi kwon.
.
swarmbug debugging configuration bugs in swarm robotics.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
athens greece.
acm new york ny usa pages.
introduction in robotics a swarm is a group of cooperative robots that is able to solve complex tasks through their collective behavior .
swarms are being used to solve many real world problems from environmental monitoring and emergency response to entertainment .
key enablers of such success are the algorithms that allow the individual robots of the swarm to plan share and coordinate their trajectories and tasks to achieve a common goal .
despite the potential of swarms developing robust swarm algorithms is challenging.
swarm algorithms are dependent on a large number of related parameters and inputs that can significantly change the behavior of the swarms.
the swarm algorithm controls multiple robots adding an order of magnitude in complexity to a large number of parameters used to configure each robot e.g.
arducopter has hundreds of configuration parameters .
swarm operations are highly dynamic compounding the variability and sensitivity of all its robots to the environment.
swarm algorithms have variables and code blocks that are highly inter dependent.
the algorithms are often a closed loop feedback control system which continuously computes robots new states using new inputs and their previous states.
in our conversation with developers of swarm algorithms and observation from public forums one of the common challenges in swarm algorithms and robotics development is to find appropriate values for configurable parameters.
a slightly misconfigured parameter can cause a buggy behavior which we callconfiguration bugs .
this paper focuses on configuration bugs in swarm algorithms i.e.
bugs caused by misconfiguration of the algorithms and robots causing incorrect swarm states such as crashing drones in a particular deployment scenario.
space of all possible scenarios a successful scenario ssucc with corg scenarios covered by corg2 a failed scenario sfail with corg3 a new configuration cfixcovering the failed scenario sfail swarmbug1 corgcfix figure illustration of a configuration bug and swarmbug .
esec fse august athens greece chijung jung ali ahad jinho jung sebastian elbaum and yonghwi kwon configuration bugs.
figure illustrates a high level concept of the configuration bug and the swarmbug s ultimate objective.
given the space of all possible scenarios sall of a swarm there is a configuration for the swarm corg that can result in a successful scenario ssucc denoted by .2denotes scenarios that can be successfully covered by corg.
a configuration bug happens when a swarm operates under a new scenario resulting in a failure sfail because it is not covered by corg.
challenges.
a typical debugging approach for a configuration bug might be tracking each parameter s value propagation to the robot s decision that caused a faulty scenario.
unfortunately the aforementioned complexity of swarm algorithms makes this approach impractical.
for example parameters often go through a number of complex computations with other variables including matrix multiplications.
precisely tracking a variable s impact after those computations is an extremely challenging task.
another typical approach is trial and error.
a developer inspects a particular variable s value modifies its value and tests whether it will fix the bug.
the debugging process typically requires non trivial manual effort due to many configurable parameters and complex dependencies.
without proper guidance on each trial and error this approach is rather impractical.
moreover even after the developer identifies a potential fix i.e.
a new value for a configurable parameter testing the fix in various scenarios is time consuming and challenging due to the large space of possible swarm behaviors.
our approach.
this paper proposes swarmbug a swarm debugging approach for configuration bugs.
as illustrated in figure it aims to find a new configuration which we call a fix cfixthat can cover more scenarios .
while not guaranteed swarmbug prioritizes cfixthat are close to the corg which can potentially cover some of the scenarios already covered by corg as per the overlapping area of 2and .
in particular swarmbug targets bugs that are caused by misconfiguration of the swarm algorithm or robot s parameters i.e.
configuration variables .
it aims to find key variables that caused a buggy behavior identify possible fixes for the bug via systematic testing and rank the fixes that preserve the behavior of the original execution.
swarmbug s key enabling technique is the novel concept of the degree of causal contribution dcc .
it creates alternative executions with and without critical factors e.g.
objects that affect the swarm s behavior to understand which factors are causally contributing to the buggy behavior.
swarmbug then finds variables that can configure swarm algorithms to adjust the dcc of the factors.
the contributions of this research are as follows we develop a swarm robotics debugger for configuration bugs.
we propose the concept of dcc to understand the degree of causal contribution of each variable to swarm behavior and use it to precisely pinpoint critical variables that contribute to bugs.
we evaluate our algorithm on real world swarm algorithms and automatically identified valid bug fixes including physical flight experiments with real world drones to empirically show that the generated fixes are effective in real world scenarios.
we have communicated and confirmed all the configuration bugs and our fixes with the authors of the swarm algorithms.
we publicly release the source code and data of swarmbug on .
motivating example we use the adaptive swarm algorithm to illustrate swarmbug s operation.
we run the algorithm for four drones one leader and three follower drones f1 f3 .
the algorithm s goal is to safely move the swarm to a destination while maintaining a diamondshape formation as shown in figure a .
the arrows with borders either blue or gray indicate the drone s flight direction.
orange arrows are the vectors caused to avoid obstacles including other drones .
gray arrows represent the vector to maintain the diamond formation.
when there are multiple vectors considered the blue arrows with borders indicate the final flight directions.
configuration variables.
in this example there are two types of configuration variables environment and swarm configuration variables.
environment configuration variables represent objects such as robots and obstacles e.g.
followers .sp self.sp.x and obstacle in figure .
swarm configuration variables are parameters for swarm algorithm and robots.
for example circles surrounding drones visualize a parameter infl radius that determines the maximum sensing distance for objects.
interrbt dist is another parameter that represents the desired distance between drones.
configuration bug.
figure b e show such a scenario where f3 crashes with an obstacle due to a configuration bug .
first the moving obstacle approaches f1 which is also moving in b and makes f1 move towards the south west leading f1 to get close to f3.
in c the obstacle forces f1 and f3 closer.
in d the obstacle approaches now f3 which fails to avoid it because the other four forces come into play three forces to avoid f1 f2 and obstacles oranges and the force to maintain the formation.
this causes f3 to move just slightly from its current position not enough to avoid the obstacle leading to a crash in e .
a cause for the failure is that in d f3 was too close to adjacent drones which interfere with the decision of f3 to avoid the obstacle.
debugging attempts without swarmbug .a typical debugging approach of the given bug is to trace the value propagation from the obstacle i.e.
the cause of the crash to the drone to understand how the obstacle and other variables affect the drone s faulty decision.
for example one may use existing program analysis techniques such as taint analysis to trace obstacle which is an environment configuration variable defined as a global variable representing the obstacle.
each drone in the swarm reads this variable to determine whether they are close to the moving obstacle or not.
however tracking the value propagation of the variable is challenging as it goes through complex computations.
figure shows a simplified value propagation graph.
the arrows in figure show the data propagation paths.
the source variable obstacle is a array and the values of its elements along with other variables including followers .sp andfollowers .sp representing other drones are used to generate each element of a array d2.
later each element of d2is used to create another array repulsive with infl radius andnu.
then each element of repulsive andattractive are added to create total a array .
finally it computes a gradient of the matrix to create gxandgy.
finally mean values of the gx and gy arrays to compute x self.sp.x and y self.sp.y coordinates.
at this point which part of bytes of the x and y coordinates are affected by the source variable obstacle is challenging to know.
using taint 869swarmbug debugging configuration bugs in swarm robotics esec fse august athens greece leaderf1 f2f3 flight configuration f1 detects the obstacle obstacle f1 approaches to f3 f1 avoids the obstacle f3 avoids the obstacle leaderf1 f2f3 a flight configuration b f1 detects the obstacle c f1 approaches to f3 d interference from f1 and f2 slows down f3 e f3 crashes with the obstacleobstacle infl radius .
m infl radius .
m interrbt dist .
m interrbt dist .
m original configuration buggy fixed configuration by swarmbug figure swarm of four drones crashing an obstacle a e .
the same swarm mission with a fix by swarmbug .
analysis would tell that every part of both coordinates depends on the source variable and other variables which are not useful for debugging the configuration bug.
note that the graph is simplified.
the complete graph of the swarm algorithm is at least times larger than figure .
a backward edge from the self.sp.x andself.sp.y tofollowers .sp andfollowers .sp that forms cycles are omitted.
debugging with swarmbug .swarmbug conducts a behavior causal analysis to find out environment configuration variables that caused the bug obtains bug fixes by mutating swarm configuration variables and ranks fixes that preserve the original behavior of the swarm.
cause analysis given a definition of configuration variables provided by a user swarmbug infers which configuration variables significantly contribute to the buggy behavior by leveraging a concept we call the degree of causal contribution ordcc details in section .
.
.
dcc essentially abstracts the impact or contribution of individual variables to a robot s decision.
dccis computed as follows.
given the original execution demonstrating the crash swarmbug creates alternative executions by removing the impact of environment configuration variables that are essentially related to surrounding objects and robots .
then we compare the robots behaviors of the original execution and d2 ...obstacle followers .sp followers .sp ...repuls ive infl radius nu ...total ...attractive ...gx and gy self.sp.x self.sp.y each box repres ents a variable or an elem ent of an array figure illustration of simplified value propagation.the alternative executions.
the difference of the robots poses becomes a dcc value.
finally we analyze the trends of dcc values around the time when the bug occurred to pinpoint the cause of the bug e.g.
whether some variable s contribution is insufficient or excessive .
note that swarmbug does not rely on tracking complex propagations of values which existing techniques struggle to do but rather analyzes values related to the robots behavior as the environment is changed.
in the earlier example swarmbug derives alternative executions without each obstacle by mutating environment configuration variables to infer the causal relationship between an obstacle and the buggy behavior.
then we compare each drone s poses observed during the generated alternative executions and the original execution obtaining the difference that represents the impact of each removed obstacle to the buggy behavior.
to this end swarmbug identifies the most impactful variable obstacles a moving obstacle .
finding potential configuration fixes from the environment configuration variable that contributes to the bug swarmbug conducts a number of experiments that change each swarm configuration variable s value e.g.
a robot s parameter s value to identify potential fixes for the bug.
specifically it focuses on the trend of dcc values of the environment configuration variable.
for example we earlier noticed that the obstacle s contribution becomes more significant near the crash while other objects e.g.
other drones also compete for the contribution.
to this end swarmbug tries to reinforce or intensify the increasing trend of the moving obstacle s dcc value.
with the change we expect the drone to take the obstacle into account more significantly than the original execution.
we then run multiple executions with mutated swarm configuration variables e.g.
increasing decreasing their values to find mutations that can reinforce the trend.
finally we find concrete values for two swarm configuration variables defined as global variables leading to two configuration fixes i infl radius .
and ii interrbt dist .
.
validating the robustness of fixes swarmbug tests the two fixes i.e.
infl radius andinterrbt dist exhaustively by running a number of tests with diverse scenarios that swarmbug derived by profiling the variation of the target scenario e.g.
spawning the 870esec fse august athens greece chijung jung ali ahad jinho jung sebastian elbaum and yonghwi kwon swarm in various positions .
to make each test more meaningful in terms of validating the robustness swarmbug measures whether each run exercises observable new swarm behaviors using dcc values.
specifically for each test we collect dccvalues and compute mse scores against previous executions dcc values.
the testing is repeated until it does not observe new swarm behaviors e.g.
mse scores of consecutive executions are all smaller than .
or reached a predefined timeout e.g.
hours .
in this example both fixes successfully pass the testing meaning that swarmbug did not observe any failures after hours of testing while the fixes with infl radius andinterrbt dist successfully finishes and tests respectively.
hence both are considered as valid fixes.
finding behavior preserving fixes some fixes may disruptively change the swarm behavior.
for instance in our example changing interrbt dist results in a bigger diamond formation making the swarm look and behave quite differently.
to avoid such fixes swarmbug aims to identify a behavior preserving fix which behaves similar to the original swarm.
specifically we compare the dcc values from a fixed execution and the original execution to measure the differences between the two executions.
if two swarm executions have similar dcc values we consider that their behaviors are similar.
in our example the dcc values from the fix with infl radius is more similar to the dcc values from the original run than the fix with interrbt dist .
chosen fix figure show the flight with the infl radius fix.
it maintains the same formation while individual drone detects and avoids the obstacle earlier preventing the situation where multiple drones get too close .
all the drones including f3 avoid the obstacle successfully .
backgrounds goals and scope .
mobile robot software configurable variables.
a typical robot such as the drones we use in our studies can have hundreds of configurable parameters and each of the parameters can affect the robot s behavior significantly.
a robot s decision making process is typically implemented as a sequence of program statements that continuously and iteratively reads inputs from various sensors and computes the robot s next state meaning that it is essentially a closed loop system .
during the computation the configurable parameters are also taken into account.
as shown in figure variables in the algorithms are highly inter dependent e.g.
most variables in the loop are dependent on their previous iteration s values making it difficult to apply data dependency analysis techniques.
field testing and simulation based testing.
testing robotics algorithms is challenging because robots interact with the physical surroundings.
while testing robots in the real world field testing or physical testing is desirable and ultimately required it is expensive and dangerous due to the cost of failures.
as a result simulationbased testing is a common alternative that can reduce development and validation costs.
still given the dimension and complexity of the real world simulation testing must identify what scenarios are worth validating and attempt to reduce the exploration of equivalent scenarios that render little value for testing.
.
swarm algorithms centralized and distributed swarm algorithms.
there are two main lines in constructing swarm algorithms centralized and distributed.
a centralized algorithm computes all the decisions of individual robots in a swarm in a centralized system.
on the other extreme a distributed swarm algorithm runs the majority of the algorithm on individual robots where robots are communicating via network channels.
existing approaches such as taint analysis have difficulty handling distributed algorithms while swarmbug works well on both centralized and distributed algorithms.
local vs global goals.
swarm algorithms may have global goals for the entire swarm and local goals for individual robots at the same time leading to conflicting goals .
for instance each robot may have a local algorithm to avoid obstacles while a swarm algorithm aims to maintain a specific formation during the flight.
when a robot in the swarm encounters an obstacle the robot s local algorithm may hold back the swarm algorithm s progress as it prioritizes its local goal i.e.
avoiding the obstacle .
note that even if a swarm algorithm includes logic to balance the two goals e.g.
prioritizing local and global goals based on the current state and environment the balancing logic may not be perfect failing to balance the conflicting goals.
complex dependencies.
as a swarm consists of multiple robots the complexity of dependencies among variables and configurations has significantly increased compared to that of a single robot.
during our experiments we observe that the average number of data dependencies i.e.
the number of edges in the data dependence graph in drone swarm algorithms is n where nrepresents the number of robots.1when n the number is approximately .
times the average number of dependencies of algorithms for a single drone which is with n the swarm algorithms dependencies are .
times bigger than the single drone algorithms .
it means that applying the data dependency analysis to swarm algorithms is ineffective in practice.
dynamic behaviors.
in a swarm individual robots dynamic behaviors are often accumulated and amplified leading to even more diverse swarm behaviors.
for example in our motivation example figure c and d have a chain reaction to the obstacle which is different from when an individual drone interacts with an obstacle.
hence a significant challenge in swarm testing is obtaining test cases that can effectively cover various swarm behaviors and prioritizing test cases to cover diverse scenarios.
.
goals and scope goals of swarmbug .swarmbug aims to achieve the three major goals to effectively debug swarm algorithms as follows.
goal developing effective causal analysis capabilities for swarm algorithms to automatically identify root causes of configuration bugs and find fixes.
goal developing an effective and efficient testing approach to validate bug fixes for swarm algorithms by systematically covering various corner cases.
1as for and we use the data dependency graph using sourcetrail withtas the total edges of the swarm algorithm and las the number of edges for an individual drone algorithm.
is the average of the difference between tandl and is the average of lof all drones.
871swarmbug debugging configuration bugs in swarm robotics esec fse august athens greece swarm algorithm and a swarm mission behavior causal analysis section .
fix candidates fix validation testing section .
fix prioritization section .
successful fixes swarmbug ...fixes sorted by preserved behavior configuration fixes for swarm configuration definitions real world testing test cases and traces figure overview of swarmbug goal understanding the impact of fixes and guiding how to choose fixes that preserve the original swarm algorithm s behavior while correcting buggy behaviors.
focus on unmanned air vehicles drones .
while our findings and insights are generic and applicable to various swarm robotics environments our research focuses on swarm robotics algorithms for unmanned aerial vehicles.
this is because they are prevalent and used in various missions and they have one of the most sophisticated dynamics leading to various challenges in debugging.
generality of swarmbug s fix.
swarmbug generates fixes for a bug under a particular mission and algorithm s configuration.
this means that the fixes may not work for a significantly different mission or scenario.
for instance a bug fix for a swarm mission with four drones may not work for a mission with eight drones.
also a bug fix for a swarm avoiding obstacles may not work if the obstacles speed changes e.g.
become faster .
design figure shows the overall procedure of swarmbug .
it takes three inputs a swarm algorithm s source code a swarm mission that triggers a buggy behavior and configuration definitions that include a list of configuration variables for the swarm and environment e.g.
certain obstacles wind etc.
.
swarmbug conducts a behavior causal analysis section .
to find causes of buggy behaviors from environment configuration variables and generate fixes for swarm configuration variables.
then swarmbug validates the fixes under various scenarios section .
to obtain robust fixes.
further it ranks the fixes based on the behavior similarity between the original swarm and the fixed swarm section .
.
finally while it is not part of our main contribution the test cases and traces can be used to conduct real world testing as shown in section .
.
.
.
behavior causal analysis .
.
configuration variables.
among the variables in a swarm algorithm there are two types of variables that are important in understanding and controlling behavior environment and swarm configuration variables.
one of the swarmbug s inputs is the configuration definitions a list of configuration variables with each variable s type either environment or swarm configuration and the value specification.
.environment configuration variables define the environment of the swarm that can be manipulated during simulation such as obstacles robots and wind.
the value specification includes a value to eliminate the impact of the variable.
forinstance if an obstacle is defined as a set of coordinates coordinate values outside of the map will effectively remove the obstacle.
we use the symbol to represent such a value.
.swarm configuration variables typically define parameters of drones and swarm algorithms.
the specification includes the range of values i.e.
minimum and maximum values distribution .
for instance the maximum drone velocity or the minimum distances between drones in a swarm.
profiling for the configuration definitions.
swarmbug expects a user to provide the configuration definitions2 which may require non trivial effort.
to mitigate this we present a set of profiling tools and supporting approaches on our project website that can generate sketches of such configuration definitions for implementations like the ones we present later in our study to reduce such effort.
.
.
degree of causal contribution dcc .our analysis targets environment configuration variables that represent obstacles and other robots because they directly affect the swarm behavior and are crucial in understanding causes of bugs.
a key innovation of swarmbug is the concept of the degree of causal contribution or dcc of a variable to a robot s pose and propose its computation without relying on complex data propagation analysis techniques such as taint analysis.
dcc is computed by comparing differences between executions with mutations applied on the environment configuration variables.
direction to the next position with the obstaclelegend delta obstacle direction to the next position without the obstacle b alternative execution a original execution c delta computationd1 d2 d3d1d2 d3d1direction of the obstacle figure example of computing a delta value.
computing delta via alternative execution.
to understand the contribution of an environment variable we first create a new alternative execution with a mutation on the variable that can essentially remove the variable s presence in the environment.
since the new execution negates the existence of the mutated variable we call the new execution alternative execution .
figure shows an example.
suppose that figure a shows an original execution that includes an obstacle leading to the drone moving toward the 2details of the configuration definitions and the real input file we use in this paper can be found on 872esec fse august athens greece chijung jung ali ahad jinho jung sebastian elbaum and yonghwi kwon algorithm computing dcc from the delta values input m a set of missions for robots.
mr mis a mission for robot r te the tick value of when the swarm mission finishes.
vec a set of environment configuration variables.
output dcc r t a set of tuples vec n wherevecis an environment configuration variable and nis the dcc value ofvwat tick tfor robot r 1procedure computeswarmdcc m vw t while t tedo formr mdo dcc r t computerobotdcc mr vec t t t time step time step represents a single tick 7procedure computerobotdcc r vec t total porg getrobotpose r vec t obtain a pose of ratt each source variable virepresenting a world object forvi vecdo tmp vi savevi vi removing the impact of an environment configuration variable vi pi getrobotpose r vec t obtain a pose of rattwithoutvi i porg pi forvivia euclidean distance total total i vi tmp restorevi dccset forvi vecdo dccset dccset vi i total return dccset south west from d1tod2 .
a counterfactual execution is shown in figure b without the obstacle.
the drone moves toward the south from d1tod3 .
as shown in figure c we obtain a delta by computing the euclidean distance between drones poses d2 andd3 from the two executions.
computing dcc.the degree of causal contribution or dcc is an aggregation of the delta values of environment configuration variables.
specifically we obtain values of all environment configuration variables.
then we compute the percentages for each variable resulting in dcc.
algorithm shows the details of dcc computation.
given a swarm algorithm it iterates over all the robots in the swarm and calls computerobotdcc for every tick to obtain all dcc values in the given mission m lines .
then it obtains the robot s pose i.e.
coordinate in the original mission at the given tick tby calling getrobotpose and stores the results to porgat line .
we remove each environment configuration variable s impact i.e.
vi by assigning tovi.
next we obtain a new robot s pose line without the object vi and store it to pi.
we compute delta iby calculating euclidean distance between porgandpi line .
we modify vi s value on each iteration to remove the object line and restore it line .
finally we construct a set of proportions of individual variables deltas line .
.
.
temporal analysis.
we analyze how dcc values change over time i.e.
trend to identify the causes of a bug.
time window for temporal analysis.
robots typically have some lag in recognizing and reacting to changes in their surroundings.
we call such time duration twin or time window for temporal analysis and focus on the trend of dcc values within the window.
note that different swarm algorithms may have different time windows so test missions are typically provided by the developers or can be obtained with slight changes of their configuration.
then we identify when the current dccvalue is changed more than thanits previous tick s dcc value i.e.
dcc value is rapidly changing .
note that the threshold is configurable3.if such rapid changes are observed we record how long the changing trend lasts.
we calculate the average time they last and use it for the time window twin.
in this paper we measured twinvalues of .
ticks ticks ticks and ticks for adaptive swarm swarmlab fly by logic and howard s respectively.
167dcc leader follower follower obstacle obstacle obstacle 3legend twinoriginal decreasing reinforced decreasing inverted increasing original increasing balanced stable dcc time sec 0original stable imbalanced decreasing infl radius .
a original nu .
infl radius .
b reinforcing infl radius .
c inverting time sec nu .
e balancing xi .
xi .
d imbalancing figure examples of dccvalue trends and fixing strategies.
fixing strategies based on dcctrends.
with the identified twin we try to identify a temporal trend of dcc values within a family of predefined templates as shown in figure that reflect our experience in practice.
then we apply a set of predefined fixing strategies depending on the matching temporal trend template.
from the time that it causes a buggy behavior tbug the time window for our temporal analysis starts at tbug twin and ends at tbug as shown in figure .
then we apply the following four strategies.
.reinforcing.
if the trend of dcc values is either increasing or decreasing we try to reinforce the trend i.e.
increasing or decreasing more .
figure a shows an example of a decreasing trend of dcc values.
figure b is a fix obtained by changing the value of infl radius a swarm configuration variable that represents the maximum sensing distance for objects to .
from .
the original value shown in figure a .
.inverting.
ifdcc values are increasing decreasing we generate a fix to invert i.e.
decrease increase the trend of dcc values respectively.
for example figure c inverts the trend of dccvalues from figure a by changing the value of infl radius to .
from .
.
this strategy is effective when a swarm overlooks an essential factor and focuses on trivial inputs.
it would invert the focus so that the essential factor can be considered.
.imbalancing.
if adcc value of the variable does not have noticeable changes we try to introduce changes that can lead to different swarm behavior.
we first try to imbalance i.e.
either increase or decrease the dcc values.
for example figure d introduces a decreasing trend by changing the value of xi a swarm configuration variable to from .
xirepresents the non leader robot s tendency of following the leader drone.
reducing this value allows robots to focus on other surroundings.
.balancing.
swarm algorithms may fail because they accidentally take some inputs into the computation more or less than they should be.
this strategy will try to reduce the impact of 3the optimal for each algorithm can be profiled.
details can be found in .
we profile the four algorithms we evaluated and find that works for all of them.
873swarmbug debugging configuration bugs in swarm robotics esec fse august athens greece overly prioritized objects in algorithms.
for example figure e changes the value of nufrom .
to .
.
nuswarm configuration variable representing the priority of avoiding obstacles over other goals e.g.
following the leader .
the fix prevents the drone from being overly considering the leader.
.
fix validation .
.
profiling spatial variations.
it is common to observe a swarm behaves differently between each test.
a robust fix should be tested under such diverse behaviors.
to understand the variation of a given swarm algorithm we profile the drone s poses from tests.
aligning spatial coordinates.
spatial coordinates of the swarm can vary across the test runs.
for example two relatively identical flights can have different coordinates if the entire swarm s poses are shifted.
to identify the variation of drones poses in the swarm it is necessary to align the drones poses based on common coordinate system.
specifically we set the spatial coordinates of the swarm on the drone that caused a bug e.g.
a crash .
other objects including other drones and obstacles are referenced accordingly.
computing spatial variations.
we run nsets of tests where each set includes ntests n 10in this paper until we reach a fixed point of the spatial variation.
we measure the spatial variation of the drones poses from all the test runs on each test set.
for measuring the spatial variation sv we leverage the concept of circular spherical error probable cep sep to identify the area that can include of coordinates from the total tests.
on the ithtest set we measure the spatial variation of the drones poses svi from all the test runs executed at this point i 10tests .
we repeat the process until we observe svi 1andsvido not differ more than .
in general we reach the fixed point with test sets meaning that we run tests in total.
details can be found on .
to this end we obtain a map called svmap spatial variation map that shows the aligned spatial variations of individual robots and objects.
figure shows an example svmapobtained from adaptive swarm .
in the map observed robots are presented as points.
solid contour lines indicate areas that are estimated as the same density.
the contour lines represent areas that contain the sample s population from to where the outmost area includes and each inner area has less population.
leader follower follower follower 3legend obstaclefollower follower follower 3leader flight direction of the swarm figure spatial variation map svmap .
.
feedback driven fuzzing.
we validate the generated fixes by testing them under various scenarios.
we use svmap which represents the spatial variation of the swarm under test.
we aim to spawn robots and obstacles within the regions shown svmap.
initially we spawn them in inner layers more than outer layers because more drones were observed there during the profiling .
during the tests we record dcc values.
if the dcc values of thecurrent test differ by more than from all the previously observed dcc values we consider the test covered some new swarm behaviors hence a meaningful test covering a new scenario.
in this case we prioritize creating new tests that are similar to the current one.
if the dcc values from the current testing are similar to dcc values from previous tests we prioritize the other layers.
note that we essentially use dcc values as feedback representing the behavior of the swarm.
if we tried all the layers and cannot find new dcc values that are more than different from the previous tests we extend the layers to cover larger spaces.
the process terminates when the test fails e.g.
robots crashing to obstacles or walls or reaches a predefined timeout.
if we reach the timeout without a failure we consider the fix is valid.
during the testing if we observe any crashes or runs that fail to reach the original goal we consider them unsuccessful runs and the corresponding fixes are discarded.
.
fix prioritization the fixes by swarmbug may affect different aspects of the swarm behavior in an undesirable way.
for example a fix may resolve a crash by changing the swarm s formation significantly increasing the distances between drones .
in such a case the swarm with the fix may look very different from the original one.
to this end we rank the fixes by how much they preserve the original algorithm s behavior.
specifically for each fix we compare dcc values from the swarm with the original configuration and fixed configuration.
then we rank the fixes with smaller differences higher because they preserve the original behavior of the swarm more than those with larger differences in dcc values.
in many cases a higher quality fix does not significantly change the swarm s behavior while eliminating the fault bug.
note that we essentially usedcc to approximate the swarm behavior.
171dcc time sec a original execution s dcc c dccof mse .
b dccof mse .
leader follower follower obstacle obstacle obstacle 3legend158 figure example mse scores measuring distances of dcc values.
to compare dcc values from different runs we leverage the mean squared error mse .
figure a shows dcc values from the original execution and figure b and c are dcc values from executions with two different fixes.
we rank the one with a smaller mse value .
higher than the other with mse value .
.
note that we make them have the same length using interpolation i.e.
applying linear interpolation to the shorter sequence then calculate the mse to handle dcc values of different time periods.
evaluation implementation.
we prototype two versions of swarmbug to support four swarm algorithms.
one in python lines to support adaptive swarm and another one in matlab lines 874esec fse august athens greece chijung jung ali ahad jinho jung sebastian elbaum and yonghwi kwon to support swarmlab fly by logic and howard s .
we also modified existing simulators emulators.
our analysis for svmap section .
is written in r lines .
environment setup.
we performed our evaluation on an intel i79700k .6ghz and 16gb ram and bit linux ubuntu .
.
for the real world experiment in section .
.
we use six crazyflies .
table selected algorithms for evaluation name sloc drones objective adaptive swarm flight avoiding static dynamic obst.
swarmlab flight avoiding static obstacle fly by logic optimizing path avoiding unsafe zone howard s flight avoiding static obstacle swarm algorithms.
as shown in table we use four representative and diverse swarm algorithms.
to select the four algorithms we search total swarm related research papers with open sourced algorithms and public github repositories related to swarm robotics from to .
among these came with runnable code from which we pruned out that were just off line planning algorithms not reactive to the environment and algorithms that did not exhibit collective behaviors e.g.
collections of individual drones without cooperative interactions .
finally we end up with the selected four swarm algorithms.
details can be found in .
note that while there are many swarm algorithm papers the viable implementations are limited.
we found that many repositories do not include the full implementations to support the swarm or do not release enough details for usage .
others just include rudimentary implementations that do not provide basic swarm functionality or testing environments e.g.
maintaining formation avoiding obstacles .
table shows the sloc source line of code of algorithms and the number of drones we used for the evaluation.
we use drones for all the algorithms except for the fly by logic as it does not support a swarm with up to drones.
the last column briefly describes the objective of each algorithm.
among the four algorithms adaptive swarm is the only algorithm that enforces a particular formation during the mission.
swarmlab tries to match the speed with other robots during the mission while the other three algorithms consider other robots as an object to avoid.
swarmlab implements two swarm algorithms olfati saber s and vicsek s .
we use olfati saber s algorithm because vicsek s algorithm has a bug all the robots are disappearing after a mission starts .
.
effectiveness buggy behaviors.
during the evaluation we aim to fix four bug classes as shown in figure by using swarmbug a a drone fails to avoid a moving obstacle in adaptive swarm leading to a crash b drones fail to avoid the second static obstacles they encounter crashing to the pillar structure which is a round shape object in the figure c the first drone fails to avoid the unsafe zone represented as the red cube that the algorithm aims to go around and d a drone the green sphere crashes into an obstacle the red sphere .
.
.
behavior causal analysis.
table shows the result of swarmbug s causal analysis.
trend shows the identified trends of dcc values as described in section .
.
.
note that the variable name is c fly by logic a adaptive swarm d howard s goal goal goalgoal b swarmlab legend flight direction of the swarm crash point goal of the mission goal crashed into unsafe zone figure buggy behaviors in the four selected algorithms the one that dominates the dcc values.
strategies shows all the fixing strategies applied.
swarm configuration shows the swarm configuration variables and their initial values we mutate to apply the fixing strategy e.g.
reinforcing or inverting the trend of dcc values .
to achieve a target dcc trend swarmbug tries both increasing the value by two times and decreasing the value by and chooses one that achieves the target dcc trend.
note that we omit several swarm configuration variables4that could not lead to any fixing strategies.
also some strategies cannot be done by mutating a particular environment variable e.g.
mutating drone vel does not reinforce the trend in the adaptive swarm s case .
in such a case we consider the strategy is not applicable and mark it as reve.
also there are some cases where the strategies are well achieved while the resulting execution always crashes.
to check such a case we run runs for sanitization purposes.
those that fail to pass the sanitization test e.g.
drones crashing into other objects drones are marked as .
all successfully applied strategies are annotated by .
it does not include the imbalancing strategy which requires thedcc trends to be balanced while all the observed dcc trends are decreasing.
.
.
testing fixes.
profiling presents the results of tests we run for spatial variation profiling section .
.
.
it took approximately .
for adaptive swarm .
for swarmlab .
for fly by logic and .
for howard s hours for run tests.
note that they are naive testing runs where swarmbug further conducts fuzz testings shown in the fuzzing column guided by mse scores ofdccvalues.
in general our fuzz testing finds more crashes lower rates of successful runs than the naive profiling tests meaning that it is effective in discovering more diverse testing scenarios.
swarmbug initially generates for adaptive swarm for swarmlab for fly by logic and for howard s fixes.
gray cells represent fixes that do not fail any tests during the profiling step.
fuzzing shows the number of successful tests during the fuzz testing out of hours for adaptive swarm and swarmlab hours for fly by logic and howard s. gray cells mean the fixes that 4in table we omit swarm configuration variables from swarmlab fly by logic and howard s respectively.
875swarmbug debugging configuration bugs in swarm robotics esec fse august athens greece table effectiveness of swarmbug algorithmbehavior causal analysis fix validation fix prioritization dev.
trendstrategies profiling1fuzzing3mse score rank cfm.
swarm configuration reinforcing inverting r2in2reinforcing inverting r2in2 w .
.
.
xi .
.
.
.
adaptive decreasing nu .4e .4e .12e .
swarm robot1.sp int dist .
.
.
.
infl radius .
.
.
.
drone vel .
reve .
.
c vm .
.
b .
.
reve swarmlab decreasing r0 .
.
reve .
p swarm.u ref c pm obs .
reve .
d ref .
reve .
v ref .
.
reve .
fly by logic decreasing max vel .
.
reve .
obs max accl .
.
reve .
c .
.
.
.
howard s decreasing dist thresh .
.
reve wypt obst pot c4 .
.
.
.
data in profiling column indicates the number of successful mission for tests.
r and in indicate reinforcing and inverting respectively.
data in fuzzing column indicates the number of successful mission over the number of fuzz testing in given time and success rate.
the program has hardcoded constants instead of variables.
we assign a conceptual name to them.
checkbox in this column indicates whether the bugs and fixes are confirmed by developers or not.
are most successful e.g.
more than of them are successful .
we run adaptive swarm and swarmlab longer than the other two because a single run from the first two algorithms is much slower than the other two.
.
.
fix prioritization.
as explained in section .
we obtain mse scores of the fixes and rank them according to the scores.
the most promising fixes are ranked the first in all cases.
two fixes are ranked second xiandv ref in adaptive swarm and swarmlab respectively.
our manual inspection shows that they are still valid fixes while they are ineffective compared to the fix ranked first.
however nuin adaptive swarm which is ranked third shows abnormal behavior it often makes robots stall or even move backward when they recognize obstacles even if the obstacles are quite far away from them .
our manual inspection reveals that the fix prioritizes avoiding obstacles significantly more than other goals.
confirmation from the algorithm authors.
throughout our research project we have communicated with the authors of all four swarm algorithms regarding the configuration bugs we find.
the bugs and fixes for the three algorithms are confirmed and acknowledged by the authors.
the authors also agreed that the higher ranked fixes are better than those that are lower ranked.
.
case study .
.
real world experiment of a fix from swarmbug .to show that a fix generated and validated by swarmbug is effective in real world environment e.g.
with various noises we conduct a physical experiment that uses the fixed configuration nu of adaptive swarm to reproduce the same flight.
setup and presentation.
we use crazyflies and leverage crazyswarm as a controller for swarming.
we use a local position system called lps supported by crazyflies to precisely locate drones 3d positions in space.
we conduct the experiments in the lab environment where the space is 3m 4m 3m in width length height .
we use the same trajectory which includes drones poses from the adaptive swarm mission shown in figure a .
figure illustrates the results.
drones start from the rightbottom side of the map marked as start and move toward the left marked as goal while avoiding obstacles.
there is an lshape static obstacle which we use two white boxes in our physicalexperiment.
moving obstacle i.e.
red symbol is approaching the drones from the left to right direction in the upper side of the map.
thick lines are trajectories computed by swarm algorithms and thin lines with jitters are the traces of the real physical drones movements from the motion capture system .
the physical aerodynamics and noise may have caused these variations i.e.
jitters .
along the trajectories we visualize instances of drones at two different time ticks.
circled letters represent drones where l means the leader and a e means follower .
the symbol is followed by a number that represents the time tick of the instances.
for instance l1 and a1 e1 represent the drones positions at the time tick while l2 and a2 e2 are positions of the same drones at the time tick .
the red transparent lines between drones visualize a group of drones at the same time tick.
result.
figure a shows partial traces of the drones using swarmbug s fix infl radius .
from the original value .
which safely finishes the mission without crashing.
figure b shows a picture of the physical experiment while safely passing the obstacle the box behind the drones .
with the swarmbug s fix drones maintain a sufficient safe distance.
a video of this physical experiment is available on .
finding a fix without swarmbug .to provide a comparison point for the quality of the fix generated by swarmbug we conduct a small additional experiment that tries to come up with a fix by manually changing the parameters without swarmbug .
first of all it would take a lot of time to pick the right configuration variable for the fix i.e.
infl radius without any guidances such as dcc and mse values used in swarmbug .
even if we assume that the desired variable infl radius is chosen finding a good value for the fix is difficult.
assume that .
is chosen the original value is .
.
the fix is tested by running the simulations times that are all successfully finished without any crashes.
to this end we run a physical experiment with the fix as shown in figure c .
observe that follower b2 and follower c2 crash each other meaning that while it passes the naive testing times the fix is not effective in real world scenarios.
.
.
debugging a ground vehicle swarm.
in this case study we show how swarmbug is used to debug a ground vehicle swarm algorithm s configuration bug.
we use a swarm algorithm 876esec fse august athens greece chijung jung ali ahad jinho jung sebastian elbaum and yonghwi kwon c trajectories na ve fix startobstacle crashed drones b2c2e2moving obstacle d picture from the physical experiment of c obstacle start a trajectories s warmbug fix b picture from the physical experiment of a moving obstacle safec2 b2e2 legend obstacles follower d1d2 follower e1e2 follower a1a2 follower b1b2 leader l1l2 follower c1c2d1e1a1b1l1 c1 l2c2b2d2 e2a2 d1e1a1b1 l1 c1l2c2b2d2 e2 a2 figure trajectories of drones during our physical experiment.
.
.
.
.
.
.
.
.
.
.
m .
.
.
.
.
.
.
.
.
.
a original execution b execution with fixrepetitive crashesdcc c dccof original execution d dccof execution with fix0 372move directionstart pointslegend s s waypoint rover cube rock walllegend rover 2m time sec figure applying swarmbug to swarmathon submitted to an annual robot competition funded by nasa swarmathon .
the algorithm took third place in the competition and was selected as the authors identified the bug with a few test runs.
the goal of the algorithm is to leverage the swarm robots to gather resources spread throughout the map quickly.
during the mission there is a buggy behavior that rovers keep crashing on the north border of the map and get stuck into the north east corner as shown in figure a .
swarmbug identifies the dcc trends as shown in figure c with seven environment configuration variables.
fluctuating dcc values for the wall i.e.
the gray area in the graph represent the crashes.
swarmbug applies the balancing strategy based on the trend identifying potential fixes from swarm configuration variables .
among these fixes m pi 2 rand pi ranked the first the original value for the variable is pi .
the fix yields the dcc trend shown in figure d .
most of the gray area is removed as the fix reduces the number of crashes.
as shown in figure b the execution with the fix does not show the buggy behavior e.g.
drones stuck in the corner .
discussion overhead.
during the operation swarmbug runs a number of tests and conducts various analyses e.g.
computing dcc and mse values on the collected data from the tests.
note that the analyses are done offline.
we also instrument existing simulators to collect values for dcc computation and the instrumentations incur less than overhead at runtime.applicability of swarmbug s fuzz testing.
while this paper focuses on finding and fixing configuration bugs swarmbug s fuzz testing can find other types of bugs as well.
specifically while fuzz testing the adaptive swarm we find a bug in the algorithm that may rarely appear at runtime.
that is when a follower drone and the leader drone get very close to each other the leader does not try to avoid the follower leading to a crash.
our manual analysis shows that the leader drone s algorithm does not consider follower drones as an object to avoid .
this is odd because follower drones have the logic to avoid the leader drone if they get too close.
our conversation with the developer confirmed that the developer assumed that the leader will always be far ahead of other drones and do not need to implement code to avoid a collision.
even testing three days without swarmbug does not reveal the bug.
swarmbug s fuzz testing identified such a scenario and exposed the defect thanks to the guidance via dcc and mse values.
we also validated this can happen in the real world and the issue is confirmed by the author of the algorithm as well.
more details can be found on our project page .
we also find that dcc can be used to identify buggy logic in the swarm algorithm.
specifically when we initially evaluate howard s algorithm we find that swarmbug could not find any possible fix.
we investigate the dcc values produced during the experiment further and notice that the observed dccvalues are extremely stable except for slight variations observed in obst pot c just before the drone crashes.
as we trace back to code related to obst pot c we found that it detects the obstacle only after a crash happens.
to properly avoid objects before it crashes the algorithm should detect the object before it gets too close.
to fix this we modify the algorithm so that it can detect objects early.
after we patch the algorithm can be found on our project page we conduct our evaluation on the algorithm again and swarmbug successfully finds a possible fix as shown in table .
scalability and usability of swarmbug .our design is general and applicable to other swarm algorithms while it requires some engineering effort.
specifically to support a new swarm algorithm two tasks are required identifying configuration variables we provide a profiling tool for this in section .
.
and thresholds e.g.
mission completion time time window mse thresholds instrumenting the algorithm to integrate swarmbug e.g.
changing sloc for adaptive swarm .
in our evaluation it took 877swarmbug debugging configuration bugs in swarm robotics esec fse august athens greece hours by a graduate student with moderate experience in drones to complete the two tasks for an algorithm.
the effort is non trivial but it is required one time for each algorithm.
for example besides the four evaluated algorithms we have applied swarmbug to swarmathon see section .
.
taking about hours identifying configuration variables the thresholds and changing sloc for the integration .
future directions.
we envision future directions of our paper along two dimensions empirical and technical.
for the empirical aspect applying swarmbug to more diverse swarm algorithms systems e.g.
ground vehicle swarm and more complicated scenarios e.g.
drones navigating a city landscape and analyzing the cost and benefits of it can be the future work.
also further analysis support to complete some of the semi automated processes such as identifying key parameters used as inputs in swarmbug can be the future work as the technical aspect.
related work testing autonomous robotics.
several testing methods are proposed and studied to solve and understand diverse challenges in testing autonomous robots.
to evaluate the exploration of the system under test sut coverage driven verification cdv guides the testing process with an automated and systematic aspect thus developers generate a broad range of test cases .
astaa proposed an automated system specialized in stress and robustness testing and then discovered hundreds of bugs.
timperley et al.
empirically studied and found that the majority of bugs in autonomous systems can be reproduced by software based simulations .
hildebrandt et al.
integrated dynamic physical models of the robot to generate physically valid yet stressful test cases .
alternatively formal validation and verification are rigorously studied and used to prove properties of the testing programs such as correctness functionality and availability.
bensalem et al.
developed a toolchain for specifying and formally modeling the functional level of robots and halder et al.
implemented a system for checking the model of robots.
deeproad validated inputs for testing autonomous driving systems.
unlike previous studies swarmbug aims to debug swarm algorithms which is an order of magnitude more complex by using the novel concept of the degree causal of contribution dcc .
testing debugging approaches.
delta debugging isolates the difference between a passing and a failing test case by running mutated test cases and observing the execution results.
bugex and holmes leverage a similar approach to understand the cause of bugs.
in addition coz introduces additional delays to infer possible optimization opportunities.
ldx perturbs program states at runtime to infer causality between system calls.
swarmbug uses a similar idea of mutating environment configuration variables to conduct behavior causal analysis.
however swarmbug handles swarm algorithms where inputs are essentially streams of data while other techniques may need a non trivial amount of modifications to handle such input data.
swarmbug also leverages the dcc values to create a fuzz testing system.
researchers leveraged random testing techniques e.g.
fuzzing to continually improve the quality of test cases .
pyse used a reinforcement learning based approach to find a worst casescenario.
there are also model based approaches inferring the actual program state or input types .
automated program repair.
there is a line of research focused on fixing buggy programs automatically .
in particular leverages a genetic programming approach to repair a buggy program.
proposes an automated program repair technique for programming assignments.
while the previous works andswarmbug share the same goal of fixing a bug swarmbug aims to fix configuration bugs in complex swarm algorithms running multiple robots.
it fixes bugs by changing the swarm configuration variables values while the previous works change the program code to repair.
qlose leverages program distances to come up with solutions for program repairing.
semcluster defines a new metric based on the input data space and uses the metric to cluster programs.
swarmbug leverages dcc to guide the analysis and testing for swarm algorithms.
conclusion we proposed swarmbug a debugging approach for resolving configuration bugs in swarm algorithms.
swarmbug automatically identifies the causes of configuration bugs by creating new executions with mutated environment configuration variables.
it compares the new executions with the original execution to find the causes of the bug.
then given the cause swarmbug applies four different strategies to fix the bug by mutating swarm configuration variables resulting in fixes for the configuration bugs.
our evaluation shows that swarmbug is highly effective in finding fixes for diverse configuration bugs in swarm algorithms.