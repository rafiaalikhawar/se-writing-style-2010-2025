definition and detection of centralization defects in smart contracts zewei lin school of software engineering sun yat sen university zhuhai china peng cheng laboratory shenzhen china linzw3 mail2.sysu.edu.cnjiachi chen school of software engineering sun yat sen university zhuhai china chenjch86 mail.sysu.edu.cnjiajing wu school of software engineering sun yat sen university zhuhai china wujiajing mail.sysu.edu.cn weizhe zhang school of computer science and technology harbin institute of technology shenzhen china peng cheng laboratory shenzhen china wzzhang hit.edu.cnzibin zheng school of software engineering sun yat sen university zhuhai china zhzibin mail.sysu.edu.cn abstract in recent years security incidents stemming from centralization defects in smart contracts have led to substantial financial losses.
a centralization defect refers to any error flaw or fault in a smart contract s design or development stage that introduces a single point of failure.
such defects allow a specific account or user to disrupt the normal operations of smart contracts potentially causing malfunctions or even complete project shutdowns.
despite the significance of this issue most current smart contract analyses overlook centralization defects focusing primarily on other types of defects.
to address this gap our paper introduces six types of centralization defects in smart contracts by manually analyzing stack exchange posts and audit reports.
for each defect we provide a detailed description and code examples to illustrate its characteristics and potential impacts.
additionally we introduce a tool named cdripper centralization defects ripper designed to identify the defined centralization defects.
specifically cdripper constructs a permission dependency graph pdg and extracts the permission dependencies of functions from the source code of smart contracts.
it then detects the sensitive operations in functions and identifies centralization defects based on predefined patterns.
we conduct a large scale experiment using cdripper on real world smart contracts and evaluate the results based on a manually labeled dataset.
our findings reveal that contracts contain at least one of the six centralization defects with our tool achieving an overall precision of .
.
index terms smart contracts centralization defects defects definition and detection semantic analysis i. i ntroduction the rapid development of decentralized applications dapps and decentralized finance defi has spurred extensive research on smart contracts.
recently a notable increase in security incidents and economic losses has been attributed to centralization defects in defi projects.
according to thecertik s report during the third quarter of alone more than related incidents were reported leading to a total loss exceeding million.
a centralization defect in a defi project refers to any error flaw or fault in a smart contract s design or development stage that results in a single point of failure .
this means that specific accounts users or addresses could disrupt normal operations potentially causing project malfunctions or even shutdown.
these defects encompass centralization issues and logical errors that directly result in the loss of funds.
for instance if the contract owner has the privilege to transfer tokens deposited by users all users assets may be at risk as the private key of the owner could be leaked.
additionally centralization defects can also stem from design flaws that may not pose threats to users funds immediately but do affect safety in certain scenarios.
in march the defi project mumi incurred an economic loss due to a centralization defect.
the contract included a function for minting mumi tokens which was controlled by a single node.
minting tokens involves generating new tokens by authenticating data creating new blocks and recording this information on the blockchain .
an attacker exploited this function to clandestinely mint and drain a substantial number of tokens resulting in a financial loss of approximately .
although previous works have reported a set of smart contract defects the unique challenges presented by centralization defects have not been fully addressed.
to address this gap we first conducted an empirical study aimed at defining centralization defects in smart contracts.
our analysis encompassed q a posts collected from ethereum stack exchange and smart contract auditarxiv .10169v1 nov 2024reports from blockchain security companies.
by employing a manual filtering and open card sorting approach we defined six centralization defects in smart contracts mint function with single signature management without timelock critical variables manipulation with single signature single proxy admin self destruct with single signature and individual contract output reliance .
to identify these centralization defects we developed a tool named cdripper centralization defects ripper which takes the smart contract s source code as input.
by identifying centralization defects in contracts developers can enhance contract security while users can mitigate investment risks contributing to the safe and sustainable growth of the smart contract community.
cdripper first constructs a permission dependency graph pdg which represents the relationships of permission dependencies among contract statements and functions such as those used for or controlled by multisignature verification timelock mechanism and permission checks.
cdripper then identifies sensitive operations in functions based on predefined rules which are summarized from the empirical study of centralization defects.
finally cdripper reports centralization defects based on the permission dependencies of functions and sensitive operations.
we applied cdripper to real world smart contracts discovering that about .
contracts in our dataset contained at least one centralization defect.
more than of reported defects arise from management through a single signature address i.e.
an address controlled by a single private key.
the compromise or loss of the private key associated with this address will leave the contract open to unauthorized access and lead to security issues.
in the performance evaluation of cdripper we used a random sampling method and manually labeled two distinct datasets.
the evaluation results show that cdripper achieved an overall precision rate of .
and a false negative rate of .
.
the main contributions of our work are as follows we defined six types of centralization defects in smart contracts which is the most comprehensive work on this topic.
for each defect we present an illustration and a code example.
additionally we provide possible solutions aimed at enhancing the security of smart contracts.
we developed a tool called cdripper for detecting the defined centralization defects.
through random sampling and manual validation the results demonstrate that our method achieves an overall precision of .
and a false negative rate of .
.
we conducted a large scale experiment involving real world smart contracts to evaluate the performance of cdripper.
our findings reveal that among these smart contracts about .
contain at least one defined defect.
we published the source code of cdripper along with all experimental data and analysis results at .ii.
b ackground to facilitate a better understanding of centralization defects we provide essential background information in this section.
a. smart contracts a smart contract serves as a computerized transaction protocol that autonomously enforces the terms of a contractual agreement .
ethereum stands out as one of the most widely adopted platforms for smart contracts .
when a smart contract is deployed to ethereum its source code undergoes compilation by the ethereum virtual machine evm compiler .
this compilation process yields bytecode which is subsequently stored on the blockchain.
variables declared within a contract but outside any function are denoted as state variables .
notably state variables are permanently stored in the evm s storage rather than in its memory.
b. decentralized ecosystem unlike a centralized ecosystem a decentralized ecosystem functions independently of specific centralized nodes.
governance within the decentralized ecosystem is distributed among its creators and users.
due to the characteristics inherent in a decentralized ecosystem such as verifiability self governance permissionlessness and native payments it enables universal access to services without the requirement for personal data.
figure depicts the primary components of a decentralized ecosystem including exchanges which facilitate the trading of fiat and cryptocurrencies crypto wallets which serve to manage crypto assets and interact with defi projects.
the arrows in the figure represent the invocation relationships between the components.
the defi project comprises a token economy and smart contracts.
the token economy delineates the distribution strategy of the defi project s tokens specifying the allocated percentage for providing liquidity in exchanges and other purposes.
smart contracts are employed to automatically execute the logic of the defi project.
users crypto wallet exchangedecentralized ecosystem defi project token economysmart contracts fig.
.
basic components of a decentralized ecosystem c. multi signature wallet the private key is an alphanumeric code in the field of cryptography .
similar to a password it plays a crucial role in securing and validating cryptocurrency transactions by providing evidence of ownership and facilitating cryptographic authorization .
a single signature address relies on a single private key.
multi signature wallets require a specific number of signers tocollectively sign a transaction using their respective private keys for approval.
the process of verifying whether the number of signers meets the predefined threshold is called multi signature verification.
iii.
c entralization defects in smart contracts in response to the insufficient research on centralization defects we conducted an empirical study and classified them into six types.
in this section we will illustrate the process of identifying the six centralization defects providing a definition and example for each one.
a. data collection ethereum stack exchange posts to identify centralization defects in smart contracts it is essential to gain insights into the centralization concerns acknowledged by smart contract developers.
ethereum stack exchange serves as a question and answer platform for ethereum users.
we conducted searches using the keywords centralization decentralization and smart contract up to october .
ultimately we collected posts pertaining to defects related to centralization in smart contracts.
smart contract audit reports in addition to posts smart contract audit reports also serve as a valuable resource for identifying centralization defects in smart contracts.
in recent years with the increasing economic impact of centralization defects in smart contracts certain smart contract security platforms have incorporated the assessment of centralization risk as part of their audit criteria.
we collected audit reports from various smart contract security auditing platforms up to october including certik sourcehat and others.
subsequently we filtered out reports that had audited centralization defects.
ultimately we collected audit reports addressing centralization defects.
b. data analysis manually filtering not all of the posts and audit reports are relevant to smart contract centralization defects.
for instance some posts delve into the centralization defects of cross chain protocols or off chain wallets.
the root cause of these defects lies in the design of the protocol rather than in the development of smart contracts placing them beyond the scope of this paper.
furthermore audit reports may not identify any centralization defects in the audited smart contracts.
therefore we manually excluded data unrelated to smart contract centralization defects.
finally we identified that posts and audit reports were relevant to solidity related smart contract centralization defects.
open card sorting to ensure accuracy we employed the open card sorting method to analyze and categorize the filtered posts and audit reports.
a card was generated for each post or report with its content divided into several parts for convenient analysis i.e.
title description comments or recommendations.
two researchers each possessing over two years of experience in smart contract research collaboratedon the analysis and classification.
we conducted a total of two rounds of classification as follows in the first round we randomly selected of the cards and the two researchers collaborated to analyze and determine the classification for these cards.
in the first step they read the title and description of each card to understand the defects associated with it.
subsequently they reviewed the comments or recommendations to understand how to address the identified defects.
furthermore cards without a clear root cause of defects were omitted.
in the second round the two researchers independently analyzed and categorized the remaining of the cards.
the detailed analysis steps were the same as in the first round.
subsequently they compared the results and discussed the differences either harmonizing or deleting them after the discussion.
finally they classified the smart contract centralization defects into six types.
title description comments what is the oracle problem definition exactly and briefly?
what is the oracle problem definition exactly and briefly?
does it mean trusting on a centralized oracle ?
or how to reach a consensus between a group of oracles ?
is the matter centralization or being trust based ?
that is in contrary to decentralization feature of blockchain.
once data is reported to a blockchain that data is now an immutable part of the history of the blockchain.
if a smart contract executes incorrectly based off that data your contract is not only not what it was intended to do but it can cause irreparable damage.
if your data is centralized coming from one source and that source is bribed hacked broken or depreciated your contract no longer works.
the solution to the oracle problem is to have a decentralized network of oracles bringing different independent sources of data on chain.
we ve seen chainlink solve this issue.
therefore we would pull in the same data from at least different sources.
if are within a same really narrow error range you likely have a trustworthy data source.
fig.
.
example of a card of ethereum stack exchange posts figure illustrates a card example generated from an ethereum stack exchange post .
the card comprises three parts the title description and comments.
in the description the questioner raised doubts about the definition of oracle problems and reaching a consensus among a group of oracles.
in response the comments emphasized the risk of relying on data from a single source and recommended the use of various independent data sources.
consequently we classified this issue as individual contract output reliance name description recommendation cfc project in the contract cfctoken the role owner has authority over the functions shown in the diagram below.
any compromise to the owner account may allow the hacker to take advantage of this authority and pause unpause the contract.
we advise the client to carefully manage the privileged account s private key to avoid any potential risks of being hacked.
in general we strongly recommend centralized privileges or roles in the protocol be improved via a decentralized mechanism or smart contract based accounts with enhanced security practices e.g.
multi signature wallets.
fig.
.
example of a card of smart contract audit reports figure illustrates an example of a card generated from a smart contract audit report .
the card comprises three parts the project name description and recommendation.
as indicated in the description there are functions that allowthe modification of critical variables in the smart contract and these functions can only be invoked by the role owner .
compromising the owner account may enable a hacker to exploit this authority and pause or unpause the contract.
the audit platform recommends mitigating this risk by employing a decentralized mechanism such as multi signature wallets or timelock smart contracts.
consequently we categorize this issue as critical variables manipulation with single signature .
c. centralization defects definition based on open card sorting we finally defined six types of smart contract centralization defects.
we provide a brief definition of these smart contract centralization defects in table i. subsequently we will elaborate on the detailed definitions and present code examples of these defects later in this subsection.
table i definition of centralization defects .
centralization defect definition mint function with single signature mfs there are functions for arbitrary token minting controlled by a single signature address.
critical variables manipulation with single signature cvs critical variables can be manipulated with a single signature address.
management without timelock mt management functions can be executed without time delay.
single proxy admin spa the admin of the proxy contract is a singlesignature address.
self destruct with single signature ss the self destruct function can be executed by a single signature address.
individual contract output reliance ior existing logic relies on the output of an individual external contract.
it should be noted that centralization defects indicate that certain sensitive operations are controlled by a single node whose failure or compromise could lead to contract malfunction or attack.
in contrast existing defects usually involve situations where vulnerable functions can be directly accessed and exploited by others.
mint function with single signature mfs this defect involves a function within the token contract that allows for the minting of an arbitrary number of tokens and this function is controlled by a single signature address e.g.
the contract creator.
typically smart contract developers utilize the mint function to manage the stability of the tokens in the market.
however if the mint function is controlled by a single signature address it introduces a significant risk.
malicious project developers or attackers can exploit the mint function to generate an extensive quantity of tokens.
this may lead to a significant influx of tokens in the market ultimately resulting in substantial economic losses for the token holders.
example a brief example of this defect is shown in figure .
the mint function lines controlled by a singlesignature address via the onlyowner modifier lines enables the contract owner to mint tokens without restrictions.
critical variables manipulation with single signature cvs this defect is characterized by functions in smart contracts that can arbitrarily modify critical variables.
if there are no restrictions on these functions and they can be invoked at will by a single signature address it may result in financial losses for users or even shut down the entire project.1contract contract mint mapping address uint256 private balances address public owner modifier onlyowner require msgsender owner only owner can perform this operation function mint address account uint256 amount public onlyowner require account !
address erc20 mint to the zero address uint256 now balances balances balances now balances.add amount fig.
.
an example of mint function with single signature defect.
example in figure the function changefee allows the smart contract owner to arbitrarily adjust the transfer fee.
as shown in the function transfer line if an attacker who has access as the owner sets the transaction fee rate to then all transferred amounts between users will be transferred to the owner address as fees consequently the real recipient will not receive any token.
1contract contract crivar uint256 public fee function changefee uint256 newfee public onlyowner fee newfee function transfer address to uint256 amount public virtual override returns bool address from msgsender uint256 actual amount amount fee uint256 fee amount amount fee transfer from to actual amount transfer from owner fee amount return true fig.
.
an example of critical variables manipulation with single signature defect.
management without timelock mt this defect pertains to the ability of administrators to modify smart contracts without implementing a timelock mechanism.
a timelock mechanism acts as a safeguard that ensures certain functions can only be executed after a predefined period.
the absence of a timelock means that when smart contracts undergo critical changes or are under attack users lack a time buffer to initiate necessary responses such as withdrawal of their tokens.
1modifier onlyafter uint256 time if block .timestamp time revert tooearly 4modifier onlybefore uint256 time if block .timestamp time revert toolate fig.
.
an example of timelock mechanism.
example figure shows an example of a timelock mechanism implemented to prevent this defect.
the timestamp of the current transaction is obtained from block.timestamp.modifiers onlyafter lines and onlybefore lines check if the current time is after or before a predefined period.
this mechanism ensures that functions using the modifier can only be executed before after a certain time.
single proxy admin spa this defect concerns the utilization of a single signature address to manage a proxy contract.
a proxy contract is essentially a facilitator users interact with it directly and it is responsible for forwarding transactions to and from a secondary contract known as the logic contract which contains the actual operational logic .
proxy contracts can be employed to upgrade smart contracts by modifying the address of the referenced logic contract.
however if the authorization to modify the logical contract is held by a single signature administrator address this poses a security risk.
these risks include losing the ability to upgrade the contract if the administrator s private key is lost and the malicious developers or attackers can steal users funds by altering the logic contract s address to one containing malicious functions.
1contract contract proxy modifier onlyadmin require msgsender getadmin only admin can perform this operation function change implementation address new implementation bytes memory data public onlyadmin erc1967utils.upgradetoandcall new implementation data fig.
.
an example of single proxy admin defect.
example the function change implementation lines in figure is employed to modify the address of the logic contract within the proxy contract.
due to the application of theonlyadmin modifier lines this function is exclusively invocable by a single signature administrator address.
self destruct with single signature ss this defect refers to the inclusion of the self destruct operation that a single signature address can trigger.
in ethereum the selfdestruct operation is employed to remove code from the blockchain and transfer the remaining ethers ethereum s cryptocurrency to a specified address .
when the selfdestruct operation can be triggered by a single signature address it poses the risk of the smart contract being terminated through a malicious invocation.
1contract contract selfdestruct function close public require msg.sender owner only the contract owner can call this function selfdestruct owner fig.
.
an example of self destruct with single signature defect.
example an illustration of self destruct with single signature is shown in figure .
a self destruct operation line is within the function close which can be invoked by the owner address.
if the private key of the owner addressis compromised an attacker can entirely destroy the smart contract at any time.
individual contract output reliance ior this defect arises when key variables or logic in a smart contract depend solely on the output of a single contract such as a single smart contract oracle.
smart contract oracles are data feeds from external systems providing essential information to blockchains.
if the single contract being relied upon fails or outputs incorrect information it may lead to the execution of incorrect logic or incorrect parameters.
1contract contract output uint160 sqrtprice tickmath.getsqrtratioattick currenttick uint256 price fullmath.muldiv uint256 sqrtprice .mul uint256 sqrtprice precision function currenttick public view returns int24 tick tick pool.slot0 fig.
.
an example of individual contract output reliance defect.
example as shown in figure the function currenttick line directly retrieves the current price tick from a decentralized exchange pool line .
therefore variable price line directly relies on the output of contract pool.
there is no validation or any reference to the outputs from the contract.
if the contract pool fails or is attacked and outputs an incorrect result then the token will be transferred at the wrong price.
iv.
m ethodology a. overview the overview of cdripper is depicted in figure .
cdripper consists of three primary modules permission analysis sensitive operations detector and defects identifier .
defects identifierpermission analysis pdg analysis reportsensitive operations detectorpermission dependencies of functions source code empirical study predefined rulessensitive operations token minting selfdestruct permission dependencies of statements multi signature verification timelock mechanism permission checkcdripper fig.
.
overview of cdripper cdripper takes smart contracts source code as its input.
firstly the permission analysis module constructs the permission dependency graph pdg and extracts the permission dependencies of statements and functions such as multisignature verification timelock mechanism and permission check.
subsequently the sensitive operations detector identifies sensitive operations in functions based on the predefined rules summarized from the empirical study of centralization defects.
finally cdripper identifies centralization defectsbased on the permission dependencies and sensitive operations within the defects identifier module.
b. permission analysis permission analysis is a process that aims to identify the permission dependencies in smart contracts.
to achieve this we first construct a permission dependency graph pdg which captures statements that are constrained by permission.
next the permission dependencies of functions can be extracted from the graph.
permission dependency graph pdg cdripper constructs a permission dependency graph pdg g n e x to represent the permission dependencies of statements within smart contracts.
this graph indicates whether the smart contract statements are constrained by permissions during execution such as requiring certain privileges multisignature verification or timelock.
a node in a pdg represents a basic block of the control flow graph cfg .
a basic block is a straight line code sequence with no branches except at the entry and exit points .
to analyze the permission dependency relationship between these basic blocks cdripper extracts the semantics of nodes and classifies them into four types.
an edge in a pdg represents the control flow dependency between two basic blocks.
depend b1 b2 is utilized to indicate that basic block b1is dependent on basic block b2 which means that every execution path to basic block b1will pass through b2.
x n p m t o is a labeling function that maps a node to one or more of the four types.
a node nis labeled as pif the node nis used to check whether the function caller is the high privilege node mif the node nis used for multi signature verification tif the node nis used as the timelock mechanism oif the node nis beyond the scope of the above three situations.
table ii fundamental information of pdg.
name description depend b1 b2 basic block b1is depend on basic block b2in cfg.
percheck b basic block bcontains the logic to check whether the function caller is the high privilege node.
multisig b basic block bcontains the multi signature verification.
timelock b basic block bcontains the timelock mechanism.
cdripper uses slither a static analysis framework to help construct the pdg.
the fundamental information of the pdg is detailed in table ii.
multisig b is utilized to verify multi signatures within the basic block b. this verification process requires two key elements the signature information provided by multiple private keys and a threshold indicating the minimum number of signatures for successful verification.
typically multisignature information is obtained from the input of the contract caller while the threshold can be obtained from user input or a predefined state variable.
as a result we establish the following criteria to identify the presence of multi signature verification within a basic block i the existence of multisignature information in the user s input ii reading an integertype value as the threshold and iii utilizing both the multisignature information and the threshold value in the same conditional logic within the basic block.
timelock b is utilized to identify a timelock mechanism within the basic block b. implementing a timelock mechanism in smart contracts requires the current timestamp of the transaction and a pre defined time threshold to determine unlocking eligibility.
therefore we consider a basic block to have a timelock mechanism if i the basic block contains statements to retrieve the current transaction timestamp such as using block.timestamp .
ii the basic block accesses a time threshold.
iii both the current transaction timestamp and the time designated for timelock unlocking are used within the same conditional logic within the basic block.
percheck b is utilized to determine whether basic block bcontains logic to check whether the function caller is the high privilege node.
the implementation of permission check logic in smart contracts requires the address of the function caller and a pre defined set of high privilege nodes.
our analysis indicates that high privilege nodes are typically set during contract creation.
these nodes may not necessarily be stored as variables of the address type for example amapping address bool might be used to determine whether an address is a high privilege node.
therefore we consider a basic block to have permission check logic if i the block includes statements to retrieve the address of the function caller such as using msg.sender ii the block accesses the set of high privilege nodes and iii both the current function caller and the set of high privilege nodes are used within the same conditional logic within the block.
permission dependencies of functions cdripper identifies the permission dependencies of functions by analyzing the pdg.
this analysis is based on two main criteria.
firstly the function itself has permission restrictions.
secondly the function calls other functions with permission restrictions.
the rules for extracting the permission dependencies of functions are illustrated in figure .
multisig f b block f multisig b multisig f call f f multisig f timelock f b block f timelock b timelock f call f f timelock f limited f b1 block f depend b1 b2 percheck b2 limited f call f f limited f limitedpublic f limited f public f fig.
.
rules for extracting the permission dependencies of functions multisig f andtimelock f indicate that function fcontains logic that can only be executed after being verified by a multisignature or unlocked by a timelock respectively.
meanwhile limited f and limitedpublic f signify that the function f can only be invoked by a high privilege node.
in addition limitedpublic f further requires that the function fneeds tobe callable directly potentially serving as an entry point for an attacker to launch an attack.
c. sensitive operations detector sensitive operations detector is designed to identify sensitive operations related to centralization defects in smart contracts.
these operations are identified based on the empirical study outlined in section iii.
specifically the sensitive operations related to centralization defects are detailed in table iii.
table iii sensitive operations related to centralization defects .
name description mint func function func is designated for token minting.
modifycrivar func function func is employed to modify the value of critical variables.
changeimple func function func is utilized to change the implementation address of proxy contracts.
self destruct func function func contains the self destruct operation.
token c contract cis a token contract.
proxy c contract cis a proxy contract.
dependoutput var out the value of variable varis depend on variable out which is the output of other contracts.
mint func indicates that the function func is used for token minting.
a function is considered a token minting function if it includes the logic to increase or modify token balances without reducing the balances of any address.
to identify mint function with single signature defect we specifically examine token contracts using token c to check if contract cis a token contract.
this approach allows us to exclude non token contracts and concentrate on the potential functions for token minting thus improving efficiency and accuracy.
modifycrivar func signifies that function func is utilized to modify the value of critical variables in smart contracts.
we observed that critical variables are usually defined and stored in the evm storage during the contract s creation.
therefore cdripper identifies modifycrivar func by subsequently identifying these critical variables and the corresponding functions responsible for writing to their storage.
proxy c signifies that contract cis a proxy contract and changeimple func signifies that function func is utilized to change the implementation address of proxy contracts.
we utilized the uschunt tool to determine if the target contract is a proxy and to identify the address variables of the logic contract.
self destruct func signifies that function func contains the self destruct operation.
since self destruct is a special operation in evm we employ the keyword to identify it.
dependoutput var out signifies that state variables varrely on the output of external calls to other contracts.
the variable outis defined by the output of external calls in other contracts and it is located by analyzing the call anddelegatecall operations.
then we identify the state variable varwhose value depends on the value of outby analyzing the data flow graph of smart contracts.
d. defects identifier the defects identifier module utilizes the permission dependencies of functions and the sensitive operations extractedfrom the previous modules to identify centralization defects.
we will provide more details on how we detect centralization defects in the following paragraphs.
mint function with single signature mfs detecting mint function with single signature involves two primary criteria.
firstly the existence of a token minting function within the smart contract secondly this function is controlled by a single signature address.
the rule for detecting mint function with single signature is shown in formula .
token c f func c mint f limitedpublic f multisig f mint function with single signature critical variables manipulation with single signature cvs detecting this defect involves two primary criteria.
firstly the existence of a function to modify the critical variables in smart contracts.
secondly this function is controlled by a single signature address.
the rule for detecting critical variables manipulation with single signature is shown in formula .
f func c modifycriv ar f limitedpublic f multisig f critical v ariables manipulation with single signature management without timelock mt detecting the management without timelock defect involves two primary criteria.
firstly the existence of a management function in the smart contract.
secondly the absence of a timelock mechanism within this function.
the rule for detecting management without timelock is shown in formula .
f func c modifycriv ar f var limitedpublic f timelock f management without timelock single proxy admin spa detecting single proxy admin involves three primary criteria.
firstly the contract should be a proxy contract.
secondly it should have a high privilege address with functions to modify the logic contract s address.
thirdly the high privilege address should be a single signature address.
the rule for detecting single proxy admin is shown in formula .
proxy c f func c changeimple f multisig f single proxy admin self destruct with single signature ss two primary criteria are used to detect the ss defect i.e.
the presence of the self destruct operation and its exclusive invocation by a single signature address.
the rule for detecting self destruct with single signature is shown in formula .
f func c self destruct f limitedpublic f multisig f self destruct with single signature individual contract output reliance ior the primary criterion for this defect is whether the state variables in the contract rely solely on the output of individual externalcalls to other contracts.
the rule for detecting individual contract output reliance is shown in formula .
var statev ar c dependoutput var out dependoutput var out out 1 out2 individual contract output reliance v. e valuation a. experimental setup the experiment was executed on a server running ubuntu .
.
lts equipped with intel r xeon r platinum 8360h cpus .00ghz and gb of memory.
dataset.
to identify centralization defects in real world ethereum smart contracts we utilized an open source dataset from a github repository .
this dataset contains the source code of all verified smart contracts on etherscan which we downloaded in november .
given that solidity .
.
was the latest compiler version at the time of writing we chose this version and excluded contracts that failed to compile.
this process yielded verified smart contracts.
subsequently we conducted preprocessing on the dataset involving two primary steps contract deduplication and the exclusion of toy contracts.
initially duplicates were identified by comparing the source code of the smart contracts which led to the removal of duplicate smart contracts.
contracts with fewer than two transactions were then excluded to eliminate toy contracts resulting in the exclusion of an additional contracts.
this refinement process ultimately yielded a dataset of smart contracts.
table iv thestatistics of dataset dataset trans avg loc avg preprocessed dataset .
.
smart contracts with defects .
.
the statistics of the dataset are presented in table iv.
in the preprocessed dataset the average number of transaction records per contract is .
and the average number of lines of code is .
.
evaluation metrics.
we summarize the following research questions rq to evaluate the effectiveness of cdripper.
rq1 what are the prevalent of the six centralization defects in ethereum?
rq2 in terms of effectiveness how is the precision of cdripper in finding centralization defects in smart contracts?
b. answer to rq1 prevalence of defects to answer rq1 we executed cdripper on verified ethereum smart contracts.
the corresponding experimental results are presented in table v. the second and third columns of the table display the number and proportion of various defects detected by cdripper respectively.
as cdripper primarily aims to determine whether there exist centralization defects within contracts instances of the same defect occurring multiple times in a single contract are considered only once.cdripper identified smart contracts containing at least one centralization defect representing .
.
critical variables manipulation with single signature cvs andmanagement without timelock mt are the two most prevalent centralization defects present in approximately .
and .
of smart contracts respectively.
in contrast selfdestruct with single signature ss exhibited the lowest frequency occurring at a rate of merely .
.
the frequencies of other centralization defect types are relatively consistent falling within the range of to .
table v the defects detected by cdr ipper centralization defects defects per mint function control by single signature mfs .
critical variables manipulation with single signature cvs .
management without timelock mt .
single proxy admin spa .
self destruct with single signature ss .
individual contract output reliance ior .
all .
analysis of the prevalence.
our analysis revealed that .
of the contracts examined exhibited at least one form of centralization defect which is notably high.
these defects are predominantly attributed to cvs andmt.
the high prevalence of defects can largely be attributed to defi developers overlooking them.
unlike traditional vulnerabilities that can result in direct financial losses these defects may sometimes be harmless to developers and even offer certain advantages such as allowing contract owners to alter critical variables like fees.
additionally addressing these defects could increase development costs leading some developers to retain them.
however these defects can harm users and erode their trust in the contracts as discussed in section iii c. as shown in table iv among the contracts identified by cdripper as having centralization defects the average number of transactions and lines of code are .
and .
respectively.
notably the average number of transactions represents a significant increase of .
compared to the original dataset.
this indicates that filtering the dataset based on the number of transactions can enhance its quality.
c. answer to rq2 evaluation of cdripper to answer rq2 we evaluate the performance of cdripper in this subsection.
due to the infrequent occurrence of certain centralization defects directly sampling the entire dataset may not capture a sufficient number of these defects making it challenging to accurately evaluate detection effectiveness.
for instance as demonstrated in table v contracts containing theself destruct with single signature defect comprise only .
of the total.
consequently direct sampling may yield a sample devoid of any contracts with this defect thus impeding the verification of cdripper s accuracy in its detection.
to address this we conducted random sampling validation respectively for cdripper s precision in detecting various types of centralization defects and for its false negative rate.
to validate the precision of cdripper we conduct a random sampling on smart contracts identified as positive by cdrip per.
we employ the sampling approach based on a confidence level and a confidence interval aligned with previous studies .
two researchers manually verified the detection results recording true positives tp and false positives fp to analyze cdripper s performance.
the results are presented in table vi.
the second column illustrates the sample quantities for each type of centralization defect.
in the third and fourth columns we provide the counts of true positives tp and false positives fp respectively.
the fifth column displays the precision of cdripper in identifying various defects calculated using the formula tp tp fp .
additionally we computed the overall precision to gauge the effectiveness of cdripper.
the overall precision is determined bypn i 1pci ci pn i ci where pcirepresents the precision of detecting defect i and ci is the number of smart contracts identified with centralization defect i. table vi the precision of cdr ipper centralization defects sam tp fp prec mint function control by single signature mfs .
critical variables manipulation with single signature cvs .
management without timelock mt .
single proxy admin spa .
self destruct with single signature ss individual contract output reliance ior .
all .
the identification of smart contracts incorporating the selfdestruct with single signature obtains a precision rate of .
for mint function with single signature critical variables manipulation with single signature management without timelock single proxy admin individual contract output reliance cdripper reports them at a precision of .
.
.
.
.
respectively.
moreover cdripper demonstrates an overall precision of .
.
false positives.
the experimental findings reveal instances of false positives.
in the context of the mint function controlled by single signature among the sampled contracts are false positives due to the misidentification of variables of token balances.
1mapping address uint256 public registeredcontracts empty erc1155 erc721 handler erc20 balance claim unknown factory staking bypass 2function registercontract address contract uint type public isregisteredcontractorowner msgsender registeredcontracts type registeredoftype .
push contract fig.
.
an example of false positive detected by cdripper.
illustrated in figure is an example of a false positive where the variable registeredcontract line functions as a mapping from contract addresses to their respective types.
remarkably the data structure of this variable is the same as that of the token balances in erc20 tokens .
consequently cdripper interprets the function registercontract line as one capable of arbitrarily modifying token balances thereby characterizing it as a mint function.in the case of critial variables manipulation with single signature certain functions initialize critical variables before reading them leading cdripper to identify these functions as modifying crucial variables resulting in false positives.
for management without timelock false positives arise due to the incorrect identification of variables intended for contract management.
regarding single proxy admin false positives are due to misjudgments concerning proxy contract behavior.
as for individual contract output reliance false positives stem from misinterpretations of external function calls.
false negatives.
to find contracts with centralization defects that cdripper failed to report we follow the same sampling method used for precision analysis.
we randomly sampled contracts from contracts where no defect was reported using a confidence interval of and a confidence level of .
we then manually label them to find false negatives that cdripper missed.
the number of false negatives of cdripper is shown in table vii.
in total we find that of contracts are false negatives the false negative rate of cdripper is .
.
table vii the number of false negatives of cdr ipper centralization defects fn per mint function control by single signature mfs .
critical variables manipulation with single signature cvs .
management without timelock mt .
single proxy admin spa all .
false negatives in the mint function with single signature result from the failure to discern certain complex data structures associated with non fungible tokens nft leading to the inability to identify the corresponding nft minting function.
the false negatives of critical variables manipulation with single signature andmanagement without timelock result from the failure to discern certain complex permission mechanisms.
specifically some contracts utilize the data structure mapping bytes roledata to store permission information.
in this structure bytes32 corresponds to string types representing high permission nodes e.g.
default admin role and roledata is a custom data structure.
the complexity of this custom data structure poses challenges for cdripper in accurately categorizing it as a permission related variable.
the false negatives related to single proxy admin arise because cdrripper fails to identify this contract as a proxy contract.
vi.
d iscussion a. cross contract analysis the implementation of multi signature verification and timelock mechanisms can be accomplished by transferring contract permissions to a multi signature wallet contract or a timelock contract.
this process involves the transfer of permissions between distinct contracts necessitating transaction records for analysis.
as cdripper solely utilizes smart contract source code as its input it lacks the capability to recognize this scenario resulting in false positives.
to quantifythe number of reported false positives in this context we have devised an algorithm to conduct cross contract analysis.
the central aspect of the algorithm involves identifying the transfer of ownership through the examination of transaction records.
table viii shows the number of false positives that occur when cross contract analysis is omitted.
all false positive rates are less than .
this indicates that while the concern of centralization defects is important developers seldom address this issue by transferring contract permissions to external multi signature wallet contracts and timelock contracts.
table viii the number of false positives resulting from the omission of cross contract analysis centralization defects fp per mint function control by single signature mfs .
critical variables manipulation with single signature cvs .
management without timelock mt .
single proxy admin spa .
self destruct with single signature ss .
b. possible solution for centralization defects to mitigate the risk of centralization defects in smart contracts we have developed cdripper specifically for detecting such issues.
furthermore our objective is to support smart contract developers in creating secure smart contracts.
in this subsection we provide possible solutions to assist developers in avoiding the identified centralization defects.
table ix possible solutions for the centralization defects .
centralization defect possible solutions mint function with single signature mfs eliminate the mint function or implement multi signature verification prior to minting.
management without timelock mt implement timelock mechanism prior to the execution of management functions.
critical variables manipulation with single signature cvs implement multi signature verification prior to modifying critical variables.
single proxy admin spa transfer administrative permissions of a proxy contract to a multi signature wallet contract.
self destruct with single signature ss eliminate self destruct or implement multisignature verification prior to self destruct.
individual contract output reliance ior implement verification of contract output or combine multiple contract outputs.
table ix presents concise potential solutions for each defect.
to address centralization defects related to sensitive functions controlled by a single signature such as mint function with single signature critical variables manipulation with single signature single proxy admin and self destruct with single signature developers should consider removing these sensitive functions from smart contracts.
if these functions are essential for the project we recommend restricting them by multi signature verification.
there are two approaches to multi signature verification direct verification before function execution and transferring control of the contract to a multisignature wallet contract.
it is important to note that while multi signature authentication can help mitigate centralization defects it cannot completely eliminate them.
there is still a risk of multiple private keys being stolen .
formanagement without timelock we suggest developers restrict management functions using a timelock mechanism.there are two approaches to a timelock mechanism direct timelock verification before function execution and transfer control of the contract to a timelock contract.
regarding individual contract output reliance developers have two viable solutions one involves the verification of whether the contract output aligns with expected criteria while the other entails considering outputs from various distinct contracts or outputs from the same contract at different time.
c. limitations first cdripper uses smart contract source code as its input which makes it unable to identify centralization defects in unverified smart contracts.
however compared to bytecode source code allows for a more accurate analysis of permissions dependencies in the contract resulting in overall improved accuracy.
additionally the source based approach is already sufficient to meet developers needs in detecting centralization defects.
therefore we have decided to use source code as the input for cdripper.
besides cdripper s current functionality is limited to detecting six specific defect types which are identified based on existing posts and audit reports.
it is possible that the current source may overlook some defects.
however our objective is to ensure that all defined defects have a real world source to guarantee their reliability.
in the future as new posts or reports emerge we plan to use the same open card sorting method to create new cards and categorize new defects accordingly.
thirdly cdripper s detection rules rely on expert knowledge of smart contracts and their centralization defects which complicates updates and raises barriers to use.
future work could involve developing an automated method for generating detection rules to lower usage barriers and simplify updates enabling cdripper to detect newly emerging centralization vulnerabilities more swiftly.
vii.
r elated work a. detection of security problems in smart contracts in recent years researchers have extensively explored the topic of defects in smart contracts.
chen et al.
were pioneers in defining and categorizing smart contract defects.
by analyzing posts about smart contracts on ethereum stack exchange they identified distinct types of smart contract defects.
subsequently they developed defectchecker a tool aimed at detecting these identified defects.
yang et al.
focused on defects in nft smart contracts defining five distinct types of nft defects.
they introduced nftguard a tool specifically designed to detect these nft defects.
furthermore several researchers have conducted studies on vulnerabilities in smart contracts.
much research employs static analysis methods for the analysis and detection of vulnerabilities in smart contracts.
for example onente zeus gasper slithercite securify ethainter and manian .
oyente stands out as the pioneering work in smart contract vulnerability detection conducting a comprehensive exploration of security vulnerabilities and developing a detec tion tool based on symbolic execution .
other works such as contract fuzzer ethbmccite mythrilcitedurieux2020empirical and echidna utilize dynamic analysis approaches.
additionally ethircite kevm and isabelle leverage formal verification methods.
however these tools face challenges in detecting centralization defects in smart contracts due to a lack of analysis on centralized permission issues.
b. defi centralization security risks analysis in response to the escalating economic losses attributed to centralization security risks an increasing number of researchers are making efforts to address these concerns.
this research can be categorized into three main types the detection of smart contract backdoors the identification of rug pull scams and the detection of privileged nodes.
smart contract backdoor detection has been addressed in works such as badapple and pied piper .
yan et al.
focus on centralization risks in cryptocurrency wallets and dapps presenting seven patterns and a specialized detection algorithm for android cryptocurrency wallets.
ma et al.
identify five backdoors in smart contracts proposing a detection method that integrates datalog and fuzzing.
lamby et al.
define centralization risk as the source code containing privileged access patterns on fund modifying logic.
however these works have a narrow focus ignoring other potential forms of centralization defects beyond backdoors and defects in other types of contracts besides token contracts or cryptocurrency wallet dapps.
rug pull scam detection involves identifying past occurrences of such events.
current research predominantly relies on machine learning methodologies for analyzing transaction records.
mazorra et al.
determine the occurrence of a rug pull by examining significant alterations in token price.
similarly xia et al.
detect malicious tokens by analyzing the resemblance of token names to those traded on centralized exchanges.
however these works are limited to the retrospective detection of rug pull incidents and can not support preemptive analysis.
detection of privileged nodes involves identifying highprivileged accounts that can invoke specific functions from smart contracts and transactions.
this can aid auditors in providing testimony about asset ownership.
ethpector can uncover ownership structures from binary smart contract code on the ethereum platform.
spcon implements role mining and security policy validation using the historical transactions of smart contracts.
however these works only focus on detecting high privileged nodes without further examining potential centralization defects.
viii.
c onclusion this paper is structured into two main sections the definition and detection of centralization defects.
in the definition phase we collected posts from ethereum stack exchange and security audit reports that discuss centralization defects in smart contracts.
through manual analysis and the opencard sorting method we identified and defined six distinct types of centralization defects.
additionally for each defect we provide a code example along with possible solutions.
to identify centralization defects in real world smart contracts we developed cdripper a tool designed to detect the six types of defects.
cdripper constructs a permission dependency graph pdg and extracts the permission dependencies of functions from the source code of smart contracts.
subsequently it detects the sensitive operations related to centralization defects and identifies defects based on predefined patterns.
we conducted a large scale experiment employing cdripper on real world smart contracts.
the results were evaluated by random sampling and manual identification.
our findings indicate that contracts exhibit at least one centralization defect with cdripper achieving an impressive overall precision rate of .
.
in future work developing an automated method for generating detection rules could lower usage barriers and simplify updates for cdripper.