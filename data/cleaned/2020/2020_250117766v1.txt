arxiv .17766v1 jan 2025formally verified binary level pointer analysis freek verbeek ali shokri daniel engel binoy ravindran open universiteit heerlen the netherlands email freek.verbeek daniel.engel ou.nl virginia tech blacksburg v a usa email freek ashokri binoy vt.edu ieee.
personal use of this material is permitted.
perm ission from ieee must be obtained for all other uses in any cu rrent or future media including reprinting republishing this material for advertising or promotional purposes creating new collective works for r esale or redistribution to servers or lists or reuse of any copyrighted component of this work in other work s.abstract binary level pointer analysis can be of use in symbolic execution testing verification and decompilat ion of software binaries.
in various such contexts it is crucial t hat the result is trustworthy i.e.
it can be formally establis hed that the pointer designations are overapproximative.
this paper presents an approach to formally proven correct binary lev el pointer analysis.
a salient property of our approach is that it first generically considers what proof obligations a gene ric abstract domain for pointer analysis must satisfy.
this all ows easy instantiation of different domains varying in precis ion while preserving the correctness of the analysis.
in the tra deoff between scalability and precision such customization allows meaningful precision sufficiently precise to ensure bas ic sanity properties such as that relevant parts of the stack frame ar e not overwritten during function execution while also allo wing coarse analysis when pointer computations have become too obfuscated during compilation for sound and accurate bound s analysis.
we experiment with three different abstract doma ins with high medium and low precision.
evaluation shows that our approach is able to derive designations for memory write s soundly in cots binaries in a context sensitive interproc edural fashion.
index terms binary analysis pointer analysis formal methods i. i ntroduction pointer analysis is central to various forms of verification and analysis for software containing pointers facilitati ng the construction of a state based semantic model of software .
it aims to statically resolve f or any pointer in a given program which region of the memory it may point to.
specifically given any two pointers it must be known whether they are aliasing always referring to separate regions in memory or if they may possibly overlap.
if a value is written to memory and no pointer information is known then one cannot accurately describe what the next state will be.
this can lead to overapproximative thrashing parts of the memory state or forking i.e.
to conservatively considering both separation and aliasing possibilities.
both such case s are undesirable as they will quickly lead to unrealistic states and path explosions.
in other words pointer analysis is a neces sity for building a state based transition system that accurate ly models the software under investigation.
such a model then typically precedes a verification or analysis effort aimed a t higher level properties.
the necessity for pointer analysis immensely exacerbates when dealing with binaries i.e.
machine or assembly code instead of source code.
the reason is that at this level ofabstraction everything is a pointer .
there are no variables and memory can be considered as a flat unstructured address space.
in a typical x86 program about of all assembly instructions write to memory1 producing tens of thousands of pointers even in medium sized programs.
moreover control flow related information is stored in writable memory such a s the current return address and the currently caught excepti on stack.
theoretically if the destination of even a single me mory write cannot be resolved then the effect of executing that memory write could result in either thrashing all memory including such control flow pertinent information or for king into unrealistic states such as when a memory write overlap s with the return address even though in reality it did not.
th is may lead to a situation where it cannot even be established what instruction is to be executed let alone what an accurat e next state can be.
this is one of the key challenges in dealing with binaries preventing one from simply using techniques developed for source code analysis and applying them to lowlevel code found in binary executables .
this paper presents an approach to formally verified binarylevel pointer analysis.
typically such analyses are based on a form of abstract interpretation where an abstract dom ain is defined that overapproximates concrete semantics .
a fundamental challenge is choosing the right abstract domain as this essentially boils down to balancing precisi on vs. scalability.
this paper thus first leaves the abstract do main polymorphic and formulates a set of eight generic to berefined functions as well as the proof obligations that thes e functions must satisfy.
over these generic functions an ex ecutable algorithm for pointer analysis is formalized and pr oven correct.
an instantiation thus defines an abstract domain and an implementation of the generic functions.
any instantiat ion that satisfies the proof obligations automatically constit utes a formally proven correct binary level pointer analysis.
as will be discussed later all the formalism and proofs are carried out in isabelle hol and have been shared with the readers.
we then provide three different instantiations of our gener ic functions each of which strikes a different balance in the trade off between precision vs. scalability.
first pointer computations form an abstract domain that keeps track of how pointers were computed highly precise but in practice one must cap the domain to a given size and produce top when 1measured over several coreutils binaries and firefox libra ries with different levels of optimization.that cap is exceeded.
second pointer bases form an abstract domain where each pointer is represented only by its pointer base e.g.
a stack pointer or the return value of a malloc more coarse as it cannot be used for alias analysis but still allows accurate separation analysis for binaries compile d from source code pointers based in different blocks can be assumed to be separate even if an out of bounds occurs .
third pointer sources are an abstract domain where a pointer is modeled by the set of sources e.g.
user inputs initial parameter values used in its computation.
this is highly coarse but is scalable and still allows a form of separation reasoning.
the pointer analysis presented in this paper is contextsensitive and compositional.
context sensitivity is desi rable since pointers are passed through from function to function .
we derive function preconditions which states that invariably a certain function is always called within in a context where e.g.
register rdi contains a heap pointer or register rsi contains a pointer to within the stack frame of the caller.
per function we can then derive a function postcondition that summarizes which regions were written to read from by the function and if after termination abstract pointers are le ft in return registers or global variables.
compositionally these summaries can then be used for pointer analysis for callers o f summarized functions.
due to space limitation we focus our presentation on intraprocedural analysis and do not expand on the above technique for composition.
bottom up pointer analysis i.e.
binary analysis in cont rast to top down source code analysis can be useful in various us e cases see section vi it can be integrated into a disassembly algorithm .
a large facet of disassembly is assessing which instruction addresses are reachable i.e.
control flow recovery .
a key challenge is resolving indirections i.e.
dynamicall y computed control flow transfers.
context sensitive pointe r analysis can assist by providing information on which pointers are passed to a function.
it can be a preliminary step to a decompilation effort .
specifically one of the steps in decompilation is to recover variables.
bottom up pointer analysis provides informati on on which memory writes actually constitute variables.
it can be the base of a bottom up dataflow analysis.
the function summaries already provide a form of dataflow analysis by providing information on in and output relations.
they can be used to verify whether functions adhere to a calling convention and to see which state parts are overwritten or preserved by a given function.
we also demonstrate by example that an overapproximative pointer analysis can be used for live variable analysis.
we emphasize the need for formally proven correct binarylevel pointer analysis.
symbolic treatment of pointers and memory is notoriously difficult.
existing approaches typic ally make various assumptions implicitly e.g.
they may implicitly assume a return address cannot be overwritten assume separation between pointers based on heuristics or best practic es or assume alignment of regions.
this paper aims to reduce the trusted code base by explicitizing such assumptions and eit her proving them through invariants or reporting them explicit ly otherwise.
the trusted code base is thus reduced to the valid ity of explicit and configurable assumptions such as regions based on stack pointers of different functions are assumed t o be separate .
limitations assumptions and scope.
a major assumption behind our approach is the treatment of partially overlapping memory accesses.
memory accesses reads or writes to partially overlapping regions may happen but we assume that they do not concern pointers.
more details can be found in section iii a. moreover our approach has been implemented for the x86 architecture and does not deal with concurren cy.
a fundamental limitation is that not all indirections may be resolved which may lead to unexplored paths.
the approach has been formally proven correct in isabelle hol and has been mirrored in haskell for experimental results.
these confirm soundness relative to a ground truth obtained by observing executions.
moreover t hey show precision comparable to or improved upon the stateof the art.
we evaluate the effect of interprocedural bott omup pointer analysis with respect to resolving indirections identifying cases where context sensitive informatio n allowed resolving a function callback.
finally for all analy zed functions it has been verified whether the result is sufficien tly precise to show that the return address has not been overwrit ten and that critical parts of the stack frame e.g.
storing non volatile register values are unmodified during execution o f the function.
this was successful for .
of all analyzed functions.
in summary we contribute aformally proven correct approach to binary level pointer analysis that leaves the abstract domain generic allowing easy development of instantiations with different charact eristics e.g.
different levels of preciseness an evaluation over roughly .
million assembly instructions showing scalability and applicability of the approa ch.
section ii studies the related work.
sections iii and iv provide details of our generic functions and their three differ ent levels of instantiation respectively.
section v demonst rates the realization of interprocedural pointer analysis throu gh our general functions.
while section vi looks at several use cases of the introduced approach section vii relates the experimental results to those produced by the state of the art tools currently available.
section viii concludes the pape r. ii.
r elated work source level pointer analysis has been an active research field for decades .
its typical use cases lie in top down contexts it takes as input source code and provides informati on to the compiler for optimizations and data flow analyse s. we here do not aim to provide an overview of this field since our work focuses on bottom up contexts taking as input a binary the result of pointer analysis provides informati on usable for decompilation and verification.generally source level approaches to program analysis cannot directly be applied to binary level programs .
various research therefore focuses on symbolic execution and or abstract interpretation specifically tailored to th e binary level.
we distinguish under approximative techniques from overapproximative ones.
in this discussion we specifically focus on how these techniques deal with pointers.
underapproximative approaches sage combines symbolic execution of assembly code with fuzz testing allowing exposure of real life vulnerabilit ies in real life software .
initially sage did not reason ab out symbolic pointer dereferences but it has been combined wi th yogi allowing runtime behavior observed from test cases to be used in refining abstractions to find whether pointers may be possibly aliasing .
s2e is a platform for traversing binaries allowing exploration of hundreds of thousands of paths using selective symbolic execution .
s2e provides an approach where dereferencing a symbolic pointer provide s next states with possible concrete values based on the symbo lic pointer and the current path constraints.
a similar approac h is taken by f uzzball a symbolic execution framework for binaries mainly concerned with improving the path coverag e of binary fuzzers .
it explores individual paths on e by one and chooses concrete values for offsets in pointers.
binsec is a code analysis tool with a focus on the security properties of binaries .
it has been applied to find use after free bugs and for reachability analyses .
symbolic execution is based on forking using an smt solver to prune infeasible paths.
b insec is based on bounded verification making it underapproximative.
kapus et al.
provi de an interesting approach by concretizing and segmenting the memory model so that symbolic pointers can only refer to single memory segments .
use of a test harness ensures both termination and that allocations always have a concret e size.
these methods underapproximate either by not exploring all paths or by underapproximating pointer values.
undera pproximation typically is very well suited for finding bugs an d vulnerabilities in software it leads to few false negative s and provides excellent scalability.
it is suitable in the conte xt of testing and binary exploration.
in contrast our pointer an alysis is overapproximative quantifying over all execution path s and all values.
this makes it suitable in the contexts of verifica tion and lifting to higher level representations.
overapproximative approaches control flow reconstruction.
overapproximative approaches to binary analysis are generally based on a form of abstract interpretation.
many approaches are aimed at control flow reconstruction and resolving of indirect branches.
by having abstract values represent a set of possible jump targets an indirection can be resolved by concretizing the abstract va lue to all instruction addresses it represents.
j akstab performs binary analysis and control flow reconstruction based on thi s principle .
the user manually provides a harness modeling the initial state and relative to that initial sta te the generated control flow graph overapproximates all paths in t hebinary.
pointer aliasing is dealt with by thrashing the symb olic state .
verbeek et al.
present an overapproximative approach to control flow reconstruction based on forking the st ate non deterministically .
their output can be exported t o the isabelle hol theorem prover where it can be formally proven correct.
an important use case for overapproximative contr ol flow reconstruction is trimming a binary by removing provably unreachable code.
b intrimmer uses abstract interpretation to prove the reachability of dead code and trim the binary accordingly.
using abstract interpretation for the purpose of control flow reconstruction i.e.
resolving of indirections is di fferent from using abstract interpretation for resolving designat ions of memory writes i.e.
pointer analysis .
it can be seen as a specific form of the more generic technique value set analysis vsa .
value set analysis.
various approaches use abstract interpretation to do vsa mapping state parts to abstract representations of a set of values that the state part may hold at a certain program point.
c odesurfer x86 utilizes as abstract domain a tuple storing a base and an offset .
the offset is modeled by an abstract domain that combines intervals and congruences.
frameworks such as bap and angr provide implementations of binary level vsa.
abstract domains are typically a form of signed agnostic intervals .
to our knowledge binpointer is the wor k closest related to the contribution in this paper.
kim et al.
provide binary level context insensitive pointer analys is in a sound and overapproximative fashion while also targeting scalability and evaluating preciseness of their produced o utput.
their abstract domain is conceptually equivalent to th e pointer bases domain presented in this paper which is als o similar to the abstract domain found in .
binpointer reac hes the conclusion of soundness by running test cases whi le we reach soundness through formal proofs.
summary of relation to overapproximative approaches.
existing approaches use abstract interpretation to recons truct control flow or to do vsa.
it is a well known issue that in realistic optimized and stripped cots binaries comput ations quickly become too complicated and obfuscated to be amenable for vsa sufficiently precise to enable reasoning over separation .
this paper presents the first approach to vsa that is formally proven correct that is generic wrt.
the abstract domain and that therefore allows different domain s with different levels of preciseness to be used.
to the best of our knowledge there exists no approach that can overapproximatively assign pointer designations to virtually all memory writes in large cots binaries in a context sensitiv e interprocedural fashion.
in section vii we aim to provide a more technical head to head comparison with existing tool s. iii.
o verview of generic constituents there are three major constituents required to formulate th e correctness theorem.
first of all a concrete semantics that provides a step function step over concrete states denoted by s s ... .
second an abstract semantics defined by .
anabstract step function step over abstract states denoted by ... and .
a join denoted .
third a concretization function sthat maps abstract states to sets of concrete states.
we prove the following two theorems theorem function sis asimulation relation between the concrete and abstract semantics s s step s s step this theorem shows that the abstract semantics overapproxi mate the concrete ones.
second we define an algorithm that performs symbolic execution while maintaining a mapping from the visited instruction addresses to the abstract states.
whenever an i nstruction address is visited twice the current abstract st ate is joined with the abstract state stored during the previous vi sit and the algorithm proceeds if the joined state is unequal to the stored one.
in essence this is a fixed point computation .
we prove theorem the mapping produced by the algorithm provides invariants sis reachable s s s.rip in words any concrete reachable state sis included in the set of states represented by the abstract state stored in map ping associated to its instruction pointer rip.
reachability means thatsis reachable from some unconstrained concrete state withripas the entry point through a path of resolved control flow transfers.
a. concrete semantics the concrete semantics are largely straightforward excep t for the treatment of partially overlapping memory accesses .
at the binary level any memory access occurs through pointer computations.
we formulate the assumption that any region in memory storing a pointer is from there on not accessed in a partially overlapping fashion .
for example consider a scenario where region an bracke le rsp0 an bracke ri h has been accessed denoting the byte region bytes below the original value of the stackpointer rsp .
from that point on regions an bracke le rsp0 an bracke ri h and an bracke le rsp0 an bracke ri h are still considered valid accesses.
region an bracke le rsp0 an bracke ri h is not as it partially overlaps with a previously accessed region.
as a consequence of this assumption any partially overlapping access is assumed no t to produce a pointer.
since we are interested in pointer analys is we therefore allow the concrete semantics to make values read from or written to by partially overlapping access to become tainted .
overapproximation then concerns untainted values only.
the concrete states stores concrete values denoted v. a concrete value is either an immediate bitvector or the speci al value tainted .
a concrete state contains an assignment of registers to concrete values.
concrete memory assigns conc rete values to concrete regions tuples of type v vcontaining the address and size of the region.
a priori no memory alignment information is available and thus concrete memor y must store concrete values as well as the current alignment.every read write updates the alignment information and tai nts values in memory accordingly.
the result is a type smodeling concrete states and function step a formal but fully executable semantics in which small assembly programs can be executed on concrete initial states.
b. abstract semantics the abstract state stores abstract values .
the datatype for abstract values denoted v is left completely polymorphic.
we assume existence of a special element.
over this datatype the following generic i.e.
undefined functions are assumed to be available vconcretization v maps o v s abstract semantics operation maps o v join v v maps o v separation an bracke le v v an bracke ri h an bracke le v v an bracke ri h maps o b enclosure an bracke le v v an bracke ri h an bracke le v v an bracke ri h maps o b aliassing an bracke le v v an bracke ri h an bracke le v v an bracke ri h maps o b for sake of presentation we omit functions used for getting initial abstract values.
function stakes as input the name of an operation executed by an assembly instruction e.g add .
note that a single assembly instruction may execute several such operations e.g.
imul .
function ssymbolically executes that operation on abstract values.
the separation enclosu re and aliassing relations are over abstract regions.
functio n r concretizes an abstract region an bracke le a si an bracke ri h by applying vto both the address and the size.
the above generic functions must satisfy a set of proof obligations.
most of these are trivial e.g.
the join must b e a commutative semigroup over v enclosure is transitive and reflexive .
we here provide some examples of interesting pro of obligations.
join separation enclosure aliasing and a bstract semantics must be overapproximative.
for separation this means that concretizing separate abstract regions must pro duce separate concrete regions note that concrete separation can be expressed in terms of linear equalities for non taint ed values.
for the semantics overapproximation is formulate d by stating that the result of applying some concrete operation square must be overapproximated by the semantics provided by s for the corresponding symbolic operation square.
here squarecan e.g.
be an arithmetic logical or bitvector operation.
the presentation shows binary operators but this easily exten ds to n ary operators.
finally there is a set of algebraic proper ties concerning the relations over regions such as enclosure i n separate region .
iv.
o verview of instantiations we provide three different instantiations each of which ha s been formally defined in isabelle hol and for each of which all proof obligations have been proven.
all three domains ar e represented by sets of elements from a different universe c b ands.
elements of these domains satisfy the following syntax c0 c1 ... constant computationc b0 b1 ... basesb s0 s1 ... sourcessthe join must be overapproximative v a0 v a0 a1 separation must be overapproximative r0 r1 r0 r r0 r1 r r1 r0 r1 semantics must be overapproximative v0 v a0 v1 v a1 v0 squarev1 v s square a0 a1 the join respects separation r an bracke le a0 a1 si an bracke ri h r an bracke le a0 si an bracke ri h the join respects enclosure an bracke le a0 si an bracke ri h an bracke le a0 a1 si an bracke ri h enclosure in separate region r0 r1 r1 r2 r0 r2 fig.
examples of proof obligations the abstract points first of all concern symbolic expression s denoted by type e. as operators symbolic expressions have arithmetic and logical operations bit level operations s uch as sign extension or masking and other operations related to x86 assembly instructions.
there is a dereference opera tor an bracke le e si an bracke ri h whereeandsiare symbolic expressions that models reading sibytes from address e. as operands symbolic expressions have immediate values state parts constants or heap pointers .
immediate values are words of fixed size.
state parts can be registers e.g.
rax edi ... or flags zf cf .
.
.
.
constants are values of state parts relative to the ini tial state.
for example rax0denotes a constant the initial value stored in register rax.
constants thus represent initial values of state parts when the current function was called.
a heappointer is an expression of the form alloc and models the return value of an allocation function such as malloc .
the idis an identifier to distinguish different mallocs.
a constant computation is a symbolic expression with as operands only immediate values and constants.
pointers with constant computations.
an expression of the syntax c0 c1 ... cis based on a non empty set of constant computations.
it non deterministically repre sents any value from the given set.
for example expression rsp0 rdi0 csimply represents any of the two constant computations.
this domain is the most concrete.
pointers with bases.
expressions of the form b0 b1 ... b partly abstract away from how the pointer is computed.
it keeps track only of positive addends in the computation that can be recognized as a basis for a pointer.
the given set is a non empty set of bases .
a base is defined by the following datastructure base stackpointer f globala allocid symbolname four types of pointer bases are recognized.
the base may be the stackpointer in x86 this is register rsp pointing to somewhere in the stackframe of a certain function f. the base may be a global address a. at the binary level the global address space is pointed to using immediate values and thus ais a bit immediate word.
the base may be the result of some dynamic memory allocation.
finally a base can be a named symbol.
at the binary level external variables are named symbols with immediate addresses.
note that any pointer will have at most one base.
for example no pointer computation would allow addition of the stack pointer and a heap address.
the datastructure allows a setof bases to allow the abstract pointer to non deterministic ally represent different pointers with bases.
pointers with sources.
expressions of the form s0 s1 ... sfully abstract away from how the pointer is computed.
whereas pointers with identifiable bases conta in sufficient information at least for roughly establishing a memory designation a pointer parameterized with sources only concerns what information has been used in the computation of the pointer.
in other words the pointer has been computed by some expression with operands from the given set of sources.
the following sources are possible source constant c baseb funname a source can be a constant a base or the return value of some function.
for example expression rdi0 rsi0 fungetc sindicates a pointer that has been computed using only the initial values of registers rdiandrsiand the return value of function getc .
example consider the running example in figure .
the example allocates memory and performs some memory writes.
two regions at addresses 0x3006 and0x3008 are relative to the initial value of the stackpointer rsp0.
the abstract pointers corresponding to these memory writes may be represented in c respectively rsp0 cand rsp0 c. the memory write at address 0x3005 occurs on the heap.
even ifoffset is some convoluted dynamically computed offset the abstract pointer will be representable in b alloc0x3003 b. finally the memory write at address 0x3007 writes to the address initially stored in register rdx plus the return value of function getc .
the abstract pointer is representable in s rdx0 fungetc s. a. separation over abstract pointers each of the three domains allows a different type of reasoning over separation.
intuitively separation betwe en two pointers implies that necessarily i.e.
for any address represented by the two pointers two memory writes commute.
separation is denoted by the infix operator .
consider two pointers p0 offset andp1.
if both pointers are defined by constant computations separation can be decided by an smt solver.
for the other domains however one may argue that separation cannot be guaranteed under any circumstances.
we argue this is too strict.
for example if one pointer is based on the heap and the other on the local stack then it is safe to assume that even if offset is chosen nefariously writes to the two pointers will either cause a0x3000 movrbp rsp 0x3001 callgetc 0x3002 movrcx rax 0x3003 callmalloc 0x3004 learsi 0x3005 movqptr rsi 0x3006 movqptr 0x2000 0x3007 movqptr rax 0x3008 movdptr a x86 assembly .rsp rsp0 c .rbp rsp0 c .rcx fungetc s .rax alloc c .rsi rsp0 c .
an bracke le alloc0x3003 b an bracke ri h rsp0 c .
an bracke le rsp0 c an bracke ri h global0x2000 b .
an bracke le rdx0 fungetc s an bracke ri h alloc c .
an bracke le rsp0 c an bracke ri h b abstract state fig.
assembly code.
for sake of presentation pseudo code is given on the right.
offset denotes some dynamically computed offset.
instruction lea loads an address into register rsi without reading from memory.
the binary has a data section wi th address range 0x2000 to0x2040 .
segmentation fault or they will commute.
assuming separati on is thus safe.
on the other hand we argue that if both pointers are based on local stackframes of different functions then assuming separation is dangerous as a stack overflow may cause the pointers to overlap.
it may be the case that separation is not necessarily true butdesirable .
consider a pointer with source set rdi0 .
the only way for that pointer to overlap with the stackframe of th e current function is if initially at the time the current fu nction was called register rdi contained a pointer to below its own stackframe.
that is invalid source code and can therefor e be considered undesirable.
for various use cases it can be useful to distinguish necessarily separation from desi rable separation see section vi .
for domains bands whether two abstract pointers are separate is in essence domain specific knowledge on what assumptions can validly be made when dealing with an x8664 binary.
in figure this knowledge will be encoded in algebraic definitions.
depending on ones view one may easil y add or remove cases of separation and move cases from desirable to necessarily or the other way around.
pointers with constant computations.
for two constant computations separation can be formulated as a linear programming problem solvable by an smt solver .
this requires the size of the regions pointed to to be known.
typically these sizes can syntactically be inferred from t he current instruction.
we define function smt as a function that takes as input two constant computations c0andc1 and two sizes si0andsi1and returns true if and only if the following smt problem is unsatisfiable c0 a c0 si0 c1 a c1 si1.
in words an address athat is in both regions should be unsatisfiable.
constant computati ons typically consist of arithmetic operations containing onl y and and bit level operations supported by smt theory qfbv.
pointers with bases.
separation for pointers with bases can be decided algebraically.
figure presents relation b i.e.
separation over bases.
the local stack frame of any function fis assumed to be separate from the global address space and th e heap.
as argued above separation over different stackfram es is desirable but not necessarily.
the global address space is assumed to be separate from the local address space and the heap.
the global address is not necessarily assumed to be separate from the symbols in the binary i.e.
external vari ables.
both are typically constant immediates within the range of addresses within the binary.
separation is considered to be desirable.
if two global addresses are based on immediates t hat fall within the range of different data sections of the binar y then separation is considered desirable.
two allocations with different ids are assumed to be separate as different ids ensure these were different calls to malloc .
a pointer based on malloc should not lead to a write overlapping with the region of a different malloc .
whether this separation should be considered necessary or desirable is debatable.
heap overflows are common and critic al vulnerabilities and if these are part of the attacker model then this separation should be considered desirable.
note t hat two pointers based on allocations with the same id are not necessarily notseparate.
pointers with sources.
since pointers with sources are more abstract there are fewer cases that allow deciding separation necessarily.
for example consider two pointer s with source sets rdi0 and rsi0 .
whether these can be considered separate depends on the initial state of the curr ent function i.e.
whether registers rdi andrsi initially were separate.
however there still are cases when separation ca n be decided.
first when two sources are actually bases the abo ve relation bcan used as decision procedure.
second consider a pointer computed using constant rdi0and a newly allocated pointer.
as long as the allocation happened within the curre nt function separation can safely be assumed essentially th is assumes that the initial state cannot predict where malloc will allocate memory.
since sources of the form funfdo not represent pointers separation between these sources a nd all other sources can be assumed.
finally consider a source rdi0 i.e.
the initial value of register rdi when the currentnecessarily stackpointer f ballocid stackpointer f bglobala stackpointer f bsymbolname globala ballocid allocid0 bsymbolname allocid0 ballocid1 ifid0 ne a ionslash id1 baseb0 sbaseb1 b0 bb1 constant c sbase alloc id ifidbelongs to current function funf ss1 desirable stackpointer f bstackpointer f iff ne a ionslash f globala bglobala ifaanda are from different data sections globala bsymbolname constant c sbase stackpointer fiffis current function fig.
separation over abstract pointers the smallest sym metric relation such that the above holds.
function was called.
it is possible that the caller initiali zed rdi with a pointer to the stackframe of the callee but we consider it undesirable.
example revisiting example we address the memory accesses in order of execution.
first a write happens to poin ter p0 alloc0x3003 b. then a write happens to pointer p1 rsp0 c stackpointer 0x3000 b. these two regions are necessarily separate for all three domains.
the n a write happens to pointer p2 rdx0 fungetc s. separation betweenp0andp2follows necessarily for domains bands.
however separation between p1andp2is not necessarily true.
it is however desirable .
finally a write happens to pointer p3 rsp0 c. similar reasoning applies for separation withp0andp2.
for domain c separation between p1andp3 is decided by an smt solver.
in similar fashion enclosure and aliassing are instantiat ed.
the join is defined as set union.
instantiating abstract sem antics and concretization is straightforward.
v. i ntraprocedural pointer analysis algorithmically intraprocedural pointer analysis can be achieved using a standard abstract interpretation algorithm .
essentially starting at some initial abs tract state with the instruction pointer set to the entry point of t he binary or a function of interest symbolic execution trav erses the assembly instructions step by step using function step.
it runs until a return statement or an exiting function call .
whenever an instruction address is visited twice the curre nt state curris compared to the state stored belonging to the previous visit.
if state stored is more abstract then state curr exploration can stop.
otherwise the two states must be joined to a state join.
that state is stored and exploration continues.
effectively this algorithm provides a partial mapping f rom instruction addresses to stored symbolic states.
a post st ate postis computed by taking the supremum of all terminal non exiting states.
thus we define state and a symbolic step function on top of the generic constituents.abstract states.
a state stores values for registers flags and memory.
an abstract state part is defined by the following datatype sp registerr flagf memory v n?
a memory statepart is represented as a region a tuple with an abstract pointer and optionally a size.
whenever clear fr om context we will omit the constructors.
for example sp rax simply means that statepart spequals register rax.
an abstract state is a partial mapping from stateparts to abstract value s s sp v.notation .rdenotes the current value stored in registerr.
memory partitions the address space into separate abstract regions and assigns stored values to each of these regions.
notation .
an bracke le r an bracke ri h denotes the value stored in region r where the size is omitted when not available.
example revisit the running example in figure .
based on the separation relations decided in example the state in figure 2b can model the state after execution of the assembly snippet.
note that this state is based on desirable separation as otherwise regions would need to get joined.
intuitively the following claims are modeled by this state any region based on a heap pointer allocated at line 0x3003 contains no pointers other than the pointer rsp0 .
the byte region at address rsp0 16stores a value that may point to the global data section.
a memory write has occurred that is determined by the initial value of register rdx as well as input provided via function getc .
that memory write was assumed to be separate from all others.
if the value stored in region an bracke le rsp0 an bracke ri h would be dereferenced then no information on its designation in memory is known.
the claims in the above example can be formalized by concretization of abstract states to concrete ones.
concretizationof state parts is provided by function spof typesp maps o 2sp sp registerr registerr sp flagf flagf sp memory r memory r r r r definition the concretization of states is function sof types maps o 2s and is defined as s s sp .sp v sp sp sp v v v s.sp v in words abstract state is mapped to any concrete state s in which both all stateparts and all stored values have been concretized.
abstract step function.
every assembly instruction can be written as a sequence of micro instructions of the follow ing form dst f in0 in1 ... a single destination be it a register a memory region or a flag gets assigned the return value of a pure operation fthat is based on zero or more input operands registers memory regions flags or immediate values .
the operation typically corresponds to a mnemonic e.g.
add orimul .
in x86 many but not all instructions have one destinatio n operand register or memory and may set a list of flags.
typically it cannot be the case that both destination and sources are memory.
we here make no assumptions and generalize the symbolic step function over any sequence of micro instructions.
transformation from basic assembly t o sequences of micro instructions can be done e.g.
using th e ghidra decompiler which translates assembly instructions of various architectures into low p code .
the semantics of executing a micro instruction consists of resolving the input operands applying operation f and writing the produced value to the state.
this is implemented in function step .
the abstract semantics sare used to apply operation fon abstract values.
functions read r and write r a are defined that take care of memory accesses in abstract states.
correctness and termination.
correctness the abstract semantics overapproximate the concrete semantics has bee n defined at the start of section iii and has been formally prove n correct in isabelle hol.
note that it may be the case that pat hs are unexplored due to unresolved indirections.
termination has also been proven but it requires the proof obligation that there does not exist an infinite chain of diff erent states such that 0 1 .... we thus ensure termination by putting bounds on the sizes of the sets of the abstract pointers.
these bounds are chosen manually.
they do not affect correctness.
making them larger makes the pointers more precise but increases running times.
for bounds c b andsthe bounds are resp.
and .
any pointer with more elements is shifted to .
vi.
u secases we here discuss several use cases with small pedagogical examples.integration into disassembly a fundamental problem in disassembly is resolving indirections.
typically indi rect jumps can be analyzed through intra procedural analysis.
for example they are the result of reading a jump table induced by aswitch statement.
for indirect calls however often inter procedural analysis is necessary.
an indirect call is often the result of a function callback.
these typically happen ac ross function boundaries a function pointer is passed from func tion to function until it is called.
this scenario mandates conte xtsensitive interprocedural analysis where the context prov ides sufficient information to resolve indirect calls.
function f 0x6000 mov qword ptr 0x6050 0x6001 call0x6500 0x6002 callexit ... 0x6050 pushrbp 0x6051 ... ... function g 0x6500 movrax qword ptr 0x6501 callrax 0x6502 ret fig.
example of indirect call figure provides an example.
function pointer 0x6050 is written to a global variable at address 0x2010 .
function h will be analyzed in a context where the pre state provides pre.
an bracke le global0x2010 b an bracke ri h 0x6050 c when symbolically executing the indirect call at line 0x6501 it is overapproximatively known that any pointer stored in the global address space based on address 0x2010 points to instruction address 0x6050 .
the recursive traversal can therefore consider 0x6050 as a reachable instruction address.
note that in a stripped binary functions are not delineated it is not known what addresses are function entries.
without context the indirect call at line 0x6501 cannot be resolved and the entire function at entry 0x6050 would have been missed.
section vii b provides data on how many indirection s can be resolved in practice.
preliminary to decompilation at the assembly level there are no variables.
bottom up analysis such as decompilation has no ground truth as to what regions in memory constituted variables.
a variable in source code typically is compiled to a memory region with the characteristic that th is region is separate from any memory write not to the same variable.
as example consider figure .
it shows assembly with some hypothetical pointer analysis result on the right .
based on the derived pointers a decompilation tool can assi gn a variable xto lines0x7000 and0x7002 .
bottom up dataflow analysis the post state produced by analysis of a function provides overapproximative insig ht into what parts of the state are modified by a function.
one0x7000 mov qword ptr 0x7001 mov qword ptr 0x7002 mov qword ptr a x86 assemblyx rsi x b decompiledrdi rsp0 c rsi allocid b rbp rsp0 c c abstract pointers fig.
assembly code decompiled to code with variables bas ed on abstract pointers.
application of this is that it can be used to verify whether a certain function abides by a calling convention.
the callin g convention designates certain registers to be non volatil e i.e.
they must be preserved by a function.
this can be observed from the post state directly.
if the post state provides th at for a register r post.r r0 c then this indicates that register r has been properly preserved.
many compilers use a push pop pattern to achieve such preservation a register value is in itially pushed to the local stack and popped just before return.
calling convention adherence requires abstract pointer an alysis to be sufficiently precise throughout symbolic execution th at the local region into which a register value is pushed is not overwritten.
a push pop pattern is not necessary though ou r approach is transparent to the means of register preservati on a function may use.
we provide an additional example demonstrating this overapproximative form of pointer analysis can be used for live variable analysis.
consider a function returning with the s tate in example .
the pointer allocated at line 0x3003 is stored in the return register rax and can therefore considered to be live.
however if the state overapproximately indicates th at the pointer is not returned and not written to global memory the pointer can be considered as not live after return of th e function.
finding suspect patterns for automated exploit generation pointer analysis can enhance real world downstream analyses.
as an example we consider automated exploit generation automatically finding bugs and generating work ing exploits .
one of the many challenges in this field is to deal with state space explosion.
our pointer analysis can be used to find patterns in the binary that may lead to vulnerabilities thereby pruning the state space to be expl ored.
as a concrete case study we can enumerate all instructions in a binary that do a function call to an external function and that pass a pointer to the current stackframe as parameter to that function.
this is a suspect pattern as the external fun ction has been given the opportunity to overwrite the return addre ss.
we have applied our pointer analysis to the ret2win challenge provide by rop emporium2.
the above heuristic finds an instruction at address 0x400701 call memset where register rdi the first parameter under the system v abi calling convention contains a local pointer.
indeed the example i s purposefully exploitable and the exploit leverages exa ctly this particular instruction.
e valuation in addition to the formal proofs of the soundness of our approach we provide a prototype implementation and conducted a series of experimental studies to evaluate soundness andpreciseness .
we run .
a comparative evaluation against the state of the art and .
a more in detail evaluation per instantiation .
a. comparative evaluation the closest related works to our binary pointer analyzer are binpointer and bpa .
unfortunately even after contacting the authors of the papers either their source co de was not available or the code was not runnable on our examples.
therefore to stay fair in our comparison we used the exact same dataset of binaries that binpointer and bpa used spec v1 and we employed the same definition of soundness and precision they used in their paper.
we map all abstract pointers to a subset of l g h for local global heap .
domains that are provably withi n the current stackframe are mapped to l domains that are relative to the stackpointer but that may possibly be above the current stack frame e.g.
point to the stackframe of a caller are mapped to l h .
global bases are mapped to g .
top is mapped to l g h the rest is considered heap and mapped to h .
this produces function pathat maps instruction addresses to observations.
to assess the ground truth we built an instrumentation tool based on the dynamic binary instrumentation tool pin .
each memory write observed at run time to some address a is mapped to an element of l g h .
ifrsp0 0x10000 a rsp0 address ais considered local here rsp0denotes the value of the stackpointer when the current function was called .
we cannot know how large the stackframe is and overapproximate the size with the constant 0x10000 for sake of observation.
if address ais a memory address covered by any of the sections where the binary is located at run time i t is considered global.
in all other cases address ais considered heap.
by running multiple executions each memory write is mapped to a subset of l g h as well.
this produces functiongtthat maps instruction addresses to observations.
the total set of instruction addresses of observed memory writes is denoted with w. soundness we consider a static pointer analysis to be sound if its results support the ground truth i.e.
the observati ons of pin.
in other words the pointer analysis must predict a superset of the ground truth.
soundness is computed using th erecall the percentage of supported memory writes to the total number.
if the recall is the pointer analysis is sound.
precision soundness does not imply usefulness.
for example if the pointer analysis returns for all the instructions it will be consider sound but useless.
we therefore measure precision as well.
in words precision measures the specificity of the returned pointer domains.
the precision is computed as the total average of the percentage of domains that pa overapproximated but were not observed by gt.
recall a w gt a pa a w precision avga w pa a gt a table i shows results.
the authors of binpointer have reported that the recall of their approach on the spec datase t is .
since we also observed the same recall for our approach on this dataset we do not include it in the table.
as the results show when it comes to heap and global memory accesses our approach achieves over a and15 higher precision compared to binpointer and bpa.
for the local memory accesses our approach shows almost similar precisi on compared to that of binpointer.
all other larger case studie s reported in are not publicly available.
interpreting a nd comparing their published results subjectively we conclu de that our work achieves at least similar precision.
the large st reported binary for binpointer is 161k instructions.
in the next section we show that our tool scales upto 507k instructions and we thus argue we are at least as scalable as well.
b. per instantiation evaluation we also evaluate per instantiation soundness and precision .
as case studies we consider a set of binaries covering over 1m instructions see table ii .
overall recall is .
we discuss precision in more detail see figure .
instantiation cis always precise as no abstraction is applied unless it assigns to a pointer.
it may assign e.g.
rsp0 0x3000 c in which case on different paths the pointer can be local or global .
of the overall memory writes .
overall instantiation cassigns a non pointer to .
of all memory writes.
instantiation b then only marginally improves that number.
it assigns pointers to .
more memory writes and for thos e only the base of the pointer is known.
however the value of this instantiation fluctuates per binary for some it did not improve on cat all but for others up to more memory writes got assigned a non pointer.
these are typically the hard cases e.g.
a local pointer to an array for which only a base could be established.
instantiation s finally assigns a non pointer to all memory writes.
figure shows that this mostly concerns heap pointers.
from this we can conclude that the cap on the number of sources is never hit since otherwise this instantiation would assign .
for those writes where both candbassign instantiation sat least provides us with information on which sources e.g.
function inputs or malloc s were used to compute the pointer value.a holistic way of looking at precision is .
to see whether the pointer analysis is sufficiently precise such that for ea ch function all its pointers are assigned a domain separate fro m the top of the stack frame where the return address is stored and .
that it enables resolving indirections.
table ii sho ws that for .
of all functions this was the case ok .
for .
of the functions not all indirections could be resolv ed un but all resolved paths ending in a return were ok. finally for .
of the functions our pointer analysis wa s not sufficiently precise to show that the return address was n ot overwritten err .
this typically happens for functions with complex stackpointer manipulation such as stack probing o r dynamic stack allocation.
viii.
c onclusion this paper presented an approach to formally proven correct binary level pointer analysis that aims to assign a designation to each memory write in a binary.
the designations are provably overapproximative the write provably cannot occur to any region in memory outside of its designation.
evaluation confirms this soundness and shows that precisio n is comparable to or improves upon the state of the art.
many existing approaches to binary analysis whether it is disassembly decompilation binary patching or securit y analysis are unsound.
state of the art tools apply heuri stics incorporate best practices and are generally based on exte nsive human in the loop knowledge.
decompilation becomes a for m of art rather than an algorithm.
we envision an overapproximative provably sound approach as an alternative.
this requires provably sound disassembly control flow reconstr uction decompilation and type inference to begin with.
at t he heart of all of these overapproximative techniques lies a pr oper understanding of the semantics of each individual instruct ion.
binary level pointer analysis aims to aid these future ende avors in overapproximative binary analysis by indicating what t he effect of each memory write in a binary can be.
data availability statement the implementation of the pointer analysis in this paper al l case studies and the formal isabelle hol proofs are availa ble anonymously at .