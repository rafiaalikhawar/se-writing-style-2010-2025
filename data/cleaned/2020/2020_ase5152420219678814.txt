race detection for event driven node.js applications xiaoning chang wensheng dou jun wei tao huang jinhui xie y uetang deng jianbo y ang jiaheng y ang state key lab of computer sciences institute of software chinese academy of sciences beijing china university of chinese academy of sciences beijing china nanjing institute of software technology nanjing china tencent inc. guangzhou china changxiaoning17 wsdou wj tao otcaix.iscas.ac.cn hugoxie yuetangdeng xiaotuoyang jiahengyang tencent.com abstract node.js has become a widely used event driven architecture for server side and desktop applications.
node.js provides an effective asynchronous event driven programmingmodel and supports asynchronous tasks and multi priorityevent queues.
unexpected races among events and asynchronoustasks can cause severe consequences.
existing race detectionapproaches in node.js applications mainly adopt random fuzzingtechnique and can miss races due to large schedule space.
in this paper we propose a dynamic race detection approach nrace for node.js applications.
in nrace we build precise happens before relations among events and asynchronous tasks innode.js applications which also take multi priority event queuesinto consideration.
we further develop a predictive race detectiontechnique based on these relations.
we evaluate nrace on real world node.js applications.
the experimental result shows thatnrace can precisely detect races and of them have beenconfirmed by developers.
index t erms node.js event driven architecture race detection i. i ntroduction node.js is an increasingly popular event driven architecture and widely used in server side and desktop applications.
the official node.js package manager npm has become the largest package registry and consists of more than 000building blocks in april .
nowadays professionaldevelopers use node.js to develop their frameworks librariesand tools .
industrial giants such as paypal uber and y ahoo also widely adopt node.js in their systems.
node.js adopts an event driven architecture and provides an effective asynchronous programming model.
in node.js time consuming io operations e.g.
file access operations canbe delegated as asynchronous tasks running in the dedicatedthreads in libuv .
thus node.js applications are not blockedby these time consuming io operations.
once an asynchronoustask completes a completion event is put into certain eventqueue.
different from other event driven architectures e.g.
client side javascript and android node.js pro vides multiple event queues which have different priorities.these events in different event queues are scheduled by thelooper thread i.e.
the main thread in node.js based on their wensheng dou and tao huang are the corresponding authors.priorities.
note that asynchronous tasks are concurrently exe cuted in the dedicated underlying threads which are differentfrom the looper thread.
the above asynchronous programming model in node.js can introduce races.
first since asynchronous tasks and theircorresponding events are executed asynchronously unorderedexecutions among events can cause unexpected interleavingsby developers thus taking the application into faulty states.second unordered asynchronous tasks and events can accessto the same external resource e.g.
files thus introducing races.races in node.js applications can cause severe consequences e.g.
unexpected application states and even worse systemcrashes .
as server side applications races in node.jsapplications may affect many end users.
thus it is importantfor node.js developers to automatically detect races in node.jsapplications.
existing approaches on race detection in event driven architectures mainly focus on client side javascript applications and android applications .
racedetection approaches in client side javascript applications mainly concern programming model features inbrowsers e.g.
dom and ajax.
race detection approachesin android applications mainly concernandroid gui model and the multi thread programming model.note that all these approaches only consider one event queue while node.js supports multiple event queues and schedules events with different priorities.
therefore it is challenging to apply these approaches to node.js applications althoughprogramming models of browsers android and node.js areconceptually similar.
recently a few race detection approacheshave been proposed for node.js applications.
node.fz adopts the fuzzing technique to randomly perturb event sched ules.
noderacer further utilizes happens before relationsto eliminate infeasible event schedules.
however they onlyexpose limited schedule space and miss races.
nodea v only detects atomicity violations in node.js and ignores otherkinds of races.
in this paper we propose nrace a predictive race detector for node.js applications.
given a node.js application nrace records its execution trace and builds precise happens before relations among asynchronous tasks and events.
further 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee .
.
.
.
.
.
.
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
fig.
.
a simplified node.js application.
a shows a simple web server and two requests.
b shows its execution process in which edata iandewrt irepresents the events for request reqi i .
we present actual file operations in capital letters i.e.
writefile andreadf ile and distinguish them from related api invocations e.g.
fs.writef ile .
nrace predicts races in alternative executions that satisfyhappens before relations.
nrace takes asynchronous tasks andmulti priority event queues into consideration and proposes anefficient algorithm to build and query happens before relationsin real world node.js applications.
to reduce benign races we further propose a few commutative race patterns based onfrequently observed benign races.
to demonstrate the effectiveness of nrace we evaluate nrace on real world node.js applications from two aspects.first we evaluate nrace for bug detection on known racesin real world node.js applications.
the experimental resultshows that nrace is able to effectively detect all knownraces while the state of the art fuzzing technique noderaceronly detects races in three hours.
second we further applynrace on open source node.js applications and detect 6previously unknown races of which have been confirmed bydevelopers.
nrace and its experimental subjects are availableat we summarize our main contributions as follows we propose a predictive race detector for node.js appli cations and build precise happens before relations thatcan handle asynchronous tasks and multi priority eventqueues in node.js applications.
we implement our approach as nrace and evaluate it onreal world node.js applications.
the experimental resultsshow that nrace can effectively detect races in real worldnode.js applications.
ii.
m otiv a tion in this section we present an illustrative example to explain the node.js event driven programming model and races risingin node.js applications.
a. motivating example figure a shows a simplified node.js web server application line and two requests for it line .
in this web server application it first uses api process.nexttick to register event e create of type nexttick line .
then it registers event etimeout of type timeout to execute after milliseconds line .
when processing ecreate the looper thread executes its callback create to write the default setting to variable prettyprint line and to create a server line .
the server registers evente data to process user requests line .
once a request arrives event edata is triggered.
the looper thread processes edata and executes its callback updatelog with parameter chunk which represents the received data of request.
callback 481updatelog parseschunk line and logs username into log file log.json line .
in order not to block the looper thread callback updatelog delegates the time consuming file writing operation as an asynchronous task asynctask to the thread pool and registers event ewrt to execute after the completion of asynctask line .
while the looper thread proceeds a thread in the thread pool asynchronously writes file log.json .
on the completion of asynchronous task asynctask event ewrt is triggered.
the looper thread executes its callback wrt to update the variable prettyprint according to the request line .
for each request two events edata andewrt and an asynchronous task asynctask are executed.
let s assume that two requests req1andreq2with different pretty print configurations simultaneously arrive line .
event edata andewrt and asynchronous task asynctask will be executed twice once per request.
for simplicity we denote edata i ewrt i andasynctask ifor each request reqi i .
once milliseconds elapse event etimeout is triggered.
the looper thread executes its callback show to synchronously read log file log.json line and print contentcont with the pretty print setting prettyprint line .
note that in node.js once an event is generated it is put into an event queue.
node.js maintains several event queues to hold different types of events i.e.
nexttick promise immediate timeout and io .
events in the same event queue are scheduled in the order that they are enqueued.
the looper thread processes immediate timeout and io event queues in a round robin manner.
when an event queueis exhausted or the number of processed events reaches athreshold the looper thread switches to process the next eventqueue.
however if there are events of nexttick type these nexttick events will be processed first before the loop thread processes any event .
therefore in figure a e create is processed before etimeout .
b. races in node.js applications for each request in figure a two events edata andewrt and an asynchronous task asynctask are executed in order edata asynctask ewrt.
however two executions of req1andreq2can interleave and thus cause races.
figure b shows an execution of races for two requests.
we can see threeraces in figure b .
event e timeout can be triggered before asynctask s completion event ewrt .
consequently event etimeout pretty prints the content of log.json .
compared with the execution shown in figure b this is a race between event etimeout andewrt 1on variable prettyprint causing the print format to be non deterministic.
asynchronous task asynctask 1andasynctask 2are concurrently executed in the thread pool and their processingorder in the file system is unknown.
thus the content offilelog.json is non deterministic.
this is a race between asynctask 1andasynctask 2on filelog.json .
event etimeout and asynchronous task asynctask 1can run concurrently.
their execution order in the file system isuncertain.
therefore this is a race between event e timeout and asynchronous task asynctask 1on filelog.json .
c. approach overview in order to detect races in node.js applications we need to address two technical challenges.
first in addition to memorylocations how can we model accesses on external resources e.g.
file log.json in figure a ?
as shown in the above example external resources are contended by events and asyn chronous tasks.
in node.js external resources are managedby underlying system and opaque to developers.
second node.js has its special execution mechanism for events andasynchronous tasks e.g.
the execution order between e create andetimeout caused by the multi priority event queues.
how can we design precise happens before relations among eventsand asynchronous tasks?
for the first challenge we study the file system apis in node.js and model them into several basic file access opera tions with various types e.g.
crate read write and delete.
then we further model these file access operations accordingto whether they are synchronous.
finally we build preciseconflicting patterns on these file access operations.
therefore we can detect races among events and asynchronous tasks onexternal resources.
second we build precise happens beforerelations among events and asynchronous tasks.
specially wedesign an efficient algorithm to build happens before relationscaused by multi priority event queues.
iii.
a pproach figure presents the overview of nrace.
given a node.js application with its test cases nrace can predictively de tect potential races.
first we run the node.js application toprofile its execution trace section iii a .
then we designhappens before relations for node.js applications which canreflect the partial order among events and asynchronous tasks section iii b .
we further design an efficient algorithm tobuild the happens before graph for the collect execution trace.
section iii c .
finally we detect potential races on conflictingoperations that are not ordered by the happens before graph section iii d and filter out benign races using predefinedcommutative race patterns section iii e .
a. trace collection an execution trace of a node.js application is a sequence of operations which are performed by events or asynchronous tasks.
in the following paper we uniformly call events andasynchronous tasks as actions for simplicity when we need to unify events and asynchronous tasks.
lifecycle related operations.
lifecycle related operations are used to control the generation and execution of events andasynchronous tasks.
we summarize them as follows.
start a start executing action a i.e.
an event or an asynchronous task.
482node.js application test casebug report trace collectionhappens before graph constructionrace detection pruning races fig.
.
the overview of nrace.
end a end executing action a i.e.
an event or an asynchronous task.
delegate e t eventedelegates asynchronous task tto the thread pool.
register ei ej eventeiregisters event ej.
there are two cases for event registration.
first event eiregisters eventejto execute after the completion of an asynchronous task.
for example edata 1registers ewrt 1for asynctask 1in figure .
second node.js allows developers to schedule events with several built in apis e.g.
process.nexttick setimmediate setinterval andsettimeout .
that said event ejis registered by event eiand will be executed after a period of time.
events registered by api process.nexttick setimmediate setinterval andsettimeout are of type of nexttick immediate and timeout1 respectively.
trigger t e eventeis triggered by the completion of asynchronous task tand put into the corresponding event queue.
trigger ei ej eventejis triggered by event eiand put into the corresponding event queue.
resolve e p when promise pis created a resolved eventp.resolved is registered to be executed once the promisepis resolved fullfilled .
resolve e p denotes that event eresolves promise p. pall promise.all apipromise.all returns promise pall which will be resolved after all promises p1 p2 ... pnare resolved or rejected after one of promises p1 p2 ... pnis rejected.
prace promise.race api promise.race returns promise prace which will be resolved or rejected after one of promises p1 p2 ... pn is resolved or rejected.
resource access operations.
resource access operations include memory access operations and external resource accessoperations.
we summarize them as follows.
read v val e eventereads memory location vand obtains value val .
we consider both reading variables and getting fields of objects as read operations.
write v val e eventewrites value val to memory locationv.
similarly we consider writing variables putting fields and deleting fields of objects as write operations.
fileaccess f type a actona i.e.
an event or an asynchronous task accesses file fwith access type type.
to model external resource accesses we map 1events registered by setinterval and sett imeout are of type timeout.each file system api into one or multiple operations.in particular we support seven access types on files i.e.
create open read write close delete and stat.
for example fs.readfilesync bar.txt invoked by event eis modeled as fileaccess bar.txt read e .
we model an asynchronous file access into a sequenceof lifecycle related operations and file access opera tions.
for example fs.readfile bar.txt cb invoked by event eis modeled as a sequence of operations delegate e t start t fileaccess bar.txt read t end t andstart cb wheretis the asynchronous task that performs the file access operation and cb is the completion event of asynchronous task t. other operations.
in addition to above operations we also track following operations which are used to filter benignraces in section iii e. conditional val e eventeperforms a if check and the checking result is val .
binary opt left right val e eventeperforms a binary operation whose left and right operands are left andright respectively.
the operator and result of binary operation is opt andval respectively.
in nrace we utilize async hooks to track lifecycle related operations.
async hooks provides several functions to record lifecycle related operations e.g.
init before after promiseresolve .
for example every time an eventeis registered function init is called to track the type of event eand the event that registers e. we further utilize jalangi to track the remaining operations.
for example jalangi records the names of variables and the values writteninto the variables for write operations so that it can track information for resource access operations.
b. happens before relation given an execution trace happens before relation is a partial relation among actions in trace i.e.
events and asynchronous tasks.
for action act iandactj we denote acti happens before actjasacti actj.
in addition we also build happens before relations over operations performed by actions.
for operation opiandopj we denote opihappens before opjasopi opj.
we overload happens before operator for both actions and operations.
rule transitivity the happens before relation is transitive i.e.
for action acti actjandactk i facti actk andactk actj thenacti actj.
rule program order operations performed by the same action are deterministically executed in the program order.
if operation opiandopjare executed by the same action andopioccurs before opjin trace thenopi opj.
483rule event atomicity each event is executed without interruption.
that said for operation opiandopjperformed by eventeiandejrespectively if opi opj then any operation ineihappens before any operation in ej.
rule event registration each event needs to be registered before it is processed.
that said if event ejis registered by event ei thenei ej.
rule setinterval if events e1 e2 ... enare registered in order via api setinterval then these events are executed in the registration order i.e.
ei ei for1 i n .
rule promise resolve if eventeiresolves promise p and event ejis the resolved event associated with promise p thenei ej.
rule promise all if promises p1 p2 ... pnare arguments passed to api promise.all and promise piis resolved by event ei thenpall is resolved after e1 e2 ... en.
in other words the resolved event eallassociated with pallis executed aftere1 e2 ... en.
therefore we build happens before relation ei eall where i n. rule promise race if promises p1 p2 ... pnare arguments passed to api promise.race and promise piis resolved by event ei thenprace is resolved after one of e1 e2 ... en.
in other words the resolved event erace associated with prace is executed after one of e1 e2 ... en.
we build the happens before relation among e1 e2 ... en anderace in an alternative manner.
we first check happensbefore relations among e1 e2 ... en.
if there exists two events eiandejsuch that ei ej then we remove the corresponding promisepjfrom arguments of api promise.race where i j n. if there is only one remaining promise pkas the argument of api promise.race we build happens before relationek erace .
rule asynctask delegation if eventedelegates an asynchronous task t thendelegate e t start t .
rule asynctask completion if the completion of asynchronous task ttriggers event e thent e. rule fifo events of the same type are put into the same event queue.
the looper thread processes events in the same event queue in fifo order.
for event eiandejwith the same type i.e.
nexttick immediate andpromise ifeiis registered before ejis registered then ei ej.i n particular for io eventeiandej i feiis triggered before ej thenei ej.
rule fifo timeout events of timeout type are also processed in the fifo manner.
for event eiandejoftimeout type ifeiis registered before ejis registered and the delay time ofeiis no more than that of ej thenei ej.
rule nexttick events of nexttick type hold the highest priority to be executed.
for event eiandej whereei is of nexttick type while ejis other types if eiis registered beforeejis executed then ei ej.
discussion.
some existing works e.g.
noderacer nodea v and asyncg also propose some happens before relations for node.js applications.
noderacer andasyncg only focus on happens before relations amongevents and ignore happens before relations between eventsand asynchronous tasks.
they also ignore happens before re lations among operations.
thus they do not contain happens before rule and .
nodea v treats asynchronous iotasks as synchronous operations and cannot reflect happens before rule and .
further nodea v does not supporthappens before rule and ignores the delay time inrule .
therefore these existing works lack some key happensbefore rules for detecting races in node.js applications.
ourhappens before relations can reflect the relations among eventsand asynchronous tasks and relations among operations.
thus our happens before relations are more complete and precisethan existing works.
we believe that our happens beforerelations can also benefit existing works.
c. happens before graph construction based on an execution trace we build a happens before graphg v e in which node v vis an action and edge e erepresents the happens before relation among actions.
noderacer and nodea v adopts the following algorithm to construct the happen before graph.
a the algorithm first adds all actions into the graph.
b then itbuilds happens before relations for simple rule and rule9 which do not depend on any other relations.
c next itbuilds happens before relations introduced by complex rules i.e.
promise race fifo fifo timeout and nexttick whichdepend on other relations.
the algorithm checks whether eachpair of actions satisfies one of complex rules.
if yes thecorresponding relation is added into the graph.
note that in step c the newly added relations may introduce other happens before relations on actions that wehave evaluated through complex rules.
therefore if step c finds a new relation the graph needs to be reprocessed again.in other words the graph is processed until no more relationis found.
the above recursive process is time consuming ifthere are many actions that can be applied for promise race fifo fifo timeout and nexttick rules in trace .
in order to efficiently build the happens before graph we design an algorithm scalable to real world node.js applica tions as shown in algorithm .
our algorithm reduces theoverhead of happens before graph construction from followingaspects incremental graph construction our algorithm starts withempty set of nodes and edges line and incremen tally builds the happens before graph in the trace order line .
after action act is added into graph line we only need to build happens before relations on a limited number of actions in the graph line instead of all of actions in noderacer and nodea v .
efficient rule matching given an action act w ee f fi ciently find action act primethat happens before act for both simple and complex rules line .
in particular itoptimizes the happens before relation construction forcomplex rules so that it does not perform the recursiveprocess and reduces the overhead which is done viafunctionbuildcomplexhb line .
484algorithm happens before graph construction input execution trace output g v e happens before graph 1v 2e 3fori i .length i do 4act 5v v act 6buildsimplehb v e act 7buildcomplexhb v e act 8end 9function buildcomplexhb v e act 10applyracerule act 11u selectunorderedaction act 12u prime sortunorderedaction u forj j u prime.length j do act prime u prime forrule complexrules do ifismatch act prime act rule then e e act prime act end end 20end efficient reachability query since there is a large number of actions in the happens before graph it is time consuming to perform the breadth first graph search toquery reachability.
we improve the breadth first searchby stopping exploring impossible paths in advance.
we illustrate the above three ingredients as follows.
incremental graph construction.
we observe that given an action act to be added into the graph only actions that occur before act in trace may happen before act.
otherwise trace will be infeasible.
based on this observation we incrementally build the happens before graph by adding one actionact into the graph according to the trace order line .
for each added action act line we only need to build happens before relations between action act and other actions in the graph.
note that event e race involved in promise race rule is processed differently because the relation caused by promise race rule on e race is determined after e1 e2 ... enthat are related to arguments of api promise.race are added into the graph.
therefore after all of e1 e2 ... enare added into graph we add erace into the graph and build happens before relations for it.
efficient rule matching.
given action act and rule rule we find action act primethat happens before action act and build happens before relation between act primeandact.
for simple rules we directly find action act primeand build happens before relation between act primeandact in a constant time.
for example when processing operationregister e e2 we store registrar information e1ine2.
when evaluating registration rule for e2 we find e1and obtaine1 e2directly.
we build happens before relations for asynctaskdelegation rule in a special manner.
for this rule wecannot obtain delegate e a start a because there are only actions but not operations in the happens beforegraph.
in order to build relations between eanda w e make a compromise nrace builds the edge from etoain the happens before graph.
we will handle this case whenquerying happens before relations among operations and itcauses no false happens before relation among operations.thus our race detection cannot be compromised.
for complex rules we first evaluate promise race rule for act line since the promise race rule only depends on the relation on the set of events corresponding to argumentsof apipromise.race which has been determined.
then we evaluate the remaining complex rules i.e.
fifo fifo timeout and nexttick rule for act line .
in order to avoid the recursive process our algorithm performsfollowing optimizations.
optimization find unordered actions.
as discussed earlier noderacer attempts to build relations for complex ruleson each pair of actions in step c and wastes time onevaluating pairs of actions that have already been ordered byhappens before relations.
this motivates us to avoid applyingcomplex rules on ordered actions.
we adopt chain decomposition to find unordered actions.
the idea of chain decomposition is to assign actionsto chains so that actions on the same chain are ordered byhappens before relations and actions on the different chainsmay be unordered.
we use a c to denote that action ais on chainc.
our chain decomposition algorithm is described as follows.
when we add action act into the happens before graph by simple rules we greedily assign action act to a chain.
i we first find the set of actions a where actions in ahave happensbefore edges with act.
ii if there exists an action act prime a after adding act intoact prime s chainc prime chainc primedoes not diverge then we assign act to chainc prime.
iii if such an action does not exist we create a new chain and assign act to it.
for example in figure before adding e7into the graph e1 e2 ... e 6are assigned to two chains c1andc2.
when adding e7into the graph we find e6 e7 and assigning e7to chainc2does not makec2diverge.
therefore e7is added into chain c2.
given a newly added action act function selectunorderedaction line finds actions which are unordered with act.
letcact denote the chain that act belongs to i.e.
act c act.
for each chain cthat is different from cact we identify its unordered actions with act through the following process.
we find the last action acti inc which satisfies the following condition actj cact acti actj actj act actj act .
actions that happen afteractiin chain care unordered with act.
for example in figure when action e7is added into the graph we find thate6happens before e7on chain c2 ande2on chain c1 happens before e6.
therefore e3ande4on chain c1are unordered with e7.
485 fig.
.
a happens before graph example with chain decomposition.
two chains c1andc2are denoted by light grey and dark grey respectively.
optimization determine action evaluation order .
as discussed earlier noderacer recursively applies complex rules until the graph reaches a fixpoint.
in order to avoid the recur sive process we determine an evaluation order for unorderedactions via function sortunorderedaction line .
for actionact a actb u i fact ahappens before actbon the same chain actais sorted before actbinu prime.
then we apply complex rules between action act prime u primeandact line .
note that the newly added relation on act primeandact only introduces relations on actions that are registered by act prime.f o r example in figure if we add the relation from e3toe7 denoted as e3 e7 which is not present in the graph relation e3 e7 only introduces relations on actions registered by e3 e.g.
e4.
these successor actions happen after act primeand are not evaluated.
therefore if we evaluate actions following thechain order we do not need to recursively evaluate complexrules on the graph.
efficient reachability query.
the reachability among nodes in the happens before graph greflects happens before relations among events and asynchronous tasks.
for node uand v iff there is a path from utoving u v. we adopt breadth first graph search to query reachability in the happens before graph g. the breadth first graph search has a maximum time complexity of o e .
however since node.js applications generates a large number of actions in ashort time there is a large number of nodes along with edgesin the happens before graph.
the breadth first graph searchdoes not scale to real world node.js applications.
we observe that if node n kdoes not occur before node nj in the trace denoted as nk nj thennk njand there is no path from nitonjthroughnk.
based on this observation to speed up querying reachability from node nito nodenj we stop traversing to node nk wherenk nj.
the benefit is that we stop exploring impossible paths in advance thusimproving efficiency.
based on happens before relations among actions we can determine happens before relations among operations.
foroperation op iandopj opi opjif opiandopjare performed by the same action and opi opjor opiandopjare performed by different actions and action opi action opj whereaction op denotes the action that performs operation op.
when querying reachability we deal with the compromise case introduced by asynctask delegation rule whenbuilding the happens before graph.
if action op i delegatest able i file access conflicting p a tterns create delete read write open close stat create diamondmath diamondmath diamondmath diamondmath diamondmath diamondmath diamondmath delete diamondmath diamondmath diamondmath diamondmath diamondmath diamondmath diamondmath read diamondmath diamondmath diamondmath diamondmath diamondmath write diamondmath diamondmath diamondmath diamondmath diamondmath diamondmath open diamondmath diamondmath diamondmath diamondmath diamondmath close diamondmath diamondmath diamondmath diamondmath diamondmath diamondmath stat diamondmath diamondmath if two types intersect at diamondmath they form a conflicting pattern.
action opj and the delegation operation occurs before opiin action opi thenopi opj.
we define concurrency relation as con opi opj op i opj opj opi.
that said if neither opihappens before opj noropjhappens before opi opihas the concurrency relation withopj.
we can further refine the above concurrency relation ascon opi opj op i opj opi opj opj opi opj opi to reduce the number of reachability queries.
d. race detection in node.js applications conflicting operations can be operations that access to memory locations and external resources e.g.
files.
we explain them as follows.
conflicting memory access operations.
two memoryaccess operations conflict when they access the samememory location and at least one of them is write operation.
conflicting file access operations.
we define file con flicting patterns based on the equivalent influence ofaccess type on file system.
the file conflicting patternsare shown in table i. two file access operations conflictwhen they access the same file and their access typematch one of our predefined conflicting patterns.
notethat our pattern is more powerful than nodea v in which file access operations are only modeled as read and write.
for example fs.statsync is modeled as an operation of read and fs.writefilesync is modeled as an operation of write.
however they do not conflict in fact.
our file conflicting patterns can precisely describethis un conflicting case.
consider two operations op iandopj a race exists betweenopiandopj denoted as race opi opj if they conflict and opihave concurrency relation with opj i.e.
con opi opj true.
we first process the observed trace to obtain the set of operations that access the same resource x op x opi opiaccesses resource x .
for each pair of operations opi opj inop x we check whether they have concurrency relation i.e.
con opi opj true.
e. pruning races we observe that the above detection approach by finding unordered conflicting operations leads to many benign races.we find that some commutative operations do not need to beordered by happens before relations to ensure correctness.
to !
!
!
fig.
.
commutative pattern summarized from ad hoc synchronization where eirepresents event e1ande2.
address this issue we summarize three commutative patterns to automatically filter benign races.
sequentialize actions.
node.js developers often utilize adhoc synchronization to force multiple actions to execute insequence.
for instance in figure event e 1ande2is registered by api setimmediate andsettimeout respectively line .
event e1ande2delegates asynchronous file writing task asynctask 1andasynctask respectively line .
if one event e.g.
e1 launches an asynchronous task e.g.
asynctask variable is set totrue.
if another event e.g.
e2 is executed before the previous asynchronous task e.g.
asynctask completes it does not launch its asynchronous task e.g.
asynctask .
in this way developers prevent multiple asynchronous tasks from being concurrentlyexecuted.
therefore although event e 1has a race with event e2on variable there is no harmful impact on the application.
to detect this benign race we analyze conditional and write operations to identify the variable that sequentializes actions.
ifa variable vis read in the conditional operation and two write operations on variable vhappen before and after an action respectively then variable vprotects actions from races.
any race on this variable is regarded as a benign race.
in our approach we utilize jalangi to record conditional operations.
since jalangi only records values but not variables for conditional operations we utilizeread x r valr e operation that occurs before conditional valc e to infer the variable accessed by the conditional operation.
if valr valc then variable vr accessed by read operation is regarded as the variable accessed by conditional operation.
use counters.
node.js applications often utilize counters.
one case is that multiple events increase a counter.
nomatter which order these events are executed in the counteris correctly increased.
another case is that after a node.jsapplications increases a counter it checks whether the valueof the counter equals to a given threshold.
if true the programwill execute some functions.
these read andwrite operations on the counter have no harmful impact on the application since the counter does not reach the threshold.
a variable vis a counter variable if it satisfies the following conditions.
a v ariable vis used by three operations insequence i.e.
read binary andwrite .
b v ariable vis read by aread operation and written by a write operation.
c binary operation s operator is addition or subtraction i.e.
or and its two operands are of type number .
d binary operation s left operand or right operand uses variable v and its return result uses variable v. similar to conditional operations jalangi only records values but not variables for binary operations.
we utilize read x r valr e andwrite xw valw e operation that occur before and after binary op left right val b e to infer the variable accessed by binary operation.
if varr left or varr right we treat variable vris used as left or right operand of binary operation.
if varb valwwe treat variable xwis used as return result of binary operation.
write shared resource with the same value.
some operations are commutative because they write the sharedresource with the same value.
the shared resource holdsthe same value no matter in which order two events areexecuted.
therefore for two operations write x val e1 andwrite x val e2 if they are unordered and val1equals toval2 we regard them as commutative operations.
note that the commutative patterns we design are not sound.
without mining developer intention and semantics ofoperations we cannot ensure the commutativity between ac tions and operations.
for example counter variables identifiedby our patterns are only self increasing counters and actualcounters are missed.
however we manually inspect benignraces reported in our evaluation and find our patterns canidentify more than half of benign races.
iv .
e v alua tion our evaluation answers the following research questions rq1 can nrace detect known races in real worldnode.js applications?
how does nrace compare with thestate of the art fuzzer noderacer ?
rq2 can nrace detect previously unknown races inreal world node.js applications?
rq3 what is the runtime overhead of nrace comparedwith noderacer ?
a. experimental setup dataset known races.
to evaluate whether nrace can detect known races in real world node.js applications wecollect known races from noderacer .
noderacerprovides known races in node.js applications along withtheir test cases.
since one of these node.js applications linter stylint cannot be profiled via async hooks module we only perform the evaluation on node.js applications asshown in table ii.
column project refers to applications column description gives a brief description of each application column issue id shows the issue report id in github and column category denotes locations where races happen.
event and async denotes races happen on events and asynchronous tasks respectively.
dataset unknown races.
to evaluate whether nrace can detect previously unknown races in real world node.js 487t able ii da t aset k nown races in real w orld node .jsapplica tions id project description issue id category agentkeepalive support keepalive http agent event fiware pep steelskin tid s implementation of fiw are pep ge event ghost the headless cms for publication event node mkdirp like mkdir p but in node.js async nes a websocket adapter plugin event node logger file file endpoint for cinovo logger async socket.io real time application framework event del delete files and directories async simplecrawler flexible event driven crawler for node.js event xlsx extract extract data from xlsx files async t able iii da t aset r eal w orld node .jsapplica tions id project description star loc nedb a javascript database node http proxy a full featured http proxy baobab javascript persistent data tree simplecrawler flexible event driven crawler for node.js serve static serve static files nodejs websocket a websocket server and client module ncp asynchronous recursive file copying line reader asynchronous line by line file reader json file store a simple json store fiware pep steelskin tid s implementation of fiw are pep ge applications we collect node.js applications from github that satisfy following conditions the application is able torun on node.js .
or above which supports the async hooks module to track events.
the application offers available testcases so that we can use them to drive the application to collectexecution trace.
finally we collect node.js applications asshown in table iii.
column project refers to the application column description gives a brief description of the application column star shows the number of stargazers on github and column loc presents lines of javascript code computed by tool cloc .
we can see that most of experimental applications are popular.
we conduct our experiments in following steps.
first we utilize nrace to instrument the source code of the targetapplication and utilize the test case to drive the application tocollect execution trace.
second we run nrace to analyze theobserved trace.
to answer rq1 we use nrace and noderacerto detect known races on the dataset .
to answer rq2 weperform nrace on dataset to detect previously unknownraces.
for both rq1 and rq2 we manually inspect the codeto validate whether each detected race is real.
to answer rq3 we measure the runtime overhead of nrace and noderacer.
inparticular in order to compare the overhead of happens beforegraph construction between nrace and noderacer weimplemented the happens before graph construction algorithmadopted by noderacer because the data structure of traceand happens before graph of noderacer is different fromours and cannot be integrated into nrace.
we compare theruntime overhead of our proposed happens before constructiont able iv detection resul t on da t aset idnrace noderacer detected total hr br fp detected y es no y es ye s y es ye s y es ye s y es ye s y es no y es no y es ye s y es ye s y es no total algorithm and noderacer s algorithm.
all experiments wereconducted on core .4ghz with 16gb memory runningmacos catalina release .
.
.
b. detect known races we run nrace on dataset to measure the nrace s ability to detect known races.
the result is shown in table iv.
columns present the result of nrace where columndetected indicates whether the known race is detected by nrace.
column total presents the total number of races that nrace reports calculated by hr br fp where hr br and fp represents the number of harmful races benign races and false positives reported by nrace respectively.
note that the known race is included in hr and the number of benign races automatically identified by nraceis shown in the bracket in column br.
488as shown in table iv nrace detects all known races.
we further report new races from node.js applications.
after manual inspection we find these new races can beclassified into three categories harmful races benign racesand false positives.
all of newly detected harmful races are side effect races of the known races.
for example in project fiware pepsteelskin once a request req returns event e req writes variable currenttoken with returned data.
however if there are two requests req1andreq2 the execution order between event ereq1andereq2is non deterministic.
if event ereq2is executed before event ereq1 ereq1overwrites variable currenttoken with returned data of req1 making request req2hangs.
one of side effect races is that if event ereq1throws an error after ereq2 it also overwrites currenttoken withnull making req2hangs.
as shown in table iv out of newly detected races are benign races which is consistent with the fact that there isa large number of benign races in node.js applications.
mostof these benign races are automatically identified bynrace.
false positives are determined by manual reproduction or related code review.
as shown in table iv nrace reports6 false positives.
these false positives are caused by ad hocsynchronization.
for example in project simplecrawler event e add caches a url for crawling in future and event ereq invokes a request to crawl a given url.
if event ereq is executed before eadd eventereq will find that there is no url under crawling.
thus it will invoke stop method to end up crawling.
as a result event eadd will not occur any more.
note that although we have detected all known races in our experiment as a dynamic approach we can still miss races ifthe provided test cases do not cover race related events.
comparison with noderacer.
in order to compare nrace with the state of the art fuzzer noderacer we utilize noder acer to detect races in runs and set one hour as timeoutfor it.
if noderacer does not detect a known race in one hour we regard that noderacer does not detect the race.
column of table iv indicates whether the known race is detected by noderacer.
as shown in table iv noderacercan only detect out of within the given timeout.
we investigate why noderacer fails to find four bugs in our experiment and find three reasons.
first although noderacereliminates the schedule space with the help of happens beforerelations it can still miss races because of the large schedulespace.
for example there are events in project socket.io.
under the guidance of happens before relations the number ofpossible event schedules is .
so runs only explores0.
of the schedule space.
second noderacer only fuzzesthe execution of events but does not perturb the execution of asynchronous tasks which further reduces the possibility toexpose races on external resources e.g.
the missing races inproject node logger file and xlsx extract.
further noderacer can miss races if it runs out of time e.g.
the missing race inproject agentkeepalive.
this result demonstrates that nrace ist able v detection resul t on da t aset id project total hrace brace fp nedb node http proxy baobab simplecrawler serve static nodejs websocket ncp line reader json file store fiware pep steelskin total more effective than noderacer to detect races in real world node.js applications.
c. detect unknown races we run nrace on dataset to measure the nrace s ability to detect previously unknown races.
column total in table v shows the number of detected races.
as shown in table v nrace detects races on dataset in total.
after manualinspection we classify detected races into three categories harmful races benign races and false positives the numberof which is shown in column hrace brace and fp respectively.
similarly the number of benign races automaticallyidentified by nrace is shown in bracket in column brace.
nrace detects harmful races in project json file store and fiware pep steelskin.
for example in json file store event e sv saves data with id myid into the json file and event erm deletes data with the same id.
the unordered event esvand erm make the content of the json file non deterministic.
we have submitted these detected races to developers.
five racesin project fiware pep steelskin is acknowledged by developers.
table v shows that nrace reports false positives which are also caused by ad hoc synchronization as discussed indataset .
nrace detects benign races.
for example in project nodejs websocket event e beg asks the connection to begin transmitting data and event ecls closes the connection.
consider event ecls is executed before ebeg to set variable state toclosing .
when event ebeg is executed it reads variable state and finds variable state does not equal to open i t does not send data.
therefore the race between event ebeg and eclshas no harmful impact on the application.
nrace automatically identifies out of benign races.
more commutativepatterns could be designed to enhance our approach.
d. overhead in table vi columns report the performance of nrace where column tc hbc dp and tdenotes the time for trace collection happens before graph construction offline race detection along with pruning and the total time calculatedbytc hbc dp respectively.
as shown in table vi nrace detects races within a few seconds.
the overhead in nrace is introduced by trace collec tion and happens before graph construction for example in 489t able vi runtime overhead on da t aset idnrace s noderacer s speedup tc hbc dp t hbc t hbc t .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
t trace collection b happens before graph construction dp race detection and pruning t total time.
project xlsx extract which consumes the most time on happenbefore graph construction there are events of which are immediate events.
as discussed before fifo and nexttick rules need to be applied to immediate events.
it takes much time to repeatedly evaluate these two rules.
we compare the performance of nrace with noderacer on dataset .
in table vi columns present the overhead ofnoderacer where column hbc and tdenotes the overhead of the happens before graph construction algorithm and the totalruntime respectively.
columns show nrace s speedupcompared with noderacer where column hbc and tdenotes the speedup in happens before graph construction and the totalruntime respectively.
on the one hand our proposed happens before graph construction algorithm performs much faster than the algorithm ofnoderacer from 1x to 89x .
since project node mkdirp and project del have a small number of events there is little difference between the overhead of our proposed algorithm andnoderacer s algorithm in these two projects.
our proposedalgorithm is efficient in happens before graph construction fornode.js applications.
one the other hand since noderacer repeatedly executes the application it has large overhead.
as shown table vi it spends nearly three hours to detect races.
as shown incolumn nrace performs much faster than noderacer from10x to 769x .
these results demonstrate that nrace is moreefficient in detecting races in real world node.js applications.
e. threats to v alidity the threat to validity is the representativeness of experimental projects.
first races selected in the evaluation come from real world node.js applications and have been studied byprevious work nodecb and noderacer .
we believethese races represent real world bugs.
second since most ofour selected node.js applications have an amount of stars webelieve they are popular and representative.
v. r ela ted work in this section we discuss related works close to ours.
event race detection.
cafa and droidracer build happens before relations among events which account foronly one event queue.
eventtrack maintains a subset of happens before relations to optimize happens before graphconstruction.
sierra reifies threads events and useractions as actions and statically builds happens before relationsto improve precision.
these existing approaches on androidapplications cannot deal with multi priority event queues.
webracer formalizes the happens before relations with web features.
eventracer proposes race coverage toreduce the number of false positives and takes advantage ofchain decomposition to decrease the overhead of reachabilityquery.
w a ve records a sequence of operations andcontrols the target program to execute the observed operationsto detect event races.
arrow further statically detectsevent races and automatically repairs them.
these approachesmainly focus on programming model features of browsers such as dom and ajax.
therefore they cannot be appliedon node.js applications.
concurrency bug detection on node.js applications.
nodecb presents an empirical study on concurrencybugs on real world node.js applications and shows light onconcurrency bugs in node.js applications.
proposes aparallel programming abstraction gems.
proposes asyncgraph to reason about event behaviors.
nodea v candetect atomicity violations and does not consider other kinds ofraces.
node.fz and noderacer fuzzes the executionorder of events to expose races.
due to randomness theycannot deterministically find bugs.
in contrast our approachcan systematically explore all the scheduling space of eventsand asynchronous tasks.
vi.
c onclusion node.js applications are increasingly popular and are widely used by many developers and industrial giants.
these ap plications are written in an asynchronous event driven ar chitecture and suffer from races.
in this paper we proposenrace to detect races based on an observed execution trace.we build precise happens before relations among events andasynchronous tasks in node.js applications which supportsmulti priority event queues.
we further develop a predictiverace detection technique based on happens before relations.we evaluate nrace on real world node.js applications andexperimental results show it can detect known races as wellas unknown races.
vii.
a cknowledge we thank y ushan zhang and y u gao for providing insightful comments about this work.
this work was partially supportedby national key r d program of china 2017yfb1001804 national natural science foundation of china foundation of science and technology on paral lel and distributed processing laboratory frontier science project of chinese academy of sciences qyzdj ssw jsc036 and y outh innovation promotion as sociation at chinese academy of sciences .
490references the npm repository.
.
available node.js stats that prove its awesomeness in .
.
available node.js at paypal.
.
available com node js at paypal node.js at uber.
.
available wp content uploads sites nodejs at uber.pdf node.js at y ahoo.
.
available node js on the road boston node js at yahoo libuv.
.
available b. petrov m. t. v echev m. sridharan and j. dolby race detection for web applications in proceedings of acm sigplan conference on programming language design and implementation pldi pp.
.
c. hsiao c. pereira j. y u g. pokam s. narayanasamy p .
m. chen z. kong and j. flinn race detection for event driven mobile applica tions in proceedings of acm sigplan conference on programming language design and implementation pldi pp.
.
p .
bielik v .
raychev and m. t. v echev scalable race detection for android applications in proceedings of acm sigplan international conference on object oriented programming systems languages andapplications oopsla pp.
.
j. wang w .
dou y .
gao c. gao f. qin k. yin and j. wei a comprehensive study on real world concurrency bugs in node.js inproceedings of ieee acm international conference on automated software engineering ase pp.
.
j. c. davis a. thekumparampil and d. lee node.fz fuzzing the server side event driven architecture in proceedings of european conference on computer systems eurosys pp.
.
y .
zheng t. bao and x. zhang statically locating web application bugs caused by asynchronous calls in proceedings of the international conference on world wide web www pp.
.
v .
raychev m. v echev and m. sridharan effective race detection for event driven programs in proceedings of acm sigplan international conference on object oriented programming systems languages andapplications oopsla pp.
.
s. hong y .
park and m. kim detecting concurrency errors in client side javascript web applications in proceedings of international conference on software testing v alidation and v erification icst pp.
.
e. mutlu s. tasiran and b. livshits detecting javascript races that matter in proceedings of joint meeting of european software engineering conference and acm sigsoft symposium on the f oundationsof software engineering esec fse pp.
.
c. q. adamsen a. m ller and f. tip practical initialization race detection for javascript web applications proceedings of acm sigplan international conference on object oriented programming systems languages and applications oopsla vol.
pp.
.
c. q. adamsen a. m ller s. alimadadi and f. tip practical ajax race detection for javascript web applications in proceedingsof joint meeting of european software engineering conference andacm sigsoft symposium on the f oundations of software engineering esec fse pp.
.
p .
maiya a. kanade and r. majumdar race detection for android applications in proceedings of acm sigplan conference on programming language design and implementation pldi pp.
.
y .
hu and i. neamtiu static detection of event based races in android apps in proceedings of international conference on architectural support for programming languages and operating systems asplos pp.
.
y .
hu i. neamtiu and a. alavi automatically verifying and reproducing event based races in android apps in proceedings of international symposium on software testing and analysis issta pp.
.
a. t. endo and a. m ller noderacer event race detection for node.js applications in proceedings of international conference on software testing v alidation and v erification icst pp.
.
x. chang w .
dou y .
gao j. wang j. wei and t. huang detecting atomicity violations for event driven node.js applications in proceedings of international conference on software engineering icse pp.
.
m. c. loring m. marron and d. leijen semantics of asynchronous javascript in proceedings of acm sigplan international symposium on on dynamic languages dls pp.
.
promise.
.
available web javascript reference global objects promise node.js documentation about async hooks.
.
available hooks.html k. sen s. kalasapur t. brutch and s. gibbs jalangi a selective record replay and dynamic analysis framework for javascript inproceedings of joint meeting of european software engineering conference and acm sigsoft symposium on the f oundations ofsoftware engineering esec fse pp.
.
h. sun d. bonetta f. schiavio and w .
binder reasoning about the node.js event loop using async graphs in proceedings of international symposium on code generation and optimization cgo pp.
.
cloc count lines of code.
.
available aldanial cloc p .
maiya and a. kanade efficient computation of happens before relation for event driven programs in proceedings of acm sigsoft international symposium on software testing and analysis issta pp.
.
w .
wang y .
zheng p .
liu l. xu x. zhang and p .
eugster arrow automated repair of races on client side web pages in proceedings of international symposium on software testing and analysis issta pp.
.
d. bonetta l. salucci s. marr and w .
binder gems shared memory parallel programming for node.js in proceedings of acm sigplan international conference on object oriented programming systems languages and applications oopsla pp.
.