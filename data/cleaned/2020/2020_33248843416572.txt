zeror speed up fuzzing with coverage sensitive tracing and scheduling chijin zhou kliss bnrist school of software tsinghua university beijing china zcj18 mails.tsinghua.edu.cnmingzhe wang kliss bnrist school of software tsinghua university beijing china wmzhere gmail.comjie liang kliss bnrist school of software tsinghua university beijing china liangjie.mailbox.cn gmail.com zhe liu computer science and technology nuaa nanjing china zhe.liu nuaa.edu.cnyu jiang kliss bnrist school of software tsinghua university beijing china jiangyu198964 .com abstract coverage guidedfuzzingis oneofthemost popularsoftwaretesting techniques for vulnerability detection.
while effective current fuzzingmethodssufferfromsignificantperformancepenaltydue toinstrumentationoverhead whichlimitsitspracticaluse.existing solutions improve the fuzzing speed by de creasing instrumentation overheads but sacrificing coverage accuracy which results in unstable performance of vulnerability detection.
inthispaper weproposeacoverage sensitivetracingandscheduling framework zerorthat can improve the performance of existing fuzzers especially in their speedand vulnerability detection.
the zeroris mainly made up of two parts a self modifying tracing mechanism to provide a zero overhead instrumentation for moreeffectivecoveragecollection and areal timescheduling mechanism to support adaptive switch between the zero overhead instrumentedbinaryandthefullyinstrumentedbinaryforbetter vulnerabilitydetection.inthisway zerorisabletodecreasecollectionoverheadand preserve fine grainedcoverageforguidance.
forevaluation weimplementaprototypeof zerorandevaluate it on google fuzzer test suite which consists of widely used applications.
the results show that zerorperforms better than existingfuzzingspeed upframeworkssuchasuntracerandinstrim improvestheexecutions peedofthe state of the artfuzzerssuchas aflandmoptby159.
helpsthemachievebettercoverage averagely .
for afl .
for mopt and detect vulnerabilities faster averagely .
for afl .
for mopt .
ccs concepts security and privacy software security engineering.
yu jiang is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtualevent australia association for computing machinery.
acm isbn ... .
coverage guided fuzzing coverage sensitive tracing scheduling acm reference format chijin zhou mingzhe wang jieliang zhe liu and yujiang.
.
zeror speed up fuzzing with coverage sensitive tracing and scheduling.
in 35th ieee acm international conference on automated softwareengineering ase september21 virtualevent australia.
acm newyork ny usa pages.
introduction coverage guidedfuzzingis oneofthemost popularsoftwaretestingtechniquesforbugdetection.inthepastfewyears ithasgained significanttractioninacademicresearchaswellasinindustrypractice.
most notably google s oss fuzz adopts american fuzzy lop afl honggfuzz and libfuzzer to continuously test open source applications.
over bugs in open source projects are discovered by oss fuzz.
a coverage guided fuzzer feeds a program with random test cases collects coverage increasing test cases such test cases are called interesting seeds and generates new test cases by mutating thoseseeds.thekeygoalofcoverage guidedfuzzersistomaximizecoverageandexploredeeperpathsasfastaspossible.manyfuzzingoptimizationshavebeenproposedtomaximizecoverage including the ones that improve seed selection strategy o r mutation strategy the ones that integrate multiple fuzzingoptimizations andtheonesthatleveragetaint analysis symbolic execution human knowledge or machine learning to assist fuzzing.
whilethoseaboveoptimizationsgreatlyimproveperformance especiallyincoverageimprovements theydonottakefuzzingoverheadintoconsideration whichmayhinderthemfromachievingbetter scalability.
for example the overhead caused by coveragecollection is costly.
we conduct experiments on afl using realworld programs of google fuzzer test suite to investigate the overhead of collecting coverage.
to our surprise afl spends an average of .
and up to .
of its runtime to trace coverage.
somerelatedworkstrytodecreaseoverheadsfrominstrumentation.
instrim reduces instrumentation cost by instrumenting 35th ieee acm international conference on automated software engineering ase apartofbasicblocksandreconstructingcoverageinformation.untracer avoids tracing coverage of non coverage increasing test casesbyremovingvisitedinstrumentationpoints.theycaneffectivelydecreaseoverheadbutcannotpreservefine grainedcoverage guidance which limits their vulnerability detection.
tospeedupfuzzing andfurtherimprovevulnerabilitydiscovery the main challenge is to keep a good balance between instrumenta tionoverheadsandthegranularityofthecollectedcoverage.those existing overhead reduction methodologies decrease the overhead with sacrificing coverage accuracy.
for example our experiments demonstratethatcomparedwithafl althoughimproves thespeed by .
untracer decreases coverage by .
which resultsin an unstable ability of vulnerability discovery.
therefore it is noteasytokeepagoodbalancebetweenoverheadreductionand coverage accuracy.
inthispaper weproposeacoverage sensitivetracingandscheduling framework zeror whichaims at increasingfuzzing speed withdiversely instrumentedbinaries.themainideaisswitching toaself modifyingbasedzero overhead instrumentedbinaryfor fuzzing when the normal instrumented binary fails to make better progress.
zerorismainlymadeupoftwoparts aself modifying tracing mechanism to provide a zero overhead instrumentation for coveragecollection.theself modifyingtracingmechanismreduces the coverage collection overhead by restricting coverage tracing toonlycoverage increasingtestcases.
areal timescheduling mechanism to support adaptive switch between the zero overhead instrumented binary and the fully instrumented binary.
to choose the optimal binary it estimates the probabilities of discoveringinteresting seeds for each binary by bayesian inference.
instead of fuzzingspeed andcoverageaccuracy within a single binary the scheduler helps fuzzers achieve both by taking advantages of diversely instrumented binaries.
weimplementedtheprototypeof zerorandappliedittoseveral state of the art fuzzers including afl and mopt .
we evaluated them on google fuzzer test suite which consists of24widely usedreal worldapplications.theevaluationresults demonstratethat zerorperformsbetterthanexistingfuzzingspeed up frameworks such as untracer and instrim.
compared withuntracer it covers .
more branches with almost the sameexecution time.
compared with instrim it covers .
more brancheswith50.
lessexecutiontime.itimprovestheexecution speed oforiginal afl instrumentation which is also adopted in mopt by .
helps them achieve better coverage averagely .
forafl .
formopt andexposurevulnerabilitiesfaster averagely .
for afl .
for mopt .
in summary this paper makes following contributions weproposeacoverage sensitivetracingandschedulingframework which integrates diversely instrumented binaries and supports adaptive switch between them to speed up fuzzing as well as maintain the vulnerability detection ability.
weproposeaself modifyingtracingmechanismtoreducecoveragecollectionoverhead.byusingthismechanism fuzzerswill be sensitive to edge level coverage granularity and only trace coverage of coverage increasing test cases.
we propose a real time scheduling mechanism which is able to dynamically choose a proper instrumented binary for fuzzing executiontoachieveb othspeed and accuracy.
weimplementedtheprototypeof zeror whichcouldbeapplied to most of the state of the art fuzzers such as afl and mopt.
the results show that zerorcould help boost executionspeed and discover vulnerabilities faster than the existing speed up framework such as untracer and instrim.
thispaperisorganizedasfollows section2introducesthebackground of coverage guided fuzzing and coverage tracing.
section illustrates the motivation of this work through an empirical study onefficienciesofdifferentcoveragecollectionmethods.section4 elaborates the idea and design of zeror.
section presents the implementation and evaluation.
section shows some related works and the main differences and we get the conclusion in section .
background .
coverage guided fuzzing coverage guided fuzzing is currently one of the most effective andefficientvulnerabilitydiscoverysolution.itaimstoautomatically generate proof of concept poc exploits by maximizing code coverage.
afl libfuzzer and honggfuzz are some well recognized coverage guided fuzzers.
figure1showsthegeneralworkflowofacoverage guidedfuzzer.
givenatargetprogramandinitialinputs fuzzingworksasfollows compiletargetprogramintotargetbinary wherecoverageinstrumentationareinjected executethebinaryandspawntarget process queueinitialinputsintoseedsgenerator generate testcasesasinput tracecoveragetoevaluatethetestcase save the test case to corpus if there is coverage growth i.e.
the test case is interesting and goto step .
during the fuzzing exe cution loop performance is highly impacted by execution speed duringruntime.fuzzer sruntimeconsistsoftwoparts coverage tracing and fuzzer s internal logic including child process establishment seed selection and mutation coverage comparison etc.
.
a simple but practical optimization for fuzzer s internal logic isafl persistent mode where a long live process can be reused to try out multiple test cases eliminating the need for repeated fork calls and the associated os overhead .
.
coverage tracing coverage guided fuzzers utilize coverage information to guide fuzzing.theytrackcoverageofeachexecution comparethecover agewithpreservedcoverage andcheckwhethercurrenttestcaseiscoverage increasing.
the most common approach to gain coverage information for fuzzing is instrumentation which is taken variouslybydifferentfuzzers.foroskernelfuzzing syzkaller and kafl instrumenttargetkernelbyhardware assistedmechanisms e.g.intelpt .forblackbox source unavailable applicationsfuzzing vuzzer usespin todynamicallyinstrument black box binaries.
for whitebox source available applicationsfuzzing libfuzzer and honggfuzz use sanitizercoverage instrumentation method provided by clang compiler and afl implements instrumentation by hardcoding basic block keys into the assembly file of target programs.
859source code instrumentation fuzzing report seeds generatorinitial seeds fuzzer target processinputfeedback binary coverage tracer feedback figure the general workflow of coverage guided fuzzing yrlg irr lqw d li d d a codeli d d uhwxuq b basic block levelli d d uhwxuq c edge level figure different coverage granularities provided by sanitizercoverage.
basic block level focuses on the coverage ofeach node while edge level focuses on the coverage of theedge.
furthermore an empty dummy block is inserted todenote a critical edge between two basic blocks.
different instrumentation mechanisms provide different coverage granularities.
sanitizercoverage and afl instrumentation method are two most widely used coverage instrumentation mechanisms.sanitizercoverageoffersbasic blocklevelandedgelevel instrumentation.
figure2 illustratesthe mechanismsin a briefexample.
basic blocks are the nodes of program s control flow graph denoting a piece of straight line code i.e.
there is no jump in orout of the middle of a block .
sanitizercoverage extracts controlflow graph of target program and instruments each basic block in llvmirwhenthebasic blocklevelinstrumentationisactivated.
to enhance instrumentation from basic block level to edge level sanitizercoverageadds dummy blockstodenotecriticaledges which is neither the only edge leaving its source block nor the only edge entering its destination block.
unlike sanitizercover age afl instrumentation method tracks edge coverage directly.it assigns random keys to target program s basic blocks during staticinstrumentation dynamicallycalculatesedgekeysthrough previousbasic block keys and currentbasic block keys and tracks edgecountersina64khashtablebyedgekeys .aflisalso compatible with sanitizercoverage .
motivations different coverage collection mechanisms trace different cover age granularities.
the more accurate information gains through tracing coverage the more overheads fuzzing faces.
however it is unclearhow granularityrelates totracingcoverage andoverhead.
anintuitiveimpressionisthat fuzzersguidedbydifferentcoveragegranularitieshavedifferentstrengthswhenfuzzingdifferent target programs.
to verify our hypothesis we conducted a preliminary experiment on different coverage granularities to evaluateeach granularity s efficiency.
three different coverage collection instrumentation mechanisms are chosen in our experiment afl edge the fuzzer is afl and target programs are instrumented by original afl s edge level instrumentation.
afl basic block the fuzzer is afl and target programs are instrumentedbysanitizercoverage usingbasic blocklevelinstrumentation.
afl coarse basic block thefuzzerisaflandthetargetprograms are instrumented by untracer which decreases time onhandlingdiscardedtestcasesbutonlyobtainscoarsebasicblock level coverage without accumulating hit count.
werunabovethreemechanismsongooglefuzzer test suite for6hoursandselectpartialresultsforpreliminaryillustration allexperiment settings are in line with section .
.
from the result of figure and table we have the following observations observation1 tracingaccuratecoverageiscostly .asillustrated in section .
coverage tracing and internal logic execution aretwoconstituentpartoffuzzer sruntime.werecordaflinternal logic execution time during each iteration and calculate edge level coveragetracingtimebycomparingeachtestcase sexecutiontimeininstrumentedversionandnon instrumentedversion.asfigure3shows timespentintracingcoverageaccountsforaveragely71.
ofafl swholeruntime.theratioisevenupto98.
whenfuzzing openssl .
.1f.
figure percentage of internal logic execution time andedge level coverage tracing time in afl.
observation2 theefficiencyofeachcoveragegranularity varies with target programs .
we record the time spent in triggeringknownvulnerabilitiesforeachmechanism andtheresult is shown in table .
due to the limitation of dyninst untracer is incompatible with some projects denote as n a .
from table we can see that afl edge exposes known vulnerabilities 860faster than others on openssl .
.1f andopenssl .
.2d afl coarse basic block exposes known vulnerabilities faster than otherson guetzli.afl basic block exposesknownvulnerabilities faster than others on lcms pcre2.
table1 timetakentotriggerknownbugsforfuzzersguided by different coverage granularities.
denotes the fuzzer cannotexposeknownbugsin6hours.n adenotescompatibility issues of untracer on specific programs.
projectaverage reaching time seconds afl afl afl untracer edge basic block coarse basic block c ares guetzli json lcms openssl .
.1f n a openssl .
.2d n a pcre2 focus of this paper from the observation we find that tracing coverage is costly.
in search for coverage increasing test cases fuzzingisbasedongeneticalgorithm whichmakesitseffectiveness highly impacted by execution speed.
thus we focus on improving fuzzing efficiency by reducing the coverage collection overhead.
weproposeanovelself modifyingtracingmechanismtoeliminate needlesscoveragecollection.besides inspiredbytheobservation instead of a tradeoff betw eenfuzzingspeed and coverage accuracy we propose a scheduling scheme which helps fuzzers achieve both goals by integrating diversely instrumented binaries.
zeror design figure depicts the basic work flow and main components of zeror.differentfromtraditionalcoverage guidedfuzzing zeror will choose a proper binary as fuzzing target i.e.
the running programforfuzzing amongdiversely instrumentedbinaries.
zeror consists of two main components coverage tracer andbinaryswitchingscheduler.
coveragetracer collectscoverageinformationfromfuzzingtarget storesseedsintocorpusiftheseedsareinteresting and sends statistical data to binary switching scheduler.
it will self adjust when fuzzing target changes when fuzzing afl instrumentedbinaries coveragetracer willreadcoveragefrom edge counters hash table when fuzzing the binaries instrumented byself modifyingtracing coveragetracer willmonitorthestatus of child process and modify the instructions of child process.
binary switchingscheduler recordsthestatisticaldatafrom coverage tracer estimates efficiency of each instrumented binary based on the statistical data and choose the optimal binary as fuzzing target when time to switch binary.
specially we leverage empirical bayesian method to estimate efficiency in a cost effective way and adoptexponentialsmoothingtosmooththetime varyingefficiency.source code diverselyinsturmented binaries multiple instrumentations fuzzing report binaryswitching scheduler coverage tracer seeds generatorinitial seeds fuzzer target processmodify feedback input switchfeedback update figure overview of zeror which mainly includes the self modifying tracing mechanism implemented with multiple instrumentation and coverage tracer and the real time scheduling mechanism implemented with the binary switching scheduler.
multiple instrumentation means theself modifying tracing based instrumentation and the fullinstrumentation of the integrated original fuzzer.
.
self modifying tracing asaforementioned coverage guidedfuzzingspendsthemajority of its runtime in collecting coverage.
it is intuitive that restrict ing coverage tracing to only coverage increasing test cases will significantlyreducetheoverhead.however howtosensecoverageincreasing seeds and ignore discarded test cases is still an open problem.differentwithstaticbinaryrewritingtechniqueusedin untracer which is coverage inaccurate time consuming and not scalable on many complex programs our solution namelyself modifying tracing adopts self modifying code technique toaddress the problem.
with the assistance of self modifying tracing fuzzerscould dynamicallyremovevisitedinstrumentation pointsduringfuzzingprocess sensefine grainedcoverage barely introduce new overhead.
self modifyingcode smc referstothecodethatcanmodifyits own instructions during the execution of the program.
it is widely used in many of software systems to support runtime code generation andoptimization minimizethecodesize andreinforcedynamiccodeencryptionandobfuscation .there are several advantages in smc such as fast paths establishment repetitiveconditionalbranchesreductionandalgorithmicefficiencyimprovement.toapplysmctocoveragetracing weneedtoobtain theaddressesofinstrumentationpointsatcompilationstage and self modifyingtheaddressesatruntimestage.astep by stepexample is shown in figure to elaborate how our solution performs self modifying tracing with compilation stage and runtime stage.
atcompilationstage weneedtogenerateazero overheadbinary and obtain the addresses of instrumentation points.
however 861address binariy codes assembly 0x2b1980 push rbp 0x2b1981 e5 mov rsp rbp 0x2b1984 b8 mov 0x1 eax0x2b1989 f7 cmp esi edi0x2b198b 7f 0c jg 2b19990x2b198d b8 mov 0x2 eax 0x2b1992 7c jl 2b19990x2b1994 b8 mov 0x3 eax 0x2b1999 5d pop rbp 0x2b199a c3 retqaddress binariy codes assembly 0x2b1980 cc int3 ... 0x2b1981 e5 mov rsp rbp 0x2b1984 b8 mov 0x1 eax0x2b1989 f7 cmp esi edi0x2b198b 7f 0c jg 2b19990x2b198d cc int3 ... 0x2b1992 7c jl 2b19990x2b1994 cc int3 ... 0x2b1999 cc int3 ... 0x2b199a c3 retqaddress binariy codes assembly 0x2b1980 push rbp 0x2b1981 e5 mov rsp rbp 0x2b1984 b8 mov 0x1 eax0x2b1989 f7 cmp esi edi0x2b198b 7f 0c jg 2b19990x2b198d cc int3 ... 0x2b1992 7c jl 2b19990x2b1994 cc int3 ... 0x2b1999 cc int3 ... 0x2b199a c3 retqlqw irr lqw d lqw e li d !
e uhwxuq hovh li d e uhwxuq hovh uhwxuq eax if a b eax if a b eax return7uxh 7uxh dovh dovh rpslodwlrq 6wdjh 5xqwlph 6wdjh hfxwh elqdu dqg lqmhfw euhdnsrlqwv5hfryhu elqdu frgh zkhq wuljjhu lqwhuuxsw rqvwuxfw hqhudwh elqdu iloh dqg uhfrug wdujhw dgguhvvhv12 figure5 astep by stepdemonstrationofself modifyingtracing.iteliminatesneedlessoverheadspentintracingcoverageof non coverage increasingtestcaseswithtwostages.itfirstinstrumentstargetprograms obtainsaddressesofinstrumentationpointsandgeneratesanon instrumentedexecutablebinaryfileatcompilationstage.then itdoesfuzztestingonthebinary detects whether instrumentation points are triggered and removes visited instrumentation points at runtime stage.
the seg ments in blue rectangles is the text segments of the program s memory layout the addresses of instrumentation points arehighlighted in blue the modified instructions are highlighted in red the recovered instructions are highlighted in orange.
therearetwochallengestobeaddressed howtoinjectinstrumentation points into target program?
blackbox instrumentation will obtainredundantandless accuratecoverageinformation whichim pairfuzzingperformance.whileinstrumentingprogramsinawhiteboxwaylikeaflinstrumentation orsanitizercoverage will introduce costly overhead.
besides using self modifying code basedonaflinstrumentationalsoobtainscoarse grainedcoverage because afl only injects instrumentation points into basic blocks.
thus aninstrumentationapproachwhichobtainsfine grainedcoverageandintroduceslessoverheadisdemanded.
howtotrack theaddresses ofinstrumentationpoints?
compilerswill deactivate somecodeoptimizationsassoonasanyaddressofbasicblockisobtained and the un optimized binary will be executed at a lowspeed.
thus we need t o track the addresses of instrumentation points in a proper way.
togenerateazero overheadbinaryandtracktheaddressesof instrumentationpoints itworksasfollowstocompileaprogram from source code to object file inject instrumentation points.
before the compiler starts performing platform independent code optimizations we construct controlflowgraphandinjectaninstrumentationpoint i.e.a call instruction to invoke callback function at the start of each basic block.
note that similar with sanitizercoverage the instrumentation could be enhanced from basic block level to edge level by adding dummy blocks to denote critical edges as section .
illustrates.instrumentingbeforecodeoptimizationsallowscontrolflowgraphtopreservesemanticsofsourcecodesothatcoverage information is collected accurately.
record clear.werecordthecorrespondingbasicblocksymbols ofinjected callinstructionsanderasealltheinjected callinstructions after compiler finishes platform independent code optimizations at intermediate representation ir level.
in this way the generated ir could be non instrumented while the recordedbasicblocksymbolsinheritthefine grainedcoverageinformation from instrumentation points.
emitaddresses.weobtainaddressesofinstrumentationpoints through the recorded basic block symbols allocate a memory in thegeneratedobjectfileandemittheaddressesintothememoryaftercompilerfinishesplatform dependentcodeoptimizationsat machine specificintermediate representation mir level.note that the addresses are a series of offsets in object file and willbe relocated to absolute addresses when a linker generates ex ecutable binary.
in this way the addresses of instrumentation points are written in generated binary and could be accessed to perform self modify tracing during runtime.
inthetextsegmentsafterstep2offigure5 wehighlightfour addresses 0x2b1980 0x2b198d 0x2b1994 and0x2b1999 inblue todenotetheaddressesofinstrumentationpoints.forsimplicity weonlyshowbasic blocklevelinstrumentation however oursolution enhancesinstrumentationfrombasic blockleveltoedgelevelby adding dummy blocks to denote critical edges.
after compilation stage azero overheadbinaryisgeneratedandpreparedforfuzzing.
atruntimestage thecoveragetracerof zerorwillexecutethe zero overheadbinary injectbreakpointsintoitandperformfuzzingonthistarget.algorithm1detailstheactionsofthecoveragetracer.
first as presented in lines the fuzzer executes the binary receivestheaddressesofinstrumentationpoints andreplacesoriginalinstructionswith 0xcc.thecorrespondingdemonstrationisshown in step in figure the binary codes of instrumentation points are replaced with 0xcc we highlight the instructions in red .
once the process executes 0xcc it will trigger sigtrapinterrupt and wait for parent process to resume it.
after the injection the fuzzer performsfuzzingonthechildprocess andmonitorsthestatusof it.
once receiving sigtrap from child process the fuzzer stores current input as interesting seed for further mutation recovers the instruction that belongs to the address and resumes child process 862as presented in lines .
the corresponding demonstration is shown in step in figure .
algorithm action of self modifying coverage tracer input the target binary b executorexec a map to store address instruction pairs 1addr.initial 2exec.run b 3addrs receiveinstrumentedaddrs 4unvisitedaddrs addrs inject breakpoints into child process 5foreachaddrinaddrsdo 6instr readinstrfromaddr addr 7addrmap .insert addr instr 8writeinstrintoaddr xcc addr 9end 10async event loop 11ifreceive sigtrap from child process then readseedandstore recover the instruction addr readrip instr addrmap .get addr writeinstrintoaddr instr addr unvisitedaddrs unvisitedaddrs addr exec.resume 18end 19end withintheself modifyingtracing wemaintainasetofinstrumentation points which have never been visited unvisitedaddrs in algorithm during fuzzing process.
the set will tend to be anemptysetasthefuzzerexplorestargetprogram sstatesmore deeply.
once a instrumentation point is visited it will be removed and never be collected again.
besides the self modifying tracingdoes not introduce new overhead during fuzzing process.
therefore alongwiththefuzzingprocess itcantheoreticallyeliminate coverage collection overhead almost down to zero.
.
binary switching scheduling section3revealsthattheefficiencyofeachcoveragegranularity varieswithtargetprograms.inspiredbythis webelievethatswitching among diversely instrumented binaries during fuzzing process will improve fuzzing performance.
however estimating efficiencies of diversely instrumented binaries is challenging because program dependentefficiency theefficiencyofeachbinaryvaries with target programs thus we cannot share one static set of parameters configuration among different programs time varying efficiency even for testing one target program the efficiency of eachcoveragegranularitychangesovertimeasthefuzzerexplores target program s states more deeply cost effective solution the solution should be cost effective and less frequent due to the high throughput of fuzzing.we propose a real time scheduling mechanism to address above problems.
in short it adaptively switches fuzzing binary amongdiversely instrumented binaries at set intervals.
during fuzzingprocess it collects statistical data i.e.
the number of interestingseeds the number of executions and the time spent on fuzzing dynamically monitors the number of interesting seeds each binary coulddiscover andchooseanoptimalbinaryasfuzzingtargetwhen theswitchtimeisup.weleverageempiricalbayesianmethodtoestimateefficiencyinacost effectivewayandadoptexponential smoothing to smooth the time varying efficiency.
estimateefficiency .tosimplifythetime varyingproblem we discretize continuous time into time periods and assume efficiency is invariant at each time period.
for a binary the efficiency at time periodtis defined as et it tt it mt mt tt rt s whereitdenotesthenumberofdiscoveredinterestingseedsduring the timeperiod t ttdenotes thetime spent onfuzzing during the timeperiod t mtdenotesthenumberofexecutionsduringthetime periodt rtdenotes the quotient of itandmt namely interestingtestcasesrate itr andsdenotesexecutionspeedwhichcanbe seen as a constant with respect to binary.
given a binary s statisticaldata and before currenttimeperiod t weaimtoestimateitrs rt andfurthercalculate the estimation of efficiency etof the binary at current time periodtthrough equation .
withempiricalbayesianmethods theintegralsoverconditional probability distributions are substituted by the empirical statistics in the observed data which allows us to estimate the posteriorprobabilities e.g.
a binary s itrs by leveraging the information fromitsstatisticaldata.foreachbinary thereisanunderlyingprobabilitydistributionofitr andateachtimeperiod t thebinary s itrrtcould beregarded as a outcome ofthe distribution.
we use betadistributiontoparameterizethegenerativeprocess definedas beta .
besides obviously for each binary at time period t the numberofinterestingseeds itobeysthebinomialdistributionwith parameters mtandrt.thus wehaveabeta binomialcompound distributionforthestatisticaldata.thegenerativeprocessofour bayesian model is described as follows sampler beta p r r r samplei binomial m r p i m r ri r m i where is gamma function.
therefore the likelihood over all number of interesting seeds is l p i1 i2 it m1 m2 mt t productdisplay.
i rip ii mi ri p ri dri t productdisplay.
i ri rii i ri mi iir i ri 1dri t productdisplay.
i 1 mi ii mi ii 863then themaximumlikelihoodcanbecalculatedthroughthefixpoint iteration fpi x x summationtext.1t i summationtext.1t i x x summationtext.1t i summationtext.1t i where x isthedigammafunction andcanbequicklycalculated through bernardo s algorithm .
with equation the and could be iteratively estimated furthermore the posterior estimation of current time period s itr could be calculated as rt it mt .
to accelerate the convergence speed of the iteration method we use method of moments to calculate the initial values 0and 0. besides to smooth timevarying observed data we leverage exponential smoothing t o calculate the smoothed number of interesting seeds ii braceleftbiggi prime ii i prime i ii 1i wherei prime iis the observed number of interesting seeds iiis the smoothednumberofinterestingseedswhichisusedinequation is the smoothing factor.
as time passes the smoothed iibecomes the exponentially decreasing weighted average of its past observations in this way we can capture time relationship between itrs.
oncetheposteriorestimationofitr rtofthebinaryisestimated the estimation of efficiency etcould be calculated through equation .
thus at current time period t we can estimate efficiencies of every diversely instrumented binaries e1 t e2 t ek t and form a probability distribution by normalizing these efficiencies p x i ei t summationtext.1k j 1ej t whereej tdenotes the efficiency of binary j. when the time to switch we can select the target binary for fuzzing according to the probability distribution.
switch among binaries .
based on the efficiency estimation we can implement the binary switching scheduler as detailed in algorithm2.first aspresentedinlines1 theschedulerrandomly choosesseveral inlinewiththeconfigurations binariesandperforms fuzzing on these binaries through executor.
for each binary theexecutorwill forkachildprocesstotestthem whichissimilartoafl sforkserver .then theschedulerasynchronously listensevents fromexecutorand timer.executor willperiodically reportstatistics numberofexecutions numberofinterestingseeds timespentonfuzzingduringthetimeperiod andschedulerwill record these statistics when receive them from executor as presented in lines .
as presented in lines when it is timeto switch binary the executor will stop its child processes and then theschedulerwillcalculatetheposteriorestimationofeach binary s itr and choose optimal binaries for fuzzing according to theprobabilitydistributionofequation .notethat thescheduler supports not only running in single mode i.e.
single core fuzzing butalso runninginparallelmode i.e.multi coresfuzzing which is more common in real industrial practice .algorithm action of binary switching scheduler input list of diversely instrumented binaries b executorexec configurations c 1scheduler .initial b 2targets scheduler .chooserandom c.numcores 3exec.run targets 4async event loop 5ifreceive statistics from executor then 6binary statistics exec.read 7scheduler .record binary statistics 8end 9iftime to switch binary then exec.stop foreachbinbdo calculate the posterior estimation of the binary s itr 0 0 scheduler .calbymoment b scheduler .calbyfpi b 0 0 r betaexpectation scheduler .update b r end targets scheduler .chooseoptimal c.numcores exec.run targets 19end 20end evaluation weimplementedtheframework zeror.theinstrumentationmechanisminself modifyingtracingisimplementedonthetopofllvm .
.
.
therecord clear procedure is implemented in the initialization of llvm machinemoduleinfo and theemit addresses procedure is implemented in the emitbasicblockstart method ofllvm asmprinter .
we create a global variable to record the mappingofmbbsymbol mcsymbol type andmbbid uint32 t type .
the runtime logic of monitoring status of process and modifying instructions of memory in self modifying tracing is based onptrace.forscalability theschedulercomponentcontainsthe self modifyingbasedzero overheadbinaryandtheoriginalfully instrumented binary of the integrated fuzzers such as afl and mopt.
the interval of switching binaries and reporting statistical dataaresetto600sand60srespectively whichbarelyintroduces new overhead and brings best performance after multiple attempts withdifferentvalues.inspiredbytheaflpersistentmode our frameworksetsupathreadwhichrunsa ptracetasktomonitor thestatus ofchild process.once thechild processtriggersa crash orexceedstimeoutlimit thethreadwillterminateandre spawn the child process.
we evaluated zerorin three aspects.
first we applied zeror to afl and compared the performance with two state of the art fuzzingspeed up frameworks untracer and instrim to assess the efficiency.
then we generalized zerorto mopt a 864table fuzzing performances of differ entafl basedfuzzing speed upmethods.
projectaverage execution time for each test case s number of covered branches afl afl instrim afl untracer afl zeror afl afl instrim afl untracer afl zeror boringssl .
.
n a .
n a c ares .
.
.
.
freetype2 .
.
.
.
guetzli .
.
.
.
harfbuzz .
.
.
.
json .
.
.
.
lcms .
.
.
.
libarchive .
.
.
.
libjpeg .
.
.
.
libpng .
.
.
.
libssh .
.
.
.
libxml2 .
.
n a .
n a llvm libcxxabi .
.
.
.
openssl .
.1f .
.
n a .
n a openssl .
.2d .
.
n a .
n a openssl .
.0c .
.
n a .
n a openthread .
.
.
.
pcre2 .
.
.
.
proj4 .
.
.
.
re2 .
.
.
.
sqlite .
.
.
.
vorbis .
.
.
.
woff2 .
.
.
.
wpantund .
.
.
.
zerorimprovement .
.
.
.
.
.
table time to expose known bugs denotes the fuzzer cannot expose the known bugs in hours and the projects whosebugscannotbetriggeredbyanyfuzzerareremoved.
project afl afl instrim afl untracer afl zeror c ares guetzli json lcms llvm libcxxabi openssl .
.1f openssl .
.2d pcre2 re2 woff2 state of the artfuzzer tostudythescalability.finally weevaluated the effectiveness of each component of zeror.
.
experiment settings torevealthepracticalperformanceof zeror theevaluationwas conductedonfuzzer test suite awidely usedbenchmarkfrom google.thistestsuiteconsistsof24popularreal worldapplications which have interesting known vulnerabilities hard to find code paths orother challengesfor bugfinding tools.
the initialseeds were collected from the built in test suite and each source code inside the test suite was compiled with o2flag.
to reduce the side effect caused by afl s file i o overhead all fuzzers were running in tmpfs.
all experiments were performed on a bit machinewith40cores intel r xeon r gold6148cpu .40ghz gib of ram and linux .
.
.
due to the random effects in fuzzing weconductedeachexperimentsforsixhoursandrepeated it ten times.
and we reported average performance.
intermsofmetrics weevaluatetheperformanceoffuzzersin three aspects namely execution time branch coverage and timeto expose known bugs.
the execution time is the average time the llvmfuzzertestoneinput function consumed.
different fuzzers areguidedbydifferentcoveragegranularity forfaircomparison wecollecttheirgeneratedseeds feedtheseedstooriginalafland gather the number of covered branches through afl bitmap.
the time to expose known bugs is the time consumed by the fuzzer to trigger the first crash.
.
efficiency of zeror we applied zerorto afl namely afl zeror by switching between afl instrumented binary and self modifying tracing instrumented binary based on binary switching scheduler.
we evaluated it on all the programs of google fuzzer test suite and compared it with two state of the art fuzzing speed up techniques instrim and untracer.
specifically for the baseline afl the version usedis .52b and the compilation tool chain is afl clang fast whichisthemostefficientinstrumentationmethodthataflprovide for instrim we activate instrim approx mode which shows best performance in their evaluations .
theresultsarepresentedintable2andtable3.the2 5columns of table2 show theaverage execution timeper testcase and the zerorimprovementinthelastrowreferstotheexecutionspeed increase.
the columns of table show the number of branches covered by each fuzzer and the zerorimprovement in the last row refers to branch increase.
table shows the time taken by each fuzzerto exposeknownbugs theprojects whosebugs cannot be triggered by all the fuzzers in hours are removed from the table.notethat duetothelimitationofdyninst untraceris incompatiblewithsomeprojects including boringssl libxml2 openssl .
.1f boringssl .
.2d andopenssl .
.0c we denote the corresponding table cell as n a. from the two tables we can deduct the following conclusions zerorincreasestheexecutionspeedofafl.intable2 theaverage execution time of afl zeror is less than afl for every benchmarkprojects.specificallyfor libjpeg theaverageexecutiontimeofaflandafl zerorare1469.
sand337.
s respectively which indicates that zerorincreases the execution speed of afl by .
.
averagely zerorincreases the executionspeed of afl by .
.
zerorhelpsaflcovermorebranches.intable2 afl zeroroutperforms afl on out of projects.
specially afl zeror improvesthenumberofcoveredbranchesby55.
on openssl .
.1fand33.
on libarchive .averagely afl zerorincreases the number of covered branches of afl by .
.
zerorhelpsaflexposebugsfaster.intable3 afl zerorexposesknownbugsfasterthanoriginalaflon8outof10projects.
specially afl zeror is .87x faster than afl in term of triggering the bug in pcre2 and exposes the bugs of re2andguetzli which cannot be exposed by original afl in hours.
zerorshows better performances compared with other fuzzing speed up techniques.
compared with instrim zeroris averagely .
faster for each execution covers .
morebranches and spends less time on bugs exposure.
compared with untracer zerorcovers .
more branches averagely and spends less time on bugs exposure.
because of the real time scheduling zerorisaveragely0.
slowerthanuntracer which is almost negligible.
figure the number of covered branches over time whenfuzzing harfbuzz.
the x axis is on a logarithmic scale.
case study .
figure visualizes the real time change of covered brancheson harfbuzz whendifferentfuzzingspeed upmethods areappliedonafl.wecanobservethatafl zerorcoversmore branches than all the other methods most of the time.
specifically afl zerortakes211secondstoachievealmostthesamenumberof covered branches as afl and instrim take 214seconds.
untracer coverslessbranchesmostofthetimecomparedwithothermethods even compared to the original afl.
as demonstrated in table untraceristhefastestfortestcaseexecution butwhenitdeletes almost all the instrumentation points it will also lose the fine grained coverage information such as hit count of branches forfuzzingguidance and willgreatly reducethe numberofcovered branches.instrimmakesaflfaster butnotasfastasuntracerand zeror anditreconstructsthecoverageinformationforguidance with instrumenting a part of basic blocks to partially maintain the ability to cover more branches.fromtheabovestatistics itisreasonabletodrawtheconclusion that withtheaidof zeror fuzzersareabletogainhigherspeedup covers more branches and exposes bugs faster.
in addition zeror showsbetterperformanceofcoverageincreaseandvulnerability discoverycomparedwithotherfuzzingspeed uptechniques.
.
scalability of zeror in addition to afl we also generalize our experiments to another state of the artfuzzer mopt tostudythescalabilityof zeror.
moptisafuzzerthatimprovesfuzzingperformancebyoptimizing the efficiency of mutation strategy.
we applied zerorto mopt namely mopt zeror in the same way as afl zeror and evaluated it on all the programs of google fuzzer test suite.
the resultsareshowninfigure7andtable4.fromfigure7wecanobserve that mopt zeror improves the number of covered branchesin out of projects and averagely increases the number of covered branches by .
compared with the original mopt.
specifically mopt zeror improves the number by .
on proj4and .
on libarchive .table4showsthetimetakenbymoptand mopt zeror to expose known bugs those projects whose bugs cannot be triggered by them in hours are removed from the table.
from table we can observe that with the aid of zeror mopt exposes known bugs faster.
specially zeror improv esthe speedof bug exposure by .39x on llvm libcxxabi .01x on pcre2.
figure relative covered branches improvement ofmopt zeror compared with mopt.
table4 timetoexposeknownbugs andtheprojectswhose bugs cannot be triggered by them in hours are removed.
project mopt mopt zeror c ares json llvm libcxxabi openssl .
.1f openssl .
.2d pcre2 woff2 insummary zerorisapplicabletootherfuzzingoptimizations like mopt and more importantly zerorcan further improve fuzzing vulnerability discovery performance on top of them.
al though we only use mopt for illustration in the experiment it 866can be easily applied to other fuzzers such as aflfast and fairfuzz .
.
evaluation of individual components zerorconsists of two main mechanisms self modifying tracing and real time scheduling.
to analyze the effects of each individual mechanism we configure two variants of our framework zeror representsthefuzzerwhichadoptsaflasseedsgenerator and only integrates self modifying tracing mechanism.
zerorrepresentsthefuzzerwhichadoptsaflasseedsgenerator.
besides itintegratesself modifyingtracingandafl sinstrumentation to collect coverage and dynamically switches between thetwoinstrumentedbinariesduringfuzzingprocessbasedon real time scheduling mechanism.
evaluation of self modifying tracing .
since untracer shares the similar idea with our self modifying tracing component we evaluate our tracing by comparison with untracer us ing projects of fuzzer test suite untracer is incompatible tothe rest projects .
for speed improvement both methods eliminatethecoverage collectingtimeofnon coverage increasingtest cases by erasing visited instrumentation points but with differ ent approaches.
figure 8a shows that when considering erasinginstrumentationpoints self modifyingtracingsavesmuchmore time than untracer on the average time consumed.
averagely selfmodifyingtracingis13.74xfasterthanuntracerwhenerasinginstrumentation points.
the saved coverage tracing time can be used for efficient binary switch scheduling.
additionally self modifying tracingisedge awarewhileuntracerisbasic block aware.figure8bshowstherelativecoveredbranchesimprovementofself modifying tracing fromwhichwecanconcludethatself modifyingtracing mechanismhelpsfuzzercovermorebranchescomparedwithuntracer.
specifically self modifying tracing improves the branchcoverage by .
on proj4 .
on libarchive .
on lcms .
on freetype2.
evaluation of real time scheduling .
our scheduling mechanism integrates two binaries the zero overhead binary instru mented by self modifying tracing and the original binary instru mented by the integrated fuzzer and then dynamically switches between them.
to study the effectiveness of the scheduler we comparezerorwithzeror and afl.
the overall result is consistent totable2 andforpagelimitation weonlyvisualize2projectsto demonstratethecoverageincreaseprocessofdifferentconfigurations in figure .
both zeror andzerorcover more branches than afl and zeroroutperforms zeror .thevisualizationindicatesthat integrating twodifferent instrumentedbinaries withthe real time scheduling helps fuzzers achieve better performance.
.
discussion although binary switching scheduler is able to integrate multiplediversely instrumentedbinaries weapplied zerortofuzzers byswitching onlybetweenoriginal instrumentedbinaryand selfmodifying tracing instrumented binary in our evaluation which couldnotfullyexcavate zeror spotentiality butalreadydemonstrates the effectiveness of tracing and scheduling.
furthermore evenwiththeschedulingoftwobinaries itimprovesbothspeed a average time taken for different methods to erase instrumentation points lower is better .
b relative covered branches improvement of zeror compared with untracer.
figure comparison between zeror and untracer.
a libjpeg b harfbuzz figure9 branchescoveredovertimewithdifferentconfigu rations.
the x axis is on a logarithmic scale.
and coverage.
recently dinesh proposed a novel approach of instrumentation we plan to integrate it in the future.
a number of covered branches over time.
b chosen probabilities of different binaries over time.
figure case study on sqlite of afl zeror.
867anotherpotentialconcerniswhethertheschedulingmechanism canhelpfuzzershiftintoproperbinary.figure10isthereal time visualizationofcoveredbranchesandthechosenprobabilitiesof diversely instrumented binaries when afl zeror is applied to test sqlite.wecanobservethatthechosenprobabilityofthebinary instrumented by afl is in decline when the number of covered branchesreachestheplateauatthetimeof30min 60min and zeror hashighprobabilitytoshiftintothefasterbinary instrumentedby self modifying tracing when the afl instrumented binary cannot makeanyprocess.theobservationindicatesthatthescheduling scheme do help fuzzer properly choose binary for execution.
however the scheduling scheme only collects execution statistical data whichmaynotbesufficientenoughtofullydisplayitsefficiency.
it could be further improved by gaining more information from data flow analysis and control flow analysis.
related works optimize fuzzing strategies .
existing optimizations of fuzzing resideindifferentstages.forthepreparationstage collafl provides a solution to collect coverage feedback without bitmap collision deepfuzzer leveragessymbolicexecutiontogenerate qualified initial seeds.
for the seed selection stage aflfast givesmoremutationtimestovaluableseedswhichexerciselowfrequency paths cerebro prioritizes seeds in corpus on the basis of static analysis and dynamic scoring.
for the seed mutation stage fairfuzz mutates input seeds in a restricted way so that theyaremorelikelytostillexploretherarestbranch mopt findstheoptimalselectionprobabilitydistributionofoperatorswith respect to fuzzing effectiveness.
specially a number of seed mutationoptimizationsleveragetaint analysissuchasredqueen angora andmatryoshka .redqueen usesalightweight input to state correspondence mechanisms as an alternative todata flow analysis angora adopts byte level taint analysis andagradient descentalgorithmforconstraintpenetration ma tryoshka identifies nesting conditional statements by control flow and taint flow and proposed three strategies for mutating the input to solve path constraints.
boostfuzzingspeed .xuetal.
designthreenewoperating primitives to solve the performance bottlenecks of parallel fuzzing on multi core machines.
instrim reduces instrumentation cost by selectively instrumenting a part of basic blocks and re constructing coverage information.
untracer avoids tracing coverageofnon coverage increasingtestcasesbyremovingvisited instrumentation points.
main differences .
optimizations of fuzzing strategies are orthogonalto zeror andmostofthemcouldalsobenefitfrom zeror.
for example the experiment results show that with the aid of zeror moptachievesbetterperformanceofcoverageexploration and vulnerability discovery.
different from instrim and untracer our study aims to boost fuzzing speedwhilepr eserve fine grained coverage collection.
although untracer has a similar idea withour self modifying tracing component rather than static binary rewriting our tracing relies on self modifying code to erase visited instrumentation points which barely introduces new overheads andprovidesmorefine grainedcoveragecollection.withthenovel binary switching scheduler more improvements can be achieved.
conclusion in thispaper we propose acoverage sensitive fuzzing framework zeror which integrates diversely instrumented binaries toboost fuzzing speed and further improve the vulnerability discovery.
zeroris mainly made up of two parts a self modifying tracing mechanism to provide a zero overhead instrumentation for coverage collection and a real time scheduling mechanism to select theproperinstrumentedbinaryforfuzzingonthebasisofempirical bayesian inference.
in the experiments of fuzzing projects from googlefuzzer test suite resultsshowthatwiththeaidof zeror fuzzers are able to gainhigher speedup cover more branches and more importantly expose bugs faster than the existing speed up techniques.
it can be applied to most of the existing fuzzers.
in our future work we plan to complement zerorwith other orthogonal fuzzing optimizations.
acknowledgement thisresearchissponsoredinpartbynationalkeyresearchanddevelopmentproject grantno.2019yfb1706200 thensfcprogram no.u1911401 thehuawei tsinghuatrustworthyresearch project no.
and the equipment pre research project no.
.