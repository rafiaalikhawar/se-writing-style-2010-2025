utilizing parallelism in smart contracts on decentralized blockchains by taming application inherent conflicts p ter garamv lgyi peter.garamvolgyi confluxnetwork.org shanghai tree graph blockchain research institute shanghai chinayuxi liu yuxi.liu duke.edu duke university durham north carolina usadong zhou dongz mail.tsinghua.edu.cn tsinghua university beijing china shanghai qi zhi institute shanghai china fan long fanl cs.toronto.edu university of toronto toronto canada shanghai tree graph blockchain research institute shanghai chinaming wu ming.wu confluxnetwork.org shanghai tree graph blockchain research institute shanghai china abstract traditional public blockchain systems typically had very limited transaction throughput because of the bottleneck of the consensus protocol itself.
with recent advances in consensus technology the performance limit has been greatly lifted typically to thousands of transactions per second.
with this transaction execution hasbecomeanewperformancebottleneck.exploitingparallelismin transaction execution is a clear and direct way to address this and to further increase transaction throughput.
although some recent literature introduced concurrency control mechanisms to execute smartcontracttransactionsinparallel thereportedspeedupthat they can achieve is far from ideal.
the main reason is that theproposed parallel execution mechanisms cannot effectively deal with the conflicts inherent in many blockchain applications.
inthiswork wethoroughlystudythehistoricaltransactionexecution traces in ethereum.
we observe that application inherent conflicts are the major factors that limit the exploitable parallelism during execution.
we propose to use partitioned counters and specialcommutativeinstructionstobreakuptheapplicationconflict chains in order to maximize the potential speedup.
when we eval uated the maximum parallel speedup achievable these techniques doubled this limit to an 18x overall speedup compared to serial execution thusapproaching the optimum.
we alsopropose occda anoptimisticconcurrencycontrolschedulerwithdeterministic aborts which makes it possible to use occ scheduling in public blockchain settings.
work done while employed at shanghai qi zhi institute.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
concepts computing methodologies parallel algorithms concurrentcomputingmethodologies softwareandits engineering software performance.
keywords blockchain distributed ledgers smart contracts parallel execution optimistic concurrency deterministic concurrency acm reference format p ter garamv lgyi yuxi liu dong zhou fan long and ming wu.
.
utilizingparallelisminsmartcontractsondecentralizedblockchainsby taming application inherent conflicts.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction the technical challenge of scaling permissionless blockchains has been a hot research topic for the last few years.
with various scaling solutions be it ethereum .
s sharding or conflux s treegraphledgerstructure theconsensusmechanismceasestobe theperformancebottleneck.whilediski o networkbandwidth and transaction execution are all possible sources of contention transactionexecutionisarguablythemostchallengingonetoaddress.
distributed ledgers that follow the account model originally introduced by ethereum are designed to reach consensus on a sequence of transactions then process them serially.
as a result currentprotocolsandtheirimplementationsareunabletomakeuse of multiple threads on multi core processors during this execution step.giventhedependenciesbetweentransactionsthroughtheir accesses to a shared data structure called the state tree the first challenge is to understand how much speedupwe canpotentially achieve byexecuting them inparallel.
then thesecond challenge istodesignaparallelschedulerwithsufficientdeterminismsothat nodes can reach consensus.
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa p ter garamv lgyi yuxi liu dong zhou fan long and ming wu to understand the degree of parallelism that can be utilized in existing transaction workloads this paper empirically studied a period of historical ethereum transactions.
taking state access traces perfectinformation transactiongascosts andthedegree ofparallelismofcomputingresources e.g.
32threads asinputs we constructed an optimal schedule for each block then compared its execution time to that of serial execution.
our major findings include theoverallspeedupachievableislimitedatabout4xcomparedtoserialexecution.whiletherearemanyblockswhoseexecution scales with the number of threads a large portion of blocks performs significantly worse.
these results are consistent with previous works .
most blocks are bottlenecked on a single chain of dependent transactions that need to be executed serially and thus dominate the overall execution time.
amanualinspectionofthebottlenecktransactionsshows thatmostofthemconflictonasinglecounterorarray.from the application s perspective most bottleneck transactions can be classified into one of three categories token distribution collectibles and decentralized finance.
theempiricalstudyresultssuggestthat insteadofoptimizing scheduler implementations our primary focus should be on eliminatingthesecommonsourcesofcontentioninsmartcontracts.in thispaper wepresentthreeindependenttechniquesforeliminating theaforementionedbottlenecks.orthogonaltothesetechniques we also present a novel scheduling framework called optimistic concurrency control with deterministic aborts occ da .
parallel schedulersthatfollowthisframeworkcancomplywiththestringent determinism requirements of distributed consensus.
the first simplest approach to eliminating bottlenecks is to use multiplesenderaddresses.bymanuallydividingasetoftransactions from a single sender to multiple disjoint sets of transactions many common bottleneck patterns can be eliminated.
the second approach is to use partitioned counters similar to sloppycounters originallyintroducedbyboyd wickizeretal.
for the linux kernel.
in this approach we maintain several sub counters the sum of which constitutes the value of the original counter.writesareroutedtoandoperateondifferentsub counters based on some attribute e.g.
the sender s address.
this way partitioned counters reduce the probability that any two writing transactions will conflict.
the third approach to addressing bottlenecks is to bypass avoidable conflicts arising from commutative updates on the virtual machine level.
two transactions that both increment a counter but donotuseitsoriginalvaluearesemanticallycommutative.however under the current ethereum virtual machine semantics such increments are translated into a read sload and a write sstore instruction which will lead to read write conflicts.
we propose a new instruction called cadd commutative add .
two transactions that only have caddoperations but no other reads and writes on agivenstateentryarenotconsideredconflicting.incrementsare applied during transaction commit serially.
our evaluations suggest that these approaches can raise the amount of speedup achievable to 18x or more making it approach the optimal case where all transaction dependencies are ignored.we also note that the non determinism that is characteristic of parallelexecutionmightpreventblockchainnodesfromreaching consensus.
a set of incentives for goodbehavior i.e.
following the protocol anddis incentivesfor badbehavior i.e.
attackingormisusingtheprotocol isanessentialpartofpermissionlessblockchains.
ethereum and similar systems offer no incentive to write smartcontracts or pack blocks in a way that improves transaction parallelizability.the numberofconflictsand ortransactionabortsis a metric of parallelizability that the incentive layer could use to assign financial rewards and penalties.
however under traditional approaches like optimistic concurrency control occ even if weenforceadeterministiccommitorder theactualexecutionon differentnodesmightstilldiverge.thiswouldleadtodifferences inthismetricondifferentnodesandthusitwouldpreventnodes from reaching consensus.
to address this issue we introduce an optimistic scheduler with deterministic transaction aborts.
to our knowledge this algorithm is the first of its kind mostly because distributed ledgers have morestringentdeterminismrequirementsthanmostotherdomains.
basedonourevaluation thisapproachallowsustointroduceincentives for parallelizability in exchange for a performance impact that is on average acceptable.
in summary the major contributions of this paper are recognizing that certain common application inherent transaction conflicts leadtobottlenecksunderparallelexecution providingasetofeffectivetechniquestodealwiththese andofferingadeterministic scheduling algorithm that makes it possible to incentivize better parallelism.
background and motivation bitcoin introduced blockchains with the goal of supporting cryptocurrency paymenttransactionswithoutrelyingonanycentral authority.
such a public blockchain is a distributed ledgermaintained by a peer to peer network in a trustlessandpermissionlessway.
the core piece of this technology is its consensus protocol nakamoto consensus that probabilisticallyguaranteesthe irreversibility of transactions in decentralized public settings even under adversarial conditions.
the ledger is composed of a chain ofblocks eachofwhichcontainsasequenceoftransactions and replicated among all the participant nodes.
each block is generatedby aminerthrough some proof of work mechanism chained at the tail of the valid chain in the miner s view and broadcast to all the othervalidator nodes through a peer to peer gossip network.
due tothelatencyofblockpropagationinthenetwork multipleminers maygenerateblocksconcurrentlywithoutseeingtheothers and hence may introduce forksinto the ledger.
the nakamoto consensus employs the longest chain rule to let all the honest nodes agree on the valid chain and execute the transactions according to the orderoftheblocksinthechainandtheorderofthetransactions in each block.
the miner of each block on the valid chain gets a certainamountofbitcoinasarewardfromthesystem.thesecurity guarantee is achieved when forks are rare and the ledger basically formsasinglechain.inordertoavoidforks thebitcoinprotocol dictates a very low block generation rate in the entire network which seriously limits its throughput.
specifically bitcoin can only achieve a throughput of transactions per second tps .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
utilizing parallelism in smart contracts on decentralized blockchains by taming application inherent conflicts icse may pittsburgh pa usa ethereumextendsbitcoinwithsupportforaturing complete programming framework and the solidity programming language whichallowsdeveloperstoimplementcomplex decentralizedapplications.
this makes it possible to apply blockchain in industries likefinancialsystems supplychains andhealthcare .in ethereum the stateresultingfromtransactionexecutionismaintained in the form of a merkle tree.
ethereum adopts an account modelinitsstate.therearetwotypesofaccounts useraccounts andsmartcontract accounts.a useraccountis associated withits etherbalanceinformationwhileeachsmartcontractaccountfurther has an associated executable code and its own storage represented as a collection of key value pairs maintained in the merkle tree.
eachtransactionoccursbetweena senderaccountanda recipient account.
the majority of transactions are one of two kinds either avalue transfer which is a purely monetary transfer of etherfrom sender to recipient or a contract call where the sender account triggersexecutionofthecodeassociatedwiththerecipientaccount.
during its execution a contract call transaction can call functions ofother smartcontracts.to ensurethat transaction executionterminates each computational step incurs a cost denominated in gas paid by the transaction sender.
the sender specifies a maximum amountofgasitiswillingtopay gaslimit andifthechargeexceedsthisvalue thecomputationisterminatedandrolledback and thesender sgasisnotrefunded.thesmartcontractcodeconsists of a sequence of bytecode instructions that can be interpreted and executedbythe ethereumvirtualmachine evm tomanipulatethe stateofthemerkletreebyupdatingthevaluesofthecorresponding keys.everybytecodeinstructionconsumesacertainamountofgas.
smart contracts developed using solidity are compiled into such bytecode sequence before they are published into the blockchain.
likebitcoin ethereumalsoemploysnakamotoconsensus although with some different system parameters e.g.
block size blockgenerationrate etc.itimprovesthetransactionthroughput to about tps but the consensus still remains the major performance bottleneck.
in this situation it makes sense that the evm is designedasasingle threadenginewithouttheneedtointroduce parallelism into the transaction execution.
to overcome the throughput bottleneck of nakamoto consensus many new and more advanced consensus protocols have been proposedinrecentyears .theseprotocolsexplorealternativestructurestoorganizeblocks e.g.
dag like structure togetherwithsomenoveldeterministicblockordering schemes to allow faster global block generation rate without compromising the decentralization and security of the network and hencetheconsensusmechanismceasestobethesystembottleneck.
forexample bothconflux andohie areabletoprocess simple payment transactions with a throughput of more than tps severalordersofmagnitudesfasterthantheoriginalnakamoto consensus.furtherresearchworklikeshrec alsostudiesand developsanewtransactionrelayprotocolthatcanmoreeffectivelyutilizethenetworkbandwidthtopreventitfrombecomingthenew system bottleneck under high transaction throughput scenarios.
these techniques shift the throughput bottleneck of blockchain systems to the transaction and smart contract execution therefore introducethepressingneedfornewtechnologiesthatcanexploit the parallelism and increase the efficiency of transaction execution.somerecentresearchworks haveexploredthedesignsofaparallelsmartcontractvirtualmachineby integrating various mechanisms of concurrency control.
however according to the reported results the speedup that can be achieved by these proposed solutions is far from linear when applied to the real ethereumworkload.
we observed thatthis is mainlybecause of the lack of inherent parallelism in the real world workload itself.
for example by investigating the historical ethereum workload we found that many critical paths of a series of transactions that have to be executed sequentially are caused by the use of sharedglobal counters.
we believe that the essential way to further im prove significantly the inherent parallelism of the real workload is to introduce a better programming paradigm that can allow the developers to express parallelism more easily while keeping the originalsemantics.inaddition inthedecentralizedenvironment driving users to adopt a new paradigm is not that straightforward as it may incur extra costs from either the engineering or theeconomics considerations.
therefore some new design of incen tive mechanisms is required to make the paradigm applicable to real world applications.
empirical study whatspeedupshouldweexpec twhenweexecuteblockchaintransactions in parallel?
to answer this question we designed an empirical study using a dataset of historical ethereum transactions.
.
methodology we empirically studied the amount of parallelism present in a realworlddatasetusinghistoricalethereumtransactions.tothisday ethereumremainsthebackboneofthedecentralizedapplicationecosystem.
as such this workload represents the most common smartcontractinteractionscenarios andthefindingscanbegeneralizedtomanyothersystems.ourexperimentmainlyfocuseson theperiodbetweenjan 2018andmay 236blocks intotal seesections3.3and7foramoredetailedjustificationof the dataset used.
thesubjectofthisexperimentissmartcontractstorageconflicts i.e.
cases where two transactions within the same block access the same entry in the state tree and at least one of these accesses isa write.
to obtain these results we ran an openethereum node formerlyparity modifiedsothatittracksandstoresallcontract storage accesses.
we stored these traces for blocks 1to in a local database.
in this experiment other kinds of conflicting accesses e.g.
conflicts on the account balance are not considered.
giventhattheexecutiontimeoftransactionsisunknownand might vary from node to node we used the transaction gas cost obtained from the transaction receipt as an approximation of this.
this follows the practice of a number of related works .
giventhe transactiondependenciesderived fromtheirstate access tracesand thegas costsof thetransactions weconstructed a dependencygraphforeachblock.then simulatingnon preemptive execution on and threads we constructed an optimal scheduleforeachblock i.e.
aschedulethatensuresthatnotransac tionneedstoabortwhilealsomaximizingthreadutilization.under this execution model the overall execution cost of this schedule puts an upper bound on the potential speedup that we can achieve authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa p ter garamv lgyi yuxi liu dong zhou fan long and ming wu any other schedule might either need to abort and re execute conflicting transactions or delay execution through locking.
apart from the overall execution cost as approximated through the overall gas cost we also inspected the heaviest path in the transaction dependency graph.
.
results and findings execution bottlenecks.
the experiment shed some light on the limitsofspeedupwecanexpecttoachievewhenexecutingethereum transactionsinparallel.
we foundthat theoverall speedupon the observed period wasonly 4x compared to theserial execution an underwhelming result considering that we had or even more threads available.
a closer look at the per block results shows that in fact manyblocks have much higherspeedups but a significant portion of blocks perform poorly see figure .
figure1 distributionofparallelspeedupbounds when comparing the execution cost of a block to the execution cost of the heaviest path in its dependency graph we found that thesetwooftencoincide.thismeansthattheoverallexecutionis bottlenecked on the execution of the heaviest path.
when we look at single blocks this heaviest path is often just a single transaction when for example a block has many simple payment transactionsandoneexpensivesmartcontractcallthatexecuteshundreds of token transfers then this latter transaction will dominate the execution time.
under our non preemptive scheduler model and the inherently serial execution model of the evm there is no easy way to handle suchsingle transactionbottlenecks.ourfocus instead isfinding effective ways to handle bottleneck chains of two or more transactions.
to focus on these we re ran our experiment with batches of consecutive blocks as the unit of execution instead of just a single block.theideaisthat giventhousandsoftransactions therelative weightofasingletransactionwillbemuchsmaller.thesameexperiment executed on batches of blo cks shows an overall speedup of9.46xcomparedtoserialexecution.
inthiscase we observedthe same result batches are often bottlenecked on a single chain of tens or sometimes hundreds of dependent transactions.we further examined the impact of these bottleneck transaction chains by re running the experiment while ignoring conflicts arising from these smart contracts.
the result is an overall speedup of .8x compared to serial execution.
these results show that bottlenecktransactionsnotonlyhaveacrucialimpactontheparallelismofourdataset butalsothatbybreakingupthesedependencychains wecanpotentiallyachievesignificantlyhigherspeedups.
classificationofsmartcontractconflicts.
togainabetterunderstandingofsmartcontractbottlenecks wecollectedtheprimary bottlenecktransactionchainsforeach30 blockbatch andcollectedthebatchesthathaveaspeedupboundof10xorless 3242intotal .
then we selected a random sample of batches and analyzed them manually.
table shows selected examples from this sample.
in terms of application types we identified three broad categories erc20 tokens token distribution airdrops accounted for of the bottlenecks in our sample decentralized finance defi applicationsmadeup29 while gamesandcollectibles non fungible tokens nfts were the cause in of the cases.
in most cases erc20 tokens lead to conflicts when there are several token transfers over multiple transactions that distribute tokensfromthesamesenderaddress.transactionsmightalsohave other dependencies for instance the total supply is updated every time new tokens are minted.
while erc20 token distributions are heterogeneousintheirimplementation e.g.
theyusevariousinter faceslike transfer multitransfer batchtransfer multisend aidrop these all result in similar conflict patterns.
in defi applications like idex and bancor a common source of conflict is the fee account whose token balance gets updated for everytrade.inthecaseofidex themajorityoftradesinvolveeth so they all increment the eth balance of the idex fee account.
examplesforgamesandcollectibles nfts includecryptokitties etheremon and idleeth.
these often involve some globally sharedcounters likethenumberofkittiesinthecaseofcryptokitties.
maintaining an array of game items is also common.
when a game involves payments and rewards the fee recipient and reward sender account s balance might also lead to storage conflicts.
intermsofthesourceofconflicts wefoundthatin194of200 batches the root cause is one or more counters that get incremented or decremented by differenttransactions.in oursample theothercommonsourceofconflicts arrays onlyaccountedfor about of the cases.
bottleneckcodeexamples.
asanexampleforcounterconflicts intokendistributions letusdiscusstheexampleinlisting1.when calling transfer the sender s balance balances is debited while the recipient s balance is credited.
the sender sbalance corresponds to one specific storage location in the statetree.
the debit operation will compile to a load sload an add add and a store sstore operation among others.
when two transactions trigger this function from the same sender address concurrently this will result in a conflict.
1function transfer address to uint256 val ... balances val balances val ... listing solidity counters source consensys eip20.sol authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
utilizing parallelism in smart contracts on decentralized blockchains by taming application inherent conflicts icse may pittsburgh pa usa table examples for bottleneck root causes from our batch random sample block batch contract contract type method s conflict type conflict source storj erc20 transfer storj counter same sender account free bob tokens erc20 airdrop bobx counter totalsupply idex defi trade adminwithdraw counter eth fee account balance bancor defi quickconvert counter bancor bnt fee recipient cryptokitties core games nft breedwithauto counter pregnantkitties mythereum card games nft mintspecificcards array cards.push card let us look at another example this time for arrays and collectibles listing2 .inthepopularcryptokittiesethereumgame eachnewcollectibleisstoredinanarray.the pushoperationon solidityarrayswillmodifytwostorageentries first itwillstore the new item at a location derived from the array s length and second itwillincrementitslength.twoconcurrenttransactions will both modify the array length and as such they will conflict.
1function createkitty ... ... uint256 newkittenid kitties.
push kitty ... listing solidity arrays source cryptokitties .
generalizability of the observations our evaluations are based on a relatively narrow period of the ethereum transaction history.
this is because acquiring the en tire transaction dataset and generating storage access traces is extremely resource consuming both in terms of storage and time.
webelievethechosenperiodisrepresentativeoftoday sethereum workload and so our findings are generalizable.
the application patterns we observed defi nft token distributions are evenmore dominant today.
contract developers have no incentive toaddress common storage bottlenecks.
in fact just by a cursoryglance we can spot storage conflicts in many recent popular ap plications uniswap exchanges that involve the same token will always conflict on the counters that represent token reserves contract uniswapv2pair .
similarly opensea trades will transfer tokenstothesame protocolfeerecipient .thissuggeststhatthe conflicts we identified are even more common today.
avoiding application inherent conflicts as we have seen in section a large portion of storage conflicts is associated with storage slots that belong to either counters orarrays.
by counterhere we mean a variable that one can use to track a quantity by incrementing or decrementing it regardless of its current value.
arraysin solidity are a simple data structure that stores a sequence of elements along with the number of elements.
intheory atransactiondependencychaincouldinvolvemultiple conflictingstorageslots.forinstance thechain a b c couldmeanthat aand bconflictonacounter while band c conflictonanunrelatedarray.in practice however thisisrarely thecase.mosttransactionsinaconflictchain willexecutesimilar operationsandwillconflictonthesamestorageentryorentries.in this case dependencies are transitive i.e.
cwill conflict with a.toalleviatetheimpactofthesetransactionbottleneckchains we needtobreak them up into multiple shorter chains by eliminating dependencies between subsets of the transactions involved see figure2 .weproposethreetechniquestoachievethis.asarrays only account for a small fraction of storage bottlenecks section .
we will focus on counters in this section.
technique conflict aware token distribution.
inourevaluations we saw that token distributions token sales airdrops are by far the most common sources of bottleneck conflicts.
in themajority of cases the source of conflict is the storage entry that stores the sender account s current balance.
thesimplestwaytoaddressthesecommonbottlenecksistouse multiple sender addresses.
by distributing the initial funds where applicable to asetof senderaccountsinstead ofasingle account andusingdifferentsenderaddressesforconsecutivetransactions wecandividethesetofbottlenecktransactionsintodisjointsetsof conflicting transactions each less likely to form a bottleneck.
ofcourse thefeasibilityofthisapproachdependsonthespecific implementationofthetoken.sometokenshaveotherdependencies for instance the total supply oftokens might alsobe incremented eachtimenewtokensareminted.inthepresenceofsuchdependencies we need a more sophisticated and general approach.
figure breaking up a conflict chain into multiple disjoint conflictchains.onthetopofthefigure alongconflictchain requires transactions 9to be scheduled serially on the same thread dominating the overall executiontime.
by breaking up this chain into two 8and each resulting chain will still need to be executed serially but the two chains can be executed in parallel to each other.thisallowsustoachieveamuchhigherspeedup.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa p ter garamv lgyi yuxi liu dong zhou fan long and ming wu technique partitioned counters.
using a technique similar tosloppy counters widely used in the linux kernel we propose a way to route multiple writes on the same counter to multiple distinct storage entries.
as writes to different storage entries do not conflict this technique can drastically reduce the conflict rate.
themainideaofpartitionedcountersisshowninlisting3.here wehaveasinglecontractthatrepresentsacounterinstance.the valueofthecounterisactuallymaintainedon3separatestorage entries called sub counters.
each time a transaction modifies the counter svalue weassignasub counterbasedonthetransaction ssender address.as addressesare derived usingcryptographichash ing thiscanbeviewedasapseudorandomsub counterassignment.
whenreadingthevalueofthecounter allsub countersareaccessed and their values are summed.
1contract partitionedcounter len int256 public cnt function add uint32 n internal uint8 slot uint8 tx.origin len cnt n function get internal view returns int256 sum for uint8 i i len i sum cnt listing partitioned counters implemented in solidity partitionedcountershaveseveraladvantages.first agiventransaction swriteswillalloperateonasinglestorageentry evenifit incrementsthecountermultipletimes asthesenderaddressdoes not change throughout the transaction s execution.
second twotransactions from two distinct sender addresses that both incre ment the counter have a much reduced chance of operating on thesamesub counterandthusconflictsareoftenavoided.third the counter can be adjusted based on the use case e.g.
for coun ters used frequently one could use more sub counters and onecould use different criteria for routing transactions to different sub counters.ourexampleroutestransactionsbasedonthesender address tx.origin as this addresses common token conflicts.
partitioned counters have two main drawbacks.
first while we onlyneedtoaccessasinglestorageentryforwritingthecounter readingit willtouchallsub counters.as aresult anytransaction that reads the counter will conflict with all writing transactions.
as such this technique is suitable for write heavy counters.
fortunately manyofthecountersweanalyzedareneverreadthrough transactions.second partitionedcounterscanbesignificantlymore expensive than built in integers especially when it comes to readingthecounter.thisdrawbackisoffsetbythepotentialincreasein parallelspeedupthatpartitionedcountersoffer.moreover many counters are rarely or never read in a transaction context.
technique commutative evm instructions.
wehavediscussedtwoapproaches.oneoperatesonthe applicationlevel i.e.
it addressesconflictsbyintroducingspecificwaystointeractwiththeapplication.theotheroperatesonthe smartcontractlevel byofferingtoolstocontractdeveloperstoavoidconflicts.athirdapproach istotackleconflictsonthe virtualmachinelevel byextendingthe protocol by new instructions that have better conflict tolerance.when the ethereum virtual machine evm executes an increment operation it first loads the storage entry s current value into memory sload thenmodifiesthisvalue add andfinallyitstores the end result back into the storage entry sstore .
this behavior originates from the solidity compiler.
as discussed before two transactions incrementing the same counter will both read and write the same storage entry and so they will conflict.
for counter increments the current value is only used for calculating the new value and otherwise it is irrelevant.
put in another way unlike other read write conflicts increments are commutative.
two transactions that increment the same counter but do not use itsvalueotherwise couldbeexecutedinanyorder.however under the current semantics of the evm such transactions will conflict.
we introduce special semantics for executing increments in a way that does not result in conflicts.
rather than compiling increments into ssloadandsstoreinstructions they instead get compiledintoasingle caddinstructionthatstandsfor commutative add.
this instruction takes a storage location and a value as its parameters.whenthevmencountersa caddinstruction itdoes not eagerly execute the addition but instead it records this operation in an in memory temporary storage.
if the vm encounters an sstoreoperation it then erases the pending caddinstructions on thesamestoragelocationastheyhavebeenoverwritten.ifthevm encounters an sloadoperation it then first executes all pending caddoperations on the same storage location then uses the result for this sload.
after the transaction has been executed the scheduler proceeds tocheckforconflicts.concurrentstoragereadsandwritestothe same storage location constitute conflicts.
if however two transactionsonlyhave caddoperationsonastoragelocation butnoother reads thentheyarenotconsideredconflicting.inthiscase these caddoperations are executed serially during the commit phase.
introducing a caddinstruction for signaling commutative operations to the vm allows us to avoid a major class of transaction conflicts that originate from operations on a single counter.
occ with deterministic aborts .
incentives in parallel scheduling permissionless blockchains have no central authority that could enforce protocol compliance.
instead protocol designers introduce incentives that encourage goodbehavior creating blocks avoiding storagebloat andpenalize badbehavior attacks .theefficiencyof parallelschedulersdependsonvariousfactors someofwhichare under the users control.
therefore parallel execution must also come with a set of incentives that maximize its effectiveness.
adetaileddesignofsuchasystemofincentivesisbeyondthe scopeofthispaper.weobserve however thatanyincentivesystem must be able to deal with spam or denial of service attacks that target mispriced operations and resources in the system as has happened several times on ethereum .
parallel execution based on occ will inevitably lead to some transaction aborts and reexecutions.ifthereisawayforuserstointentionallytriggeraborts without any penalty then that opens up the door to a serious dosvulnerabilityofthescheduler.ourgoal then istodefinean execution framework that would allow schedulers to deal with this issue by deterministically pricing transaction re executions.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
utilizing parallelism in smart contracts on decentralized blockchains by taming application inherent conflicts icse may pittsburgh pa usa figure classic occ transactions are committed right after execution regardless of their order in the block.
this results in different commit orders 4and andend states might diverge.
figure4 occwithdet.commitorder after execution commit is delayed untiltheprevioustransactionintheblock has committed.
the commit abort decisionforatransactionmightdiverge on different nodes .
figure occ da transactions can onlyseeaversionofthestatedecided prior to execution even if a more re cent version is available.
each executionofatransactionwilleithercommit or abort on all nodes.
.
levels of determinism parallelschedulersintroducealevelofnon determinismintothe execution astheprecisetimingoftransactionsmightdifferfrom nodetonode.thisisindirectconflictwiththerequirementsofthe consensusmechanism whichreliesonstrictdeterminismforthe nodes to converge into a consensus state.
in blockchain systems therefore parallel schedulers must maintain higher levels of determinismcomparedtotraditionalalgorithms.wedefinethefollowing three levels of determinism in optimistic transaction execution.
classicocc classicocc hasnodeterminismguarantees.
generally transactions start execution on a firstcome first servedbasis.node localconsistencyistypically ensuredbythepropertyof serializability whichdictatesthat theobservableresultsoftheparallelexecutionareequivalent to those of someserial execution.
however ex ecution of the sametransaction set ondifferentnodesmight correspondto different serial executions and yield diverging results.
occ with deterministic commit order instead of dictatingthattheparallelscheduleisequivalentto anyserial schedule it must correspond to a specificserial schedule.
thismeansthatthefinalexecutionresultondifferentnodes willbeequivalent eventhoughtheactualexecutionmight differ.thisrequirementcanbesatisfiedbycommittingtransactionsstrictlyaccordingtotheblocktransactionorder or by scheduling according to a dependency graph .
occ with deterministic aborts while deterministic serializationorderguaranteesthattheobservableoutputs there sultingstate arethesameacrossallnodes theactualexecu tionmightstilldiffer duetodifferenttimingoftransactions a transaction might be committed on one node and aborted on another.
if the protocolrelies on this commit abort decision to penalize aborts and avoid dos attacks see section .
thiswillleadtodivergingstates.thus thehighestlevelof determinism we aim for is when aborts themselves are deterministic ifatransactionisabortedonceononenode it is aborted exactly once on all the other nodes as well.
occwithdeterministiccommitorder isatopicwithconsiderable researchattentionindeterministicdatabasesystems .on the other hand the stringent requirements of occ with deterministic aborts to the best of our knowledge have not been describedelsewhere.
while imposing such restrictions on occ schedulersmight certainly have a negative impact on the parallel speedup we argue it is crucial for implementing parallel schedulers under a distributed consensus setting.
.
occ da occ with deterministic aborts ourexecutionmodelisbasedonoccwith snapshotisolation.transactionsarescheduledonasetofthreadsforexecution.executed transactionsarecommittedaccordingtotheblocktransactionorder.
atthestartofitsexecution eachtransactionreceivesa snapshot correspondingtotheversionofthestorageaftersometransactions preceding it have been committed.
this snapshot does not change during the execution of the transaction.
the highest transaction idwhosecommittedwritesarepartofthissnapshotcorresponds tothestorageversion ofthesnapshot or equivalently thestorage version of the transaction to be scheduled.
as an example let us assume that transaction 1has been committed transaction 2is being executed on one thread and we are scheduling transaction 3on another thread.
in this case canseestorageversion i.e.
thecontentsofstorageuptoand including swrites .if duringtheexecutionof 2modifies some storage values these updates are not visible to .
if during thecommitof theschedulerdetectsthatsomevaluesreadby wereconcurrentlymodifiedby 2andthus 3operatedonoutdated values then 3is aborted and scheduled for re execution.
in distributed consensus transaction execution is deterministic the same code triggered with the same inputs its parameters and authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa p ter garamv lgyi yuxi liu dong zhou fan long and ming wu thecurrentstate willproducethesameoutputs.fromthis itiseasy to see that a transaction executed over a specific storage version i.e.
thesamestate ontwodifferentnodeswilleithercommiton both or abort on both.
wethendefineocc daasfollows.weassignastorageversion to each execution of each transaction prior to execution txn i svn i. txn i standsforthe i sexecutionoftransaction n where i ....notethat dependingontheschedulerimplementation atransactioncanbeexecutedtwoormoretimes.thelastexecution mustcommit whileallprecedingexecutionswillbeaborted.forallpotentialexecutions iofalltransactions ninanexecutionunit e.g.
in a block svn iis defined uniformly on all nodes and it is defined prior to execution so that it does not rely on non deterministic executiondetails.then forany txn i transaction nwilleither abort or commit on all nodes.
throughouttheexecutionof txn i theschedulermustallow the transaction to access storage entries written by transactions up to and including transaction svn i. the scheduler must not allow thetransactiontoaccessstorageentrieswrittenbyatransaction with an id higher than svn i even if it is committed.
if svn ihas not committed and therefore the storage version specified priorto execution is not available when txn i is being scheduled for execution the transaction cannot start execution and must wait.
.
example wehave4transactions labeled .transactions 1and 3have a storage conflict 1writes a storage entry read by .
let us then walkthroughschedulingthesefourtransactionsontwodifferent nodeswith2threadseach underdifferentdeterminismguarantees.
figure depicts an example schedule using classic occ.
this approach has no determinism guarantees.
in particular we can see that the commit order on node ais while it is 4onnodeb.thedivergingrelativeorderofthetwoconflicting transactions might lead to diverging states on the twonodes.while 1and 3conflict inthisexampletheyarenot executed concurrently and therefore neither needs to be aborted.
infigure4 weseeanexampleof occwithdeterministiccommit order.o nn o d e b 3finishes execution before .h o w e v e r i ti s is not committed until after 1has at which point the conflict is detectedand 3isaborted.thefinalcommitorderonbothnodes a andbis .however duetothedifferentrelativeorder of the execution of 1and 3on the two nodes the first execution of 3commits on node awhile it aborts on node b. in distributed consensus such non determinism is not acceptable section .
.
notethat 4onnodebcannotread uncommitted resultsfrom 2or eventhoughbothfinishexecutionbefore .thiskindof snapshot isolation allows us to avoid cascading aborts.
an investigation of whether allowing transactions to read uncommitted results is beneficial is beyond the scope of this paper.
finally figure shows how occ da works.
prior to execution all nodes decide that the first execution of 3can only read the statepriorto sexecution sv3 whilethesecondexecution canseethestateafter sv3 .
therationaleforthesevalues isdiscussedinsection5.
.
asaresult eventhough 3isscheduled after 1onnodea itisnotallowedtosee swritesandthusitwill abort.thisyieldsaresultconsistentwiththeothercasewhere 3isexecutedconcurrentlywith asonnode b.thesecondexecution will see the latest state on both nodes aandband consequently it will commit on both nodes.
.
assigning storage versions letusmakesomeremarksabouttheassignmentofstorageversions.
the simplest approach is to set svn .
this approach does notrelyonanyinformationaboutthetransactionset.whilethis simplefirstapproximationworks setting svn 0to thestateprior to transaction s execution will lead to aborts if the transaction set contains any dependencies.
for a more sophisticated heuristic for storage version assignment wecanrelyontwokindsofinformation.first wecanusethe expectedexecutiontimeoftransactionstofindthelateststorage versionatransactionisexpectedtosee.if basedonthisestimation 3willstartexecutionafter 1butbefore thenweset sv3 .
second an estimation of the transaction dependency graph might allowustopreventaborts.forinstance ifweguessthat 3islikely to conflict with then we can set sv3 .
we do not have perfectinformationaboutexecutiontimesortransactiondependencies.
forthe former the transaction gaslimit canserve asa reasonable firstestimation.forthelatter staticanalysisandvariousheuristics might provide us with an approximate dependency graph.
theaccuracyofthestorageversionassignmenthasadirecteffect on the performance of the parallel scheduler if we use a storage versionthatistoolow thenweriskintroducingmoreaborts.if on the other hand we use a storage version that is too high then the transaction might need to be delayed while it waits for the storage version to become available leading to thread under utilization.
finally another aspect to consider is the overhead of the scheduler.maintainingmultiplestorageversions mightintroduceasignificantstorageoverheadincasetherearemanywrites.limiting the lowest storage version each transaction can see might help us put a limit on this overhead.
.
the algorithm adetailedalgorithmforocc daispresentedinalgorithm1.this algorithm takes a set of transactions and their dependencies as inputs.
the dependency graph can be constructed through an estimation of the read write set of each transaction.
it is not necessaryfor the estimation to be perfect but it needs to be deterministic and consistentonall theblockchainnodes.themoreprecise itis the fewer unnecessary aborts we may encounter.
inthebeginning thestorageversionofeachtransactionisinitializedasthemaximumidofthetransactionsthatitdependson according to the dependency graph or if it has no dependency lines2 .thetransactionsarepushedintoamin heap htxsindexed by the storage version.
there are three other min heaps.
hreadymaintainstransactionsreadytobescheduled hthreadsis exactly the thread pool for executing transactions and hcommitis forthetransactionsthathavealreadyfinishedtheexecutionand wait to be committed.
the global variable nextmaintains the id of thenextto be committedtransaction.notethatthealgorithmdescribesthetransactionexecutionmechanismusedinoursimulation whichresultsindeterministicexecutioncompletionorderaccording to the given gas consumption of each transaction.
however in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
utilizing parallelism in smart contracts on decentralized blockchains by taming application inherent conflicts icse may pittsburgh pa usa algorithm occ da input transactions t gasgas number of threads t none or a dependency graph d 1htxs an empty minheap of sv id 2forid t do 3ifdexiststhen idmax foredge id id prev ddo tx iddepends on tx idprev tx idreads what tx idprev writes idmax max idmax idprev htxs.push idmax id 10else htxs.push id 12hready an empty minheap of id sv 13hthreads an empty minheap of gas id sv 14hcommit an empty minheap of id sv 15next 16whilenext t do stage schedule 18for sv id htxs.pop do ifsv next 1then htxs.push sv id break else hready.push id sv 24while hthreads pool sizeand hready 0do id sv hready.pop hthreads.push gas id sv stage execution 28if hthreads 0then gas id sv hthreads.pop hcommit id sv fori hthreads do hthreads .gas hthreads .gas gas stage commit abort 34while hcommit 0do id sv hcommit.pop ifid nextthen hcommit.push id sv break foridprev do iftx idprev s write set tx id s read set then get aborted break ifabortedthen htxs.push id id else commit successfully next next 48return arealsystem thecorrectnessandeffectivenessofourscheduling strategy do not rely on this execution determinism.
lines16 47showthestagesthattransactionsexperience.stage1 isschedulingtransactionsintothethreadpool .weconsider a transaction ready to execute when the transaction correspondingto its storage version has been committed.
ready transactions are pushed into the thread pool if it has empty slots .
stage2istheexecutionoftransactionsinthethreadpool.we simply choose the transaction with the minimal remaining gas which is exactly the top of hthreads push it into hcommit and maintain the gas accordingly.
thelaststageistryingtocommitthetransactionsonebyone inhcommit lines33 .transactionsin hcommitaremaintained in the order of id since we always commit transactions in order withoutskips.foreachto be committedtransaction thealgorithm checkswhetheritshouldbeabortedorcommittedthroughchecking whetherthereexistanyread writeconflictsbetweenthecurrent transaction and those transactions committed since it starts toexecute lines .
if aborted the transaction is pushed back intohtxswith its new storage version set as id otherwise the commit succeeds.
evaluation .
experimental setup the experimental evaluation of the techniques presented in this paper builds on the empirical study discussed previously.
all simulationsdiscussedhereoperateonthestorageaccesstracescollected from the ethereum transaction dataset as outlined in section .
for evaluating the proposed bottleneck elimination techniques weanalyzedthebest caseparallelexecutiontimeusingthetransactiondependencygraph withandwithoutapplyingthesetechniques.
in this experiment we rely on perfect knowledge of transaction dependencies.
we start by constructing a dependency graph of transactions wherevertices thatcorrespondtothetransactions areweightedbythetransactiongascosts.then wesimulatescheduling the transactions on a set of threads .
in each scheduling step out of all transactions with no unexecuted dependencies we select the one that has the heaviest path starting from it.
the gas cost of this schedule serves as the baseline.
for thisexperiment we use block batches as the unit of execution to reduce the effect of single transaction bottlenecks see section .
.
for evaluating the potential effect of using partitioned counters weprunethetransactiondependenciesinapseudorandomfashion in a way that is consistent with this technique.
for instance fora counter of length for each dependency we remove it with a probability of .
for seeing the impact of deterministic scheduling we simulated an occ scheduler with deterministic commit order as our baseline.
theschedulerhaszeroupfrontinformationaboutthetransaction dependencies.
when scheduling a transaction for execution the scheduler uses thehighest committed transaction id asits storage version.tomakethetransactioncommitorderdeterministic the scheduler commits transactions according to their block order.
for deterministic aborts instead of using the highest executed transactionidasthetransaction sstorageversion weuseastorageversion definedpriortoexecution weuse i.e.
thestoragepriortothe block s execution as the storage version for the transaction s first execution and use tx id for its second execution.
we then compare the overall gas costs of these two occ simulations.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa p ter garamv lgyi yuxi liu dong zhou fan long and ming wu figure distribution of speedup bounds block batches .
assumptions and limitations ourevaluationsarebasedonsimulationsusingreal worlddata not on implementation in a real world blockchain system.
we chose to simulate scheduling because currently there is no parallel evm available.thepotentialoverheadoftheparallelvmisnotconsideredasitdependsheavilyontheactualimplementation.weaimto comparedifferenttechniquesinacontrolledanddeterministicway without speculating about the vm implementation.
for the two experiments our focus is on the change in the maximum speedup achievableand thedifferencebetween thetwooccmethods.
we believe these relative measures also apply in a real world system.
theevaluationassumesthatpartitionedcounterscanbeapplied toallstorageconflicts.thisisareasonableapproximationbasedontheresultspresentedinsection3.
wherewefoundthatalmostall conflicts can be traced back to counters used in token distribution scenarios.
the information available to our simulated scheduler storageread writetraces isinsufficienttodecidewhetherastorage location corresponds to a counter for this one would need to rely on the contract s source code which is often not publicly available.
theothertwoproposedtechniquesarenotevaluated.theeffect of conflict aware token distribution is equivalent to that of partitionedcounters.asforcommutativeevminstructions ourstorage tracesdonotprovideinformationabouttheseriesofinstructions executed that would be necessary to evaluate commutative operations.
we expect the effect of the three techniques to be similar as they all remove edges from the transaction dependency graph in a similarway.infact commutativeevminstructions mightbemore effective the first two techniques will still result in some conflicts while this third one could serialize all updates without conflict.
.
evaluation results overallresults.
foreach10 blockbatch welookatits optimal execution cost on threads based on the transaction dependencygraph andcomparethistoitsserialexecutioncost.forthebaseline with no modification the average speedup over all batches is .93x while the overall speedup on the whole period is .25x due to the bottlenecks discussed in section .
using a counter of length theaveragespeedupbecomes21.23x whiletheoverallspeedup is17.96x.thehighestspeedupwecanhopetoachieve whenwe remove all transaction dependencies is .63x on average while theoverallspeedupis20.61xinthisexperiment.
as for occ da over single blocks with threads the baseline occ scheduler has a .287x overall speedup min .52x max 32x figure occ da performance impact avg .89x whilethedeterministicschedulerresultsin3.275xoverall speedup min .52x max 32x avg .84x .
we observed similar results over batches of blocks.
discussion.
theseresultsshowthattheparallelisminherentin thedataset .25x ismuchlowerthanwhatthetransactionswouldallowfor .63x .thisisduetothefactthattransactionsdepending on each other need to be scheduled serially or get aborted .
by eliminatingsomedependenciesusingtechniqueslikepartitioned counters wecanapproachthislimit achievingupto17.96xspeedup withjustacountersizeof2.figure6showsoverlayedhistogramsfor the distribution of speedup bounds for each block batch.
from this figure we can clearly see how partitioned counters let us converge to the optimum in terms of the parallel speedup achievable.
figure shows the performance degradation caused by occda blue comparedtooccwithdet.commitorder red onsingle blocks.
for this figure blocks were ordered by their baseline speedup red .
we can see that extending the scheduler with deterministicabortsdidcauseperformancedegradation however the speedups generally still do not diverge much from the baseline exceptforafewoutliers.infact inthisdataset .
oftheblocks producedexactlythesameresultusingthetwoschedulers while only0.
resultedin80 ofthebaselinespeeduporlower.
implications.
theseresultssuggestthatpartitionedcounterscan haveasignificantimpactonthehighestparallelspeedupthatwe can achieve.
even with just a counter of length when applied toallconflicts theparallelspeedupbounddoubled approaching the optimum.
raising the counter length we keep approaching the optimum.
based on these results we believe that the techniques proposedinthispaper whenappliedtosomecontractsresponsible forsomemajorbottlenecks cansignificantlyincreasetheparallel speedup that any real world parallel scheduler can achieve.
theresultsaboutocc dasuggestthatraisingthelevelofdeterminism only has a minor performance impact decreasing the overallspeedupfrom3.287xto3.275x.asshowninfigure7 whilethere areoccasionaloutlierswithsignificantperformancedegradation underthis schedulingmechanism they arerare.
whileitis possiblethatamoreperformantscheduler andaworkloadwithmore parallelism willresultinalargerdiscrepancybetweenthesetwo numbers based on these initial evaluations our expectation is that occ daissuitableforimplementationinreal worldblockchain protocols.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
utilizing parallelism in smart contracts on decentralized blockchains by taming application inherent conflicts icse may pittsburgh pa usa threats to validity themostsignificantthreattothevalidityofourstudyisthattransaction and contract interaction patterns have changed since the observedperiodin2018andsoourconclusionsdonotholdformore recent periods.
we believe that this is unlikely.
the issues pointed outinthispaperhavenotbeenaddressed andsotherehasbeen neither awareness nor incentive to avoid these conflict inducing patterns.ifanything theproblemhaslikelybecomemoresevere with several new hotspot contracts emerging many of which have obviousstorageconflicts.anexampleforthisisuniswap aspointed out in section .
.
saraph et al.
also observes that the parallelizability of blocks seems to decrease over time.
there is a chance that the gas cost of transactions does not accurately capture their running time which would reduce the accuracyofourevaluations.giventhat themosttime consuming operations namely sloadandsstore haveveryhighgascosts large deviation seems unlikely.
inthisstudy weonlyconsideredstorageconflicts.otherconflict types include conflicts on an account s balance and nonce andconflicts on contract creation destruction.
balance conflicts canbe handled using partitioned counters.
nonce conflicts require adjustingthenoncemanagementmechanism.ascontractexistence conflicts are rare they are unlikely to have distorted our results.
relevance and future work scope.ourworkfocusesonethereumbutourfindingsandsolutionsareapplicable tootherchainsas well.thisclaimis supportedbytwotrends.first manysignificantblockchainsadoptethereum s execution logic ethereum classic bsc while others are in the processofaddinganevmcompatibilitylayer near solana .second differentchainssharecommonusecases defiswapplatforms nftmarketplaces andpopularethereumapplicationsareoften forkedandredeployedonotherchains uniswapandpancakeswap .
this results in similar transaction workloads on these chains.
this similarity is supported by previous research as well .
feasibility.
implementing parallel execution of blockchain transactions requires further research and engineering effort.
we need further research on parallel execution incentives and the evm needstobe extendedwithaparallelscheduler.
occ daprovides a foundation for these by offering a parallel scheduling framework suitable for distributed consensus protocols.
we also need techniques for increasing the parallelizability of the transaction workload.theproposedbottleneck eliminationtechniquesaddress this requirement.
of these techniques only commutative evm instructions requiresaprotocolupgrade.finally furtherworkis required to design an optimized deterministic parallel scheduler building on existing techniques from traditional database systems.
related work parallel execution of blockchain transactions has been the focus of considerable research attention in recent years.
perhaps the firstsuch work is by sergey et al.
in which the authors propose totreatsmart contractsasconcurrentobjects topreventcommon bugs.in2019 saraphetal.
publishedanexploratoryworkto estimatethepotentialbenefitofexecutingethereumtransactionsinparallelbysimulatinga2 phaseparallel then serialoptimistic scheduler.
they observe a fold speedup for the period in using64threads andidentify cryptokitties asahotspotcontract.
theybrieflyremarkonincentivesandcommutativeoperations.reijsbergen et al.
evaluate the potential speedup on seven public blockchains using dependency graphs working on the granularity of contracts instead of storage entries.
they report that up to 6x speedupisachievableusing8ormorecores andobservethatlarger blocksareeasiertoparallelize.ourempiricalstudyisinspiredby these two works and we reinforce or expand on some of their conclusions.howev er theseworksdonotanalyzeconflictsin depth andsotheyfailtoexplainthepoorparallelspeedupstheypredict.
their models also do not fulfill the determinism requirements that would make them practical in public blockchains.
numerous previous works have proposed to use various concurrency control techniques to parallelize blockchain transactions.
in theapproachproposedbyanjanaetal.
minersuseoptimistic stm to execute transactions and produce a dependency graph that validators can use to re execute transactions.
zhang et al.
insteadofusingadependencygraph proposetoincludeeachtrans action swritesetintheblock andletvalidatorsusethesetodetect conflicts.
panget al.
alsoconsider the granularityof the additionalinformationincludedintheblock.dickersonetal.
propose to use abstract locks to detect conflicts during speculative parallel execution.dozieretal.
ontheotherhand useapessimistic concurrencycontroltechniquebylockingtheaccountsaccessed during transaction execution.
finally bartoletti et al.
offer a formalmodelofconcurrentblockchaintransactions.mostofthe proposedtechniquesareprotocol breaking inthesensethatthey modify the block structure and the execution semantics while our approachremainscompatiblewithserialimplementations.these works show modest speedup on parallel miners but they do not address the root cause of the speedup limit.
an overview of this area can be found in the survey piece by kemmoe et al.
.
optimistic concurrency control has been widely used in databasesandwide areadistributedsystems.deterministicocc was pioneered by abadi et al.
in calvin they use a deterministic locking protocol to let nodes arrive on a consistent transaction order eliminating the need for distributed commit protocols.
their approachisfurtheroutlinedinseveralotherpapers .our discussion of the determinism of blockchain transaction execution was inspired by these works.
in addition to using a predefined serialization order we introduced an even higher level of determinism where the effects of transactions that are normally not observable are also deterministic and can be used for incentive assignment.
conclusion with the evolution of consensus protocol technology in public blockchain theexecutionefficiencyisbecomingthenewbottleneckoftheentiresystem whichdrivestheneedofparallelizingthetransaction execution.
this work observes that the application inherent conflictsarethefundamentalobstacletoachievingidealspeedup in existing parallelization techniques.
to address this issue the proposed solution introduces the convenient improvement on the smartcontractprogrammingparadigmwithconsiderationofthe supportofincentives thereforeopensthepossibilityofmaximizing the parallelism of transaction execution in public blockchains.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa p ter garamv lgyi yuxi liu dong zhou fan long and ming wu