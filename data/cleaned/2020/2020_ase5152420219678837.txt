end to end automation of feedback on student assembly programs zikai liu eth zurich zurich switzerland zikail2 illinois.edutingkai liu university of illinois at urbana champaign champaign il usa tingkai2 illinois.eduqi li purdue university west lafayette in usa qili8 illinois.edu wenqing luo university of illinois at urbana champaign champaign il usa wenqing4 illinois.edusteven s. lumetta university of illinois at urbana champaign champaign il usa lumetta illinois.edu abstract we developed a set of tools designed to provide rapid feedback to students as they learn to write programs in assembly language lc a risc like educational instructionset architecture .
at the heart of the system is an extendedversion of klee klc3 that enables us to both identify issuesand perform equivalence checking between student code and agold correct version of each assignment.
feedback begins whenstudents edit their code using a vscode extension that leveragesstatic analysis to perform a variety of correctness and stylechecks encouraging students to improve their code quality.
eachtime a student commits code to their git repository our systemtriggers.
using klc3 klee the student code is executed alongwith the gold version and issues and behavioral differences aredelivered back to the student through their git repository asa human readable report test cases and scripts.
a queueingsystem allows students to monitor progress but responses aregenerally available within minutes.
we also extended the lc 3simulation tools to support reverse debugging making the processof finding complex bugs much more tractable for students and used emscripten to develop a browser based interface foruse in testing and debugging.
finally our system maintains anindividual regression test suite for each student and requiresa submission to pass all previous tests before re evaluation inklc3 thus avoiding encouraging programming by guesswork.we deployed the system to provide feedback for the assemblyprogramming assignments in a class of over students infall .
students wrote a median of around lines ofassembly for these assignments making heavy use of our toolsto understand and eliminate their bugs.
anonymous studentfeedback on the tools was uniformly positive.
since that semester we have continued to refine and expand our tools analysiscapabilities and performance and plan to deploy the system againin the near future the class is offered every fall .
i. i ntroduction learning to program is difficult.
as with all topics students learn more quickly when given immediate feedback tailored to their efforts.
however while university staff instructors andteaching assistants are capable of providing such feedback staff are not available and lack the time needed to provideindividual attention to each student s programs.
automating feedback has been an important topic for years and systems such as web cat are widely used inclasses.
we address the need for rapid feedback by leveragingklee to perform both symbolic analysis of student codeas well as equivalence checking with a correct implementationof the given assignment.
in our class students first programin assembly language for the lc instruction set architec ture isa which was invented for educational purposes inthe textbook by patt and patel .
the symbolic equivalencechecking that forms the core of our feedback system was oneof the approaches explored by the early klee work .
use ofklee in providing rapid feedback on student programs writ ten in c was pioneered by gao but the focus in that workis on c programs supported by the standard klee llvm in frastructure.
in fact most feedback systems focus on high levellanguages and few make use of symbolic analysis.
thispaper represents the first use of symbolic analysis to providerapid feedback on lc assembly programs through in depthcustomization of klee and describes the implementation andresults of deployment as an end to end system.
we decided to make use of the low level infrastructure provided by klee but to implement our own modules forpreliminary lc code analysis lc state execution a bitmemory model and search heuristics.
we also generalize theidea of loop reduction to accommodate the multi entry point loops often found in assembly language programs.
also as we felt that the klee output might be difficult for noviceprogrammers to understand and utilize we developed issuefiltering and human readable report and script generation tohelp students through their first significant debugging efforts.we refer to our extended klee as klc3.
we then extended the tools surrounding klc3 to allow students to make use of more familiar interfaces such as vscodefor editing and real time static checks as well as git to submittheir code and receive the klc3 analysis and feedback results.finally we added support for reverse back in time debuggingto the existing lc simulation tools and made them availablethrough a browser interface by leveraging emscripten andminor modifications to the c implementations of the tools.
aswe extended the tools around klc3 our system is able to to 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee cover the whole workflow of editing testing and debugging when students work on their assignments.
after developing much of this framework we deployed it to provide feedback to over students taking our introductoryassembly language and c programming course in fall providing us with several thousand code samples as well asan opportunity to survey student opinions about the tools.
the remainder of this paper is organized as follows.
in the next section we provide additional details about our fall 2020deployment and student use as background.
in sec.
iii wedescribe our lc extension to the vscode editor thatprovides feedback as students edit their programs.
sec.
iv thenprovides an overview of the system from when the studentcommits a new copy of an assignment through when theyreceive feedback.
we follow with details of our extensionsto klee in sec.
v. after deploying the system we madea number of further optimizations two of which we explainin sec.
vi.
in sec.
vii we discuss changes made to thelc simulation tools provided with the textbook to supportreverse debugging and the browser based interface that wedeveloped.
sec.
viii provides timing information about thespeed at which we are now able to offer feedback on studentprograms.
sec.
ix describes a few other aspects of our system including a summary of student feedback and comparesour approach with the commonly used web cat .
finally sec.
x offers our conclusions.
ii.
d eployment context prototype versions of most of the tools developed for this project were ready in the fall semester so wedeployed them for use in providing feedback to students tak ing our introductory assembly language and c programmingcourse.
conditions were fairly normal despite the covid 19pandemic students and teaching assistants were resident oncampus and made use of the usual classrooms and computerlabs.
the instructor however gave lectures live over zoom using multiple cameras to observe the students and to hear anyquestions.
a video inset of the instructor enabled students tosee gestures and facial expressions.
while the interaction wasnot identical to a normal semester we believe that it was asclose as possible in the physical absence of the instructor.
a total of students completed the course.
each student implemented three assignments over four weeks using lc 3assembly language.
each assignment is built upon the previousone by including a student s previous code directly.
in thefirst assignment which we call s ubroutines here students were required to write two subroutines to perform formattedoutput to the display.
in the second assignment s chedule students populated a weekly schedule with events then printedthe schedule to the display.
each event consisted of a name an hour and a bit vector of the days in a week on whichthe event occurred.
finally in the third assignment d fs students implemented a depth first search with backtrackingto fit additional events with flexible hours again specified bya bit vector into an existing weekly schedule.
students wrotea median of lines of lc code for the three assignments.since students received feedback each time they committedtheir code to the github server they were inclined to commitas they made progress providing us with code samplesfor s ubroutines samples for s chedule and for dfs.
for automating feedback we also made use of correct implementations authored by the course staff.
the klc3 feedback system was linked to the assignment submission system so feedback was automatic for all students.we did not maintain a control group as we felt it unfair todeprive students of the opportunity for feedback from klc3.in this paper we instead compare with a nearly identicalversion of the class held two years earlier in which the sameinstructor presented the same material to students in personon the campus.
students and other course staff were different of course.
students were not forced to make use of the lc 3vscode extension and the survey results suggest that onlyabout half did so.
students were also not forced to make useof our browser based lc tools but about two thirds did.
iii.
e diting in vsc ode initially we added basic static checking into klc3 to identify problems such as dead code but we wanted to givestudents feedback as early as possible.
vscode is a populareditor amongst students in later programming classes so wedecided to encourage students to try it by developing an lc 3extension that gives real time feedback as students edit theircode.
by delivering appropriate warnings to students beforethey submit their code we also enable them to fix potentialbugs before they commit to their repositories and add load toour analysis server.
the vscode extension reports three kinds of feedback errors warnings and information.
errors imply that the codecannot assemble.
warnings indicate potential bugs or poorstyle.
information shows the results of analyses on the code such as which registers in a subroutine are callee saved havetheir values preserved by the subroutine .
our vscode extension implements per instruction analysis control flow analysis and procedure based analysis.
feedbackmessages about potential issues in the code are conveyed viavscode s squiggles and pop up windows.
although none of the extension s feedback is specific to any particular assignment nor does the extension have any infor mation about what constitutes correct behavior we observethat the ability to convey meaningful feedback messages tostudents while they write their code may still increase theirexpected functionality grade in assignments.
functionalitygrade is the part of a student s grade allocated to correctbehavior as opposed to points obtained for demonstratinggood coding style and including adequate comments.
using the s ubroutines program as an example for which code samples assemble we used our grading script to calculate thefunctionality grade out of for each sample then computedan average functionality grade among samples for which ourextension reports the same number of warnings.
the resultsappear in tab.
i. code samples that generate no warningsoften still fail to implement the assignment correctly hence the 19table i functionality grades vs number of warnings number of warnings count a vg.
functionality grade .
.
.
.
fig.
.
a canonical example of a fully unrolled loop typical of those produced by students not yet able to formulate iterative constructs.
average functionality grade for warning free samples is not .
nevertheless grades for warning free samples averaged over10 points higher than samples that contain warnings indicatingthat feedback during editing can be helpful in guiding studentsto develop correct solutions.
in addition to helping with correctness early feedback can also help students to avoid developing bad coding habits.for example while extending the idea of loop reductionto assembly code see sec.
vi b we found code samplesin which students unable to formulate loops properly hadinstead written fully unrolled loops.
fig.
shows a canonicalexample in which five adjacent addresses containing pointersare checked for null and a common value is writtenfrom r3 to the address referenced by each non null pointerfound.
in the example the branch instructions are independent creating possible paths.
in some samples however studentslinked several such constructs producing thousands of paths many of which were impossible to execute due to correlationsamongst the branches.
such style is not encouraged and a largenumber of paths undermines the performance of our symbolicanalysis on the code.
the extension identifies unrolled loops byscanning through the code with different strides and detectingrepeated code segments that can potentially form a loop.
whenthe extension finds an unrolled loop it raises a warning toindicate that the code can be turned into a loop.
interestingly using the extension we found that handunrolled loops are common in student code and that theirfrequency depends strongly on the complexity of the particularloop that students are asked to write.
to illustrate this idea wecompared the final versions of the d fsassignment of students in the fall semester with those of the fall students.the assignment was changed in minor ways to reduce thelikelihood of sharing code between semesters.
in particular the days of the week were printed as three letter abbreviationsin but as full names in .
also the encoding oftable ii percentage of students vs .number of unrolled loops number of unrolled loops fall fall days in the bit vector for each event was reversed in monday was represented as tuesday as and so forth.
in2020 monday was tuesday was and so forth.
the results are in tab.
ii failure to write loops is generally common in both classes but is more common amongst the2020 students.
in terms of the assignments the slight changesproduced visible differences in the results by changing thecomplexity to conceptualize loops.
specifically the variable length weekday names complicate the process of finding thestarting address of each string and the reversal of bit vectorordering makes using these data more challenging because thelc isa makes left shift easy but right shift difficult.
fortunately our vscode extension is able to identify handunrolled loops and to raise warnings as shown in fig.
bythe squiggles under the ld instructions the first instructionin the loop body to encourage students to think harder or toseek help for implementing a loop.
fig.
.
overview of dynamic code analysis system.
iv .
d ynamic analysis overview an overview of our dynamic code analysis system appears in fig.
.
the system consists of four main components agithub server maintained by the university a webhook server a job dispatcher and the klc3 execution engine.
when astudent submits a new version of a program by pushing code the github server immediately notifies the webhook server which is implemented as an http server in golang.
thewebhook server filters out events other than modifications tothe program residing in the master branch of the student scurrent assignment then applies any policy decisions to thesubmission.
generally we limited each student to one newevaluation every five to ten minutes in order to discouragestudents from attempting guesswork while debugging.
theexact policy varied by assignment and is easily modifiable.approved new submission events are wrapped up as klc3execution tasks and sent to the job dispatcher.
the job 20fig.
.
klc3 architecture and workflow.
dispatcher is also implemented in golang allowing us to leverage go s channel abstraction to implement a queue andthen to parallelize execution of multiple klc3 executionson our server.
the job dispatcher uses four worker threadsthat continuously fetch tasks from a single queue.
for eachsubmission drawn from the queue a worker updates a localcopy of the student s git repository using the go git library extracts the submission and forks off a instance of klc3to analyze the student s code.
once klc3 has produced areport and associated files the worker incorporates everythinginto a new directory in a feedback branch of the student srepository.
the directory name indicates both the assignmentand the date and time at which the student pushed the newversion allowing students to easily locate their feedback.
theworker then returns to the queue to obtain a new assignment.students can view the report on the github websites or byupdating their own local git repositories.
we also providea web interface to our queue system to enable students tomonitor queue status and to display klc3 reports.
for thispurpose we make use of the oauth2 api of the github server.
to encourage students to make use of test cases generated by klc3 see sec.
v and to discourage programming by guesswork we implemented a regression test system.
a privateclass repository is used to maintain sets of regression tests foreach student each of which is initialized to the test casesprovided with the assignment.
before analyzing code klc3re evaluates all regression tests.
only code that passes all suchtests is then analyzed symbolically.
newly generated test casesare added to the regression test suite so a student s nextsubmission must pass the new tests as well.
v .
klc3 a rchitecture klee offers a well defined infrastructure for symbolic representations optimizers caches and interfaces with smtsolver backends upon which higher level modules such as thellvm ir executor are built.
klc3 is similarly built uponthe klee infrastructure with a few modifications but wereplaced the higher level modules with our own code includ ing an lc symbolic executor a bit addressable memorymodel code flow analyzers state searchers and generatorsfor test cases and human readable reports.
fig.
illustratesthe structure of klc3 our modified klee architecture.
a. lc assembly parser and symbolic executor rather than requiring instructors to learn the klee api we developed a set of annotations on lc assembly files through which instructors can specify symbolic variables as well asconstraints identify different types of memory regions read only uninitialized but accessible and so forth and selecttypes of output to be compared between student and goldcodes to generate behavioral issues.
users can also overridethe default behavior messages and hints provided by thedifferent types of issues tested by klc3 and can to a limitedextent define new issues.
the input files are parsed along withcommand line options to automatically generate the equivalentof the additional c code normally required for use with klee.
our symbolic executor enables klc3 to support direct symbolic execution of lc code even when that code isquestionable or obviously buggy.
for example a jump vio lating subroutine call return semantics can be executed ratherthan immediately terminating the state some students did sointentionally although such operations are not encouragedand klc3 does raise a warning by default.
with precisecontrol of each instruction klc3 is able to reproduce theexact behavior of the official lc simulator lc3sim whichis critical when students debug their code using the generatedtest cases in lc3sim.
detection of more subtle problems suchas using uninitialized registers can also be performed in amore controlled manner.
b. issue detection and equivalence checking klc3 executes an lc program and detects any improper operations by the code such as out of bound memory accesses.
when applied to a programming assignment andprovided with a correct version of the assignment solution a gold version klc3 not only detects the problems inthe test program itself which we call execution issues b u t also performs equivalence checking between the test programand the gold version thus identifying any behavioral issues between the two.
execution issues typically indicate undefined or irreproducible behavior or the possibility of a crash when theprogram executes.
for example klc3 can detect the use ofuninitialized registers.
when a program starts all registers areconsidered to be uninitialized.
if a test program state uses aregister without first writing a value into the register klc3raises an issue for that state.
most execution issues arise inthe executor but some rely on control flow analysis such asidentification of improper subroutine structure in which a stateexecutes a ret return instruction that does not return to the instruction after the most recent jsr jump to subroutine instruction.
the set of execution issues reported by klc3 was developed based on experience with student code.
initially wereported only a few common mistakes based on our ownexperience such as reading uninitialized memory or registers.
21fig.
.
equivalence checking between test program and gold program.
early versions of klc3 were then tested on student codes from a previous semester and later on students during fall2020 as they wrote their assignments which helped us toidentify additional issues through manual analysis such as us ing a symbolic value for the program counter pc overwritinginstructions and broken subroutine calls.
after testing severalhundred student codes we arrived at a stable set of issues as detailed in the klc3 manual included in the replicationpackage which we may extend in future semesters.
behavioral issues signify differences between the output produced by a student s code and that produced by the goldcode for example incorrect answers printed to the screen.these issues are identified by comparing symbolic equalityfor the display an i o device memory and registers aftera program terminates as shown in fig.
.
specifically whena state of the test program terminates normally instead ofencountering a terminating issue its final path constraints areused to launch a state of the gold program.
after the goldstate terminates the equivalence checker module symbolicallycompares displayed output memory registers and or the lastexecuted instruction of the two states.
if the gold state forksto multiple states all of them are compared with the teststate.
assignments typically specify comparison for a subsetof these possible outputs so only those outputs relevant to theassignment are compared as specified in the klc3 input files.divergence in the outputs raises behavioral issues.
c. generation of test cases scripts and reports just like klee klc3 generates concrete test cases that reproduce detected issues.
issues are frequently triggered many times due to forked states and repeated execution of instruc tions.
ideally each bug in a student s code should be reported exactly once.
however there is no easy way to localize bugsin the test code particularly behavioral issues.
issues triggeredon the same instruction may not necessarily result from thesame bug while a single bug may trigger a series of issues atdifferent instructions.
to avoid overwhelming students withfailed test cases we filter the set of issues produced bya student s code before reporting them to the student.
inparticular we report only one instance of any given executionissue at any location in a student s program.
in that way forexample if states access illegal addresses at a particularload instruction the student sees only one report and one testcase.
for behavioral issues such as incorrect output whichcan t be localized in the test code only one instance of eachtype is reported from a single run.
for each reported issue a description the instruction that triggers the issue for execution issues runtime information such as the address accessed for memory issues and theoutput for incorrect output issues and sometimes a hint aboutpossible fixes for the issue is provided to the student.
eachreported issue is associated with a subdirectory containing atest case one or more assembly files and an lc script.
thetest case contains concrete values derived from the symbolicsubspace of the state that triggered the issue.
the test casesare designed to be used with the lc simulator lc3sim so students need understand nothing about klc3 nor aboutsymbolic execution in general.
ideally a test case follows thesame control path in lc3sim as it does in klc3 and triggers thesame issues except for a small number of pitfalls as describedin the klc3 manual .
the lc script can be executed bylc3sim to help the student load the test case and reproduce thebug.
sample reports are available in the klc3 manual .
vi.
o ptimizations timeliness is critical for effective feedback.
our goal is to provide feedback within minutes after any submission.
staticanalysis in the vscode extension is real time while achievingsuch an aggressive goal in symbolic analysis requires tuningof both the execution engine and input spaces.
the raw speedof the execution engine dictates the number and length ofpaths that can be explored and improving that speed enablesexploration of larger input spaces.
tightly constrained inputspaces finish quickly but may not expose bugs while an overlygeneral input space may make klc3 run out of time exploringcorrect paths thus again failing to expose bugs.
most of our klc3 optimizations had not been developed in time for the fall deployment forcing us to use fairlysmall input spaces particularly for d fs and thus to miss some bugs in our analysis.
using the code samples that wecollected we have been able to significantly improve klc3 sperformance and are now able to fully explore much largerspaces while meeting our minute goal for most submissions.
in this section we describe two of the more interesting optimizations implementation of an additional cache withinone of the lower layers of klee and extension of the loopreduction algorithm to assembly language in order tosidestep path explosions within loops.
a. independentelementset cache the independentsolver module of klee removes irrelevant constraints from smt queries before passing them to the next level solver .
to identify the relevant constraints thesolver iterates through the query expression to construct anindependentelementset a set of symbolic variables that areinvolved in each constraint and the query expression.
we noticed that student code samples produced large numbers of independentelementsets for the d fssamples that 22table iii timeout rates for d fssamples with and without the independent element setcache timeout in minutes cache no cache .
.
.
.
assemble and require minutes or less to analyze the average number of independentelementsets constructed is .
.
constructing such a large number requires substantial time.we also noticed that student code samples led to significantoverlap in the constraints on queries issued by klc3.
forexample the constraints defining the input space are includedin every query issued to the independentsolver.
given the costof construction and the overlap in constraints we decidedto investigate adding a cache that maps symbolic constraintexpressions to independentelementsets.
an effective cache must have a reasonably high hit rate and speed when results are cached.
as klee infrastructureuses dynamic allocation for symbolic expression instances cache comparisons can be either pointer based or value based.pointer hashing and comparison are fast but fail to matchidentical expressions if they are constructed separately indifferent states for example .
value based hashing and com parison require walking through the nested expressions whichtakes more time.
we evaluated both approaches and also ahybrid and found that for the purpose of klc3 pointer basedcomparison achieves a high hit rate and provides a substantialperformance boost for most student codes.
for the d fssamples that assemble we measured the klc3 analysis time up to minutes with the cache enabled and up to minutes with the cache disabled to captureperformance information more accurately .
in light of our5 minute feedback goal we summarize the fraction of samplesthat require more than and minutes of analysis in tab.
iii.we then eliminated samples that timed out as well as those thatfinished within seconds to reduce measurement errors .
forthe remaining samples the fraction of baseline no cache analysis time required with the cache appears in fig.
.
thegeometric mean of the fraction is .
an average speedup of3.
.
the cache hit rate is over .
for more than .
of the d fssamples.
use of the cache for s chedule samples shows a similar result for samples that neithertime out nor finish within seconds the geometric mean ofthe analysis time ratio is .
a speedup of .
.
b. loop path reduction on lc programs loop reduction is effective in reducing klee execution time while maintaining high code coverage and bug detectionfor student c programs .
the key observation behind loopreduction is that even simple control flow within a loop bodycan produce an exponential number of paths over multipleloop iterations but rarely are most such paths relevant toidentifying bugs.
loop reduction identifies all paths througha loop body and prioritizes execution of states that coverpreviously unexplored paths through the loop body while at fig.
.
impact of the independentelementset cache distribution of analysis time reduction ratios for d fssamples.
the orange line shows the cumulative fraction of samples with reduction ratios below a given value.
the same time de prioritizing or even avoiding execution of states that follow paths through the loop body that have alreadybeen covered by other states.
the original loop reductionalgorithm assumed that every loop had only a single entrypoint which holds for any c program that doesn t use goto statements and is also true in most c programs that do makeuse of goto generally for exception handling .
in contrast the single entry point assumption for loops fails to hold for many programs written in assembly language.without c statements such as if for and while loops in assembly are constructed purely from branches and jumps generally resulting in more complicated control flow and lessclearly defined structure.
as a result we had to generalize theloop reduction algorithm to accommodate the more flexibleforms of control flow used by our students and in ourown solutions to the assignments .
we then implemented thegeneralized version of loop reduction and tested it on thesamples collected from our class.
loop structures in an lc program must be identified and extracted automatically based on control flow analysis.
thefirst step is to construct a control flow graph cfg in whichthe nodes are basic blocks sequences of instructions witha single entry point and no control flow except for the lastinstruction and arcs connect each node to any other node thatmay follow it in dynamic execution.
in this paper we consideronly the context of control flow within a single well definedsubroutine we do not apply the algorithm to codes in whichsubroutine structure is defined improperly whether we detectsuch behavior statically or dynamically .
starting with the cfg for a subroutine we identify all strongly connected components sccs .
each scc forms oneor more of the outermost loops within the subroutine.
foreach scc we then identify each possible entry point thecfg nodes at which arcs from outside the scc arrive.
foran scc s let s call one such entry point e. the node e forms one outermost loop l e s .
other entry points may form additional loops with the same code the scc s often these are used to implement similar but separate operations inthe assembly code.
a c compiler might produce such code ifit found common subexpressions or common code sequences 23within a single subroutine for example.
for each loop l e s we identify all paths through a single iteration of l. in one iteration loop lcan either terminate or continue to another iteration.
continuing to another iteration we interpret as returning to e and the head to head h2h paths are defined as all paths that form simple cycles within s starting and ending at e. similarly the head to exit h2e paths are defined as all simple paths that start at eand exit s without returning to e .
we can then define the exit nodes for loop l e s as the set of cfg nodes outside of sat which one or more of the h2e paths of loop lterminate.
the nested loops subloops of a loop l e s consist of all loops in s e .
in other words a subloop has at least one h2h path in its parent loop that doesn t pass throughthe entry point of the parent loop.
for each loop we identifynested loops by executing recursively on the cfg induced bythe nodes in s e noting that the h2e paths of a subloop may also exit any number of containing loops as well.
during static analysis we identify loop paths as follows.
we define an h2h h2e segment of a loop as an h2h h2e path of the loop but with each arc within any subloop replacedby a single virtual edge from the entry node to the exit node.in other words the subpath in the subloop is invisible to theparent loop except for the entry and the exit nodes.
the numberof h2h h2e segments in a parent loop can be less than thenumber of h2h h2e paths as multiple subpaths through asubloop are counted as one segment in the parent loop if thesubpaths share the same exit node.
as loop analysis is static dynamic jumps are not allowed.
subroutine calls are assumed to return and are summarized asa single edge from the call to the next instruction in memory at the return address .
beginning with the most nested loops loops and their segments are identified through depth first search dfs starting from each subroutine s entry point.
thealgorithm is shown in fig.
.
we implemented the sample coverage update algorithm from to track loop coverage in klc3.
the algorithmuses a stack to record the current loop nest in each stateand to update h2h and h2e coverage.
we also implementedthe statepruningsearcher from except that postponed states are selected randomly for reactivation without check ing constraint compatibility with the uncovered path.
unlikellvm ir lc uses only the sign of the last operation sresult to control conditional branches.
branch outcomes andconstraints thus depend on both the preceding instructions aswell as the control flow path into the branch which is hard todetermine without actually executing postponed states.
ratherthan making complicated speculations and incurring additionalsolver overhead we chose to select a state randomly.
among s chedule samples generalized loop reduction reduced analysis time for .
of them.excluding samples that reported second analysis theaverage speedup for the samples that benefit is .
faster than the original dfs search heuristic.
after acceleration theanalysis time of the samples ranges from to seconds with .
finishing within seconds and an aver function analyze loop dfs u g parent path gis the parent loop scc excluding its entry node l none ifuis the entry of a known loop l0then ifl0 gthen required for l0to be a subloop parent.subloops parent.subloops l0 l l0 else ifu sccsofgof size 1then found a new subloop l new loop with entry node uand scc s parent.subloops parent.subloops l analyze loop dfs u s u l empty path iflis not none then reached existing new subloop e l.h2eedg skip paths in the subloop else ifuis a subroutine call then e u u.next skip subroutine and assume it returns else e u.outedges for all u v edo ifv parent.entry then reach the the parent s entry parent.h2hseg parent.h 2hseg path u v else ifv gthen exit the parent loop parent.h2eseg parent.h2eseg path u v parent.h2eedg parent.h2eedg parent.entry v else still in the parent loop analyze loop dfs v g parent path u v fig.
.
analysis algorithm for generalized loop reduction.
age of .
seconds.
among d fssamples .
samples were accelerated.
again excluding samples whichreported second analysis the average speedup is .
the resulting analysis times range from to seconds andthe average time is .
seconds.
we did observe one d fssample for which loop reduction finished early but reported no issues whereas issues werefound without loop reduction.
considering how quickly theanalysis finishes for the samples that benefit from loop re duction we believe that we can simply execute the dfssearch heuristic if loop reduction terminates without findingany issues in a student s code.
the fraction of lc samples that benefit from loop reduction is lower than we had expected based on the c programsreported in .
while investigating this issue we found thatmany of our samples contain unrolled nested loops whichproduce large numbers of segments in the outer loops.
someof these segments may be difficult or impossible to cover witha limited input space.
in fact some samples contain provablyuncoverable loop paths sometimes due to poor style such asconsecutive branches based on the same condition.
while wehave found many such samples by hand however we have yetto identify fast and efficient ways to eliminate the impossiblesegments automatically as most of the issues are more subtlethan consecutive branches.
as another effect of samples with many paths loop analysis can sometimes add significant time on the order of tens ofseconds.
however since the programs that benefit from thetechnique are those for which the analysis finishes quickly wecan set a limit of a few seconds on analysis time and therebyavoid any practical impact on the klc3 response time.
24vii.
t esting and debugging environment programmers often rely on cyclic debugging in which a program is relaunched to reproduce a single bug.
however restarting a program doesn t necessarily produce thesame bug at the same place.
such difficulties are especiallyconfusing for novice programmers.
on the other hand evenwhen a bug can be reproduced identifying its source oftenrequires some kind of unexpected program behavior to benoticed whereas the reason for the bug occurs earlier inthe program s execution forcing the programmer to use acombination of re execution and reasoning to determine thecause.
enabling a debugger to support reversing executionback to the cause of the bug thus becomes attractive.
students debug lc programs by executing them under the control of the lc simulator lc3sim.
in order to makedebugging easier for our students we extended this simula tor to support reverse execution sometimes called back in time or omniscient debugging.
two main approaches havebeen developed to support reverse execution recording andreconstructing .
the recording method saves necessarytrace information for each step of execution and uses thisinformation to undo the effect of each step when executingin reverse.
this method usually results in a large log and oftenrequires hardware support for acceptable performance.
thereconstructing method instead saves checkpoints full stateinformation during forward execution.
to perform reverseexecution the method reloads the closest checkpoint before thedesired reverse execution stopping point then executes in theforward direction to reach that stopping point.
reconstructingrequires less log information and less hardware support butcheckpoint positions must be chosen carefully making theapproach less flexible than the recording method.
we chose to implement the recording method in the lc simulator.
lc is a bit isa with general purpose regis ters so the architectural state is small allowing state changesto be recorded in a compact log.
and as the lc simulatoruses software to simulate execution of lc instructions recording trace information at the isa level does not addsubstantial overhead to instruction execution.
we also felt thatstudents benefit from the speed of reverse execution based onthe recording approach in which single instructions can beexecuted at approximately the same speed in both directionsin time allowing students to go easily back and forth in theircode s execution trace.
the reverse execution functionality relies on two modules of the original lc simulator the first the user interfacemodule handles three kinds of commands information com mands management commands and execution commands.reverse execution is closely related to the execution com mands that instruct the execution of the lc instructions.by design these commands are similar to the step next and continue commands available in most debuggers.
thesecond module the execution module simulates the executionof lc instructions.
we upgraded both modules with reverse execution func tionality and documented the changes for students in a newlc tool manual provided as supplemental material .
for theexecution module we added recording of state changes causedby each instruction s execution.
an lc instruction causesat most four registers and one memory location to change.we record the original values and the address of the changedmemory location if any when executing an instruction.
eachof these sets of changes is small and suffices to revert the effectof the execution step.
the recording cache is implemented asa cyclic array with enough space for all reasonable studentcodes.
in the user interface module we added a new category of reverse execution commands.
for every forward executioncommand such as step and continue we implemented areverse version such as rstep reverse step and rcontinue reverse continue .
the semantics of each new command wereselected carefully to be symmetric with the forward executioncommands.
for example just as finish executes through theret instruction at the end of the current subroutine and returnsto the caller rfinish executes in reverse back to the callsite that entered the current subroutine.
the lc simulatoralso has a graphical interface version in which simulatorcommands appear as buttons.
we also upgraded this interfaceto include command buttons for reverse execution.
after finishing the implementation we were pleased to realize that our extension can also simplify grading procedures.
inparticular some information is lost when a program executesto completion in the simulator making it difficult to test thatinformation.
for example our s ubroutines assignment tests students understanding of caller and callee saved registers and register values are checked as part of grading.
soin certain cases requires asking students to add specific labelsto their code so that grading scripts can check register valuesafter setting a breakpoint at the labels.
if a student fails toinclude the label or puts the label in the wrong place staffmust fall back on time consuming manual grading with aminor penalty for the student .
using reverse execution wecan simply back out of the changes made when the studentprogram terminates revealing the final register values left inplace by the student s code.
the lc tools provided with the textbook assume the availability of a environments that novice programmers maynot yet have learned to use such as unix or cygwin.
to makethe tools more accessible to our students we explored theautomatic translation of these programs into javascript andwebassembly for use through a web browser.
we made useof emscripten to do so.
we started by translating the lc 3assembler and simulator into javascript modules enabling oursystem to manage their use and execution lifetime.
we thenreplaced the standard unix filesystem used in the tools withan in memory filesystem adding import and export commandsto the web interface so that instructors and eventually ourklc3 feedback system can populate the filesystem with apredefined set of files.
finally we implemented a modern webinterface to the tools to enable students to make use of themwithout the need to install a unix like platform and then to 25fig.
.
queueing delay for all fall code samples.
fig.
.
klc3 analysis time for the samples from fall that assemble.
we set a time limit of minutes seconds .
download and build the tools themselves.
supporting this interface from the original c code required a few modifications asthe textbook s gui tool is based on tcl tk and communicatesthrough pipes with the simulator.
viii.
f eedback timing our goal is to provide feedback on each student submission within minutes.
the time required from a student s point ofview includes not only analysis by klc3 but also queueingdelays in the job dispatcher and other system components.failures and downtime also contribute to perceived delay andwhile the prototype deployed in fall did suffer fromseveral outages most of the bugs have been tracked down andeliminated leaving the system reasonably stable.
we examined queueing time as recorded in our logs for all submissions in the fall semester to produce thehistogram in fig.
.
the vertical scale is logarithmic andthe distribution is dominated by delays of seconds or less.based on this data we believe that our virtual server withfour processors and gb of dram more than suffices fora class of students.
while we expected more significantdelays near deadlines in fact the value of the feedback seemsto have convinced students to work earlier thus spacing outtheir submissions in a way that enabled them to digest and acton klc3 feedback reports.looking forward in fig.
we show the distribution of klc3 analysis times using all klc3 optimizations currentlyimplemented for the full set of samples that assemble the remaining require a negligible amount of time todetermine that assembly fails .
the input spaces are defined tobe general enough to fully explore student code samples andare substantially larger than those used during the fall 2020semester.
for these data we set a time limit of minutes onklc3 leading to timeouts for .
samples.
for eachsample that timed out however klc3 reported issues.
ix.
d iscussion a. survey results as the assembly assignments occupy only about the first third of the semester ample time remained to survey studentsanonymously on their opinions about the tools.
roughly aquarter of the students answered the survey.
few analytic features of our vscode extension were ready in time for students and our distribution method was pri vate requiring manual updates.
nevertheless roughly half ofrespondents had used our vscode and our extension ratherthan other editors to write their programs and of thoseusers found the extension helpful.
as described earlier wehave since extended both the syntactic and static analysesand have added style specific features such as identificationof unrolled loops which we only realized were a major issueafter analyzing student codes more carefully.
survey respondents generally found klc3 feedback to be useful in identifying and understanding their bugs particularlywhen bugs were subtle.
one student mentioned for example that klc3 ...reminded me of an extreme case that i wouldotherwise neglect.
as many bugs occur for corner cases helping students to think more carefully about their programsis also a positive outcome.
we were also surprised by studentcomments on the flow charts visualizations of control flow produced automatically for their code by klc3.
these werecreating as a debugging aid for us to help us to understandstudent code but the students themselves also found themuseful in identifying differences between the intended andactual control flow.
we hadn t expected novice programmersto be able to make use of them but the class does define andencourage the use of flow charts in understanding programs and several respondents commented positively about theirinclusion in the klc3 reports.
two thirds of respondents made use of our new browserbased interface to the assembler and simulator.
however whenmaking use of the klc3 reports to debug their code studentspreferred to use the traditional simulation and execution tools perhaps because of the lack of scripting support in the browserinterface at the time.
we have rectified that lack and plan toenable klc3 reports to be pulled directly into the browseralong with the scripts needed to reproduce any specific failure.
although support for reverse debugging was available only in time for the third assignment d fs half of the students made use of it in completing that assignment.
we werepleasantly surprised by this number and expect more students 26and instructors to find the functionality useful.
although the idea has been around for decades and reverse debuggingis supported in open source debuggers such as gdb it isturned off by default for performance reasons.
the survey also produced a number of interesting comments.
first although we had already kept response timesfrom the server to minutes students still wanted faster results.some of this attitude may arise from instances in whichour prototype system was unavailable sometimes for severalhours.
however as illustrated in sec.
vi we have alsosignificantly improved the time required for analysis sincethe class deployment.
second although we implemented per student regression testing and rate limited new submissionsto deter students from making guesses about their programs students did seem to rely on klc3 for finding bugs ratherthan developing their own tests going so far as to expresssurprise when the tool with a limited input space missedbugs that showed up during grading.
about half of the respon dents admitted to relying completely on klc3 for identifyingbugs.
philosophically providing more definitive guidance inan introductory class may be acceptable.
alternatively byrestricting the input space used by klc3 one can leave certainaspects of testing to the students themselves.
either approach iseasy to define and to use based on the input scripting languagedeveloped for klc3.
b. comparison with samples from fall to understand the effect of our system on student s ability to produce correct code we compare code samples from with those produced by students in the fall offeringof the course before the development of our tools.
manyaspects of the two courses were the same the same instructorpresented the same material albeit in person in ratherthan over zoom as in and the assignments were nearlyidentical with slight modifications to the ordering of inputs the meanings of specific bits and the exact output formatrequired.
as noted in sec.
iii the differences in assignmentsmay introduce some difference in behavior as might thedifferences in the student populations and the tas.
for the fall samples we extracted the first and the last commits that assemble from each student s commit sequenceof s ubroutines and d fssamples then computed the fractions on which klc3 reports any memory related warnings such as accessing uninitialized memory or any error suchas incorrect output or timeout .
results are presented in fig.
9using blue triangles to indicate the percentage of students witheach type of issue.
generally student code improved from firstto last commit as expected.
in fall students submitted their code once after they had finished testing and debugging it.
for comparison weadjusted the symbolic input spaces to match the specificationchanges and executed klc3 on each of these submissions.the orange lines in fig.
show the percentage of studentcodes exhibiting each type of issue.
in the s ubroutines assignment student subroutines were required to preserve the values of most registers.
a code fig.
.
percentage of student code samples on which klc3 reports warnings or errors.
samples that fail to assemble are excluded.
fragment provided with the assignment in both semesters tested one register s value across a subroutine call to showstudents how such testing could be accomplished.
to test theircode students needed to adapt that code to the other registers.in fall this code fragment was the only method providedto help students test their programs yet .
of the studentsdid not make use of the test provided as shown in the top leftplot in fig.
.
in fall students also received feedbackabout incorrectly modified register values from klc3.
thefraction of the first commits that assemble from fall withincorrectly modified registers is .
higher than that offall while the fraction of the last commits that assembleis much lower only .
.
the higher initial rate of errors in may indicate that students preferred the feedback system over performingtheir own testing even in the early stages of development.alternatively since klc3 executed automatically wheneverstudents committed their code students may have simplywanted to preserve a copy of their work before beginning totest.
regardless the differences in the final submission showthat the targeted feedback and test cases were more effectivein identifying problems in their code as they made progresson testing and debugging.
a similar pattern is observed forthe other errors of s ubroutines and the errors of d fs.
memory warnings show somewhat different behavior.
for these the rates among students in the fall class for bothassignments were lower in their first commits that assemblethan in the final submissions again our only data point forthe students in .
we believe that this behavior resultsfrom changes in the assignment specifications while studentsare never encouraged to use memory outside of the specific re gions defined in the specifications the specifications didnot explicitly forbid such use whereas the specificationsdid.
this finding shows the potential for improving pedagogywith insights from students submissions.
although the fractions of erroneous submissions decrease the overall impact of automatic feedback on student learningremains an open area for further investigation.
ideally suchimpact should be evaluated through longitudinal assessment in which students who have learned with and without suchfeedback are compared in terms of their proficiency in later 27classes or even in their careers.
we plan to deploy the system again in near future to further investigate this topic.
c. comparison with web cat many universities now use web cat rather than simple execution of test vectors in programming classes.
the key idea behind web cat is to have students generate their own tests in a manner similar to test driven development.
like klc3 web cat relies on the availability of a gold version of anassignment a solution.
students are then evaluated based on a combination of the validity and correctness of their tests along with coverage ofthe gold version.
in particular validity evaluates the student provided tests against the gold version of the code whilecorrectness evaluates them against the student version of thecode.
coverage measures the degree to which a student s testsfully exercise the gold version and can in practice be basedon code coverage branch coverage or even on something likea full test set from symbolic execution.
web cat s focus on encouraging and rewarding test development by students is an interesting and valid goal butwe believe that some of the more subtle errors and variationsintroduced by novice programmers are likely to be missed bysuch a system.
for example we note that roughly a third ofstudents final submissions of d fsstill suffered from some type of memory error in fall see fig.
.
while sucherrors may effect output often they have no direct impacton program behavior.
some such errors are akin to out of bounds array accesses in languages like c which may or maynot cause a program to produce incorrect results.
often thebehavior ends up depending on the compiler operating system or even on the isa.
in the case of lc code for example thesimulator initializes most memory locations to so studentcode with erroneous behavior often works fine or works thefirst time but not the second time and so forth.
in our experience and also as reported in for c programs using gold code coverage as the basis for student codeevaluation is also limiting.
test generation using klc3 with asymbolic input space on the gold program typically generatesa superset of the tests required for code or branch coverage but even those tests do not uncover all bugs in student code even when combined with a similar set generated by klc3with the student code itself.
in particular while all possiblecode paths are covered by the tests generated by klc3 theactual tests consist of specific input vectors and the vectorsthat differentiate the student and gold versions may be missed.equivalence checking as described in this paper and by theearlier work on c specifically targets such vectors and is thusbetter able to identify subtle behavioral differences.
nevertheless we recognize that web cat may be better in avoiding the tendency of students to rely on the feedbacksystem for testing.
in the future it may be interesting tocombine the two approaches using something like web catto provide initial feedback but switching to klc3 afterstudents have surpassed some threshold with their own tests.d.
alternative designs early in our project we considered an alternative approach to handling lc programs with klee translating lc codeto c specifically to an lc virtual machine implementedin c then compiling to llvm ir and using klee.
aftersome initial research we decided on the more direct approachdescribed in this paper.
the lc isa differs from c in severalnoteworthy ways lc programs operate directly on registersand make explicit accesses to the bit addressable memory while registers and addresses are managed by compilers andhidden from c programmers.
also lc assembly can containdirect jumps to arbitrary memory locations using jmp or jsrr while c offers only the limited goto statement.
finally subroutines calls in c rely on the concept of stackframes which are not explicit in lc .
we feel that theadditional indirection implied by mapping lc code througha virtual machine and then through a c compiler to llvmwould add too much overhead to analyzing the relativelysimple programs produced by our students.
the complexity ofensuring consistent behavior as well as inverting the mappingto explain issues found in the final version clearly to studentsin terms of their original code is also somewhat daunting.
e. pushing optimizations into klee the authors of klee have also noted the possible need for an independentelementset cache as a comment in the source code.
to investigate the value for c programs wetranslated one author s d fssolution into c compiled it using clang o2 and executed it with klee on the same symbolicinput space.
in that form the code required construction ofonly .
6independentelementsets .
fewer than did the lc version.
the gap may be due to differencesbetween lc and the llvm ir lc lacks multiplicationinstructions comparison instructions use condition codesinstead and other features.
consequently more lc in structions are needed to implement the same functionality.compiler optimizations also reduce the number of instructions.the average number of lc instructions executed by klc3for d fssamples is .
while klee executed only .
106llvm ir instructions for the c version.
the impact of the cache is therefore less pronounced although webelieve that the cache may be useful in analyzing certain typesof c programs.
x. c onclusion considering both student feedback and our success in using the system to deliver feedback based on symbolic evaluation ofstudent submissions within our goal of minutes we plan tomake continued use of these tools in future classes and to makethem available to others using lc to teach programming.towards that end we provide a replication package withsource code and manuals for all components as well as theassignments and several sample solutions for each.
detailedimplementations and discussions of the tools can also be foundin the authors theses .
28references s. edwards using test driven development in the classroom providing students with automatic concrete feedback on performance in proc.
int l conf.
education and information systems technologies and applications eista aug. .
.
available c. cadar d. dunbar and d. engler klee unassisted and automatic generation of high coverage tests for complex systems programs inproceedings of the 8th usenix conference on operating systemsdesign and implementation ser.
osdi .
usa usenix association p. .
y .
patt and s. patel introduction to computing systems from bits and gates to c and beyond 2nd ed.
mcgraw hill higher education .
j. gao use of symbolic execution as automated grading tool for introductory programming courses ph.d. dissertation university of illinois at urbana champaign .
.
available a. luxton reilly simon i. albluwi b. a. becker m. giannakos a. n. kumar l. ott j. paterson m. j. scott j. sheard andc.
szabo introductory programming a systematic literature review inproceedings companion of the 23rd annual acm conference on innovation and technology in computer science education ser.
iticse companion.
new york ny usa associationfor computing machinery p. .
.
available j. gao and s. s. lumetta loop path reduction by state pruning inproceedings of the 33rd acm ieee international conference on automated software engineering ser.
ase .
new york ny usa association for computing machinery p. .
.
available a. zakai emscripten an llvm to javascript compiler visual studio code code editing.
redefined.
go git a highly extensible git implementation library written in pure go z. liu t. liu q. li w. luo and s. s. lumetta replication package of the lc automatic feedback system aug. .
.
available j. engblom a review of reverse debugging in proceedings of the system software soc and silicon debug conference pp.
.
z. liu using concolic execution to provide automatic feedback on lc programs .
.
available t. liu improved feedback and debugging support for student assembly programming .
.
available q. li vscode extension for lc programming .
.
available w. luo in browser lc toolchain and queue management for symbolic testing .
.
available