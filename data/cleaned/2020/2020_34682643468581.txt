detectingandlocalizingkeyboardaccessibilityfailuresinweb applications paul t.chiou universityof southerncalifornia usa paulchio usc .eduali s.alotaibi universityof southerncalifornia usa aalotaib usc .eduwilliamg.j.halfond universityof southerncalifornia usa halfond usc .edu abstract thekeyboardisthemostuniversallysupportedinputmethodoperable by people with disabilities.
yet many popular websites lack keyboard accessible mechanism which could cause failures that make the website unusable.
in this paper we present a novel approach for automatically detecting and localizing keyboard accessibility failures in web applications.
our extensive evaluation of our technique on real world web pages showed that our technique was able to detect keyboard failures in web applications with high precisionandrecallandwasabletoaccuratelyidentifytheunderlying elements inthe webpagesthat ledto the observedproblems.
ccs concepts software andits engineering keywords web accessibility wcag software testing keyboard navigation acmreference format paul t. chiou ali s. alotaibi and william g. j. halfond.
.
detecting and localizing keyboard accessibility failures in web applications.
in proceedingsofthe29thacmjointeuropeansoftwareengineeringconference andsymposiumonthefoundationsofsoftwareengineering esec fse august 23 28 athens greece.
acm new york ny usa 13pages.
.
introduction the web is fundamentally designed to work for all people yet oftheworld spopulationpossessessometypeofdisability thatcanhindertheirabilitytousetheweb.forthem access towebapplicationsisparticularlyimportantasthewebprovides connectionstoservicesandinformationthatmightotherwisebe unavailable .
despite legislation that mandates companies to provideequallyaccessiblewebsites webaccessibilityissuesare widespread.asof2019 ofinternetsitescontained accessibility blockers thatmadecriticalfunctionalityinaccessibletodisabled users resultinginconsiderabledisadvantagesforpeoplewith disabilities.
userswithdisabilitiesareoftenunabletouseatraditionalpointand clickortouch operateddeviceandmustuseothermechanisms permissionto make digitalor hard copies of part orall ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrightsforthird partycomponentsofthisworkmustbehonored.
forallotheruses contactthe owner author s .
esec fse august 23 28 athens greece copyright heldby the owner author s .
acm isbn .
.3468581to interact with web applications.
for example users with disabilitiesmayemployassistivetechnology at suchasscreenreaders speech basedcontrollers andswitchdevices.sincethekeyboard isthemostuniversallysupportedalternativeinputmethodoperable by people with disabilities mostatgenerate emulated keystrokes to navigatea web application s user interface ui .
unfortunately keyboard accessibility is one of the most common and prevalent accessibility issues .
studies show that as many as of popularwebsites lack keyboard accessible mechanisms and4 containaccessibilitybugsthatmakethekeyboard completely unusable .
we call the manifestation of these issues keyboardaccessibilityfailures kafs whichare broadly failures thatpreventtheuser from interactingwith the webapp s uifeatures using the keyboard.
testingfor kafsischallengingduetothehighlycomplexnature ofclient side uisinmodernwebapplications.these uisprovide responsive and dynamic interfaces that are highly mutable and containcontentthatcanbedynamicallycreatedandbindedwith javascript.
this poses several challenges first the static html source code may not resemble the document object model dom with which end users actually interact making traditional static analysisonhtmlsourcecodeinadequate.second thekeyboard interactiongovernedbytheevent drivenexecutionenvironment maybeconstantlychangingasthewebapplicationentersdifferent uistates.thismakesitnecessarytoidentifyawebapplication s possiblebehaviors beyondsimplyaone time snapshot.
finally thejavascriptcoderesponsibleforeventhandlersandtheirinteractions can be difficult to analyze using static analysis which makes itdifficult tostaticallymodelkeyboard handlingina ui.together these challenges can make it very difficult to adequately test for keyboardaccessibilityissues.
existingtechniquesforidentifyingkeyboardinaccessibilityissues have limitations in their usage and applicability.
for example fona statically analyzes a web page s domcontent to identifykafs.
however it only analyzes specific attributes of dom elements and does not completely capture all the different ways kafscanbeintroducedintoawebpage.otherapproaches suchas pyccuracy andaria check allowdeveloperstowriteoruse scenariobasedteststocheckkeyboardaccessibilityrequirements.
however these technique require developers to employ manually generatedtestcasesforeachoftheirpagesandanticipatetheproblems that may occur.
as a result keyboard accessibility testing largely remains a manual effort that requires visual inspections of a web page which makes it a timeconsuming costly anderror prone process.
inthispaperwepresentournovelapproachforautomatically detectingandlocalizing kafsinwebpages.toachievethis ourapproachcombinesbothstaticanddynamicanalysisbasedtechniques esec fse august 23 28 athens greece pault.
chiou alis.alotaibi andwilliamg.j.
halfond 89n n figure real world examples ofkafs alexa left california dmv right to both address the complications caused by complex modern web appuis and more completely identify behaviors that can cause kafs.
our approach defines a dynamic web crawling technique that systematically builds a model representing the possible keyboardbasednavigationthroughawebpage s uielements including thoseinducedbyjavascriptbasedbehaviors.thenourapproach analyzesthismodeltoidentifywhenthepresentormissingnavigationflowswillleadtoa kaf.ourevaluationofthetechnique showed that it is very accurate in terms of precision and recall in detecting kafs and identifying the html code responsible for the observedfailures.thekeycontributionsofthispaperare the firstdefinedkeyboard basednavigationalmodelforawebpage the first formalization of keyboard accessibility issues in terms of graph basedproperties afullyautomateddetectionandlocalization technique that outperforms state of the art and practice on real world web applications and a study on a set of real world webpagesthat showsthat our approach isaccurateandefficient.
background keyboard usage is one of the foundational requirements for web accessibility and it is reflected in guideline .
of the w3c web accessibilityinitiative wai swebcontentaccessibilityguideline wcag .
.
these guidelines require web uis to be usable by themany users that operatethecomputersolelywith akeyboardbased inputdevice.
keyboard based users utilizeasetof standard keyboard commands to navigate to different items of interest in webapplicationsandcarry outadesiredaction .
keyboard based users and point and click pnc based users interactwithawebpage suielementsinaverydifferentmanner.
inthepncmodality usersmoveacursorusing apointingdevice e.g.
mouse andpressbuttonstoactivatea uielementunderneath the cursor.
in the keyboard modality users must press keyboard buttons such as taband shift tab to move the browser s focus toauielementthattheuserwantstointeractwith.unlikethe pnc modality movingbetween uielementswithakeyboardhappens sequentially meaningthatifauseriscurrentlyonelement nand wantstointeractwithelement n i thentheusermustpressthe tabitimesuntilfocusisonthedesiredelement.theusermayalso press shift tabto move backwards through the elements.
the ordering of the elements is determined by the browser based on the structure of the dom but may be overridden by a developer using javascript or html attributes such as tabindex .
in this paper we call the ordering of the elements in this sequence the keyboardnavigationflow ofthewebpage s ui.onceanelementhas focus akeyboardusercancarryoutactionsonitbypressingother keyboard buttons.
for example when the focus is moved onto agroupofelements suchasmenulistsorradio buttons thearrow keys canbeusedtomovebetweentheelements of the group.
the spaceor enterkeys are used to manipulatethe element currently in focus and the esckey is typically used to exit a user prompt or dialog .
all web browsers are required by the w3c s user agent accessibility guidelines to support this standardsetofkeyboardstrokesthroughtheir keyboardapi.
althoughkeyboardaccessibilityfailures kafs canrefer toa widerangeofkeyboardrelatedaccessibilityissues inthispaper we usethetermtospecificallyrefertotwocommontypesof kafsthat impact the keyboard navigation flow of a web page s ui.
these are inaccessiblefunctionalities iafs and keyboard traps ktfs which are formally defined under wcagsuccess criteria sc sections .
.
and .
.
.
we explain these two types in detail below.
.
inaccessible functionalities sc2.
.
requires all functionality of a web page to be available via the keyboard interface.
the term inaccessible functionality iaf isusedtodescribefailuresofawebpage uitoconformwiththis guideline.
this type of kafoccurs when an interactive element is not included in the keyboard navigation flow of the uior an element in the navigation flow does not have a keyboard event handler.
this means that a keyboard based user is either unable to usethestandardkeyboardnavigationkeystoputfocusononeor moreelementsinthepage s uiorthattheelementisnotactionable and the user is unable to activate the uielement s functionality.
therearemanyrootcausesofthistypeoffailure whichwediscuss indepthinsection .
.
butmostrelatetocustomcontrolelements that do not have eventhandlers properly defined.
an example of inaccessible functionality occurs in the header navigationmenuofthe alexawebsite whichwefoundinourevaluationandisshowninfigure .inthissubjectthe solutions and tools menu items expand sub menu items when the mouse cursorishoveredoverthem.thesemenuitemsareimplemented with div elementsthathavethe hovercsspseudo class defined in the web page s static css declarations to make them interactable.sincetheexpansionofthesub menusareonlytriggered withmousehover thecontainedlinks to arenotaccessible to keyboard based users resulting in a situation where none of the sub menu items can be seen byakeyboard baseduser.
.
keyboard traps sc2.
.2requiresthatifkeyboardfocuscanbemovedtoa uielement ofthepageusingthekeyboardinterface thenfocusmustalsobe able to move away from that element using only the keyboard 856detectingandlocalizing keyboardaccessibility failuresin webapplications esec fse august 23 28 athens greece interface.theterm keyboardtrap ktf isusedtodescribefailures of a web page uito conform with this guideline.
this type of kaf occurswhenfocusbecomes stuck onasequenceofoneormore interactive elements and the user is unable to interact further with otherpartsofthewebpageviathekeyboard.aswiththefirsttype ofkaf therearemanypossiblerootcausesforthiskindof kaf whichwediscussindepthinsection .
.
butthemostcommon istheuseofthird partywidgetpluginsthatoncereceivingfocus preventedtheuserfromreturningtocontentoutsideoftheplug in viathe keyboard.
figure1showsanexampleofa ktfthatwefoundinoneofour evaluationsubjects the californiadmv sappointmentregistration page .thistrapwascausedbyjavascriptthatautoadvanced thekeyboardcursorwhentheusertypedpartofaphonenumber.
when three numbers were entered into the area code input field developer defined javascript code automatically advanced the cursor to put focus on the next input field .
consequently a keyboard user was not be able to make a correction to the area code by moving backwards since on each attempt to shift focus to the area code input box would cause the javascript to again advance focus to the next input field .
in fact any interactive elementprior tothetrap e.g.
to was nolongeraccessible to the keyboarduserafter enteringan area code.
webapplication modeling toperformthedetectionandlocalizationof kafs ourapproach firsttakesapageundertest put asinputandbuildsmodelsof the ways users can interact with it via both the keyboard and pnc.
this is shown in the left half of figure .
the keyboard navigation flow graph knfg models the different ways a keyboard user can interact with a put.
to the best of our knowledge we are thefirsttodefinesuchamodel.thepoint clicknavigationflow graph pcnfg represents the ways a pncuser can interact with awebpage s uiandis similarto existing representations such as the state flowgraph .
keyboard navigation flow graph point click navigation flow graphput xpath1 xpath2 report knfg pcnfg .
.
localization detection .
.
.
.
figure anoverview ofour approach .
modeling keyboardnavigationflow knfg formal definition.
to model keyboard navigation flow we define a new abstraction the keyboard navigation flow graph knfg .
aput s keyboard navigation flow is represented by a set ofknfgs.
eachknfgrepresents the ways a web page s ui can be navigated from the perspective of a keyboard user.
formally we represent a knfgas a tuple v vs v0 k e wherevis theset of all nodes in the graph and each v vcorresponds to a unique html element in the put vs vrepresents a state of theput which we define as the set of html elements that are visibleinthe put v0 vsistheentrynodeofthegraph i.e.
the first html element thatkeyboard basedusers can interact with when the putrenders in the browser kis the set of standard keyboard based actions that may cause a focus transition between nodesinthegraph and eisthesetofdirectededgesthatrepresent the transitionsthat can occur inthe put.
knfg nodes.
the node set of a knfg v contains a node for each html element in the put.
our approach identifies the nodesbyrenderingthe putinabrowserandthenanalyzingthe put sdomto identify each unique html element.
each node is uniquely identified by its xpath in the dom.
our approach groups syntactically linked nodes such as a label and its bounded form elementandelementswrappedwithinotherinlinecontrolelements sincethesenodesareintendedtorepresentasinglefunctionality.a nodev0 vrepresentstheentrynodeofthegraphandisthehtml elementinthepagethatisthestartingpointforkeyboard based navigationofthepage.a put sinitialv0nodecanbeidentifiedby determining the xpath of the element thatinitially has focus after the page rendersinthe browser.
the inclusion of state vs in theknfgenables our approach to modelmodern webapplications where new htmlelementsmay beenabledoraddedtoa put.wedefine vsasthesubsetofallnodes intheputthatarevisibleinthebrowser.althoughrelatedwork hasproposedmanydefinitionofstateforwebpages weusethis because it is well suited for our problem domain since only visible elementscanbeinteractedwithviathekeyboardandanychangein thesetofvisibleelementsmayintroduceanewnavigationflow.to illustrate considerfigure whichshowsahidden div componentthatisnotdisplayeduntiltheuseractivatesthe forgotname link itseventhandlingtriggersandexpandsthehidden div displayingtheencompassedthree phonelookup textfields.our approach would consider and 3to be distinct states since the additional displayed links will define a new navigation flow throughthe put.achallengeinidentifyingthehtmlelements thatcomprise vsisthatduetothecomplexinteractionsbetween html andcss attributes there is nocanonical way to determine if a given node is visible.
therefore we compiled a set of heuristics that our approach uses to determine if an element is visible.
theseare non disabledelementsthatdonotexhibitafinalcomputeddomlayout style of type hidden visibility hidden display none or inherit their ancestor s rendered hidden properties elements that are not rendered with a height or width of zero pixels or excluded from the put s visual flow e.g.
elements inside another tab menu or inside containers that are collapsed whose contents aren t shown .
all of these heuristics can be identified by analyzing the attributes of the elements in the domofthe put when ithas been renderedinthe browser.
knfgedges.
theedgeset eofaknfgrepresentsthekeyboard navigationflowpossibleasaresultofkeyboard basedactions.a keyboard user can manipulate a page s interactive elements using astandardsetofactions whichwerepresentwith k.this setof actions includes all standard keyboard commands used to navigate awebapplication suiasdefinedbyw3c andwebaccessibility testing communities .
s operations can be broken 857esec fse august 23 28 athens greece pault.
chiou alis.alotaibi andwilliamg.j.
halfond input divdiv win btn input divdiv win btn link link spaninput divdiv win btn link link span input input inputforgot name sign up searchnamedropdown 2dropdown tel tel tel 3forgot namesearchname dropdown sign up dropdown 1dropdown dropdown 2name searchtab shift tab tab shift tab enter space esc esc entertab shift tab tab shift tab tabshift tabtab shift tab tab shift tabtab shift tabshift tab tabtab shift tabtab shift tab mshift tabshift tab shift tab tab tabshift tab1 dropdown dropdown 2name searchinput divdiv user btn input divdiv user btn link link spaninput divdiv user btndiv div div input divdiv user btn link link span input input inputinput divdiv user btn div div hover in click clickclick clickmouseover defaultmouseover mouseover click clickdefault clickdefault click clickmouseover mouseoverdefault clickdefault default1 3dropdown dropdown 2dropdown dropdown 2dropdown dropdown menuitem menuitem menuitem 3menuitem menuitem 2name searchname searchname search dropdown dropdown 2name searchforgot name sign up forgot name sign up tel tel tel 3hover out enter esc enter esc mshift tabenter false v0 v0 v0 figure a simplified version of the knfg left and pcnfg right with their corresponding ui states omitted some noninteractive nodes andself loopedges incurred by enter space or esc intofourcategories navigation tab shift tab selection actuation enter space anddismissal esc .our approach does not model keyboard shortcuts or scrolling keys suchas pgup pgdn home and endsincetheyonlychangehow contents are displayed or move the keyboard cursor within a text input basedcontrol andservenointeractive purposes.totrigger navigationbehaviorsthatrequiretextinput wealsoincludetwo actionsthatrepresentstheentryoftext.thefirstis andrepresents the entry of a random length string of alphanumeric characters.
thesecondis mandrepresentstheentryofamaximumlength string into the text input where maximum length is determined bythemaxlength attributeofthetextinput ifdefined.bothtext entry actions are followed by the tab shift tab or no action.
this simulates the common user behavior of entering input or interactingwithacontrol andthenmovingtoeitherthenextor priorelementinapage.inthetext wewilldenotethesesequences by showing both relevant symbols as the action even though they can be represented as a single compound action e.g.
entering max length text and then pressing tab would be represented as m tab knfg construction.
at a high level the edges in the knfg areidentifiedbyiterativelyexploringthepageusingonlykeyboardbasedactions i.e.
k untilnonewnavigationinformationisfound i.e.
the graph has reached a fixed point .
the first iteration of this process begins by interacting with each node v vs. for a given v our approach first sets the browser s focus on vand then executes everyactionin konv.
aftereach action our approach analyzes thepagetodeterminethefocustransitionthatoccurred.ifanaction causes a new state to be created then the new state is added to a worklist of states that will be explored in subsequent iterations of the edge building process.
if the action causes the page to attempt tonavigatetoadifferentpage ourapproachinterceptsthisevent andpreventsitfromhappening.ourapproachalsoincludestwo edgesthatlinkthelastelementinapage stabordertothefirst i.e.
vn v0andvn v0 .
this is done in order to exclude browser controls which are accessible via tab from the knfg.
an edge can be either an intra or inter state edge.
we describe the details of handling eachkindofedge below.
intra stateedgesdescribethenavigationflowinapageasaresult of an action on a node when there is no new page state created.
aftertriggeringanaction konanode vi ourapproachdetectsthefocuschangefrom vitovi 1andcreatesanedgeinthegraph vi vi vs indicatingthatthebrowserfocuscouldshiftfrom a source node vito a target node vi 1by pressing keystroke whileviis in focus.
our approach detects a change in focus by queryingthebrowsertoidentifytheelementcurrentlyreceiving focus in the put.
if an action does not trigger a focus shift e.g.
executing spacetotickacheckbox aselfedgeiscreated.ouredge creationmechanismcancaptureashift ornoshift infocusthatis caused by javascript event handlers since it simply observes the response of the page to the keyboard action which would include any javascript actions.
lastly if causes any sort of change in the dom sattributes values then the flagissetto true otherwise itissetto false.usingourrunningexample anintra stateedge exists between the name input field to the search button since focuscantransitionbetweenthetwoelementsbypressingthe tab and no new visible html elements appear i.e.
there is no new statecreated .thisedgeandotherintra stateedgesforourexample are showninredinfigure .
inter state edges describe the navigation flow in a page when anactiononanodeleadstothecreationofanewuistate.when our approach detects a new state it creates an edge in the same waythatanintra stateedgewouldbecreatedwiththeexception of the target node.
in this scenario the target node is in the new state v s andisthenode v0 v stowhichfocusistransferredto bythebrowser.anexampleofaninter stateedgecanbeseenin ourrunningexamplewherepressing esconthe forgotname and sign up links in state when the div component containing these links is active will dismiss the div component and return the navigation to state .
this edge and other inter state edges are representedas green edges infigure .
theknfgconstruction is sound under the assumption that the keyboard navigation is deterministic i.e.
executing on every node would always transition the focus to the same node and a node has exactly one predecessor successor through an intra state edge .inthecaseswherenon determinismdidoccur anelement could transition to different elements we observed such cases were always accompanied by some kind of visual state change which would be captured in the knfgbuilding process.
the edge construction is complete with respect to the w3c default set of standardizedkeyboardnavigationkeys.ifawebpageweretouse 858detectingandlocalizing keyboardaccessibility failuresin webapplications esec fse august 23 28 athens greece non standard keys for interaction our approach would not explore these actions.
however it is important to note that these cases are not common in practice and our kcould be easily redefined to handle other key sets.
the node identification is complete since all nodes in a page can be identified by examining the domof the page at runtime.
the only exception to this is for web sites that embed objects such as legacy flash silverlight java applets or third party plugins neither of which are modeled in the knfg.
however notethatsupportfortheseframeworksiscurrentlybeing phasedoutbymajorbrowsers .
.
modeling point andclick navigation thenavigationandinteractionsavailabletoa pncuserina put are represented by a set of point click navigation flow graphs pcnfgs .eachpcnfgrepresentsthewaysawebpage suicanbe interacted with from the perspective of a pncuser for a particular stateofthe put sui.formally werepresenta pcnfgasatuple v vs vuser m e wherevis the set of all nodes in the graph vs vrepresents the state which is defined by the set of nodes that are visible in the put vuser vis the initial node mis the setofmouseeventtypes and eisthesetofedgesthatrepresent the mouse navigation controlflow.
information about the nodes in the pcnfgis defined similar to that of the knfg.
specifically the node set v and state vs ofthe pcnfg are definedand identifiedinthe same wayas those for theknfg.
the one exception to this is the definition of the entrynode vuserofthegraph.unlikethecaseofkeyboard based navigation there is not a single node in the putthat represents the starting point for pncbased navigation.therefore we define aspecialnode vuserthatconceptuallyrepresentstheentrytothe putand connects to all of the nodes that a pncuser can interact withinthe put.
apncbased user can manipulate a page s interactive elements usingasetofactions whichwerepresentwith m.thissetincludes all mouse event types that implement the mouseevent interface suchas mousedown mouseup click mouseover mouseenter mouseleave ormouseout .
the edges in the pcnfgare defined usingastandarditerativecrawlingexploration.forexample similar totheconstructionofthestateflowgraphoriginallyproposedby crawljax .in ourapproach thetargetelementsthat willhave events triggered on them are represented by vsand the events to be triggered on them are represented by m. we omit further detailsofthisexplorationduetospaceconstraintsandsinceitis notacontributionofourapproach.anexample uiandpcnfgare showninfigure .
detectionand localization ofkafs asshowninfigure onceourapproachhasgeneratedthe knfgs andpcnfgsfortheput itdetectsandlocalizes kafsbyanalyzing andcomparing the twographs.
.
detectionofinaccessible functionalities aniafoccurs when functionality available to a point and click pnc user is not available to a keyboard user.
at a high level our approach identifies all of the interactive html elements available to apncuser by analyzing the pcnfgand then by analyzingtheknfg checksthat the same elements can be navigated to and activatedbyakeyboarduser.
ourapproachtodetectiafsisshowninalgorithm .theinputs tothis algorithmare the set of pcnfgsandknfgs thatwere previouslyconstructed.wedenotethesesetsas pcnfg andknfg respectively.
first the algorithm identifies the functionality i.e.
interactive elements available to a pncbased user line .
this is done by calculating vpcthe set of nodes in the pcnfg that are reachable from vuser i.e.
the entry node of the initial state of the pcnfg .
next the approach iterates over each node vpc vpcand checksifitisalsoaccessibletoakeyboarduser lines3 8 .foreach vpc the approach finds the corresponding node vkin theknfg line4 .notethatforagivenstate boththe pcnfgandknfghave the same vset and therefore there will always be a corresponding node if the corresponding knfgstate exists.
non reachableiafs.
thefirstaccessibilitycheck line5 determinesif vkisreachablefrom v0oftheknfg .ifitisnot then thisimpliesakeyboardusercannotnavigateto vk i.e.
vkcannot receivekeyboardfocus usingthekeyboardnavigationflowdefined by theputandvkis considered to be inaccessible and added to vif the setofelements inaccessibledueto flowproblems line6 .
non actionableiafs.
thesecondaccessibilitycheck line7 determines if vkis actionable.
a naive way to detect this would betosimplyexaminethe domanddetermineif vkhaseitheran explicitorimplicitkeyboardeventhandlerassociatedwithit.however akeyboardeventhandlermaybeassignedthroughcomplex event delegation which may not be visible via dominspection orvkmay handle some key presses e.g.
tabandshift tab that simply change the browser focus without actually activating the element.therefore todetermineif vkisactionableitisnecessaryto check in the knfgwhether it has any outgoing edges that modify thedomstate i.e.
is set totrue .
the presence of such an edge indicates that there exists some keyboard action on the element thatcanbetriggeredanddosomethingotherthantransferfocus toanotherelement.notethat wcagonlyrequiresactionableas anaccessibilitycriteriawhentheelementcanbetriggeredbythe mouse.
this is accounted for in our approach since vkis the corresponding node of a node already in the pcnfg and by definition a node is only in the pcnfgif it has an associated mouse event handler.
onceallnodesin vpchavebeenanalyzed thedetectionreturns true falsebased on whether any nodes have been identified as inaccessible line9 .thisalgorithmcanbeoptimizedforpage level detection by returning truethe first time any inaccessible element isidentified i.e.
at lines6and8 .
algorithm1 inaccessiblefunctionalitydetection input pcnfg mousenavigationmodel input knfg keyboard navigationmodel output trueorfalse vif vna vpc getreachablenodes vuser pcnfg forvpc vpcdo vk correspondingnodeinknfg vpc knfg if isreachable v0 vk knfg then vif vif vk if e outedges vk e. truethen vna vna vk return vif vna 859esec fse august 23 28 athens greece pault.
chiou alis.alotaibi andwilliamg.j.
halfond in theknfg from our running example figure the algorithm identifies that in state vdropdown2must be accessible via the keyboard because it is reachable in the pcnfg.
however in theknfg it is unreachable from v0via flow edges red edges thus putting this node in vif.
similarly for vdropdown1 the detection finds it is reachable from v0but finds there is no outgoing edge with true suchanedgewouldexistifits enteredgecouldhave exploredstate .
therefore this node isput into vna.
.
localization ofinaccessible functionalities when inaccessible functionalities occur it implies that there is either a anedge missingfrom the knfgthatwouldconnectthe accessible components to the inaccessible components i.e.
not reachable or b anelementismissingarequiredkeyboardhandler i.e.
not actionable .
non reachableiafs.
to localize the missing edges that cause elementstobecomeunreachable ourapproachanalyzesthe pcnfg andknfg andassignsasuspiciousnessscoretovariousedgesthat couldrepresentthemostlikelyconnectionpoint.atahigh level the intuition of our approach is to split the localization into two parts.
the first part tries to identify the most likely source node ofthemissingedgeandthesecondparttriestoidentifythemost likelytargetnodeofthemissingedge.ourapproachcomputessuspiciousnessscoresforeachofthesetwonodesetsandthenpresents arankingoftheedgesbasedonthecombinedsuspiciousnessofthe source and target nodes of the edge.
the algorithm for computing suspiciousnessofeachedgeisshowninalgorithm .theinputs to this algorithm are pcnfg andknfg as defined above.
the algorithmiteratesovereachstate s pcnfgandcheckstoseeifthe stateofthe pcnfgexistsinthe knfg .sincebothtypesofgraphs have the same vset and define their states in the same manner thischeckonlyneedstodetermineifthe vsforthepcnfgexists inthe knfg .
ifthestate ispresentinthe knfg the approachexaminesthe state to determine if it contains nodes that are inaccessible i.e.
unreachable .
lines5 8 compute the set of nodes that are inaccessibleforthekeyboarduser vkaf usingaprocesssimilartothat defined in algorithm .
the approach then iterates over each node vkaf vkafinordertodeterminethemostlikelysourceandtarget nodesforthemissingedgethatcaused vkaf.thepossiblesource nodesarerepresentedas vs whichwasalreadycomputedastheset ofnodesreachableinthe knfgfromv0atline7.sincethesenodes are reachable from the entry point one of them will be the node that represents the source node of the missing edge.
conversely vtrepresents the set of possible missing edge target nodes.
the approachcomputes vtbyfindingallof thenodesthat canreachto vkaf.onemightassumethatthemissingedgetargetnodewould always be vkaf however it is possible that vkafmay be part of a largercomponent whichisalsoinaccessible.inthisscenario these othernodesshouldalsobeconsideredaspossibletargets.fornodes invt line computes their suspiciousness score.
the intuition of thisscoreisthatnodesin vtrepresentasubgraphofthe knfgand nodes higher in the topological ordering of this subgraph are most likelythecorrecttargetnode sincetheycanthemselvesconnect tothemostnodesinthesubgraph.therefore rankassignsthese nodes a higher suspiciousness.
specifically the dombased rankofeachofthenodesin vtisusedtoassignsuspiciousness.asuspiciousness score is alsocomputed for nodes in vs. in lines 13 14 our approach iterates over each of the nodes in vsand assigns a suspicousness score to each.
the basic ideaisthatnodes in vsare consideredmorelikelytobethesourcenodeiftheyarespatially close to nodes in vt. we define close as the domtree based distancebetweenthetwonodes whichiscalculatedbythenumber of edges that must be traversed in the domtree for one node to reach another.
this definition of closeness represents the design practice that keyboard navigation generally transitions between nodes that have some kind of locality.
the approach then takes the cartesian product of vsandvtand assigns the suspiciousness score of the edge vs vt based on the sum of the suspiciousness scores ofvsandvt.
the approach resets the node scores for vsand vtevery time it processes a vkafso the scores always reflect the suspiciousnesswith respectto theinaccessiblecomponents.
note thatthefinalscoresoftheedgesin earecumulativeacrossallstates lines18 19 .
in our running example figure the localization algorithm identifiesthatinstate oftheknfg vdropdown2andv mustbe accessibleviathekeyboard butsinceneithernodesarereachable fromv0in that state both are in the set vkaf.
when identifying the edges responsible to connect these nodes the algorithm first identifies vsas the blue cluster reachable from v0andvtas the orangeclusterwhere vdropdown2resides.thealgorithmthen identifies the purple dotted edge as the candidate faulty edge with the highest suspiciousness score due to their proximity in the dom.
this concept alsoapplies to v inits redcluster.
algorithm2 inaccessiblefunctionalitylocalization input pcnfg mousenavigationmodel input knfg keyboard navigationmodel output ranked listofsuspiciousedges e foreachpcnfg pcnfg do knfgstate correspondingstate pcnfg ifknfgstate knfg then intra state vpc getreachablenodes vuser pcnfg vk correspondingnodesinknfg vpc vs getreachablenodes v0 knfg vkaf vk vs foreachvkaf vkafdo vt backwardreachability vkaf assignsuspiciousness scoresfor nodesin vs forallvs vsdoresetscore vs forallvt vtdo forallvs vsdoscore vs distance vt vs assignsuspiciousness scoresfor nodesin vt forallvt vtdoscore vt rank vt vt foreach vs vt vs vtdo score vs vt score e. vs vt score vs score vt e e addedge vs vt else inter state e getstatetransitionedge pcnfg e e addedge e returnedgesinesorted by score ofeach edge if the current pcnfgstate does not match a state in the knfg then the identification of the missing edge is simplified line and 21 22 .
becauseoftheway our approach constructs the knfg a newstateinthe knfg isonlydefinedifthereexistssomeaction an edge thatduringthecrawlingofthecurrent knfgstatetransitions the state s vstov s. thus if a state exists in the pcnfg and not intheknfg itindicates thereexistssomemissingkeyboard 860detectingandlocalizing keyboardaccessibility failuresin webapplications esec fse august 23 28 athens greece navigational transition leading to the v state and the state transitionedgeto v stateinthe pcnfg istheedgemostlikely tobefaulty.line22classifiesthemissingstatetransitionedgewith thehighestpossiblesuspiciousnessscoreof0.forexample inthe pcnfg of our running example state and state are explored via mouse hovering dropdown1 anddropdown2 .
the algorithm identifies the inter state edge highlighted in green that transition from these nodes to and 5as suspicious edges because these states are not inthe knfg .
non actionable iafs.
the localization of elements that are notactionableisexactlythesetofelementsidentifiedas vnainalgorithm1and no further localization is needed for those elements.
.
detectionofkeyboardtraps tounderstandtheintuitionofourdetectionapproachforkeyboard traps first recall that keyboard traps cause keyboard based users to become stuck in a sequence of one or more nodes.
the navigation flows that would cause this to occur will be identifiable as cycles in the knfg.
this represents a situation where once a keyboarduser hasentered the cyclewitheither tabor shift tab theywillbeunabletonavigateawayfromtheelementsinthecycle using the keyboard.
theapproachtodetectkeyboardtrapsisshowninalgorithm .
the algorithm begins by iterating over each knfgin theknfg line1 .foreach knfg theapproachextractstwoedge induced subgraphs one based on edges labeled with the tabaction and the other one based on edges labeled with the shift tab.
the two subgraphs are computed by iterating through the edge set eof theknfgand retaining the subset of edges where shift tab or tab.
these two subgraphs represent the two ways keyboardbasedusersareabletonavigateamongelementsandthatwouldbe affected bya cycle.
using the edge induced subgraphs enables the approach to avoid false positives that would be caused by cycles defined by the forward backward edges created for each node due to the taband shift tabnavigation and by edges whose actions maynotcauseafocusshift suchas enter or space.
the approach then iterates over the two subgraphs line .
the approach first removes the specially created edges that link the last element in a page s tab order and the first element i.e.
vn v0 line .
the reason for this removal is that this specially added edge creates a cycle in the knfgto enable users to cycle fromthelastnodeinthetabordertothefirst butdoesnotrepresent akeyboardtrap.aftertheedgeremoval ourapproachanalyzes thesubgraph todetermineifit containsacycle inwhichcasethe approach has identifiedthat aktfexistsinthe knfg line .
algorithm3 keyboardtrapdetection input knfg keyboard navigationmodel output trueorfalse foreachknfg knfg do knfgtab getedgeinducedsubgraph knfg knfgshifttab getedgeinducedsubgraph knfg foreachknfgtabandknfgshifttab asgdo g.removeedges vn v0 ifgcontains a cycle then return true returnfalse in state of theknfg from our running example the four cycles highlighted in yellow would be detected.
of which the twocycles of size formed by edge vtel2 vtel2 m shift tab vs and vtel3 vtel3 m shift tab vs areresultsoftheauto tabbingmechanism.
the larger two cycles of size formed by edges vtel1 vtel2 tab vs vtel2 vtel3 tab vs vtel3 vtel1 tab vs and vtel1 vtel3 shift tab vs vtel3 vtel2 shift tab vs vtel2 vtel1 shift tab vs are the result of the mechanism that prevents the user from leaving the three telephoneboxesunless entrieshave been filled.
.
localization ofkeyboardtraps when aktfoccurs it indicates that an edge has been created that shouldnotbepresentinthenavigation.thekeyinsightisthata ktfiscausedbyanedgethatalreadyexistsbutwhosetransition to the next node in the navigation flow is incorrect.
therefore our analysistriestoidentifywhichedgeinthe knfgismostlylikely to be incorrect.
since there is not a definitive way of identifying thisedge weemployasuspiciousnessscorebasedapproachthat encodes heuristics that we found useful in identifying the likely faultyedge.
the approach for computing suspiciousness of the edges is shown in algorithm .
lines 2 6 employ the same preparatory steps used in the detection algorithm algorithm .
namely the approach iterates over each knfgof theput identifies the two edge induced subgraphs in the knfg and then removes the edges betweenvnandv0of each subgraph.both heuristics employed by our approach focus on the nodes and edges that are part of a cycle i.e.
thedetected ktf .therefore thenextstepsofthealgorithm lines7 9 identifyandextracttheconnectedcomponentsinthe graph.
our approach does this by using tarjan s bridge finding algorithm to find and remove all bridges i.e.
edges that disconnect a component when removed in g lines 7 8 .
this leaves onlyconnectedcomponentsin g.sincethissetofcomponentsmay include components of size one with no self loops the approach removesthesenodes line9.
thesenodescanbesafelyremoved from consideration since by definition they cannot be part of a trap i.e.
theydonotcontainaselfloopandarenotpartofalarger cycle.
the next part of the algorithm lines 10 19 applies our approach s localization heuristics.
our approach employs two heuristics for localization.
the first heuristic is that edges in a connected componentaremorelikelytobeafaultyedgethanthosenotinthe component.thisheuristic is reasonable sincetypically one ofthe edgesinthecomponent scycleshouldactuallybedirectedtoanode not in the cycle i.e.
breaking the cycle and the failure to do so is the cause of the ktf.
this heuristic is implemented in lines 11 13 which iterate over the edges in the component and increase the suspiciousness score of each of them.
the second heuristic focuses on identifying the edge in the cycle that is most likely to represent the back edge with respect to the page s navigation flow.
the key insight to this is that the default tab navigation rendered bythebrowserisdeterminedbyadepthfirst pre ordertraversal ofthedomtree .inmostcases unlessscriptingwasusedto alterthedefaulttabsequence the domrankdeterminesthekeyboardnavigationflow.inlines14 17 ourapproachleveragesthis informationtoidentifythemostsuspiciousedgewithinthecycle.
specifically forthe tabinducedsubgraph thisedgeistheonethat flows from the lowest min domranked element to the highest 861esec fse august 23 28 athens greece pault.
chiou alis.alotaibi andwilliamg.j.
halfond max domrankedelement line15 .forthe shift tabinduced subgraph since this goes in the reverse direction it is the edge that flows from the highest max domranked node to the lowest min domrankednode line17 .notethatsuchback edgemay not exist if the default sequence of tab navigation is violated.
in suchextremelyuncommoncases theheuristicwouldstillwork but not aswell i.e.
itwouldlowerthefaultyelement s ranking .the back edgeidentifiedbythisheuristichasitssuspiciousnessscore increased line19 .theseheuristicsareappliedforeach knfgand once all of them have been analyzed the approach returns a list of all edges ranked inorder oftheirscore highestto lowest line .
algorithm4 keyboardtraplocalization input knfg keyboard navigationmodel output ranked listofsuspiciousedges e foreachknfg knfg do knfgtab getedgeinducedsubgraph knfg knfgshifttab getedgeinducedsubgraph knfg foreachknfgtabandknfgshifttab asgdo g.removeedges vn v0 ebridge tarjan g g.removeedges ebridge forallv gwheredegree v 0dog.removenode v foreachvcomp gdo foredge vcompdo e e edge score edge ifg.instanceof knfgtab then eback getedge min rank vcomp max rank vcomp elseifg.instanceof knfgshifttab then eback getedge max rank vcomp min rank vcomp e e eback19 score eback returnedgesinesorted by score ofeach edge in state of theknfg from our running example the cycle formed across vtel1 vtel2 andvtel3that prevents the user from leaving the three telephone boxes consists of three edges in either the taband shift tabdirection.
the order of appearance of thesethree text fields inthe domsequence wouldmake the edge vtel3 vtel1 tab vs and vtel1 vtel3 shift tab vs astherespective back edge that ismore suspicious.
evaluation toassesstheeffectivenessofourapproach weconductedanempirical evaluation that focusedonthree researchquestions rq1 whatistheaccuracyofourtechniqueindetecting kafsin webapplications?
rq2 if akafis detected what is the quality of the localization results providedbyour technique?
rq3 howmuchtimedoesourtechniqueneedtodetectandlocalize kafs?
.
implementation we implemented our approach as a java based prototype tool keyboardaccessibility failure detector kafe .
the implementationemploysacrawlerforeachsubjectpage sexplorationand is fully automated requiring no manual effort by users.
it uses selenium webdriver to load render and interact with the subject web pages to build the knfgandpcnfg.
all web pages wererendered with a fixed screen resolution of pixels on firefoxversion .
controlledby selenium version .
.
.
during interactionwithasubjectwebpage weusedthewebdriverapi tosendkeypressestothepageandmonitortheswitchinfocus.
we wrote and executed javascript based code to detect changes to the subjectpage andcapturethepage s domfor furtheranalysis.
we rankafeand all experiments on a single amd ryzen threadripper 2990wx bit machine with 64gb memory and ubuntu linux18.
.4lts.theimplementationof kafeandsubjectswill be madeavailable to the community viathe projectwebsite .
.
subject web pages accessibility tools we conducted our evaluation on a set of real world subject web pagesgatheredfrom governmentandhighereducationwebsites that are required bylaw to complywith wcag frequently visitede commercewebsites and sitesfromthemoztop500 mostvisitedwebsiteslist .wechosesubjectsfromthesesources duetotheirobligationforaccessibilitybytheada andtheir popularity.
the authors manually interacted with each web page s uiand the underlyingfunctional components perkeyboardaccessibility testing techniques and used of those that contained atleastone kaf.overall oursubjectscontained168iafsand28 ktfs.
for each kaf we identified the edge s that would either enable access to iafs orremove cycles causing ktfs while at the sametimeremainingconsistentwiththepage spre existingnavigation flow.
to help measure the false positive detection rate in rq1 we also included subjects that did not contain any kafs.
the dynamic ui contents in the subjects comprised of modern html5 andcustomjavascriptwidgets suchassliders dropdownmenus calendars andtooltipscomponents.duetospaceconstraints wedo notlisteachofthesubjectsinthepaper butincludethemassupplementarymaterialintheappendix.wecapturedacompleteversion ofeachsubjectwebpage using an interactive httpproxy .
forthepurposeofevaluatingourapproach sperformance we comparedagainstasetofstate of the arttoolsfromtwosources existing web accessibility testing tools described in research literature and the webaccessibilityevaluationtoolslist provided bythew3c.from weselected aria check tabindex counter the implementation of the fona approach andqualweb becausetheydetectedfailuresthatatleastpartiallyoverlappedwith kafs.
the other tools we found achecker evalaccess hera ffx mauve pyccuracy did not target and were not capable of detecting issues related to keyboard accessibility.from weselectedthepopular wave toolbecauseithad the most completehandling of keyboard accessibilityissues of the listedtools.othertools onthelistignoredtheimpactof scripting andstylingthatareresponsibleformostaccessibilityissues which meant they could not outperform wave.
for all of these tools weusedthepubliclyavailableofficialimplementationsvia theirwebsites.
.
proceduresandpresentation ofresults to answerrq1 we rankafeagainst the subject web pages and measured how accurately it could detect both types of kafs.
in thisexperiment wemeasuredtheprecisionandrecallof kafe s detectionresultsandcomparedthisagainsttheaccuracyofexisting 862detectingandlocalizing keyboardaccessibility failuresin webapplications esec fse august 23 28 athens greece table detection localization andtimingresults foreachevaluated approach.
inaccessiblefunctionality failure keyboard trapfailure run time minutes tool dep der lor mef aef dep der lor mef aef average kafe .
.
aria check n a n a n a n a n a n a .
tabindex counter n a n a n a n a n a n a .
qualweb .
.
n a n a wave .
.
n a n a .
state of the art approaches.
for each subject web page we consideredadetectiontobecorrect i.e.
atrue positive if kafeindicated thepagecontaineda kafofatypeandwehadpreviouslydeterminedthatthepagecontaineda kafofthattype.wecalculated false positives true negatives and false negatives in an analogous way.
the four state of the art tools we compared against each had their own way of reporting detections so we normalized their results so they could be compared against kafe.qualweb and wavetarget several different types of accessibility related failures such as low color contrast and missing alternative texts therefore they generate many issue reports unrelated to kafs.
for these two tools we considered reports with any mention of keyboard accessibilityissuesasa kafdetectionforthecorrespondingweb page.tabindex counter scansandreportsaratio 0to1 for a web page based on the number of interactive elements that have validtabindex andaria roleattributes .weconsidered anyratiolessthan100 tobeadetectionforthepage.
aria check usesbehaviour basedacceptanceteststoevaluateapage sdynamic behaviour with respect to accessibility requirements through pre defined usage scenario test cases.
we considered the failure of anyoftheseteststoconstituteadetection.forallfourtools our mechanism for recognizing a detection was consistent with the tool s intended usage and resulted in themostfavorable accuracy scores for the tool.
the result of rq1 is shown in table .
columns dep and der showeachtool sdetectionprecisionandrecall for eachtype ofkafs.
toanswerrq2 wemeasuredtheabilityof kafetoaccurately identify the faulty element s responsible for the kaf.
for this rq weonlycompared kafeagainstqualweb andwavesincetabindexcounterandaria check do not provide localization information.
to measurelocalization quality weusedtheeffortmetricfrequently usedinthefaultlocalizationcommunities bycalculating the expected number of elements a developer using the output ofeachtool wouldhavetoexaminetofindthefault.thismetric reflectsanassumptionaboutdevelopers behaviorandprovidesa normalization that allows us to quantify and relatively compare results.
to calculate kafe s localization quality for subjects containing onlyasingle kaf wedirectlyusedtherankofthefaultyedgein therankedlistofedgesproducedastheoutputofthelocalization algorithms.
for subjects containing multiple failures we calculated therankofeachfaultyedgeusingthemethodologyproposedby jones and colleagues .
this methodology reports the rank of the first faulty element that appears in the result set simulates the fix of that fault and then reruns the localization analysis to get the rankingofthenexthighestfault.theintuitionbehindusingthis methodologyisthatitapproximatestheworkflowofadeveloperwho scans the results fixes a fault and then reruns the analysis to see if any more faultsremain.
to calculate the localization quality of the results generated byqualweb andwave weemployedaslightlydifferentprocess.
this is necessitated by the fact that neither tool ranks the reported htmlelements.therefore weusedamethodologyproposedby alameer and colleagues .
this technique approximates anaveragerankundertheassumptionthatthefaultyelementisuniformly distributed in an unordered set.
for a single fault the average rank is on average half the size of the unordered set.
in the case of multiplefaults thisgeneralizestoalinearsearchfor kitems faults inanunordered set ofsize nwhere thedistribution ofthe kitems is uniformly random.
the equation for calculating this value is n k .
lastly since both tools return a set of html elements as opposed to edges we considered a localization to be successfulifthetoolidentifiedanodecorrespondingtoeitherthe sourceortargetofthefaultyedge.intable column lor shows thelocalizationrecallofeachtool whichistheaveragepercentage of output sets returned that contained the faulty element in any rank.
columns mef and aef show the median and average number of elements needed to be examined to find the kafs for eachtool.
toanswerrq3 wemeasuredtherunningtimeofthefivetools on each subject web page.
for kafe the running time included thetimetostartthetool loadthebrowser buildthemodels and compute detection and localization results algorithms 1to4 .
for the other four tools the running time included the time to run the tool on a subject until the output of the tool was displayed.
for qualweb this meant the time to submit a subject link for analysis until the result page was displayed.
for wave it included the time from the browser extension was clicked until the results were displayed.
for tabindex counter andaria check this included the timeofloadingthepage executingthetool sunittestcodes and displaying the result.
the results of rq3 are shown in table .
for eachtool the average column showsthe averagerunning time.
.
discussion ofresults fordetectingiafs theresultsintable 1showsthat kafewasable to detect iafs in the subject applications with high accuracy.
in termsofprecision only tabindex counter performedbetter however itsrecallwasonly39 .fromexaminingthisresult weconcluded that while using tabindex androleattributes to detectiafs was averypreciseapproach itdidnotdetectallofthedifferentways kafscouldoccur.intermsofrecall only aria check matchedthe recall ofkafefor iafs.
in our examination of aria check s results we observed that subjects failed all of its test cases and all of the subjects failed at least one of the test cases.
this included 863esec fse august 23 28 athens greece pault.
chiou alis.alotaibi andwilliamg.j.
halfond subjectsthatwehadverifiedasfreeofiafs.thisresultindicates thatfailurestoconformtoariamarkupstructurearenotsufficient to indicate the presence of iafs.
lastly none of the approaches exceptfor kafewereabletodetectanyofthe ktfs.thekeyboard traps were undetectable by the other tools because they focused on examining dombasedproperties but ktfs representruntime behaviorthat isundetectable byexamining the dom.
in terms ofthe qualityof thelocalization kafeperformed significantly better than the other two approaches.
one of the key results that show this is the localization recall lor .
for iafs this metric shows that the html elements outputted by qualweb containedonly6 ofthefaultsand wavecontainedonly15 of thefaults.incontrast kafe soutputcontained94 ofthefaults.
significantly theresultsofmedianrank mef andaveragerank aef show that kafewas able to consistently highly rank the faulty elements.
in fact across all subjects kaferanked the faulty edgeinthetopthreefor35 ofthefaults andintoptenfor76 of the faults.
for ktfs the localizationqualitywas also high but it wasnotpossibletocompareagainstotherapproachessincenone ofthemcould detect andtherefore localize ktfs.
we investigated the results in more detail to understand the cases in which our approach did not correctly detect or localize.
fordetection wefoundourapproachdetectedtwofalse positive iafsandonefalse positive ktf.fortheiafs thedevelopersimplementedsectionheadingsusingnon accessiblelinks.basedon ourobservations thesenon accessiblelinksweresupposedtobe accessiblebutinthiscontext theyofferednointeractivitytothe web page so we did not consider them to be true failures.
based onourexperience usinglinksforsectionheadingsisanunusual implementationtechnique.forthe ktf thefalse positiveoccurred onacaptchacomponent.inthelivewebpage therewasnotrap.
however during our experiment a trap occurred because our web proxy did not correctly cache this captchacomponent due to securityprotocols.forlocalization ourapproachwasunabletolocalize five iafs due to firefox s implementation of the dommutation observerwebapi notbeingabletodifferentiatesomespecific sub states under mouse hover which meant that they were not included in the oracle pcnfg.
our approach was also unable to localizethree ktfsbecauseinthoseparticularcases thedeveloper implemented dropdown boxes that visually overlaid each other.
this caused the selenium webdriver to be unable to interact with thedropdowninwhichtheseadditionaltrapswerelocated.inturn thismeantourapproachcouldnotbuild knfgedgesoriginating from thesedropdownboxes.
the runtime of kafewas significantly slower than the other approaches.however inabsolutetermstheaverageamountoftime neededby kafe abouttwentyminutes isnotasignificantamount of time.
furthermore this higher time cost is offset by its much higherprecisionandrecallthantheotherapproaches.weanalyzed theruntimebreakdownofeachindividualstepin kafeindetail andfoundthatover99 ofthetotaltimewasspentonmodeling and building the graphs.
specifically the time spent on building theknfg andpcnfg averaged .
minutes and .
minutes respectively.theaveragetimefor kafdetectionwas0.8seconds andforkaflocalizationitwas3seconds.theaveragedetection andlocalizationtimeforiafswas1.1secondsversus2.7seconds for ktfs.
div div div1 a groupon page where the show password button is not reachable focusable and the facebook and google log in buttons arereachable focusable butnotactionablebythekeyboard.
input b canonproduct registration page where the keyboard focus is trappedon theproduct model inputbox .
figure real world examples ofkafs .
.
the impactof kafs.the impactofthe kafsthatwe found in our subjects was generally quite severe.
for iafs often core functionalitiesofthewebpagewereunavailabletokeyboard based users.
for example they would be unable to log in via google or facebook s external authentication e.g.
figure 4a unable to retrievetheirpassword unabletochangetheirlanguage locality preference or sometimes unable to use the like facebook plugin.
the impact for ktfs was even more dramatic.
users would get stuckwhenenteringdataintowebformswithauto tabbingscripts preventingthemfrommovingbackwardstomakecorrections.this is particularly troublesome for blind users that must move backwardsthroughthefieldstoverifythattheycorrectlyenteredthe numbers viascreen readers.when stuck theywouldbe forcedto refreshthepage orclosethebrowserandrisklosingalloftheform information entered.
.
.
the rootcausesof kafs.weanalyzedthesubjectwebpages toidentifyrootcausesofiafsandfoundseveralreoccurringpatterns.
custom ui controls based on div span or li where developers would implement mouse event handlers but not keyboard handlers.
we found that out of buttons and out of dropdown lists across our subject pool were inaccessible duetotheirinabilitytoreceivekeyboardfocus.wealsofound34 instances where a a was used to trigger javascript instead of having an href attribute.
as a result these elements were not able to receive keyboard focus .
we found two instances where the developer explicitly assigned a tabindex of to make a customwidgetfocusablebutyet withoutdefininganykeyboardevent handlers the controls were not actionable.
actions triggered by mouse hovering.
overall a remarkably high of menus implemented to expand when a mouse hovered over them were inaccessible.roughly athirdofthosecouldnotreceive focus and mostof theothers thatcould receive focus could not expand via a keyboardaction.thisproblemalsoappearedwhentooltipswere 864detectingandlocalizing keyboardaccessibility failuresin webapplications esec fse august 23 28 athens greece implemented using custom mechanisms.
overriden standard control elements.
we found six cases of checkbox radio button whose operations were delegated to a programmatically associated label .
clicking on the label indirectly activates the control.
however for aesthetics the developers made these control hidden and styled its label s css to make it appear to be a custom checkbox radio button.these inaccessible implementations assumethatuserswouldbeableto click onthe label totick the associatedcontrol.
for root causes of ktfs we similarly found several reoccurring patterns.
auto advanceduringdataentryinwebforms.over half of the of the ktfs we found were due to mistakes in implementingthisfunctionality.
customizedwidgetsboundtoscripts that altered the focus or the layout of the ui.
often unintended side effects of this alteration would lead to the ktf.
text input boxeswith overriden keydown andkeypress events.typically these would be used to auto complete data entered into search boxes or to filter the contents of dropdown lists as users entered text e.g.
figure 4b .
mistakes in the implementation of these handlers resulted in keyboard users being unable to navigate away from the inputbox.
.
.
limitations.
the primary cause of inaccuracy in our approach was when selenium webdriverwas unable to interact with some elements that it considers notinteractable or when the domwas considered stale .
thesesituations occur when elementsareobstructedbyothers orwhenthe domisspontaneously altered by ajax calls that were not triggered via our automated interaction e.g.
eventsautomaticallyloadedvia atimer aslider carousel that constantly loads persistent streams or asynchronous calls that implement infinite scrolling to loadand populate data .
we believe that further improvements in web page capture and replaytechniqueswouldallowforthisbehaviortobemorereliably controlledfor duringanalysis.
.
threatsto validity a potential threat to external validity is that our tool is implementedusingselenium sfirefoxdriverbuttherecouldbepotential discrepancies in keyboard navigation behaviors between different webbrowsersthatcausescross browserbehavioralinconsistencies.
however it is important to note that the kafground truth would therefore also vary.
these browser specific kafs could be easily detected by systematically running kafeusing different selenium webdrivers for differentbrowsers.
a potential threat to criterion validity is that both the kafs ground truth andfaultswereidentifiedbytheauthors.interms of mitigating this threat it is important to note that the success criteria in wcagare by design defined in such a way as to make it possible to objectively determine when a failure has occurred .inaddition wefollowedbestpracticesdefinedin and there was no disagreement between the authors in terms of what was classified as a iafs or ktfs.
the failures are also defined intermsofbehaviorsofspecificelementsofa ui whichmakesit possible to objectively determine the faulty element that should be identifiedby kafe.asfurthervalidation weperformedafollow upinvestigationofthe kafsweidentifiedinourstudy.sincewe began the research project of the subjects had been repairedby thedevelopers.
we reached out via the website s contact forms totheremaining28toreportourfindings.fifteenacknowledged ourreport andthreeofthemreportedthattheywereaddressing the kafs.
related work guideliner isatoolthatassesseswebuielementconformance to a predefined set of usability guidelines.
it focuses on visual characteristics of web uis such as the position of elements on the screen the distance between the elements and the length of scrolling.
vizassert uses formal verification methods to attemptdetectionandrepaironinaccessiblelayoutproperties.both approaches focus on accessibility relating to layout properties and are not capableofinteractingwiththe put to expose kafs.
axeray is an automated approach that infers semantic groupings of elements across various regions of a web page to test if these elements violate their wai aria roles semantic structure.
researchwork verifiesariaspecifications ondynamic content and ui components to detect interactive accessibility issues.althoughariaisusefulinprovidingcustomattributesvia thebrowser saccessibilityapi italonedoesnotensuretheseinteractablecontrolelementsareproperlyscriptedtobeaccessible.
work done by watanabe et al.
evaluates various dynamic ui elements that can cause ataccessibility issues.
they characterize complex custom widgets and navigation elements such as dropdownmenus tabwidgets menupopups datepicker slideshowsandcarouselswidgets toensuretheybehaveaccording to accessibility standards.
although useful for inspiring best practices for implementing iafconformance these ad hoc approachescannotbegeneralizedtohandlekeyboardonamore diversescale.
manytechniquesfocusonmobileaccessibilityissuesandtheir conformance measures based on violations particularly developed accessibility checkers to identify andcategorizetheidentifiedissues.whilethemajorityofthisresearchisrelatedtomobileaccessibilityfailuredetection research by zhang et al.
focus on repairing these failures as well as other deep learning and search based repair.
latte isanothertechniquethatautomatically executesusecases using assistive services to detect accessibility failures.
however these approachesonly work onandroid apps not webapps.
conclusion poorlydesignedwebapplicationscreatekeyboardaccessibilitybarriers that exclude people with disabilities from interacting with its functionalities.
in this paper we presented a novel approach for automaticallydetectingandlocalizing kafsinwebpages.theevaluationshowedthatourapproachcoulddetectandlocalizekeyboard failures with high precision and recall.
we believe these results are positiveandshowthatourapproachcouldhelpdeveloperstodebug kafs inwebapplications.