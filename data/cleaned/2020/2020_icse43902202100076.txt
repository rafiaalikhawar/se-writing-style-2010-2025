same file different changes the potential of meta maintenance on github hideaki hata raula gaikovina kula takashi ishio christoph treude nara institute of science and technology hata raula k ishio is.naist.jp university of adelaide christoph.treude adelaide.edu.au abstract online collaboration platforms such as github have provided software developers with the ability to easily reuse and share code between repositories.
with clone and own andforking becoming prevalent maintaining these shared files isimportant especially for keeping the most up to date version ofreused code.
different to related work we propose the conceptof meta maintenance i.e.
tracking how the same files evolve indifferent repositories with the aim to provide useful maintenanceopportunities to those files.
we conduct an exploratory studyby analyzing repositories from seven different programminglanguages to explore the potential of meta maintenance.
ourresults indicate that a majority of active repositories on githubcontains at least one file which is also present in anotherrepository and that a significant minority of these files aremaintained differently in the different repositories which containthem.
we manually analyzed a representative sample of sharedfiles and their variants to understand which changes might beuseful for meta maintenance.
our findings support the potentialof meta maintenance and open up avenues for future work tocapitalize on this potential.
i. i ntroduction clone and own is a quick way to create customized variants of a software project by copying an existing product and adapting it to a new set of requirements .
despite perceivedbenefits such as simplicity availability and independence ofdevelopers clone and own has been criticized for leadingto a large number of code clones making it difficultto propagate changes such as bug fixes from one instanceto another.
clone and own also leads to problems related toawareness developers do not know when and where their codeis being cloned they do not know the origin of the clonedcode and they have no means of staying aware of changesto other instances that might benefit their own instance of thecloned code.
source code reuse across multiple software projects has been widely studied in code clone research.
it is reported thata large number of projects included copies of libraries .gharehyazie et al.
reported that most projects obtain files fromoutside rather than providing their files to other projects .forking including traditional hard forking and recentfork based development in github is one type ofsource code reuse.
recent studies discussed several problemsin forking such as redundant development lost contributions and fragmented communities .even with its large scale code resources and a large amount of developers google is reported to address reuse properlywith a monolithic source code management system .such a monolithic system has several advantages unifiedversioning extensive code sharing and reuse simplified de pendency management large scale refactoring and so on .based on the monolithic source code management changesto core libraries are promptly and easily propagated throughthe dependency chain into the final products that rely on thelibraries .
although introducing such a complete monolithic source code management system in the entire free libre open sourcesoftware floss ecosystem is not practical tracking sourcecode across multiple projects could bring new insight intosoftware maintenance.
if we can aggregate and composeuseful changes from various repositories maintaining the sameorigins sharing such composed changes can help softwaremaintenance activities efficiently for multiple projects.
we callthis approach meta maintenance.
to investigate the feasibility of meta maintenance in this paper we report on the results of an exploratory study ofalmost million files that are shared by multiple githubrepositories.
we found that in more than of the repos itories in our sample there is at least one file which alsoexists in another repository.
most of these files have not beenmaintained but there is a significant minority which has notonly been maintained but often has received project specificchanges such as bug fixes.
we manually analyzed a represen tative sample of such files as part of a qualitative analysis and found that files that are shared by a large number ofrepositories are often libraries e.g.
jquery while files that areshared by a smaller group of repositories tend to contain utilityfunctionality e.g.
drivers .
in the former case the repositorieswhich share the file tend to be unrelated while in the lattercase there is often a relationship between repositories e.g.
one repository relying on the code in another .
investigating how files changed in different repositories revealed a number of different types of changes includinglibrary updates e.g.
upgrading the jquery library commitstaken from a known origin e.g.
the linux kernel project as well as project specific changes e.g.
bug fixes .
we ar gue that project specific changes have the largest potentialfor meta maintenance and we conducted a survey in which ieee acm 43rd international conference on software engineering icse .
ieee we asked project maintainers what they thought of specific instances where meta maintenance could be applied in their repositories i.e.
the maintainers were maintaining a file that had been changed in another repository potentially incorporating interesting changes.
this survey result provided further evidence for the potential of meta maintenance and pointed out interesting areas for future work.
ii.
r elated work before outlining our methodology we discuss extensive literature related to code clones origin analysis and forks.
a. cross project code clones code clone detection is the most popular approach to analyze source code reuse activities.
since developers may modify a code fragment for their own purpose various tools have been proposed to detect similar source code fragments .
kamiya et al.
proposed ccfinder that analyzes normalized token sequences.
jiang et al.
proposed deckard that compares a vector representation of an abstract syntax tree.
nguyen et al.
proposed exas that compares a vector representation of a dependence graph.
sasaki et al.
proposed fcfinder that recognizes file level clones using hash values of normalized source files.
cordy et al.
proposed nicad that compares a pair of code blocks using a longest common subsequence algorithm.
sajnani et al.
proposed sourcerercc that compares a pair of code blocks using jaccard index of tokens.
code clone detection tools revealed that software developers often copy source files from other projects.
hemel et al.
analyzed vendor specific versions of linux kernel.
their analysis showed that each vendor created a variant of linux kernel and customized many files in the variant.
ossher et al.
analyzed cloned files across repositories using a lightweight technique.
they reported that projects cloned files from related projects libraries and utilities.
koschke et al.
also reported that a relatively large number of projects included copies of libraries.
lopes et al.
analyzed duplicated files in .
million projects hosted on github and reported that the projects have a large amount of file copies.
gharehyazie et al.
analyzed cross project code clones of java projects on github.
they also analyzed timestamps of the clones and reported that developers often copy an entire library and some projects serve as hubs sources of clones to other projects.
the analyzed source code is a snapshot at a certain point of time.
our study extends the analysis by including additional programming languages and all the versions of projects.
identified code reuses across projects can be used for several applications.
dang et al.
reported that microsoft developers use code clone information to fix bugs in multiple products at once.
rubin et al.
reported that industrial developers extract reusable components as core assets from existing software products.
bauer et al.
proposed to extract code clones across products as a candidate of a new library.
ishihara et al.
proposed a function level clone detection to identifyreusable functions in a number of projects.
luo et al.
proposed a method to identify semantically equivalent basic blocks for code plagiarism detection.
chen et al.
proposed a technique to detect clones of android applications using similarity between control flow graphs of methods.
davies et al.
proposed a file signature to identify the origin of a jar file using classes and their methods in the file ignoring the details of code.
ishio et al.
extended the analysis to automatically identify libraries copied in a product.
similar to these approaches this study starts the analysis from file level clones.
b. origin analysis software projects use source code repositories to manage the versions of source code.
although a repository tracks modified lines of code between two consecutive versions of a file the feature is not always sufficient to represent a complicated change.
godfrey et al.
proposed origin analysis to identify merged and split functions between two versions of source code.
the method compares identifiers used in functions to identify original functions.
steidl et al.
proposed to detect source code move copy and merge in a source code repository.
the method identifies a similar file in a repository as a candidate of an original version.
kawamitsu et al.
proposed an extension of origin analysis across two source code repositories.
their method identifies an original version of source code in a library s source code repository.
spinellis constructed a git repository including the entire history of unix versions.
the unified repository enables developers to investigate the change history of source files across projects.
german et al.
used ccfinder to detect code siblings reused across freebsd openbsd and linux kernels and then investigated the source code repositories of the projects to identify the original project of a code sibling.
krinke et al.
proposed to distinguish copies from originals by comparing timestamps of code fragments recorded in source code repositories.
krinke et al.
used the approach and visualized source code reuse among gnome desktop suite projects.
in this study we do not intend to identify origins but investigate files in clone sets in terms of whether there are useful changes in their histories that could benefit other repositories.
c. forks software developers often fork repositories in order to propose source code changes to the original projects.
stanciulescu et al.
analyzed an oss community and reported that forks contribute new features while developers may spend their effort on redundant development.
ren et al.
proposed a machine learning model using change description patch content and issue tracker to identify redundant code changes in forks.
zhou et al.
proposed a tool named infox to automatically identify unique source code changes as new features in forks.
different from those analyses this study does not focus on forked repositories and revealed that non forked repositories also include their own changes to reused source 774code.
zhou et al.
reported that better modularity and centralized management are associated with more contributions and a higher fraction of accepted pull requests from forks.
they also reported that the lower the pull request acceptance rate the higher the chance of a project having hard forks.
regarding hard forking ray et al.
analyzed porting of an existing feature or bug fix across forked projects .
they reported that forking allows independent evolution but results in the significant cost of porting activity.
propagating changes to others is also considered as a challenge in software product line engineering.
str ber et al.
included the task in scenarios for evaluating techniques that support developers during the evolution of variant rich systems.
to support such propagation of a bug fix redebug and clorifi have been proposed to efficiently identify source file clones to which a patch should be applied.
iii.
m eta maintenance terminology the concept of meta maintenance is based on the model of individual evolution of the same files clones in different repositories not limited to forks which is inspired by google s monolithic source code management system with the aim to maintain the overall ecosystem.
we now define the terminology needed to describe meta maintenance at file level.
aseed file is a specific version of a file that is shared in multiple software repositories.
in this paper we focus on git repositories thereby considering specific git blobs appearing in multiple repositories to be seed files.
a git blob stores the content of a file with a specific version and is identified with its sha hash of the content .
let frefer to a seed file for a repository rso that r f indicates the repository rcontaining filef.
software repositories that contain the same seed file are then referred to as belonging to the same seed family sf0 where sf0 r1 f r2 f .
.
.
r n f for repositories r1 r2torn.
after the time tpassed the seed family sf0 becomes sft r1 fx r2 fy .
.
.
r n fz where fx fy andfzrepresent updated files from the same seed file f and x y and zare the number of changes to the files.
the file f0 f and we call fi i avariant .
we call fland fmduplicate variants if their contents are the same even if l andmare different.
meta maintenance involves the analysis of how variants in the same seed family evolve.
forking is an explicit form of sharing seed files.
in this paper we do not focus on forks as seed families.
recent studies have tried supporting change propagation in forks with a centralized model that is accumulating changes upstream and distributing them downstream .
as well as such explicit reuse relationships meta maintenance is conceptualized to be able to support implicit reuse relationships.
we intend to support repositories in seed families with a decentralized model that is useful changes are aggregated from individual repositories and are distributed to others.iv.
p reparations in this section we present our research questions and data collection methodology.
a. research questions the main goal of the study is to explore the potential for meta maintenance for contemporary software projects in github.
based on this goal we constructed six research questions to guide our study.
we now present each of these questions along with our motivation.
rq1 how prevalent are seed files in software repositories?
rq2 what kinds of seed files are there?
rq3 are there relationships among repositories in seed families?
rq4 what was the main driver of the changes for variants?
rq5 how uniquely do variants evolve in seed families?
rq6 how do developers consider changes for variants?
the motivation of rq1 is to understand whether seed files and their seed families are common in the wild.
furthermore we would like to quantitatively explore the distribution maintenance statuses and patterns of seed families.
rq2 rq3 andrq4 require a deeper analysis of seed files and repositories where we would like to understand the nature of the seed files and reasons behind their evolution.
the key motivation for rq2 is to identify kinds of seed files that are used in the software repositories.
such insights would help identify the nature for why these seed files were reused in other repositories.
then for rq3 we would like to understand whether there is a connection among repositories in the same seed families.
the key motivation for rq4 is to determine the key drivers that influenced the changes that were made to the seed files in those repositories.
rq5 then investigates the seed files from an evolutionary and maintenance standpoint.
we would like to quantitatively understand how developers are updating or maintaining variants after reusing seed files in their projects and how differently variants evolve.
our aim forrq6 is to understand how developers react to changes in other variants.
b. data collection here we describe our procedures for target repository preparation git blob extraction and stratified sampling for our data collection.
a repository preparation to pursue the feasibility of meta maintenance we collect a large amount of software development repositories that have been actively developed.
we follow the same procedure as in a previous study to identify candidate repositories.
we target software development repositories on github written in seven common programming languages that is c c java javascript python php and ruby.
these languages have been ranked consistently in the top languages on github from to based on the number of repositories from to the number of pull requests from to and top languages from to in the official report .
using 775table i collected repositories language candidates obtained c c java javascript python php ruby sum the ghtorrent dataset1 we identify active repositories for the seven languages with the following criteria i having more than commits in their entire history the same threshold used in previous work and ii having at least commits in the most active two years to remove long term less active repositories and short term projects that have not been maintained for long.
we determine repositories languages based on the ghtorrent information.
as mentioned in section iii we exclude forked repositories in this study.
we remove repositories that had been recorded in ghtorrent as forks of other repositories.
note that even though we exclude such explicit forks which have been targeted extensively by related work there can be implicit forks in our dataset.
this could be because repositories were forked outside of github for example.
although these implicit forks are not considered in research on fork based development we keep these repositories in this study to investigate the feasibility of meta maintenance.
with the above procedure we obtained the candidate list of repositories for the seven languages as shown in table i. from the candidate list some repositories were not available because they had been deleted or made private.
additionally we exclude repositories that have only one committer in order to remove self learning repositories online judge code for example .
in total we obtained more than repositories which is almost of the candidate repositories.
b git blob extraction from each repository we extracted all existing blobs and their file names using git revlist all objects andgit cat file commands.
only the blobs of source files with the following file extensions are targeted in this study .c .h c .cc .cp .cpp .cx .cxx .c .hh .hp .hpp .hxx .h c .java java .js javascript .py python .php php and.rb ruby .
blobs appearing in multiple repositories are considered to be seed files.
in total we obtained seed files in our dataset.
c stratified sampling to understand these seed files and their characteristics towards answering our research questions we conducted stratified sampling to enable us to gain insights into a variety of different scenarios.
we hypothesize that the size of the corresponding seed families is a particularly important criterion for distinguishing different kinds of seed 1mysql database dump from html.
fig.
plot of the number of seed families for each number of seed files log log scale .
table ii construction of the stratified sample seed families sample size common sometimes rare sum files.
to understand the distribution of size of seed families across seed files we plotted the distribution cf.
figure .
each dot represents a tuple of number of seed families size of seed family e.g.
the left most dot indicates that there were more than million seed families of size two.
we then divided seed files into three categories those that are part of big seed families common those are part of small seed families rare and an additional category in between sometimes .
based on visual inspection of the plot in figure we set the thresholds at a family size of at least for common and at least for sometimes.
the left side of figure represents small seed families rare with less than instances each and the right side represents large seed families common with more than instances each.
table ii shows the corresponding numbers.
the stratum with a family size of at least contains seed families the stratum with a family size of at least but no more than contains more than million seed families and the stratum with a family size smaller than contains more than million seed families.
the goal of our stratified sampling is to understand these different groups better.
we randomly sampled a statistically representative number of seed families from each stratum ensuring that our conclusions regarding ratios within each sample would generalize to the entire stratum with a confidence level of and a confidence interval of .
the last column of table ii shows the number of seed families in each sample for a total sample size of .
for the seed families the evolutionary period of variants within a seed family measured from the earliest commit in seed files to the latest commit in variants was a minimum of .
years a median of .
years and a maximum of years.
776v.
m ethod we describe our mixed method procedure including a quantitative analysis a qualitative analysis and a survey.
a. quantitative analysis to understand the prevalence of seed files in a large amount of software development repositories rq1 we conduct a quantitative analysis of our collected dataset and stratified sample in terms of existence status size and modifications of seed files.
the history of a variant is examined based on the path of the seed file.
therefore variants that have changed significantly in content can be tracked but variants that have been renamed or moved are not tracked in this study.
to investigate how variants evolve in different projects rq5 we measure the degree of variant evolution in each family using two metrics retention of similarities with seed files and uniqueness of differences with other variants.
retention how variants are similar to seeds.
for a pair of a variant vand its seed file s we measure their similarity as follows similar to a previous study of clone and own .
retention f v s v s v where x represents a set of trigrams of tokens in file x ignoring comments and white spaces.
to recognize tokens and comments in source code we employed lexical analyzers based on the ripper library for ruby and antlr4 for the other six languages.
we calculate an average retention value for all variants vin a seed family as follows.
retention v s p v2vretention f v s v a higher retention v s means variants are similar to their seed files that is variants have not been changed largely.
uniqueness how variants evolved differently.
to measure the amount of project specific changes for each variant we calculate the uniqueness of content as follows.
uniqueness v s p v2vu v s v v v u v f t2 v 8f2f.t f v the function u v f measures the amount of trigrams only in a variant vin the family.
a higher uniquness v s value indicates that the variants are more different from one another.
b. qualitative analysis to understand the types of seed files rq2 the relationships among repositories in seed families rq3 and the characteristics of changes for seed files rq4 we manually annotate seed files and seed families in our sample which is conducted in multiple iterations.
in each iteration except for the last one three authors independently annotate instancesfrom each stratum using open coding.
after each iteration the authors discuss the codes that have emerged and how to distinguish between them.
we repeat this process on new subsets from each stratum until we finalize the list of codes and achieve kappa agreement of at least .
among the three annotators.
one author then annotates the rest of the data.
since there can be a large number of variants in a seed family we annotate up to five variants per seed family.
if a seed family contains more than five variants we conduct stratified sampling by selecting the three variants with the largest number of commits and the two variants with the lowest number of commits.
c. survey to understand the potential of meta maintenance rq6 we conduct a survey for developer feedback.
to find metamaintenance opportunities we searched unique commits in seed families that is we identified commits that appear only in single repositories.
to limit the search space we target commits whose commit message contains the keyword fix which is considered to be related to fixing bugs.
there are and seed families that contain at least one unique commit for rare sometimes and common samples respectively.
again to limit the search space seed families with more than two unique commits are filtered out which resulted in and seed families for rare sometimes and common samples respectively.
we manually investigate these seed families.
by checking the latest commits on github we found that some repositories applied the identified unique commits later by cherry picking.
we also found that some unique commits are not easily applicable to other repositories because of the large differences in the histories.
five cases were selected where the changes were neither too large nor too complex.
the survey was distributed in forums issues or emails of the corresponding projects.
as part of the questionnaire we asked a how important the seed file was to the project b what kind of maintenance activities were the developers interested in regarding the file and c whether they would be interested in a meta maintenance approach.
we received three responses and noticed that due to specificity of the files only the core contributors of the projects responded in all cases.
vi.
f indings here we present our findings for each research question.
a. prevalence of seed files rq1 a seed file existence figure 2a shows the percentages of repositories that have at least one seed file.
although the percentage is relatively low for java but still more than more than of repositories contain seed files for the other languages.
especially for repositories written in c javascript php and python more than of repositories contain seed files.
figure 2b presents the distributions of the number of different seed files per repository for repositories that have at least one seed file.
median values are shown in the boxplot.
we cc javajavascriptphppythonruby type a anoseed seed a percentage of repositories with and without seed files.
c c java javascript php python rubyseed per repo b distribution of the number of seed files per repository.
fig.
prevalence of seeds from a seed file existence and b the number of seed files in a repository per language.
table iii frequency of variant statuses in our sample common sometimes rare dormant inactive unchanged maintained sum see that repositories contain dozens of seed files at median which implies there likely exist sets of seed files commonlyshared by multiple repositories.
for c and php whose projectshave more seed files we see forked projects from specificproducts which should share many seed files.
b status of variants for the concept of metamaintenance we are interested in only repositories that aremaintaining variants.
we distinguish variants based on theirstatuses as follows.
dormant a variant is in a dormant or an unmaintained repository.
similar to previous studies we set one year as a threshold to consider dormant that is we consider a repository dormant or unmaintained if therepository does not have commits in .
inactive a variant does not exist in the main branch usually master in github .
unchanged the seed file has not been modified and exists in the latest commit of the main branch.
maintained a variant had been changed and exists in the latest commit of the main branch.
table iii shows the frequencies of the variant statuses in thethree strata of our sample.
we see that the majority of variantsare not maintained for common for sometimes and for rare.
c types of seed families table iv summarizes the frequencies of seed family types as described below.
not maintained we observed that some projects recorded in ghtorrent point to the same repositories even though idtable iv frequency of seed family types in our sample common sometimes rare not maintained empty seed zero variance non zero variance sum and or project names are different.
this happens when repositories re registered in github.
we consider a seedfamily not maintained if there is no maintained variantin the seed family after removing identical repositories that is all variants in the seed family are either dormant inactive unchanged or identical.
empty seed we found some seed files do not have meaningful contents as source code such as no line only a blankline or only comment lines.
we manually identified thosefiles.
as seen in table iv such empty seed files appearonly in the common stratum.
zero variance there is only one maintained variant or the same changes have been applied to all variants that is duplicate variants.
we found some variants had been cherry picking commits from their origins with differentfrequencies.
non zero variance even after removing duplicate variants there are multiple maintained variants in a seed family.
for meta maintenance we are only interested in variants thathave evolved independently.
therefore only seed families ofnon zero variance are targeted in our study.
in the seed families duplicate variants are removed for the further analyses.table v shows the number of seed families and the number ofremaining variants in our filtered sample.
this sample is usedto answer the following research questions.
778table v target data in our sample seed families variants common sometimes rare sum table vi types of seed files library configuration utility other common sometimes rare summary we revealed that seed files are prevalent.
in more than of the targeted repositories in github there exists at least one seed file.
despite the large amount of seed files most of them have not been maintained nor used in the latest snapshots.
however there exists some amount of potential variants for meta maintenance for each stratum.
b. types of seed files rq2 we achieved kappa agreement of .
in our annotation.
our analysis revealed the following four types of files with table vi showing the number of instances for each code in each stratum library seed files which contain a library a program that contains a collection of code used by applications are particularly widespread in the common stratum where they account for of all seed files that we encountered during our annotation indicating that most seed families in the common stratum are library users.
a representative example is the jquery library e.g.
in the modxcmsjp evolution jp repository.
utility functionality seed files which contain utility functionality a system software for controlling the operation of a computer devices etc.
were predominantly found in the sometimes stratum where they account for of the annotated seed files coincidentally the same ratio as library files in the common stratum.
drivers such as the driver for avance logic als300 als300 soundcards in the masahir0y linux repository3are a representative example for this group of seed files.
configuration configuration files are much less common as seed files with most of them appearing in the common strata.
the config.php file of the contao core bundle4 repository can serve as an example.
media script jquery jquery.min.js contao config config.php1 10000raresometimescommon fig.
loc in seed files per stratum.
other we used the code other mostly for header files or files containing version information such as version.php in the gmagicscott core.wordpress mirror repository.
we also investigated typical file sizes in each stratum.
figure shows the corresponding distributions.
in general the number of lines of code for libraries which are widespread in the common stratum is smaller compared to the other strata mostly due to presence of a large number of minified javascript libraries.
the differences between sometimes and rare strata are negligible.
summary we revealed that seed files which are part of large seed families are often libraries whereas seed files from medium sized seed families tend to contain utility functionality.
files from large seed families tend to be smaller in terms of number of lines of code than files from smaller seed families.
c. repositories in seed families rq3 as documented by previous work github hosts a wide variety of projects the characterization of which is beyond the scope of this paper.
instead to understand the potential of meta maintenance our focus is on the relationships among repositories in seed families i.e.
whether there is a connection among them.
such connections could stem from forking or copying as well as from the code of one repository using the code from another repository.
we distinguish each repository in our sample into related or non related .
in this annotation we achieved perfect kappa agreement i.e.
.
among the three annotators.
related there is an explicit relationship among repositories e.g.
one is a fork of another their names are similar or identical or because one mentions the other prominently in its documentation.
the most common example of such a relationship are the many linux variants in our sample.
for example the driver file gl520sm.c is contained in the repositories masahir0y linux6and whissi linuxstable.7the repositories can easily be connected based on their names even though only the former contains the information that it is forked from torvalds linux.
in wp includes version.php 779table vii relationships among seed families related non related common sometimes rare table viii change types known library project tangled other origin updates specific updates common sometimes rare addition the latter repository states in its description that it is a mirror of the linux distribution hosted on git.kernel.org.
non related on the other hand many seed families do not contain any evidence to suggest that there is a connection among the repositories apart from using at least one common file.
for example the repositories movelab tigatrapp server9and magda io magda10both contain twitter s bootstrap library via a bootstrap.js file.
the former repository contains a server with which tigatrapp a spanish citizen science project apps communicate whereas the latter contains an open source software platform designed to assist in all areas of the data ecosystem.
apart from both repositories using bootstrap there is no apparent connection among the repositories.
note that both repositories have made one change to their instance of bootstrap.js since the files were identical.
table vii shows that the ratio of related vs. non related differs significantly between the strata.
while all repositories in our sample from the common stratum were not related the vast majority from sometimes and rare were related.
summary repositories which contain seed files that are part of large seed families tend to not be related.
in many cases they are different repositories using the same library.
on the other hand repositories which contain seed files which are part of smaller seed families tend to be related.
d. changes for seed files rq4 to understand how the repositories might be able to benefit from meta maintenance we investigated the commit histories of all files in our sample to characterize the set of changes that had been applied to them.
our annotation revealed four categories plus other and we achieved kappa agreement of .
.
reference to a known origin for many repositories in our sample the origin is obvious this applies in particular the various linux variants.
in those cases changes that have been applied to seed files are often the same commits that have been applied to the origin.
we were often able to detect this directly from the commit meta information e.g.
when commit author and commit committer are different.
for example the process.c file11in the ziyann omap repository attracted commits since being identical across its seed family many of which were committed by linus torvalds12and authored by a contributor of the ziyann omap repository.
library updates library updates are the most common kind of change in the common stratum see table viii.
an example is the previously mentioned jquery library e.g.
in the modxcms jp evolution jp13repository.
while there have been commits to this file since it was identical across its seed family the commit messages of these commits14clearly show the pattern of library updates e.g.
update jquery .
.
.
.
and update jquery .
.
.
project specific changes the most interesting case for metamaintenance are project specific changes which are not library updates or made in reference to a known origin.
as table viii shows we found such files in all strata.
an example is the jquery library15in the dmitrykuzmin chat repository which has one new commit since being identical across its seed family with the commit message trying to fix ie issues.
.
we argue that such fix attempts might be relevant to other repositories containing the same file.
we found project specific changes in at least one quarter of seed families in the common and rare strata.
tangled updates in case the commit history contained changes that could not easily be localized to the file under investigation we applied the code tangled updates .
in these cases meta maintenance on the basis of files is unlikely going to be successful since changes affected many files often hundreds if not thousands.
tangled updates were not widespread in our sample.
other for change histories which did not fit any of the previous categories we applied the code other .
an example are the commits to bootstrap.js16in the sparcrequest sparc request repository.
all of the four commits made since the file was identical across seed families indicate updates to the copyright information most of them simply changing the year.
this is unlikely to be useful for maintenance.
process.c 0dce7db475116f3a35206714e2721bf355f049c2 manager media script jquery jquery.min.js webapp lib jquery .
.
.min.js assets javascripts bootstrap.js 780common sometimes rare0.
.
.
.
.
.0ratio of seed content a distribution of retention v s per stratum.common sometimes rare0.
.
.
.
.
.0ratio of unique content b distribution of uniqueness v s per stratum.
fig.
evolution of variants from a similarities with seed files and b differences with other variants.
summary while some variants were updated in