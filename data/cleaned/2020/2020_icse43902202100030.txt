autoccag an automated approach to constrained covering array generation chuan luo jinkun liny shaowei caiy xin chen z bing he z bo qiao pu zhao qingwei lin hongyu zhangx wei wu saravanakumar rajmohany dongmei zhang microsoft research china ystate key laboratory of computer science institute of software chinese academy of sciences china zmicrosoft united states xthe university of newcastle australia l3s research center leibniz university hannover germany chuan.luo v xich15 v hebi boqiao puzhao qlin saravar dongmeiz microsoft.com jkunlin william.third.wu gmail.com caisw ios.ac.cn hongyu.zhang newcastle.edu.au abstract combinatorial interaction testing cit is an important technique for testing highly configurable software systems with demonstrated effectiveness in practice.
the goal of cit is to generate test cases covering the interactions of configuration options under certain hard constraints.
in this context constrained covering arrays ccas are frequently used as test cases in cit.
constrained covering array generation ccag is an np hard combinatorial optimization problem solving which requires an effective method for generating small ccas.
in particular effectively solving t way ccag with t 4is even more challenging.
inspired by the success of automated algorithm configuration and automated algorithm selection in solving combinatorial optimization problems in this paper we investigate the efficacy of automated algorithm configuration and automated algorithm selection for the ccag problem and propose a novel automated ccag approach called autoccag .
extensive experiments on public benchmarks show that autoccag can find much smallersized ccas than current state of the art approaches indicating the effectiveness of autoccag .
more encouragingly to our best knowledge our paper reports the first results for ccag with a high coverage strength i.e.
way ccag on public benchmarks.
our results demonstrate that autoccag can bring considerable benefits in testing highly configurable software systems.
index terms constrained covering array generation automated algorithm optimization i. i ntroduction nowadays there are increasing demands for customized software and services.
developing highly configurable systems has attracted considerable attention in both academia and industry.
a highly configurable system provides many options through which users can easily customize the system .
however testing such a highly configurable system is challenging.
it is hard or even infeasible to test all possible configurations combinations of options as the number of configurations grows exponentially with the number of options and only certain specific configurations may lead to system failures.
for example assuming that a software system has options with possible values each there are more than ten million possible configurations in the worst case.
hence the time required for testing all these qingwei lin is the corresponding author of this work.configurations could be unacceptably high which creates an urgent need for more practical testing methods.
it is well recognized that combinatorial interaction testing cit is an effective and practical way for detecting option combination related faults in a configurable software system.
more generally cit tests a moderate number of configurations sampled from the entire configuration space thereby significantly reducing the number of required test cases.
this sampling process for cit generates a covering array ca .
a t way ca covers all possible combinations of the values of any set of tconfiguration options where t the coverage strength is a small integer value usually ranging from to .
in practice for configurable systems there are also hard constraints mutual dependencies and exclusiveness among the options.
the problem of constrained covering array generation ccag which aims to find minimum sized constrained covering arrays ccas while satisfying a given set of hard constraints is the core problem of cit and is in theory np hard .
practical algorithms for tackling the ccag problem can be categorized into three main classes greedy algorithms e.g.
constraint encoding algorithms e.g.
and meta heuristic algorithms e.g.
.
greedy algorithms can handle way and 3way ccag rapidly but the ccas produced by them are often very large and can be unacceptable in practical scenarios where considerable time is required for testing a single configuration .
constraint encoding algorithms first encode a given ccag instance into a constraint optimization problem and then solve it using a constraint solver.
although constraintencoding algorithms can solve way ccag they typically fail to tackle way ccag.
in contrast meta heuristic algorithms are able to tackle both way and way ccag and usually produce much smaller sized way and way ccas than the greedy algorithms.
however effectively solving tway ccag t still remains a challenge for meta heuristic algorithms .
it is important to solve t way ccag with t .
much work e.g.
has provided evidence that higher ieee acm 43rd international conference on software engineering icse .
ieee coverage strength indicates stronger fault detection capability.
the literature shows that way ccag detects only of faults for the widely used traffic collision avoidance system while way and way ccag can detect and of faults for that system respectively.
also a recent work shows that up to about of faults would be missed if we do not use combinatorial testing with high coverage strength t .
another recent work demonstrates that through extensive empirical study on various software the fault detection rate of t way ccag with t 4is up to .
more than that of way ccag.
actually for life critical applications e.g.
aviation even one fault can be fatal .
furthermore t way ccag with t 4can find corner case faults that could cause serious consequences and are very difficult to be detected through manual testing.
for example a recent study in lg electronics shows that through way and way combinatorial testing lg electronics detected critical faults in washing machines and refrigerators.
more importantly these faults could cost tens of millions of dollars if they had to be fixed after sale .
to our best knowledge very few work focuses on effective solving of the challenging way and way ccag problems.
for example recently a gpu enabled parallel ccag algorithm called chip reports the experimental results for way ccag on a number of benchmarking instances but the cca sizes reported by chip are remarkably large and the runtime of chip is considerably long which can be observed in section v and in the literature .
in this paper for the first time we study the efficacy of automated algorithm optimization techniques for ccag with a focus on solving t way ccag with t 4andt .
many metaheuristic algorithms expose parameters whose settings greatly affect their performance .
for instance in the context of cit a representative state of the art meta heuristic algorithm called tca which is able to produce small ccas in many cases introduces a number of parameters that have substantial impact on its performance.
automated algorithm optimization techniques including automated algorithm configuration e.g.
and automated algorithm selection e.g.
have been demonstrated to be effective on a variety of np hard combinatorial problems such as boolean satisfiability e.g.
and minimum vertex cover e.g.
.
in this paper we conduct research on leveraging automated algorithm optimization techniques to optimize the existing ccag algorithm tca in order to make it more capable of solving way and way ccag.
specifically we propose a novel automated ccag approach dubbed autoccag which can automatically schedule tca with different configurations for solving t way ccag effectively through leveraging the automated algorithm configuration and automated algorithm selection techniques.
through extensive experiments we present that autoccag achieves much better performance than current state of the art ccag algorithms including tca casa and chip .
in particular our comparative experiments are conducted on a broad range of real world application instances from pub lic benchmarks.
our experimental results clearly demonstrate thatautoccag significantly outperforms current state of theart ccag algorithms for way and way ccag on realworld instances.
in addition the performance of autoccag is better than or equal to that of all its state of the art ccag competitors for way and way ccag on all these instances.
our main contributions in this paper are as follows.
we provide clear empirical evidences that automated algorithm configuration and automated algorithm selection can push forward the state of the art in ccag solving.
we propose a novel automated ccag approach dubbed autoccag which leverages the effectiveness of automated configuration and automated selection techniques.
we perform extensive experiments demonstrating that autoccag performs significantly better than existing state of the art ccag algorithms for solving way and way ccag on real world instances.
ii.
p reliminaries in this section we first introduce combinatorial interaction testing and then survey automated algorithm optimization.
a. combinatorial interaction testing we introduce definitions and notations related to cit and formally describe the ccag problem.
a system under test sut the definition of a system under test sut also known as instance in this paper is a pairs p c where pis a collection of options and c is a collection of constraints on the permissible combinations of values of the options in p. for each option pi2p the set of feasible values is denoted as vi.
to formally define the ccag problem we need to introduce the definitions of tuple andtest case as described below.
b tuple given an sut s p c a tuple is a set of pairs denoted by f pi1 vi1 pi2 vi2 pit vit g which implies that option pij2ptakes the value vij2vij.
a tuple of size tis called at tuple.
c test case given an sut s p c a test case tc is a tuple that covers all options in p. in another word a test case is a complete assignment to p. in practice the options of most software systems are subject to hard constraints on the allowable combination of values.
since testing with invalid test cases would waste much testing time it is critical to guarantee that all generated test cases are valid.
given an sut s p c a tuple or test case is valid if and only if it does not violate any constraint in c. besides a tuple iscovered by test case tcif and only if tc that is the options in take the same values as the ones in tc.
since all necessary notations are defined we introduce the concept of constrained covering array cca and the formal formulation of the constrained covering array generation ccag problem as below.
d constrained covering array cca given an sut s p c at way constrained covering array cca s t is a set of valid test cases such that any valid t tuple is covered by at least one test case in cca wheretis called the covering strength of cca.
202e constrained covering array generation ccag given an sut s p c and a covering strength t the problem oft way constrained covering array generation ccag is to find at way cca of minimum size.
in practice meta heuristic algorithms can construct much smaller sized ccas than other types of algorithms.
among existing meta heuristic algorithms for ccag tca is considered as the representative and state of the art one.
tca is a typical local search ccag algorithm which starts from a partial cca as its initial solution and iteratively improves the current solution via making small modifications.
reported by the literature tca can produce ccas with much smaller sizes than existing approaches on extensive way and way ccag instances.
b. automated algorithm optimization techniques we first describe automated algorithm configuration and then introduce automated algorithm selection.
automated algorithm configuration actually many practical algorithms have hyper parameters whose settings considerably affect performance this especially holds for meta heuristic algorithms for solving combinatorial optimization problems .
the automated algorithm configuration also known as automated hyper parameter tuning technique is to address the following question given a configurable algorithm and a set of instances how to determine the optimized configuration also known as hyper parameter settings of the given algorithm for solving the given set of instances?
recently there has been a growing body of automated algorithm configuration for determining optimized hyper parameter settings .
automated configuration has been successful applied in various fields such as data mining automated machine learning and deep learning .
automated algorithm selection the automated algorithm selection technique is to address the following question when there exist a number of base algorithms aiming at solving the identical problem how to select the most suitable one?
considerable attentions have been paid to this question resulting in various promising approaches .
automated algorithm selection has shown its effectiveness in solving many np hard combinatorial problems such as boolean satisfiability maximum satisfiability answer set programming and constraint satisfaction problem .
iii.
t heautoccag approach in this section we propose a novel effective automated ccag approach called autoccag which leverages effective automated configuration and automated selection techniques.
a. top level design of autoccag the main idea of our proposed autoccag approach is to advance the state of the art in ccag solving through automated algorithm configuration and automated algorithm selection.
we first illustrate the top level design of autoccag in figure .
there are three key components in our autoccag approach configuration optimizer promising configuration generator configuration scheduling planner.
promising config.
setcfg1cfg2 cfgn... run target algorithm with scheduling plan constrained covering arrayscheduling plancfg1 cfg2 cfgn rmc cfg1 tmcrmc cfg2 tmc rmc cfgn tmc... training instances config.
scheduling plannercfg1config.
optimizer cfgn cfg2 promising config.
generator config.
optimizerconfig.
optimizerti ti ti ... marginal contribution calculationtarget algorithm instance to solvefig.
.
top level design of autoccag .
workflow of autoccag as illustrated in figure autoccag works as follows given a target configurable ccag algorithm a the configuration optimizer of autoccag utilizes automated configuration to determine the optimized configuration for a the promising configuration generator of autoccag aims to generate a set of promising configurations ofawith complementary strength the configuration scheduling planner of autoccag leverages automated selection to construct a scheduling plan for target ccag algorithm a. finally autoccag runs target ccag algorithm awith the generated scheduling plan to solve a given instance to produce the constrained covering array for that instance.
target ccag algorithm as discussed before we first need to decide the target ccag algorithm adopted by autoccag .
as reported in the literature and also observed in our experiments in tables i and ii tca can produce notably smaller sized ccas than other existing algorithms ont way ccag 26t65 .
also tca is a configurable algorithm and its original version has configurable hyperparameters.
one hyper parameter is boolean valued and has two possible values true orfalse .
another one is a positive integer hyper parameter.
the remaining one is a real valued hyper parameter ranging from to .
in fact a powerful paradigm called programming by optimization pbo which advocates practitioners to expand the design space of target algorithms has shown its effectiveness in improving meta heuristic algorithms for solving a variety of np hard problems e.g.
boolean satisfiability and minimum vertex cover .
inspired by the success of the pbo paradigm we expand the design space of tca through the pbo paradigm 203alg.
method boac for configuration optimizer input tb boac time budget for boac ti a collection of training instances a the target algorithm output cfg optimized configuration of a 1cfg the default configuration of a 2perf the average performance of awithcfg onti cfg perf cfg perf 4ml a gp model trained using sample cfg perf 5while time budget tb boac is not reached do sc a set of randomly sampled configurations of a ifwith a probability of half then cfg the configuration of awith the largest expected improvement assessed by ml from sc else cfg the configuration of awith the largest variance assessed by ml from sc perf the average performance of awithcfg onti ifperf is better than perf then cfg perf cfg perf ml is incrementally updated by adding a new sample cfg perf 14return cfg and thus make tca incorporate more configurable algorithm mechanisms.
for each of these newly incorporated configurable algorithm mechanisms one new boolean valued hyperparameter is introduced in tca to decide whether this new algorithm mechanism is activated.
hence autoccag utilizes the pbo based version of tca as its target ccag algorithm.
b. configuration optimizer since automatically configured algorithms have exhibited state of the art performance on a wide range of combinatorial problems it is advisable to design a configuration optimizer based on automated algorithm configuration in autoccag .
hence the first step is to investigate to what degree automated algorithm configuration is effective for ccag.
details of boac bayesian optimization bo is an effective framework for automatically tuning hyper parameters of configurable algorithms .
the bo framework constructs and updates a machine learning model to learn the effect of hyper parameter settings on target algorithm performance and iteratively determines a promising configuration via the constructed machine learning model.
an effective machine learning model for bo is gaussian process gp .
given a configuration of the target configurable algorithm gp can evaluate its potential benefit using expected improvement ei and assess its diversification property using variance .
based on the bo framework we propose a new method called boac bayesian optimization based automated configuration for our configuration optimizer.
boac utilizes gp as its machine learning model.
the boac method is outlined in alg.
and needs inputs the time budget for boac denoted by tb boac a collection of training instances denoted by ti the target algorithm to be configured denoted bya.
the output of boac is the optimized configuration of the target algorithm a denoted by cfg .boac works in an iterative manner until the time budget tb boac forboac is reached line in alg.
.
in each iteration boac obtains a new sample i.e.
a pairwise item consisting of a configuration chosen by gp denoted by cfg and the average performance of awithcfg across all training instances in ti denoted by perf lines and in alg.
.
after obtaining the new sample in each iteration boac s machine learning model mlwould be incrementally updated by adding a new sample cfg perf line in alg.
.
then we need to specify how boac chooses a promising configuration using gp in each iteration.
in each iteration boac first constructs a candidate configuration set sc where each candidate is randomly sampled from the whole configuration space line in alg.
.
then boac switches between the exploitation mode and the exploration mode to pick a promising configuration.
since it is important to balance exploitation and exploration in our work with a probability of half boac works in the exploitation mode it picks the configuration cfgwith the largest ei assessed by ml from sc line in alg.
otherwise boac works in the exploration mode it chooses the configuration cfg with the largest variance assessed by ml from sc line in alg.
.
since in each iteration boac s machine learning model ml would be incrementally updated by using a new sample the configuration determined by boac would become more effective with the number of iterations increases .
configuration protocol in this paper autoccag applies our proposed algorithm optimization method boac to conduct automated algorithm configuration.
for automated configuration we use one benchmark as the training set.
our boac method is utilized to minimize the size of the generated cca.
following the common setting of automated configuration we use a time budget of days for the configuration process of boac and a cutoff time of seconds per algorithm run during the configuration process ofboac .
once the configuration process is completed the configuration determined by boac is reported as the final outcome of our configuration process.
c. promising configuration generator in section iii b we introduce how to use configuration optimizer to determine the optimized configuration for an configurable algorithm on a given collection of training instances.
we note that the obtained optimized configuration shows the best average performance across all training instances however this does not mean that the obtained optimized configuration can achieve the best performance on each training instance.
in fact it is recognized that for the same configurable algorithm its various configurations show diverse performance when solving different instances .
hence it is advisable to generate a set of promising configurations with complementary strength and then use the automated selection technique to leverage the complementary strength of them.
1for the first iteration since the gp model ml has not been constructed the default configuration of aand the average performance of awith the default configuration are chosen lines and in alg.
.
204alg.
method pcg for promising configuration generator input ib pcg iteration budget for pcg tb boac time budget for boac ti a set of training instances a the target algorithm output pc a set of promising configurations of a 1pc ?
2while time budget ib pcg is not reached andti6 ?do cfg the optimized configuration of target algorithm aselected by boac using tb boac tias inputs pc pc fcfg g remove such instances where target algorithm awith configuration cfg can achieve or exceed best known cca sizes from ti 6return pc to address this challenge we propose a new method dubbed pcg which is a promising configuration generator to recommend a set of promising configurations with complementary strength.
our proposed pcg method is listed in alg.
and needs inputs ib pcg i.e.
the iteration budget for pcg following the practical standard in this paper ib pcg is set to tb boac i.e.
the time budget for boac ti i.e.
a collection of training instances a i.e.
the target algorithm.
the output of pcg is a set of promising configurations denoted by pc.
in the beginning pcg initializes pc as an empty set line in alg.
.
then pcg works in an iterative manner until one of the termination criteria is met.
as indicated in alg.
there are two termination criteria for pcg the iteration budget ib pcg is reached the training instance settibecomes empty.
in each iteration pcg first activates boac to determine the optimized configuration cfg using tb boac tiandaas inputs line in alg.
then pcg addscfg intopc line in alg.
.
at the end of each iteration pcg removes such instances where target algorithm awith the configuration cfg found in this iteration can achieve or exceed best known cca sizes2 from ti line in alg.
the main intuition is that in the subsequent iterations we only focus on those instances where the configurations already in pcshow moderate performance in order to better find those configurations with complementary strength.
in summary the main idea of pcg is to find such configurations which can achieve better performance on those instances where previously determined configurations show moderate performance.
as a result pcg is able to generate a set of promising configurations with complementary strength on all training instances.
d. configuration scheduling planner thanks to our proposed pcg method for a given ccag algorithma i.e.
tca in this paper we can obtain a set of promising configurations pcwith complementary strength on all training instances.
2for the best known cca size for each instance we collect the value from previous studies .it has been widely recognized that providing a scheduling plan consisting of a combination of different effective configurations is able to achieve significantly better results than just determining a single configuration .
the intuition is that running a scheduling plan would exploit the complementary strength among all configurations in this plan and could achieve more robust performance than just using a single configuration .
also the literature conducts extensive empirical study to demonstrate that for the boolean satisfiability sat problem which is a well known prototypical np hard combinatorial problem the effective configurations for solving the sat problem are usually not similar resulting in different clusters of effective configurations in the entire configuration space.
besides the literature demonstrates that there is a strong connection between the ccag problem and the sat problem the ccag problem can be encoded into the sat problem so it is possible that there might be different clusters of effective configurations for solving the ccag problem.
hence an advisable solution is to provide a scheduling plan which consists of a bunch of configurations with different time budgets rather than a single configuration with the whole time budget.
then we need to address the following challenge given a new instance and the cutoff time for solving the new instance how to select suitable configurations from pcand allocate suitable time budget for each selected configuration?
in order to address this challenge we propose a novel method named csp which is a configuration scheduling planner based on the automated selection technique.
marginal contribution before introducing the details of our csp method we introduce an important concept called marginal contribution which can measure the contribution of each configuration underlying the whole scheduling plan.
since the methods for computing marginal contribution for various problems are different we utilize a logarithmicbased method for computing marginal contribution in the context of ccag solving which is described as follows.
given a set of tca s promising configurations pc notation size pc denotes the performance i.e.
the averaged size of resulting ccas on all training instances achieved by an ideal configuration selector which leverages the complementary strengths of the tca s configurations in pc.
the absolute marginal contribution amc for each configuration b2pc is calculated below amc b lnsize pcnfbg size pc after obtaining the absolute marginal contribution for each configuration b2pc the relative marginal contribution rmc for each configuration b2pc is calculated below rmc b amc b p c2pcamc c details of csp our csp method is outlined in alg.
and provides a scheduling plan based on the marginal contribution calculation.
the time budget assigned to our csp method is the whole given cutoff time.
205alg.
method csp for configuration scheduling planner input tmc cutoff time for solving instance i pc a set of promising configurations of the target algorithm found by spc output listmc optimized configuration schedule plan 1listtmp 2foreach configuration b2pc do calculate rmc b according to equation listtmp.append 5sortlisttmpbyrmc in a descending order 6listmc 7foreach pairwise tuple inlisttmpdo listmc.append 9return listmc as described in alg.
the procedures of our csp method are described as follows for each configuration bunderlying the given set of promising configurations pc the relative marginal contribution for configuration b i.e.
rmc b is computed according to equation .
then all configurations are sorted by their rmc values in a descending order.
the scheduling plan generated in this stage consists of all configurations whose rmc values are greater than and the time budget allocated to each component algorithm is proportional to its rmc value.
finally through the above procedures csp constructs the final scheduling plan listmc.
after the final scheduling plan listmcis obtained our autoccag approach runs the target ccag algorithm with the final scheduling plan listmcto solve a given instance and thus generates the constrained covering array for that instance.
iv.
e xperimental design in this section we describe the experimental design of this work in detail.
in particular we first introduce the benchmarks used in the experiments.
then we present the research questions of this paper.
after that we describe the competitors.
finally we introduce the experimental setup.
a. benchmarks since the literature utilizes two benchmarks i.e.
real world andsynthetic to evaluate the performance oftca we therefore adopt these two benchmarks in our experiments.
both benchmarks are readily available online.
moreover we include an additional real world application benchmark entitled ibm into our experiments.
in our experiment a benchmark is a collection of ccag instances where each ccag instance consists of two files i.e.
the model file and the constraint file.
more details about benchmarks are available online3.
we briefly describe the real world ibm andsynthetic benchmarks below.
real world .
this benchmark includes real world instances and has been intensely studied in literature .
these instances are derived apache an influential open source web sever application bugzilla a widely used web based bug tracker gcc a well known compiler collection from the gnu community containing compilers and libraries for multiple programming languages spin s and spin v the simulator and verifiervariants of spin a widely used model checking tool.
this benchmark was first presented by cohen et al.
.
ibm.
this real application benchmark is comprised of practical instances originally introduced in the literature and is available online5.
these instances are generated aiming to provider better service for ibm customers and cover a broad range of real world application fields including health care insurance network management storage etc.
synthetic .
this benchmark contains synthetic instances that were generated to resemble the characteristics of real world software systems in real world .
these synthetic instances were originally described by cohen et al.
.
thesynthetic benchmark is used as the training set required by autoccag .
in this paper autoccag is trained by solving way ccag on all instances in the synthetic benchmark.
the real world andibm benchmarks are adopted as the testing set and are used to evaluate the practical performance of autoccag and other state of the art ccag algorithms.
due to the page limit we only list the results ofautoccag and its competitors for solving way and 5way ccag on real world and hardest instances in ibm in tables i iv.
the complete results of autoccag and its competitors for solving way and way ccag on all instances in the ibm benchmark are available online3 where the results on all instances in the real world andibm benchmarks for way and way ccag can be also found .
b. research questions to evaluate the effectiveness of autoccag we aim to answer the following research questions rqs .
in the context of ccag solving previous meta heuristic solvers can achieve good performance for way and way ccag but effectively solving way and way ccag still remains a challenge .
hence in this paper we focus on advancing the current state of the art in way and way ccag solving.
rq1 can the use of automated configuration improve the state of the art in way and way ccag solving?
in this rq we evaluate the efficacy of our proposed configuration optimizer boac for way and way ccag.
we would like to explore if the performance of the state ofthe art ccag algorithm tca can be improved through boac .
in particular we first utilize boac to find the optimized configuration for the original version of tca resulting in the original version of tca with the optimized configuration dubbed tca opt .
then we conduct experiments to demonstrate whether tca opt shows performance improvement over tca.
rq2 can automated selection be leveraged to improve the state of the art in way and way ccag solving?
ctdbenchmarks.zip 206table i comparing autoccag with tca opt tca casa and chip for way ccag on the re a l w o r l d andibm benchmarks .
the run time is measured in second .
instanceautoccag tca opt tca casa chip min avg time min avg time min avg time min avg time size time apache .
.
.
.
bugzilla .
.
.
.
.
.
.
.
gcc .
.
.
.
spin s .
.
.
.
.
.
.
.
spin v .
.
.
.
.
.
healthcare2 .
.
.
.
.
.
.
.
healthcare3 .
.
.
.
.
.
.
.
healthcare4 .
.
.
.
.
.
.
.
insurance .
.
.
.
.
.
.
.
networkmgmt .
.
.
.
.
.
.
.
processorcomm1 .
.
.
.
.
.
.
.
processorcomm2 .
.
.
.
.
.
.
.
services .
.
.
.
.
.
.
.
storage4 .
.
.
.
.
.
.
.
storage5 .
.
.
.
.
.
in this rq to study the effectiveness of automated selection we conduct comparisons between autoccag and tca opt .
actually tca opt which runs the original version of tca with a configuration selected by boac does not leverage the effectiveness of automated selection.
rq3 how does autoccag compare against state ofthe art algorithms for way and way ccag?
in this rq autoccag is compared against three state ofthe art ccag algorithms i.e.
tca casa and chip for solving way and way ccag.
rq4 can autoccag show state of the art performance for way and way ccag with a shorter cutoff time?
in this rq autoccag is evaluated to solve way and way ccag instances with a half of the cutoff time.
we compare the results of autoccag using a half of the cutoff time against the results of tca opt using the full cutoff time to demonstrate the efficiency of autoccag .
c. competitors in this paper autoccag is compared with state of the art ccag algorithms i.e.
tca casa and chip .
tca is a state of the art two mode meta heuristic algorithm.
reported in the literature tca outperforms a number of ccag algorithms including casa cascade andacts on many real world and synthetic instances.
casa is a high performance simulated annealing ccag algorithm6.
reported in the literature casa outperforms a greedy construction algorithm maetg on a number of real world and synthetic instances.
chip is a recently proposed effective hybrid parallel ccag algorithm which can use vast amount of parallelism provided by graphics processing units.
as reported in the literature and claimed by the authors of chip chip reports the first and state of the art results for solving way ccag on the real world andibm benchmarks.
note that hhsa is an effective ccag algorithm for way and way ccag.
since the implementation of hhsa available online7does not support solving t way ccag with t we do not include hhsa into our comparisons for 4way and way ccag.
the results of comparing autoccag with hhsa for way and way ccag are available online3 and autoccag can find smaller sized or equal sized ccas than hhsa on all instances for way and way ccag.
d. experimental setup all experiments in this paper were conducted on a computing server with .50ghz intel xeon e7 v3 cpu and .0tb memory running gnu linux.
because meta heuristic algorithms are usually randomized we performed independent runs per instance for each algorithm.
for solving way ccag the cutoff time of each algorithm run is set to cpu seconds following the experimental setup of tca .
since no ccag algorithm can report feasible solutions for way ccag on the apache and gcc instances within cpu seconds in our experiments the cutoff time of each algorithm run for solving way ccag on the apache and gcc instances is set to cpu seconds.
it is recognized that solving way ccag is much more difficult than solving way ccag and solving way ccag requires vast computing time .
thus for way ccag the cutoff time of each algorithm run is set to cpu seconds.
in our experiments especially in tables i iv for tca if there is no specific description it is evaluated using the original version with the default configuration.
for casa it is evaluated using the configuration recommended by its authors .
for chip we do not have the access to its source code and only its binary executable is available8.
we tried to run the binary executable of chip on all instances for solving 4way ccag using the cutoff time of seconds the same .jia projects cit hyperheuristic downloads comb linux 64.tar.gz 207table ii comparing autoccag with tca opt tca casa and chip for way ccag on the re a l w o r l d andibm benchmarks .
the run time is measured in second .
instanceautoccag tca opt tca casa chip min avg time min avg time min avg time min avg time size time apache bugzilla .
.
.
.
.
.
.
.
gcc spin s .
.
.
.
.
.
.
.
spin v .
.
.
.
healthcare2 .
.
.
.
.
.
.
.
healthcare3 .
.
.
.
.
.
.
.
healthcare4 .
.
.
.
.
.
.
.
insurance .
.
.
.
.
.
networkmgmt .
.
.
.
.
.
.
.
processorcomm1 .
.
.
.
.
.
.
.
processorcomm2 .
.
.
.
.
.
.
.
services .
.
.
.
.
.
.
.
storage4 .
.
.
.
.
.
.
.
storage5 .
.
.
.
.
.
cutoff time adopted by autoccag but in our experimental environment chip cannot report feasible solutions for almost all instances.
actually this is not surprising the experimental results in the literature report that for solving way ccag on the majority of instances chip requires more than tens of thousands and even more than hundreds of thousands of seconds and needs vast amount of parallelism provided by graphics processing units to obtain feasible solutions.
as a result the experimental results of chip for solving way ccag are taken from the literature .
also the binary executable of chip does not support solving t way ccag witht so in table ii we mark for the results of chip for solving way ccag.
for each algorithm on each instance we report the smallest size min and the averaged size avg of the cca found by the respective algorithm over runs.
in addition for each algorithm on each instance we report the running time time required for finding the optimized ccas averaged over runs and all running times were measured in cpu seconds.
if an algorithm failed to find a cca during all runs we report the results as .
in tables i iv for each instance we use boldface to indicate the best results with regard to cca size in our comparisons.
moreover in tables i iv for each instance we individually compare the performance of autoccag against that of each competitor we conduct wilcoxon signed rank tests to check the statistical significance of the results and calculate the vargha delaney effect sizes for each pairwise comparison between autoccag and each of its competitors.
for each instance if a all the p values of wilcoxon signed rank tests at confidence level are smaller than .
and b the varghadelaney effect sizes for all pairwise comparisons between autoccag and each of its competitors are greater than .
indicating large effect sizes we consider the performance improvement of autoccag over all its competitors statistically significant and meaningful and mark the results of autoccag using underline .
in table i the experimental resultsofchip are taken directly from the literature which were obtained by only performing one run of chip per instance.
therefore we do not conduct statistical test to compare the performance of our autoccag approach with that of chip .
for our boac method following the literature we adopt the ard mat rn kernel as its gp kernel and use the hyperparameter settings recommended in the literature .
v. e xperimental results in this section we report the experimental results to show both the effectiveness and the efficiency of autoccag .
a. rq1 performance improvement for way and way ccag by automated configuration we utilize boac to find the optimized configuration for the original version of tca resulting in tca opt i.e.
the original version of tca with the optimized configuration .
that is to say for solving a given ccag instance tca opt runs the original version of tca with the single optimized configuration.
the comparative results of tca opt andtca for way and way ccag on the real world andibm benchmarks are reported in tables i and ii respectively.
we note that the full results are available online.3as can be clearly seen from tables i and ii on both metrics of smallest size and averaged size the performance of tca opt is better than or equal to that of tca on all instances.
the experimental results in tables i and ii demonstrate that the state of the art in way and way ccag solving can be considerably advanced using automated configuration.
b. rq2 performance improvement for way and way ccag by automated selection the major difference between autoccag andtca opt is that autoccag runs the pbo based version of tca with a scheduling plan consisting of multiple high performing configurations of the pbo based version of tca while tcaoptruns the original version of tca with a single optimized 208table iii comparing autoccag with the cutoff time of seconds against tca opt with the cutoff time of seconds for way ccag on the re a l w o r l d andibm benchmarks .
the run time is measured in second .
instanceautoccag sec tca opt sec min avg time min avg time apache bugzilla .
.
.
.
gcc spin s .
.
.
.
spin v .
.
.
.
healthcare2 .
.
.
.
healthcare3 .
.
.
.
healthcare4 .
.
.
.
insurance .
.
.
.
networkmgmt .
.
.
.
processorcomm1 .
.
.
.
processorcomm2 .
.
.
.
services .
.
.
.
storage4 .
.
.
.
storage5 .
.
.
.
configuration.
hence tca opt does not leverage the effectiveness of automated selection.
the comparative results of autoccag and tca opt for way and way ccag on both real world andibm benchmarks are summarized in tables i and ii respectively.
according to tables i and ii the results present that when compared to tca opt our autoccag approach is able to consistently achieve better or equal performance on all instances in terms of the metrics of smallest size and averaged size .
the experimental results in tables i and ii provide evidence that automated selection can significantly push forward the state of the art in way and way ccag solving.
c. rq3 comparison among autoccag and state of the art ccag algorithms for way and way ccag related to this rq we conduct experiments on extensive real world applications instances to compare our autoccag approach against existing state of the art ccag algorithms in order to show the effectiveness of autoccag .
the experimental results of autoccag and its state of theart competitors i.e.
tca casa and chip for way and way ccag on the real world andibm benchmarks are presented in tables i and ii respectively.
it is clear that autoccag performs much better than all its competitors for solving way and way ccag on these two benchmarks.
for solving way ccag on the metric of smallest size autoccag performs much better than all its state of the art competitors on out of instances presented in table i for the remaining instance i.e.
networkmgmt autoccag tca and chip can find the cca with the same smallest size of besides casa performs worse than autoccag tca andchip on this instance but the run time required by autoccag .
sec is much less than tca .
sec and chip sec .
also on the metric of averaged size autoccag performs much better than all its state of the art competitors on all instances presented in table i.table iv comparing autoccag with the cutoff time of seconds against tca opt with the cutoff time of seconds for way ccag on the re a l w o r l d andibm benchmarks .
the run time is measured in second .
instanceautoccag sec tca opt sec min avg time min avg time apache bugzilla .
.
.
.
gcc spin s .
.
.
.
spin v .
.
.
.
healthcare2 .
.
.
.
healthcare3 .
.
.
.
healthcare4 .
.
.
.
insurance .
.
.
.
networkmgmt .
.
.
.
processorcomm1 .
.
.
.
processorcomm2 .
.
.
.
services .
.
.
.
storage4 .
.
.
.
storage5 .
.
.
.
for solving way ccag except two instances i.e.
apache and gcc where no ccag algorithm can report feasible solutions within the cutoff time on both metrics of smallest size and averaged size autoccag achieves much better performance than all its state of the art competitors on out of instances presented in table ii for the remaining instance i.e.
spin s autoccag andtca find the ccas with the smallest and averaged sizes of both besides casa performs worse than autoccag and tca on this instance but the run time required by autoccag .
sec is much less than tca .
sec .
the experimental results in tables i and ii provide evidence that our autoccag approach performs much better than all its competitors and dramatically pushes forward the state of the art in way and way ccag solving.
d. rq4 evaluating autoccag with a shorter cutoff time for way and way ccag in order to analyze the efficiency of autoccag we conduct more experiments to study the performance of autoccag with a shorter cutoff time for solving way and way ccag.
in the experiments related to this rq autoccag is evaluated to solve way and way ccag instances with a half of the standard cutoff time.
the results of autoccag with a half of the standard cutoff time i.e.
seconds for way ccag and seconds for way ccag and tca opt with the full cutoff time i.e.
seconds for way ccag and seconds for way ccag for solving way and way ccag on the real world andibm benchmarks are reported in tables iii and iv respectively.
from table iii for solving way ccag on both metrics of smallest size and averaged size autoccag achieves better or equal performance compared to tca opt on all instances.
also from table iv for solving way ccag on both metrics of smallest size and averaged size autoccag achieves better or equal performance 209compared to tca opt on all instances but two.
as shown in table ii for those two instances healthcare2 and networkmgmt in terms of smallest size and averaged size autoccag with the full cutoff time achieves better or equal performance compared to tca opt with the full cutoff time.
the experimental results in tables iii and iv provide evidence that autoccag with even a half of cutoff time can perform much better than tca opt with full cutoff time for solving way and way ccag which indicates that autoccag requires much less run time to perform better than tca opt on solving the majority of ccag instances.
e. threats to validity there are three potential threats to validity of our evaluation cutoff time a potential threat to validity in our experiments is the cutoff time we set for each algorithm for solving way ccag.
following the existing work we set the cutoff time to seconds.
according to the results reported in table i autoccag can find ccas for all instances except two apache and gcc which indicates that the cutoff time is reasonable.
nevertheless the cutoff time might not be long enough for all experiments.
to reduce this threat we conduct additional experiments to run autoccag and its competitors to solve apache and gcc with the cutoff time of seconds.
the results in table i show that autoccag is still able to take much less computation time to find much smallersized ccas compared to all competing ccag algorithms on these instances.
for solving way ccag the cutoff time for each algorithm run is set to cpu seconds as the way ccag problem is more challenging and requires more computations.
in our future work we will design methods for recommending optimal cutoff time for the ccag problem.
generalt way coverage although in this paper we only show the effectiveness of autoccag through experiments on way and way ccag in fact autoccag is able to deal with general t way ccag as well.
for example autoccag is able to deal with way and way ccag.
due to limited space we do not report our empirical results for way and way ccag in this paper but they are available online.
actually on the metrics of smallest size and averaged size the performance of autoccag is better than or equal to that of all its state of the art competitors i.e.
tca casa hhsa and chip on all instances in the real world andibm benchmarks for solving way and way ccag.
furthermore autoccag supports other coverage criteria such as 6way coverage.
we will evaluate the effectiveness of autoccag int way coverage t in our future work.
training set according to section iv a the training set used in our experiments is the synthetic benchmark which consists of instances and a potential threat to validity of our experiments is the small training set.
as introduced in section iii gp is the main machine learning model underlying autoccag and supports small training set .
besides a recent study shows that using a small training set can achieve the state of the art performance in solving the problemof minimum vertex cover a well known np hard combinatorial optimization problem.
furthermore as described in section iv a the synthetic benchmark resembles the real world benchmark and there is no explicit relationship between the synthetic benchmark and the ibm benchmark.
however according to tables i and ii autoccag trained on thesynthetic benchmark performs best on all instances in the ibm benchmark which covers extensive applications indicating the generality of autoccag .
vi.
r elated work combinatorial interaction testing cit is an important research topic in software engineering and has been well explored for the last two decades.
for the general information e.g.
theoretical work and practical achievement interested readers can refer to the book written by kuhn et al.
and the survey summarized by nie and leung .
practical algorithms for solving ccag can be classified into three main categories greedy algorithms meta heuristic algorithms and constraint encoding algorithms.
greedy algorithms can rapidly generate a cca in some scenarios where the metric of size is not the primary objective.
popular greedy algorithms can be categorized into two main classes onetest at a time otat algorithms and in parameter order ipo algorithms.
the well known algorithm aetg is the first one using the otat strategy .
bryce et al.
proposed a generic framework of the aetg like algorithm .
afterwards a number of variations of aetg were proposed .
the ipo algorithms extended horizontally and vertically to cover the tuples .
many variations of the ipo algorithms were also proposed e.g.
.
meta heuristic algorithms work in an iterative manner during the search process those algorithms aim at seeking a cca with a particular size k once ak sized cca is found then the algorithms will try to seek a cca with the size smaller than k. meta heuristic algorithms include tabu search simulated annealing genetic algorithm etc.
actually besides ccag meta heuristic algorithms have exhibited success in solving various np hard problems .
based on simulated annealing ccag algorithms garvin et al.
proposed the one sided narrowing and t set replacement techniques resulting in an influential ccag algorithm called casa which reduces runtime and finds smaller sized ccas.
jia et al.
proposed a ccag algorithm named hhsa which uses hyper heuristic search and dynamically applies different strategies during the search.
linet al.
proposed effective meta heuristic ccag algorithms dubbed tca and fastca which use tabu search to reduce the number of uncovered valid tuples in order to improve the performance for solving ccag.
recently mercan et al.
presented an effective parallel ccag algorithm called chip which can use vast amount of graphics processing units to implement the parallelism.
in addition there is another way to tackle this problem.
banbara et al.
and yamada et al.
encoded the ccag 210problem into the sat problem and then use powerful constraint solvers to handle the resulting sat encoded instance.
yamada et al.
proposed a constraint encoded algorithm called calot which shows effectiveness for solving way ccag.
more particularly it can prove the optimality for 2way ccag on a number of instances .
however solving t way ccag t still remains a challenge for constraintencoding algorithms.
vii.
c onclusion in this paper we propose a novel automated ccag approach dubbed autoccag which is able to leverage the powerful automated configuration and automated selection techniques for solving the challenging ccag problem.
extensive experiments on a broad range of real world instances demonstrate that our autoccag approach significantly outperforms its state of the art ccag competitors for solving way and way ccag on public real world application benchmarks.
also the performance of autoccag is better than or equal to that of all its state of the art ccag competitors for solving way and way ccag on these public benchmarks.
the testing benchmarks used in our experiments and the detailed experimental results including the experimental results of all ccag algorithms for solving way way 4way and way ccag on all testing instances are available at .