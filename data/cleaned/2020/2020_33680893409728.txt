block public access trust safety verification of access control policies malik bouchet amazon usabyron cook amazon usabryant cutler amazon usa anna druzkina amazon usaandrew gacek amazon usaliana hadarean amazon usa ranjit jhala amazon usabrad marshall amazon usadan peebles amazon usa neha rungta amazon usacole schlesinger amazon usachriss stephens amazon usa carsten varming amazon usaandy warfield amazon usa abstract data stored in cloud services is highly sensitive and so access to it is controlled via policies written in domain specific languages dsls .
the expressiveness of these dsls provides users flexibility to cover a wide variety of uses cases however unintended misconfigurations can lead to potential security issues.
we introduce block public access a tool that formally verifies policies to ensure that they only allow access to trusted principals i.e.that they prohibit access to the general public.
to this end we formalize the notion of trust safety that formally characterizes whether or not a policy allows unconstrained public access.
next we present a method to compile the policy down to a logical formula whose unsatisfiability can be checked by smt and ensures trust safety.
the constructs of the policy dsls render unsatisfiability checking pspace complete which precludes verifying the millions of requests per second seen at cloud scale.
hence we present an approach that leverages the structure of the policy dsl to compute a much smaller residual policy that corresponds only to untrusted accesses.
our approach allows block public access to in the common case syntactically verify trust safety without having to query the smt solver.
we have implemented block public access and present an evaluation showing how the above optimization yields a low latency policy verifier that the s3 team at aws has integrated into their authorization system where it is currently in production analyzing millions of policies everyday to ensure that client buckets do not grant unintended public access.
esec fse november virtual event usa copyright held by the owner author s .
acm isbn .
concepts security and privacy logic and verification access control.
keywords access policies cloud security smt formal methods cloud storage acm reference format malik bouchet byron cook bryant cutler anna druzkina andrew gacek liana hadarean ranjit jhala brad marshall dan peebles neha rungta cole schlesinger chriss stephens carsten varming and andy warfield.
.
block public access trust safety verification of access control policies.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa 11pages.
introduction in the cloud computing era clients ranging from banks to hospitals to commercial and government entities store and access their sensitive data via remote services managed by third party providers.
these clients elect to do so because centralized services are fast inexpensive reliable available and can scale up to serve the data to as many users as needed.
for example s3 is a high performance high availability cloud object storage service offered by aws that allows clients to create buckets within which they can store their data as s3 objects.
dsls for access control policies much of the client data stored in such services is highly sensitive and should only be accessible to the organizations to whom the data belongs.
even within those organizations there may be strict policies governing which set of principals should be granted or denied access to different kinds of data.
to this end services like s3 also provide their clients a domain specific language dsl in which the clients can precisely specify access control policies as per their own requirements.
as in many other settings the policy dsl was originally designed to grant a single user access to a specific resource but has over time evolved to support the myriad use cases that arise in large client corporations.
281this work is licensed under a creative commons attribution international .
license.
esec fse november virtual event usa bouchet et.
al.
allow principal arn aws iam role dev action s3 resource arn aws s3 my bucket allow principal notaction s3 deleteobject resource arn aws s3 my bucket figure misconfigured s3 access control policy.
for example instead of specifying just a single user the dsl has ways to describe sets of users and express hierarchical relationships between organizations groups roles and users .
similarly instead of describing just buckets there are primitives for describing the detailed structure of buckets organized as hierarchical directory structures.
who polices the policies?
the flexibility provided by the dsl is crucial to support the diverse use cases of different clients however unintentional misconfigurations can lead to potential security issues.
for example consider the policy in figure that is based on a real user policy adapted to s3 .
the policy consists of two statements.
the first statement allows a dev role to execute any s3 action on any object in the my bucket bucket.
the second statement allows all actions not equal to i.e.other than s3 deleteobject on any objects in the same bucket.
the client intended their policy to allow the dev role to perform any action except s3 deleteobject .
the result however was a policy that allows everyone to access data in the bucket as the second allow statement does not restrict access but instead gives access to all principals.
in this case the correct mechanism to restrict access as per the client s intent would be to change the allow in the second statement to a deny and the not equals action clause to an equals action .
while the policy dsl allows for compact specifications of expressive policies reasoning about the interaction between the semantics of different statements can be challenging to manually evaluate especially in large policies with multiple operators and conditions.
block public access in this paper we introduce block public access a tool that formally verifies policies to ensure that they only allow access to trusted principals i.e.that they prohibit access to the general public.
we develop block public access via the following contributions.
.
trust safety our first contribution is the notion of trust safety that formally characterizes whether or not a policy allows unconstrained public access .
the definition of trust safety varies on each use case which can have an implicit set of trusted entities outside of whom access should not be granted.
some policies may consider any access beyond a trusted part of the network to be public while others may wish to restrict access to certain individuals regardless of location.
at cloud scale manually inspecting or annotating policies to specify trusted entities is infeasible.
likewise asking clients to provide this set of trusted entities is not an option as it imposes a significant burden on users by requiring them to annotate legacy policies.
we address this problem by presenting analgorithm to infer the set of trusted entities from an access control policy .
.
semantic verification our second contribution is an algorithm to automatically verify whether a given policy is trust safe .
our algorithm builds on work that encodes the semantics of policies aslogical constraints that soundly and precisely characterize the sets of requests that are granted access by the policy .
we show how to compose this encoding with additional constraints that determine whether or not the policy is trust safe.
this allows us to compile the policy down to a single logical formula whose unsatisfiability determined by an smt solver implies that the policy is trust safe.
the rich policy language which allows conditions with wildcards ranging over user names ip addresses and sets of users roles and resources yields smt formulas that fall in the combined theories of strings regular expressions bitvectors and arithmetic.
checking the satisfiability of formulas over such theories is a pspace complete problem .
the formulas encoding real world policies are often large and complex making satisfiability solving slow.
.
syntactic trust safety verification any solution that prevents public access must be part of the authorization system itself and therefore has to be extremely fast.
for example s3 handles millions of requests per second all of which need to be checked to ensure they are not gaining access based on a misconfigured policy.
thus our third contribution is an approach that efficiently rewrites the formulas to eliminate all the rules that allow trusted access leaving behind a much smaller residual policy that corresponds only to untrusted accesses .
in the majority of cases the residual policy is trivial i.e.prohibits all untrusted accesses allowing us to verify trust safety without even querying the smt solver!
in the remaining cases the formula is drastically smaller thus enabling efficient smt based verification.
.
evaluation and deployment our final contribution is an implementation of block public access that ensures that all created and updated policies are trust safe .
our implementation ensures that untrusted public access to s3 buckets is not allowed anytime during the bucket s lifecycle.
to this end we introduce two additional checks in the authorization process one when attaching policies and one when requesting bucket access.
when a user tries to attach a new policy to a bucket e.g.the policy from figure s3 invokes block public access to check if the policy is trust safe.
if this is not the case s3 fails to attach the policy and returns a warning.
second when a user requests access to a bucket block public access uses a cache to determine whether the policy attached to the bucket was trust safe and if not the s3 authorization mechanism denies the request based on block public access s result.
thus to be integrated as a blocking check in the request path of the s3 service block public access s checks must have very low latency .
we present an evaluation that shows that the syntactic rewrite enables precisely such low latency verification without compromising soundness .
consequently the s3 team at aws has integrated block public access into their authorization system where it is currently in production enabling s3 to guard client buckets from unintended public access.
282block public access trust safety verification of access control policies esec fse november virtual event usa s3 access policies we begin with an overview of some of the features of the iam policy language that highlights the features that make checking trust safety challenging.
s3 is an object store where a logical unit of storage is called a bucket .
s3 stores data as objects in these buckets.
each resource e.g.the bucket and the objects in the bucket is uniquely identified by an amazon resource name arn .
access to s3 buckets and other aws resources is granted via identity access management system iam policies which are attached to the bucket or resource and are used to control access to the bucket and the objects in it.
request contexts when an access request is made to an aws service a request context is generated which includes the principal making the request the resource being requested and the action being invoked.
the request context also contains a set of servicespecific key value pairs that can be referenced in policy conditions.
the iam policy evaluation engine compares the request context with the policies for the user and the resource to determine if access is granted or denied.
s3 uses this evaluation engine to make sure only authorized requests are serviced.
the iam policy evaluation engine is called on all requests so it must only add a very small overhead.
for example the iam engine would allow the following request context under the policy in figure principal arn aws iam user malicious action s3 putobject resource arn aws s3 my bucket dir filename sourceip .
.
.
the aws policy language is expressed as serialized json and hence the request context can contain extra keys not present in the policy.
policies figure summarizes the core constructs of the aws policy language in a simplified abstract syntax.
a policy comprises a set ofallow anddeny statements that respectively grant or block access to sets of users.
a request is only granted access if the policy contains an allow statement that matches the request and does not contain any deny statements that match it regardless of the order in which the statements appear in the policy.
when writing example policies we will elide set brackets for singleton sets and elide the condition section when it is empty.
the policy language has grown to be flexible enough to support all current aws services as well as future ones and extensions.
this flexibility stems from two crucial features.
wildcards first allowing wildcards in the principal resource and action constructs.
wildcards can range over possibly unboundedly many values and hence let users concisely specify permissions at a fine level of granularity.
for example the user can refer to all s3 actions as s3 or use arn aws s3 my bucket .html to refer to all html files in a given bucket.
conditions second the condition construct over key value pairs allows specifying a set of logical conditions under which access is granted or denied.
conditional expressions are constructed using operators on key value pairs.
these operators can for example compare dates datelessthan check ip ranges ipaddress do case insensitive string matching stringequalsignorecase and alsomatch regular expressions stringlike over a set of candidate values.
if any of these values match the key the condition evaluates to true.
additionally the negation not quantification forallvalues and optional check ifexists qualifiers can suitably extend the operator s semantics.
reasoning about policies wildcards and conditionals which are the key to the flexibility of the policy language combine to make manually reasoning about policies challenging.
for example consider allow principal action s3 getobject resource arn aws s3 my bucket condition ipaddress sourceip .
.
.
stringnotlike sourceip .
?.
.
this policy will allow s3 getobject requests if the source ip address matches both conditions.
the source ip must be in the .
.
.
range but at the same time not match the .
?.
.
regular expression where ?
stands for any one character and for one or more arbitrary characters.
all ip addresses in this range will match the regular expression so this allow statement will deny all requests.
automatically inferring this fact requires combining bit vector constraint solving for the ipaddress a np complete problem with string constraints for stringnotlike an even harder pspace complete problem .
while this is obviously a crafted example large organizations often write complex policies hundreds of lines long that are similarly challenging to reason about.
service specific constraints to precisely analyze policies we need to also take into account constraints that are specific to differentservices using aws.
each service publishes the custom set of actions resource and condition key combinations they support.
certain condition keys are defined globally across all services e.g.
sourceip while other condition keys are service specific e.g.
s3 prefix .
there are currently global context keys and s3 has additional service specific context keys.
some keys are not always present some keys are only compatible with certain actions and some key combinations are not compatible.
for example the s3 prefix key only exists for s3 listbucket action requests and it limits the response of s3 listbucket to object key names with a specific prefix.
trust safety next let us formalize what it means for a policy to be trust safe i.e.whether the policy blocks all requests coming from untrusted entities.
specifically we delineate exactly what aspects of policies and requests are trusted and hence what constitutes an untrusted public access.
.
motivating examples recall that s3 is an object store where a logical unit of storage is called a bucket .
s3 stores data as objects in these buckets.
each resource e.g.the bucket and the objects in the bucket is uniquely identified by an amazon resource name arn .
the bucket policy which is attached to the bucket controls access to the bucket and the 283esec fse november virtual event usa bouchet et.
al.
policy statement statement effect principal action resource condition effect allow deny principal principal notprincipal string action action notaction string resource resource notresource string condition condition operator operator opname keyname value opname null stringequals stringequalsifexists forallvalues stringequals foranyvalue stringequals stringlike stringnotequals ipaddress .
.
.
keyname sourcevpc sourceip s3 prefix .
.
.
value string num bool figure core syntax of the aws policy language allow principal arn aws iam role dev arn aws iam role support action s3 getobject resource arn aws s3 my bucket allow principal action s3 getobject s3 putobject resource arn aws s3 my bucket condition stringequals username admin deny principal action s3 resource arn aws iam my bucket accounts condition stringnotequals sourcevpc vpc abcdef a policyp1is not trust safe allows untrusted access allow principal action s3 resource arn aws s3 my bucket deny principal action s3 resource arn aws s3 my bucket condition stringnotequals principalorgid o b policyp2is trust safe prohibits untrusted access figure example policies.
objects in it.
figure shows two example policies in the simplified abstract syntax for s3 that we will use to motivate our definition of trust safety.
example not trust safe consider policyp1from figure a .
the first statement allow gives bucket read access to the dev and support roles.
the second statement allow gives read and write access to all principals if the username is admin .
the final statement deny restricts access to my bucket accounts only to requests originating from the vpc abcdef virtual private cloud1.
this policy allows untrusted entities access to certain resources.
consider the following request context principal arn aws iam user admin action s3 getobject resource arn aws s3 my bucket secret filename username admin this request context will match the second allow statement.
while there is a restriction on the username there is no restriction on the account containing the username.
an adversary could create a user called admin in their own account and thus gain access to the bucket.
while the username key in the request is populated by the service from the user part of the principal identifier the value is controlled by the issuer of the request.
the username is not by itself sufficient to uniquely identify a request issuer.
note that the deny statement does not apply to this request context because the deny only applies to resources that match arn aws s3 mybucket accounts .
example trust safe the policyp2in figure b consists of one statement that allows any principal to execute any action on the bucket and another that denies all requests not originating from the o organization.
this policy does not allow public access because it only allows requests coming from the o organization.
the principalorgid is a unique identifier that cannot be duplicated or modified by the issuer of the request.
.
requests and policies we start by defining requests and access control policies.
keys and values letkdenote the set of all request context keys including global keys and s3 specific keys.
each key k k has a type type k associated with it representing the set of the values that can be associated with the key.
for example type sourceip ipaddress andtype s3 prefix string .
request contexts arequest context ris a set of key value pairs mapping keys to their values i.e.
r k val k k andval type k where principal action andresource are always present.
other request keys may be optionally present.
allowed requests letpbe a policy.
we write allow p to denote all the request contexts that are allowed by a given policy allow p rpolicypallows request context r .
trusted requests as the above examples illustrate in order to formalize trust safety we must answer the question given a request context comprising a set of key value pairs how do we know it is coming from a trusted 1virtual private clouds are a feature in most public cloud offerings that provides isolation between different parts of the cloud through a private ip subnet or vlan.
284block public access trust safety verification of access control policies esec fse november virtual event usa entity ?2not all request keys are created equal some of the key values can be controlled by the issuer of the request while others are populated by the service.
recall the request context from .
the values of the action and the s3 prefix keys are controlled by the issuer of the request they choose what action to call and how to configure it.
on the other hand the values of principal andsourceip are set by the service and are always the unique principal identifier of the request issuer and the request source ip respectively.
similarly in the above examples we assumed that the virtual private cloud vpc abcdef and the organization o are trusted and that requests that can be proven to come from these sources are safe.
thus intuitively the keys that cannot be altered by the user are considered trusted.
we will use this notion of trusted keys and their values to define trust safety.
trusted keys the trusted key set trkis a subset ofkcontaining the set of keys in a request context that cannot be altered by the issuer of the request.
examples of trusted keys in trkinclude sourcevpc sourceip anduserid .
the username key is not a trusted key because as we have seen in example above one can create a user with any name in a different account.
the set of trusted keys for a given service requires domain expertise but only needs to be determined once.
trusted values lettrv k be a given set of trusted values for key k where a trusted value corresponds to an entity the author of the policy trusts.
for policy p1in example the set of trusted values istrv sourcevpc vpc abcdef .
for policyp2in example the trusted value set is trv principalorgid o .
we will use these sets of trusted values to define a trusted context.
definition trusted request context .a request context ris trusted for a given set of trusted values trv k if there exists k val rsuch that k trkandval trv k and risuntrusted otherwise.
in other words if the request context contains at least one trusted key i.e.one that cannot be modified by the issuer of the request and the value associated with this key is trusted then the request is considered trusted.
definition trust safety .a policypis trust safe if there does not exist an untrusted request context r allow p .
that is a policy is trust safe if it only allows trusted requests or dually if it blocks all untrusted public accesses.
verifying trust safety next we will use the definition of trust safety to construct an smt formula that is unsatisfiable iff the policy is trust safe thereby yielding an algorithm to automatically verify whether a policy is trust safe.
we develop our algorithm in three steps.
first we build up a semantic representation of a policy i.e.a logical formula for which each satisfiable assignment represents an allowed request context.
second we assume that we are provided with a set of trusted entities and we show how to combine this set with the policy to obtain a logical formula that is unsatisfiable if and only if the policy is trust safe .
.
third we present our technique 2note that we assume the request is authenticated our goal is to ensure it is authorized to perform the requested action.s1 p arn aws iam role dev p arn aws iam role support a s3 getobject r arn aws s3 my bucket s2 a s3 putobject a s3 getobject r arn aws s3 my bucket username username admin s3 a s3 r arn aws s3 my bucket accounts sourcevpc sourcevpc vpc abcdef allow p1 s1 s2 s3 figure smt encoding of p1 forinferring a set of trusted entities automatically from the policy description which together with the logical encoding lets us use smt solvers to automatically determine whether a policy is trust safe.
.
a logical encoding of policy zelkova is an smt based checker for iam access control policies that can answer questions about policies by converting the policies into a logical representation and using smt solvers to answer queries about interesting properties of the policies.
for example zelkova can check whether one policy is more permissive than another.
block public access uses zelkova to generate an smt formula corresponding to allow p where satisfiable assignments are in one to one correspondence with request contexts r allow p .
figure resp.
figure shows the encoding corresponding to allow p1 resp.
allow p2 .
the encoding for each policy is a formula over the variables p a and rthat correspond to the principal action and resource in the request context.
in addition to these variables the encoding also introduces a variable for every condition key referenced in the policy.
in the above example these aresourcevpc username andprincipalorg .
because some condition keys are optional we introduce an additional boolean variable key which is true if the key is present in the context.
the set of all satisfying assignments of the formula corresponds to the set of all authorization contexts that will be allowed by the policy.
forp1 we have two allow statements s1ands2 and one deny statement s3.
the policy allows a request if either of the two allow statements match i.e.s1 s2is satisfied and the deny statement does not match s3 .
the policy is represented by the conjunction of the encoding of the allow statements and the negation of the deny statement.
thus the policy allows access for requests matching any of the allow statements but that do not match any of deny statements.3the encoding ofp2follows a similar pattern.
while we use zelkova for policy translation we do not use the public check mentioned in .
that check is not formally defined 3note that we are abusing notation to say a s3 since this in fact will correspond to a form of string matching rather than equality.
285esec fse november virtual event usa bouchet et.
al.
s1 a s3 r arn aws s3 my bucket s2 a s3 r arn aws s3 my bucket principalorg principalorg o allow p2 s1 s2 figure smt encoding of p2 and furthermore it was based on a fixed notion of public access not influenced by the policy under consideration.
instead we develop a logical encoding of trust safety that can be compared against the smt encoding of allow p .
.
a logical encoding of trust safety given a policyp a set of trusted keys trkand trusted values trvwe can check whether a policy is trust safe by constructing a verification condition vc a first order logic formula vc p trk trv allow p trust trk trv where allow p describes allrequest contexts allowed by p and trust trk trv describes trusted request contexts.
we can then use an smt solver to check the satisfiability of the formula .
a satisfying assignment corresponds to an untrusted public access that is allowed and hence we reject pas not trust safe.
instead if the formula is unsatisfiable we can be sure that all allowed requests are trusted and hence we can accept the policy as trust safe.
encoding the trusted requests given the sets of trusted keys trkand their trusted values trv we generate the following formula that corresponds to the set of all trusted request contexts.
trust trk trv k trk v trv k var k vark v where varkdenotes the variable in the smt encoding corresponding to key k. hence if the vc formula has any satisfying assignments then the policy allows untrusted public access and the satisfying assignment can be used to compute an example of an untrusted request that would be allowed by the policy and can be presented to the user as an explanation.
.
inferring trusted entities the above procedure relies on having a given set of trusted values for the trusted keys.
as discussed earlier .
the set of trusted keys can be determined once for each service.
hence we need only determine the trusted values for each key.
instead of relying on users to provide a specification of trusted values we must automatically infer the values that the user trusts.
we achieve this with a syntactic analysis on the structure of the policy.
extracting trusted values from policies trv key p denotes the set of trusted values that can be inferred from policy p. intuitively trv key p contains all the values of the keyin the policy that cannot match an overly large set of values for domain specific definitions of overly large.
this set is computed syntactically fromthe policy.
the following are examples of what we consider trusted key values for several keys trv sourcevpc p vv p is compared with sourcevpc and vand ?
v trv sourcearn p vv p is compared with sourcearn and account v and ?
account v for the sourcevpc key that stores the virtual private cloud identifier we only trust values that do not contain any wildcard symbols.
because private cloud identifiers are assigned nondeterministically any wildcard in this identifier will result in granting unintended access.
however other trusted identifiers may contain wildcards.
consider for example the amazon resource name arn that has the following structure arn partition service region account id type resource a wildcard in the region section of the arn is safe because a user may want to reference resources across multiple regions.
a wildcard in the account id section denoted by account v is not safe because account ids are nondeterministically assigned even a wildcard replacing just one digit would allow public access since the matched accounts are random.
coming up with the precise definition of trv key p for each key requires extensive domainspecific knowledge but it need only be created once to be used many times.
examples revisiting policyp1in figure a we infer the following set of trusted key value pairs principal arn aws iam role dev principal arn aws iam role support sourcevpc vpc abcdef note that the username admin key pair is not in the set of inferred keys because the username value can be controlled by the issuer of the request.
for the policy p2in figure b we infer just the following pair as a trusted value principalorgid o .
efficient verification given a policyp we can compute the set of trusted keys and values and then use those to compute a vc .
if the vc is resp.
not satisfiable then the policy allows resp.
prevents untrusted request contexts and hence is not resp.
is trust safe.
semantic trust elimination recall that the vc has two parts.
the formula allow p describes all allowed request context and the second conjunct trust trk trv stipulates that we exclude alltrusted requests.
intuitively the second conjunct semantically eliminates trusted requests from the vc forcing the smt solver to find a satisfying assignment that corresponds to an untrusted public access.
the wildcards and string comparisons that are crucial for making the policies flexible yield vcs whose satisfiability checking is pspace complete .
while smt solvers have sophisticated heuristics to efficiently solve string constraints in practice 286block public access trust safety verification of access control policies esec fse november virtual event usa the vcs generated in are quite large for real world policies and hence satisfiability checking is quite slow.
syntactic trust elimination our key observation is that instead of semantically eliminating trust using the smt solver we can exploit the structure of the policies to syntactically eliminate the trusted components from the policies in a sound manner.
this drastically shrinks the sizes of the policies and hence the vcs making verification efficient.
we implement syntactic trust elimination via a set of syntax directed rewrite rules that rewrite a policy pinto a new smallerp that allows strictly fewer requests thanp by denying some or all of p s trusted requests.
formally given an input policyp p0 we use a set of local rewrite rules to derive fromp0a sequence of increasingly restrictive policies p0 p1 .
.
.
pn where for each step i n allow pi allow pi and any request context r allow pi allow pi is a trusted request context.
when no further rewrites can be applied p pndoes not allow anytrusted request contexts but allows only theuntrusted requests allowed by p. thus ifp denies allrequests we can be sure thatpalsodenies all untrusted requests i.e.thatpis trust safe.
we can establish the last check that p denies all requests by comparingp to the trivial policy that denies all requests using zelkova s policy comparison engine.
our syntactic elimination procedure drastically shrinks the size of the vc in two ways.
first it yields a much slimmer p that excludes all the trusted elements of p. second it removes the need for the additional trust trk trv clause that semantically eliminates trusted keys and values.
together the rewrites make verification efficient as shown in .
rewriting strategy our rewriting rules implement the following high level strategy each rule removes trusted values from a positiveconditions in allow statements or b negative conditions in deny statements.
intuitively the former reduces the set of allowed requests by directly eliminating the conditions that allow those requests the latter amounts to removing exceptions to the deny statements thereby increases the set of requests that are explicitly denied.
note that the the transformed policy is not used in place of the original user supplied policy for the purpose of access control it is simply used to determine if the original policy is trust safe and then discarded.
rewriting policies recall from figure that a policy pis defined as a set of statements s1 .
.
.
sn .
we define our rewrite system via two sets of rules.
rules of the form opt s s rewrite the statement sinto s .
rules of the form opt s indicate the statement sis trivial and can be removed from the policy.
we write opt s for the result of repeatedly applying the rules until no further rules can be applied or we have derived .
the rules are syntax directed and hence deterministic making opt s welldefined.
thus we rewrite a policy as opt s1 .
.
.
sn s si.opt si s rewriting statements figure shows a subset of the rules for rewriting different statements.
recall from figure that each statement is a tuple of the form e p a r c where e allow deny is the effect pis the set of principals ais the set of actions ris the set of resources and cis the set of conditions under which the statement is matched.
the values of aandrare not used in ourrewrite rules so we elide them and write simply e p c .
we will also drop the literal condition in our presentation of the rules.
the derivation rules from figure remove trusted principals and trusted condition values from the policy.
principal matching rules the rule removes a trusted principal from the set of principals of an allow statement.
the rule can be read as given a statement allow principal p p c if the principal pis trusted then pcan be removed from the set of allowed principals resulting in the simplified statement allow principal p c the rule determines that allow statements with an empty principal list can be rewritten to i.e.deleted as they cannot match any requests.
condition matching rules opdenotes the condition operation such as stringlike orarnequals .notop denotes the negated condition operators such as stringnotlike orarnnotequals .
the rule removes trusted values that occur under a positive operator in the condition of an allow statement.
the resulting policy is more restrictive as it does not necessarily allow request contexts containing k v .
the removes trusted values that occur under a negative operator in the condition of a deny statement.
the intuition is that we are removing trusted exceptions to the deny statement therefore the resulting policy allows fewer request contexts.
removing trusted values can result in policies with an empty set of values.
the rule removes allow statements with an empty set of values under a positive condition because this condition and hence the entire statement could never match.
similarly empty values under a negative condition in a deny statement always evaluates to true and so we remove the condition.
key existence rules recall that if the condition operator contains theifexists suffix the rule matches if the key is not present in the context.
the trusted value elimination rules work the same as the regular operators but the operator elimination rule transforms the condition to match if the key is not present checked using the null operator .
correctness each rule for opt s preserves un satisfiability over untrusted requests i.e.modulo the assumption trust trk trv .
this leads to the following correctness result for our optimization theorem .pis trust safe iff opt p is trust safe example figure shows the policies obtained by rewriting the examples in figure .
for p1 this entails the following steps applying the rule twice until the principal set is empty then applying the rule to remove the allow statement and using the rule to remove all trusted exceptions to the deny for the sourcevpc key in the stringnotequals condition.
after the above no values remain in the deny condition and we apply the rule to remove the condition entirely.
this results in a derived policy that still allows untrusted requests from any admin user for resources in my bucket but not in 287esec fse november virtual event usa bouchet et.
al.
opt allow principal p p c allow principal p c ifp trv principal opt allow principal c opt allow p op k v v c allow p op k v c ifk trk v trv k opt allow p op k c opt deny p notop k v v c deny p notop k v c ifk trk v trv k opt deny p notop k c deny p c opt allow p opifex k v v c allow p opifex k v c ifk trk v trv k opt allow p opifex k c allow p null k true c figure sample rules for simplifying policies.
allow principal action s3 getobject s3 putobject resource arn aws s3 my bucket condition stringequals username admin deny principal action s3 resource arn aws s3 my bucket accounts a final policy derived from p1.
allow principal action s3 resource arn aws s3 my bucket deny principal action s3 resource arn aws s3 my bucket b final policy derived from p2.
figure final policies after applying derivation rules.
my bucket accounts e.g.requests like .
similarly we transform the policy in figure b by first removing the safe exceptions and then dropping the condition for the deny statement altogether.
the resulting deny statement unconditionally denies all requests as does the policy.
note that derivation rules for handling both allow anddeny statements are necessary.
consider simply using the syntactic check from trv k to ensure that every allow statement only allows syntactically trusted values.
by ignoring deny statements this approach would result in a false positive for the policy in figure b while the allow statement is very broad the deny statement crucially narrows down the set of allowed request contexts to only those coming from a specific organization.
implementation in this section we describe the overall system architecture and show howblock public access is integrated in s3.
this integration must satisfy the same operational requirements as the s3 service security durability availability and robustness.a key concept in a service such as s3 is the separation between the control plane and the data plane.
the control plane is responsible for configuring the service e.g.creating buckets setting the bucket policy and deleting buckets.
the data plane is responsible for the primary workload e.g.read and writing objects to buckets.
the data plane of s3 is used several orders of magnitude more often than the control plane.
in turn the latency requirements for the data plane are an order of magnitude more stringent than on the control plane.
block public access is designed to prohibit public access to both control and data plane operations.
while block public access is fast enough to be integrated into the control plane of s3 it is too slow and high variability for data plane integration.
to solve this the crucial insight is that block public access only needs to run its analysis in the control plane when policies are updated.
a cached result can be used in the data plane since block public access analysis decides if a policy is trust safe rather than deciding if individual requests are public or not.
the computational complexity of the problem still makes timeouts on pathological examples unavoidable.
to maintain soundness we choose to fail closed if the analysis result is unknown due to a time out we say the policy is not trust safe.
block public access provides two checks which can be enabled independently.
the first blocks any attempt to attach a policy that grant public access.
the second blocks access to existing buckets that already have a public policy.
while sometimes it is reasonable to allow public access for example sharing public data to ensure we are safe by default the recommendation is to enable both options.
figure shows simplified s3 authorization code with these two options.
the updatepolicy routine calls block public access to check if the policy allows public access.
if it does and the s3newpublic option is enabled then the policy is never attached.
otherwise the result of the block public access analysis is stored in the cache and the policy is attached to the bucket.
the auths3 authorization check uses this cached value to block access if the s3legacypublic option is enabled.
after retrieving the cached value we enhance the request context by adding a special key to the context s3 ispublic and mapping it to the cached value.
if thes3legacypublic option is enabled we create a lock down policy that will deny access if the original bucket policy was public.
the lock down policy has the following structure 288block public access trust safety verification of access control policies esec fse november virtual event usa boolean updatepolicy bucket bucket policy policy boolean ispublic blockpublicaccess.
checkpublicpolicy policy account account bucket.getaccount if ispublic account.s3newpublic return false policycache.store policy ispublic bucket.attachpolicy policy return true boolean auths3 bucket bucket request req if !iam.authenticate req return false policy policy bucket.getpolicy boolean ispublic policycache.get policy req.context.add s3 ispublic ispublic account account bucket.getaccount list policy policies new arraylist policies.add policy if account.s3legacypublic policies.add generatelockdownpolicy account return iam.evaluate policies req figure block public access integration in s3 authorization process.
deny notprincipal acccount action s3 resource condition boolifexists s3 ispublic true here account is the account owner of the bucket.
this policy will deny all requests for a public policy except from the owner s account.
using a lock down policy with an extra request context key ensures we do not have to modify the iam policy evaluation logic.
figure shows the system design when block public access is enabled.
s3 api calls that result in policy updates trigger a request to a fleet dedicated to running block public access .
the result is stored with the policy in the policy cache database.
all other requests consult this cache before delegating the authorization check to the iam authorization engine.
when a user issues a request req s3 uses the policy cache to augment the reqwith the information whether the bucket policy allows public access req .
if the block public access option is enabled it will also add a lock down policy p and then use the iam policy evaluation engine to determine whether access should be granted.
in this architecture s3 manages a high availability silo ed fleet of hosts dedicated to handling policy analysis requests.
this gives flexibility in throttling requests as needed.
one of the reasons for using a dedicated fleet as opposed to reusing the existing s3 infrastructure is that smt queries have a very different cpu profile compared to most s3 calls.
because smt solvers are cpu intensive using the same hosts to handle both s3 api calls and block public access requests would result in unacceptable slow downs.
a block public access specific s3 fleet is deployed for each region the service runs block public access fleets3 authpolicy cache aws identity and access managementupdatepolicy p p ispublic p ispublic auth response req p req userfigure system diagram for block public access integration in s3 request path.
in.
to ensure high availability fleets are spread over availability zones and designed to work even if one of availability zones goes down.
the fleet can be dynamically scaled to meet demand.
to be integrated in a high availability widely used service like s3 our block public access checks must meet the same operational bar as s3.
in addition to exhaustive testing we monitor the following metrics across all regions latency availability and throughput.
if any of these metrics are outside of predefined bounds an automatic system pages our on call engineer.
the policy encoding in zelkova on which block public access is based is designed to be robust to changes in the aws environment.
however sometimes we do need to update the encoding to support additional functionality.
one such example is the addition of new trusted context keys.
to avoid false positives zelkova s encoding needs to be updated with knowledge of the syntax and semantics of these keys.
due to backwards compatibility these upgrades should not affect the way existing policies are evaluated.
to ensure that our updates will not change the way existing policies are analyzed we have an exhaustive corpus of policies that we use to benchmark our zelkova analysis results.
before releasing the upgraded version of our zelkova checks we re analyze these policies to ensure there are no regressions.
the enhanced s3 authorization system described here helps customers secure their s3 buckets.
using block public access customers can override s3 permissions that allow public access making it easy for the account administrator to set up centralized control and prevent variation in security configuration regardless of how an object is added or a bucket is created.
by integrated policy analysis in the control plane and using cached results in the data plane s3 can use our block public access checks as a sound mechanism to prevent public access to s3 resources.
289esec fse november virtual event usa bouchet et.
al.
figure block public access runtime using direct and optimized algorithms.
evaluation finally we present an evaluation of the efficiency and precision of block public access .
efficiency to evaluate the improvement in the overall runtime of the policy analysis by our optimized syntactic algorithm we randomly selected 901real world policies and compared the results to the direct semantic approach.
the results are shown in figure .
each line in the graph is sorted to be monotonic i.e.the order of policies is different between the two lines and the graph does not directly compare the runtime of each policy.
there is an .
average speedup in runtime using the optimized algorithm.
the bulk of the optimized algorithm speedup comes from avoiding the smt solver.
this can be seen in figure as short vertical segments of the graph.
the optimized algorithm is able to solve .
of problems without even invoking the smt solver.
instead block public access detects that the generated smt formula is trivial i.e.it either asserts false or asserts a single atom both positively and negatively.
the direct algorithm produces only .
trivial smt problems by comparison.
among the policies there were 167problems that were non trivial for both approaches.
even across these non trivial problems the optimized approach produces an average .
reduction in smt problem size and a corresponding .
speedup.
precision we also evaluate the precision of block public access by measuring our rate of false positives when evaluating policies.
recall that to ensure that a public resource is never marked as non public we chose to fail closed if block public access times out on a request we say the policy is not trust safe.
false positives and unknowns could result in denied access for legitimate requests.
because we are solving a problem in the pspace complexity class it is inevitable that we will occasionally run into pathological examples that cannot be solved quickly.
from our 901sample policies we had zero unknowns.
from our own use of zelkova over the past three years we estimate the unknown rate to be approximately one unknown every two million policies.
additionally both internal and external feedback we have received indicates a similarly low rate of false positives.
related work we position block public access with respect to some lines of related work.
policy dsls policy languages have been used in a variety of domains including trust management distributed authorization rolebased access and access control of resources .
several policy languages are defined as datalog programs as datalog enables efficient verification of properties .
the trbac policy model uses concrete units of time to grant or revoke access .
this is accomplished in the aws policy language with conditions on date and time.
fisler et al.
define a policy formalism that consists of transitions between different states of the environment that determine access control in policies .
the access control model in aws also uses a policy and a dynamic environment request context to determine permissions but the environment does not evolve during a single access request.
the aws policy language is defined with respect to a json serialization and is designed to be used across various cloud services and scenarios of access control.
formal policy analysis the fireman system uses binary decision diagrams to analyze access control lists acl in firewall configurations.
the acl configuration language is more restricted than ours and the tool answers a fixed set of queries about which accesses packets are allowed.
hughes and bultan transform xacml policies into boolean satisfiability problems and use a sat solver to check partial orders between policies using a bounded analysis.
bounding the analyses however makes it unsound.
the margrave system encodes firewall policies as propositional logic formulas and uses sat engines to analyze policies.
finally the secguru tool compares network connectivity policies using the smt theory of bit vectors.
most similar to our approach is the work in which checks properties of aws access control policies by encoding their semantics in first order logic.
none of the above explores any notion like trust safety.
has heuristics to detect not prevent public access that are integrated in monitoring mechanisms like aws config and the s3 console that have relaxed latency requirements compared to the request path of s3.
in contrast block public access implements a run time preventative check that improves on the response time of by an order of magnitude which was achieved with an efficient algorithm based on policy rewriting.
moreover block public access ensures that no public access is ever allowed throughout the lifetime of the protected cloud resources.
finally the presentation in lacks any description of trust safety and any algorithm for checking it.
we provide a formal definition and a detailed algorithm describing how to check this property without requiring user input.
conclusion previous attempts at solving the problem of detecting misconfigured policies have relied on monitoring logs using machine learning to find suspicious access patterns or providing console warnings.
all of these techniques detect the problem after access to the bucket has already been granted.
in this work we developed a practical solution that prevents public access to s3 buckets due to misconfigured policies.
our solution is sound fully automated scales to 290block public access trust safety verification of access control policies esec fse november virtual event usa cloud scale request rates and handles all the intricacies of an industrial widely used access control policy language.
this solution is currently deployed as part of s3.
it analyzes millions of policies a day to prevent unintended public access.