this is a repository copy of a generative and mutational approach for synthesizing bugexposing test cases to guide compiler fuzzing .
white rose research online url for this paper version accepted version proceedings paper ye g. hu t. tang z. et al.
more authors a g enerative and mutational approach for synthesizing bug exposing test cases to guide compi ler fuzzing.
in proceedings of the 31st acm joint european software engine ering conference and symposium on the foundations of software engineering.
es ec fse the 31st acm joint european software engineering conference and symposium on t he foundations of software engineering dec san francisco usa.
association for computing machinery acm pp.
.
isbn copyright held by the owner author s .
this is an aut hor produced version of a conference paper accepted for publication in proceedings of esec fse made available under the terms of the creative commons attributio n license cc by which permits unrestricted use distribution and reproduction in a ny medium provided the original work is properly cited.
eprints whiterose.ac.uk reuse this article is distributed under the terms of the creat ive commons attribution cc by licence.
this licence allows you to distribute remix tweak and build upon t he work even commercially as long as you credit the authors for the original work.
more information and t he full terms of the licence here takedown if you consider content in white rose research online to b e in breach of uk law please notify us by emailing eprints whiterose.ac.uk including the url of th e record and the reason for the withdrawal request.
a generativeand mutationalapproachforsynthesizing bug exposingtestcasesto guide compiler fuzzing guixinye northwestuniversity china gxye nwu.edu.cntianmin hu northwestuniversity china hutianmin stumail.nwu.edu.cnzhanyongtang northwestuniversity china zytang nwu.edu.cn zhenye fan northwestuniversity china fanzhenye stumail.nwu.edu.cnshin hwei tan concordiauniversity canada shinhwei.tan concordia.cabozhang tencent inc. china cradminzhang tencent.com wenxiang qian tencent inc. china saplasqian tencent.comzheng wang universityof leeds unitedkingdom z.wang5 leeds.ac.uk abstract randomtestcasegeneration or fuzzing isaviablemeansforuncovering compiler bugs.
unfortunately compiler fuzzing can be time consuming and inefficient with purely randomly generated testcasesduetothecomplexityofmoderncompilers.wepresent comfuzz afocusedcompilerfuzzingframework.
comfuzz aimsto improve compiler fuzzing efficiency by focusing on testing componentsandlanguagefeaturesthatarelikelytotriggercompilerbugs.
our key insight is human developers tend to make common and repeaterrorsacrosscompilerimplementations hence wecanleveragethepreviouslyreportedbuggy exposingtestcasesofaprogramming language to test a new compiler implementation.
to this end comfuzz employs deep learning to learn a test program generator from open source projects hosted on github.
with the machinegenerated test programs in place comfuzz then leverages a set ofcarefullydesignedmutationrulestoimprovethecoverageand bug exposingcapabilitiesofthetestcases.weevaluate comfuzz on11compilersfor jsandjavaprogramminglanguages.within 260hoursofautomatedtestingruns wediscovered33uniquebugs across nine compilers of which have been confirmed and includinganapidocumentationdefect havealreadybeenfixedby thedevelopers.wealsocompared comfuzz toeightpriorfuzzers onfourevaluationmetrics.ina24 hourcomparativetest comfuzz uncoversatleast .
morebugsthanthestate of the artbaselines.
ccs concepts software and its engineering software testing and debugging compilers computing methodologies artificial intelligence .
z.tang is the corresponding author.
g.yeand t. hu areco first authors.
esec fse december 3 9 san francisco ca usa copyright heldby the owner author s .
publicationrightslicensed to acm.
thisistheauthor sversionofthework.itispostedhereforyourpersonaluse.not for redistribution.
the definitive version of record was published in proceedings of the31stacmjointeuropeansoftwareengineeringconferenceandsymposiumonthe foundations of software engineering esec fse december 3 9 san francisco ca usa fuzzing historicalbug guidedtesting deep learning compiler acmreference format guixinye tianminhu zhanyongtang zhenyefan shinhweitan bo zhang wenxiang qian and zheng wang.
.
a generative and mutationalapproachforsynthesizingbug exposingtestcasestoguidecompiler fuzzing.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december 3 9 san francisco ca usa.
acm new york ny usa 13pages.
introduction compilersplayakeyroleinsoftwaredevelopment .mostapplication developerstreatcompilersas blackboxesandhaveto trust thecompiler generatedcode.however moderncompilersareintricate software systems with large codebases consisting of hundreds of thousandsoflines andlike manylarge scalesoftwareprojects compiler bugs are inevitable and often manifest in the deployment environment .unfortunately detectingcompilerbugscanbe challenging yettheirpresencecansignificantlyimpedesoftware development leading to runtime crashes and even catastrophic consequenceswhen applicationsare deployed .
automatedtestcodegenerationtechnique orfuzzing hasbeen awell establishedandeffectivewaytodetectcompilerbugs .
compiler fuzzing techniques include generation based and mutation based methods which are typically usedwithdifferentialtesting .thisisachievedbyexecuting a randomly generated test program on multiple compiler test beds andobservingtheoutputsofthecompilerandexecutablebinary.an anomalous behavior like compiler crashing freezing compilation timeout orabinaryexecutionresultthatdeviatesfromthemajority ofthe outputs indicates apotentialcompilerbug.
a fundamental challenge for fuzzing techniques is generating test cases that can quickly expose buggy behaviors .
existingapproachestypicallyemployagenerationormutation based approach.
generation based techniquesconstructtestcasesbyusing either manually designed grammar rules generation templates or by restructuring code snippets extracted from a program seeds pool .
in contrast mutation driven techniques leverage pre designed rules to synthesize test cases .esec fse december3 san francisco ca usa g.ye t. hu z.tang z.fan s.tan b.zhang w. qian andz.wang thesefuzzingtechniqueshaveprovenuseful however theyhave afundamentallimitationwhenappliedtocompilerswithalarge codebase.thesetechniquesoftenrelyonrandomtestgenerationto achievecoverage whichisunlikelytobeeffectiveduetotheuneven distributionofsoftwarebugsacrosscomponents .inpractice it iscommonforafewmodulestoaccountformostbugs .consequently arandomtestgenerationapproachmaydisproportionately allocatetestingeffortstomoduleslessprone tobugs.therefore a more efficient and effective strategy for compiler fuzzing should directfuzzing efforts toward modules more likely tocontain bugs.
byfocusingonthesespecificmodules wecanmaximizetheimpact ofourtestingeffortsandincreasethechancesofuncoveringcritical vulnerabilitieswithin agiven test time budget.
wepresent comfuzz anewcompilerfuzzingframeworkthat combinesgenerativeandmutationaltechniqueswhileimproving thecompilertestingefficiency.unlikepreviousapproachesthatrely on random test case generation for achieving coverage which is challenginginthecontextofcompilertesting comfuzz isspecificallydesignedtotargetcompilercomponentsthataremore likelytocontainbugs.toachievethis comfuzz leverageshistorical testprogramsobtainedfromproofs of concept pocs ofcommon vulnerabilities and exposures cves and compiler test suites.
our generative approach is motivated by two key observations bugs areprevalentinasmallfractionofcodewithinsoftware and the fixing of historicaldefectsoften introduces new bugs .
insteadofsolelyusinghistoricaltestcasesasseedprogramswitha random mutation strategy to test compilercomponents uniformly comfuzz conducts intensive fuzzing tests on modules that have previouslyexhibitedbugs.thesetargetedmodulesareknowntobe error prone andcan potentiallycontain bugsintroducedbyfixes.
to reduce the developer s efforts in building the test program generator we harness the potential of deep learning based generative techniques .particularly we employatransformer based model toinferfeaturesandconstructsofthetargetprogramminglanguage.tocreatetestinputs programsinourcase weuse the historical code as seed input for our trained model which then producesnewtestprograms.sincetheseprogramsarederivedfrom bug exposingtestcases theyareapttoembodyspecificfeatures like standard library calls or language constructs while exhibiting new behaviors introduced by the program generator.
therefore these generated programs can effectively guide the fuzzing efforts towardtestingthe error prone componentsofthe compiler.
our approach is among the recent efforts of synthesizing test programs by reassembling the code ingredients extracted from the historicaltestcases .however existingapproachesfailedto conducthigh intensitytestingforabuggycompilercomponentdue to the randomness of the assembled test cases.
our key conceptual insight is that there can be residual bugs in previously buggy modules andwecanleverageasetofbug guidedmutatorstofindthese residual bugs.
for example to find residual api misuse bugs we definedsim a mutatorthat replaces the original api with another similarapitoexposemoreresidualbugs.duringeachtestingiteration abug guidedmutatorisselectedtomutateatestprogramthat has been shown to expose anomalous compiler behaviors.
we also designed five general purpose mutators to improve the diversity of the generated test cases.
we use general purpose mutators tocreatenewtestcodesincaseswherethedevelopedtestprograms fail to expose bugsorcannotimprove the code coverage.
weevaluated comfuzz on11javascript js andjavacompilers.
in260hoursofautomatedtestingruns comfuzz reportedatotalof 33uniquebugsacrossninetestedcompilers covering26previously unknown bugs.
of the submitted bugs have been confirmed and22bugs includinganopenj9documentbug havebeenfixed by developers.
our extensive evaluations show that comfuzz is highlyeffectiveingeneratingbug exposingtestcases.comparedto eightstate of the art sota fuzzers comfuzz uncovers at least .
more bugsthanprior methods.
in summary this paper makes the following contributions we propose a new compiler fuzzing technique by combining the historical test programs and bug guided mutators which can quickly cover the defective compiler components and achieve focusedintensive testing we present an extensible test generation scheme that can be easilyportedtotestcompilersforotherprogramminglanguages weevaluatedtheeffectivenessof comfuzz bycomparingitwith sotafuzzersthatutilizehistoricaltestcasesforsoftwaretesting.
backgroundand motivation .
compiler testingandchallenges prior work for compiler testing includes generation based andmutation guided methods.whilepromising priormethodsstill sufferfrom the followingtwochallenges how to generate bug exposing test cases that can quickly cover the defective component of a compiler?
although many methods havebeendevotedtogenerating validtestcases all of them are randomly generated so that they fail to quickly locatethebuggycomponentsofacompilerduringtheearlytesting phase.
furthermore a recent study stated that bugs in software do not conform to a uniform distribution and only of code will have bugs .
this means randomly synthesized test cases in prior work may be wasting most of the time testing the benign compiler modules.
even if a test case triggers a compiler bug prior work cannot continuously test the buggy compiler module in adjacent iterative tests which is bound to decrease testing efficiency.
thus anotherchallengeis howtoconductfocusedandhigh intensive testing for a buggy compiler component in adjacent testing iterations.
recent studies indicate that one major cause of bugs is the incomplete or incorrect repair of historical bugs .
meanwhile bugsthatarethesameorsimilartothehistoricalonesoftenarise during software evolution .
furthermore recent work hasshownthatusinghistoricaltestprogramsasseedtestprograms canimprovefuzzingefficiency .inspiredbythese studies we derived two key intuitions historical test programs e.g.
testsuitesorpocs canbeusedtogeneratebug exposingtests for quickly covering buggy compiler components and buggy compilercomponentscanbecontinuouslyandintensivelytested by mutating the generated bug exposing tests.
these intuitions helpto addressthe twochallenges above andmotivate our work.
unlike prior work our work aims to balance reusing existing codefragmentsfromhistoricalprogramsandexploringnewprogramstatestoidentifybugs.thekeyquestionsare howtoobtain high quality seeds and how to leverage historical programs fora generative andmutationalapproachforsynthesizingbug exposing testcases to guide compilerfuzzing esec fse december3 san francisco ca usa 1public class jvmtest comfuzz generated args via bug guided mutators static int i static int limit static int arr int test2 int i int limit int arr comfuzz generated code segment via dl model while i !
if arr limit break return arr public static void main string args throws exception newjvmtest.test2 i limit arr figure a comfuzz generated test case obtained from a historical testcaseandexposed anew bugofopenj9.
exploring new program states.
our approach differs from other dl based methods by reusing historical tests as the model seed input for test program generation.
we extract randomly cut out code blocks to create a high quality initial pool of seed programs.
we thencombineagenerationmodelwithcarefullydesignedmutators to explore newprogram states andexpose bugs.
.
motivationexample figure shows a bug exposing test case generated by comfuzz during iterative testing which uncovers a new performance bug of openj9.forthistestcase openj9failstoenablejitoptimizationfor themainloopinlines8 10.specifically this while loop appearsat the entry of the test2function.
it has a walk.bytecodepcoffset of in openj9 which disables the jit optimization of openj9 leadingtosignificantperformancedegradation.specifically openj9 takes over seconds to execute the test program while other jvm engines like hotspot take milliseconds.
this performance bug wasfixedbythe openj9 developers.
comfuzz generatesthisbug exposingtestprogrambysetting theappropriatevariables lines3 5 tomanifesttheperformance bug.thesevariablesaregeneratedusingourbug guidedmutator whereas the code block test2function in lines 6 11 is created from ahistoricalbug exposing test case .
comfuzz achieves this by first building a dl based program generator.then thelearnedgeneratorisappliedtoproducenew test cases by taking as input a randomly chosen seed generation header e.g.
line .
unlike prior work our seed generation headers are extracted from the historical test programs e.g.
jdk test suites and pocs collected from cve.
our goal is to focus on compiler components that are likely to contain bugs.
the bug triggeringvariables e.g.
limit atline4 arecriticalfor manifesting this performance bug as using a small value makes theperformancedifferencenegligible.togeneratesuchvariables we study the historical test cases to design boun one of our five bug guided mutators.
finally comfuzz assembles the generated program thebug triggeringvariabledeclarationstatements and thenecessarystartupfunctionintoacomplete executabletestcase.
.
automatedprogramgeneration the rapid advances in deep learning dl promote the automated programmodelingmethods whichhavebeenwidely usedinprogram relatedtasks suchascodeoptimization programgeneration andvulnerabilitydetection .since no expert knowledge is required many dl based compiler fuzzershave been proposed for automated test program generation .
newer approaches subsequently employ more powerfulneuralnetworkstofurtherimprovethecorrectnessofthe generatedtestcases.inspiredbypriorwork weuseanadvanced neuralnetworktomodelprograms aimingtoautomaticallygenerate test cases.
unlike existing dl based fuzzers that randomly createtestcases wefeedhistoricaltestsintothemodeltogenerate bug exposing test cases achievingabetterbug exposing ability.
ourapproach figure provides comfuzz overview which uses historical programsandbug guidedmutatorsforfocusedcompilertesting.tothis end weestablish atest programgenerator based ona pre trained model section3.
.thebuiltgeneratorisusedtogeneratebugexposingtestcasesbyfeedingitwiththehistoricaltestprograms section .
.
the generated test cases are applied to test target compilersthroughdifferentialtesting section3.
whichkeepsthe interesting testcasesthatdiscovernewcompilerbranchesortrigger inconsistentdifferentialoutcomesand apply them to focused and guidedtests using bug guidedmutators section .
.
.
programgenerator construction most existing compiler testing approaches utilize domain specific languagemodels e.g.
grammarortemplate basedgenerators to generatetestprograms.thesemethodsrequireexpertknowledgeto designthe grammaticalrulesor the generationtemplates making these approaches hard to extend for new programming languages.
instead our program generator is built upon a transformer based model which is easy to generalize to other programming languages byfeeding itwiththe target training samples.
data collection and preprocessing.
since our program generator is built by fine tuning a pre trained model the fine tuning process requires massive training samples.
to collect enough samples we respectively scraped the top 10k open source jsandjava projects ranked by stars hosted on github.
for each project we extracted function level code snippets as training samples.
specifically ourapproachfirstremovesallcomments.then weextractthe function level code segments from the programs using parsers i.e.
esprima forjsand javaparser forjava .
toimprove the correctnessofextractedcodesnippets wealsoextracttheexpected globalvariablesandinsertthemintothebodyofthecodesegments.
finally we utilize syntax analysistools e.g.
jshint forjsand javacompiler forjava to ensure the syntax correctness of the code segments andstore theminacodebase.
language model.
our language model is constructed based on a transformer basedneuralnetwork .itisessentiallyanencoderdecodernaturallanguagegenerationmodelwithamulti headattentionmechanism.boththeencoderanddecoderarecomposed of a stack of six identical blocks.
specifically an encoder block consists of a multi head self attention layer and a position wise fully connected feed forward layer.
a decoder block consists of an encoderblockandamulti head attentionlayer.
for eachnetwork layer we employ aresidual connection andanormalization layer.
fine tuning.
thepre trainedmodelisrefinedusingcollectedtraining programs.
during the fine tuning phase we encode each trainingsampleasasuitablevectorforinputintoneuralnetworks.toesec fse december3 san francisco ca usa g.ye t. hu z.tang z.fan s.tan b.zhang w. qian andz.wang codesource train trainingsamples programgeneratortc 39test262 test suites testcaseshistorical testprogramsseedspool generation headers targetcompilers v8 jsc chakra...javascript java hotspotopenj9 graalvm ...filteringduplicate miscompilations potentialbugcodecoveragemutation rules bug guidedmutating newtestcases generatenext iterative testing figure overview of comfuzz which combineshistorical testcasesandbug guided mutatorsforfocused intensive fuzzing.
do so we employ byte pair encoding bpe a subword based tokenization algorithm.
bpe constructs a vocabulary dictionary by iterativelymergingthemostfrequentpairsofcharactersorcharactersequencesinagivencorpusintosubwords.thisprocessensures that each vocabulary item is represented as a subword based on its frequency in the training set.
using bpe we create a vocabulary that captures common subword units in the corpus.
when processing a trainingsample we map eachsubwordto an integer byreferencing the vocabulary dictionary.thismapping allowsus totransformthetrainingsample i.e.
acodesnippetinthiswork intoasequenceofintegers.bycollectingalltheintegervaluesassociatedwiththesubwordsinthesample weobtainarepresentation vector that effectivelyencodes the sample sinformation.
givenaninputtingvector v whichisfirstfedintothepre trained modeltoobtaintheactivationvalueofthelasttransformerblock bm l.then itispassedthroughaclassificationlayertopredictthe nexttoken.
the processcan be representedas follows p y v1 ... vm softmax bm lwy wheresoftmax representstheclassificationlayer yisthepredicted token and wyistheweightmatrix.sincethepre trainedmodelhas billions of parameters the former layers are language independent features.
thus the fine tuning process only trains the last few layers.this isdone byupdatingthe weightsofthe lastfew layers while keeping others unchanged during fine tuning.
the objective isto maximizethe following function l v ylogp y v1 ... vm toacceleratemodelconvergence wefine tunedourlanguage modelusingtheadamoptimizer for200epochs.re training took around hours using three nvidia gtx 3080ti gpus whichwasaone offcost.thehyperparametersweusedinclude temperature .
response length top p andothersaredefault.oncetrained ourlanguagemodelcancontinuously generatetest programs byfeeding the seedgenerationheaders.
.
testcasegeneration figure shows that a test case contains three ingredients a mainfunction lines 12 13 a test program lines 6 11 and its arguments lines .
we synthesized test programs by feeding the generationheadersintoarefinedlanguagemodel.
generation header extraction.
we feed the generation model withaseedcodeinput generationheader extractedfromahistorical test program e.g.
int test2 int i int limit int arr in figure .
as the seed input determines the starting point ofatestprogram agoodgenerationheaderplaysanimportantrolein generating bug exposing programs.
to obtain high quality generation headers we first collected as many historical test programs aspossible.for java wecollectedthehistoricaltestprogramsfrom the test suites of hotspot openj9 kona and graalvm.
for js we obtainedthetestprogramsfromtest anofficialjavascript languageconformancetestsuite.allpocsarecollectedfromthe cve database.
we then extract all function level code blocks for each gathered historical test program by parsing it into an ast.
thegenerationheadersareextractedbyrandomlycuttingoffthe former lines of the function level code block.
note that we also collect 20k ordinary generation headers that are extracted from open sourceprojectsforeachprogramminglanguageinorderto increasethe diversityofgeneratedtest cases.
test program generation.
the test program is synthesized by feedingthegenerationmodelwitharandomlychosenseedgeneration header.
during testing the generation model first randomly selectsagenerationheaderfromtheseedpool anditthenyieldsthe probabilisticvector ofthenext token e.g.
a subword based token encoded by bpe .
differ from natural language generation tasks that output the token with the highest probability we employ a markov chain monte carlo mcmc algorithm a probabilistic sampling scheme where a token with a higher prediction probability is more likely to be chosen to sample the next token.
this processcanimprovethediversityofthegeneratedtestprograms.
next thegeneratedtokenisappendedtotheoriginalgeneration header which is fed to the generation network to produce the next token repeatedly.
this synthesized process terminates when the generationnetwork produces thetermination symbol eof or a bracket that indicates the end of a program method or exceeds the maximum token length .here issetto be .
argumentsgeneration.
incompilertesting ahigh qualitytest casenotonlycontainsabug exposingtestprogrambutalsocontainstheargumentsexpectedbythetestprogram.tosynthesizethe desired arguments we designed several heuristic rules for all basic datatypes e.g.
integer double string array object etc.for java the variable type is determined according to the parameter type forjs theargumenttypesareinferredusinganexistingwork .
.
differential testing weemploytheestablisheddifferentialtestingmechanism to expose compiler bugs.
a majority voting scheme is utilized to capturetheanomalouscompilerbehaviorswhichareyieldedbythe minoritycompilers.theanomalouscompilationsneedtobefurther confirmedmanually after filtering duplicatemiscompilations.
anomalouscompilerbehaviors.
acompilertypicallyconsists of three components a parser that checks if a program is correctlya generative andmutationalapproachforsynthesizingbug exposing testcases to guide compilerfuzzing esec fse december3 san francisco ca usa atestcase parsing phaseall compilers parsed?noparsing error optimization phaseall compilers passed?yesnooptimization error yesexecution phase successful?yespass nowrong result exception timeout crash figure possible outcomes of differential testing.
an anomalous behavior deviating from most compiler outcomes indicates a potential bug.
our current do not consider wrong result and timeout at the parsing and optimization stages because it is hard to establish an oracle for the intermediate results and attribute timeout to intermediate compilation stages respectively.
coded without syntax and semantic errors an optimizer that aims at optimizing code at a high level intermediate representation ir andagenerator alsoknownasbackend whichisresponsiblefor translatingtheirintobinarycode.thus theincorrectimplementation of any of the aforementioned three components may produce an anomalous behavior indicating a possible compiler bug.
this happens when the outcome for a given test input compiled using a compiler differs from the outcome from most of the tested compilersforthesameinput e.g.
wrongresult exception timeout and crash.
these anomalies can manifest at various stages including parsing optimizing and runtime.
however comfuzz does not detect wrongresults and timeout attheparsingandoptimization stages because the intermediate outcome during parsing and optimization istypicallyimplementation dependent and it is hard to attribute compilation timeout to individual stages since we treatthetestedcompilerasablackbox.figure3showssevenpotential outcomes when executing a test case.
all outcomes except for the pass represent anomalous behaviors that necessitate subsequent manual analysis.
a pass outcome signifies that all tested compilersyieldidenticaloutcomeswithoutanyabnormalbehavior.
as this outcome aligns withthe expectedresult itisdisregarded.
suppose the test case does not trigger any anomalous outcomes during the parsing and optimization phases the compilerbackend proceeds to translate the optimized code into machine instructions tobeexecutedonthetestedplatform.however whenexecutingthe compiled binary there are potentialscenarios where fourdistinct anomalousbehaviors mayarise duringruntime.
firstly a wrong result occurswhenthebinaryproducesanoutputthatdeviates from the outputs generated by most tested compilers.
this discrepancyindicatesaninconsistencyorerrorwithinthecompiledbinary.
secondly an exception is encounteredwhenthe execution of the binary results in a thrown exception while the execution given byothercompilersdoesnotexhibitthisbehavior.thispointstowards an exception handling flaw.
thirdly a timeout occurs if a program fails to terminate within the specified time limit while binariesgeneratedbyothercompilersterminatebeforethetimelimit.
this usually indicates an optimization bug leading to prolonged executiontimes.lastly a crash canmanifestifthebinaryitself orthe compiler e.g.
forinterpret execution mode crashes during execution.this occurrence suggestsapotentialcompilerbug.
identifying anomalousbehaviors.
among sixtypes of anomalous behaviors crashandtimeoutare of immediate interest indicating the erroneous compiler implementation.
following the practices in prior work we set the timeout threshold for runtime execution to seconds.
we consider an erroneous behavioroccurswhenanybinarygivenbyacompilerhasanexecution time exceeding seconds whereas binaries generated by otherexception in thread main java.lang.stringindexoutofboundsexception string index out of range at java.lang.abstractstringbuilder.deletecharat abstractstringbuilder.java at java.lang.stringbuilder.deletecharat stringbuilder.java ...... exception in thread main java.lang.
stringindexoutofboundsexception index length at java.base java.lang.string.checkindex string.java at java.base java.lang.
abstractstringbuilder.deletecharat abstractstringbuilder.java at java.base java.lang.stringbuilder.deletecharat stringbuilder.java ......hotspot openj9 figure4 differentiatedanomalousbehaviorsthathotspot andopenj9 threw which indicatethe same jvmexception.
compilers for the same input complete their execution within seconds.inourevaluation wedonotencounteranyfalsepositives whenusingthisthreshold sowedonotfinditbeneficialtoincrease the threshold.
for the other four anomalous behaviors a majority votingschemeisappliedtoidentifyifacompilercontainspotential defeatsbycomparing the compilation andexecutionresults.
since all compilers may not have the same error or exception messages directlycomparingtheiroutcomescanresultinahigh false positive rate.
figure shows one of such examples where bothhotspotandopenj9threwan out of bounds exceptionwith thesamelanguagesemanticsbutdifferentmessages highlighted with a dark background .
if we were to compare the contents directly thiswouldmistakenlybecategorizedastwodistincttypesof differential behavior.
we propose using a key information extractor to minimize false positives.
the extractor first eliminates compilerspecificimplementations suchasthelocationorvariable related information from the stack trace generated by the target compilers.
it then extracts the essential information such as the exception typeandaffectedapis highlightedinboldredfontinfigure4 and storestheminanunorderedlistforeachcompileroutput.listswith the same elements indicate the same anomalous compiler behavior.
inaddition theextractedkeyinformationisalsousedtofilter outduplicatemis compilations.specifically weextendedthetreebasedclassifierproposedbycomfort tobuildourfilter.unlike comfort whichconsistsofthreedecisionlayers ouraugmented filteraddsanewlayeratthesecondlayerofcomfort.thedecision nodes in the new layer correspond to standard exit codes also known as return codes that are returned by the operating system.
.
mutation forfocusedtesting test case mutation is a powerful way to improve code coverage.
priormutationalapproaches randomlychoosepre designed operators to mutate the interesting test cases incurring extraordinarily costly and time consuming testing.
this is because the random mutants fail to focus on testing a specific compiler componentinsuccessivefuzzing.todoso wedesignedseveralbug guided mutators to generate new bug exposing test cases by mutating the interesting test casethat has triggeredthe anomalousbehaviors.esec fse december3 san francisco ca usa g.ye t. hu z.tang z.fan s.tan b.zhang w. qian andz.wang algorithm1 mutatorschedulingpolicy input tprog atest programneeded to bemutated om thecollectionofbug guided mutators gm thecollectionofgeneral purpose mutators output pnew alist thatstores the mutated test programs letom sim vul insl snip boun letgm repo genp conf insc del letpnew mbethe empty lists tast parsingtoast tprog iftprogis an interesting test case then m identifymutators tast om else m identifymutators tast gm end if m selectcandidatemutators m tnew mutation tprog m pnew.append tnew returnpnew mutationoperators.
wedesignedtenkindsofmutationoperators includingfivebug guidedandfivegeneral purposemutators.all ourmutatorscanbefoundat .toobtainasetofbug guidedmutatorsforfindingresidualbugs werefertotheexistingliteratureon frequently occurringbugs .thisleadstofivebug guided mutatorsrepresentingfivecommonclassesofbugs i.e.
apimisuse security performance incomplete bug fixes and missing boundary check .thebug guidedmutatorsaimtoproducenewbug exposing test programs based on interesting test cases for focused testing whereas the general purposemutators are applied to improve the diversity of the mutant programs to avoid convergence during the testingprocess.we describe bug guidedmutatorsbelow similar api replacement sim replace an original api call with one that has similar semantics or the same return values.
this mutatorisinspiredbyprior work onapi misuse .
vulnerability rules vul mutate the target test case with vulnerabilityrulesmanually designedaccording to pocs.
insertloopstatement insl insertloopstatement e.g.
for while into the target test program.
this is motivated by a prior empirical study onperformance issues .
snippet replacement snip replace a basic code block with astructurally similarone.thisisinspiredbypriorwork that observedthatmorethan95 ofcodefragmentsoverlapbetween the historicaltest programs dueto incompletebugfixes.
boundaryvalues boun generateboundaryvalues e.g.
oxff null for arguments passedto the function calls.
given an interesting test case mutator simis responsible for replacing an existing api with a new one with similar functions or the same types of return values.
for example the javafunctionlastindexof string str will be replaced with the similar method lastindexof string str int fromindex .
such mutation is able to reach deeper code branches of the method lastindexof and continuously test the string class ofjvm.
forthejslanguage therearealsomanysimilar semanticfunction calls suchas string v.s.tostring .similarapisareautomaticallycollectedusingascripttoparsethelanguagespecificationdocument.vulaimsat mutatingthetest casebyusing pre designedvulnerability patterns.
specifically we implemented three patterns thatcoverthreetypesofvulnerabilities includingcwe cwe915 andcwe .wechosethembecausetheyarethetop 3most severevulnerabilities wecounttheseveritybycalculatingthenumberofrelevantcveslabeledashighorcriticaltothetotalnumberofcves .thefirstpatternisaboutprototypepollutionvulnerability whichisachievedbymodifyingtheprototypechainattributes through proto orobject.setprototypeof and declaring a newobjectaccordingly.thesecondpatternisrelatedtotheremote code execution vulnerability which applies the getter setter or definegetter and definesetter to modify the attributesofthetargetobjects.thethirdpatternabouttypeconfusion vulnerabilityreplacesafunctioncallwithmultiplecalls meanwhile changingtheobjecttype.thetestcasesthatconformtoanyoneof the vulnerability rules will be mutated.
we would like to note that theabovetwomutators simandvularelanguage specific and they need to mutate the interesting test cases according to the program context of a specific programminglanguage.
this we think is inevitable due to the nature of different programming languages.
insloperator inserts the loop statement e.g.
fororwhile into the test case to enrich the control dependencies of the mutant program.
this operator creates a hot code region to activate the just in timecompilationmoduleoftestedcompilersforexploring the performance issue.
the snipoperator replaces a basic code block in the original test program with a similar one.
to do so we firstextractthecodeblocksfromgatheredprograms andeachcode blockisacompletefragment e.g.
ifstatements thatisrecorded with ablock assembly constraint which is represented as a tuple pre constraint post constraint .differfrompre postcondition in hoare logic thepre constraint marks its required variables or statements and the post constraint labels the return values that are required to be defined to execute the code block without a runtime error.
the collected code blocks with theirblock assembly constraint are stored in a json file.
the snip operatorwillfirstselectthecodeblockswithexpected blockassembly constraint from the json file and then randomly selects a code block to replace the original one.
this aims to cover deep branches for tested components.
the last operator bounis to generate the boundary values for the test case.
for the java test program we defined boundary values such as nan null 0xfff and undefined etc.
which are from the historical test cases that exposedcompilerdefectsorvulnerabilities.forthe jsprogram we utilize comfort to generate the boundary values according to the ecma 262specification.this operationcancontinuously test an api andcover its deeper code branches.
to increase the diversity of the test cases we also designed five general purposemutationoperators.theyaredescribedasfollows replace operator repo randomly replace a binary or a unaryoperatorwithanothercorrespondingone.e.g.
replace with orreplace with .
generate parameters genp randomly generate parameters withprimary andreference types.
change control flow conf change the control flow by replacing aconditional statement e.g.
replace ifwithswitch.
insertconditionalstatement insc insertconditionalstatements e.g.
if...else intothe originaltest case.a generative andmutationalapproachforsynthesizingbug exposing testcases to guide compilerfuzzing esec fse december3 san francisco ca usa table target compilerswe have tested.
category compilers versions buildno.
releasedate v8 v9.
.
8a05d7a dec. v1.
.
a75335b dec.2020chakracorev1.
.
.
beta 418a27c jun.
spidermonkey c96.
fd8da16 jan. javascriptcore v286936 dec. graaljs v21.
.
ede7e2b oct. jerryscript v3.
.
6fe763f1 sep. hermes v0.
.
7d3e091 aug. 2022js quickjs v2021 b5e6289 mar.
v8u332 b02 1e4e4ae feb. 2022openj9v11.
.
c902226 feb. v8.
.
e1f6c13 feb. 2022hotspotv11.
.
b8cdf1a jan. 2022jvm graalvm v22.
.
.
bd6570e jan. total deletecodesnippet del randomlydeleteabasiccodeblock from the originaltest case.
thegeneral purposemutatorschangethedataandcontroldependencies that significantly deviate from the original programs to guide towards testing more uncovered compiler components.
specifically mutators repoandgenpchangethedatadependencies while confandinscalter the control dependencies.
the mutatordelcan changeboth the data andcontroldependencies.
mutatorscheduling policy.
algorithm1 presentsour mutation scheduler.theschedulertakesinthemutatorsandthetestprogram required to be mutated producing a list of new mutated test cases.
givenatestprogram tprog ourschedulerfirstdeterminesifitisan interesting test program.
here the interesting test programs refer to those that have ever triggered anomalous compiler behaviors or discoveredthenewbranchesofthetestedcompilers.ourinsight isusing both codecoverageandanomalous compiler behaviorsas guidance can help to discover more new code branches.
if tprogis aninteresting test case the scheduler then identifies which bugguided mutators are suitable for mutating lines 5 6 otherwise theappositegeneral purposemutatorswillbechosen lines7 8 .
todetermine m wefirstparse tprogintoanast line4 andsearch thepotentialmutationpositionsbytraversingtheparsedast.a mutation position essentially refers to an ast node whose context programconformsto the patternofanyofourtenmutators.for example the test2function in figure expects two parameters of typeinteger which can be generated by the bug guided mutator boun.
note that the mutator determination process may produce multiplemutators.
the schedulerwillrandomlychoosenomore thanm.maxmutatorstogeneratenewtestprograms lines10 12 .
experimentalsetup target compilers.
we apply comfuzz to testjsandjvmcompilers.
table lists the tested compilers and the versions used.
specifically we apply comfuzz to 8jsand 3jvmcompilers using their latest trunk branches.
in total we have tested target compiler versionconfigurations.table statistics forexposed bugspertargetcompiler.
compiler submitted confirmed fixedof conf.
chakracore spidermonkey graaljs jerryscript hermes quickjs openj9 hotspot graalvm total competitivebaselines.
wechooseeightpriormethods covering bothgeneration andmutation based fuzzersfor compilertesting.
specifically wecompare comfuzz withfourfinegenerativefuzzers comfort andpolyglot forthejsengine javatailor andjattack thelatesttwotestprogramsynthesizersfor jvm testing.wealsocompare comfuzz withfourmutationalfuzzers codealchemist die and montage forjsengines as they represent the sota methods andclassming for jvm.
implementation and evaluation platforms.
our program generator is built upon a transformer architecture in pytorch v1.
.
.
our mutators are implemented in jsandjava.
the differential testing engine is written in python.
our evaluation platform isamulti coreserverwitha3.6ghz8 core 16threads intelcorei7 cpu four nvidia gtx 3080ti gpus and 64gb of ram running ubuntu .
operating system with linux kernel .
.
all dnn models run onthe native hardware using gpus.
experimentalresults .
bug summary thissubsectionexhibitsthenumberofidentifiedbugsandpresents their various summary statistics for the purpose of evaluating the ability of comfuzz to discover previously unknown bugs.
the experiment started with testing jsengines first in november and then extending our testing framework to jvmin april .
the total testing time is about hours on approximately 400k test cases for jsand 200k test cases for javathat are generated from around 20khistoricaltest programs.
numberofbugs.
table2givesthedistributionofthe comfuzz exposedbugsaccordingtothetestedcompilers.
comfuzz discovered bugsinall the tested compilers exceptfor v8 andjavascriptcore.
among the confirmed bugs we found a total of three unique bugsexposedbythesametestcases.listing3showsoneofthese bugs.
this implies that bugs are prevalent in different compilers.
overall as of february we have reported unique bugs.
to date bugs have been confirmed of which have been fixed by the developers.
for the remaining four reported jsbugs two bugs were rejected due to the special design of the compiler the other two bugs are waiting to be verified.
in addition to the above fourbugs threemorebugsweresilentlyfixedinthebetaversion of the tested compilers after submitting our bug reports.
in total comfuzz exposed26outof33bugsthatwerepreviouslyunknown.esec fse december3 san francisco ca usa g.ye t. hu z.tang z.fan s.tan b.zhang w. qian andz.wang js jvm total0 confirmed bugs tested compilers parser optimizer backend figure confirmed bugspercompiler component.
it is worth mentioning that for openj9 comfuzz found bugs farmorethanthenumberofbugsexposedinothercompilers.this is mainlybecauseopenj9 introduces many optimizationschemes thatarepronetodefectsduetoincorrectimplementation.herefive such bugswere foundby comfuzz inthe optimizerofopenj9.
affected compiler components.
as discussed in section .
a compiler is composed of a parser an optimizer and a backend.
each of the three components inevitably has defects due to wrong implementations.
to assess how comfuzz performs in covering thesethreecomponents wegroupedthe comfuzz discoveredbugs into three categories parser optimizer andbackend according to the phase where the bug is caused.
figure gives the number of confirmed bugs discovered by comfuzz for each component.
notethattheopenj9documentbug seelisting4 isexcludedfrom figure .
for jsengines comfuzz exposed around 4 5 bugs in the three components indicating that bugs are prevalent in different components of a compiler.
for jvm the most error prone componentis optimizer whichhasexposed6bugs followedby thebackend andparser.overall bugsin optimizer areprevalent 6jvmand 4jsbugs belong to this group.
according to the developers feedback this isoftendue toerroneousimplementationof the optimization schemes.
this is in line with the current research trend that mainstream compiler vendors are striving to enhance the optimization level anddepth.
.
ablation study recallthat comfuzz consistsofthreecomponents ageneration model that leveragesthe historical test programs see section .
the bug guided or general purpose mutators that mutate interestingtestcases seesection3.
.toillustratehowtheyperform inbug exposingcapability weevaluatetheireffectsin comfuzz with an ablation study.
in comfuzz m andcomfuzz a we removedthemutationandgenerationpartandkeptothermodules unchanged respectively.
likewise in comfuzz g andcomfuzz p we respectively remove the general purpose mutators and bugguidedmutatorsandkeepothercomponents.wecompared comfuzzwith all four variants with a test time budget of hours.
all thevariantsareevaluatedusingthesameseedprogramstoavoid the test biascausedbythe randomnessofthe test casegenerator.
figure6reportsthenumberofbugsdiscoveredbyeachimplementation variant.
comfuzz m discovered four bugs for jsand fivebugsfor jvm respectively.thisconfirmsthatourgeneration modeliseffectiveingeneratingbug exposingtestcases.furthermore comfuzz a respectively exposed five and six bugs for js andjvm indicatingtheeffectivenessofourmutationstrategyalone.
by augmenting the generation model with bug guided mutators comfuzz g improves comfuzz m by exposing four more bugs.
likewise comparing comfuzz p withcomfuzz m wecanseethat withgeneral purposemutators comfuzz p discoveredtwomore js jvm total comfirmed bugs tested compilers comfuzz comfuzz m comfuzz g comfuzz p comfuzz a figure confirmed bugsfoundby comfuzz variants.
bugs suggesting a better bug exposing capability.
this indicates the usefulness of our bug guided and general purpose mutators in augmentingourgenerationmodelforexposingcompilerbugs.the ablationstudy alsoshowsthat comparedtoitsvariants comfuzz achievesthebestperformancebygivingatleast .
improvements in bug detection.
this indicates the effectiveness of comfuzz in combining the generative andmutational techniques.
.
bug examples comfuzz is capable of finding diverse kinds of bugs on tested compilersaccordingtothehistoricaltestprogramsandbug guided mutators.toprovideaconvincingglimpseofthediversityofthe exposed bugs we give four comfuzz generated test cases that expose the jsandjvmcompilerbugs.
1public class jvmtest 2public static void main string args throws exception stringbuilder sb newstringbuilder sb .
append j sb .
deletecharat system .
out .
println sb .
tostring listing openj9 for jdk fails to throw an outofbound exceptionforthistestcode.
openj9parserbug.
thebug exposingtestcodeinlisting1isa program that throws an outofbounds exception because it deletes anelementthatdoesnotexistatline5.whenexecutingthistest code openj9forjdk8failstothrowanexception.therootcauseis thatopenj9incorrectlyreturnstheboundaryvaluewhencallingthe innerfunction stringbuilder delete int start int end .
thisbug exposingtestcodeismutatedviaourbug guidedmutator sim see section .
by replacing the delete function with the deletecharat function.
this bug was quickly confirmed and addedto the repairlistfor the nextrelease version.
1public class jvmtest static void foo integer i do return while i public static void main string args foo listing hotspot for jdk throws an assertionerror exceptionwhile thecodeis correct.
hotspot backend bug.
the tested hotspot for jdk threw an assertionerrorexception whenexecutingthetest caseshownin listing .as thetest codeis syntacticallycorrect hotspotshould compile the code successfully and transform the test code into a bytecode.therootcauseofthisbugisthatthehotspotbackend incorrectlymapsflat do...while loopstatementsintothebytecode.a generative andmutationalapproachforsynthesizingbug exposing testcases to guide compilerfuzzing esec fse december3 san francisco ca usa comfuzz producesthisbug exposingtestprogrambyapplyingthe bug guidedmutator insltoinsertthe do...while loopstatement into the body of the foofunction at lines .
the bug has been confirmedandassignedfor repair.
1varfoo function t1 t1 .
sort function a b return a b print t1 5varparameter1 foo parameter1 listing ittriggers an optimizer bugofspidermonkey.
spidermonkey optimizer bug.
this test program in listing containsa sortfunctionthatinvokesaninlinecomparisonfunction atline2 whichissynthesizedviareplacingtheoriginalbodyof thefoofunction with sortfunction call1by using our bug guided mutatorsnip section3.
.thecorrectoutputsofthistestprogram shouldbe a b becausethe jsspecification ecma 262statesthat thesortfunctionshouldreturntheoriginalarray t1 hereis a b whenthevalueofthestatement a bintheinlinecomparison function equals nan.
while spidermonkey yields b a the wrong results.
the root cause is that spidermonkey misused a specific optimizationschemeforthecomparisonfunctioninsteadofactually callingthecomparatorfunction leadingtoanincorrectresult.this bug is immediately verified and classified as p1priority the most urgent level that should be fixed soon as bugzilla states.
moreover asimilar test casealsoexposedaconfirmedbugofjerryscript.
1public class jvmtest 2boolean testlatin1 try stringbuilder sb newstringbuilder system .
out .
println sb .
capacity sb .
ensurecapacity integer .max value catch outofmemoryerror oom oom.
printstacktrace return true 10public static void main string args throws exception newjvmtest .
testlatin1 listing the test program that revealed the incomplete documentation probleminopenj9.
incompleteopenj9documentation.
thecomfuzz generated testprogrampresentedinlisting4triggeredananomalousbehavior ofopenj9forjdk11 i.e.
catchingan oomexception .suchbehavior is expected because the xx compactstrings option responsible for causing this exception is disabled by default in openj9 for jdk while it is enabled in hotsopt and openj9 for jdk .
during the manual analysis we found that the openj9 documentation had nodescription forthisoption.wehave reportedthisdefecttothe developer anditwasfixedquicklyafter reporting.
.
evaluationofdifferential testing toquantifytheroleofourdifferentialtestingmodule wecountthe numberofconfirmedbugsexposedby comfuzz anddividethem intoeither crash bugsthatleadtoaruntimecrash or inconsistency 1thesortfunction is originated from the link .table3 thenumberof comfuzz uncoveredbugsfoundby execution crashesordifferentialtesting.
compilers crash inconsistency ratio of inconsis.
js .
jvm .
total .
percentage testing time hours fpr fnr a js b jvm percentage testing time hours fpr fnr figure7 howthefalsenegativerate fnr andfalsepositive rate fpr change as we increase the testingtime.
bugsdiscoveredbydifferentialtesting .asshownintable3 approximately of the bugs were uncovered due to inconsistency showing the importanceof employingdifferential testing.
recallthatourdifferentialtestingmethodologyincorporatesa filteringmechanism designedto duplicate mis compilation behaviors.weconsidertwometricstoassessthefilter seffectiveness the falsepositiverate fpr andthefalsenegativerate fnr .inthis context a false positive refers to the number of cases mistakenly classifiedasbugs whilea falsenegative representsthenumberof actual inconsistentresultsthat were erroneouslyfiltered.figure showshowfnrandfprchangethroughoutthetestingprocess.we observe that throughout the entire testing period the fpr remains consistentlylow below10 .asthetestingprogresses weseea gradualdecreaseinthefnrofourfilteringmechanism showingits increasing efficiencyin accurately identifying inconsistent results.
.
compareto priorcompiler fuzzers weusethefollowingmetricstocompare comfuzz againsteight baselines introducedinsection bug exposing capability.
this metric quantifies the number of anomalous compiler behaviors.
note that we have checked and removed all the duplicate anomalous behaviors hence each of themindicatesapotentialcompilerbugthatneedstobeverified by developers.
for a fair comparison we tested each fuzzer for hours of consecutive testing runs using the comfuzz s seed programs andseedprograms from the baselines respectively.
syntaxpassingrate.
itmeasurestheratioofthegeneratedtest cases that are syntactically correct.
for each fuzzer we leverage 50k generatedtest casesto compute the syntax passingrate.
code coverage.
we use three widely used coverage criteria statement coverage function coverage and branch coverage for the comparison.to collectthe coverageinformation we usegcov and lcov forjvm and llvm cov forjsengine the code profiling toolsfor instrumentingc code in jsandjvmcompilers.
throughput.
following the practices in we compute the fuzzing throughput by measuring the number of test cases processed per minute.
this is computed by applying each fuzzer to the same 10ktest casesusing their defaultsettings.esec fse december3 san francisco ca usa g.ye t. hu z.tang z.fan s.tan b.zhang w. qian andz.wang js anomalous behaviors tested compilers comfuzz comfort montage codealchemist die polyglot jvm anomalous behaviors comfuzz classming javatailor jattack a w comfuzz sseed programs js anomalous behaviors tested compilers comfuzz comfort montage codealchemist die polyglot jvm anomalous behaviors comfuzz classming javatailor jattack b w baselines seed programs figure anomalousbehaviorsfoundby differentfuzzers.
js percentage tested compilers comfuzz comfort montage codealchemist die polyglot jvm percentage comfuzz classming javatailor jattack figure comparisonresults ofsyntaxpassingrate.
.
.
bug exposingcapability.
figure8showsthat comfuzz exposed more unique anomalous behaviors than other individual fuzzers either using comfuzz s or baselines seed programs.
with comfuzz sseedprograms comfuzz discovered16anomalousbehaviorsfortarget jsengines achievinganaverageimprovementof thanthenumberofanomalousbehaviorsdiscoveredbyother fuzzers.for jvm comfuzz foundatotalof13anomalousbehaviors .
over the number of anomalous behaviors found by javatailor.
amongall29anomalousbehaviorsdiscoveredby comfuzz 15were foundbythetestcasesgeneratedfromhistoricaltestprograms and 6werediscoveredbyourbug guidedmutators.likewise comfuzz exposed a total of anomalous behaviors with baselines seed programs alsoachievinga .
more thanthat ofotherbaselines.
this demonstrates comfuzz sbug exposing capability.
.
.
syntaxpassingrate.
figure9showshowmanyautomatically generatedtestprogramscanpassthesyntaxchecks.
comfuzz gives an average passing rate of achieving a improvement over mostalternativemethods.amongthesyntacticallyincorrecttest cases generatedby comfuzz nearly90 of themwere created by general purposemutators whichareerror proneastheyrandomly mutate the test cases without any syntax guidance.
in contrast jattack and javatailor applied well designed grammatical rules to synthesize test cases reaching higher passing rates of and .
respectively.however thegrammaticalruleslimittheirbugexposingabilities.asweshowinsection5.
.
comfuzz discovered at least1.
more anomalousbehaviors thanany ofthe baselines.
.
.
code coverage.
figure presents the comparison results of codecoverage where comfuzz givesthebeststatementandbranch coveragecomparedtoallevaluatedfuzzers.theresultsdemonstrate thatusinghistoricaltestprogramsforgeneratingtestcasesismore helpful in covering deeper code of the tested compiler.
for the jsengine montageandcodealchemistachievehigherfunction coverage than comfuzz .
the reason is that their seed programs covermore jsfunctions buttheygivealowerstatementandbranch coverage than comfuzz due to the low syntax passing rate of their generated tests.
this also illustrates montage and codealchemist have lower bug exposing capabilities than comfuzz .
.
.
throughput.
table4 compares the fuzzing throughput computed as the number of test cases processed per minute.
we ran statement cover.
function cover.
branch cover.
percentage js comfuzz comfort montage codealchemist die polyglot statement cover.
function cover.
branch cover.
percentage jvm comfuzz classming javatailor jattack figure compared results ofcodecoverage.
all fuzzers with the same 10k test cases and then calculated the throughput.comparedtootherfuzzers classmingtakesthelongest timetofuzzatestcase.thegenerationtimeaccountsforamuch largerpartofthis asclassmingneedstogetthescopeofthelive codebyexecutingtestcases bothoriginandmutateprograms .as forcomfuzz itgeneratestestcaseswithlargeloopswhenusing inslmutator leading to a long run time in the total test and a lower throughput than other baselines.
nonetheless the fuzzing throughputof comfuzz iscomparable to otherfuzzers.
discussionsand threats to validity our work focuses on the context of compiler testing by combining historicaltest casesandbug guidedmutationrules.
comfuzz providesafocusedandefficientcompilerfuzzingframework achieving a higher bug exposing capability than sota solutions.
we emphasizethat comfuzz isnotdesignedtoreplaceexistingfuzzers.
instead we aim to generate bug exposing test cases for quickly discovering buggy compiler behaviors.
hence we employ a dlbased model to learn a test program generator from historical test cases.
unlike jattack our program generator cannot guarantee the correctsyntaxofallsynthesizedtestcasesduetotheusageofprobabilistic predictionmechanisms during the sampling process.
still the efficiency in generating syntactically valid programs would remainlargelyunchangedcomparedtojattack.inthefuture we will try to employ more powerful neural networks with a larger numberoftrainingsamples.unlikeexistingfuzzers ourworkdoes notpursuefullcodecoverageforthetestedcompiler.incontrast wefocusoncoveringthebuggycompilercomponentsviaasetof carefullydesignedbug guidedmutators.
threats.
ourexperimentsmaynotgeneralizebeyondtheevaluated fuzzers and languages beyond javaandjs.
we mitigate this by evaluatingeightsotas.portingourtechniquetoanewprogram languagewouldrequirethedl basedtestprogramgeneratoron new historical test cases collected for the targeting language redesignsomeofthemutationrulesandkeyinformationextractorfor differentialtestingbutthemodeltrainingcanbelargelyautomated.
related work generativefuzzers.
generation basedtestingoftenutilizesstochastic grammar rules or generation templates tosynthesizetests.therepresentativemethods areedsketch andjsfunfuzz .edsketchisanopen source template based jvmfuzzerthatuseshand writtengenerationtemplatestosynthesize javaprograms.similarly jsfunfuzzemploys pre definedcontext freegrammarstogenerate jstestcases.subsequent studies have proposed increasingly complex grammar and templates to improve the syntactic or semantic passing rates of generated test programs .
jattack provides customized generation templates where developers can encapsulatea generative andmutationalapproachforsynthesizingbug exposing testcases to guide compilerfuzzing esec fse december3 san francisco ca usa table fuzzingthroughput test cases minute .
fuzzers js throughput fuzzers jvm throughput comfuzz .58comfuzz .
comfort .
classming .
montage .39javatailor .
codealchemist .
jattack .
die .
polyglot .
the expected code features for jvmtesting.
spe introduces a syntactictemplatethatconsistsofaskeletalprogramandvariables set.
it generates random equivalent c programs by enumerating the combinations of the skeletal program and the variables.
clsmith the extended method of csmith added multiple generation options to generate opencl kernels for covering more compiler features.
however these approaches pursue full coverage oftargetcompilers leadingtoaninefficientbug revealingability.
by contrast comfuzz is devoted to quickly exposing the buggy compiler component by generating bug revealing test cases based onhistoricaltest programs.
we are the firstto do so.
mutational fuzzers.
mutational testing aims to improve the code coveragefortargetcompilers whichisachievedbyreassembling or modifying a set of seed programs .
emi and its subsequent works are among the representative mutation based fuzzers.
they generate semantic equivalent test cases by performing equivalent mutations.
langfuzz uses and recombines code fragments that previously exposed bugs to generate random jsprograms.
symfuzz mutates parent test programsbasedontheoptimalmutationratiothatisdetermined bywhite boxsymbolicanalysis.ifuzzer utilizesgeneticprogramming techniques to generate unusual input code fragments fortesting jsengines.codealchemist anditsimprovement workdie breaksthehistorical jspocsintocodesegmentsand reassemblesthesesegmentsintonewtestprograms.classming mutates the parent test cases by introducing a live bytecode mutation technique for jvmtesting.
differ from the aforementioned fuzzers comfuzz utilizes the bug guided mutators to generate newtest cases bymutatingtheparent bug revealing testprograms whichcan coverthedeepercodebranchesandimplementhighlyintensivetestingforthebuggycompilercomponent.thismutation insightcould be valuable for mutation guidedcompilertesting.
guidedcompilertesting.
sincerandomtestcasegenerationmethodsforcompilertestingareblindandtime consuming recentstudies have proposed a set of guided fuzzers.
afl is the first coverage guidedtestingframework anditemployscompile time instrumentation and genetic algorithms to assist in generating randomtestcasesforcoveringmorecodebranches.thesubsequent works further improve code coverage for domain specific testing by mutating the seed programs.
poloto etal.
proposed aninterpreter guided unittesting solution on the jit compiler.
it employs concolic testing to explore all possible executionpathsandthecorrespondingvaluesofaninterpreterand usestheseconcretevaluestoimplementdifferentialunittestingon multiple jit compilers.
classfuzz is a coverage guided method onjvmcompilers it employs mcmc sampling to guide mutator selection.confuzzion introducesamutationalfeedback guidedfuzzer on jvmfor exposing the type of confusion vulnerabilities.
it uses historical execution information to randomly select mutation methods to generate new test cases.
javatailor is a closely related work that produces randomly generated tests by mutatinghistoricaltestprograms.thekeydifferenceisthat comfuzz generated test cases are bug directed that can perform focused and highlyintensivetestingforabuggycompilercomponent leading to more effective testingthanotherguidedfuzzers.
dl basedtesting.
toreducehumaninvolvement deep learning models have been used to generate test cases.
deepsmith and learn fuzz start with the recurrent neural network rnn to generate test code opening the dl based testing trend.
the subsequentwork exploreddifferentdeeplearningarchitectures e.g.
lstm seq2seq and gpt to improve thesyntacticpassingrateofthegeneratedtestcodes.inspiredby existingmethods comfuzz also uses thedeep learning model for test code generation but it focuses on a directed generation by feeding the neuralnetwork withhistoricaltest cases.
conclusions we have presented comfuzz a fuzzing framework for detecting compiler bugs.
comfuzz leverages historical bug exposing test programs to generate test cases.
this strategy increases the test coverageofcompilercomponentsthatarelikelytocontainbugs.
ratherthansolelydependingonpasttestcasesandapplyingrandom mutations across all compiler components comfuzz focuses inonmodulespreviouslyknownforbugs.suchmoduleshavebeen historically prone to errors and canpotentially contain bugs introducedbyfixes.auniquefeatureof comfuzz isitsuseofbug driven mutatorstouncovertheseresidualbugs.tofurtherenrichourtestingdiversity weincorporatedfivemultipurposemutatorsdesigned toproducenewtestcaseswhenexistingonesfallshortinrevealing bugsorenhancingcode coverage.
weevaluate comfuzz on11distinctcompilers coveringboth js andjava.in260testinghours itunveiled33distinctbugsinnineof those compilers.
of these detected issues were verified with being rectified by the developers.
compared to eight prior fuzzers comfuzz uncovers at least .
more bugsthanits counterparts.
data available thedata andcode associatedwith thispaper areopenly available at