cross language android permission specification chaoran li swinburne university of technology australia chaoranli swin.edu.auxiao chen monash university australia xiao.chen monash.eduruoxi sun the university of adelaide australia ruoxisun278 gmail.com minhui xue csiro s data61 australia minhuixue gmail.comsheng wen swinburne university of technology australia swen swin.edu.aumuhammad ejaz ahmed csiro s data61 australia ejaz629 gmail.com seyit camtepe csiro s data61 australia seyit.camtepe data61.csiro.auyang xiang swinburne university of technology australia yxiang swin.edu.au abstract the android system manages access to sensitive apis by permission enforcement.
an application app must declare proper permissions before invoking specific android apis.
however there is no official documentation providing the complete list of permission protected apis and the corresponding permissions to date.
researchers have spent significant efforts extracting such api protection mapping from the android api framework which leverages static code analysis to determine if specific permissions are required before accessing an api.
nevertheless none of them has attempted to analyze the protection mapping in the native library i.e.
code written in c and c an essential component of the android framework that handles communication with the lower level hardware such as cameras and sensors.
while the protection mapping can be utilized to detect various security vulnerabilities in android apps such as permission over privilege imprecise mapping will lead to false results in detecting such security vulnerabilities.
to fill this gap we thereby propose to construct the protection mapping involved in the native libraries of the android framework to present a complete and accurate specification of android api protection.
we develop a prototype system named natidroid to facilitate the cross language static analysis and compare its performance with two state of the practice tools termed axplorer andarcade .
we evaluate natidroid on more than android apps including system apps from custom android roms and third party apps from the google play.
our natidroid can identify up to new api permission mappings in contrast to the worst case results derived from both axplorer andarcade where approximately corresponding authors sheng wen and xiao chen.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
have at least one false positive in permission over privilege.
we have disclosed all the potential vulnerabilities detected to the stakeholders.
ccs concepts security and privacy mobile platform security .
keywords android permission cross language analysis native code acm reference format chaoran li xiao chen ruoxi sun minhui xue sheng wen muhammad ejaz ahmed seyit camtepe and yang xiang.
.
cross language android permission specification.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
introduction android protects access to restricted data e.g.
the device identifier and actions e.g.
making phone calls through permission enforcement .
such an access control model can protect users against snooping and protect the stability and security of the operating system .
when an android app attempts to access the restricted resources a security check is triggered to inspect whether proper permissions are granted.
lack of permission request will prevent access to the resource and further cease the corresponding functionality or even crash the app.
therefore it is essential for developers to know the permissions required of the invoked api.
unnecessary required permissions can pose three threats i too many required permissions may confuse users.
users suspect that the app has unexpected behaviors which leads to users uninstalling or unwilling to install the app ii the permissions required by an app is an important feature in detecting android malware.
unnecessary permissions will fool the detector and cause a false alarm iii the app will incur security risks with unnecessary permissions.
once the app contains vulnerabilities that can be injected with tampered code it is easy for an attacker to thwart user privacy or invoke sensitive apis.
moreover requesting unnecessary permissions may esec fse november singapore singapore c. li x. chen r. sun m. xue s. wen m. e. ahmed s. camtepe y. xiang figure android software stack expand the attack surface and expose the android operating system to a host of attacks especially privilege escalation attacks .
therefore to safeguard users privacy and protect the android ecosystem android app developers are suggested to follow the principle of least privilege i.e.
requesting a minimum set of permissions required to fulfill the apps functionality.
unfortunately android does not provide official documentation for the permission specifications i.e.
a mapping between apis and the required permissions making it difficult for app developers to follow the least privilege rule and further lead to security vulnerabilities such as permission over privilege .
to address this problem researchers have been working on developing methods that generate an accurate list called a protection map that maps android apis to the required permissions.
the previous works that provide such protection maps include stowaway pscout axplorer arcade psgen and most recently dynamo .stowaway empirically determines the permissions required in android apis using feedback directed testing.
pscout andaxplorer leverage control flow reachability analysis on the source code of the android framework to generate the mapping between apis and permissions.
arcade proposes a path sensitive method based on graph abstraction techniques to generate a more precise mapping.
psgen statically generates the protection map for android ndk.
dynamo extracts the protection mapping through dynamic test.
dynamic testing methods e.g.
stowaway anddynamo can accurately map the required permissions to api invocations that they have tested however such dynamic approaches suffer from an intrinsic shortcoming of low coverage.
the existing static analysis based approaches e.g.
pscout axplorer and arcade have better coverage but may lead to imprecise results because of improper modeling of the complicated android communication mechanisms.
psgen extracts protection mapping for android ndk i.e.
both protected apis and permission checks are in the native code which has a different scopeto our approach i.e.
the protected apis are in the java framework while the permission checks are in the native code .
specifically existing works only analyzed the java api framework in the android api framework but overlooked the c c native library that consists of core android system components and services e.g.
camera service sensor service .
for example the public method opencamera incameramanager.java class implements its permission check android.permission.camera in the native library cameraservice.cpp .
missing native library analysis will mistakenly conclude that the api opencamera does not require any permissions one example is detailed in section .
while the api permission protection mapping contributes to identifying security vulnerabilities in android apps such as permission over privilege i.e.
an app requests additional permissions that are not required the imprecise mapping will lead to false results on detecting such vulnerabilities.
taking the aforementioned case as an example an app invokes the api opencamera will need to request the corresponding permission android.permission.camera however existing works that do not analyze the native libraries will identify it as a permission overprivilege case and henceforce a false positive.
static analysis is widely used in code analysis due to its fast speed and high code coverage especially in the field of android security analysis .
there are also many works on vulnerability identification of android operation systems and apps .
in this research to address the shortcomings of the existing works we leverage the cross language analysis on the overall android system including both the java api framework and the c c native libraries .
to this end we analyze the cross language communication mechanisms on five android open source projects aosp and summarize two communication models to facilitate the cross language analysis.
we develop a prototype system natidroid and generate native triggered i.e.
an android api whose permission check is implemented in the native library api permission mappings in aosp versions .
.
.
.
and .
which were chosen to benchmark against prior works see detailed discussion in section .
in addition to the mappings generated by previous works axplorer andarcade and respectively in aosp .
natidroid can successfully discover mappings that are not covered previously.
note that while most android apis are java methods few of them are c c methods.
nevertheless these native methods play indispensable roles in the android system such as interacting with the hardware layer.
we further use the new mappings to detect permission over privilege vulnerabilities on a large dataset containing more than android apps including system apps from custom android roms and third party apps from the google play.
we identify the worst case scenario where approximately apps with permission over privilege detected by axplorer andarcade are false positives.
in summary we make the following contributions we design and implement a prototype system natidroid to facilitate cross language control flow analysis on the android framework.
to the best of our knowledge this is the first work to enable cross language analysis on the android framework.
by incorporating natidroid with existing java side permission 773cross language android permission specification esec fse november singapore singapore mappings e.g.
axplorer orarcade we obtain a complete permission mapping that covers the entire android system.
we make our system and results publicly available to benefit researchers and practitioners.
we apply natidroid to extract the permission api protection mappings from the native libraries on five aosp versions .
.
.
.
and .
.
we show that permissions including signature and dangerous permissions are determined to be enforced in native libraries which are not covered by two stateof the practice benchmarks axplorer andarcade .
we analyze android apps for permission over privilege.
our results show that natidroid is effective in identifying vulnerable android apps.
we have identified approximately false positives in terms of the number of the apps with at least one permission over privileged.
we hope that the proposed system natidroid in this paper could bridge the gap between java and native sides analysis see figure rendering the static analysis of the overall android framework to be complete and accurate.
background and motivation this section provides background information on how android os operates and explains the limitations of the existing static api protection mapping generation techniques that motivate our work.
android framework.
android framework consists of the java api framework layer and c c native library layer i.e.
the second and the third layers from the top in figure .
the java api framework layer offers application programming interfaces apis written in the java language for android app developers to access android features and functionalities.
the java framework accesses the device hardware capabilities such as the camera and sensors via the c c native library layer.
when a java framework api e.g.
the camera manager in figure invokes a call to access device hardware the android system loads corresponding library module e.g.
the camera service for that hardware component.
android permission model.
when an app needs to use any of the protected features of an android device e.g.
accessing the camera sending an sms making a phone call it must obtain the appropriate permission s from the user.
when an android api is called the android framework checks whether it is protected by any permission.
most of such permission checks are defined in the java api framework layer in the android system while there are yet a number of them defined in the c c native library layer.
existing works leverage static analysis on the java api framework layer of the android framework to extract the mapping between apis and corresponding permission checks.
ignoring the invocation of native libraries miss the permission checks in the native libraries leading to incomplete mapping results.
motivating example.
we further elaborate on our motivation with a real world example illustrated in figure .
the code from lines to is derived from a popular photography app vstudio.android.camera360 on google play.
the app initialises a cameramanager instance line and opens the camera instance by invoking opencamera method line .
the invocation chain then traverses along the call path through an android sdk class 1the source code is available at figure motivation example derived from a real world android app vstudio.android.camera360 .
the code is simplified for better illustration.
cameramanager.java lines to and a native library cameraservice.cpp lines to and finally triggers a permission check in the native library line .
note that the cameraservice.connectdevice line communicates with the cameraservice connectdevice line in a cross language way marked as purple .
the security check examines if the method is called by its own process i.e.
cameraservice hence no permission is required or the corresponding permission android.permission.camera is granted.
if neither it is called from its own process nor the android.permission.camera permission is granted a permission denied error is returned line which will further prevent opencamera to be executed.
this example implies a protection mapping from the android api cameramanager.opencamera to its permission protection check android.permission.camera callingpid getpid .
unfortunately as existing works only analyzed the java source code in the android framework they miss the permission checks implemented in the native libraries.
for instance the mapping 2some if then else statements are omitted in line of figure for better illustration consequently the protection mapping only reflects the simplified code as shown in figure .
the complete protection mapping for opencamera can be found in our open source repository.
774esec fse november singapore singapore c. li x. chen r. sun m. xue s. wen m. e. ahmed s. camtepe y. xiang of the api cameramanager.opencamera to the permission android.permission.camera as shown in the example does not exist in the state of the practice works such as pscout axplorer or arcade .
the incompleteness of the mapping results further introduces false results in detecting security vulnerabilities such as permission over privilege detailed in section .
.
approach we propose and implement a prototype system natidroid to address the cross language protection mapping problem that has long been overlooked in previous works.
figure illustrates the overall design of natidroid .
as depicted natidroid contains three modules.
the pre processing module prepares the intermediate artifacts for analyzing the android framework and native libraries such as intermediate .jar files for java side analysis and clang compile commands for native side analysis .
the entry points identification module summarizes two cross language communication models used in the android framework and identifies the entry points for both java and native sides analysis.
the cross language interprocedural control flow graph icfg analysis module constructs the cross language icfg and extracts the permission mapping.
we propose a complete solution for extracting native triggered permission mapping from the android system.
we leverage soot and clang static analysis frameworks although our solution is also applicable to other static analysis frameworks.
soot is a popular java optimization framework for analyzing and visualizing java and android apps which has been widely used in various projects for static analysis .clang is a lightweight compiler for c language family.
we use clang to transform c c code to the abstract syntax tree ast .
additional code for implementing natidroid consists of approximately 7kloc.
we detail the design and implementation of each module in the following subsections.
.
pre processing due to the complexity and cross language nature of the android framework there is no off the shelf tool for static analysis of the android framework i.e.
java api framework andnative library as a whole.
natidroid leverages the divide and conquer strategy to facilitate the java and native sides analysis.
however there are still non trivial tasks to prepare the aosp codebase for the static analysis.
hence in this module we prepare the intermediate artifacts from the aosp codebase which are required to enable the java and native sides analysis.
note that the pre processing module includes most engineering works which is not considered our technical contribution.
however it is essential to facilitate the proposed cross language analysis.
java side analysis preparation.
natidroid s java side analysis takes compiled .jar file as input.
however to maintain the stability of the android system some non sdk class and method bodies are hidden using the hidden javadoc tag e.g.
non sdk android apis that may be changed in the future versions without noticing the app developer during the building of android.jar from source code.
the hidden classes and methods only expose the method name parameters return values and minimum set of statements required to handle the invocation which is not sufficient for constructing acomplete icfg.
we therefore retain the intermediate output during the compilation i.e.
the intermediate .jar files that have not been combined as android.jar .
these intermediate .jar files such as services.com.intermediates.jar have the complete class and method information sufficient for facilitating static analysis.
native side analysis preparation.
before we build the crosslanguage icfg cf.
section .
we leverage clang to transform c c source code to ast.
a complete set of clang compile command is required to enable the static analysis however is not provided in android documentation.
android uses the ninja to build system .
during the compilation process the .ninja files containing ninja build commands are generated by the compiler.
however the commands obtained from .ninja files consist of file operations and a mixture of gnu compiler collection gcc and clang commands which are not compatible with the off the shelf clang based analyzer.
we then develop a system to loc to extract and pre process the required commands from these files.
the functions of the system include merging separated ninja commands and replacing the clang commands with clang commands i.e.
adding c headers in clang command s parameters .
.
entry points identification recall that the overall idea of generating a protection mapping is to examine whether the invocation of an api will trigger a permission check in the android framework i.e.
if there is a permission check node in the icfg starting from the api call .
due to the complexity of the android framework building an icfg of the overall framework is neither practical nor efficient.
as natidroid s goal is to complement the existing mappings such as axplorer andarcade by adding the protections whose permission checks are located in the native libraries we only generate sub icfgs for the android apis that involve cross language communication.
the first step to generate sub icfgs is to identify the entry points of the graphs for both java and native sides .
to this end we first summarize two cross language communication mechanisms used by android.
aidl based communication model.
the android operating system os is based on linux but does not inherit the inter process communication ipc mechanism of linux.
in android resources between processes are not shared.
android interface definition language aidl is one of the ipc mechanisms that android adopted to enable communication for remote invocation providing crossprocess or even cross language communication.
figure depicts the workflow of aidl based client service model where the java framework works as a client requesting service from the native library.
aidl utilizes a pair of stub proxy classes on java side to communicate with native libraries.
the proxy is responsible for sending requests to native service and implementing the remote method which invokes the transact method and communicates with native side while the stub class inheriting the binder class transforms service binder and receives the reply from native service using the method ontransact .
thetransact andontransact are synchronous such that a call to transact does not return until the target has returned from ontransact .
on native side it is unnecessary to generate stub proxy pairs but directly implements the remote method using the name as same as the remote method on java side to handle the request from 775cross language android permission specification esec fse november singapore singapore figure an overview of natidroid system figure aidl communication model.
the java side caller invokes remote method from native side.
java side so that we can always find the receiver ontransact and the same name remote method as the aidl sender.
through using pairs of ontransact andtransact methods as sender and receiver on both sides the communication between java and native sides is established.
therefore cross language interaction can be detected via matching the use of aidl on java and nativesides e.g.
the stub proxy pair the ontransact methods and the implementation of the remote methods and the transact methods .
we can then determine the entry points for static analysis accordingly.
an example of aidl mechanism is shown in figure where the method getcamerainfo uses aidl to implement the communication between java and c .
a pair of a sender and a receiver on each side of aidl i.e.
the client and the service handles the cross language communication.
the caller line invokes the method getcamerainfo which is firstly defined as an interface in line and then implemented in line the detailed implementation is omitted .
in the corresponding native library lines to the receiver ontransact handles the request and further invokes the method getcamerainfo line .
the getcamerainfo method then executes the method implementation and sends the execution result back to the java side ontransact method line which is further passed back to the caller line .
note that the getcamerainfo in line and the getcamerainfo in line are the two interface methods that both invoke the transact method omitted to establish the communication between java and native sides.
the natidroid will match the pair of such figure an example of aidl based cross language communication model.
the code snippets are simplified for better illustration.
remote methods and recognize them as a pair of java entry point and native entry point.
note that for the inner language aidl communication on both java and native sides natidroid generates icfg with a similar approach except for the identification of entry points.
jni based communication model.
java native interface jni provides a cross language interface between java and native code written in c c .
this enables developers to write native methods to handle situations when an app cannot be written entirely in the java programming language e.g.
when the standard java class library does not support the platform specific features or program library such as communication with the underlying hardware.
in the jni framework native functions are implemented in .cor.cpp 776esec fse november singapore singapore c. li x. chen r. sun m. xue s. wen m. e. ahmed s. camtepe y. xiang figure jni communication model.
java and native sides communicate with jni.
files.
when invoking the function it passes a jnienv pointer a jobject pointer and any java arguments declared by the java method.
figure shows the jni based communication model adopted by android.
android uses the jni dynamic register to link native methods.
different from the aidl model the jni based communication starts from a registration process.
when android starts running the androidruntime class uses the startreg method to start the registration of jni methods which will further invoke all jni registration functions implemented in the native libraries.
the registration functions will register native methods with the corresponding java class specified by an array of jninativemethod structures that contains the java method name java method signature and pointers to the native function.
after the registration process all the jninativemethod on native side is registered and linked to the corresponding java method in the java virtual machine jvm .
we further explain the jni based communication mechanism with an example given in figure which is derived from android hardware radio.cpp in aosp .
.
the method register android hardware radio line is called to register the jni methods for radio with the jni method information provided in line .
specifically the kradiomoduleclasspathname variable line declares the containing class name of the java method and gmodulemethods line declares the correspondence between the java method and the c function.
the variable gmodulemethodsis defined to contain groups of the java method name line parameter and returned types lines to and the pointer of c method line .
all the information will be dynamically registered in jvm during run time.
finally the c method involved in the cross language communication is declared in line while the involving java method can be found in the java file radiomodule.java in package android.hardware.radio lines to .
according to the jni based communication mechanism we extract pairs of entry points from java and native sides.
specifically the jni methods and the corresponding native methods are vaguely identified by a linear sweep searching of keyword registermethodsordie registernativemethods andjniregisternativemethods over the.cpp files at first.
then we extract the class path name e.g.
thekradiomoduleclasspathname in figure and the array of jninativemethod structures from which a pair of figure an example of jni based cross language communication.
the code snippets are simplified for better illustration.
algorithm constructing cross language icfg input android native code and intermediate jar c. output cross language icfg g. g nep j nepc scanentrypoints c foreach nep j nepc nep j nepc do nc ec nativeicfggenerator nepc ifhassecuritycheck nc then foreach nc ec nc ec do g g nc ec nj ej javaicfggenerator nep j foreach nj ej nj ej do g g nj ej e link nep j nepc g g nep j e g g nepc e entry points can be located and recognized e.g.
the pair of native setup andandroid hardware radio setup .
.
cross language protection mapping extraction after the entry points on both java and native sides are identified we further extract the protection mappings from aosps.
in this section we first introduce how natidroid generates icfg from both sides.
based on the icfg natidroid then traverses the crosslanguage android api call paths and corresponding security checks e.g.
permission checks to generate the api permission protection mappings.
.
.
cross language icfg generation.
algorithm elaborates the detailed steps involved in generating cross language icfgs.
after obtaining the entry point pairs from both java and nativesides line as detailed in section .
natidroid first leverages a forward analysis to generate an icfg on the native side from each identified native entry point line .
if the native side icfg does not contain any security checkpoint e.g.
permission check uidcheck andpidcheck we discard the icfg for computational efficiency 777cross language android permission specification esec fse november singapore singapore figure an example of using strong pointer in native library line .
otherwise natidroid further utilizes a backward analysis to build a java side icfg starting from the paired java side entrypoint to an android api.
if the reached android api is further invoked by other android apis we extend the icfg until the api is not called by any other apis lines to .
the icfgs generated from both sides are then connected with the communication models identified in section .
lines to .
handling the service identifier.
the aforementioned aidl is often used to invoke remote methods in service.
before the invocation the service is usually pointed by passing a string to the getservice orcheckservice method for example the string media.player in line of figure .
when building the call graph we need to handle such remote invocation and identify which class is the identifier string actually pointed to.
these services are registered to the system through an addservice method either on java side or native side .
therefore we can automatically collect the correspondences between these identifiers and service classes from it.
first we scan the java and c files looking for addservice methods.
then the program confirms whether the method is servicemanager.addservice ordefaultservicemanager addservice separately.
once confirmed the program extracts a pair of service class and the corresponding identifier from the parameters for example the string identifier media.player in figure will be paired with its service class mediaplayerservice .
handling android strong pointer.
although the strong pointer defines the type variable the type is not necessary to be restricted.
therefore we need additional efforts to get what type the strong pointer actually points to from the context.
according to the strong pointer mechanism when we find that a member function is called if the object is declared as a strong pointer the invocation of the member function will be determined automatically.
the natidroidalgorithm protection maps extraction input the cross language icfg generated in algorithm g. output the protection mapping m. m map node condition n dfs g foreachn ndo ifisjavaapinode n then k getallnativechildren n foreachk kdo ifhassecuritycheck k then c c getsecuritychecks k m m n c will first trace the statement where an object is assigned to the strong pointer.
if it is assigned through method getservice the type of the object will be determined by the passed service identifier otherwise natidroid will determine the type of strong pointer according to the variable type returned by the function.
handling member variables.
a class member variable is also possibly assigned by a strong pointer.
for example in line of figure the setaudiosource method of the mmediarecorder object is invoked but from this line of code we cannot determine the type of variable mmediarecorder so that we cannot determine whichsetaudiosource method has been invoked.
by looking up in the referenced header file from line we find that this variable is a member variable of class mediarecorder .
therefore to find out the type of this variable we can search the entire class looking for the assignment or initialization statement.
note that the assignment should be ignored if the assignment releases the pointer e.g.
pointing the variable to a null pointer.
in this case the variable mmediarecorder is initialized as the return value of createmediarecorder in the class constructor line .
we have explained how to determine the return type of createmediarecorder in the previous paragraph handling android strong pointers.
to implement the process automatically if a variable cannot be tracked in the local scope natidroid will point to the header file to check whether it is a member variable and thus the tracking scope will be expanded to the entire class.
handling particular access control.
binder transaction executes with the identity i.e.
pid and uid of a caller.
if a transaction needs to run with callee s identity binder.clearcallingidentity can temporarily clear the caller s identity so that the callee s identity will be checked during the transaction.
then the caller s identity can be restored by binder.restorecallingidentity .
to handle such intervened access control natidroid uses callee s identity for security control for all methods between the two binder methods.
.
.
protection mapping extraction.
algorithm shows the pseudocode of extracting the protection mapping of android apis.
after obtaining the cross language icfg we resort to a depth first search dfs strategy line to check if there are call paths between android apis in the java api framework layer and security checks in the native library layer.
for each node in the icfg if it is a java node we will collect all its native children lines to and obtain the security checks defined in its children nodes lines to .
if there are more than one checkpoint on the call trace e.g.
an 778esec fse november singapore singapore c. li x. chen r. sun m. xue s. wen m. e. ahmed s. camtepe y. xiang table permission api protection mappings extracted by natidroid .
the results of axplorer andarcade are generated from the android java framework while the results of natidroid are generated from android native libraries.
sourcenative library c c api framework java natidroid axplorer arcade permission api affected permission api affected permission api affected s1 d n total s d n total s d n total aosp .
aosp .
aosp .
aosp .
aosp .
1s signature permission d dangerous permission n normal permission.
android api is protected by multiple permissions we concatenate them with and operation.
as inspired by aafer et al.
we also include security checks other than permission enforcement such as uid and pid checks.
if there is more than one android api along the track we create a mapping entry for each of them i.e.
all android apis along the track have the same security check .
finally each pair of java api node and its corresponding security check s in native side will be added into the protection mapping line .
evaluation the main contribution of this work natidroid is to enable the cross language static analysis of the android framework.
since there is a number of existing tools and works well handling the static analysis of the java side of android framework natidroid specifically focuses on the analysis of the crosslanguage part of the android framework.
in this section we run experiments to verify the performance of natidroid and to answer the following research questions rq1 how effective is natidroid in identifying permission enforcement in native libraries?
rq2 how many permission mappings can our tool identify that are not recognized by the state of the practice approaches?
rq3 how can our tool contribute to real world security evaluation?
we use natidroid to extract the api protection mapping for aosp versions .
.
.
.
and .
.
we obtained the source code from the official aosp repository .
the experiment ran on a linux server with intel r core tm i9 9920x cpu .50ghz and gb ram.
.
rq1 the performance of natidroid we present the statistics of permission api protection mapping extracted from the native libraries in table columns to .
it takes hours on average to extract the protection mapping from each aosp version.
in each of aosp .
.
.
and .
our tool identified more than apis whose permission enforcement take place in the native code while in aosp .
natidroid detected apis containing permission enforcement on the native side.
in table we list the permissions that have permission checks in native libraries including dangerous permissions signature permissions and normal permissions.
signature permissions areonly granted if the requesting app is signed with the same certificate as the app that declared the permission.
normal permissions refer to the permissions with minimal risk to the system and the users private data.
dangerous permissions are those higher risk permissions that would give access to private user data or control over the device that can negatively impact the users.
due to the lack of ground truth for the permission protection mappings it is difficult to evaluate the overall accuracy of the extracted mappings.
we therefore resort to a manual process to examine the correctness of our mappings.
to this end we manually inspect the involved source code in the aosp codebase to confirm if the apis will go through the corresponding security check s and if the condition s in the security check s is are consistent with the condition s in the mappings.
we randomly selected of the total mappings i.e.
mappings for manual inspection and found no missing or redundant protection conditions in our mappings.
we further looked into the results on the affected api in each aosp.
in aosp .
the number of affected apis decreased significantly compared to other versions in aosp .
vs. .
.
in aosp .
to .
.
through the manual code review we found that two signature permissions access drm certificates and control wifi display have been removed in aosp .
.
at the same time the code related to the audio service was refactored and simplified which greatly reduced the number of exposed methods.
answer to rq1.
natidroid identified more than apis that are protected by permission enforcement in the native code in aosp .
.
and apis in aosp .
which are verified by manual inspection sampling .
.
rq2 comparison with other mappings state of the art works use static and dynamic analysis approaches to extract the api permission protection mapping from the android framework.
for instance axplorer and arcade use static methods to retrieve the protection mapping.
dynamo on the other hand extracts the mapping by leveraging dynamic analysis.
this rq compares our results with the mappings derived from these approaches.
unfortunately the mapping from dynamo lacks method signature information e.g.
class name return type and parameter list which is required to identify a method e.g.
there could be methods with identical names in different classes .
we cannot accurately compare our mapping with dynamo s mapping.
779cross language android permission specification esec fse november singapore singapore table permissions with permission checks in native libraries permissionsaosp protection level .
.
.
.
.
access drm certificates signature access fm radio signature access surface flinger signature capture audio hotword signature control wifi display signature location hardware signature modify audio routing signature read frame buffer signature record audio dangerous camera dangerous internet normal modify audio settings normal the permission exists in aosp the permission does not exist in aosp.
therefore in this rq we compare our work with axplorer and arcade .
the mappings of axplorer andarcade are derived from their public repositories3note that since both works only released their mapping results for aosp version .
and under in lieu of the tools we are unable to obtain the mappings on aosp .
.
and .
.
table presents the comparison of permission api protection mappings on the five aosp versions.
unsurprisingly since natidroid only focuses on the permission checks in the android native libraries while axplorer andarcade only work on the android java framework there is no overlap between natidroid and the two works respectively.
as shown in the first two columns of table the number of newly identified permissions that are missed in previous works ranges from to in the five aosp versions.
there are to android apis associated with these permissions i.e.
invoking these apis requires the corresponding permissions to be granted counting up to approximate of the mappings reported in the previous study which are overlooked in the previous work that only analyzed the java side of the android framework.
table reports the breakdown of the mappings based on the permission protection levels.
the mapping results contain the permissions in signature dangerous and normal levels.
missing these mappings especially the ones for the dangerous permissions will lead to false results in detecting security issues of android apps such as permission over privilege detailed in section .
.
thus the main security and privacy threats to the majority of android apps i.e.
third party apps which usually have no access to signaturepermissions are caused by inaccurate mapping of dangerous permissions.
it is therefore worth highlighting that natidroid has identified the mappings for two additional dangerous permissionscamera andrecord audio which are closely related to user s privacy.
answer to rq2.
natidroid is able to identify dangerous permission signature permissions and normal permissions that previous works have missed.
approximate of the mappings reported in the previous study are related to these permissions.
and experimental dataset set source apps custom rom appsxiaomi .
lg .
samsung .
huawei .
third party apps google play store total .
rq3 applications of protection mappings the protection mappings can be leveraged to detect security issues of android apps such as permission over privilege .
in this subsection we evaluate the effectiveness of our extracted mappings in identifying the security vulnerabilities.
we include two categories of android apps in our experiments the custom rom apps that are pre installed on the devices such ascamera andcalendar as well as the third party apps that users can download from official or alternative app stores e.g.
social networking apps banking apps .
the experimental dataset contains custom rom apps extracted from five android custom roms of four vendors i.e.
samsung lg huawei and xiaomi and third party apps randomly downloaded from the google play store.
table shows an overview of the dataset in use.
we use the permission protection mappings extracted from aosp to detect security vulnerabilities in both the custom rom apps and third party apps.
the aosp mapping may miss some vendorcustomized permissions e.g.
huawei.permission.set smsc address which may be used in the custom rom apps.
nevertheless we argue that using the aosp mapping may miss some vulnerabilities caused by the misuse of vendor customized permissions but will not affect the results corresponding to the official permissions serving as the main scope of our study.
permission over privilege detection.
android app developers access android framework functionalities by invoking android apis.
some apis have access to sensitive information such as reading the contact list are protected by permissions.
developers need to request such permissions from the android system before accessing the sensitive resources.
specifically a list of required permissions need to be declared in the androidmanifest.xml file and the corresponding permissions protected apis are to be invoked in the app s implementation.
according to the android developers documentation app developers should request a minimum set of permissions required to complete the app s functionality as introducing additional permissions will increase the risk of privacy leak.
however developers usually either intentionally or unintentionally request permissions that are not related to the functionalities actually implemented in the app and hence not necessary .
to detect apps with the permission over privilege issue we extract the reachable apis of the app with a min timeout for all approaches i.e.
natidroid arcade and axplorer and retrieve its protection conditions e.g.
permission uid pid according to the mappings.
for instance when invoking an android api it may check the uid e.g.
uid aid system checks if the app has system privilege and the pid e.g.
callingpid getpid examines if the method is called by its own process along with permission enforcement.
while the uidcan be retrieved statically 780esec fse november singapore singapore c. li x. chen r. sun m. xue s. wen m. e. ahmed s. camtepe y. xiang table permission over privilege detection results data set sourceanalyzable appsavg unneeded permissions per app of false positive permissions of apps that have false positives nati ar1ar nati ax ax nati ar nati ax nati ar nati ax custom rom appsxiaomi .
.
.
.
.
.
.
lg .
.
.
.
.
.
.
samsung .
.
.
.
.
.
.
huawei .
.
.
.
.
.
.
total .
.
.
.
.
.
.
third party apps google play store .
.
.
.
.
.
1nati natidroid ar arcade ax axplorer merge the two mappings.
thepidhas to be determined at run time thereby cannot be obtained through static analysis.
nevertheless the apps included in the experiment are custom rom apps and third party apps which cannot possess pidof android system services.
therefore it is safe to assume that callingpid getpid will always return false in our tested apps.
finally if the app declares permission in theandroidmanifest.xml file that is not required i.e.
no apis associated with the permissions found in the app we flag it as an over privilege case.
results.
the over privilege detection costs seconds per app on average.
the most time consuming step i.e.
extracting reachable apis in the apps is the same in each benchmark approach.
hence time overhead has negligible difference after integrating natidroid into the benchmark approaches.
table presents the over privilege detection results.
to demonstrate the effectiveness of our mappings in pinpointing the permission over privilege issue we compare previous works results with our results.
recall that natidroid only extracts protection mappings from the native libraries in our results i.e.
nati ar andnati ax the java side mappings are derived from arcade andaxplorer .
we identify .
and .
apps with a permission over privilege issue using arcade s and axplorer s mappings respectively.
among their results we identify that .
and .
in arcade s and axplorer s results respectively contain false positive results caused by missing native triggered permission mappings.
specifically as shown in the last four columns of table there are and permissions that are erroneously identified as over privilege by axplorer in .
third party apps and .
custom rom apps respectively for axplorer permissions in .
third party apps and permissions in .
custom rom apps are found to be false positive.
interestingly both arcade andaxplorer report that a significantly high proportion of apps approximately suffer from a permission over privilege issue.
we therefore take an in depth look into their detection results and observe that the majority of their false positives are caused by missing native triggered internetpermission mappings.
as illustrated in figure we further present the breakdown of permissions that cause the false positive results in the comparing methods.
specifically missing internet permission mappings leads to and false positives in arcade s and axplorer s results.
other missing permission mappings that contribute to the false positives include record audio false positives in both arcade andaxplorer modify audio settings and false positives in arcade andaxplorer figure false positive over privileged permissions in previous works detected by natidroid .
respectively and camera false positives in both arcade and axplorer .
manual inspection.
due to the lack of ground truth we manually inspect if the over privileged permissions detected are indeed unneeded by the containing apps.
the first two authors of this paper and three security researchers are involved in the manual inspection.
the result is determined via majority voting.
for each app we decompile the apk file and locate the relevant apis.
then we manually check the app s context and determine whether the invocation of the apis meet the conditions in the protection mappings.
as this process involves immense manual efforts it cannot scale to cover a large number of apps.
hence we manually verified randomly selected apps.
our manual analysis indicates that most of the cases are true positives .
the remaining five apps contain implicit parameters passed to the apis to be examined which cannot be precisely inferred via static analysis.
nevertheless we resort to a dynamic approach to verify the remaining five apps.
specifically we remove the permissions in question from the androidmanifest.xml file and repackage the app.
then we manually test the app on an emulator to confirm if the app crashes or the corresponding functions are disabled.
as a result the removal of the permissions in question has no impact on the apps suggesting that these permissions are indeed unneeded.
answer to rq3.
our tool identified that more than half of the over privilege results from state of the practice tools are false positives which is caused by missing native triggered permission mappings.
threats to validity android versions.
in this paper we propose a solution to facilitate cross language static analysis of the android framework and 781cross language android permission specification esec fse november singapore singapore build a prototype system natidroid to extract api permission mapping from the android operating system.
to compare with the state of the practice works axplorer andarcade which are close sourced and only generated the mappings up to android .
in our experiment we extract the mappings from the latest versions they have i.e.
.
and .
and three newer versions i.e.
.
.
and .
.
nevertheless the proposed solution can apply to any android version with further engineering works to be done in the pre processing module.
custom roms.
android smartphones such as samsung huawei and xiaomi are shipped with vendor customized android systems i.e.
custom roms rather than the aosp.
unfortunately these custom roms are not open source.
the proposed solution takes the source code as input therefore it cannot extract permission mappings from these close sourced custom roms.
however smartphone vendors can use our solution to analyze their customized android versions based on their source code.
nevertheless to maintain the compatibility of running third party apps such custom roms are not likely to modify the normal anddangerous level permission specifications of aosp that third party apps can access but rather add a few signature level permissions for their own system apps.
therefore the results derived from aosp will not affect the security analysis of third party apps which are the majority in the android ecosystem.
on the other hand with natidroid thirdparty vendors can perform an inner security analysis on custom rom source code determine whether there are errors in the implementation of permission mappings and further detect permission over privilege before releasing an app.
static analysis.
when extracting the protection mapping our approach may suffer from the inherent limitations in generating static icfgs from both java soot and native clang side.
moreover some values and properties can only be obtained at runtime including runtime variables that may affect the conditional branch and functions that can only be analyzed at runtime e.g.
memory operations .
when detecting over privilege issues in android apps we may suffer from the intrinsic vulnerability of static code analysis when encountering code obfuscation and reflection which may lead to the unsoundness of our results.
when building the apps call graph our method may yield unsound results because it may miss the context and the parameters that can only be obtained at runtime.
for example the api android.media.mediaplayer void setdatasource requires the internet permission when the data source is online media.
the source is not always a static string so that it may be assigned at run time.
nevertheless these challenges are regarded as well known and non trivial issues to overcome in the research community .
related work android api protection mapping.
stowaway initially explored and analyzed the android permission specification.
they extracted api mappings based on the feedback directed fuzz testing and dynamically recorded the permission checks of apis.
the mappings they extracted are accurate but the code coverage is limited.
to address the limitations of low code coverage pscout uses static analysis to extract the api protection mapping.
however they did not consider the context of the api invocation and thusmay produce false positive mappings.
axplorer leverages more accurate static analysis on the sdk and android framework and generates more precise permission specifications.
arcade conducts a similar static analysis with additional attention paid to extract other security mechanisms such as uidandpidchecks.
while these works only analyzed the java side of the android none of the works has looked into the native libraries within the android framework.
in order to overcome the limitations of static analysis dynamo uses dynamic analysis aiming to obtain more accurate mapping.
psgen conducts an analysis permission specification for android ndk i.e.
both protected apis and permission checks are in the native code which has a different scope to our approach i.e.
protected apis are in the java framework while the permission checks are in the native code .
our work fills the research gap by analyzing the native libraries and their communications with the java framework to produce more comprehensive permission protection mappings.
cross language analysis on android.
a plethora of works have proposed to solve the analysis of cross language code.
fourtouniset al.
scan the binary libraries and cross referenced the information to search the call backs from native code to java.
their work focuses on the jni mechanism alone.
however the android framework provides ipc mechanisms such as aidl which are not considered.
wei et al.
propose a static analysis framework that focuses on performing cross language modeling and generating call graphs for the analyzed apps.
jucify conducts a static analysis approach which extends the app analysis to native codes.
zhou et al.
provide a hardware assisted analyzer to solve the issue that the native code analysis for native code in apps is incomplete.
nevertheless these works are only applicable to android apps which are far less complicated than the android framework we analyzed.
specifically the cross language analysis approaches analyze the communication between the apps native libraries and their java side components.
the main technical challenge is intercomponent communication handling for example the invocation between java and native side methods through jni.
our work analyzes the communication between system components.
one of the main technical challenges is inter procedural communication between system components such as aidl binder.
conclusion we proposed a novel approach natidroid to facilitate the crosslanguage analysis of the android framework.
natidroid identifies the entry point pairs of both java and native sides of the android framework where both sides are communicated through jniand aidl based mechanisms so natidroid builds the cross language icfg on the overall android framework java native code .
based on the cross language icfg we extracted native triggered permission specifications and created the protection mappings in the native code to complement existing java based mappings.
we further applied our new mappings to detect permission over privilege vulnerabilities in a large dataset consisting of more than android apps.
we finally show that using the mapping derived bynatidroid can identify a significant number of false results existing in the state of the art such as axplorer andarcade .
782esec fse november singapore singapore c. li x. chen r. sun m. xue s. wen m. e. ahmed s. camtepe y. xiang