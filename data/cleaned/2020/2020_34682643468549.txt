soundand efficient concurrencybugprediction yancai statekey laboratory of computer science instituteofsoftware chinese academy of sciences and university of chinese academy of sciences beijing china ycai.mail gmail.comhao yun statekey laboratory of computer science instituteofsoftware chinese academy of sciences and university of chinese academy of sciences beijing china yunhao ios.ac.cnjinqiuwang statekey laboratory of computer science instituteofsoftware chinese academy of sciences and university of chinese academy of sciences beijing china wangjq ios.ac.cn lei qiao beijing institute of control engineering beijing china fly2mars .comjens palsberg universityof california losangeles ucla usa palsberg ucla.edu abstract concurrencybugsareextremelydifficulttodetect.recently several dynamictechniquesachievesoundanalysis.m2isevencomplete for two threads.
it is designed to decide whether two events can occur consecutively.
however real world concurrency bugs can involvemoreeventsandthreads.somecanoccurwhentheorder of two or more events can be exchanged even if they occur not consecutively.we proposea newtechnique seqcheck tosoundly decide whether a sequence of events can occur in a specified order.
theorderedsequencerepresentsapotentialconcurrencybug.and several known forms of concurrency bugs can be easily encoded intoeventsequenceswhereeachrepresentsawaythatthebugcan occur.toachieveit seqcheck explicitlyanalyzesbranchevents and includes a set of efficient algorithms.
we show that seqcheck issound anditisalsocomplete ontraces oftwothreads.
wehaveimplemented seqcheck todetectthreetypesofconcurrencybugsandevaluatediton51javabenchmarksproducingupto billionsofevents.comparedwithm2andotherthreerecentsound racedetectors seqcheck detected 333racesin30minutes while othersdetectedfrom130to285racesin6to12hours.
seqcheck detected deadlocks in seconds.
this is only one less than dirk but dirk spent more than one hour.
seqcheck also detected atomicityviolationsin20minutes.theevaluationshows seqcheck can significantly outperform existing concurrency bugdetectors.
ccs concepts softwareanditsengineering multithreading scheduling software testinganddebugging .
corresponding author permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
esec fse august 23 28 athens greece copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
concurrency bugs data races deadlocks atomicity violations acmreference format yancai haoyun jinqiuwang leiqiao andjenspalsberg.
.sound andefficientconcurrencybugprediction.in proceedingsofthe29thacm jointeuropeansoftwareengineeringconferenceandsymposiumonthefoundationsof software engineering esec fse august 23 28 athens greece.acm newyork ny usa 13pages.
introduction concurrentprogramscanexhibitdifferentthreadinterleavingsdue to non determinism bringing concurrency bugs .
they can bringharmfulresults oreven disasters .
todetectconcurrencybugs onepromisingdirectionwouldbea soundpredictiveanalysis .theyrunaconcurrent programtogeneratetracesconsistingofdifferenttypesofevents.
they then consider the dependencies of events and model such relationseitherasconstraints ordirectedgesingraphs or comparable vector clocks .
and a feasible solution or a feasible topological order or a pair of conflicting vector clocks is takenasaproofoftheexistenceofarealconcurrencybug.different modelsofferdifferentabilitiesandsufferfromdifferentweaknesses.
for example constraint solver based ones are able to check values inmemoryaccessevents producingalargerconcurrencycoverage but they rely on heavy constraint solvers to guarantee their soundness and completeness.
to be efficient these techniques usually analyze a segmentation e.g.
every 10k consecutive events of a trace .graphbased onescanbecomplete givenatraceof twothreads overfull traces but are usually inefficient.vector clockbasedapproachesare efficient but often incomplete.
thispaperfocusesonefficient sound andcompleteapproaches.
to the best of our knowledge m2 is the state of the art one.
however m2islimitedtodataracepredictiononly ormoreprecisely it is limited to predict the kinds of concurrency bugs involving two events that should occur consecutively.
data races right fall into this category because it is defined to be two conflicting memory accessesoftwothreads that occur consecutively.
esec fse august 23 28 athens greece yancai haoyun jinqiu wang lei qiao andjens palsberg furthermore othertypesofconcurrencybugssuchasdeadlocks atomicity violations and order violations are not limitedtotwoeventsortwothreads.theydonotrequirethatall involved events occur at the same time.
for example two wellprotected events can form a concurrency bug if their orders are reversed however itfitspoorlywiththedefinitionofdataraces.
it seems highly nontrivial to extend m2 to support the detection of common concurrency bugs see section .
in this paper we address the above challenge by presenting seqcheck an efficient and sound tool to analyze full traces to detectvarioustypesofconcurrencybugs.
seqcheck iscomplete when there are two threads.
the core of seqcheck is an algorithm to decide whether a sequence of two or more events is feasible overa given trace.
such a sequencecanvaryfordifferenttypesof concurrency bugs but can be easily designed it can have events from any number ofthreads.
seqcheck firstly calculates an event set that is necessary for determining the feasibility ofthe sequence.
secondly seqcheck constructsagraphtoreordertheeventsintheset.itappliesfour types of orders as edges including program orders observation orders onpairsofwriteandread lockorders andtheordersfrom theinputsequence.
finally itcomputesaclosurefortheseorders onthegraph.ifnocycleisfoundintheprocess seqcheck soundly decides that the sequenceisfeasible indicating atrue bug.
seqcheck isinspiredbym2 however theessentialdifferencebetweenthemisthatm2targetsdecidingwhethertwoevents can be reordered one after another whereas seqcheck targets deciding whether a sequence of events in a specified order is feasible nomatterwhethertheycanoccurconsecutively.note iftwo events can occur consecutively they are exchangeable but two exchangeable events may be unable to occur consecutively.
as a result m2produces asubsetofthat of seqcheck .
toachievetheabovegoal seqcheck considersbranchevents.
besides forapotentialconcurrencybugwithmorethantwoevents that have multiple ways to occur seqcheck natively supports a divide and conquer manner to decide it.
that is seqcheck can decide a potential concurrency bug to be true if it decides thatanysequence correspondingtoauniquewayforthebugto occur isfeasibleinatrace.instead ifanytwoeventsofasequence canoccurconsecutivelyindifferenttraces m2cannotdecidethat thesequencecanbefeasibleinthesametrace.weshowthatthe algorithm seqcheck iso n2 log n wherenis the number of events.andwe presentaproofto show that seqcheck issound andisalsocomplete when there are twothreads.
we have implemented seqcheck for java programs to detect general concurrency bugs.
we selected two sets of previously used java benchmarks with from and from .
they produced traces up to millions or even billions of events.
on detecting data races and atomicity violations we compared seqcheck with m2 and other three sound algorithms shb wcp syncp and with atomfuzzer on the first set of benchmarks respectively.
on detecting deadlocks we compared seqcheck with dirk a sound deadlock prediction tool on the secondsetofbenchmarks.
theexperimentshowsthat seqcheck significantlyoutperformed othersonbotheffectivenessandefficiency.onracedetection seqcheckdetected races in minutes the others detected from130to285racesinatleast6hours.thelatterfourreachedourtime limit 1hour onalmostalllarge scalebenchmarks.ondeadlock detection seqcheck detected ones in seconds this number is only less than that by the constraint solver based dirk that are expected to detect more than ours .
however dirk spent hour.seqcheck detected30 atomicity violations in the first set of benchmarks whereas atomfuzzer detectednone orcrashed.
in summary we make the following contribution weproposeadynamic approach seqcheck thatmodelsprogram branchesand predictsthe feasibilityofeventsequences.
thus weturnthedetectionofconcurrencybugsintoaquestionoffeasibilityofaneventsequence.andweproposehow to detectthree types of concurrency bugs.
we present an analysis to show that seqcheck is sound and is also complete when thereareonlytwothreads andfurther showseqcheck has atime complexityof o n2 log n .
wehaveimplemented seqcheck andcompareditwithseveral recentsoundworks.anexperimentconfirmsthat seqcheck issignificantly more efficient andeffective thanothers.
preliminaries and motivations .
basic definitions thissectiondescribesasetofdefinitionsandnotationsaboutsequentially consistency memory models that are similar to definitionsfoundinprevious papers .
execution trace .
an execution trace represents a linearizationofamultithreadedprogramexecution.itisatotallyordered listofitsevents forwhichtheorderisdenotedby .for atrace we uset todenote thenumberofthreadsintrace and use tto denote the projection of on thread t t .
each event e has a thread id and a event id which can be extracted by tid e eid e .tid e denotes the thread which ebelongs.eid e denotesthe index of ein tid e .
there are three categories of events other synchronization eventscan be handledsimilarly memory event write read denoted by wr t x rd t x w indicates a thread twrites to a memory location x or read from a location xwhere the last write event to xiswandw can be .
lock event acquire release denoted by acq t l rel t l indicates a thread tacquires or releases a lock l. other implicit synchronizationscan be treatedbasedonthis twoevents.
branch denoted by br t indicates there isanother path that isnotfollowedbythread t.note thisincludesboththeexplicit conditionalbranchesandtheimplicitbranches methodcalls memoryusage inobject orientedprogramminglanguages .
we denote the set of event types as wr rd acq rel br and use op e toextractthetypeofanevent e.wesupposethateachthread startsandends withabranchevent sand e respectively.
intherestofthispaper wemayomitthethreadidofaneventor thewriteeventinareadeventifthereisnoambiguityinthecontext.
weassumethatlock acquire releaseeventsarewell nested i.e.
if athreadhasacquiredmultiplelocksatatime thecorresponding lockrelease eventsmustbe inthe nestedmanner.
256soundandefficient concurrency bugprediction esec fse august 23 28 athens greece we define a set of auxiliary functions.
for a memory lock event e we useloc e to get its location lock.
we denote the set of all locations of a trace asl .
for a read event e we useobs e and obsx e to denote the involved write event in a trace or a set ofevents x.foralockacquire releaseevent e weusematch e to denote the correspondingpaired lock release acquire event.
we uselastop x e andnextop x e to denote the most recent event that operates on xbefore and after ein program order respectively whereop wr rd acq rel br wherexandopcan be omitted indicating any eventtype andany location respectively.
we usee andexto denote all events in a trace and all events in a set x respectively.
and we use erd x ewr x eacq x erel xto denotethesetofallreadevents allwriteevents alllockacquire events and all lock release events in x respectively.
we define the operation on them as the projection on a location lock e.g.
erd x e erd x loc e x .
two events e1ande2from different threads are conflicting denoted as e1 e2if they are memory events on the same location and at least one of them is a write event or they are lock eventsand have the same lock.
we use confset x e to find theconflictingeventof einaneventset x weonlyusethisfunction when there isonly one conflicting eventin x .
forsimplicity weviewasequenceofevents e1 e2 en asanarray e.g.
referstoe1 .asequence isareadvariant of another sequence denote as if and for i we have either or rd t x w rd t x w .asequence isw rconsistent if foranyits read event e rd t x w wis identical to the most recent write event onxbeforeein .
that is a read event always reads a value fromthelatestwriteeventtothelocation.aprefixofasequence e1 e2 en isasequence e1 e2 ei where1 i n or .
we denote the set of all prefixes of asprefix .
note that atrace isalsoregardas an eventsequence.
.
orders given atrace we definethree basic types oforders programorder po.
e1 e2 e tid e1 tid e2 e1 e2 e1 poe2 i.e.
among thread local events .
observation order oo.
letx e e erd x e rd t x w w ooe.
lock order lo.
letx e e1 e2 eacq x e1 e2 match e1 loe2 match e2 loe1.
.
motivations m2 is a sound predictive technique for race detection and is alsocompletewhenthereareonlytwothreads.forapairofconflict events e1 e2 m2 firstly builds a graph where vertexes are events that may affect the execution of e1ande2and edges are defined as three types of orders.
m2 then applies a closure algorithm on thegraph.afterthat ifthereisnocycleformed m2decidesthat the two events can occur at the same time and they form a race.
otherwise itmakesnodecision unlessthe tracehastwothreads and inthiscase m2decidesthatthetwoeventsdonotformarace .
m2decideswhethertwoeventscanoccurconsecutivelytodetect races.
even if it can be extended to further check whether more events from different threads can occur consecutively detectingt1t2 acq l rd y wr x rel l 5acq l 6rd x 7wr x 8rel l 9wr y t1t2 sync l x y sync l x y figure atrace right oftwothreads left .
commonconcurrencybugsrequirestodeterminewhetheranorder of two or more events can be reordered.
this cannot be resolved bym2.let s discuss this point.
figure1showstwothreadsandonetracewherethread t1executesafterthread t2.let sdenoteeacheventinthetracebytheir line numbers.
m2 s purpose is to check whether e2ande9is a race.
m2 firstly computes a set of dominating orders.
for e2 the set is empty as no event before it can affect the execution of e2.
for e9 evente6dominates it where e6reads a value on xwritten by e3.
similarly we have that e3is dominated by e2.
as a result the setdominating e9containse2.thisindicatesthatthetwocannot execute consecutively.
m2 decides that they do not form a race.
obviously thisconclusionisfalsegiventhatthetracestemsfrom the code onthe left.
next supposethatm2isextended todeterminetheorders say whethertheexecutionorderfrom e2toe9canbereversedintothat frome9toe2inanalternativeexecution.obviously thistargeted order and the concluded dominating order i.e.
e2dominates e9 together form a cycle.
as a result m2 decides that the target order cannot be reversed.
however it is obvious again that the target frome9toe2 order isfeasible inadifferenttrace.
thereasonfailingm2ontheabovetwoexamplesisatitsexecutionmodel.m2followsthemodel thatrequires every read event in an inferred partial execution should read a value written by the same write event as the original trace any other inferred partial execution violating it is unsound i.e.
not guaranteed to be feasible .
that is the model implicitly assumes that any read event is followed by a branch and reading a value from a differentwriteeventmayproduce executiondivergence.
tomakem2workableintheaboveexample branches mustbe explicitly considered.
actually some constraint based approaches alreadyconsiderbranches wheretheyrequire areadevent shouldreadthesamevalue thatcanbefromdifferentevents as that in the original execution and any violation to it may produce an infeasible trace.
this results in a huge search space for largescaleprogramsandconstraint solverscanbeinefficientonthem .besides itisdifficulttoconsiderconstraints e.g.
thelogic operations like or for graph basedapproacheslike m2.
supposem2isadaptedtorecognizebrancheventsandcheckthe aboveorderreversingproblem.then therearefourbranches right before andright after eachof thetwo events tobe analyzed.
one adaptionform2istoinferracesfortwoeventsthroughdeciding whether any two branches can be executed consecutively.
this requires an analysis on the four pairs of branches.
however the twoareinconsistent i.e.
whetherthetwobranchescanbeexecuted consecutivelyandwhether the twoeventscan form arace.
257esec fse august 23 28 athens greece yancai haoyun jinqiu wang lei qiao andjens palsberg forexample figure 2showsatrace includingbranchevents.
for the two events e12ande6 the adapted m2 can decidethat two branchesbeforethem i.e.
e11and s cannotexecuteconsecutively duetothewrite readorderfrom e7toe10 moreover thetwoevents cannotformaraceforthesamereason.now suppose isanother tracewhichisthesameas exceptthatweswap e6ande7 namely e wr x ande wr p in .
now considering the two events e12ande .theadaptedm2candecidethatthetwobranchesbefore them i.e.
e11and s cannotexecuteconsecutivelyduetowritereadorderfrom e 6toe10 but thistime thetwoeventsindeedform a race.
we can see from these two cases that there is no consistent conclusion on whether a race can be decided by deciding whether the involved branches can be executed consecutively.
we can also drawthesameconclusiononothercases e.g.
thebranchbefore one eventandthe branchafter the secondevent .
anotherlimitation isthatm2isnot designedforcheckingmultipleeventsfromtwoormorethreads.saythatwewanttocheck whetherthethreeevents e6 e12 e18infigure 2canexecuteinthe order e6 e18 e12 this pattern can be a concurrency null pointer exception .ifm2isadaptedtodecidewhethereachtwoofthem canform arace itwillbechallengingto provethe correctnessbecause each isolated conclusion is drawn under different conditions e.g.
write read orders .
ourapproach wefirstpresentasetofdefinitionsandthenpresentouralgorithms to check the feasibility of an event sequence.
we use the trace andthe sequence e6 e18 e12 infigure 2to illustrate them.
.
feasible sets open lock set.
given a set x e of a trace and an event e eacq x ifmatch e x we sayean open lock event.
we use open x todenotethesetofallopenlockeventsin x.forexample letx e15 ontrace we have open x e15 e19 .
producible set pset .
given an event set x e of a trace and a set y x we define a producible set orpsetfor short pset x y p1 p2 where p1 x erd y and p2 e e rd t x w rd t x w erd y w ewr x intuitively pset x y haveexactlythesamesetofeventswith xexcept that some of its read events have different but valid write events note in p2 w canbethesameasthatin e .inparticular if y we have pset x y x p1andp2 .
for the running example let x e1 e18 rd p e12 and y e18 rd p e12 in the setx1 e1 e rd p e6 is apsetofxbuttheset x2 e1 e rd p e4 isnotapsetof xas the event e6isinewr x e6 e12 but the event e4isnot.
the reason for introducing the set y xis that we consider branch events explicitly.
hence there should be a cut over a set ofeventssuchthat allreadeventsinonepartshouldreadthe samevaluesasthatintheoriginaltracebut somereadevents in another part can read different values as long as they do not produce executiondivergence.we willdefinesuch a ylater.
to correlate events in the two sets xandpset x y we use s e foranyevent e pset x y todenoteitsoriginalevent ein x.notice that for an event e pset x y ife p1 thens e e.t1t2t3 acq l2 wr x rel l2 wr y acq l2 wr p wr x rel l2 9acq l1 10rd x 11br 12wr p 13wr y 14rel l1 acq l1 rd x br rd p acq l2 rd y rel l2 rel l1 figure a trace and a sequence of events e6 e18 e12 .
givenx e in a trace lety xandx pset x y we say thatx isafeasible set orfsetfor short if itsatisfies program orderclosed orprefix closed e x e2 x ife2 pos e then e x s e e2.
observation feasible e rd t x w erd x we have w x .
lock feasible e erel x we have match e x and eacq1 eacq2 eacq x eacq1 eacq2 ifmatch eacq1 x match eacq2 x thenloc eacq1 loc eacq2 .
thedefinitionoffsetrestrictsasettobefeasiblebyconsidering program orders observation orders and lock orders.
for the running example let x e andy e4 e12 e18 then we havex e1 rd p e6 e19 rd y e4 e21 isafset of x. .
feasible traces givenanexecutiontrace wesaythataneventsequenceover e denotedas isafeasible trace if prefix or ewhere isfeasibleand isw rconsistent and the following three conditions are satisfied a lett tid e br lastbr e e t and br then such that t br prefix t t e .
b op e acq then ex stse open e loc e loc e .
c op e rel then e open e t loc e loc e .
the condition 2arequires that the appended event emust be exactlythenexteventof texcept ifitisareadeventandthereis nobrancheventafter it itcan read differentbut valid values.
.
feasible partialorders afsetcanbelinearizedintoaneventsequence.however sucha sequence is not guaranteed to be a feasible trace defined in the last subsection.
this section defines a set of necessary partial orders such that if a sequence is linearized from a fset by reserving all partialorders over the set then itisafeasible trace.
givenatrace andapartialorder poverafset x pset x y wherex e andy x we saypis atrace respecting partial orderoverx if prefinestheprogramorderin whenrestricted 258soundandefficient concurrency bugprediction esec fse august 23 28 athens greece e1 raw e2 a w w w r e1 e2 b acq1 rel2rel1acq2 e1e2 c acql1 acq m1 acq m2 acql2brbr figure anillustrationon theobservation closure.
toeventsin x foreveryreadevent r x ifr x ywehave obsx r pr and foreverylockacquireevent eacq ex such thatmatch eacq x and for every lock release event erel x iferel eacq thenerel peacq.we writethat prespectsx .
trace closedpartialorders.
givenatrace andasetofevents x e lety e x nextbr e x andpbeatrace respecting partialorderoverafeasiblesetofevents x pset x y .wesay thatpistrace closed if itsatisfiesthe following observation closed .
foreveryreadevent r rd t x w erd x such that s r y w ewr x w pr.
for every read event r erd x such that s r y letw obsx r beingconflictingwith r.foreverywriteevent w ewr x w a ifw prthenw pw b ifw pw thenr pw .
lock closed .
for events erel1 erel2 erel x and their matched acquireevents eacq1 match erel1 andeacq2 match erel2 iferel1 eacq2 thenerel1 peacq2 erel2 peacq1.
in the definition if there is no branch event after the read event r the observation closed property requires that rcan happen after any write event.
in other case it requires that any write should occur either before or after both events from a pair in observation order obsx r r on the same location as shown in figure a and b .thisisdifferentfromthatofm2thatappliessameruletoall readevents.figure a illustratesthatanywrite w shouldoccur beforew obsx r as it alreadyoccurs before r due to the order e1 e2 .
figure b illustrates the second case.
the lock closed property requires two conflicting critical sections not overlapping.
the order of the two sections can be obtained when the order of two events in them e1 e2 is known as illustrated in figure c .
then we can infer that erel1occurs before eacq2.
other cases e1 occurs after erel1 e2occurs before eacq2 have similar results.
given a feasible set of events x e from a trace its fsetx may have zero to multiple trace closed partial orders.
if it has one wecallthesmallesttrace closedpartialorder pastheclosureof x andalsosaythat pisafeasiblepartialorder overx .there exists at most one smallest trace closed partial order which can be provedbycontradiction .
.
the seqcheck algorithm this section presents the detailed algorithm of seqcheck and also compareitwithm2.
seqcheck decidesthefeasibilityofanevent sequence that encodes a potential concurrency bug.
we allow two kinds of ordering to be specified by an input the orders betweentwoeventsinagivensequenceand whetheraneventnot fromthesequencecanoccurinbetweenanytwoeventsfromthe sequence.the secondisreferredto as adjacency set.
formally given a trace an event sequence e1 e2 ...en overapset andasetofpairs a ei ej ei ej e seqcheckalgorithm1 computepotentialfset 1f tohold afset candidate.
2m tomapbranch events to write events.
3l tohold aset ofopen locks.
4q atemp queue to keep intermediate events.
5foreache e doq.push e 6fori e to1do 7l open e e e po 8foreachej l confset l ej ej do q.push match ej l l ej 11l l l 12while q.empty do 13b 14ecur q.pop 15fore e f e poecurdo ifop e brthenb b e else ifop e rd nextbr e then eb nextbr e m .insert obs e else ifop e acqthen lete e e e e poe tid e tid e tid e tid e ife thenq.push match e else ife poethen x the index of e in foreachi x 1to1do l open ej e ej po ec confset l e q.push match ec q.push match e f f e 31foreachei bdo q.push m push allevents mapped from ei.
removekey eifromm 34foreacher erd f nextbr er fdo ifnowriteeventcan be observedby erthen ew the first conflicting eventof erin thread tid obs er q.push ew 38returnf answerswhetherthereisafeasibletrace thatsatisfies anda that is for i j n we have ei ejand for a pair e1 e2 a we have ex stse e such that e1 e e e2.
overall seqcheck computes a set of events as a candidate of fset algorithm andthencheckswhetherthereisasetoffeasible partial orders over the candidate algorithms and4 if so the eventscan be reorderedto obey the given sequenceof events.
generate a candidate fset.
algorithm 1computes a set of events fas a candidate fset.
it starts from an initial set of all events in and iteratively includes additional events according to the three requirements in the definition of fset.
in the iteration m maps a branch event to a set of write events.
that is the key of themapisabrancheventandthevalueisasetof write events.it indicates that any read event before a branch event in program order read a value from one of the mapped write events.
hence if abranchisincluded allmappedwriteeventswillbe included.
additionally for any open lock event enot from threads in the algorithm includes the release event match e and all other eventsbefore itbyprogram order.
259esec fse august 23 28 athens greece yancai haoyun jinqiu wang lei qiao andjens palsberg algorithm2 computelockorders f 1clo tohold ainitial setoflocksemantic orders.
2l tokeep asetofintermediate open lockacquisitions.
3foreachi e to1do 4l open ej e ej po 5ecur next 6whileecur f l do ifop ecur rel match ecur po then ea match ecur ec confset l ea ifec then clo clo ecur ec l l ea else ifop ecur acq confset l ecur then l l ecur ecur next ecur 16l l l 17l open f 18foreachec erel fdo 19ea confset l ec 20clo clo ec ea 21returnclo table state changesofalgorithm 1on trace .
line5 q e6 e18 e12 l f m line6 q e6 e18 e12 e22 l e9 e5 f m line12 q l f e1 e15 m e e12 note inourdefinitionoffset therearetwoparts xandy.the resultfis actually the x in definition and for any remaining key eb that is not removed in line all read events in between eb andits previous branchofthe same threads belong to y. compared to m2 that has a rconealgorithm to find a set of potential events starting from two given events our algorithm focusesonasequenceofevents.thisbringsthefollowingmajor differences we include all events in line5 to be part of f whereas m2 excludes the two events of a potential race we process alleventsin inthereverse orderasthat are expectedto occur line whereas m2 can start from any of two events we consider read events in two categories.
for read which is followed by branch event in f we include the corresponding write event.
for the other case we heuristically include some write so that the readeventhaveatleastonewritetoobserve.however m2treats readeventsthesameandincludesallwriteeventsifthereadevents are included.
the three points distinguish our algorithm from that of m2.
they allow us to model how branch events can affect trace feasibilityandhowan eventsequencecan be considered.
on the running example algorithm 1runs as follows and we show how q l f andmchanges in table .
recall that each thread in starts and ends with a branch.
the ein table1is the end branch in thread t2.
line initializes qto include all events in next the loop at line appends e9intolin first iteration.
when processing e18in the second iteration e9 lis a conflicting event ofe15andmatch e15 e22is appended into q in the third iteration e5isappendedinto l e9 e5 .theiterationatline12 pops all events in qas well as other events that occurred before theminprogramorder theyareincludedinto f.finally wehave f e1 e15 .table state changesofalgorithm 2on trace .
cpo coo e7 e10 e7 e16 cso e6 e18 e18 e12 line3 clo e22 e9 e8 e19 l e9 e19 line17 clo e22 e9 e8 e19 l e9 initializeasetofpartialorders.
seqcheck nextchecks whethertheset fcanbeafset.itfirstconstructsthreesetsofpartial orders on faccording to the definition of the trace respecting partialorders programorder cpo observationorder coo lock semantic order clo.
the program order cpocan be easily constructedaccordingtotheoccurrenceorderofeventsfromthe same threads in f. the observation order coois defined to be obsf e e e erd f nextbr e f .
thelockorder cloisconstructedbyalgorithm .unlikem2 the lock orders consist of the intra thread lock orders among open lock events for events in lines of the first for loop at line and the lock orders between the open lock event for the eventsin andforallothersin f thefor loopatline .theintra lock orders must be constructed by considering the sequence order.
finally seqcheck includes the set of input orders csoin wherecso ei ei i e .
table2showsthefour sets oforders initsfirstrow giventhe setf.note although fincludestheevent e20 rd y thereisno observation order from obs e20 i.e.
e13 to it this is because by ourdefinition wehave nextbr e20 f.thesecondrowintable shows thestate changesofalgorithm .fortheexample.by the algorithm during its second iteration the for loop at line as the evente15and its matching event e22are both included in f the algorithm inserts a intra thread lock order e22 e9 .
in the third iteration theintra threadlockorder e8 e19 isincludedduetothat e18ishappenedafter e6in andaconflictpair onlock l2exists.
computeaclosure.
giventhefoursetsofpartialorders seqcheck computes a closure according to the definition of the trace closed partial order as shown in algorithm .
before introducingthealgorithm wefirstintroduceagraphdatastructure .
allpartialorders willbe representedas edges onsuch agraph.
letgbeadirectedacyclicgraphand xbeasetofevents.the vertexes of gconsist of all events exand the edges are defined to be asubsetofex ex.we defineasetof operations over g g.insert e1 e2 inserts an edge e1 e2 intog.
g.reach e1 e2 returns trueif there isapathfrom e1toe2.
g.succ e t returns the earliest successor e ofein thread t whereg.reach e e returns true.
g.pred e t returns the latest predecessor e ofein thread t whereg.reach e e returns true.
thesefouroperationsover gcanbedonewithan o n log n algorithm throughfenwick tree wheren ex .
given a trace a graphg an initial set of orders c and a adjacencyseta algorithm 3iterativelyexamineseachpartialorder inc inserts it into g and closes it according the definition of trace closedpartialorders.theseareshownasfunctions insertandclose obsclosure andlockclosure .
for observation closed rule algorithm 3only close the rule .
rule will be consider in algorithm .besides itfurtherclosesanyadjacencyorders lines 22 26 .
that is for any pair of events e1 e2 a if an event e 260soundandefficient concurrency bugprediction esec fse august 23 28 athens greece algorithm3 closeorders g c a 1letf g.f 2foreachx e1 e2 cdoqc.push x 3while qc.empty do ex ey qc.pop 5ifg.reach ey ex then return false 6else if g.reach ex ey theninsertandclose ex ey 7returntrue 8function obsclosure e1 e2 9foreachx loc e e erd f ewr f do ew lastwr x e1 er nextrdx e2 ifew obs er nextbr er fthen qc.push ew obs er e w nextwrx e2 foreachei erd f obs ei ew nextbr ei fdo qc.push ei e w 17function lockclosure e1 e2 18foreachl loc e e eacq f erel f do eacq lastacq l e1 erel nextrel l e2 qc.push match eacq match erel 22function adjacencyclosure a 23foreach e1 e2 ado foreacht 1tot do qc.push g.pred e1 t e2 qc.push e1 g.succ e2 t qc.push g.pred e2 t e1 qc.push e2 g.succ e1 t 27function insertandclose e1 e2 28g.insert e1 e2 29obsclosure e1 e2 30lockclosure e1 e2 31fori j 1tot i tid e1 j tid e2 do epred esucc g.pred e1 i g.succ e2 j g.insert epred esucc obsclosure epred esucc lockclosure epred esucc 36adjacencyclosure a occurs before or after one of the two event it also occurs before or after anotherone.algorithm 3fails whenever itfinds acycle.
fortherunningexample thegiveninitialsetofordersareshown in figure a except the two from events of t2 where we do not explicit show the program orders .
the two orders are produced by algorithm .
considering that obs e16 ise7and the event e2occurredbefore e16byprogramorder algorithm 3reorderse2 beforeobs e16 resultinganorder e2 e7 .whencomputingthe lockclosure ofthis order an order e3 e5 isinserted.
the complete seqcheck algorithm.
algorithm 4describesthecomplete seqcheck .givenatrace aneventsequence andanadjacencyset a itdrivesalgorithms and3tofinda closure.
the order specified by the input sequence of events is denoted as cso.
then algorithm 4check if the read event which arenotfollowedbybrancheventin f hasawriteeventtoobserve.
if not it heuristically let erobserve the first conflicting write in threadtid obs er andcalculatestheclosure.theseoperations are according to the observation closed rule .
if it succeeds it additionallyconsidersallotherconflictingbutunorderedpairsof events line .
such pairs are inserted into gaccording to their occurrence orders in .
afterseqcheck finishes if there is a cycle itreturns otherwise itreturns alinearizationofthe graph g.t1t2t3 acq l2 wr x rel l2 wr y acq l2 wr p wr x rel l2 acq l1 rd x br rd p acq l2 rd y rel l2 rel l1 17acq l1 18rd x 19br 20wr p t1t2t3 acq l2 wr x rel l2 acq l1 wr y rd x acq l2 br wr p wr p wr x wr y acq l1 rel l2 rel l1 rd x br rd p acq l2 rd y rel l2 rel l1 a b figure the closure for trace in a and one of its corresponding execution in b .
for the running example seqcheck produces a set of orders as shown in figure a .
as there is no cycle found and no additional eventtobeordered theseordersindicatethattheset fproduced byalgorithm 2isa fset.
and itdecides that the inputsequence isfeasible andfigure b showsatrace that satisfies .
in summary as reflectedin algorithms and3 m2canonly handleadjacencyrelations while seqcheck canhandlebothadjacencyrelationsandorderrelations.thatis m2canonlydetect that events happen consecutively while seqcheck can detect that eventshappeninaparticularorder aswellasconsecutively.and seqcheck has anovel definitionof feasible sets.
.
algorithmanalyses algorithmtimecomplexity.
seqcheck consistsoffouralgorithms.
let nbe the size of trace the total number of events in .
algorithms 1has two major loops.
in the first major loop theopen map can be initializedin o n by scanning allevents once.thefunction confset l e canbeimplementedin o log n .
the second majorloop the whilepart pushes eacheventatmost onceinto q and allthe operationsinloop canbeimplemented in o log n .so both parts have an o n log n time complexity.
inalgorithm eachfor while loopprocessesatmost nevents.
for each event there is at most a call to confset l e .
that is o n log n in time complexity.
algorithm 3computes a closure fortheedges.thereareatmost n2edgesandeachisinsertedinto g once.thatis n2 log n intimecomplexity.algorithm 4hastwo loop processingatmost n2eventpairs.foreachpair itinsertsat mostoneedge.hence seqcheck has n2 log n timecomplexity.
next wegiveananalysisonthesoundnessandthecompleteness ofseqcheck .
theorem .
soundness .
given a trace an event sequence andanadjacencyset aovere ifalgorithm 4returnsalinearization then is afeasible tracethat satisfies anda.
proofsketch.
weshowthat isafeasibletracebyinduction.
let e prefix such that is feasible i.e.
in thebasestep .whenappending eto weshowbelowthatno condition ofthe definitionof feasible traces isviolated.
261esec fse august 23 28 athens greece yancai haoyun jinqiu wang lei qiao andjens palsberg algorithm4 seqcheck a 1f computepotentialfset 2c cpo coo clo cso csois a set of orders over .
3g f 4if closeorders g c a then return 5foreacher erd f nextbr er fdo 6if ex stsew ewr f g.reach ew er then e w the first conflicting eventof erin thread tid obs er if insertandclose e w er then return 9foreachunorderedpair e1 e2 g e1 e2 e1 e2do 10if insertandclose e1 e2 then return 11 atopological orderof g alinearization of g 12return first ifeis a read event algorithm 4initially sets an order obs e e resultinginanedgefrom obs e toeing algorithm 3ensures that any other conflicting write events are ordered either beforeobs e or aftere.
therefore no other conflicting write eventappearsinbetween obs e andein .hence thesequence eisw rconsistent.
second if eis a lock acquire event algorithm 1ensures that therearenotwoopenlockeventson loc e algorithm 3ensures thatallotherconflictinglockreleaseoracquireeventsarebefore eor aftermatch e .
ifeis not closed they before e. the similar analysisapplieswhen eisalockreleaseevent.hence theconditions 2band2cindefinitionoffeasible trace are not violated.
third algorithm 4keeps program orders according to algorithm1 when an event e is included all other events occur before e by program orderare included.
hence we have e t e tand the sequence t t e prefix t .
and we can rewrite tto be t br form in definition that is also in prefix t .
thus the condition 2aisnot violated.
inductively we show that is a feasible trace when we have .
finally as algorithm 4includes the order by and algorithm closes adjacencyorders according to a satisfies anda.
theorem .
completeness.
given a trace of two threads an eventsequence andanadjacencyset aovere ifthereisafeasible trace thatsatisfies anda algorithm 4returnsaneventsequence.
proofsketch.
when there are two threads the initial sets cpo coo clo cso theirclosurebyalgorithm theclosure onaare necessary orders to witness .
if no cycle forms after algorithm 4in line seqcheck will check the read events which are not followed by branch event one byone.becausethereareonlytwothreadsin areadeventcan onlyobservethewriteevent beforeitinprogramorder or intheotherthreads.whentheline8needtobeexecuted itmust meet the second case.
in other words there must be no relative writeeventbeforeitinthesamethread.so it sadefinitecaseto add the order from the first conflicting write event of the other thread to the read event.it s anecessary order.
then seqcheck checksothersunorderedpairs.inthisprocedure onlysomecriticalsectionsareunordered.thisprocedurewill notformcycle asanyunorderedcriticalsectionindicatesthattherealgorithm5 detectconcurrencybugs detectdataraces 1foreachpair of conflictingmemory events e1 e2 do 2 last e1 e2 e1 next e2 3a e1 e2 4ifseqcheck a then print adataracedetected detectdeadlocksoftwothreads 6foreachpotentialdeadlock acq1 l acq1m acq2m acq2 l do 7 1 acq2m acq1m acq2 l 8 2 acq1 l acq2 l acq1m 9ifseqcheck 1 seqcheck 2 then print adeadlockdetected detectatomicityviolationsofthe pattern w w r 11foreachpotentialatomicity violation w1 w2 r do 12 w2 w1 r 13ifseqcheck then print an atomicityviolation detected are no conflicting event pair to dominate two section.
actually orderingthemisuseful for linearization.
finally algorithm 4returns a linearization of g i.e.
an event sequence.
note if there are additional threads there may have conflicting criticalsectionsthatwillbeincludedbyalgorithm .ordersamong these events may not be necessary to witness a sequence and a cyclemaybe introduced.
improve performance seqcheck cansufferfromanoverheadthatstemsfromhandling a large number of orders and event pairs in searching for any unordered events that are part of potential bugs .
m2 adopts an optimization to only consider pairs of conflicting events that are neitherprotectedbycommonlocksnororderedbytrace respecting partial orders.
the optimization is in a pre process phase under an o n2 log n wherenisthe number of events algorithm.
wealsoincludeapre processphase.however weconstructa graphg to have aninitial setof program orders andobservation orders andthen tocomputeatransitive closure withconsidering branches on g .thenfrom g wecaneasilyidentifypairsofalready ordered events and the remaining pairs are undecided.
the algorithmtoconstructthegraphis o k2 n log n intimecomplexity where kandnarethenumberofthreadsandthenumberof events respectively.moreover pre storingthe observationorders andperformingan de duplication are alsoan acceleration.
detect generalconcurrencybugs thissectionpresentsalgorithm 5thatdrivesalgorithm 4todetect three types of concurrency bugs by encoding theminto sequences ofevents.othertypes can be implementedsimilarly.
detect races.
a race occurs when two conflicting events occurconsecutively.ourworkdecidessequenceofeventsandcannot be directly used to detect races.
algorithm 5introduces two moreevents last e1 andnext e2 .
note thesetwoeventscan be dummy ones as long as they are right before and right after e1 2by program order.
besides there is an adjacency ordering 262soundandefficient concurrency bugprediction esec fse august 23 28 athens greece e1last e1 e2 next e2 w1w2 racql1 acq m1 acq m2 acql2 c b a w1w2 r figure an illustration of part of sequence for three concurrency bugs.
requirement noothereventshouldbebetween e1ande2.itthen produces a target sequence .
obviously the two events form a raceiffseqcheck a returns an eventsequence.
detect deadlocks.
unlike data race any deadlock occurs by following a sequence of events.
hence we only need to check whether a feasible sequence over lock acquisition events only exists.
for deadlocks of two threads algorithm 5generates all two sequences where 1is shown in figure b .
obviously the four eventsformadeadlockiffeitherofthecallto seqcheck returns aneventsequence.fordeadlocksofmorethreads onecaneasily implementanalgorithmtogeneratepossibleoccurrencesequences andto checktheirfeasibilityaccordingly.
detectatomicityviolations.
detectionofatomicityviolation isevenmorestraightforward.itisknownthattherearemultiple patterns .algorithm 5shows how to detect the pattern whereawriteevent w1intrudesintoawrite readpair w2 r .given three events w1 w2 andr suppose that they occur in this order in the algorithm straightforward generates a sequence w2 w1 r andcheckswhetheritisfeasible asillustratedinfigure c .
note figure c shows two cases where the read event rcan be from athirdthread orfrom the thread tid w2 .
evaluation .
benchmarksandtraces wecollectedasetofpreviouslyusedjavabenchmarks where31programswereusedfordataracedetectionandatomicity violations detection.
this set is almost the same set as evaluated before except4werenotfound.onlysomeofbenchmarks in the atomfuzzer paper are available among which we includedfour includingthelargestone.weused20benchmarks injavafrom fordeadlockdetection.werunthetooldirk to generatetraces.
thefirstsixcolumnsoftable 3showthestatisticsofalltraces includingthenumbersofthreads events locations mems locks andbranches.forwell readablepurpose weoptimizedthetable upper case k and m indicates thousand and million magnitude respectively.weclassifyalltracesintofourcategoriesaccording tothenumberofevents n intimecomplexity s bench 1m events m bench from1m to100m l bench from100m to 000m andxl bench 000m events .
.
experimentalsetup we implemented seqcheck in java and compared it with m2 wcp shb and syncp on data race detection.
the four race detectors are published in recent years and syncp is the state of art.section 7hasmorediscussiononthem.theyare available from the release package .
we compared seqcheckwith the sound deadlock detector dirk which is also the state of the art on sound deadlock detection except that dirk is a constraint solver based one.
for atomicity violation detection weonlyfoundanavailabletoolatomfuzzer forcomparison.
atomfuzzer detects potential atomicity violations and then for eachofthem schedulesanewexecutionwithaim to trigger it.
all experiments were conducted on a linux server with two intel r xeon r gold 6148cpus and 256gib ram.
following the work we setupa timelimitofonehour fairlylimitthemaximum usage of memory 80gib for each tools run each tool one by one withguaranteeing no cpu io dense processes runningsimultaneously.weconductedallexperimentfivetimesandtookthe average values.
different scheduling may produce different traces we run the benchmarks onceto collectedthe same setof traces.
resultsondataracedetection .table3showstheresulton racedetection includingthenumberofraces thetimecost andthe max meandistancesofarace i.e.
thenumberofeventsbetween the two events .
the symbols and to indicate the cases with noracedetectedandthecaseswherethetimelimitwasreached respectively.note foreachapproach wecollectedandde duplicated all reported races before it finished or run out of time.
we use seqctodenote seqcheck inresulttablesfromthissubsection.for well readable purpose we use lower case s m h to indicate seconds minutes hoursrespectively.
from table we see that seqcheck performed significantly betterthanothers.oneffectiveness seqcheck detectedthelargest set of races on each group of benchmark.
we have manually confirmedthat seqcheck detectedallracesdetectedbyothersand nofalsepositiveswerereportedby seqcheck ons bench.overall itdetected48moreracesthantheotherfour.someoftheseraces have adistance ofmore than200m.
this shows the advantage of seqcheck by analyzing branch events .
both syncp and m2 detected a similar set of races and .
this is consistent with the previous result .
both wcp andshb detectedasimilar setof races and144 .
onefficiency seqcheck spent30minutesonallbenchmarks whileothersspentfrom6hoursto11.5hours.oneachlargebenchmark except s bench seqcheck isalsothefastestoneexcepton montecarlo andseries.overall seqcheck isnearly 12timesfaster thanallotherapproaches.amongtheotherfour m2spentthemost time .
hours and syncp wcp and shb spent from hours to 7hours.
this result isalsoconsistent withthat of .
anotherobservationisthat except seqcheck allothersreached to to.
and on the xl bench group all run up to nearly or more than hour except m2 on h2.
but m2 has many more to on all benchmarks.
this result is consistent with the features of these four algorithms the three syncp wcp shb are streaming algorithmsandhavealmostalineartimecomplexity butm2 as well as seqcheck is a full trace algorithm where optimizations can be conductedfor it.
results on deadlock detection .table4shows the results on deadlock detection by dirk with window size 10k and seqcheck .
italsoincludes the number of threads andevents.
on effectiveness dirk detected one more deadlock than seqcheck.
in detail seqcheck detected one additional deadlock onvector missed by dirk.
all these are true positives based on 263esec fse august 23 28 athens greece yancai haoyun jinqiu wang lei qiao andjens palsberg table results on detection ofdata races.
benchmarks threads eventsmemslocks branchs races time distance syncpm2wcpshbseqc syncp m2 wcp shb seqc max means bencharray .03s .15s .03s .02s .10s critical .03s .09s .03s .02s .10s pingpong .03s .09s .03s .02s .07s airlinetickets .03s .14s .03s .02s .11s account .03s .10s .04s .02s .11s clean .08s .16s .05s .03s .11s bubblesort .3k .15s .71s .08s .05s .12s .2k .1k boundedbuffer .5k .07s .16s .08s .05s .08s .1k .1k mergesort .9k .2k .08s .17s .10s .07s .11s .4k raytracer .7k .9k .9k .23s .25s .29s .23s .09s .7k .1k bufwriter .9k .6k .63s .38s .46s .24s .18s .9k .8k ftpserver .8k .8k .9k .81s .17s .57s .41s .19s .2k .6k readerswriters .0k .4k .52s 1m33s .09s .07s .42s .2k .2k moldyn .0k .7k .0k .46s 20m54s .05s .07s .34s .0k .3k m benchjigsaw .8m .2k .0k .58s .92s .64s .09s .54s .3k .7k montecarlo .1m850.1k .1m .38s to .15s .58s .97s .5m .2m sunflow .9m .0m .4m 1m13s 9m21s 2m18s 1m44s .33s .0m .0m crypt .0m .3m .8m 5m06s to 6m38s 5m07s .61s .8m .8m l bencheclipse .3m .4m .7k .1m 12m05s 18m32s 8m36s 6m24s .14s .3m .4m xalan .2m .8m .8m to to 9m51s 7m08s 1m56s .2m .1m lufact .6m .0m .7m 11m09s to 15m37s 10m37s 1m25s .1m .5m batik .9m .1m .9k .3m 11m41s 6m01s 15m23s 12m41s .59s lusearch .0m .7m .9m 14m21s to 17m51s 13m46s .16s200.6m .8m pmd .6m .1m .9m 16m07s to 20m28s 16m20s .91s224.4m .6m tsp .1m180.9k .3m 18m36s to 22m25s 17m15s 2m20s .7m .0m series .2m286.4k .1m .12s .65s .00s .19s .17s luindex .0m .5m .6m 27m48s 14m35s 35m56s 27m36s 1m02s .9k .9k xl benchsparsematmult .9m .0m .3m to to to to 5m07s sor .3m .0m .3m to to to to 4m08s .1m .6m avrora .3m864.5k .4m to to to 58m03s 4m52s .8k364.4k h2 .7m .1m .0m to 25m19s to 59m31s 5m16s total .9m96.4m .1k3 .2m 6h59m 11h36m 6h36m 5h57m30m03s our code inspection.
on vector the distance of the deadlock i.e.
the two acquire events is .7m which is very large window and constraint solver based approaches are probably unable to detect.
on all other benchmarks the distance is at most .6k.
hence dirk was able to detect two deadlocks on deadlock andtransfer missed by seqcheck .
on these two deadlocks there are data flows that can be handled by dirk but not seqcheck .
it is challenging to extend seqcheck to handle these cases we leave it as a further work.note somebenchmarkshavedeadlocksbuttheirtracesdo nothaveone andbothtoolsdidnotdetectdeadlocksonthem.
on efficiency seqcheck is significantly better than dirk.
seqcheckspentlessthan6secondsintotalandlessthan2.5seconds oneachbenchmark.however dirkreachedonetoandtookmuch more time especiallyonbenchmarks with 500k events.
resultsonatomicityviolationsdetection .weconfigured seqcheck todetecttheatomicityviolationpattern w1 w2 r as thatshowninalgorithm 5andwesetthedistancebetween w2and rto be at most .
the result is shown in table including the numberofatomicityviolations thetimecost andthemax mean distance.we use to indicateacrash intesting.theresultshowsthat seqcheck finishedinlessthan20minutes and30uniqueonesweredetected.someoftheseatomicityviolations have a distance up to .7m andseqcheck finished in about seconds.
this shows that seqcheck is efficient on detecting atomicity violations.
the results on s bench are also manually confirmedandthey matchthe pattern w1 w2 r .
atomfuzzer i.e.
atomf detected none on all benchmarks anditfrequentlycrashedonmanybenchmarks.wehavealready tried our best to avoid crashes as much as possible.
but it seems noavail.themainreasonofcrashesisthatatomfuzzerdoesnot support java reflection.
related works traditionalunsoundapproaches.
twoearliestworksondata racedetectionarebasedonthehappens beforerelation and thelocksetdiscipline .theformerdefineapartialorderover synchronizationsandiswidelyadoptedinmanydataracedetectors .thelatterdefinesadatarace iftwoaccessesarenotprotectedbyacommonlock .
hybrid analyses combine the two approaches to improve accuracy 264soundandefficient concurrency bugprediction esec fse august 23 28 athens greece table results on detection ofdeadlocks.
benchmarks threads events deadlocks time distance dirk seqc dirk seqc max mean deadlock .02s .07s notadlk .02s .10s picklock .02s .07s hashtable .03s .10s bensalem .06s .07s transfer .02s .10s test .06s .07s stringbuffer .03s .07s diningphi .05s .10s dirkaccount .15s .10s log4j2 .5k .80s .10s dbcp1 .9k .23s .10s derby2 .0k .31s .12s dbcp2 .1k .55s .10s jdbc1 .5k .92s .19s jdbc2 .6k .33s .19s jdbc3 .8k .48s .16s jdbc4 .9k .44s .20s .6k .6k vector .4m to .34s .7m .7m testperf .9m .63s .47s total .0m 1h02m .95s .
others include scheduling and sampling approaches .
unfortunately the above can report false positives.
sound offline analysis.
sound dynamic ones as discussed in section include three types.
m2 is a graph based one that hasbeen extensivelydiscussed.dirk andrvpredict are representativesofconstraintsolverbasedones.theycaninferalternative executions by considering branches and concrete read write values hence they have the potential to cover many races as well as deadlocks and other concurrency bugs like concurrency use after freeandconcurrencynull pointer dereference .
however theyrelyon e.g.
smt solvers.thispreventsthemfrom analyzing a full execution trace.
they can miss a race with much a larger distance.
soundonlineanalysis.
inrecentyears moreandmoresound dynamic online approaches have been proposed like cp wcp shb dc sdp wdp andsyncp .theseapproachestrack dependencyamongmemoryevents and guarantee thatthepredicted partial traceisfeasibleviavectorclocks .hb and shb both miss simple races because they cannot swap the critical sections.
the other approaches based on hb construct weaker partial orders in order to reduce the degree of incompleteness.
cp andwcp aresoundbutincompleteevenfortwothreads.
dcand sdp are unsound weakenings of wcp and wdp is an unsound weakening of dc.
the dc wdp races filtered by a vindication algorithmbecomesoundbutincomplete .therecentlyintroducedsyncpisthestateoftheartindetectingracesusingonline techniques.alloftheseonlineapproachesarecomputableinlinear time andhave been comparedinour experiments.
other approaches such as static race analysis are unsound reporting false races.
techniques such as implement efficient dynamic race detectors.
tools such asroadrunner andrapid providedynamicanalysisframeworks to facilitate experimentation for concurrentprograms.table full results on detection ofatomicityviolation.
benchmarks atom time distance atomfseqc atomf seqc max means bencharray .17s .07s critical .07s .10s pingpong .76s .07s airlinetickets .07s .10s account .56s .10s clean .07s .07s bubblesort .08s .11s boundedbuffer .17s .08s mergesort .07s .11s raytracer .12s .08s .1k .1k bufwriter .08s .15s ftpserver .17s .8k .8k readerswriters .40s .73s moldyn .19s .30s m benchjigsaw .37s montecarlo .72s sunflow .22s crypt .59s .32s l bencheclipse .62s xalan .86s .7m .8m lufact .72s .31s batik .10s lusearch .09s pmd .94s tsp .30s series 26m27s .07s luindex .61s xl benchsparsematmult .27s 3m16s sor .01s 3m21s avrora 2m54s .0k .4k h2 3m07s total 27m08s 19m07s .9m .9m conclusion wehavepresentedanefficient sounddynamicapproach seqcheck for detection of general concurrency bugs.
it advanced m2 by modeling branch events and supporting decisions on whether an event sequenceisfeasible.with seqcheck onecaneasilyencodeapotential concurrency bug into one or more sequences of events.
seqcheck hasbuiltinthesequencegenerationfordataraces deadlocks andatomicityviolations.theexperimentalresultsshowthat seqcheck achievedsignificantlybetterresultsthanrecentsound dataraceanddeadlockdetectorsinbotheffectivenessandefficiency.