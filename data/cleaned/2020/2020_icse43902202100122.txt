too quiet in the library an empirical study of security updates in android apps native code sumaya almanee?
arda unal?
mathias payery and joshua garcia?
?university of california irvine fsalmanee unala joshug4g uci.edu yepfl mathias.payer nebelwelt.net abstract android apps include third party native libraries to increase performance and to reuse functionality.
native code is directly executed from apps through the java native interface or the android native development kit.
android developers add precompiled native libraries to their projects enabling their use.
unfortunately developers often struggle or simply neglect to update these libraries in a timely manner.
this results in the continuous use of outdated native libraries with unpatched security vulnerabilities years after patches became available.
to further understand such phenomena we study the security updates in native libraries in the most popular free apps on google play from sept. to may .
a core difficulty we face in this study is the identification of libraries and their versions.
developers often rename or modify libraries making their identification challenging.
we create an approach called librarian library version identification that accurately identifies native libraries and their versions as found in android apps based on our novel similarity metric bin2sim.librarian leverages different features extracted from libraries based on their metadata and identifying strings in read only sections.
we discovered popular apps with vulnerable versions with known cves between sept. and may with 14of those apps remaining vulnerable.
we find that app developers took on average 20days to apply security patches while library developers release a security patch after 12days a 10times slower rate of update.
i. i ntroduction third party libraries are convenient reusable and form an integral part of mobile apps.
developers can save time and effort by reusing already implemented functionality.
native third party libraries are prevalent in android applications apps especially social networking and gaming apps.
these two app categories ranked among the top categories on google play require special functionality such as 3d rendering or audio video encoding decoding .
these tasks tend to be resource intensive and are thus often handled by native libraries to improve runtime performance.
the ubiquity of third party libraries in android apps increases the attack surface since host apps expose vulnerabilities propagated from these libraries .
another series of previous work has studied the outdatedness and updateability of third party java libraries in android apps with a focus on managed code of such apps e.g.
java or dalvik code .
however these previous studies do not consider native libraries used by android apps.we argue that security implications in native libraries are even more critical for three main reasons.
first app developers add native libraries but neglect to update them.
the reasons for this may include concerns over regressions arising from such updates prioritizing new functionality over security deadline pressures or lack of tracking library dependencies and their security patches.
this negligence results in outdated or vulnerable native libraries remaining in new versions of apps.
second native libraries are susceptible to memory vulnerabilities e.g.
buffer overflow attacks that are straight forward to exploit.
third and contrary to studies from almost years ago native libraries are now used pervasively in mobile apps.
to illustrate this point we analyzed the top apps from google play between sept. and may .
we obtained the version histories of these apps from androzoo totaling versions of those top free apps.
from these apps we identified native libraries in total with an average of 11libraries per app and a maximum of for one version of instagram.
to better understand the usage of third party native libraries in android apps and its security implications we conduct a longitudinal study to identify vulnerabilities in third party native libraries and assess the extent to which developers update such libraries of their apps.
in order to achieve this we make the following research contributions we construct a novel approach called librarian library version identification that given an unknown binary identifies i the library it implements and ii its version.
furthermore we introduce a new similarity scoring mechanism for comparing native binaries called bin2sim which utilizes 6features that enable librarian to distinguish between different libraries and their versions.
the features cover both metadata and data extracted from the libraries.
these features represent elements of a library that are likely to change between major minor and patch versions of a native library.
we conduct a large scale longitudinal study that tracks security vulnerabilities in native libraries used in apps over years.
we build a repository of android apps and their native libraries with the 200most popular free apps from google play totaling versions gathered between the dates of sept. and may .
this repository further contains native libraries used by these versions.
prior work has measured the similarity ieee acm 43rd international conference on software engineering icse .
ieee between binaries.
however these approaches identify semantic similarities differences between binaries at the function level with the goal of identifying malware.
librarian orthogonally is a syntactic based tool which computes similarity between two benign binaries at the file level with the goal of identifying library versions with high scalability.
we utilize librarian and our repository to study librarian s accuracy and effectiveness the prevalence of vulnerabilities in native libraries in the top apps and the rate at which app developers apply patches to address vulnerabilities in native binaries.
the major findings of our study are as follows for our ground truth dataset which contains 46known libraries with 904versions librarian correctly identifies of those library versions thus achieving a high identification accuracy.
to study the prevalence of vulnerabilities in the top apps in google play we use librarian to examine 53apps with vulnerable versions and known cves between sept. and may .
14of these apps remain vulnerable and contain a wide range of vulnerability types including denial of service memory leaks null pointer dereferences or divide by zero errors.
we further find that libraries in these apps on average have been outdated for days.
the combination of high severity and long exposure of these vulnerabilities results in ample opportunity for attackers to target these highly popular apps.
to determine developer response rate of applying security fixes we utilize librarian to analyze 40apps focusing on popular third party libraries those found in more apps with known cves such as ffmpeg giflib openssl webp sqlite3 opencv jpeg turbo libpng and xml2 between sept. and may .
we find that app developers took on average days to apply security patches while library developers release a security patch after days a 10times slower rate of update.
these libraries that tend to go for long periods without being patched affect highly popular apps with billions of downloads and installs.
we make our dataset analysis platform and results available online to enable reusability reproducibility and others to build upon our work .
ii.librarian figure shows the overall workflow of librarian .
librarian identifies unknown third party native libraries and their versions unknown lib versions by extracting features that distinguish major minor and patch versions of libraries that are stable across platforms regardless of underlying architecture or compilation environments comparing those features against features from a ground truth dataset known lib versions using a novel similarity metric bin2sim and matching against strings that identify version information of libraries extracted from known lib versions which we refer to as version identification strings.
in the remainder ofthis section we describe each of these three major steps of librarian .
unknown lib versions known lib versionslibra ryversion identific ation librarian identified library versions fig.
librarian identifies versions of native binaries from android apps by using our bin2sim similarity scoring technique to compare known ground truth dataset and unknown versions of native binaries.
a. feature vector extraction our binary similarity detection is based on the extraction of features from binaries combining both metadata found in executable and linkable format elf files as well as identifying features in different binary sections of the library.
all shared libraries included in android apps are compiled into elf binaries.
like other object files elf binaries contain a symbol table with externally visible identifiers such as function names global symbols local symbols and imported symbols.
this symbol table is used during loading and linking and by binary analysis tools e.g.
objdump readelf nm pwntools or angr to infer information about the binary.
to distinguish between different libraries and their versions we need to identify differencing features.
to that end we define a set of six features inherent to versions and libraries.
five features represent elf metadata these features are used to compute the similarity score between two binaries as described in section ii b hence we refer to these features as metadata features.
orthogonally we leverage strings extracted from the .rodata section of an elf object which we refer to as version identification strings.
this feature complements the similarity score from the first set of features.
we either use it to verify the correctness of the version or as a fallback if the similarity to existing binaries in our ground truth dataset is low see section ii c .
table i shows the list of all librarian features.
the features include i five metadata features based on exported and imported functions exported and imported globals and library dependencies and ii one data feature which is applied as a second factor to either substitute the metadata features in case the reported similarity score is low or to confirm the reported score.
these features represent the code elements of a library that would be expected to change based on a versioning scheme that distinguishes major minor and patch versions of a library.
furthermore these features are stable across platforms regardless of the underlying architecture or compilation environments.
we did not include code features e.g.
control flow and data flow features as they are extremely volatile and change between compilations and across architectures.
binary similarity matching is a hard open 1348feature typename definitionmetadataexported globals externally visible variables i.e.
they can be accessed externally.
imported globals variables from other libraries that are used in this library.
exported functions externally visible functions i.e.
functions that can be called from outside the library.
imported functions functions from other libraries that are used in this library.
dependencies the library dependencies that are automatically loaded by the elf objectdataversion identification strings flexible per library version strings e.g.
libfoo .
.
matched to strings in the .rodata section of an elf object table i list of features librarian extracts from native binaries of android apps along with their type and definition.
problem while recent work has made progress regarding accuracy the majority of algorithms have exponential computation cost relative to the code size and are infeasible for large scale studies.
we built a dataset of heuristics by inspecting the binaries in our ground truth dataset.
we developed scripts to process the data in the .rodata sections extracted during feature processing and search for unique per library strings that contain version information.
for example ffmpeg version info is found when applying the regex ffmpeg .
orffmpeg version .
.
table ii shows our list of extracted version heuristics.
each version heuristic can be produced automatically by constructing regular expressions from strings in .rodata sections of binaries in our ground truth dataset.
for example if the string libfoo .
.
is found in version .
.
of libfoo librarian uses a regular expression replacing the numeric suffix of the string with an appropriate pattern e.g.
libfoo .
.
we deliberately exclude any metadata or identifying strings for symbols that are volatile across architectures or build environments like compiler version relocation information and types or debug symbols.
librarian s accuracy results in section iii a2 demonstrate that our selected set of features suffice to distinguish between different versions of libraries.
the implementation leverages angr s elf parser which already is platform independent.
our extraction platform recovers all metadata from the elf symbol tables and if available searches for string patterns in the comment and readonly sections.
our filters remove platform specific information and calls to standard libraries e.g.
c abi calls vectors or other data structures .
the current implementation covers x86 x86 arm and arm64 binaries which are all platforms we observed in our evaluation.
we accommodate for architecture differences in two ways first we remove architecture noise in feature vectors e.g.
symbols that are only used in one architecture and second we collect if available binaries for the different architectures.
the feature extraction compiles all recovered information as a dictionary into a json file.
the dictionary contains arrays of strings for each of the features mentioned above plus additional metadata to identify the library and architecture.
b. similarity computation librarian s similarity computation which we refer to asbin2sim leverages the five metadata features when computing the similarity scores between an app binary and ourground truth dataset.
bin2sim is based on the jaccard coefficient and is used to determine the similarity between feature vectors.
bin2sim allows librarian to account for addition or removal of features between different libraries and versions.
given two binaries b1andb2with respective feature vectors fv1andfv2 bin2sim computes the size of the intersection offv1andfv2 i.e.
the number of common features over the size of the union of fv1andfv2 i.e.
the number of unique features bin2sim fv fv jfv1 fv2jjfv1 the similarity score is a real number between and with a score of indicating identical features a score of indicating no shared features between the two libraries and a fractional value indicating a partial match.
due to the volatility of the similarity score filtering noise such as platform specific details as mentioned in the previous section is essential for the accuracy of our approach.
librarian counts an unknown library instance from unknown lib versions as matching a known library version if its bin2sim is above .
.
this threshold was determined experimentally and works effectively as our evaluation will demonstrate see section iii .
if bin2sim results in the same value above the threshold for multiple known binaries librarian tries obtaining an exact match between one of the known binaries and the unknown binary by using their hash codes to determine the unknown binary s version.
a low similarity score might result from modifications made by app developers to the original third party library which results in the removal or addition of specific features.
from our experience removal of features from the original library is common among mobile developers and is likely driven by the need to reduce the size of the library and the app as much as possible.
for example we observed that the webp video codec library is often deployed without encoding functionalities to reduce binary size.
some size optimization techniques require choosing needed modules from a library and leaving the rest stripping the resulting binary and modifying build flags.
another factor that reduces similarity as measured by the jaccard coefficient is that certain architectures tend to export more features as compared to others.
for instance 32bit architectures such as armeabi v7a and x86 export more features compared to arm64 v8a and x8664.
c. version identification strings for libraries where librarian reports low similarity scores e.g.
some libraries like renderscript orunity only 1349library name extracted heuristics jpeg turbo jpeg turbo version .
ffmpeg ffmpeg .
ffmpeg version .
firebase firebase c .
libavcodec lavc5 .
libavfilter lavf5 .
libpng libpng version .
libglog glog .
libvpx webm project vp .
opencv general configuration for opencv .
opencv .
openssl openssl .
openssl .
speex speex .
sqlite3 3 .
.
unity3d .
expected version .
v orbis xiph.org vorbis .
.
xml2 gitv2.
.
table ii heuristics used to search for unique per library strings that contain version information export a single function1 these five features fail to provide sufficient information about the underlying components in a library.
if libraries only export one or a few functions the similarity metrics have a hard time distinguishing between different libraries.
we therefore extend the features with strings that uniquely identify the library.
such strings are often version strings.
based on extracted flexible per library heuristics from our ground truth dataset see table ii we heuristically identify exact library versions and increase overall accuracy.
for libraries with high similarity scores we use these library heuristics to confirm the correct version.
to identify binaries with low similarity scores we leverage version identification strings which is the set of extracted perlibrary version strings.
for example say a library version lv extracted from app ahad a similarity score of .
when compared with opencv .
.
using metadata features.
given the low score we search the version identification strings feature for specific keywords such as general configuration for opencv .
.
oropencv .
.
.
where the asterisk represents the versioning scheme of opencv library.
our feature extraction process logs all strings arrays of more than ascii printable characters ending with a byte from the .rodata section alongside the other features.
as libraries commonly have large amounts of read only string data that frequently changes we cannot use this data directly as a feature due to the low overlap resulting in low similarity .
by processing the .rodata from our ground truth dataset and clustering the data we extract common version identifiers and version strings.
we then translate them into regular expressions that allow us to match versions for different libraries.
iii.
e valuation to assess the prevalence of vulnerable native libraries for android we answer the following three research questions rq1 accuracy and effectiveness of librarian.
can librarian accurately and effectively identify versions of native libraries?
how does librarian compare against stateof the art native library version identification?
how effective 1these libraries are stripped and hide all functionality internally.
the single exported function takes a string as parameter which corresponds to the target function and they dispatch to internal functionality based on this string.arelibrarian s feature types at identifying versions of native libraries?
rq2 prevalence of outdated libraries.
how prevalent are vulnerabilities in native libraries of android apps?
rq3 patch response time.
after a vulnerability is reported for a third party library how quickly do developers apply patches?
to supplement the aforementioned rqs we conducted a detailed case study on a vulnerable app section iii d providing practical insight into vulnerabilities in third party libraries and possible exploits.
to answer these research questions we analyze the top apps in google play over several years.
we track the version history of these apps from androzoo a large repository of over million android apps.
our repository contains app metadata including the app name release dates and native binaries.
note that google play unfortunately restricts lists to apps.
overall we collected instances where each instance is a version of the 200top apps from google play.
we determined that 145out of of the distinct apps in our repository contain at least one native library i.e.
out of of the total apps in our database.
there are a total of libraries in the form of .sofiles i.e.
shared library files in our repository with an average of 11libraries per app and a maximum of for one version ofinstagram.
in fact instagram for which we collected versions since dec. contains a total of .sofiles.
we run librarian on a machine with amd epyc core cpus and 512gb of ram running ubuntu .
.
the average number of features in the extracted feature vectors is features.
some outliers such as libwaze and libtensorflow reach up to features.
this shows that the set of third party native libraries in our repository is diverse some of them are very complex and offer a large number of functionalities.
generating feature vectors is quick and generally takes a few seconds per library.
the most complex library libtensorflow takes 4min and 38sec to analyze.
we found that out of binaries for which librarian inferred their versions the average runtime for library version detection is .
seconds with a minimum of seconds and a maximum of seconds.
1350a.
rq1 accuracy and effectiveness to determine if librarian accurately and effectively identifies native library versions from android apps we assess librarian in three scenarios.
for the first scenario we compare its accuracy with osspolice the state of theart technique for identifying versions of native binaries for android apps.
for the second scenario we assess librarian on a larger dataset for which osspolice could not be applied and thus evaluate librarian s accuracy independently of other tools.
in the third scenario we assess the effectiveness of librarian s feature types at identifying versions of native libraries.
comparative analysis osspolice uses source code to build an index that allows it to identify versions of binaries.
osspolice measures the similarity between strings extracted from binaries and features found directly in source repositories.
unlike librarian osspolice relies on comparing binaries with source code resulting in an overly large feature space which in turn makes osspolice susceptible to falsely identifying any binary containing a library as exactly matching that library.
for example osspolice falsely identifies mupdf andopencv as matching libpng because those two libraries include libpng in their source code .
we repeatedly contacted the osspolice authors to obtain a fully working version of their tool but unfortunately they did not provide us their non public data index or sufficient information to reproduce their setup.
as a result we performed a comparative analysis between librarian andosspolice based on the published osspolice numbers .
the ground truth dataset in the osspolice evaluation contains a total of binaries out of which 67are unique extracted from 104applications collected by f droid .
librarian correctly identified unique binaries in theosspolice dataset improving accuracy by compared to the accuracy reported by osspolice which correctly identified libraries.
osspolice has lower accuracy because it misidentifies reused libraries as described above and it relies on simple syntactic features e.g.
string literals and exported functions while our feature vectors extract additional features such as imported functions exported and imported global variables and dependencies that uniquely identify different versions of binaries.
these additional features were a major factor in the superior accuracy of librarian compared to osspolice.
librarian did not identify 4binaries because the library functions are dispatched from a single function and do not contain identifying version information that was readily available.
hence our extracted features fail to provide sufficient information about the underlying components in the library.
nevertheless librarian significantly reduces the number of binaries that need to be manually inspected.
lastly it is important to reiterate that these results are only compared against the dataset used in the osspolice paper but without us being able to replicate or reuse osspolice due to key elements of the tool being unavailable.finding librarian achieves a improvement in its accuracy compared to osspolice on the unique binaries in osspolice s dataset.
unlike osspolice librarian obtains this improvement without relying on source code which may not be available for all libraries and results in an unnecessarily larger feature space.
independent accuracy we further assess librarian s accuracy on a larger and more recent set of library versions than those found in osspolice s dataset.
to that end we manually collect a set of binaries with known libraries and versions known lib versions in figure and compare the inferred libraries and versions to the known ones to determine librarian s accuracy.
we build our dataset based on libraries used in common android apps.
experiment setup.
we first manually locate the pre built binaries of libraries to serve as ground truth.
to that end we use readily available auxiliary data such as keywords found in feature vectors binary filenames and dependencies.
once we identify potential targets we retrieve the pre built binaries of all versions and architectures if possible.
there are a variety of distribution channels where app developers can obtain third party binaries.
we obtained such binaries from official websites github and debian repositories.
the binaries with known libraries and versions contain 46distinct libraries with a total of 904versions and an average of19versions per library.
results.
librarian correctly identified the versions of libraries in our ground truth of these library versions have unique feature vectors of the these libraries contain the exact version number in the strings literals and the remaining of library versions are distinguished using hash codes to break ties between bin2sim values of binaries.
misidentification occurs in of library versions where the largest equivalence class contains library versions.
this usually occurs for consecutive versions minor or micro revisions e.g.
.
.
and .
.
.
these minor or micro revisions generally fix small bugs and do not change add or remove exported symbols.
although librarian cannot pinpoint the exact library version in this case librarian significantly reduces the search space for post analysis to a few candidate versions.
finding librarian correctly identifies of .
library versions from distinct libraries making it highly accurate for identifying the native libraries and versions.
for misidentified library versions librarian reports a slightly different version.
feature effectiveness to assess the effectiveness of metadata features version identification strings and their combination at inferring binaries we computed the extent to which each feature is capable of inferring binaries in our repository.
to that end any binary whose library and version can be inferred with a bin2sim above .
as described 1351in section ii counts as an inferred binary.
we found that of binaries in our repository are inferable by version identification strings only.
of the remaining binaries are inferable using only the five metadata features mentioned in section ii a while the remaining are inferred using both metadata features and version identification strings.
this indicates that not all libraries have the version information encoded directly in the strings.
having a combination of both metadata features andversion identification strings is crucial to increase the number of inferred binaries.
we further aimed to assess the extent to which each of the five metadata features contribute to computing bin2sim in order to assess each of their individual effectiveness.
recall from section ii b that our matching algorithm leverages five features when computing the similarity scores between an app binary and our ground truth dataset.
table iii lists these feature along with their contribution factor i.e.
the average percentage each one of these features contribute to the total similarity score.
to calculate the contribution factor contrib f of a feature f we first calculate the similarity score taking all five features into account score all .
we then calculate the similarity score of each feature separately score f .
for each feature we find contrib f score f score all which is the percentage each fcontributes to the total similarity score.
as shown in table iii exported functions contributes the most when computing bin2sim equation i.e.
.
of the matching features are exported functions followed by imported functions contributing .
dependencies exported globals and finally imported globals contributing less overall.
still these five features sometimes manage to uniquely identify a library and are therefore included as they overall improve the similarity score.
recall that version identification strings is not taken into account when computing the similarity score between binaries.
finding of binaries are inferable using version identification strings are inferable using metadata features and .
are inferable using both feature types.
exported functions and imported functions account for the overwhelming majority of effectiveness of metadata features contributing and32 respectively.
feature typename contribution factormetadataexported globals .
imported globals .
exported functions .
imported functions .
dependencies .
table iii list of features bin2sim extracted from native binaries of android apps along with their type and overall contribution factor which measures the average percentage each feature contributes to the total similarity score b. rq2 prevalence of vulnerable libraries to study the prevalence of vulnerabilities in native libraries we need to identify their exact versions.
to that end weleverage librarian to identify potential library versions from our repository.
once the versions are identified we investigate the extent to which native libraries of android apps are vulnerable and remain vulnerable.
experiment setup.
we infer the correct version of binaries of the total binaries in our android repository using librarian .
due to the highly time consuming nature of the manual collection of ground truth binaries we limit ourselves to libraries that i are found in a greater number of apps more than 10apps and ii have known cves.
as a result an overwhelming majority of the remaining binaries in our dataset have either no known cves or affect very few apps making them an unsuitable choice for applying an expensive manual analysis for studying this research question.
results.
we found that out of binaries for which we inferred their versions were vulnerable libraries affecting distinct apps.
14new releases of these distinct apps remain vulnerable at the time of submission.
the complete list of libraries with reported cves between sept. and the writing of this paper can be found in table iv.
as for the number of apps affected by vulnerable libraries our results show that 53distinct apps have been affected by a minimum of 1vulnerable library and a maximum of16vulnerable libraries covering dates between sept and may .
finding of the top apps on google play .
were plagued by a vulnerable library over approximately six years and months i.e.
between sept. and may .
14of those apps still include a vulnerable binary i.e.
of the top apps on google play even at the time at which we collected apps for this study and are on average outdated by days.
as a result vulnerable native libraries play a substantial role in exposing popular android apps to known vulnerabilities.
we emailed app developers since february to inform them that their apps continue to use a vulnerable library.
we urged them to take an action i.e.
remove or replace such libraries or at least provide some justification as to why such libraries are not updated.
our investigation is ongoing.
while several app developers already updated their apps to remove the vulnerable library many updates are still outstanding.
some of the replies we received simply blame other library developers.
for example we heard back from discord that the vulnerable lib is a dependency of another third party library used in discord fresco until fresco fixes this however we are not able to address this in our app .
four libraries were particularly prevalent in terms of the number of vulnerable versions they contain i.e.
openssl the number of apps they affect i.e.
opencv and giflib or the length of time during which the library remained vulnerable i.e.
xml2 inmicrosoft xbox smartglass .
openssl has the largest number of vulnerable versions in total included in 13distinct apps.
3apps amazon alexa facebook messenger and norton secure vpn still include vulnerable 1352lib name no.
vul lib versvul lib vers no.
apps no.
apps still vul opencv .
.
.
.
.
.
.
.
.
.
webp .
.
.
.
.
.
giflib .
.
.
.
ffmpeg .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
libavcodec .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
libavformat .
.
.
.
.
.
libavfilter .
.
.
.
.
.
libavutil .
.
.
.
.
.
libswscale .
.
.
.
.
.
libswresample .
.
.
.
sqlite3 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
xml2 .
.
openssl .
.0a .
.1c .
.1e .
.1h .
.1i .
.1p .
.1s .
.2a .
.2f .
.2g .
.2h .
.2j .
.2k .
.2m .
.2o .
.2p .
.2r .
.
.
.0g .
.0h .
.0i .
.1b13 jpeg turbo .
.
.
.
libpng .
.
.
.
.
.
.
.
.
.
.
.
.
.
table iv a list of libraries with reported cves found in our repository along with the number of distinct apps that were affected by a vulnerable library and the number of distinct apps containing a vulnerable version till now.
versions of openssl.
opencv and giflib affect the most apps.
opencv has the largest number of affected apps with a total of 21apps where 7recent apps still have a vulnerable instance of opencv.
most applications do not include opencv directly but indirectly through the dependencies of card.io which enables card payment processing but comes with the two outdated versions .
.
and .
.
of both opencv core andopencv imgproc.
following opencv in the number of affected apps is giflib which has two vulnerable versions found in a total of 15distinct apps 1app is still affected.
one vulnerable version of xml2 .
.
was found in versions of microsoft xbox smartglass and the library was not updated for years still remaining vulnerable up to the writing of this paper.
this particular case is notable due to the extremely long amount of time the library had been vulnerable and remained vulnerable.
to examine the affects of vulnerable libraries on apps further we list popular apps and the reported cves they expose their users to.
table v shows out of 14popular apps that are using at least one library with a reported cve at the time of our app collection.
we discuss four of these apps in more detail in the remainder of this section.
facebook messenger which has a download base of over 500m the largest in this list contains openssl .
.
which is vulnerable since sept. .
this vulnerable library contains multiple memory leaks which allows an attacker to cause a denial of service memory consumption by sending large ocsp online certificate status protocol request extensions.
amazon kindle an app that provides access to an electronic library of books with a total of more than 100m installs uses two vulnerable libraries xml2 .
.
andlibpng .
.
.
xml2 .
.
contains a variant of the billion laughs vulnerability which allows attackers to craft an xml document with a large number of nested entries that results in a denial of service attack.
xml2 .
.
is vulnerable since nov. and continues to be used in recent versions of the app.
libpng1.
.
has a null pointer dereference vulnerability.
thisvulnerability was published years ago under cve and it remains unchanged in recent releases of amazon kindle.
doordash a food delivery app with more than 10m installs includes giflib .
.
which was reported vulnerable over months ago.
a malformed gif file triggers a division by zero exception in the dgifslurp function in giflib versions prior to .
.
.
this vulnerable library remains unchanged up to now.
target uses opencv .
.
as a dependency of card.io which enables card payment processing.
this version of opencv was announced vulnerable in aug. yet remains unchanged in these apps.
app name vulnerable libs no.
installs amazon alexa openssl .
.2p sqlite3 .
.
10m amazon kindle libpng .
.
xml2 .
.
100m amazon music ffmpeg .
.
100m doordash giflib .
.
10m facebook messenger openssl .
.
500m grubhub opencv .
.
10m sam s club opencv .
.
10m subway opencv .
.
5m norton secure vpn openssl .
.1b 10m target opencv .
.
10m table v out of 14popular apps from google play which include a vulnerable library that remained unchanged.
finding these four apps showcase that these vulnerabilities are wide ranging involving denial of service memory leaks or null pointer dereferences.
the high severity and long exposure time of these vulnerabilities results in ample opportunity for attackers to target these highly popular apps.
c. rq3 rate of vulnerable library fixing to determine the vulnerability response rate we identify the duration between the release time of a security update and the time at which app developers applied a fix either by i updating to a new library version or ii completely removing a vulnerable library.
recall that we collected the previous 1353versions of the top apps from google play.
moreover we inferred the library versions from libraries using librarian .
given the histories of apps and inferred library versions we can track the library life span per app i.e.
the time at which a library is added to an app and when it is either removed or updated to a new version in the app.
to this end we analyzed 40popular apps with known vulnerable versions of ffmpeg giflib openssl webp sqlite3 opencv jpeg turbo libpng and xml2 between sept. and may .
we exclude apps that removed a library before a cve was associated with it and apps containing libraries that are vulnerable up to the writing of this paper.
we obtained the date at which a library vulnerability was found when a security patch was made available for the library and the time at which either the library was updated to a new version or removed.
table vi shows all the combinations of apps and vulnerable libraries.
finding on average library developers release a security patch after days from a reported cve.
app developers apply these patches on average after days from the date an update was made available which is about 10times slower than the rate at which library developers release security patches.
finding reveals that many popular android apps expose end users to long vulnerability periods especially considering that library developers released fixed versions much sooner.
this extreme lag between release of a security patch for a library and the time at which an app developer updates to the patched libraries or just eliminates the library indicates that at best it is highly challenging for developers to update these kinds of libraries or less charitably app developers are highly negligent of such libraries.
app name vul lib version vul announcedttrp days ttaf days xbox xml2 .
.
apple music xml2 .
.
tiktok giflib .
.
zoom meetings openssl .
.0a amazon alexa openssl .
.1s amazon kindle libpng .
.
starmaker ffmpeg .
ebay opencv .
.
fitbit sqlite3 .
.
uber opencv .
.
snapchat sqlite3 .
.
discord giflib .
.
lyft opencv .
.
twitter giflib .
.
instagram ffmpeg .
.
table vi combinations of apps and particular vulnerable library versions they have contained the date the vulnerability was publicly disclosed vul announced the period between vulnerability disclosure and patch availability in days i.e.
time to release patch ttrp and the total number of days elapsed before a fix was made i.e.
time to apply fix ttaf developers applied security patches for vulnerable libraries at a rate as slow as .
years in the case of xbox and as fast as days for instagram where a vulnerable version offfmpeg was removed in that amount of time.
in order to determine what type of fix was applied by a developer we checked the next app version where a vulnerable library was last seen.
we found that developers either kept the library but updated to a new version removed a vulnerable version or removed all native libraries in an app.
in the next paragraphs we discuss five popular native libraries used in android apps that exhibit particularly slow fix rates ffmpeg openssl giflib opencv and sqlite3.
multiple vulnerabilities were found in versions .
and .
of ffmpeg in dec. and jan. respectively.
the number of days a security patch was released for these vulnerable library versions is 4and2days respectively.
however developers took 267days to address vulnerabilities ininstagram and nearly 3years to apply a fix in starmaker.
openssl .
.0a andopenssl .
.1s were associated with cve andcve in aug. and may of which openssl developers provided a security patch 91and12days after.
however developers of zoom took1 days to apply a fix while developers of amazon alexa took days.
a heap based buffer overflow was reported in giflib .
.
at the end of .
the results show that 3apps using this vulnerable version of giflib have an average time to fix i.e.
total number of days elapsed before a fix was applied of days years which is 10times slower.
this lag time is particularly concerning since giflib released a fix days after the vulnerable version.
a fix to an out of bounds read error that was affecting opencv through version .
was released 41days after the cve was published.
the vulnerable versions of this library affects 3apps in total uber lyft and ebay.
opencv has an average time to fix of days i.e.
2years which is 19times slower than the rate at which library developers of opencv release security patches.
sqlite3 released version .
.
which fixes an integer overflow found in all versions prior to .
.
.
snapchat and fitbit removed a vulnerable version of sqlite .
.
library 786days later.
finding the results for these five popular native libraries in android apps show that it often takes years for app developers to update to new library versions even if the existing version contains severe security or privacy vulnerabilities placing millions of users at major risk.
to further understand the consequences of outdated vulnerable libraries we calculated the average time to fix across all vulnerable libraries per app.
table vii lists the top apps with the most number of days a vulnerable library remained in an app until a fix for the vulnerability was applied.
apple music had the longest lag between the vulnerable library being introduced and fixed i.e.
years.
uber was the fastest 1354app name time to apply fix days no.
installs apple music .
50m amazon kindle .
100m ebay .
100m fitbit .
10m snapchat .
000m xbox .
50m zoom meetings .
100m lyft .
10m amazon alexa .
10m uber .
500m table vii top most negligent apps in terms of the average time to fix a vulnerable library at almost days.
individual apps had as few as over million installs and as many as over a billion installs.
among the social media apps snapchat which has over billion downloads and the largest number of installs among the top apps in table vii fixed its vulnerable libraries after days.
these very long times to fix vulnerable libraries in highly popular social media apps places billions of users at high security risk.
finding the most neglected apps in terms of time to fix vulnerable native libraries range from .
days to nearly five years affecting billions of users and leaving them at substantial risk of having those libraries exploited.
this finding emphasizes the need for future research to provide developers with mechanisms for speeding up this very slow fix rate.
table viii lists the top most neglected vulnerable libraries across all apps.
xml2 is the most neglected library with an average time to fix of 5years webp is the least neglected library with an average time to fix of days.
among these libraries the fact that it takes app developers days on average to update vulnerable versions of openssl is particularly concerning due to its security critical nature.
lib name time to apply fix days genre xml2 .
xml parser libpng .
codec jpeg turbo .
codec ffmpeg .
multimedia framework opencv .
computer vision openssl .
network giflib .
graphis sqlite3 .
rdbms webp .
codec table viii top most neglected vulnerable libraries in terms of the average time to fix finding future research should focus on these highly neglected libraries as experimental subjects for determining methods to ease the burden of updating these libraries running regression tests to ensure these updates do notintroduce new errors and repairing those errors possibly automatically when they do arise.
d. exploitability case study to demonstrate the exploitability of unpatched vulnerabilities in third party apps we carry out a targeted case study where we analyze individual applications and create a proof of concept poc exploit.
our poc highlights how these unpatched vulnerabilities can be exploited by third parties when interacting with the apps.
xrecoder allows users to capture screen videos screen shots and record video calls.
furthermore xrecoder provides video editing functionalities enabling users to trim videos and change their speed.
this application uses ffmpeg an open source video encoding framework that provides video and audio editing format transcoding video scaling and postproduction effects.
xrecoder embeds the ffmpeg library version .
.
which is vulnerable to cve reported in july .
ffmpeg .
.
contains a vulnerable function ffmov write packet that may result in a division by zero error if provided with an empty input packet.
hence an attacker can craft a waveform audio to cause denial of service.
to assess whether this vulnerable function is reachable in xrecoder we used radare2 to replace the first instruction in the vulnerable function with an interrupt instruction.
we run the application after the latter modification which consequently resulted in an app crash i.e.
allowing us to trigger the vulnerability consistently.
ff mov write packet is called by multiple functions across two different binaries ffmpeg .
.
.so and the app specific libisvideo.so and two different platforms dalvik and native .
av buffersink get frame one of the ancestors of ff mov write packet is called by nativegeneratewaveformdata from the dalvik side.
iv.
d iscussion findings in rq2 section iii b demonstrate that out of binaries for which we inferred their versions were vulnerable libraries affecting 53distinct apps between sept. and may .
this constitutes about of the top apps on google play.
more alarmingly new releases of 14distinct apps remain vulnerable even at the time at which we collected apps for this study with an average outdatedness of days.
while we have informed app developers about the outdated libraries in their apps one interesting piece of follow up work based on this result is surveying android app developers to determine the reason for this extremely slow rate of fixing vulnerable native libraries in their apps.
such a study can further assess what forms of support app developers would need to truly reduce this slow rate of updating vulnerable library versions to ones with security patches.
for rq3 section iii c we analyzed the speed at which developers updated their apps to patched libraries and found 1355that on average library developers release a security patch after days from a reported cve.
while app developers apply these patches on average after days from the date an update was made available times slower .
recall that we only consider apps in these cases that actually ended up fixing vulnerable native libraries.
the results for rq2 and rq3 corroborate the need to make app developers aware of the severe risks they are exposing their users to by utilizing vulnerable native libraries.
overall our results demonstrate the degree to which native libraries are neglected in terms of leaving them vulnerable.
unfortunately our findings indicate that the degree of negligence of native libraries is severe while popular apps on google play use native libraries extensively with out of top free apps .
interesting future work for our study includes uncovering the root causes of such negligence and means of aiding developers to quickly update their native libraries.
for example platform providers e.g.
google could provide mechanisms to automatically update native libraries while also testing for regressions and possibly automatically repairing them.
such an idea is similar to how debian s repositories centrally manage libraries and dependencies between applications and libraries.
whenever a library is updated only the patched library is updated the applications remain the same.
the android system would highly profit from a similar approach of central dependency and vulnerability management.
v. t hreats to validity external validity.
the primary external threat to validity involves the generalizability of the data set collection and the selection methodology.
recent changes in google play limited the length of the top apps list to items.
despite the restrictions imposed by google play limiting our analysis to the top apps these apps account for the bulk of downloads and the largest user base on google play and are generalizable to popular apps thus having the largest impact.
the results from rq1 show that librarian detects versions of native libraries with high accuracy .
the need to compare against binaries with a known number of versions and libraries i.e.
known lib versions in figure limits librarian .
specifically misidentification of a library or its version might occur when an unknown binary for which we are trying to identify a library and version does not exist inknown lib versions.
in these cases librarian identifies the unknown binary as being the library and version closest to it according to bin2sim that exists in known lib versions.
one possible way of enhancing librarian in such cases is to leverage supervised machine learning which may at least be able to identify if the library is most likely an unknown major minor or patch version of a known library.
internal validity.
one internal threat is the accuracy of timestamps in androzoo and its effect on the reported patch life cycle findings.
to mitigate this threat we collected androzoo timestamps over three months and correlated updates with google play.
we verified that androzoo has a maximum lag of days.
this short delay is much smaller than the updatefrequency of vulnerable apps.
furthermore we verified that using dates added to androzoo and version codes give us reliable timestamps for earlier time periods.
construct validity.
one threat to construct validity is the labeling of the libraries in our repository as vulnerable or not.
to mitigate this threat we relied on the vulnerabilities reported by the common vulnerabilities and exposures database which contains a list of publicly known security vulnerabilities along with a description of each vulnerability.
we conducted an exploitability case study of one vulnerable library in an app section iii d. for the remaining set of discovered vulnerable libraries apps we verified that vulnerable native functions are exported and that the library is loaded from the app dalvik side.
performing a complete analysis of exploitable reachable native functions in android is an interesting but orthogonal research problem.
building a cross language control flow data flow analysis to assess reachability of vulnerable native code from the dalvik code of an android app is an open research problem worthy of a separate research paper recovering a binary cfg dfg is currently unsound based on heuristics and runs into state explosion and conducting an exploitability study of all vulnerable libraries apps across our entire dataset is infeasible due to the large amount of apps libraries.
another threat to validity is the possibility of developers manually patching security vulnerabilities.
to mitigate this threat to validity we checked the versions identified by librarian and found that librarian correctly identifies an overwhelming majority of patch level versions .
.
for the patch level versions that librarian cannot distinguish as effectively librarian makes manual identification much easier by significantly reducing the search space for post analysis to only candidate versions.
furthermore based on the results of our dataset we believe that app developers are unlikely to manually patch a library they do not maintain given that it already takes years for these developers to simply update a library version.
vi.
r elated work a series of work has demonstrated the importance of thirdparty libraries for managed code of android apps i.e.
dalvik code and their security effects and implications .
derr et al.
investigated the outdatedness of libraries in android apps by conducting a survey with more than app developers.
they reported that a substantial number of apps use outdated libraries and that almost of17k actively used library versions have known security vulnerabilities.
backes et al.
report for managed code level libraries that app developers are slow to update to new library versions discovering that two long known security vulnerabilities remained present in top apps during the time of their study.
none of these studies examined native third party libraries in android apps nor did they look at the security impact of vulnerable libraries or whether these vulnerabilities are on the attack surface.
librarian now explores the attack surface of 1356native libraries closing this important gap and calling platform providers to action.
a wide variety of approaches have emerged that identify third party libraries with a focus on managed code.
these approaches employ different mechanisms to detect third party libraries within code including white listing package names supervised machine learning and code clustering .
libscout proposed a different technique to detect libraries using normalized classes as a feature that provides obfuscation resiliency.
some techniques identify vulnerabilities in native libraries by computing a similarity score between binaries with known vulnerabilities and target binaries of interest .
vulseeker matches binaries with known vulnerabilities using control flow graphs and machine learning.
similarly discovre and binxray matches binaries at the function level.
other techniques employ a hybrid technique such as binsim mobilefinder binmatch and droidnative .
these approaches identify semantic similarities differences between functions in binaries based on execution traces for the purpose of analyzing identifying malware.
unlike these tools librarian focuses on benign libraries with the goal of identifying their versions with high scalability.
binary analysis tool bat and osspolice measure similarity between strings extracted from binaries and features found directly in source repositories.
unlike librarian these approaches compare source code with binaries which introduces the issue of internal clones i.e.
third party library source code that is reused in the source code of another library .
bat and osspolice rely on simple syntactic features e.g.
string literals and exported functions .
osspolice cannot detect internal code clones while librarian can giving it superior ability to identify versions of native libraries.
furthermore bat does not detect versions of binaries and was shown to have inferior accuracy for computing binary similarity compared to osspolice.
unlike these tools librarian extracts additional features such as imported functions exported and imported global variables and dependencies that uniquely identify different versions of binaries.
as shown in section iii a1 these additional features were a major factor in the superior accuracy of librarian compared to osspolice.
other related empirical research studies the prevalence of vulnerable dependencies in open source projects vulnerabilities in webassembly binaries or investigates the updatability of ad libraries in android apps .
other work such as present third party library recommendation tools for mobile apps.
despite the existence of much previous work on survivability of vulnerabilities in android apps libraries such work has not conducted a large scale longitudinal study of native third party libraries as we did in this paper.
moreover the survivability of vulnerabilities in non native libraries are significantly shorter compared to those reported in our results.
while survivability of vulnerabilities in native android apps took on average days in our study prior work shows that survival times of vulnerabilities in python and javascript are days and days respectively.
of vulnerabilities in npm packages were fixed within a month were fixed within months only .
none of this aforementioned related work has examined the prevalence of security vulnerabilities in android s native libraries or the time to fix for vulnerable versions of such libraries.
as a result our work covers a critical attack vector that has been ignored in existing research.
vii.
c onclusion third party libraries have become ubiquitous among popular apps in the official android market google play with out of the top free apps on google play containing native libraries.
these libraries are particularly beneficial for handling cpu intensive tasks and for reusing existing code in general.
unfortunately the pervasiveness of native third party libraries in android apps expose end users to a large set of unpatched security vulnerabilities.
to determine the extent to which these native libraries remain vulnerable in android apps we study the prevalence of native libraries in the top apps on google play across versions of those apps.
from these versions we extracted native libraries.
to identify versions of libraries we constructed an approach called librarian that leverages a novel similarity metric bin2sim that is capable of identifying versions of native libraries with a high accuracy a correct identification rate.
for vulnerabilities we found 53apps with vulnerable versions with known cves between sept. and may with 14of those apps still remaining vulnerable until the end point of our study.
we find that app developers took on average days to apply security patches while library developers release a security patch after days a 10times slower rate of update.
viii.
d ata availability our dataset analysis platform and results are available online for reusability and reproducibility purposes.
ix.
a cknowledgement this work was supported in part by award cns and cns from the national science foundation and grant number from the erc horizon program.
1357references shahid alam zhengyang qu ryan riley yan chen and vaibhav rastogi.
droidnative automating and optimizing detection of android native code malware variants.
computers security .
kevin allix tegawend e f. bissyand e jacques klein and yves le traon.
androzoo collecting millions of android apps for the research community.
in proceedings of the 13th international workshop on mining software repositories msr pages .
acm press .
g abor antal m arton keleti and p eter hegedundefineds.
exploring the security awareness of the python and javascript open source communities.
in proceedings of the 17th international conference on mining software repositories msr page new york ny usa .
association for computing machinery.
michael backes sven bugiel and erik derr.
reliable third party library detection in android and its security applications.
in proceedings of the acm sigsac conference on computer and communications security ccs pages .
acm press .
theodore book adam pridgen and dan s. wallach.
longitudinal analysis of android ad library permissions.
arxiv .
.
brandon carlson kevin leach darko marinov meiyappan nagappan and atul prakash.
open source vulnerability notification.
in francis bordeleau alberto sillitti paulo meirelles and valentina lenarduzzi editors open source systems 15th ifip wg .
international conference oss proceedings ifip advances in information and communication technology pages .
springer new york llc january .
15th international conference on open source systems oss conference date through .
cve.
alexandre decan tom mens and eleni constantinou.
on the impact of security vulnerabilities in the npm package dependency network.
in proceedings of the 15th international conference on mining software repositories msr page new york ny usa .
association for computing machinery.
erik derr sven bugiel sascha fahl yasemin acar and michael backes.
keep me updated an empirical study of third party library updatability on android.
in proceedings of the acm sigsac conference on computer and communications security ccs pages .
acm press .
ruian duan ashish bijlani meng xu taesoo kim and wenke lee.
identifying open source license violation and day security risk at large scale.
in proceedings of the acm sigsac conference on computer and communications security ccs pages .
acm press .
william enck damien octeau patrick mcdaniel and swarat chaudhuri.
a study of android application security.
in in proceedings of the 20th usenix security symposium page .
sebastian eschweiler khaled yakdan and elmar gerhards padilla.
discovre efficient cross architecture identification of bugs in binary code.
in proceedings network and distributed system security symposium.
internet society .
f droid.
ffmpeg.
jian gao xin yang ying fu yu jiang and jiaguang sun.
vulseeker a semantic learning based vulnerability seeker for cross platform binary.
inproceedings of the 33rd acm ieee international conference on automated software engineering ase pages .
acm press .
gnu.org.
michael c. grace wu zhou xuxian jiang and ahmad reza sadeghi.
unsafe exposure analysis of mobile in app advertisements.
in proceedings of the fifth acm conference on security and privacy in wireless and mobile networks wisec page .
acm press .
qiang he bo li feifei chen john grundy xin xia and yun yang.
diversified third party library prediction for mobile app development.
ieee transactions on software engineering pages .
armijn hemel karl trygve kalleberg rob vermaas and eelco dolstra.
finding software license violations through binary code clone detection.
inproceeding of the 8th working conference on mining software repositories msr page .
acm press .
hewlett packard enterprise cyber risk report .
https 4aa6 3786enw.pdf.
yikun hu yuanyuan zhang juanru li hui wang bodong li and dawu gu.
binmatch a semantics based hybrid approach on binary code clone analysis.
arxiv .
.
daniel lehmann johannes kinder and michael pradel.
everything old is new again binary security of webassembly.
in 29th usenix security symposium usenix security pages .
usenix association august .
m. li w. wang p. wang s. wang d. wu j. liu r. xue and w. huo.
libd scalable and precise third party library detection in android markets.
in ieee acm 39th international conference on software engineering icse pages .
yibin liao ruoyan cai guodong zhu yue yin and kang li.
mobilefindr function similarity identification for reversing mobile binaries.
in javier lopez jianying zhou and miguel soriano editors computer security volume pages .
springer international publishing .
librarian.
libvpx.
bin liu bin liu hongxia jin and ramesh govindan.
efficient privilege de escalation for ad libraries in mobile apps.
in proceedings of the 13th annual international conference on mobile systems applications and services mobisys pages .
acm press .
ziang ma haoyu wang yao guo and xiangqun chen.
libradar fast and accurate detection of third party libraries in android apps.
in proceedings of the 38th international conference on software engineering companion icse pages .
acm press .
alejandro mazuera rozo jairo bautista mora mario linares v asquez sandra rueda and gabriele bavota.
the android os stack and its vulnerabilities an empirical study.
empirical software engineering .
copyright empirical software engineering is a copyright of springer .
all rights reserved last updated .
jiang ming dongpeng xu yufei jiang and dinghao wu.
binsim trace based semantic binary diffing via system call sliced segment equivalence checking.
in usenix security symposium .
israel j. mojica ruiz meiyappan nagappan bram adams thorsten berger steffen dienst and ahmed e. hassan.
analyzing ad library updates in android apps.
ieee software march .
conference name ieee software.
a. narayanan l. chen and c. k. chan.
addetect automated detection of android ad libraries using semantic analysis.
in ieee ninth international conference on intelligent sensors sensor networks and information processing issnip pages .
opus.
radare2.
jaebaek seo daehyeok kim donghyun cho taesoo kim and insik shin.
flexdroid enforcing in app privilege separation in android.
in proceedings network and distributed system security symposium.
internet society .
y .
shoshitaishvili r. wang c. salls n. stephens m. polino a. dutcher j. grosen s. feng c. hauser c. kruegel and g. vigna.
sok state of the art of war offensive techniques in binary analysis.
in2016 ieee symposium on security and privacy sp pages .
sonatype state of the software supply chain.
sonatype.com 2019ssc.
speex.
mengtao sun and gang tan.
nativeguard protecting android applications from third party native libraries.
in proceedings of the acm conference on security and privacy in wireless mobile networks wisec pages .
acm press .
v orbis.
haoyu wang yao guo ziang ma and xiangqun chen.
wukong a scalable and accurate two phase approach to android app clone detection.
inproceedings of the international symposium on software testing and analysis issta pages .
acm press .
yifei xu zhengzi xu bihuan chen fu song yang liu and ting liu.
patch based vulnerability matching for binary programs.
in proceedings of the 29th acm sigsoft international symposium on software testing and analysis pages .
acm july .
huan yu xin xia xiaoqiong zhao and weiwei qiu.
combining collaborative filtering and topic modeling for more accurate android mobile app library recommendation.
in proceedings of the 9th asia pacific symposium on internetware internetware pages shanghai china .
acm press.
yajin zhou zhi wang wu zhou and xuxian jiang.
hey you get off of my market detecting malicious apps in official and alternative android markets.
in proceedings of the 19th network and distributed system security symposium page .