conflict aware inference of python compatible runtime environments with domain knowledge graph wei cheng state key laboratory for novel software technology nanjing university china wchengcs.nju gmail.comxiangrong zhu state key laboratory for novel software technology nanjing university china xrzhu.nju gmail.comwei hu state key laboratory for novel software technology nanjing university china whu nju.edu.cn abstract code sharing and reuse is a widespread use practice in software engineering.
although a vast amount of open source python code is accessible on many online platforms programmers often find it difficult to restore a successful runtime environment.
previous studiesvalidatedautomaticinferenceofpythondependenciesusing pre built knowledge bases.
however these studies do not cover sufficient knowledge to accurately match the python code and also ignore the potential conflicts between their inferred dependencies thusresultinginalowsuccessrateofinference.inthispaper we propose pycre a new approach to automatically inferring python compatible runtime environments with domain knowledge graph kg .specifically wedesignadomain specificontologyforpython third party packages and construct kgs for over popularpackages in python and python .
pycre discovers candidatelibraries by measuring the matching degree between the known libraries and the third party resources used in target code.
for the np complete problem of dependency solving we propose a heuristicgraphtraversalalgorithmtoefficientlyguaranteethecompatibility between packages.
pycre achieves superior performanceon a real world dataset and efficiently resolves nearly half more import errors than previous methods.
keywords python runtimeenvironmentinference knowledgegraph conflict resolution dependency solving configuration management acm reference format wei cheng xiangrong zhu and wei hu.
.
conflict aware inference of python compatible runtime environments with domain knowledge graph.in 44thinternationalconferenceonsoftwareengineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction with the rise of programming communities such as github and stackoverflow code sharing and reuse have become a common corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
forprogrammers .
pythonis oneof themost popular high levelprogramminglanguagestoday dueinparttoitsmassive third partypackageresources whichalsooftencauseenvironment configuration issues.
an empirical research observed that the usabilityrateofallthepythoncodesnippetsonstackoverflowis parsableand runnable and thework in furtherfound that .
of the python code snippets shared through github are not executable with over half of failures due to missing dependencies in a clean python environment.
executingapythoncodethatcontainsthird partyresourcesina clean python environment triggers dependency errors which raise the built in exception importerror .
to resolve this programmers needtospecifythepackagesanddesiredversionsinaconfiguration scriptsuchas requirements.txt.however thisisnotatrivialwork.
thestudyin observedthatprogrammersusuallyspendbetween minutes and two hours to set up the environment and in some cases theyevencannotrestoreacorrectexecutionenvironment.
therefore automatically inferring the runtime environments of python code helps which can free up the time of programmers spent on dependency issues and thus is significant for code reuseand automated software configuration management.
however there are several challenges to automatic inference of python runtime environments.
let us see a python code snippet showninfigure1a.theimportedtop levelmodules namely redcap influxdb openfisca core andgpkit arenotbuilt inmodulesinthe python standard library.
executing pip install redcap receives the error message error no matching distribution found for redcap because redcapdoesnotexistonpythonpackageindex pypi and the package corresponding to it is pycap.
in fact it is commoninpracticethatthenameofamoduleimportedinpython code does not match the name of the python package it belongsto.
moreover after a successful installation with pip install influxdb another error message importerror cannot import name influxdbclusterclient appears whichindicatesthatthe latest version influxdb .
.
does not contain this attribute.
in fact the last version containing attribute influxdb.influxdbclusterclient is3.
.
.
a naive approach installs the python packages with the same names as the imported top level modules.
however this approach failstoinfercorrectdependenciesinmanycases asillustratedinthe above example.
the challenges are essentially the lack of sufficient domain knowledge.
dockerizeme builds an offline knowledge base semi automatically to infer the environment dependencies for python code snippets.
v2 searches working environments withproperversionsbasedontheerrormessagesofcodeexecution.
snifferdog buildsan apibankof pythonpackagestoinfer the ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa wei cheng xiangrong zhu and wei hu 1importurllib2 1numpy .
.
2importredcap 2openfisca core .
.
3frominfluxdb importinfluxdbclusterclient ascli 3pycap .
.
4importopenfisca core.simulations 4gpkit .
.
.
5fromgpkitimportunits variable model 5influxdb .
.
6fromgpkit.tools.autosweep importautosweep 1d b requirements.txt 8client cli.from dsn influxdb usr pwd host1 1frompython .
.
10a variable a m 11l variable l m 3copyrequirements.txt 12m1 model a 4runpip install r requirements.txt 13tol1 1e 14bst1 autosweep 1d m1 tol1 l verbosity 6copysnippet.py snippets snippet.py 15print solved after 2i passes cost logtol .3g bst1.nsols bst1.tol 7cmdpython snippets snippet.py a python code snippet.py c dockerfile figure a motivating example.
specificversionsandrestoretheexecutionenvironmentsofjupyter notebooks.thesepreviousstudieshaveachievedgoodperformancebyusingpre builtknowledgebases buttheydonotcoversufficient knowledge to accurately match more complex python code.
in this paper we design an elaborated ontology for python third party packagesandautomaticallyconstructpythonpackageknowledge graphs kgs by installing and analyzing the releases on pypi.
afterbuildingthedomainkgs wearestillchallengedbyhow to match the target code with python dependencies.
to cope with this we design a novel metric of matching degree and treat allattributesunderatop levelmoduleasawholetobetterdiscover requiredlibraries.furthermore dependencyconflictsoccurwhen differentinferredpackagesdependonthesamepackage butspecify different and incompatible versions of that package.
continuingtoconsiderthecodeshown infigure1a installingthelatestver sions of packages openfisca core andgpkitcauses a dependency conflict because openfisca core .
.
requiresnumpy .
.
andgpkit .
.
.
.
requiresnumpy .
.
.
thus we should choose an older version gpkit .
.
.
which requires numpy .
.3and is compatible with other packages.
dependency solving shouldensure that all direct dependencies and transitive dependencies i.e.
dependencies of dependencies are compatible with the rest of inferredenvironment.tothebestofourknowledge allprevious studies have not considered the compatibility of the inferred python environments yet.
due to the np completenessof dependency solving we propose a heuristic graph traversal algorithm to infer a compatible environment which efficiently selects the newer versions and prunes the traversal paths.
the main contributions of this paper are listed as follows we design an ontology for python third party packages and anautomaticapproachtokgconstruction.asaresult we createthepythonpackagekgsforpython2andpython3 eachofwhichcontainstheknowledgeofover10 000python packages and nearly versions.
sections wedefineanewmetricofmatchingdegreebetweenpythonlibraries and third party resources in target code to discover requiredlibraries.moreover weconsiderthecompatibility oftheinferredpythonenvironments anddesignanefficient heuristic algorithm for dependency solving.
sections figure overview of our approach.
we implement our approach called pycre and evaluate it with realworldpythoncodesnippetsongistable .ourexperiments show that pycre efficiently resolves dependency issues for bothpython2andpython3 leavingonly1 importerror which issignificantly superior to importerror of the state of the artapproach .
overview of pycre figure depicts an overview of pycre which automatically inferspythoncompatibleruntimeenvironmentswiththepre built pythonpackagekgs.thefundamentalrequirementofpycreis tocoverasmanythird partyresourcesusedinthetargetcodeas possible.additionally pycredirectlyspecifiesthepackagesand their versions in a feasible installation order to avoid the potential conflicts between inferred dependencies.
pycreconsistsoftwophases wheretheupperportionofthe figureshowstheconstructionofour pythonpackagekgs.allwe canknowfromtargetcodearetheimportedmodulesandthecalled attributes including the names of variables classes functions and even hidden submodules.
see figure 1a for example matching the third partyresourcesintargetcodetothecorrectlibrariesrequires agreatdealofdomainknowledge.accordingtoourdesignedontology we offline construct two python package kgs for python and python respectively.
thebottomportionshowstheautomaticinferenceofcompatible runtime environments.
with the python package kgs pycre authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
conflict aware inference of python compatible runtime environments with domain knowledge graph icse may pittsburgh pa usa parses a target python code discovers its candidate libraries accordingtomatchingdegrees andgeneratesthecompatibleruntime environment through dependency solving.
the output of pycre is a requirements.txt containing a list of required python packages with specific versions in a correct order and adockefile containing the inferred python version.
the dependencies in requirements.txt work together reducing the risk of dependency conflicts compared to installing dependencies individually.
for example figure 1b shows the requirements.txt generated by pycre for the python code shown in figure 1a.
the dockerfile shown in figure 1c installs all python packages with the command pip install r requirements.txt.
python package knowledge graph domainknowledgeofpythonpackagesisessentialforautomatic inferenceofcompatibleruntimeenvironments.wedevoteoureffortstodesigninganontologyforpythonthird partypackagesand a method to automatically construct the corresponding kgs.
.
python package ontology design as shown in figure we define an ontology to represent relationships between entities and properties for describing entities package node.
each package node represents a python package and stores the package s nameas a property.
the storedpackagenamesarenormalizedandunified making no two package entities having an identical name.
versionnode.
eachversionofapythonpackageisstoredas adistinctversionnode.aversionnodecontainsitsstandard versionidentifierand install status ofthecorrespondingrelease.therearethreevaluesfor install status success fail andunknown where unknown meansthattheversionhas not been installed yet.
module node.
each module node corresponds to a specific module of a version and has two properties.
property import status takes the value trueorfalse indicating whether the module can be successfully imported or not.
another property is the fully qualified name e.g.
clientis a submodule of module redis and its name is stored as redis.client.
however module names are not unique as different versions of a package may contain homonymous modules that have different attributes or even different packages may have homonymous modules.
attributenode.
eachattributenodestorestheattribute s nameasaproperty.unlikemodulenodes attributeswithan identical name are defined as a single entity in the ontology.
for example attribute redis.client.redis is saved as attribute redisof module redis.client.
in our ontology attribute can be variable function class or any content available in the corresponding module.
package version has version edge whichindicatesthe relationship between the package and its version.
version module module has module edge.
each successfullyinstalledversionhasmodulesinprinciple andmodules may have their submodules.
module attribute has attribute edge whichshowsthat the attribute is available in the module.packageversion module attributehas versionhas modulehas module has attribute requires figure entities and relationships defined in the python package ontology.
version package requiresedge whichrepresentsthat the package is a direct dependency of the version and has a requirement property to store the version specifier.
.
knowledge acquisition to extract knowledge we first determine the python packages that we want to analyze and get all available versions.
then we record the installation status by installing each version of the packages.
at last we acquire the modules attributes and direct dependencies of those versions that are successfully installed.
the whole process of knowledge acquisition is automated.
packages.
alistofavailabledistributionsonpypicanbeobtainedaccordingtopypisimple.1duetotheexpenseoftime and storage we usually specify a list of packages for further knowledgeacquisition.withtheknowledgeofcommonly used python packages in a certain domain the success rate ofinferredpythoncompatibleruntimeenvironmentscanbe greatly improved.
versions.
wegetallavailableversionsofeachpackageby executing pip install package version since manypackagesarenotavailableinexactlythesameversions under different python releases.
version is a special versionidentifierthatdoesnotexist whichmakespipoutput all available versions.
installations.
some releases have strict requirements for the supported python versions or even require system level dependenciesthatpipcannothandle.thus noteveryrelease onpypicanbeinstalledsuccessfully.weattempttoinstall eachversionofapackagewith pip install package version and record the installation status.
requirements.
most releases require certain direct dependenciestobeinstalledbeforetheirinstallations whichare stored in their metadata.
we get the dependency requirementsofeachsuccessfullyinstalledreleasefromits metadatafile.
dependency requirements prompt a lot of unknownpythonpackages duetotheincompletenessofour kg.wecreatepackagenodesforthesepackages butwithout further knowledge acquisition.
modulesandattributes.
apythondistributionusuallyhas multiplemodules.foreachsuccessfullyinstalleddistribution wefirstattempttogetitstop levelmodulesfrom top level.txt.
if that file does not exist we try to check all created directoriesandfilestoobtainitstop levelmodules.wethenfindall authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa wei cheng xiangrong zhu and wei hu submodulesofeachtop levelmodulerecursively.finally we try to import each module and use python built in function dir to attain all attributes of the imported modules.
we removethemodulesandattributesthatstartwiththeunderscore because they are conventionally intended for internal use.
after constructing the python package kgs we can periodically checkfornewpackagesandversionsbasedontheaboveprocess to incrementally upgrade our kgs.
note that pypi doesn t support the replacement of existing releases but only deletion we can also delete the corresponding entities and relations in our kgs thus ensuring the consistency of our kgs.
environment inference forenvironmentinference wefirstobtaintheimportedthird party modules and called attributes by parsing the target code.
then we queryourkgstodiscovercandidatelibrariesthatbestmatchthese modules and attributes.
finally we expand a dependency graph with transitive dependencies of candidate libraries and infer the installation instructions of compatible dependencies in order by dependency solving.
.
target code parsing astheonlyinput weassumethatthecodeshouldbefullyparsed.to determinewhichthird partylibrariestobeinstalled wefindallthe imported modules that are not in the python standard library and thecalledattributesinthosemodules.wefirstparsethetargetcode into an abstract syntax tree ast in a clean python environment and then walk in the ast for both of the following information importedmodules .thesyntaxforthe importstatementin pythonis import module as alias orfrom module import name as alias .themodulesinthepythonstandardlibraryareignored andwestoreallpossiblethird party modules as imported modules.
it is worth mentioning that name canbeasubmodule function class variableorany attribute that can be accessed in the module.
additionally programmers can bind an imported resource with an optionalaliasnameandusethealiasnamedirectlyinthecode butatthesametime theoriginalnameoftheimportedresource would no longer be used.
we record the mappings between the imported resources and their alias names.
calledattributes .inadditiontotheimportedmodules the attributes of those modules used in the code are also cru cial for discovering the candidate libraries.
we visit each attribute node in the ast and record all the attribute names prefixedwithanimportedresourceoritsalias.accordingto themappingobtainedfromthe importstatement wethen mapthe prefixback tothecorresponding importedresource name thus restoring its fully qualified name for each at tribute.
for example the fully qualified name of attribute from dsn isinfluxdb.influxdbclusterclient.from dsn line 8infigure1a .duetotheuncertaintyin from module import name wetreat module .
name asapossible attribute name as well.
we store these attribute names as called attributes.gpkit tools autosweep autosweep 1dvariable model units m figure a parse tree generated by target code parsing.
algorithm calculatesmatchingdegree s l input setsof resources list lof resources in the library output matching degree between sandl 1degree 2foreachres sdo 3pre longestprefixreferencepathof resmatchedin l 4degree degree pathlength pre pathlength res 5returndegree we represent the imported modules andcalled attributes as a forest.eachtreeintheforesthasatop levelmodulenameasarootnode andcontainsallthesubmodulesandattributesofthatmodule inthecode.forinstance byparsingtheexamplepythoncodein figure 1a the parse tree of module gpkitis shown in figure .
the results of target code parsing can be used to infer the candidate python versions.
we parse the code in python and respectively andthepythonversionswiththefewest importedmodules and no syntax errors are the candidates.
for example the imported moduleurllib2 line in figure 1a is a standard library in python 2andhasbeensplitintoseveralmodulesinpython3named urllib.request andurllib.error.
the sample code imports fewer nonstandardmodulesinpython2thaninpython3 andthusitspython version is inferred.
if the number of imported modules is equal we would extrapolate further in the following.
.
candidate library discovery in this phase for each candidate python version we query the correspondingpythonpackagekgtofindthecandidatelibraries that best match the forest obtained by code parsing.
for the resources i.e.
modules or attributes used in the code it is more reasonable to use partial matching than to precisely query thefullyqualifiednamesinthekgduetoincompleteknowledge.
however widely usedstringsimilaritymetricssuchaseditdistanceandjaccardcoefficient arenotapplicablehere asafullyqualified namerepresentsareferencepath e.g.
openfisca core.simulations andsapphire.simulations aretwocompletelyunrelatedmodules.we define a metric based on the longest prefix match of the reference pathtocalculatethematchingdegreebetweenalistofresourcesand a library as shown in algorithm .
reference paths in python are separatedbydots.forexample thelengthofthereferencepathfor resourceinfluxdb.influxdbclusterclient.from dsn is3.although therelease influxdb .
.
hasattribute influxdb.influxdbclient its longest prefix reference path is influxdband matching degree is1 .
we discover candidate libraries separately for each parse tree in the forest according to the following steps authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
conflict aware inference of python compatible runtime environments with domain knowledge graph icse may pittsburgh pa usa s1.wequerytherootnodeoftheparsetreeinthekg which referstoatop levelmodule.iftherearemoduleentitieswith thesamenameinthekg wedirectlygotos2withthequery results.otherwise weattempttoinstallapythonpackage with the same name as the top level module.
s2.theremaybedifferentversionsorevendifferentpackages thathavethesame top levelmodule sowefilterthese candidatesfurtherbysubmodules.wesetmax hopasthedepth of the parse tree and query our kg to obtain spanningtrees reachable from the top level modules following thehas module relationships to max hop.
then we calculate thematchingdegreebetweentheimportedmodulesandthe modules with import status astruein each spanning tree.
the candidate spanning trees with the highest matching degree are retained.
s3.sincetheversionupdatesmaycausetheadditionorremoval ofattributes weneedtoselecttheproperversions.weenrichthespanningtreesbyqueryingtheattributesofmodulesintheparsetree.similarly wecalculatethematchingdegreebetweenthecalledattributesandtheresourcesineachspanning tree.
the candidate trees with the highest matchingdegree are retained and their corresponding libraries are optimal for the parse tree.
after our discovery process we finally determine the candidate libraries of each parse tree in the forest which may correspondto multiple versions of more than one package.
meanwhile thepython version with the maximum matching degree is selected.
python is the default if their matching degrees are equal.
.
dependency solving tocovermostthird partyresourcesusedinthetargetcode each top level module should have at least one candidate library in the inferred runtime environment.
furthermore we expect each package in the inferred environment to meet all its version constraints which is called dependency solving.
dependency solving is a hard problem in all non trivial component models and has been proved np complete .
existing worktreatsdependencysolvingasaseparateconcerninpackage manager andreliesongenericdependencysolversbasedonthe tried and tested techniques such as solvers of the boolean satisfiability problem sat .
there are efficient modern sat solvers but it is nearly impossible to control the answers provided by the solvers with many priorities.
for optional versions of a python package we prefer the latest version that can be in stalled successfully since the latest version is usually downward compatiblewithpreviousversionsandcontainsnewresources.fortimeefficiencyandcompliancewithversionselectionpriorities we propose an efficient heuristic graph traversal algorithm.
we create a start node which points to all the virtual nodes that representthetop levelmodules.wequeryourkgsforalltransitive dependenciesofthecandidatelibraries formingaheterogeneous directedgraphcalleda dependencygraph.thedependencygraph wouldbeiterativelyextendeduntiltherearenomoredependencies.
thenodesinthedependencygrapharedividedintoconjunction nodesanddisjunctionnodes.conjunctionnodesincludethestart node and version nodes which depend on all its direct successors.disjunctionnodesincludemodulenodesandpackagenodes which require at least one direct successor.
moreover each edge pointing to a package node is attached with specific dependency requirements whichrestrictthechoiceofitsversions.theversionsthat failtobeinstalledduringknowledgeacquisitionarenotconsidered.
definition compatible dependency subgraph .letg v e beadependencygraph where vdenotesthevertexsetincluding packages versionsandmodules and edenotesthedirectededgeset based on the dependency relationships.
a compatible dependency subgraph g prime v prime e prime ofgsatisfies i v prime v e prime e and start node s v prime.
ii we denote edge a bby a b and regard a specific versionrequirementasacollectionofversionsthatsatisfythe requirement.
compatibility requires for each conjunction node c v prime e c n e e e prime.
foreachdisjunctionnode d v prime lets e e d n e e prime s ifdis a package node .
for each package node p v prime letr requirement of e e i p e prime p n e prime n intersectiontext.
r rr.
sat solver.
withthedependencygraph eachnodecorresponds to a boolean variable and the constraints are encoded as a boolean formula in conjunctive normal form cnf .
the constraints of a dependencygrapharetranslatedintobooleanclausesincnfaccording to the following rules start node sis set totrue denoted by s .
a conjunction node cdecides all its direct successors x1 x2 ... xn c x1 xn logicalandtext.
i n c xi .conjunction nodes include the start node and version nodes.
adisjunctionnode ddecidesatleastoneofitsdirectsuccessorsx1 x2 ... xn d x1 xn logicalortext.
i n xi d .
disjunctionnodesincludemodulenodesandpackagenodes.
a virtual module node mrequires at least one of its candidate versions v1 v2 ... vn m v1 v2 vn logicalortext.
i n vi m .meanwhile eachcandidateversion vi requires its package pi logicalandtext.
i n vi pi .
a package node only has one of its versions v1 v2 ... vn logicalandtext.
i n i j n vi vj .
a version node vis incompatible with versions v1 v2 ... vn of its direct dependencies that do not meet the specific requirements v v1 v2 vn logicalandtext.
i n v vi .
iftheformulaissatisfiable theresultingcompatibledependency subgraph would consist of all the nodes with value trueand the edges between them.
ourheuristicalgorithm.
thedetailsofouralgorithmareshown in algorithm and we start traversing from the start node with an empty subgraph.
with the depth first search dfs our algorithm has two heuristic strategies i priority we prefer the latest version line that can be successfully installed by sorting all compatible versions line ii pruning if one version of a packageisincompatible weskiptheotherversionsofthatpackagewith identicaldependencyrequirements line15 becausetheywould cause the same conflicts.
when the currently selected version ofa package does not satisfy the newly added version constraints the current version and all its direct dependencies and transitive dependencies need to be removed from the subgraph line .
we authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa wei cheng xiangrong zhu and wei hu algorithm extendssubgraph g prime n p input subgraph g primeto be extended current traversed node n direct predecessor pofnin this visit output trueorfalse indicating whether a compatible subgraph can be found.
1tmpg g prime and add node nand edge p n totmpg 2ifnis a conjunction node then 3foreachdirect successor cofndo if extendssubgraph tmpg c n then returnfalse 6g prime tmpg returntrue 7else 8c version sorted direct successors of nwhich are compatible in tmpg 9ifexists edge n d tmpgthen ifd ctheng prime tmpg returntrue elseremove n d and recursively remove the dependencies of version dfromg prime 12whilecis not empty do ifextendssubgraph tmpg c n then g prime tmpg returntrue elseremovec and the elements that have the identical dependency requirements in c 16returnfalse only backtrack on the current search path when we encounter a dependencyconflict whichishighlyefficientbutinrarecasesmay miss solutions.
to address it we call a sat solver as the fallback to ensure the completeness of our algorithm when it claims that there is no solution.
let us see the dependency graph in figure .
according to dfs our algorithm first traverses to openfisca core .
.
depending on numexper .
.
thatrequires numpy .
.thus thelatestversion .
.6ischosenfor numpy.whenconsideringthedirectdependency ofopenfisca core .
.
onnumpy itisfoundthat numpy .
.
does not meet the new version requirements .
.
.s o numpy1.
.6is removed it does not depend on other packages and a compatible version .
.4is reselected.
when traversing to the packagegpkit we prefer the latest version .
.
.
.
.
however its versionrequirement .
.4fornumpyconflictswiththeprevious requirement .
.
so we reselect the version of gpkit.w e skip version .
.
.
which has the identical requirement for numpy as the incompatible version .
.
.
.
and traverse to version .
.
.
.
the version requirements of gpkit .
.
.
are compatible and the currentversionof numpymeetsalltherequirements.now wefind a compatible dependency subgraph using our heuristic algorithm.
at last we identify the packages that need to be explicitly installed as well as the installation order.
after removing the start nodeandmodulenodesinthesubgraph allpackageswithanindegreeof0arerequiredtobeinstalledexplicitly sincetheyarenot the dependencies of any packages.
moreover for a package if the latestversionthatmeetsitsversionconstraintsisdifferentfromthe selected version it would probably lead to an unexpected version start gpkit gpkitopenfisca coreopenfisca core .
.
.
.
.
.
.2numpy25.
.
numexper .
.
.
.
.
figure5 partialdisplayofadependencygraph.nodecolorsare in accord with the colors of entity types in figure ex cept for the start node.
nodes with dashed outgoing edgesareconjunctionnodes andnodeswithsolidoutgoingedgesare disjunction nodes.
best viewed in color.
sowe installthispackage explicitly aswell.the installationorder ofallpackagesisgeneratedbytopologicalsorting whichensures that all dependencies of each package are installed ahead of time.
evaluation .
experiment settings dataset.
we conduct ourexperiments onthe gistable dataset which is a real world dataset built on the github s gist system and contains single file python code snippets.
dockerizeme and v2 have also been evaluated on this dataset.
comparative methods.
in addition to our pycre several comparative methods are assessed in the experiments gistable which attempts to install the python packages withthesamenamesastheimportedtop levelmodules.it is a baseline method and does not use any knowledge.
dockerizeme whichinferstheruntimeenvironments based on a pre built knowledge base without considering python versions nor specific dependency versions.
v2 which reuses the inference results of dockerzieme as the starting environments in python and python and guides the version changes by the error messages of code execution until finding a working environment.
snifferdog which usesa pre builtapibank torestore the execution environments of jupyter notebooks.
prior knowledge.
for the fairness of our experiments all methodsshouldacquireknowledgeforthesamepythonpackages.we obtain a list of python packages from the knowledge base built by dockerizeme .accordingtopythonenhancementproposals pep pythonpackagenamesarecase insensitiveanddonot distinguishbetweendash dotandunderscore.so wemergetheduplicatepackagessuchas flask restful andflask restful.eventually we have unique python packages for knowledge acquisition.
theknowledgebasebuiltbydockerizemeforthe10 765python packages is available.
v2 uses the inference results of dockerzieme as the starting environments so it can be ignored.
it is worth mentioning that the knowledge acquisition of dockerizeme is not fully automated but requires manual work.
snifferdog only acquires knowledgeforaspecialselectionof488pythonpackages.inthis paper we build its api bank for the packages using its publiclyavailablecode.wealsoautomaticallyconstructourkgsfor python2andpython3bythemethoddescribedinsection3.
.the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
conflict aware inference of python compatible runtime environments with domain knowledge graph icse may pittsburgh pa usa table1 statisticsoftheexitstatusofcodeexecutiononthe gistable dataset.
exit status python python success timeout importerror syntaxerror other exceptions knowledge of pycre and other methods is stored in a neo4j database exceptforsnifferdog whichisloadeddirectlyintomemory according to its design.
validationenvironment.
weleveragedockertoensurethateach pythoncodeexecutesinanisolatedenvironment.forpython2and python3 ourdockerimagesareinitializedontheofficialimages python .
.
andpython .
.
respectively.weupdatepiptothe latestversion currently20.
.4and21.
.4forpython2andpython3 respectively.
we configure pip to use its new dependency resolver by default which refuses to install the packages with incompatible requirement combinations.
we conduct all experiments on ubuntu .
lts with one intel xeon gold cpu and 16gb memory.
experiment procedure.
giventhatonlyourpycreandv2can infer the python version for target code and v2 cannot specify afixed python version we conduct the experiments in three environments python python and the inferred python versions.
for each method we first infer dependencies for each code in thedatasetandrecordthetimespentontheinferencetoanalyze the efficiency.
the timeout of inference is set to one hour since v2 isadynamicinferencemethod whichneedstorepeatedlyrollback theversionsandgeneratethevalidationenvironments.thecode toinfer dependenciesinsnifferdog isincomplete so wereplicate it according to their paper for enabling snifferdog to infer the dependencies of python code.
then we record the inferred python dependencies in requirements.txt in order and build the docker image according to the experimental settings.
to avoid the failures due to network fluctuation or other factors we give ten minutes for each python package installation whenbuilding each docker imagefor validation.
failures to install dependencies when building images are ignored which is in line with the behavior of programmers.
finally we run the code in the corresponding docker container.
the code snippets that run successfully are marked as success.
wemarkthecodesnippetsrunningformorethanoneminuteas timeout because some code may not stop running due to awaiting input encountering dead loops etc.
the othersare marked as exception andthenamesoftheirexceptionsarerecorded.sincev2 onlyreturnsdependencieswhenitfindsaworkingenvironment foreachfailedcode weselecttheexceptionnameofthelastvalidationfromitsoutputlogs.built inexception importerror israisedwhen animportstatement fails to find the module definition or when a from ... import statementfailstofindthenametoimport.we alsoincludepython3 sbuilt inexception modulenotfounderror asimporterror which is a subclass of importerror and raised byimportwhen a module cannot be located.table statistics of our python package kgs.
entity python python package version 841module 182attribute total 851relationship python python has version has module has attribute requires total dataset analysis.
we run each code in the gistable dataset in the validation environment and the exit status is shown in table .
thereare4 388codesnippetswith syntaxerror inpython3 much morethan719inpython2 whichinclude454codesnippetsthat havesyntaxerrorsinbothversions.thedifferenceinthenumberof code snippets that run successfully also indicates the bias towards python2inthedataset.allautomaticinferencemethodsonlyfocus on dependencies i.e.
importerror because it is almost impossible toautomaticallyresolveerrorsinthecodeitselformissingexternal inputs such as database .
so our experiments only validate the inferred environments of code snippets with importerror.
.
evaluation of knowledge graph our knowledge graphs.
knowledge acquisition is indeed timeconsuming which takes about hours using normal cpu cores.
the rest of the building process is negligible in comparison.
thewholeprocesscanbeeasilyacceleratedbyparallelization thus reducingtime andeffort toa greatextent.table 2shows thescale ofourpythonpackagekgsandthequantitiesofeachtypeofentities and relationships.
excluding those packages for which no version is available in the corresponding python environments we analyze and packages in python .
.
and python .
.
respectively.theextra2 325and2 375packagesareadded duetopackagedependencies butwedonotperformknowledgeacquisition for these packages to ensure the fairness of knowledge.byfurtheranalyzingourkgs wefindthat74 .
and .
versions fail to be installed and .
and .
modules fail to be imported in python and python respectively due to various issues such as missing dependencies and incompatible python versions.
this indicates that thereleasesonpypicannotalwaysbeinstalledsuccessfully and the modules andattributes obtained by statically parsing the code cannot always be used successfully.
moreover nearly of the successfully installed versions have at least one direct dependency showing the necessity to consider the compatibility of inferred dependencies.
domain knowledge.
to compare the knowledge acquired by differentmethods wecountthequantitiesofversions modulesand attributes which are shown in table .
the modules and attributes with the same full qualified names are counted only once and the packageshaveatleastoneversion.dockerizemeanalyzesthelatest version of each package to get the name of top level modules containing the fewest domain knowledge.
snifferdog downloads all releases on pypi for each package and statically parses the python codetogetallthedefinedapis.itfailstogetanytop levelmodules for 831packages mainly because itcannot infer thepython versionsneededforstaticparsing.incontrasttoourpycre snifferdog getsslightlymoreversionsandattributes butcannotdeterminethe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa wei cheng xiangrong zhu and wei hu table comparison of domain knowledge acquired by different methods.
method package version module attribute dockerizeme snifferdog pycre python pycre python table4 comparisonofknowledgecoverageonthegistable dataset.
method top level module submodule attribute dataset dockerizeme snifferdog pycre python availability of this knowledge which may cause unexpected errors in the inferred environments.
additionally we add submodules intothepythonpackageontology.theacquisitionofsubmodules providesalargeamountofmoduleknowledgeforpycre which are useful to infer appropriate dependencies.
knowledgecoverageondataset.
weanalyzethecoverageofthe knowledgeacquiredbyeachmethodonthegistabledataset which significantlyinfluencestheresultsofinference.consideringthat thedatasetismorebiasedtowardspython2 weparseeachcode under python .
.
by the approach presented in section .
.
we dividetheimportedmodulesintotop levelmodulesandsubmodules since only our method supports queries for submodules.
the analytical results are shown in table .
compared to dockerizeme and snifferdog our kg has the maximum coverage on all types of knowledge but still lacks a large amount of knowledge about the dataset.
only800 .
top level modules arecovered in our kg which means that in many cases pycre can only choose to installthepythonpackagewiththesamename.submodulesand attributes are covered with .
and .
respectively.itincreasesthedifficultyofdiscoveringcandidatelibraries which reflects the realistic limitations of exact matching and the necessity of our matching degree.
.
evaluation of inference we evaluate the effectiveness and efficiency of pycre in inferring python compatible runtime environments.
table shows the validation results of the inferred environments by each method.
importerror.
the most intuitive assessment is the ability to resolve importerror which reflects the effectiveness of the runtime environmentinference.asshownintable5 pycreresolvesthe most importerror inallthreedifferentsettingsandissignificantly better than the comparative methods.
gistable the baseline method that is consistent with the programmer s behaviors in solving dependency issues fails to resolve importerror for2 592gistsand1 751gistsinpython2andpython respectively.
dockerizeme fails to resolve importerror in more gists than the baseline gistable s method mainly because of itstable validation of the inferred environments generated by each method in different python releases.
method importerror success timeout others dataset gistable 248dockerizeme 225snifferdog 402pycre a environment validation in python .
method importerror success timeout others dataset gistable 347dockerizeme 199snifferdog 404pycre b environment validation in python .
method importerror success timeout others v2 144pycre c environment validation with the inferred python versions.
methodofmatchingtargetcodeandpythondependencies.dockerizeme uses partial matching for imported modules to find libraries in the knowledge base which is based on the longest prefix of the module name.
for example statement from pyspark.sql.functions importudf inthecodesnippet2ismappedtothepackage py becausethereisnomodule pysparkandthelongestmatchedprefixis modulepyindockerizeme sknowledge base.howeve r thepython packagecorrespondingtothismoduleis pyspark whichisthepackage that other methods choose to install.
in fact dockerizeme uses domain knowledge to solve code for which baseline cannot solve importerror butfailstosolve514codeforwhichbaseline can solve importerror in python .
although these two methods do not specify versions for the inferred packages which minimizes the version restrictions they still encounter dozens of dependency conflicts.
sincev2usestheinferenceresultsofdockerziemeasthestarting environments its performance is similarly affected.
v2 claims to findworkingenvironments for3 206code but133of themdonot runsuccessfullyinourvalidation andevenhavedependencyissues.
one major reason is that v2 does not consider the compatibility betweenthe packagesinthe inferredenvironments.
additionally dockerizeme and v2 install some packages incidentally according totheirassociationrules whichleadstomanyredundantpackages and is also more likely to cause dependency conflicts.
snifferdogachievesrelativelygoodperformance mainlybecause it has a large amount of api knowledge to assist its inference.
however snifferdogisdesignedforjupyternotebooksandignores some issues in python such as the inference of python versions which affects its applicability on more general python code.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
conflict aware inference of python compatible runtime environments with domain knowledge graph icse may pittsburgh pa usa table6 averageandlongestinferencetimeofeachmethod for5 655codesnippetswithatleastonethird partypackage and have no inference timeout in all methods.
method dockerizeme v2 pycre avg.
time s .
.
.
max.
time s .
.
.
workingenvironments.
another valuable metric is the number ofworkingenvironments whichindicatestheabilityofaninference method to restore the runtime environments of python code.
as shown in table pycre infers a successfully runnable environment for the most python code snippets in all three different settings.moreover thecodemarkedas timeout usuallyhasadead looporawaitsinputs andcanbetreatedas successatleastuntil theytimeout.inthissense itcanbeassumedthatpycreinfers the working environments for .
gists which is also the best result among all methods.
inferencetime.
inferencetimeisacrucialmetricfortheefficiency ofinferencemethodsandrepresentstheuser swaitingtime which is one of the most important performance metrics for software.
as listed in table we evaluate the average inference time and thelongestinferencetimeforeachmethod.weonlyconsiderthe 655giststhathaveatleastonethird partypackageinpython2 or python and have no inference timeout in all methods.
since the api bank of snifferdog is loaded in memory and does notquery an external database we do not discuss its inference time.
theinferencetimeofdockerizemeandpycre whichfullyuses pre built knowledge bases are short and comparable whereas v2 which involves online execution has a much longer inference time.
itisworthnotingthatonlytheinferenceofv2for353gistsdoes not finish in one hour.
ablation experiment.
to validate the effectiveness of our proposed heuristic algorithm we exclusively use the sat solver to conductanablationexperiment i.e.disableourheuristicalgorithm whichiscalledpycre satonly .intheinferredpythonversion pycre satonly infers3 337environmentsmarkedas success and marked as timeout leaving importerror .
pycre withtheheuristicalgorithm shownintable5c issuperiortopycre satonly inthevalidationofinferredresults.theaverage solvingtimeoftheheuristicalgorithmis0.2secondswhilethesat solver is .
seconds.
however the longest time of the heuristic algorithmis8.4seconds whichismuchlowerthan219.3secondsof the sat solver and the difference becomes more significant as the sizeofthedependencygraphincreases.moreover comparedtoourheuristicalgorithm onlyusingthesatsolverhasproblemscaused byrandomness.thesatsolvermaychooseoldversionsaslong asthedependencyrequirementsaremet butitusuallyleadstoa lossofcompatibilitywithnewerversions.also theenvironments inferred by the sat solver are variable and have the potential to introduceredundantdependencies whichmaycausetroublesfor users.basedonouranalysis ourheuristicalgorithmsolves5 .
ofthe5 637codesnippetsforwhichhaveatleastonedependency and a compatible solution.
we believe the approximation of ourheuristic algorithmisgood.
besides whilespecifyingaversion for each inferred package can better match the target code such24.
.
.
.
.
.
.
importerror oserror systemexit nameerror syntaxerror attributeerror others figure proportions of exceptions thrown by the environment validation inferred by pycre.
versionrequirementsaremorelikelytocausedependencyconflicts.
incontrast ourapproachiseffectivelyconflict awarethroughdependency solving with dependency conflicts occurring only in inferred environments.
exception statistics.
we further analyze the exceptions in table 5c for the validated environments inferred by pycre.
we include the subclasses of an exception in the count of that exception and the results are shown in figure .
except for importerror the three most common python built in exceptions are oserror systemexit andnameerror which are mainly caused by code design or missing extra inputs and cannot be solved by installing dependencies.
syntaxerror israisedlargelyduetothetargetcode itself.moreover attributeerror israisedwhenanattributereference fails mainly due to the reference on nonetype and some third party resource.
therefore we can assume that in most cases the packages are also compatible in the inferred environments where importerror is resolved by pycre.
practicalsignificance.
theeffectivenessandefficiencyofpycre contributes to software engineers solving dependency issues of python code in practice.
beginners often have difficulty building a runtimeenvironmentforsamplecode andprofessionalprogrammers also waste muchtime with complicated versions and dependencies.
as in the manual evaluation on the gistable dataset it takes software engineers between minutes and hours to build theruntimeenvironment whiletheaverageinferencetimeof our approach on this dataset is only seconds which can significantly improve the efficiency of development.
considering the performance of pycre it is also important for the development of automated configuration management.
.
threats to validity theresultsofourexperimentsmaysufferfromseveralthreatsto validity.thefirstisthefairnessofknowledge whichcanlargely affect the inferred results of individual methods.
for this reason all methods in our experiments acquire knowledge based on the same packages following their own methods.
however the knowledge base shared by dockerizeme and v2 was previouslyconstructed and the latest versions of python packages in it are sometimesnotthelatestversionsatnow.wethinkthatthishaslittle authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa wei cheng xiangrong zhu and wei hu impact on the experimental results because the dataset was proposed earlier than the construction of the dockerizeme knowledge base whichmeansthatthecodeactuallyreliesonolderversions ofthe packages.oppositely more newversions inpycre alsoincrease the difficulty of inference.
another threat is timeout in the validation results.
the code that is marked as timeout does not throw any exceptions in a minute but this does no guarantee that therearenoproblemsinsubsequentexecution.consideringthat the import statements for resources are usually at the beginning of the python code code that executes with a timeout usually does not have dependency issues which mitigates this threat.
.
case study inadditiontoresolvingthecompatibilityofinferredenvironments the following python code snippets illustrate several other unique capabilities of pycre.
skip unusable releases.
pycre obtains the real status of package installations andmodule imports withknowledge acquisition which can guide pycre to skip the releases that are actually unusable.
see the code snippet excerpted from a real world gist 1frompytubeimport youtube 2defdownload video video url output youtube youtube video url video youtube.filter mp4 return video.download output notethatthiscodeisonlycompatiblewithpython2.gistable and dockerizeme generate pip install pytube to install the dependency which means that the latest version pytube .
.
in python would be installed by default.
however after successfully installing the package it fails to import pytubein the code which raisesanexceptionduetotheprobleminthisversionitself.v2fails to find a working environment for this code because it encounters timeout while verifying the candidate environment resulting in no information available toguide the version changes.
snifferdog statically parses all versions of pytubeand the latest version .
.
contains the attribute pytube.youtube so it selects pytube .
.
which fails to be installed and is actually only available in python .
in the knowledge acquisition phase we already know that the modulecannotbesuccessfullyimportedintheseversions sobased onourpre builtkgs pycreskipstheunusableversionsandinstalls pytube .
.
.
avoid useless downloads.
if one version of a package fails to beinstalledorisincompatiblewithotherpackages pipwouldattempt to install other versions instead which is also known as the backtrackingbehavior.4sincepipdoesnothavefullpackagedependencyinformationbeforedownloadingthepackage itmayleadtoa large number of unnecessary downloads which increases the time andsystemmemoryspentonbuildingtheruntimeenvironment.
skippingunusablereleasesasdescribedabovecanavoidtheuseless downloadscausedbyfailedinstallations.the importstatements below exemplify the strength of our approach in another aspect.
np 2fromdeepwalk.graph import graph the dependencies that are inferred to be explicitly installed by all the methods except pycre are numpyanddeepwalk.
pip first downloads numpy .
.
and then downloads deepwalk .
.
.
however deepwalk .
.
dependson gensim .
.
whichrequires numpy .
.1andisincompatiblewith numpy .
.
sonumpy1.
.1is downloaded again.
this causes a redundant download for numpy.basedontheuniqueknowledgeofdependencies pycre infersthatonly deepwalk .
.
needstobeinstalledexplicitlyand that compatible numpy .
.
would be installed automatically.
related work .
python runtime environment inference therearemanystudiesrelatedtosoftwarekginsoftwareengineering .
dockerizeme is a pioneering work which offline builds a knowledge base to infer the language system level environment dependencies required for python code to execute withoutimporterrors.comparedwithit ourpycrehasseveral significant differences.
first dockerizeme only considers the latest versionofeachpackage whichcannothandleremovalorrenaming thatmayaccompanywithversionchanges.second dockerizeme mapsthetop levelmodulestopythonpackages anddoesnotobtain submodules and attributes.
however there may be multiple versionsofdifferentpackagescontainingmoduleswiththesame name whichneeds furtherdecision basedon theattributes called in the code.
v2 enhances dockerizeme by exploring the possible configurationspaceforapythoncodesnippet.itvalidatescandidate environments iteratively through code execution and applies environmentmutationtogeneratenewcandidateconfigurationsaccordingtothefailuremessages.whilev2canfindsuccessfulruntime environmentsforsomepythoncode itsfeedback directedsearch is quite time consuming and even fails when an incorrect version does not manifest as a crash.
on the contrary pycre infers the appropriatepythonlibrariesusingthepre builtkgs whichisan efficient approach.
snifferdog is committed to restoring the execution environmentsofjupyternotebooksandevenreproducingtheresults.
it builds an api bank to record mappings from popular python librariestotheirapisbyparsingthepythonfiles.severalaspects affecttheeffectivenessofitsenvironment inference.first itsapi bankstoresonlypublicfunctions butotherpublicsubmodulesand variablesshouldalsobeconsidered.second thestaticanalysismay failtogetanyknowledgeduetotheuncertaintyofpythonversions usedbythereleases.third itdoesnotguaranteethatthedefined apis can actually be called since the packages and modules where these apis are located may fail to be installed or imported.
asfarasweknow thereisnostudyaddressingthecompatibility of the inferred environments like our work.
.
dependency solving dependency solving and some of its variants has been provedtobenp complete whichcanbeeasilyencodedintoasatsolv ing problem using cnf .
any solution of sat is equally authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
conflict aware inference of python compatible runtime environments with domain knowledge graph icse may pittsburgh pa usa valid butpracticallysomesolutionsarebetterthanothersfordependency solving.
trezentos et al.
defined the software dependencyproblemasanextensionofthesatformulationcalled pseudo booleanoptimization pbo .thereareseveralefficientpbo solvers such as open wbo solver and sat4j solver and pseudo boolean constraints can be translated into clauses that can be handled by a standard sat solver .
abateetal.
reviewedproposalsfromthedependencysolving fieldinrecentyears.theytreatdependencysolvingasaseparate concern in component evolution management .
although a few popularpackagemanagerslikeeclipsep2usesatsolversfordependencysolving thevastmajorityofpackagemanagersincluding pipstillusescustomizeddependencygraphtraversals.thetraditionaldependencyresolverofpackagemanagersreceivesaspecificinstallation request given by the user whereas dependency solving inpycreneedstodeterminetherequiredinstallations whichis more difficult.
fortunately we have global knowledge through the pre built python package kgs which enables us to heuristically prune the search path for generating the compatible environments.
conclusion and future work inthispaper weproposeanapproachtoautomaticallyinferring python compatible runtime environments with domain kg.
we design a domain specific ontology for python third party packages and propose an automatic approach to constructing the python package kgs.
given a python code we discover candidate libraries by measuring the matching degree with third party resources used in the code.
furthermore we propose a heuristic graph traversal algorithm to infer the compatible runtime environment.
compared with existing approaches we show the superior effectiveness efficiency and compatibility of our approach in runtime environment inference.ourapproachcancontributetoautomatedsoftwareconfiguration management and facilitate code reuse.
in future work we will acquire knowledge for more python packages and improve the coverage.
we also plan to add the deprecation information of modules and apis into the kgs and use ittofurtherinferappropriateversions.besides wewillextendthedependency inference to the entire project instead of single file codeandconsiderthecompatibilitywithlocaldependencies which is more general in practice.
finally we will apply our approach toother languages with transitive dependencies such as node.js.