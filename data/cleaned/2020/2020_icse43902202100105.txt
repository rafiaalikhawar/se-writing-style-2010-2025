bounded exhaustive search of alloy specification repairs sim on guti errez brida y germ an regis guolong zhengz hamid bagheriz thanhvu nguyenz nazareno aguirre y marcelo friasyx department of computer science fcefqyn university of r o cuarto argentina ynational council for scientific and technical research conicet argentina zdepartment of computer science engineering university of nebraska lincoln usa xdepartment of software engineering buenos aires institute of technology argentina abstract the rising popularity of declarative languages and the hard to debug nature thereof have motivated the need for applicable automated repair techniques for such languages.
however despite significant advances in the program repair of imperative languages there is a dearth of repair techniques for declarative languages.
this paper presents beafix an automated repair technique for faulty models written in alloy a declarative language based on first order relational logic.
beafix is backed with a novel strategy for bounded exhaustive yet scalable exploration of the spaces of fix candidates and a formally rigorous sound pruning of such spaces.
moreover different from the stateof the art in alloy automated repair that relies on the availability of unit tests beafix does not require tests and can work with assertions that are naturally used in formal declarative languages.
our experience with using beafix to repair thousands of realworld faulty models collected by other researchers corroborates its ability to effectively generate correct repairs and outperform the state of the art.
i. i ntroduction software has become ubiquitous and many of our activities depend directly or indirectly on it.
having adequate software development techniques and methodologies that contribute to producing quality software systems has therefore become essential for many human activities.
a well established approach to achieving quality is to emphasize good problem understanding and planning ahead of development i.e.
to put an emphasis on the analysis and design phases of software development .
these phases need to deal with descriptions of software and problem domains which are typically captured using specification or modeling languages.
techniques and tools that allow users to analyze specifications are very important as they help developers in discovering flaws such as missing cases in the specifications wrong interpretations of requirements etc.
two main problems arise in this phase correctly understanding the problem situation thus capturing the right problem and correctly stating the problem in the language at hand thus capturing the problem right .
in the context of formal specification where formalisms with formal syntax and semantics are employed the latter problem is particularly relevant as the developer has to master the notation to correctly capture in a formal way a given software description .
even for experienced developers many times subtle errors arise like mistakenly using the wrong expression to capture a property omitting an operator or using an operatorin place of another leading to incorrect specifications that do not capture the developer s intentions .
these kinds of mistakes share characteristics with program defects.
therefore techniques for dealing with these defects and in general to assess or improve software quality such as techniques for bug finding and program debugging are also relevant in the context of software specifications.
in particular techniques for improving debugging e.g.
via the automation of fault localization or program repair are pertinent in the context of software specification.
this paper targets the problem of automatically repairing formal specifications more precisely specifications in alloy a formal language that has many applications in software development and has been successfully applied in a number of domains such as the discovery of design flaws in telecommunication applications the analysis of security mechanisms in mobile and iot platforms the automation of software testing and the verification of programs among other applications .
while specifications share a number of characteristics with programs certain characteristics make it non trivial to apply the broad range of techniques for program repair in the context of specifications.
for instance as a way to tame the space of candidates various program repair techniques such as genprog only use coarse grained syntactic modifications such as block replacement swapping deletion and insertion but no intra statement modifications are allowed.
the rationale is that good levels of repairability in programs are achieved via coarse grained modifications thanks to redundancies that are present in code especially in larger programs.
such redundancies are not often seen in specifications in particular due to the relative conciseness of specifications compared to programs.
other approaches to program repair e.g.
par restrict the modifications to patterns learned from human written patches mined from large repositories categorizing fixes such inputs for the repair process are not available in the context of formal specification simply because as opposed to source code there are no large repositories of specifications.
finally most program repair techniques rely directly or indirectly on the availability of test cases while there exist initiatives that incorporate test cases to specifications other forms of checking such as property satisfiability and verification are ieee acm 43rd international conference on software engineering icse .
ieee more naturally found in specifications.
in this paper we present beafix a novel technique that automatically repairs faulty alloy specifications.
beafix has several features distinguishing it from the state of the art .
firstly the technique does not depend on test cases neither for fault localization nor for specification repair it supports any kind of specification oracle notably the typical assertion checks and property satisfiability checks found in alloy specifications as well as test cases.
it is then more widely applicable in the context of formal specification where test cases are rarely found accompanying specifications.
secondly the technique tackles automated repair in a bounded exhaustive way i.e.
by exhaustively exploring allpossible repair candidates for a given set of mutation operators and maximum number of applications on a set of identified suspicious specification locations .
thus it either finds a fix or guarantees that no fix is possible within the provided bound and with the considered mutation operators over the identified faulty locations.
this approach is natural to the context of alloy where users are accustomed to bounded exhaustive analyses.
beafix supports fine grained mutations and is designed to enable the repair of multi location specification defects.
since bounded exhaustive exploration suffers from inherent scalability issues our technique features a number of pruningstrategies that leverage the use of the alloy analyzer tosoundly prune large parts of the candidate space.
more precisely given a candidate repair for a specific suspicious location our technique exploits both a syntactic analysis of the specification and a semantic analysis using the alloy analyzer for checking the feasibility of this candidate in the sense that applying this specific repair candidate to the corresponding location preserves the feasibility of the overall multi location repair.
when feasibility fails it allows us to prune in a sound way i.e.
without losing valid fixes significant parts of the search space for repair candidates thus reducing specification repair running times.
we evaluate our technique on a benchmark of alloy specifications including specifications previously used in assessing arepair and a large benchmark of faulty alloy specifications produced by students .
our evaluation shows that our pruning technique significantly reduces specification repair running times duplicating the number of repairs that can be produced within a hour timeout and reducing the repair time by 62x on average.
moreover when specifications feature typical assertions and these are used as oracles our technique shows a significant improvement in overfitting reduction compared to the test based technique arepair.
ii.
a nillustrating example in this section we introduce both alloy and our technique by means of a motivating example.
alloy is a formal specification language with a simple syntax and a relational semantics.
the syntax of the language is rather small and is compatible with an intuitive reading of specifications or models as they are typically called in the context of alloy we will use specification andmodel interchangeably in this paper .
specifications can resemble object oriented notions that are familiar to developers.
the basic syntactic elements of alloy specifications are signatures which declare data domains signature fields akin to class attributes that give structure to specifications and declare relations between signatures predicates parameterized formulas that can be used to state properties represent operations etc.
facts formulas that constrain the specifications and represent assumptions and assertions formulas that capture intended properties of the specification i.e.
properties that the user would like to verify.
formulas in alloy are expressed in relational logic a first order logic extended with relational operators such as relational transpose union difference and intersection.
alloy supports various quantifiers all andsome are the usual universal and existential quantifiers respectively one and lone are for exists exactly one and exists at most one respectively .
it also features additional important relational operators relational join a generalization of composition to n ary relations which can be used to express navigations as in object orientation and transitive closure which can be applied only to binary relations and extends the expressiveness of alloy beyond that of first order logic.
consider the alloy model in figure a modified version of an alloy specification of linked lists that is part of the benchmark used in .
this model declares domains for booleans with its two constants captured via singleton relations and signatures for nodes and lists.
nodes have a link a set of nodes and associated elements a set of integers lists have a header a set of nodes .
a factconstrains the cardinalities of these signature fields lists have at most one header and nodes have at most one successor node and exactly one element when applied to expressions lone one andnoconstrain a given expression to have a cardinality of at most one exactly one and exactly zero respectively .
notice the additional fact which is there for analysis purposes it states that exactly one list is going to be considered in each instance of the model and that all nodes present in an instance will be those in the list no unreachable heap objects .
predicate loop captures lists with a loop in its last node saying that a list satisfies the predicate if it either has no header or for exactly one of its nodes the elements reachable in one or more steps from link are exactly the same reachable in zero or more steps through link .
predicate sorted attempts to capture that lists are non decreasingly sorted this predicate is buggy though as the order constraint is strict .
predicate repok is simply defined as the conjunction of loop andsorted .
predicate contains is used to model an operation on lists namely the operation for querying membership of an integer as an element of a node of a list.
the result of the operation is captured by an additional boolean parameter.
this predicate is buggy it does not correctly model the intended operation e.g.
it admits the predicate to return true despite the contents of the list .
alloy specifications can be automatically analyzed by an analysis mechanism that resorts to sat solving and is implemented in a tool called alloy analyzer .
two kinds of analy1136abstract sig boolean one sig true false extends boolean sig node link set node elem set int sig list header set node fact cardinalityconstraints all l list lone l.header all n node lone n.link all n node one n.elem fact ignore one list list.header.
link node pred loop nothis.header one n this.header.
link n. link n. link pred sorted buggy all n this.header.
link n.elem n.link.elem pred repok loop sorted run repok for but exactly node expect buggy pred contains repok x !
inthis.header.
link.elem res false res true pred count repok res n this.header.
link n.elem x assert containscorrect all l list i j int count j iff contains check containscorrect for fig.
.
a faulty sample alloy specification.
sis are possible running a predicate and checking an assertion.
both are analyzed in bounded scenarios.
running a predicate searches for instances scenarios that satisfy all the constraints cardinalities facts etc.
including the predicate being run.
assertion checking looks for counterexamples of the asserted properties.
analysis is performed up to a bound k typically referred to as the scope of the analysis meaning e.g.
that assertion checking will either find a counterexample within the given scope or guarantee the validity of the formula within the bound similarly a predicate will be found to be satisfiablewithin the provided scope or not to have a satisfying instance within the scope .
this bounded exhaustive analysis of course does not necessarily mean that the formula is valid resp.
satisfiable as counterexamples resp.
instances of greater size may exist if larger scopes are considered.
the alloy language is the vehicle for defining abstract software models in a lightweight and incremental way with immediate feedback via automated analysis .
typically the process of constructing an alloy model as the one in our example starts very much in the same way one would proceed while eliciting requirements or sketching an abstract software design basic domains of the model are identified signatures of the model over which more structured components are organized signatures equipped with fields .
how these domains and components are constituted the inherent constraints of the problem domain and the operations that represent the software model capacities are all incrementally created via a constant interaction with the alloy analyzer.
this process eventually involves the use of assertions and predicates that capture intended properties of the model and that serve essentially as the oracle of the specification i.e.
the properties that would convey the acceptance of the model.
sometimes these properties can help find surprising counterexamples that lead to refinements of the properties themselves but more often they help one in debugging the core of the model i.e.
in getting the model right adapting it until the intended properties result as expected.
for instance for the linked lists model the developer would expect the representation invariant repok to be satisfiable and the definition of contains to have the relationship with count captured in property containscorrect .
while the intended properties are subject to defects too they are typically significantly shorter and clearer than the core of the specification.
they capture high level properties of the model so they are expected to be simpler to write and get right.
so once the intended properties are set the user may perform the corresponding analyses and use the results as an acceptance criterion for the specification and the corresponding design it conveys.
that is a model will be considered incorrect if any of the analyses of the intended properties fails i.e.
has a result that contradicts the user expectations.
in figure for instance the user may consider the consistency of repok the assertion containscorrect and the auxiliary predicate count as the oracle of the specification meaning that when this intended property is found to be invalid the user would start modifying the remainder of the specification as an attempt to fix the error.
beafix as well as other model repair techniques aim at reducing human intervention along this overall modeling process by automatically fixing errors in incorrect models.
let us describe how the technique works assuming for the moment that the faulty locations in the model have been correctly identified.
in order to attempt to repair the specification and assuming that for the first location the syntactic mutation operators lead to ndifferent fix candidates for that specific location and for the second location we have m 1137different fix candidates in the worst case we have to check n mpotential fixes as we would want to consider all combinations of candidate fixes for each repair location.
the model expectations in our example the satisfiability of repok and the bounded validity of containscorrect will be the acceptance criterion fix repair i.e.
if a fix candidate passes these analyses it will be considered a fix.
the automated repair process for the above faulty specification is then straightforward to describe we have n m repair candidates the combinations of fix candidates for the suspicious locations and since we aim at exhaustively exploring this candidate space we would run the oracles on each candidate stopping as soon as we find one that passes all predicates and assertions.
let us describe some situations that allow for sound pruning i.e.
pruning that only avoids invalid fix candidates.
notice that in our case we have two defective lines but these are not symmetric the bugs in sorted affect contains ascontains depends on repok which in turn depends on sorted but the latter does not depend i.e.
calls directly or indirectly on contains .
thus when checking a specific candidate for sorted that does not pass an oracle involving sorted but not contains as for instance the satisfiability of repok we can stop analyzing the fix candidate for sorted altogether and not consider it in combination with any further candidates for the other location.
consider for instance the following combination of fix candidates for sorted andcontains pred sorted all n this.header.
link n.elem !
n.link.elem pred contains repok x !
inthis.header.
link.elem res false res true assuming that we consider the above described oracles for the specification this combination does not pass the oracles it is an invalid fix candidate.
moreover if we leave the current fix candidate for sorted and iterate over other candidates forcontains the property check requiring repok to be satisfiable will continue to fail as the unsatisfiability of repok cannot be solved by changing the definition of contains .
thus if we are able to identify this situation as we explain later on our technique does so we can safely consider a different mutation for sorted or equivalently soundly skip all combinations of the current mutation to sorted with all other mutations for contains .
now let us look at another situation that will also allow us to soundly prune parts of the fix candidate space even in the presence of bidirectional or multi directional dependencies between faulty locations.
consider the above fix candidate for predicate contains that replaced by .
this local candidate that fails to pass an oracle such as the assertion oncontains in combination with a particular candidate forsorted does not allow us to discard it altogether as the failing cannot in principle be blamed on on its own it may be the case that this candidate works with a different candidate for sorted .
so in order to check the local feasibility of the candidate for contains we need to consider it in combination with any other candidate for sorted of course trying to avoid checking allcandidates for this predicate.
assuming that we identified the body of the quantification of sorted as the problematic part in that predicate fault localization techniques for alloy in particular the one we use in this paper can identify fine grained faulty locations such as particular subexpressions what we would need to intuitively check is whether there exists a boolean value for that location that in combination with would make the oracles pass pred sorted all n this.header.
link ?
?
pred contains repok x !
inthis.header.
link.elem res false res true that is can we replace the double question mark above by a value that would make oracles pass?
if the answer is no then we can blame and try another candidate for contains avoiding considering of with candidates for sorted .
if we are able to correctly identify these situations as our technique does and we describe later on in this paper we can again safely prune a large number of candidates namely all combinations of with all the mutations for sorted .
it is worth remarking that we do not assume any particular format or characteristic neither from the specification itself nor from the oracle.
this is in contrast with previous work on repairing alloy specifications which requires repair oracles to be provided as alloy test cases .
alloy test cases define scenario based expectations similar to what one would capture with unit tests for source code.
as an example consider the evaluation of contains on a particular concrete structure and its corresponding expected outcome the expected outcome represents a boolean for satisfiable and for unsatisfiable pred containsfalseonlisttest some n0 n1 node this.header n0 n0.link n1 n0.elem n1.link n1 n1.elem contains run containsfalseonlisttest expect while scenarios do participate in the alloy modeling process they typically do so as a result of analyzing properties .
that is tests are not a common explicitly described part of alloy specifications.
recent proposals notably are starting to motivate the use of test cases in formal specification.
as mentioned our approach allows for any kind of oracle including test based oracles.
1138iii.
t hetechnique our approach to alloy specification repair involves a series of tasks for fault detection fault localization fix candidate generation and fix candidate assessment.
we describe these in more detail below.
a. fault detection and fix acceptance criterion in general given an alloy specification we may say that such specification is faulty if at least one of the analysis commands in the specification has an outcome contrary to its corresponding expectation.
this can be either a failing assertion assertion with counterexamples or a predicate that is unsatisfiable while the user expected it to be satisfiable or vice versa.
we may also allow for other flavors in commands in particular alloy test cases in the spirit of aunit .
the fault detection stage then resorts to sat solving the underlying analysis mechanism behind alloy analyzer the tool for alloy specification analysis .
similarly a fix candidate can be considered an acceptable patch when all the analysis commands in the specification have an outcome that coincides with the corresponding command s expectations.
our technique requires the user to identify the specification oracle i.e.
the assertions predicates or tests that the technique will have to consider as fix acceptance criterion.
the technique will then identify faults in the remainder of the specification the oracle is left out of the analysis space for fault localization and generate fix candidates for the faulty locations.
therefore our repair approach cannot fix any faulty situation but only those where the developer is certain about some part of it the oracle and wishes to alter the remainder of the specification to pass it.
looking for solutions that may modify the specification and the criterion for acceptance would lead to fixes that may simply relax the acceptance criterion.
notice that in this respect we follow the same approach that arepair and most test based program repair techniques the tests the repair oracle cannot be changed in the repair process.
as described later on in this section other trivial solutions such as changing a command s expectations or simply removing a command are prevented due to how the fault localization is performed which cannot be blamed on commands and how fix candidates are generated only by mutating the faulty locations .
b. fault localization once a specification is deemed faulty we need to identify the specific parts of the specification that are more likely to be blamed for the fault or faults.
we do not deal with fault localization in this paper and we assume an external technique tool provides fault localization information.
there exist techniques for fault localization that specifically target alloy specifications such as the spectrum based fault localization mechanism behind arepair and our fault localization technique presented in .
while in principle any fault localization technique would fit our technique as long as the employed fault localization can handle the oracles present in the faulty specification it is worth to remark that thefault localization within arepair inherently depends on having tests as oracles acceptance criteria for specifications .
moreover the fault localization in arepair can dynamically change the identified faulty locations as the specification is transformed during the repair process.
our technique on the other hand uses an offline process for fault localization the faulty program is fed to the fault localization tool and a number of suspicious specification locations are returned.
this is the input to our specification repair approach and the space ofallpossible patches for these locations for a maximum depth in mutation application and a given set of mutation operators will be considered.
for our experiments in section iv we use the flack fault localization technique .
while we do not describe in detail the fault localization technique in this paper we refer the reader to let us remark a number of facts about flack it supports arbitrary satisfiability checks and assertions as well as tests as specification oracles it is based on the use of partial maximum satisfiability procedures to process counterexamples of an alloy model witnessing the faulty status of the specification and it can only identify faults within formulas and relational expressions it cannot locate faults in data definitions such as signature and field declarations nor in commands alloy s runs and checks .
c. generation of fix candidates once the suspicious expressions are identified syntactical variants of these expressions are produced.
we consider an ample set of mutation operations including the obvious logical and relational operator insertion removal and replacement quantification mutation e.g.
changing a quantifier multiplicity constraint replacement field variable swap replacement etc.
based on alloy s grammar.
our tool processes the specification to obtain some typing information so that some legal expressions that necessarily lead to empty relation contradictory formulas are disregarded as well as innocuous operation application e.g.
double transitive closure .
two elements are important to highlight here namely the use of join to produce navigation chains using fields signatures etc.
and the possibility of combining mutations i.e.
applying further mutations to an already mutated expression akin the so called higher order mutants in mutation testing.
both the mutation operators and the maximum depth i.e.
the number of cumulative mutations hence the higher order nature of the generated mutants that can be applied to a given faulty location are configurable.
these are boundedexhaustively generated as the space of fix candidates is traversed see below .
in our experiments we used mutation operators in total typically leading to roughly between and level mutants per location.
d. fix candidate space traversal here we present our general repair approach.
the two pruning techniques just introduced are also described in more detail and we argue about their soundness.
the search space is organized as a search tree in a traditional search problem 1139the root is the original specification with its faulty locations identified and if a specification sis in the tree and s0can be obtained by applying a mutation to a faulty location then s0 is also in the tree with the same locations marked as faulty so that the mutation process can be iterated .
this in principle leads to an infinite fix candidate space which we explore up to a maximum depth.
while any search strategy may be applied we explore the state space in a breadth first fashion.
partial repair checking our first pruning strategy consists of identifying one of the suspicious locations for which a current repair candidate fails as established by an analysis check that does not depend on the remainder of the faulty locations.
we will describe it in more detail assuming two faulty locations without loss of generality.
let spec be an alloy specification check check kits analysis checks used as oracles and l0 l1the suspicious locations identified by the fault localization phase.
each analysis check check i refers to a specific part of spec which can be determined by a straightforward syntactic analysis check irefers to the formula it directly mentions the body of the corresponding predicate or assertion all the facts axioms of the specification that are implicitly involved in every analysis check and the symbols directly and indirectly referred syntactically to by these predicates called relations used etc.
.
this syntactic analysis can determine then for every check i which of the suspicious locations l0andl1it involves.
most logics and certainly alloy s relational logic have a sort of syntactic locality property that guarantees that the validity satisfiability of a formula depends only on the symbols it refers to.
in the case of alloy since validity satisfiability is actually bounded validity satisfiability it can also depend on the scope the bound of analysis but since the bound of analysis cannot be modified in the patch generation phase we can disregard it .
moreover the logic is monotonic meaning that adding more assumptions to a formula can never reduce the conclusions drawn originally from it.
these properties allow us to make the following observation.
let m0andn0constitute the modifications to locations l0andl1 respectively in the current fix candidate i.e.
be the expressions substituting the original expressions in locations l0andl1ofspec .
if a failing satisfiability check check irefers to only one of the suspicious locations say l0and its current expression m0 this means that the formula in check iis determined to be false independently of n0.
then for every alternative expression nifor location l1 the corresponding fix candidate m0 ni the replacement expressions for locations l0andl1 will still make check ito be false due to the monotonicity of the logic.
in other words the specification cannot be repaired by modifying location l1if the current fix for location l0 is maintained.
we can therefore exclude prune from the checking all m0 ni fix candidates as soon as we determine this situation which in turn can be determined by a syntactic analysis of the specification and the analysis outcome for fix candidate m0 n0 .
we refer to this analysis and the corresponding pruning it enables as partial repair checking due to the partiality of fixcandidates when these do not involve all suspicious locations.
variabilization our second pruning strategy is called variabilization due to the mechanism employed for prune checking that requires introducing fresh variables to refer to fix candidates to specific locations in a general way.
letcheck ibe a failing assertion validity check that refers to suspicious locations l0andl1 and let m0 n0 be the current failing fix candidate.
notice that since check iis a failing validity check we have a counterexample cex ias a result of the violation.
that is we have that cex i6j spec check i where spec denotes the fix candidate obtained by replacing l0andl1bym0andn0 respectively in spec .
the purpose of variabilization is to check whether the current fix forl0 i.e.
m0 may work with some candidate for l1 other thann0 of course which we already know it does not work .
for technical reasons we actually check whether some fix for l1may work in combination with m0 for counterexample cexi.
let us describe the process for performing this check.
notice that fault locations can be subexpressions of a formula let us refer by f1to the formula predicate fact etc containing l1.
also let tbe the most general type for l1in context f1 in alloy this most general type will depend on the arity required by l1inf1 the context in which l1 may depend upon and will use the most general unary type the universe univ .
let specl1be the specification obtained by replacing f1inspec by 9l1 tjf1 i.e.
we substitute l1by an existentially quantified variable of typet hence the name variabilization .
we now can check cex ij specl0 check i i.e.
whether there exists a value of type tthat can be put in place of location l1 so that cex iceases to be a counterexample.
if this is the case then local fix m0works as a fix for l0 at least as far as cex iis concerned and we may traverse the space of local candidates for l1to attempt to find a complete fix.
but on the other hand if the above check fails then there is no value that can be put in place ofl1such that the local fix m0would work cex iwould still be a counterexample .
therefore we can again exclude prune from the checking all m0 ni fix candidates if the check fails.
one may argue why not check the variabilized specification in the general case instead of so only for counterexample cex i. the reason has to do with the type t of location l1.
when this type is a relation of an arity greater than one variabilization leads to a higher order quantification that alloy cannot handle as a general analysis check but it can do so for the specific counterexample cex i. to clarify this variabilization process and especially the reason why we typically have higher order quantification let us consider the example introduced in section ii where 1140one local fix candidate is applied and the other was generalized with question marks.
assuming that assertion containscorrect failed a counterexample cex was generated from this fix.
to check whether variabilization pruning can be applied we turn the question marks into existential quantifications.
intuitively the corresponding variabilized specification would then be as follows we are abusing the notation below using boolean for the type of the variabilized formula within sorted pred sorted some b boolean all n this.header.
link b pred contains repok x !
inthis.header.
link.elem res false res true however we need to take into account that the variabilization context the place where the location being variabilized occurs depends in this case both on this andn.
thus the actual variabilization for the check is as follows we are again abusing the notation for the sake of clarity pred sorted some b list node boolean all n this.header.
link b pred contains repok x !
inthis.header.
link.elem res false res true we cannot check containscorrect over this specification due to the higher order quantification in sorted but we can check it for cex .
it is worth remarking that the above check if successful will produce a relational value forbthat makes the variabilized specification work.
it will notproduce an expression to put in place of the body of the quantification as a local fix candidate.
it would not even produce a relational value that can be hardwired as a local fix of the corresponding location since it is in principle just a relational value that works for counterexample cex .
but its existence is what enables us to decide that a local fix for l1 sorted may be possible considering the current local fix for l0 the incontains .
our check essentially corresponds to only checking for feasibility of a local fix with respect to other locations.
an alternative to the above would be to attempt to turn the relational value bound to binto a relational expression that can be considered a local fix candidate.
such a process would correspond to a synthesis procedure which would require a grammar for expressions so that the solver can attempt to work out an instance an actual expression during the satisfiability process.
while it is technically feasible it is also significantly more costly than our simpler query for satisfiability which we solely use for pruning.iv.
e valuation we now assess our technique for automated repair of alloy specifications.
our evaluation is based on two benchmarks of real faulty alloy specifications one taken from and used in the evaluation of arepair and the other originated in the alloy4fun project which includes new models with a total of faulty variants considering different specification assignments resolved by different students .
all the presented experiments were run on a .6ghz intel core i7 processor with gb ram running gnu linux.
we used a hour timeout for each repair analysis instance.
our evaluation considers the following research questions rq1 what is the impact of the pruning strategies in the performance of our technique?
rq2 how does our technique compare to previous work on automated repair for alloy specifications?
for rq1 notice that the pruning strategies only apply to specifications with multiple faulty locations.
we then evaluate our technique with pruning enabled vs. pruning disabled over the following cases from arepair s benchmark we will refer in this way to the benchmark used in the original evaluation of we consider specifications out of the that are part of the benchmark.
we disregard cases that have exactly one bug in total in the benchmark as these will not make pruning checks nor trigger the pruning.
from alloy4fun we consider a total of faulty specifications.
to build these specifications we tracked the models with multiple assignments and identified the cases in which a given model was submitted with more than one bug by the same student.
while the student id is not reported as part of the alloy4fun dataset submissions are organized as chains of interaction ids that correspond to a same student session.
we use this information to organize submissions based on student sessions.
the results are summarized in table i. this table shows for each of the benchmarks the number of cases how many were repaired with pruning enabled and disabled recall the hour timeout and the average time for those cases that were repaired within the timeout time is in milliseconds .
we also report the increased repairability and improved efficiency obtained by pruning.
we considered the cases that were not repaired with pruning disabled but were repaired with pruning enabled as if they were repaired in hour.
so the increased efficiency is actually a lower bound of the actual improvement.
for reference we also report the range of efficiency improvement along all cases in each benchmark.
forrq2 we compare our technique with the only other approach for repairing alloy models namely arepair .
we analyze both tools in their corresponding abilities to repair specifications in our considered benchmarks.
for arepair s benchmark we used the models corresponding assertions as oracles for beafix and automatically generated test suites using aunit for arepair.
recall that arepair requires tests as oracles for the repair process we actually follow the 1141table i impact of pruning in repairability .
benchmark total pruning disabled pruning enabled improved repairability efficiency cases repaired cases avg.
time repaired cases avg.
time repaired cases avg.
time arepair s benchmarks balancedbst cd .
x 3x dll .
x 80x farmer fsm student .
x 26x total .
x 37x alloy4fun s benchmarks graphs .
x x lts .
x x trash .
x 46x production classroom .
x 82x cv total .
x 85x procedure suggested in as test cases are not commonly found accompanying alloy specifications.
notice then that the results reported in do not coincide with those reported here for arepair s benchmark as we use the same models with different test suites.
the test suites used in include manually designed cases to help arepair in overcoming overfitting.
in our evaluation we favored a comparison in which only the original assertions are available and thus we generated test cases automatically with aunit using the best performing criterion predicate coverage .
from the alloy4fun dataset we generated a benchmark consisting of i every faulty submission of the dataset as a single specification these correspond to every intermediate specification submitted for analysis check in alloy4fun and ii the specifications combining all modifications within a single user session that we used for rq1 .
the total number of faulty specifications in this benchmark is faulty submissions plus sessions combining submissions of the same user .
for beafix we used the models corresponding assertions as oracles.
since we do not have tests for these specifications and arepair inherently requires tests as repair oracles we generated tests automatically using aunit with predicate coverage as a target criterion using the specification assertions and employed these generated test suites for running arepair.
in all of the above cases we contrasted the obtained repairs against correct versions of the corresponding specifications using alloy analyzer to account for overfitting.
the results for arepair and alloy4fun benchmarks are summarized in tables ii and iii respectively.
for each model we report the number of cases and for each tool the number of fixes found percentage also reported and how many of these are correct and incorrect the latter due to overfitting patches.
we also report the percentage of correct and incorrect patches with respect to the total number of cases and the average repairtime in milliseconds for each tool these are the averages only for the repaired cases .
a. discussion let us discuss the evaluation results.
for rq1 the results are conclusive the impact of pruning is significant.
let us remark that the efficiency speed up is better than the increase in repairability 38x to 85x speed up as opposed to roughly .5x increase in repairability .
this may be explained by the timeout that we have set hour may be a small timeout for specification repair using beafix increasing it may show a repairability increase closer to the speed up.
another important issue about these results is that the semantic check that we need to perform for pruning using variabilization does in fact pay off.
in other words the variabilization checks that require additional calls to the sat solver implied a time saving thanks to pruning that improved the overall analysis time.
this of course is relative to the considered case studies.
we did not observe any case where the overhead caused by pruning made the tool to actually take longer to repair a faulty specification which may in fact happen for a specification if most feasibility checks succeed consuming time and leading to no pruning.
the benchmarks were taken from other authors work we did not purposely look for specifications that may favor or harm the pruning strategies.
we plan to design synthetic specifications and extend the set of case studies to further assess the effect of pruning.
regarding rq2 the comparison between beafix and arepair can be analyzed along various dimensions.
let us first consider the evaluation over arepair s benchmark.
for this benchmark the test suites used for running arepair are solely composed of automatically generated tests using aunit with predicate coverage.
as a result the number of correct specification fixes differ from the experiments in where manually designed test cases helped the tool from overfitting.
in our current experiments arepair is affected 1142table ii experiments taken from arepair s benchmarks .
total arepair beafix model casesrepaired avg.correct incorrect repaired avg.correct incorrect time time addr arr balancedbst bempl cd ctree dll farmer fsm grade other student total table iii experiments taken from alloy 4fun s benchmarks .
total arepair beafix model casesrepaired avg.correct incorrect repaired avg.correct incorrect time time graphs lts trash production classroom cv total by overfitting out of the produced fixes are correct fixes.
beafix outperforms arepair in terms of the number of repaired models models repaired by arepair against repaired by beafix a difference in the number of repaired models over the size of the benchmark .
it is worth remarking that the two techniques complement each other in terms of the repaired models arepair is able to repair models that beafix does not repair see for instance ctree andfsm and beafix repairs models that arepair is not able to repair see for instance student andother .
in terms of efficiency both tools show comparable running times.
the average time to produce a repair is however just a reference since the tools perform different kinds of tasks.
beafix does not include fault localization so the times here account for absolute repair times given that the faults have been localized offline.
arepair on the other hand includes both the time to localize faults and perform the repair.
let us remark however that in arepair on average of the time corresponds to repair and to fault localization.
unlike arepair that alternates between patching and calling fault localization beafix calls fault localization only once before triggering repair.
as such the proportion of time devoted to fault localization is much less.
in our experiments when weconsider the combination of fault localization and beafix on average is devoted to fault localization in the worst case student6 the fault localization time was of the total time .
further details can be found in the tool s site see below .
now let us consider the alloy4fun benchmark.
for this benchmark we did not have any choice but to automatically generate test cases as these were not available for these models.
we generated test cases automatically using aunit again using the best performing generation criterion as reported in .
arepair is able to repair a significant number of models out of .
however only were correct fixes the remaining were overfitting cases that passed the automatically generated tests but were not correct fixes for the corresponding specifications.
beafix on the other hand produced a smaller number of fixes out of the .
but since it uses alloy assertions as repair oracles instead of test cases it showed no overfitting issues for these specifications.
as a result beafix shows a better effectiveness in repair of correctly repaired models by beafix against of correctly repaired models by arepair.
regarding the cases themselves again the tools complement each other there are cases correctly repaired by one tool that were not repaired by the other and vice versa.
1143the observed overfitting is an important difference between the two tools and their approaches and confirms our intuition and motivation regarding the use of stronger repair oracles that naturally come in specifications.
clearly one may argue that arepair s performance in terms of overfitting can be improved by feeding the tool with different stronger test suites.
we fully agree and in fact this is confirmed with arepair s benchmark if the test suites used in are fed to arepair which as we mentioned include manually crafted tests then out of models are repaired compared to the out of repaired models obtained with just automatically generated tests effectiveness is increased from to .
writing theright set of test cases for specification repair is a time consuming task that would require a manual design of a test suite for each of the models to improve the tool s results.
the overfitting problem is an inherent problem of using tests as specifications and thus it is expected of tools such as arepair.
it is important to remark that we do not claim that our technique leads to no overfitting since this will depend on the oracle being used and how faithfully it captures the developer s intentions.
in the case of our controlled experiments where we had the ground truths as oracles which would not be the general case in formal specification we had no overfitting although overfitting may still have been observed due to the bounded nature of the analysis.
in any case being forced to use test cases as opposed to more general properties makes it more prone to overfitting.
other attributes of the generated patches may be considered.
one of these is readability.
we can remark that candidate patches are built out of mutations of the faulty expressions and the space of faulty expressions is visited in breadth first.
therefore simpler shorter fix candidates are considered first.
while we did not evaluate readability in a systematic fashion beafix s patches can be simpler and clearer than manual human written ones.
for instance for production.inv4 in the alloy4fun benchmark the faulty expression all c component c.parts .position in c.position .
next is manually fixed by a student with the following expression all c component c. parts component .position not in c.position .
next or no c. parts component beafix on the other hand produces the following all c one component c.parts.position inc.position.
next another dimension to consider is efficiency of our technique compared with manual repairs.
in alloy4fun we can measure the effort of human patches by considering the time of the sessions of a same student from defect introduction to its fixing.
on average it takes a student about minutes to fix a defect once it is introduced.
on the other hand the average time to repair in the case of beafix is about seconds.
for instance for the above faulty specification it took the student a total of minutes to get it right.
beafix repaired it in seconds.
due to space reasons we do not present here a moredetailed comparison.
the benchmarks the tool s output with further statistical information and the tool itself can be found in the tool s site see below .
v. r elated work the problem of automatically repairing software defects has received great attention in the last decade and a variety of techniques have been proposed to tackle it including generateand validate techniques e.g.
based on evolutionary computation or other forms of search in the space of candidates techniques based on patch synthesis e.g.
techniques that gather constraints for correct program behavior and produce patches from these and techniques driven by data e.g.
techniques based on learning .
the emphasis is largely targeted at programs rather than specifications .
as explained earlier in this paper the context of formal specification has some significant differences with programs source code that render many of these techniques not applicable or at least difficult to adapt to repairing specifications.
the problem of dealing with the explosion of repair candidates has been dealt with in different ways in the context of automated program repair.
some approaches attempt to bring down the branching factor in the search space by using a single mutation e.g.
others consider a very small set of mutators e.g.
based on patterns of human written fixes or consider coarse grained mutations e.g.
no intra statement program modifications .
most of these approaches perform nonexhaustive heuristic searches as opposed to our technique that proposes safely pruning the search space.
our technique produces fine grained repair candidates that are akin to mutations such as operator and operand replacements etc.
or more generally combinations of mutations as in higher order mutations in the context of mutation testing .
the motivation for this decision is based on a number of issues that seem to impact the effectiveness of larger grained modifications such as the copying deletion and swapping of whole expressions as operations to build repairs in the context of specification for instance for the case studies presented in our manual inspection showed no case where one may repair the specification by deleting swapping or copying whole expressions within the specification .
firstly specifications do not seem to feature the same level of reuse that programs have.
for instance in text books on formal specification with more traditional languages such as z or b one does not see modularization mechanisms e.g.
schema machine composition being used for reuse across different specifications with the exception of the reuse of some general purpose specifications of sets sequences etc.
rather modularization mechanisms seem to be exploited mainly for specification organization with little impact in reuse.
secondly most declarative specification languages are order insensitive the order of declarations and statements is irrelevant as opposed to operational languages making orderchanging modifications ineffective .
thirdly specifications are significantly shorter than source code and therefore less redundancy that could be exploited for repairs is observed.
1144while most work on automated repair applies to programs there are some notable exceptions .
the tool autofix targets contract equipped programs and can produce repairs that make the programs satisfy their contracts at least as far as a test suite can determine .
the technique can modify contracts as well as the code itself and therefore can be considered as a specification repair technique.
the approach differs from ours in many respects it applies to specifications at the source code level as opposed to the more abstract specifications we target in this paper it is not constrained to specifications it can indistinguishably alter programs and specifications and the specification is notthe oracle for repair the tests are.
an approach closely related to ours as it applies to alloy specifications too is arepair .
arepair repairs faulty alloy specifications by combining a number of techniques including a technique for synthesis known as sketching and mutation based repairs as in program repair.
arepair can fix specifications with multiple buggy locations and is able to do so considering a manageable set of candidates thanks to an effective fault localization approach and resorting to sketching rather than arbitrary mutations .
in effect arepair is guided by its own fault localization approach and the whole process is supported by alloy tests.
our approach on the other hand is not coupled with fault localization and can use different techniques e.g.
as long as they can be used with the fault localization oracle at hand for fault localization.
alloy tests are similar to unit tests for source code they provide specific scenarios with an expected outcome when evaluating specific parts of an alloy specification e.g.
a predicate.
the tool has been successfully applied to repair specifications taken from a benchmark of alloy models very efficiently by being combined with techniques for automated alloy test generation as tests are necessary for repair .
as for program repair techniques which use tests as acceptance criteria they are subject to overfitting the problem that arises when a candidate passes all tests but is not a true repair i.e.
there are situations in which the program in this case specification fails to comply with the intended behavior.
this as usual is strongly related to the quality of the provided test suite and many of the cases from were repaired thanks to additionally manually provided test cases .
arepair inherently depends on test cases while our technique works on arbitrary alloy specification oracles.
see the previous section for a more detailed comparison of beafix with arepair from a more experimental point of view.
our technique uses alloy counterexamples to weakly check variabilization feasibility since fully checking feasibility requires dealing with higher order quantification.
to perform this higher order checking one may use alloy .
we experimented with this approach but due to performance issues we favored our current counterexample based mechanism.
also in this line one may profit from alloy to capture alloy s grammar and semantics into alloy and use the solver to encode the whole repair approach.
in this way alloy would function as a synthesis engine with the solver the search for repairs as in some semantic program repair approaches e.g.
.
in our initial attempts we did not manage to obtain results due to the available heap space being exceeded for fragments of alloy s grammar significantly smaller than what we are considering with our ad hoc search approach.
we plan however to further investigate this possibility.
vi.
c onclusion software specification and modeling are crucial activities of most software development methods.
getting a software specification right i.e.
capturing correctly a software design the constraints and expected properties etc.
especially when the language to capture these is formal is very challenging.
thus techniques and tools that help developers in correctly specifying software is highly relevant.
in this paper we have presented a technique that helps precisely in this task in the context of formal specification using the alloy language .
our technique has a number of characteristics that distinguish it from related work .
firstly it does not require any particular form of the oracles i.e.
the properties to be used for assessing fix candidates as opposed to existing work which require such oracles to be expressed in terms of test cases .
secondly it bounded exhaustively explores the state space of fix candidates thus finding a specification fix or guaranteeing that such a fix is impossible within the established bounds for the identified faulty locations and with the provided mutation syntactic modification operators.
this is suitable in an alloy context where users are accustomed to boundedexhaustive analyses.
this bounded exhaustive exploration of fix candidates demands then appropriate mechanisms to make the search more efficient.
our technique comes with two sound pruning strategies that allow us to avoid visiting large parts of the state space for fix candidates which are guaranteed not to contain valid fixes.
we have assessed our technique on a large benchmark of alloy specifications and shown that the pruning strategies have an important impact in analysis.
the technique has an efficiency comparable to that of the previous work it complements the latter in terms of the fixes it is able to generate and is less prone to overfitting as it naturally supports stronger oracles based on assertion checking and property satisfiability that usually accompany alloy specifications.
vii.
d ata availability beafix all benchmark data further statistical information and the instructions to replicate the experiments in this paper are available at .
a snapshot of the tool and benchmark as used in the paper is available at .