pem representing binaryprogram semantics forsimilarity analysis via a probabilistic execution model xiangzhexu zhouxuan xu1415 purdue.edu xuan1 purdue.edu purdueuniversity westlafayette usashiwei feng purdueuniversity westlafayette usa feng292 purdue.edusiyuancheng purdueuniversity westlafayette usa cheng535 purdue.edu yapeng ye purdueuniversity westlafayette usa ye203 purdue.eduqingkaishi purdueuniversity westlafayette usa shi553 purdue.eduguanhong tao purdueuniversity westlafayette usa taog purdue.edu le yu purdueuniversity westlafayette usa yu759 purdue.eduzhuozhang purdueuniversity westlafayette usa zhan3299 purdue.eduxiangyu zhang purdueuniversity westlafayette usa xyzhang cs.purdue.edu abstract binary similarity analysis determines if two binary executables are from the same source program.
existing techniques leverage static and dynamic program features and may utilize advanced deep learningtechniques.althoughthey havedemonstratedgreat potential thecommunitybelievesthatamoreeffectiverepresentation ofprogramsemanticscanfurtherimprovesimilarityanalysis.in this paper we propose a new method to represent binary program semantics.itisbasedonanovelprobabilisticexecutionenginethat can effectively sample the input space and the program path space of subject binaries.
more importantly itensures that the collected samples are comparable across binaries addressing the substantial variationsofinputspecifications.ourevaluationon9real world projectswith35kfunctions andcomparisonwith6state of the art techniques show that pemcan achieve a precision of with common settings outperformingthe baselines by10 .
ccsconcepts security andprivacy software reverseengineering .
keywords binary similarity analysis program analysis acm reference format xiangzhe xu zhou xuan shiwei feng siyuan cheng yapeng ye qingkai shi guanhongtao leyu zhuozhang andxiangyuzhang.
.
pem bothauthorscontributed equallyto this research.
esec fse december san francisco ca usa copyright heldby theowner author s .
acm isbn .
binary program semantics for similarity analysis via a probabilistic execution model.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of softwareengineering esec fse december3 sanfrancisco ca usa.
acm newyork ny usa 12pages.
introduction binarysimilarityanalysisdeterminesiftwogivenbinaryexecutablesoriginatefromthesamesourceprogram.ithasawiderangeof applications suchas automatic software patching softwareplagiarismdetection andmalware detection .
for example assume a critical security vulnerability has been reported and fixed in a library.
it isofprominent importanceto applythe patchtoother deployed projectsthatincludedthelibrary.however thelibrarymaybecompiled with different settings in different projects.
binary similarity analysisallowsidentifyingallthevariants.givenapoolofcandidate binaries which are usually functions in executable forms a similarityanalysistoolreportsallthebinariesinthepoolequivalenttoaqueriedbinary .theproblemischallengingasaggressive code transformations such as loop unrolling and function inlining in compiler optimizations may substantially change a program and produce largely different executables .
given its importance there is a large body of existing work.
earlierwork e.g.
focusesonextractingstaticcodefeatures such as control flow graphs and function call graphs.
they are highly effective in detecting binaries that have small variations.
many proposedto usedynamic informationinstead because it better discloses program semantics.
for example inmemory fuzzing imf usesfuzzingtogeneratemanyinputs andcollects runtimeinformationwhenexecutingtheprogramon these inputs.
it then uses the collected information to compute binary similarities.
when the fuzzer can achieve good coverage imf is able to deliver high quality results.
however achieving goodcoverageisdifficultforcomplexprograms seeourexample thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 san francisco ca usa x.xu z.xuan s.feng s.cheng y. ye q. shi g.tao l.yu z.zhang andx.zhang in section .
.
recently machine learning and deep learning techniquesareusedtoaddressthebinarysimilarityproblem .
these techniques work by training models on a large pool of binaries that have positive and negative samples.
theformerincludesbinariescompiledfromthesamesourceand the latter includes those that are functionally different.
the models are hence supposed to learn implicit features that can be used to cluster functionally equivalent programs.
however as shown in sections .2and4.
these models may learn features that are notrobust andinmanycases notsemanticsoriented leadingto sub optimalresults.
inspiredbytheexistingworksthatleveragedynamicinformation weconsiderthesemanticsofabinarytobeadistributionofitsinputsandtheircorresponding externallyobservable valuesduring executions.
observable values are those encountered in i o operations and global heap memory accesses.
compared to otherruntimevaluessuchasthoseinregisters observablevalues are persistent across automatic code transformations as compilers hardly optimize these behavior .
however since we need to compare arbitrary binaries ideally we would have to collect sufficientsamplesintheinputspaceofallthesebinaries.making such samples universally comparable is highly challenging.
in section2.
weshowthatanaivesamplingstrategythatexecutesall subject binaries on the same set of seed inputs can hardly work as differentbinariestakeinputsofdifferentformats.forexample a validinputfor aprogram u1d434isverylikelyaninvalidinputforprograms u1d435and u1d436.
as such it can only trigger similar error handling logicsin u1d435and u1d436 makingthemnot distinguishable.
in this paper we propose a sampling technique that can effectivelyapproximatesemanticsdistributionsbyselectingandinterpretingasmallsetofequivalentpathsacrossdifferentversionsof a program.
it is powered by a novel probabilistic execution engine.
it runs candidate binaries on a fixed set of random seed values.
although many of these seed values lead to input errors it systematically unfoldstheprogrambehavior starting fromthe execution pathsoftheseseedvalues calledthe seedpaths .specifically itflips a bounded number of predicates along the seed paths.
for instance flippingafailinginputcheckforcesthebinarytoexecuteitsnormal functionality.whilepredicateflippingisnotnew our techniquefeatures a probabilistic sampling algorithm .
specifically wecannotaffordexhaustivelyexploringtheentireneighborhood of the seed paths even with a small bound of flipped predicates .
hence we leverage a key observation that the predicates with the largest and the smallest dynamic selectivity tend to be stable before and after automatic transformations while other predicates vary a lot by the transformations .
dynamic selectivity is a metric computed for a predicate instance that measures the distance to the decision boundary.
for example assume a predicate x yyields true x ydenotesitsdynamicselectivity.ourtheoreticalanalysis insection .5disclosesthatsinceautomatictransformationscannot inventnewpredicates butratherremove duplicate andreposition them the likelihood that code transformations change the ranking ofpredicateswiththesmallest largestselectivityismuchsmaller than that for other predicates.
hence we sample paths by flipping predicatesthathaveclosetothelargestandthesmallestselectivity followingthe beta distribution thathasaushape biasingtowardsthetwoends.therefore iftwobinariesareequivalent ouralgorithmcansampleasetofcorrespondingpathsinthebinaries byflippingtheircorrespondingpredicatessuchthattheobservable valuesalongthesepathsdisclosethe equivalence.
our contributionsare summarizedas follows.
weproposeanovelprobabilisticexecutionmodelthatcan effectivelysamplethesemanticsdistributionofabinaryand make the distributionsfrom allbinariescomparable.
we develop a path sampling algorithm that is resilient to code transformation and capable of sampling equivalent pathswhentwobinariesareequivalent.wealsoconducta theoreticalanalysisto discloseits essence.
we propose a probabilistic memory model that can tolerate invalidmemory accesses due topredicate flipping whilerespecting the critical property of having equivalent behavior when the binary programs are equivalent.
wedevelopaprototype pem.weconductexperimentson twocommonlyuseddatasetsincluding35kfunctionsfrom30 binaryprojectsandcompare pemwithfivebaselines .theresultsshowthat pemcanachievemorethan precision on average whereas the baselines can achieve .pemis also much more robust when the true positives i.e.
binaries equivalent to the queried binary are mixed withvariousnumbersoftruenegatives i.e.
binariesdifferent fromthequeriedbinary inthecandidatepool whichclosely mimicsreal worldapplicationscenarios.consequently pem cancorrectlyfind7outof81 daycvesfrombinariesinthe wild whereas the baselines can only find .
we upload pem at .
motivation and overview .
motivating example ourmotivatingexampleisadaptedfromthemainfunctionof catin coreutils .
the simplified source code is shown in fig.
1a.
lines2 to10parsethecommandlineoptions.lines 12to19iterativelyread the file names from the command line and emit the file contents to theoutputbuffer.thefunctiondelegatesthemainoperationstotwo functions.
when some conditions at line 13are satisfied a simpler methodsimple cat iscalled.otherwise itcallsamorecomplex functionthatformatstheoutputaccordingtothefullpanoplyof command line options.
for example at line if the global flag print invisible isset thefunctionprintsouttheasciivalues ofinvisible characters.
compiler optimizations may substantially transform a program.
in fig.2bandfig.2a weshow thecontrol flowgraphs cfgs for our motivatingexamplegeneratedbytworespective compilation settings o0 meaning no optimization and o3 meaning having all commonly used optimizations applied.
the switchstatement at line3iscompiledtohierarchical if then else structureswith o0 asshownintheorangecircleinfig.
2b.incontrast itiscompiledto anindirect jump with o3 as shown in the orange circle in fig.
2a.
thepredicateatline 13correspondstothebluecircleinfig.
2b.we can see two branches each consisting of only one basic block.
two delegated functions are called in the two basic blocks respectively.
however the two functions are inlined in the optimized version resulting in branches with much more blocks e.g.
blocks in the branchofthecomplexfunction asshowninthebluecircleinfig.
2a.
402pem representing binary program semantics forsimilarity analysis viaaprobabilistic executionmodel esec fse december3 san francisco ca usa 1voidmain cat intargc char argv while !
c get cli opt argc argv bestuv switch c case b flag0 true .
.
.
format true break case e flag1 true break case v print coreutils v8.
break .
.
.
default quote error abort .
.
.
define pagesize inbuf andinsize do if flag0 flag1 format ret simple cat inbuf insize else .
.
.
outbuf xmalloc outbuf pagesize ret complex cat inbuf insize outbuf while .
.
.
21intcomplex cat char inbuf intinsize char outbuf if print invisible inbuf 0x20 outbuf to ascii inbuf a coreutils cat 1voidmain touch intargc char argv while !
c get cli opt argc argv bcdfhv switch c case b flag 0x100 break case c flag 0x1 break case v print coreutils v8.
break .
.
.
default quote error abort for inti begin i argc i touch function argv b coreutils touch figure motivatingexample tobetterillustratethechallenges weintroduceanotherfunction adapted from the main function of touchincoreutils as shown in fig.1b.
the function touchmodifies the meta information of files.lines 2to10parsethecommandlineoptionsandthefor loop atline11iterativelyperformsthetouchoperation.wecanseefrom fig.2cthat the syntactic structures of touchandcatare more similar than those between catwith and without optimizations.
theobservationcanbequantifiedbythestatisticsofthesecfgs showninthe caption.
.
limitationsofexistingtechniques fuzzing basedtechniques.
therearetechniquesthatleverage fuzzingtoexplorethedynamicbehaviorofprogramsandusethem insimilarityanalysis.forexample in memoryfuzzing imf iteratively mutates function inputs and collects traces.
since the parameterspecificationsfor functionsinstrippedbinariesarenot available itischallengingtogenerateinputsthatcanachievegood coverage.
in our example imf can hardly generate legal command line optionsfor the function main cat .
thusmost collected behavior is from the error processing code at line .
moreover they tend to collect similar error processing behavior from main touch .
as such thedownstreamsimilarityanalysislikelydrawsthewrong conclusion about their equivalence.
our experiments in section .
show that imf can achieve a precision of on complex cases whereas ours can achieve .forced execution based techniques.
to extract more behavior from binary code there are methods that use coverage as guidance to execute every instruction in a brute force fashion.
a representativeworkblex executesafunctionfromtheentrypoint.then it iteratively selects the first unexecuted instruction to start the next round of execution until every instruction is covered.
we call techniquesofsuchnatureforced execution basedastheylargely ignorepathfeasibility.
therearetwoessentialchallengesforthese techniques.
first they tend to use code coverage within a function astheguidanceforforcedexecution whichhastheinherentdifficultyindealingwithfunctioninlining .anotherchallengeis to provide appropriate execution contexts when execution starts at arbitrary unexecuted locations.
for example suppose that in the first few rounds blex executes the true branch at line 14of fig.
.
when it tries to cover the false branch at line it uses a fresh execution context discarding the variables computed at line .
according to our experiments in section .
these techniques can achieve a precision of whereas our technique can achieve .
learning basedtechniques.
emergingtechniques leveragemachinelearningmodels.somemodels extract static features from cfgs.
however these static features are not robust in the presence of optimizations.
another line of work uses language models .
their hypothesis is that these models could learn instruction semantics and hence function semantics.
to limit the vocabulary i.e.
the set of words tokens supported binaries are often normalized before they can be fed to models.
for example immediatevalues i.e.
constantsininstructions and constant call targets are replaced with a special token himmin safe e.g.
thetoken x call himm aroundline8infig.
b and c thatcorrespondstothefunctioninvocation get cli opt .
whilethismakestraining convergence feasible a lot of semantics are lost.
these models may not learn to classify based on instructions essential to function semantics.
for example safe leverages an nlp technique called attention .
conceptually the attention mechanism determines which instructions are important to the output.
we highlight the statements and their tokens with the largest attention values in fig.
.
in these three functions the first few tokens in gray with large attention values are in the function prologues.
the corresponding instructions e.g.
push perform the samefunctionality savingregistervalues tomemory andallocatingspaceforlocalvariables.infig.
3a themodelalso pays attention to tokens instructions related to the switch case statement.asdiscussedbefore however staticstructuresarenot reliable due to optimizations.
in contrast in fig.
3b the model instead emphasizes the normalized function invocation at line which is not distinguishable from the invocation at line in c with a large attention value as well.
from the parts that the model paysattentionto itiseasytoexplainwhysafeconcludes cat o0 is more similar to touch o0 instead of cat o3.
we visualize the weights of full attention layers in fig.
of an extended version of this paper .
.
ourtechnique weaimtoleverageprogramsemanticsinsimilarityanalysis.we definethe semantics ofabinary program u1d443as follows.
403esec fse december3 san francisco ca usa x.xu z.xuan s.feng s.cheng y. ye q. shi g.tao l.yu z.zhang andx.zhang a cat o3 144blocksand218edges b cat o0 blocks and edges c touch o0 89blocksand120edges figure control flow graphs formotivation examples x sub eax 0x41 x cmp eax 0x35 x unk x jmp raxx push r14 x push r12 x sub rsp 0x148 x jmp 0x971 23voidmain cat intargc char argv not meaningful in source code while !
c get cli opt argc argv bestuv switch c case b flag0 true ... break case e flag1 true break case v print coreutils v8.
break default quote error abort a cat o3x movabs rdx himm x call himm x cdqex push rbp x sub rsp 0x1c8 x mov edi1 23voidmain cat intargc char argv not meaningful in source code while !
c get cli opt argc argv bestuv switch c case b flag0 true ... break case e flag1 true break case v print coreutils v8.
break default quote error abort b cat o0x push r14 x push r12 x jmp 0x971 23x push rbp x sub rsp 0x148 x mov edi x unk x call himmvoidmain touch intargc char argv not meaningful in source code while !
c get cli opt argc argv bcdfhv switch c case b flag 0x100 ... break case c flag 0x1 break case v print coreutils v8.
break default quote error abort c touch o0 figure3 ourexample insafe.thestatementshighlightedinyellowhavelargeattention andhenceareimportant .
the gray boxes to the right of the yellow statements denote the corresponding tokens.
special token himmdenotes a constant oraconstant controlflow target.
definition .
.
the semantics of a binary program u1d443is represented by a distribution u1d465 u1d442 u1d449 u1d443 u1d465 d with u1d465 xan input to u1d443and u1d442 u1d449 u1d443 u1d465 the set of externally observable values when executing u1d443on u1d465.
observable values are those observed in i o operations global and heapmemoryaccesses.
intuitively thejointdistributionofinputsandobservablevalues when executing u1d443on the inputs denotes u1d443 s semantics.
observable valuesare hardlyalteredbycode transformations.
a naive sampling method.
one may not need to collect a large number of samples to model the aforementioned distribution becauseiftwoprogramsareequivalent executingthemonequivalent inputsproducesequivalentobservablevalues.therefore anaive method is to provide the same set of inputs to all programs such that those that are equivalent must have identical observable value distributions.however suchasimplemethodisineffectivebecause of the following reasons.
first even equivalent programs might have different input specifications e.g.
different numbers of parametersanddifferentordersofparameters makingautomatically feedingequivalent inputs tothem difficult.
furthermore different programs have different input domains.
when the provided inputs are out of range and hence invalid the corresponding observable value distributions cannot be used to cluster programs.
in our example thevaliddomainof u1d450atline3ofmain cat isasetofcharacters b e s t u v whereas the domain of u1d450at line3ofmain touchis b c d f h v .withoutinputspecifications whicharehardtoacquireforbinaryfunctions thenaivesamplingmethodmayprovide a random input say u1d450 .
as a result the executions of both functions fall into the exception handling paths and the observable valuesare not distinguishable.
ourmethod.
insteadofsolvingtheinputspecificationproblem which is very hard for binary programs we propose a technique agnostic to such specifications.
specifically we propose a novel probabilisticexecutionmodelthatservesasaneffectivesampling method to approximate the distribution ddenoting program semantics.givenaprogram u1d443 weacquireitssemanticrepresentation as follows.
we execute u1d443on a setxof pre determined random inputs which is an invariant for all programs we want to represent.
to address the challenge of input specification differences we assign the same value u1d465 xto each input variable for all programs .
that is we feed the same value to all input parameters making their order irrelevant.
we repeat this for all values in x. as an example for the programs in fig.
we setargcand argv allelementsinthebuffer inboth main cat andmain touch as well as inbuf insize and outbuf in function complex cat to acquiring three executions.
then we set them to acquiring anotherthreeexecutions andsoon.
these random values may not be valid inputs and hence the corresponding executions may not disclose meaningful semantics.
we hence further sample k edge off behavior.
404pem representing binary program semantics forsimilarity analysis viaaprobabilistic executionmodel esec fse december3 san francisco ca usa definition2.
.
givenaprogram u1d443andaninput u1d465 let u1d45dbethe programpathtakenwithinput u1d465 wesayapath u1d45d is u1d458 edge off from u1d45d if u1d458predicates along the execution need to be flipped to other branchoutcomes in orderto acquire u1d45d .
forinstance supposethatwhenexecuting main cat with u1d450 thepath u1d45dis2 .ifthebranchatline 2isflippedtoline assuming that the following execution path is 19is1 edge offfrom u1d45d.
u1d43e edge offbehavior ofaninput u1d465 isessentiallytheobservablevaluesencounteredinall u1d458 edge off paths of u1d465 .observethatfor main cat andmain touch although the0 edge offbehaviors i.e.
theoriginalexecutions arenotdistinguishable the1 edge offbehaviorsarequitedifferent e.g.
the behaviorof main cat includesthosefromthedelegatedfunction at line17.
however there is a practical challenge covering all u1d458 edge offbehaviorevenwhen u1d458 2maybeinfeasibleforcomplex programs since the number of u1d458 edge off paths grows exponentiallywith u1d458.moreover controllingthesamplingprocessexclusively by u1d458inducessubstantialnoiseduetocodeoptimizations transformations.specifically optimizationssubstantiallychangeprogram structures adding removingpredicates.the u1d458 edge offbehaviors are hence quite different.
an example can be found in section a of an extended version of this paper .
to suppress the noise introducedbyoptimizations we leverage theobservationthatoptimizationsrarelychangethe selectivity rankingofpredicateswith the maximum andminimum dynamicselectivity .
definition2.
.
dynamicselectivityforapredicateinstance u1d465 u1d466.alt is barex barex barex barex where are the runtime valuesofvariable u1d465and u1d466.alt and .
forinstance supposethatinanexecution thevalueof inbuf atline22infig.1is173.itisthencomparedwith0x20.thedynamic selectivity of the predicate instance is hence i.e.
0x20 .
essentially the dynamic selectivity reflects how likely a branch predict evaluates to true .althoughautomaticcode transformationsmaychangedynamicselectivity thepredicateinstances with the largest smallest dynamic selectivity tend to stay as the largest smallest ones after transformations.
we formally explain the observation in section .5and empirically validate it in section4.
.therefore weselectpredicateinstancestoflipfollowing abeta distribution with u1d6fc u1d6fd .
.
the distribution has the largest probabilities for predicates with the minimum and maximum selectivity and small probabilities in the middle like a u shape .
intuitively if two programs are equivalent similar their predicateswiththelargestandthesmallestselectivitytendtobe thesame.byflippingthesepredicatesinthetwoversions weare exploringtheirequivalentnewbehavior.
in our example for both the optimized and the unoptimized versionof main cat thealgorithmfirstflips thepredicateatline withahighprobabilitysincethe !
chasthelargestselectivityon path2 .thenweachievethe1 edge offpath as discussed above.
along the new path the algorithm flips the predicatewiththelargestselectivityatline 22forfurther2 edge off explorationinboth versions exposing similar behavior.
torealizetheprobabilisticexecutionmodel wedevelopabinary interpreterthatcanfeedthebinarywithspeciallycraftedinputsand sample observable values section .
.
it also features a probabilistic memory model that can tolerate invalid memory accesses while observable values input program input distribution probabilistic execution observable value distributionseed inputs probabilistic mem model path sampling value frequencya sequence of same value instructions cfginterpreted paths next pathmultiple samples aggregation interpreterinvalid pointer dereferences values figure workflow of pem ensuring equivalent observable values for equivalent programs section3.
.
compared to traditional forced execution based techniques pemnaturallyhandlesthefunctioninliningproblemasour samplingisnotdelimitedbyfunctionboundariesandourexecution contextsarelargelyrealistic.comparedtofuzzingbasedtechniques ours does not rely on solving the hard problem of generating valid inputs.
compared to machine learning based techniques our techniquefocusesondynamicbehaviorofprograms whicharemore accuratereflections ofprogram semantics .
design .
overallworkflow theworkflowof pemisshowninfig.
.theinputisinthegrey boxontheleftside.itconsistsofasetofseedinputs eachbeing an infinite sequenceofthe same value the binaryexecutable and a path sampling strategy that can predict the next path to interpret based on the set of interpreted paths.
the interpreter interprets the subject binary on a seed input supplying the same value to any inputvariable encountered duringinterpretation to eliminate any semantic differences caused by parameter order differences.
the interpretation also strictly follows the path indicated by the pathsamplingcomponent.wheninvalidpointerdereferencesare encountered which can be easily detected the interpreter interacts with the probabilistic memory model to emulate the access outcomes.
the emulation ensures that the same sequence of observable values are returned for equivalent paths.
after sampling ontherightside theobservablevaluedistributionsaresummarized for later similarity analysis which simply compares two multi sets.
theremainderofthissectionisorganizedasfollows.wefirst model binary instructions using a simplified language.
then we presentthesemanticrules.afterthat wediscussthepathsampling methodandthe probabilisticmemory model.
.
language thesyntaxofourlanguageisinfig.
.aprogram u1d443consistsofa sequence of instructions.
there are three categories of instructions.
first there are instructions that move values among registers u1d45f1 u1d45f2movesthevaluein u1d45f2to u1d45f1 u1d45f u1d463movesaliteralvalue u1d463 u1d45f1 u1d45f2 u1d45f3 movestheresultof u1d45f2 u1d45f3to u1d45f1.thesecondcategoryisloadandstore instructions.
the load instruction u1d45f1 treats the value in u1d45f2 asamemoryaddressandloadsthevalueinthespecifiedmemory location to u1d45f1.
store is similar.
there are also instructions that changethecontrolflow.instruction jmp u1d44ejumpstotheinstruction at u1d44e jcc u1d45f u1d44eperforms the jump operation only when the value in u1d45fis non zero jr u1d45fis an indirect jump that uses the value in u1d45f as the target address.
instruction donemeans the interpretation is finished.
although our language does not model functions for 405esec fse december3 san francisco ca usa x.xu z.xuan s.feng s.cheng y. ye q. shi g.tao l.yu z.zhang andx.zhang program u1d443 colonequal u1d43c register u1d445 colonequal u1d45f0 u1d45f1 ... u1d45f31 val u1d463 colonequal ... addr u1d44e colonequal ... comparison colonequal ... binop colonequal ... instruction u1d43c colonequal u1d45f1 u1d45f2 u1d45f u1d463 u1d45f1 u1d45f2 u1d45f3 u1d45f1 u1d45f2 u1d45f3 u1d45f1 u1d45f2 jmp u1d44e jcc u1d45f u1d44e jr u1d45f done u1d43c1 u1d43c2 figure syntax ofour language u1d445 u1d452 u1d454 u1d460 regstate colonequalregister val u1d440 memory colonequaladdr val u1d456 u1d450 instrcnt colonequalz u1d442 u1d449 observablevaldist colonequalval z colonequalundefined value u1d45d path colonequalinstrcnt z u1d460 seedvalue colonequalz decode u1d44e returnsinstructions in a basicblock starting from u1d44e.
valid u1d44e if anaddress u1d44eis valid pointing to allocated memory .
invalidld u1d44e load a valuefrom aninvalidaddress u1d44e.
figure6 statedomainsininterpretation top andauxiliary data andfunctions bottom simplicity ourimplementationsupportsthefullx86instructionset includingfunctioninvocations andreturns.
.
interpretation thestatedomainsoftheinterpreterareillustratedintheupperbox offig.
.theregisterstate u1d445 u1d452 u1d454 u1d460isamappingfromaregistertoa value.whileinourpresentationvaluesaresimplynon negativeintegers our implementation distinguishes bytes words and strings.
the memory store u1d440is a mapping from an address to a value.
we useaninstructioncounter u1d456 u1d450toidentifyeachinterpretedinstruction along the execution path.
u1d442 u1d449denotes the observable value statistics.itisamappingfromavaluetothenumberofitsobservations thatis howmanytimesthevalueappearsinthecurrent interpretation.inthelowerbox wedefineanumberofauxiliary data structuresthatareimmutableduringinterpretationandanumberofhelperfunctionsusedinthesemantic rules.in particular we use todenoteanundefinedvalue u1d45dtodenotethepathtointerpret determinedbythepathsamplingcomponent foragivenseed value u1d460 .
it is a mapping from instruction count to an instruction address.
for example a edge off path for a seed value can be 0x804578 0x80a41f .itmeansthatthepredicate instancewiththe instructioncount1000ought totakethebranch startingat0x804578whenexecutingthebinarywiththeseedinput and the instance with count should take the branch at 0x80a41f.
the helper function decode u1d44e disassembles the instructionsinabasicblockstartingat u1d44e.thefunction valid u1d44e determines if an address is valid.
note that since we enforce branch outcomes and use crafted inputs the execution states may be corrupted.
this function helps detect such corrupted states and seeks help from the probabilistic memory model.
the function invalidld u1d44e loads avaluefrom an invalidaddress.
partofthesemanticrulesareinfig.
.asshownatthetopof fig.
thestateconfigurationisatupleoffiveentries.aruleisread as follows if the preconditions at the top are satisfied the state transition at thebottom takes place.
for example rule jccgtsays that if there is a branch u1d44e specified in u1d45dfor the current instruction count u1d456 u1d450 theconditionaljump isinterpreted andthecontinuation is u1d43c decodedfrom u1d44e .
intuitively given a seed value u1d460 the interpreter initializes all registers and parameters with the same value u1d460 and starts interpretationfromthebeginning rule start .theinterpretationlargely follows concrete execution semantics except the following.
first stateconfiguration u1d445 u1d452 u1d454 u1d460 u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 entrypoint u1d452 u1d45b u1d45f u1d445 u1d452 u1d454 u1d460 u1d460 u1d445 u1d452 u1d454 u1d460 decode u1d452 u1d45b u1d446 u1d461 u1d44e u1d45f u1d461 u1d45d u1d44e u1d43c decode u1d44e u1d445 u1d452 u1d454 u1d460 jcc u1d45f u1d44e u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d445 u1d452 u1d454 u1d460 u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d43d u1d450 u1d450 u1d43a u1d447 u1d445 u1d452 u1d454 u1d460 u1d45d u1d43c decode u1d44e u1d445 u1d452 u1d454 u1d460 jcc u1d45f u1d44e u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d445 u1d452 u1d454 u1d460 u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d43d u1d450 u1d450 u1d447 u1d445 u1d452 u1d454 u1d460 u1d45d u1d445 u1d452 u1d454 u1d460 jcc u1d45f u1d44e u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d445 u1d452 u1d454 u1d460 u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d43d u1d450 u1d450 u1d439 u1d445 u1d452 u1d454 u1d460 u1d44e u1d463 u1d440 u1d445 u1d452 u1d454 u1d460 u1d445 u1d452 u1d454 u1d460 u1d445 u1d452 u1d454 u1d460 u1d45f1 u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d445 u1d452 u1d454 u1d460 u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d43f u1d451 u1d449 u1d445 u1d452 u1d454 u1d460 u1d44evalid u1d44e u1d440 u1d445 u1d452 u1d454 u1d460 u1d445 u1d452 u1d454 u1d460 u1d445 u1d452 u1d454 u1d460 u1d45f1 u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d445 u1d452 u1d454 u1d460 u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d43f u1d451 u1d448 u1d451 u1d445 u1d452 u1d454 u1d460 u1d44e valid u1d44e u1d463 invalidld u1d44e u1d445 u1d452 u1d454 u1d460 u1d445 u1d452 u1d454 u1d460 u1d445 u1d452 u1d454 u1d460 u1d45f1 u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d445 u1d452 u1d454 u1d460 u1d43c u1d456 u1d450 u1d440 u1d442 u1d449 u1d43f u1d451 u1d43c u1d463 figure interpretationrules when it encounters a conditional jump which is indicated by the path descriptor u1d45dto take a specific branch it takes the specified branch rule jccgt .
otherwise it follows the normal semantics rulesjcctandjccf .
second when it encounters a load if the address is valid but the memory location has not been defined it fills it with u1d460 ruleldud if the address is invalid it fetches a value from the probabilistic memory model rule ldiv otherwise it loads a value from the memory as usual rule ldv .
here u1d445 u1d452 u1d454 u1d460 u1d445 u1d452 u1d454 u1d460 meansthattheregisterstateisupdatedby associating u1d45f1to u1d463 yielding a new state u1d445 u1d452 u1d454 u1d460 .
store instructions are interpreted similarly.
we track all dynamic memory allocations for access validity checks.details are elidedas this isstandard.
wealsohaveasetofloggingrulesthatdescribehow pemrecords the statistics of observable values.
we record the frequencies of memory addresses accessed values loaded stored control transfer targets andpredicateoutcomes.duetospacelimitations details arepresentedinsectionbofanextendedversionofthispaper .
loops and recursion.
since our goal is to disclose semantic similarity and not to infer semantics faithful to any executions induced byrealinputs followingcommonpractice weunrolleachloopand recursive call20 times.
.
pathsampling wepresentthepathsamplingmethodinalgorithm .itconsistsof two functions.
function interpretat line1interprets the input program and flips the predicates that are indicated by path a mapping from instruction count to an address .
specifically during interpretation thealgorithmflipsapredicateinstancetoanaddress indicatedin pathifthecorrespondinginstructioncountismet.the function returns alistofencounteredpredicate instances.
function sampleiteratively selects a predicate instance to flip from all the interpretation results in previous steps .
variable candidatesdenote a set of candidate predicates for flipping and budget the number of interpretations allowed.
to begin with pemfirst interpretsafaithfulpathwithoutalteringanybranchoutcome.itthen adds predicates inthis faithful pathto the candidates list line .
asshownintheloopatline pemiterativelyselectsapredicate to flip line composes a new path with the outcome of the 406pem representing binary program semantics forsimilarity analysis viaaprobabilistic executionmodel esec fse december3 san francisco ca usa algorithm1 probabilisticpathsampling 1function interpret program path interpretsthe input program flips predicates indicated by path returns predicateinstancesin the form path instruction count predicate selectivity outcome 2return u1d45d u1d44e u1d461h u1d456 u1d450 u1d45d u1d45f0 u1d460 u1d452 u1d4590 u1d45c u1d462 u1d4610 ... 3function sample program 4candidates candidatebranchesto flip 5budget numberofsample rounds 6faithful interpret program 7candidates.add faithful 8whilebudget 0do budget budget path ic pr sel out select candidates nextpath path ic getbranch pr out results interpret program nextpath candidates.add results selectedpredicate flippedatline function getbranch acquires the target address for the true false branch outcome of a predicate pr interprets the program according to the new path line and updates the list of candidates line .
note that at line to select the predicate instance to flip pemsorts all the candidate predicates by their dynamic selectivity.
then a real number u1d456 is sampled following the probability density function pdf of a beta distribution .pemselects a predicate that is at the u1d456 percentile of the sorted candidates list i.e.
u1d460 u1d452 u1d459 u1d452 u1d450 u1d461 u1d452 u1d451 u1d45d u1d45f u1d452 u1d451 u1d460 u1d45c u1d45f u1d461 u1d452 u1d451 u1d450 u1d44e u1d45b u1d451 u1d456 u1d451 u1d44e u1d461 u1d452 u1d460 u1d456 u1d459 u1d452 u1d45b u1d460 u1d45c u1d45f u1d461 u1d452 u1d451 u1d450 u1d44e u1d45b u1d451 u1d456 u1d451 u1d44e u1d461 u1d452 u1d460 .
details can be foundinsection fofan extendedversionofthis paper .
.
formal analysis ofpathsampling the effectiveness of our path sampling algorithm piggybacks on the following theorem.
theorem .
.
assume two functionally equivalent programs u1d443 and u1d443 .ifweinterpretthemalongtwoequivalentpathsandcollect the predicateinstancesduringinterpretation thepredicate instanceswith thelargest smallest dynamicselectivityinbothprogram shavealarger probabilitytomatch comparedtothosewithnon extremese lectivity.
while optimizations e.g.
constraint elimination may modify predicates to simplify control flow predicates with the smallest and largest dynamic selectivity are most resilient to optimizations namely theirselectivityrankinghardlychangesbeforeandafter optimizations.
modifications to predicates introduced by optimizations fall into two categories predicate elimination andinsertion.
a predicate relocation can be considered as first removing the predicateandthenaddingittoanotherlocation.specifically compiler may eliminate a predicate if its outcome is implied by the path conditionreachingthepredicate.forexample itmayeliminatea predicate u1d465 10ifthepathconditionincludes u1d465 .ontheother hand compiler may introduce new predicates to provide control flowshortcuts.takefig.
8asanexample.compilerinsertsanew predicate u1d465 infig.8b showninred .themodificationsimplifiesthecontrolflowwhen u1d465islessthan .notethat inthese cases the dynamic selectivity of an inserted predicate will be close tothedynamicselectivityofanexistingonebecausetheseinserted predicates are derivedfrom constraintsinexisting predicates.1ifx .
.
.
2else if x .
.
.
3else if x .
.
.
.
.
.
5else abort a beforeoptimization1if x abort 2ifx .
.
.
3else if x .
.
.
4else if x .
.
.
.
.
.
6else abort b after optimization figure8 exampleofoptimizationthatprovidescontrolflow shortcutbyinsertingpredicates.thecompilerinsertsapredicatex 10atline1infig.8b.whenx theexecutiondirectly goestoabort without comparing with other values.
the intuition of ourtheorem is hencethat the rankings of predicateswiththesmallest largestselectivitydonotdependonwhether other predicates are modified.
in contrast the predicates ranked in themiddlebytheirselectivityaremorelikelytohavetheirrankings changedwhen predicates are removedoraddedbyoptimization.
proofsketch.
weformalizetheintuitionbyfirstreasoningaboutthe predicateshavingclosetothesmallestdynamicselectivit y.reasoningforthelargestonesissymmetric.supposethatforeachp redicate thecompilerhasaprobability u1d461toeliminateitandaprobability u1d45efor havingapredicateinsertedthatranksrightbeforeit.inei thercase wesaythepredicateismodified.theprobabilitythatapred icateis notmodifiedisnotedas u1d45f u1d461 u1d45e.wefurtherdenoteas p u1d458the probabilitythatthe u1d458 thsmallestpredicateisstillthe u1d458 thsmallest oneafteroptimization.itiscalculatedbythefollowingfo rmula p u1d458 u1d45f u1d458 summationdisplay.
u1d456 parenleftbigg u1d458 u1d456 parenrightbigg parenleftbigg2 u1d456 u1d456 parenrightbigg u1d45f u1d458 u1d456 u1d461 u1d456 u1d45e u1d456 intuitively therankingofthe u1d458 thsmallestpredicateisnotchanged by optimizations if a this predicate is not modified and b the numberofpredicateswithasmallerdynamicselectivitydoesnot change.
in the above formula u1d45frepresents condition a and the second term represents condition b .
specifically b is satisfied only when the numbers of removed and inserted predicates that rankbefore u1d458areequal.here parenleftbig u1d458 u1d456 parenrightbig u1d45f u1d458 u1d456meansanevennumber u1d456 ofthe u1d458 1predicateswithasmallerrankingaremodified and parenleftbig2 u1d456 u1d456 parenrightbig u1d461 u1d456 u1d45e u1d456means half of the modifications are removals and the other halfareinsertions.wevisualizethedistributionof p u1d458infig.9with threesetsofconfigurationsof u1d461and u1d45e.wecanseethatinallsetups p u1d458monotonically decreaseswhen u1d458increases.
wealsoconductanempiricalstudytovalidateourtheoreticalanalysis.theresultsarevisualizedinsection .
.theresultsshow pem hasan80 chanceofmakingcorrectselectionsandexploring equivalent paths by deterministically selecting the predicates with largest smallest dynamic selectivity.
advantagesofprobabilisticpathsamplingoverdeterministic selection.
note that the probability of predicates with the smallest largest selectivity having theirrankings changedby optimizationisnot0 althoughitissmallerthanothers.totolerate suchcertainty weemploy aprobabilisticapproach meaning that we follow a beta distribution instead of deterministically selecting the predicates with extreme selectivities for flipping.
we further conduct a formal analysis to justify why the probabilistic sampling algorithm is better than the deterministic algorithm.
intuitively by 407esec fse december3 san francisco ca usa x.xu z.xuan s.feng s.cheng y. ye q. shi g.tao l.yu z.zhang andx.zhang k th smallest0.
.
.
.
.8pkt .
q .
t .
q .
t .
q .
figure p u1d458w.r.t.
u1d458 the u1d465 axis denotes the ranking of predicates by dynamic selectivity the u1d466.alt axis denotes the probabilitythatthepredicatewiththe u1d458 thsmallestdynamic selectivity after optimization has the same ranking.
each line showsresults foroneset of u1d461and u1d45e.
followingabetadistribution pemspendssomebudgetonpredicatesthatdonothavethelargestorsmallestselectivity butselectivities close to the largest and smallest.
these additional selections increase the probability that pem selects the correct path i.e.
the equivalentpath ateachstep.takingmorecorrectstepsatearlier selections increasesthe chancethat pemchooses a correctstep at later selections because the candidate predicates of later selections comefrompreviouslyexploredpaths.theformalproofisshown insection c ofan extendedversionofthis paper .
effect of path infeasibility.
our algorithm may select infeasible paths.
two possible concerns are whether observable values along infeasible paths in two similar binaries can correctly disclose their semantic similarity and whether observable values along infeasible paths in twodissimilar binaries may undesirably match leadingto the wrongconclusion oftheirsimilarity.
forthefirstconcern weshowthat pemlikelyselectscorrespondingpathswhentwobinariesaresimilar regardlessofthefe asibility of selected paths.
that is although the paths may be infeasi ble thesequencesofobservablevaluesalongthemareequivalen t.we showaproofsketchinsectiond.1andshowempiricalsupport in sectiond.3ofanextendedversionofthispaper .
forthesecondconcern theprobabilitythattwoequivalentpaths areselectedby pemintwodissimilarbinariesisverysmall.inthose cases although the initial seed paths may be undesirably similar e.g.
the error handling paths the following flipped infeasible pathsquicklybecomesubstantiallydifferent.theformalproofisin sectiond.2andtheempiricalstudyisinsectiond.3ofanextended versionofthis paper .
.
probabilisticmemorymodel the goal of the probabilistic memory model pmm is to handle loadsandstoreswithinvalidaddressesinducedbypredicateflipping andtheuseof out of bound seedvalues.akeyobservationisthat the specific values written to read from the pmm do not matter aslongastheycanexposefunctionalequivalence.wedefinethe following twopropertiesfor avalid pmm.
definition .
.
we say a pmm is equivalence preserving if thesequenceof invalid addressesaccessed and thevalueswrittento read fromthepmmmustbeequal fortwoequivalentpathsintwo functionallyequivalentprograms.
this property ensures pemcanplaceequivalent programsinto the same class.
definition .
.
we saya pmm is difference revealing if the sequenceof invalid addressesaccessed andthevalueswritten to readfromthepmmmustbedifferentfortwodifferentpaths pertaininginvalid memory accesses in two respective programs which may or may not beequivalent.
thisistoensuredifferentprogramsarenotmistakenlyplaced in the same class.
for example a naive pmm always returns a constant value for any invalid reads and ignores any invalid writes.
it isequivalence preservingbut not difference revealing.
our pmm is designed as follows.
before each interpretation run itinitializesa probabilisticmemory u1d443 u1d440 whichisamapping addr valofsize u1d6fesuchthat u1d44e u1d443 u1d440 u1d45f u1d44e u1d45b u1d451 u1d45c u1d45a .an invalid memory read from the normal memory u1d440with address u1d44e isforwardedtothe u1d443 u1d440throughthe invalidld u1d44e function which returns u1d443 u1d440 .
similarly an invalid memory write to the normalmemory u1d440withaddress u1d44eandvalue u1d463isachievedbysetting u1d443 u1d440 u1d463.
itcanbeeasilyinferredthat ourpmmsatisfiesthe equivalence preserving property by induction on the length of program paths .
intuitively the firstinvalidaccessesintwoequivalentpathsmust have the same invalid address.
as such our pmm must return thesamerandomvalue.thissamerandomvaluemaybeusedto computeotheridentical invalid addressesinthetwopathssuch that the following invalid loads stores are equivalent.
it also probabilisticallysatisfiesthedifferencerevealingproperty.specifically differentpathsmanifestthemselvesbysomedifferentinvalidaddresses and our pmmlikely returns different random values for these different addresses rendering thefollowing memorybehaviors with invalid addresses different.
the chance that different paths may exhibit the same behavior depends on u1d6fe.
due to the complexityofmodelingmemorybehaviorinreal worldprogram paths wedidnotderiveatheoreticalprobabilisticboundforour pmm.
however empirically we find that u1d6fe u1d458enables very goodresults withourloopunrollingbound20 .anexamplecan be foundinsection e ofan extendedversionof this paper .
evaluation weimplement pemonqemu .detailsareinsectionfofan extendedversionofthispaper .weevaluate pemviathefollowing researchquestions rq1 howdoes pemperform comparedto the baselines?
rq2 howuseful is peminreal world applications?
rq3 ispemgeneralizable?
rq4 howdoes eachcomponentaffectthe performance?
.
setup we conduct the experiments on a server with a core intel r xeon r 4214r cpuat .40ghz 188g memory andubuntu .
.
datasets.
weusetwodatasets.
dataset i tocomparewithimfand blex which only use coreutils as their dataset we construct a dataset from coreutils .
.
we compile the dataset using gcc .
and clang with optimization levels i.e.
o0 o2 and o3 .
dataset ii includes real world projects commonly usedin binary similarity analysis projects .
they are coreutils curl diffutils findutils openssl gmp sqlite imagemagick and zlib.
the binaries are obtained from .
in total we have programs with35kfunctions compiledwith3differentoptions.
detailscan be foundintable8ofan extendedversionof this paper .
baselinetools.
wecomparewith6baselines.forexecution based methods baseline i we use imf and blex which are sotasasfarasweknow.fordeeplearningmethods baseline ii 408pem representing binary program semantics forsimilarity analysis viaaprobabilistic executionmodel esec fse december3 san francisco ca usa table1 comparisonof pem imf andblex.
candgdenote clangandgcc respectively.eachprecisionisaveragedover the106 binariesincoreutils.
pairprecision precision precision pemimf blex pemimfpemimf c o0c o394.
.
x .
.
.
.
c o2c o399.
.
x .
.
.
.
c o0g o394.
.
x .
.
.
.
g o0g o396.
.
.
.
.
.
.
g o2g o398.
.
.
.
.
.
.
g o0c o392.
.
x .
.
.
.
average .
.
.
.
.
.
.
weusesafe andtrex .weusetheirpre trainedmodelsor trainusingtheirreleasedimplementationwiththedefaulthyperparameters.
also we compare with the best two models i.e.
gnn andgmn inhow solve that conducts ameasurement study onmachinelearningmethods.
metrics.
followingthesameexperimentsetupinimfandblex forafunctioncompiledwithahigherleveloptimizationoption e.g.
o3 we query the most similar function in all the functions in the samebinary compiledwithalowerleveloptimizationoption.as such thereisonlyonematchedfunction.wehenceuseprecisionat position pr as the metric.
given a function pr measures whether the matched function scores the highest out of the pool of candidate functions.
many data driven methods use area under curve auc of the receiver operating characteristic roc curve.
existing literature points out that a good auc score does not necessarily imply good performance on an imbalanced dataset e.g.
class having sample and class having .
therefore we choose pr as our metric which aligns better with the real world imbalanced use scenario ofbinary similarity.
.
rq1 comparisonto baselines comparison to baseline i. we compare pemwith baseline i on dataset i.toconducttheevaluation wefirstuse pemtosample each function in these binaries and aggregate the distribution of observable values.
then for each function in an optimized binary we compute its similarity score against all functions of the same program compiled with a lower optimization level and use the ones with the highest scores to compute pr .
besides pr we also use pr and for a more thorough comparison with imf.
thecomparisonresultswithimfandblexareshownintable .
thefirsttwocolumnslistthecompilersandtheoptimizatio nflags usedtogeneratethereferenceandquerybinaries.columns3 and8 9listpr and respectively.notethatblexonly reportspr 1anddoesnothaveresultsforbinariescompiledwit h clang.pemoutperformsblexonpr 1andoutperformsimfonall 3metricsunderallsettings.especially forfunctionpairs clang o0 gcc o3 and gcc o0 clang o3 whicharethemostchalleng ing settingsinourexperiment pemoutperformsimfbyabout25 .
comparisontobaseline ii.
wecompare pemwithbaseline iion dataset ii.followingthesetupofhow solve foreachpositive pair of functions namely similar functions negative pairs i.e.
dissimilar functions are introduced to build up the test set.
the results are shown in fig.
.
the u1d465axis represents different programs andthe u1d466.altaxisispr .theresultsof pem gnn and 1wecompare pemwiththereportedresultsintheimfpaperandcontacttheauthor s ofimftoensureoursetupsarethesame.
.
.0o0 vs o3 gmn gnn pem avg.
gmn avg.
gnn avg.
pemo2 vs o3 .
.
.
.
.
.
programsprecision figure10 comparisonwithhow solve.weleveragethebest twomodels i.e.
gnnandgmn inhow solve.eachbardenotes aprogram whosenameiselided.abarwith1.0pr 1means thatpemfinds the correct matches for all functions in the program.dashedlinesdenotetheaveragepr 1ofeachtool.
gmn are shown in green yellow and red bars.
the average pr of each tool is marked by the dashed line with the related color.
note that gnn and gmn are the best two models out of all ml basedmethodsinhow solve includingtrexandsafe .
as fig.10illustrates pemachieves scores from .
to .
which isaround betterthangnn andgmn.
comparisonwith trex and safe.
with the aforementionedcompositionofdataset pemoutperformstrexby40 andoutperforms safeby25 onaverage.moreover theperformanceoftrexand safeissensitivetodatasetcomposition.henceinthiscomparative experiment weanalyze howdifferent data compositionsaffect the performance of different tools.
our results show that pemis more resilient than trex and safe.
details can be found in section h ofan extendedversionof this paper .
.
rq2 real worldcasestudy wedemonstratethepracticeuseof pemviaacasestudyofdetecting dayvulnerabilities.supposethatafteravulnerability isreported a systemmaintainerwantstoknowifthevulnerablefunctiono ccurs inaproductionsystem.shecanuse pemtosearchforthevulnerable functionfromalargenumberofbinaryfunctionsanddecidew hether furtheractionsshouldbetaken e.g.
patchthesystem .we collect8 dayvulnerabilities cves andusetheoptimizedversion ofthe problematicfunctiontosearchforitscounterpartintheun optimized binary.
the results show that in out of the cases our tool c an findthegroundtruthfunctionasthetopone whiletheother two ml based methods each can only find of them.
even if we look intothetop30 bothofthemcanonlyfind2oftheseproblemat ic functions.detailscanbefoundinsectioniofanextendedve rsion ofthispaper .
.
rq3 generalizability we evaluate the generalizability of pemfrom three perspectives.
first we show that pemis efficient so that it can scale to large projects.
second we illustrate that pemhas good code coverage for most functions.
that means it can explore enough semantic behavior even for complex functions.
last but not least besides x86 weshowthat pemcansupportanotherarchitecturewith reasonablehumanefforts meaningthat pemcanbeeasilygeneralizedto analyzing binary programs from multiple architectures without the need of substantial efforts in building lifting or reverse engineeringtoolsto recover high level semantics from binaries.
efficiency.
pemanalyzesmorethan3functionspersecondinmost cases.notethatthisisaone timeeffort.afterinterpretationand generating semantic representations pemsearches these representations to find similar functions.
pemcompares more than 409esec fse december3 san francisco ca usa x.xu z.xuan s.feng s.cheng y. ye q. shi g.tao l.yu z.zhang andx.zhang coreutilsdiffutilsfindutilscurlgmpzlib imagemagickopensslsqlite0.
.
.
.
.
.0o0 coreutilsdiffutilsfindutilscurlgmpzlib imagemagickopensslsqliteo3 .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
figure coverage of pem pairs per second in most cases.
the comparison can be parallelized.
with processes we are able to compare .
million function pairs in4minutes wall clock .wevisualizetheresultsinfigure27of an extendedversionofthis paper .
pemtakes minutes to cover more than code for all functions in coreutils with a single thread .
in comparison the forcedexecutionbased methodblextakes .
hours.
in our experiment pemtakes26minutesto processtwo coreutilsbinariescompiled with different optimization levels and it takes another minutes tocompareall1.7millionfunctionpairsbetweenthesetwobinaries yielding atotal time cost of40 minutes.
while imf takes 32minutestocompletethesametask pemachievessignificantlybetter precision than imf.
machine learning models typically have an expensivetrainingtime.theyhavebetterperformanceintesttime.
coverage.
the code coverage of pemon dataset ii is shown in fig.
.
the u1d465axis marks the projects and the u1d466.altaxis shows the percentage of functions for which pemhas achieved various levels of coverage denoted by different colors.
as we can see of the functionsin o0and85 functionsin o3haveafullorclose to full coverage.
those functions with less than coverage have extremelycomplexcontrolflowstructures withmanyinlinedcallees.
for example the main function of sortin coreutils has basic blocks resulting in millions of potential paths.
note that even with such a huge path space pemis still able to select similar paths and collectconsistent valueswithahigh probability.
cross archsupport.
weaddaarch64 supportto pemwith only around lines of c code and .
person day efforts.
this ispossiblebecauseourprobabilisticexecutionmodelisgeneraland does not rely on specialized features from the underlying architecture.pemachievesapr 1of86.8forcoreutils o0and o3 on aarch64 whereasitscounterpartonx86 64is89.
.inaddition it achievesapr 1of84.9whenwequerywithfunctionscompiled onx86 64inthepooloffunctionscompiledonaarch64.details can be found in table of an extended version of this paper .
.
rq4 ablation study probabilisticpathsampling.
first weempiricallyvalidateour hypothesis that branches with the largest and smallest selectivity are stable before and after code transformations.
we collect equivalentinterpretationtracesfromthemainfunctionsincoreutils binaries compiled with different options.
then we analyze the matchingtracesandcheckifthepredicateswiththelargestandthe smallest selectivity in these cross version traces match leveraging thedebuginformation.intotal westudy636tracesfrom6binaries withatotalof16kpredicateinstances.weobservethatwithaprobabilityofmorethan80 ourhypothesisholds.thedetailedresults areshowninfig.
.fromthetwoendsofthelines wecanobserve thatinmorethan80 cases thepredicateswiththesmallestand the largest selectivity match.
in contrast those in the middle dotable perf.
w.r.t.
differentpath sampling strategies lastpred det.
pem pr .
.
.
cover o0 .
.
.
cover o3 .
.
.
table perf.
w.r.t.
differentbudgets pr cover o0 cover o3 table perf.
w.r.t.
differentmemory models no mem const pmm pr .
.
.
cover o0 .
.
.
cover o3 .
.
.
nothavesuchaproperty.themedianforthe max 3selectivityis even closeto0 .
forpredicateinstanceswiththesmallest largest selectivityinonetrace e.g.
o3 wefurtherstudythese lectivity rankingsof theircorrespondencesinthe othertrace e.g.
o0 .the resultsarevisualizedinfig.
.observethatinmorethan98 cases theyhavethetop 3smallestorlargestselectivityintheot hertrace.
furthermore weselect80mostchallengingfunctionsincoreutilstofurtherstudytheeffectivenessofourpathsamplingstrategy.
thesefunctionshavemorethan150basicblocksandtheaverage connectivity is larger than namely a block is connected to more than3blocksonaverage.wecomparetheperformanceof3path sampling strategies.
the results are shown in table .
the three rowsshowthepr thecodecoveragefor o0and o3functions respectively.
the second column presents a strategy in which pem flips the last predicate encountered in the previous round with an uncoveredbranch.thethirdcolumndenotesastrategyinwhich pemdeterministicallyflips thepredicates withthe largest and the smallest selectivity at each round.
the last column presents our probabilistic path sampling strategy.
observe that the probabilistic strategysubstantiallyoutperformstheothertwoandboththedeterministicand probabilistic strategies can achieve good coverage.
code coverage versus precision.
we runpemwith different round budgets on coreutils and observe coverage and precision changes.
the results are shown in table .
observe that if we only interpret each function once without any flipping the precision is as low as and the coverage is low too.
with more budgets namely flipping more predicates both the precision and the coverage improve indicating pemcan expose equivalent semantics.
but the improvement becomes marginalafter .
probabilisticmemorymodel pmm .
werunpemwithdifferent memorymodelsetupsoncoreutilstoillustratethebenefito fmodelinginvalidmemoryaccesses.theresultsareintable .specifically no memmeanswedonotmodelinvalidmemoryaccesses.wereturn randomvaluesforinvalidreadsandsimplydiscardinvalidw rites.
the precision of no mem is nearly lower than pmm while their coverage is similar.
that is because some dependencies betweenmemoryaccessesaremissingwithouthandlinginvalid writes.
ontheotherhand ifweallowwritestoinvalidmemoryregion sbut alwaysreturnaconstantvalueforallinvalidreads asshow ninthe columnof const theprecisionisbetterthanno mem.however it 410pem representing binary program semantics forsimilarity analysis viaaprobabilistic executionmodel esec fse december3 san francisco ca usa min min 2min 4min 6min 8max 8max 6max 4max 2max selectivity0.
.
.
.
.
results of a program median figure predicate correspondence versus dynamic selectivity.eachbluedashedlinerepresentstheanalysisresultsof path pairs from two respective binaries compiled differently fromaprogram.the u1d465axisrepresentsselectivity with min theminimaland maxthemaximum and u1d466.altdenotesthepercentageofpredicatematches.wealsocomputethemedian foreachselectivity resultingintheorangeline.
min min min max max max selectivity0200400600number ofpredicates figure13 correspondenceofpredicateswithminandmax selectivity.blueisforminandorangeformax.forexample thebaratmin 1meansthatabout20predicateswithminselectivityinonetracehavemin 1selectivityintheothertr ace.
isstillinferiortopmm.thisisduetoreturningtheconstan tvalue makingreadsfromdifferentinvalidaddressesindistingui shable.
robustness.
we altersystemconfigurationsof pemand runrandom sampling for each probabilistic component in pem.
the experimentalresultsshowthat pemisrobustwithregardtodifferent configurations and variances in samplings.
details can be found in section g ofan extendedversionofthis paper .
related work binarysimilarity.
manyexistingtechniquesaimtodetectsemantically similar functions driven by static and dynamic analysis.
a number of representative methods have been discussed in section .
.
other techniques compare code similarity at different granularity e.g.
whole binary assembly and basic block .
while our method represents semanticsatthefunction level theresultingvalue setsofoursystem can be used as function semantic signatures and facilitate comparisons workingat othergranularity.
forced execution.
forced execution concretely executesabinaryalongdifferentpathsbyflippingbrancho utcomes.
theytypicallyaimtocovermorecodeinaprogramandthususe coverageastheguidance.theycanhardlyselectsimilarset sofpaths forthesameprogramcompiledwithdifferentoptimizations .their focusisonrecoveringfrominvalidmemoryaccesses.incont rast the probabilistic memory model of pemreveals the different semantics introducedbydifferentinvalidaccesseswithhighprobabi lity.
conclusion we develop a novel probabilistic execution modelfor effective samplingandrepresentationof binary programsemantics.
itfeatures apath samplingalgorithmthatisresilienttocodetransformations andaprobabilisticmemorymodelthatcantolerateinvalidmemory accesses.
itsubstantially outperforms the state of the arts.
data availability our experimental data andthe artifact are available at .