automatically resolving dependency conflict building failures via behavior consistent loosening of library version constraints huiyan wang state key lab.
for novel software technology nanjing university nanjing china why nju.edu.cnshuguan liu state key lab.
for novel software technology nanjing university nanjing china liu shuguan .com lingyu zhang state key lab.
for novel software technology nanjing university nanjing china zly smail.nju.edu.cnchang xu state key lab.
for novel software technology nanjing university nanjing china changxu nju.edu.cn abstract python projects grow quickly by code reuse and building automation based on third party libraries.
however the version constraints associated with these libraries are prone to mal configuration and this forms a major obstacle to correct project building known asdependency conflict dc building failure .
our empirical findings suggest that such mal configured version constraints were mainly prepared manually and could essentially be refined for better quality to improve the chance of successful project building.
we propose a looco approach to refining python projects library version constraints by automatically loosening them to maximize their solutions while keeping the libraries to observe their original behaviors.
our experimental results with real life python projects report that looco could efficiently refine library version constraints .4s per version loosening by effective loosening .
new versions expanded on average automatically and transform .
originally unsolvable cases into solvable ones i.e.
successful building and significantly increase solutions more on average for originally solvable cases.
ccs concepts software and its engineering software maintenance tools.
keywords dependency conflict version constraint loosening resolution acm reference format huiyan wang shuguan liu lingyu zhang and chang xu.
.
automatically resolving dependency conflict building failures via behaviorconsistent loosening of library version constraints.
in proceedings of corresponding authors.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .. .
.
31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa 13pages.
introduction python projects depend extensively on third party libraries for resource and code reuse and have gained increasing popularities in recent years.
until aug there are over four million release versions of libraries in pypi a well known centralized python repository of third party libraries.
to build python projects anywhere and anytime developers write configuration scripts e.g.
setup.py orrequirements.txt with version constraints for dependent third party libraries each of which specifies expected versions for a specific library e.g.
numpy .
meaning all versions equal to or over .
.
when such version constraints are properly specified a python project can be restored or built with a compatible execution environment via importing those third party libraries satisfying these constraints which can be done in a recursive way by any python library installer e.g.
pip .
however python projects and their dependent third party libraries are developed independently and this causes developers to have to write version constraints manually without proper guidance.
besides the quick growth of third party libraries requires developers to spend non trivial efforts on keeping these constraints up to date along with library evolution.
when failed to do so the version constraints can conflict with each other and the concerned projects would result in building failures named dependencyconflict building failure or dc building failure for short due to the lack of a compatible execution environment .
fig.1gives a real building failure example from buginpy .
the failure steams from the fact that a project installing library clifford .
.
requires a llvmlite library version satisfying constraint .
.
.
to be installed first transitively required by numba .
but this installation conflicts with the project s another constraint on library llvmlite .
.
.
existing work has investigated into this problem and proposed various ways to address the concerned dc issues for python projects.
for example wang et al.
proposed building dependency graphs for python projects to detect dc issues.
ye et al.
and chengesec fse december san francisco ca usa wang et al.
clifford .
.
numba .
from clifford .
.
llvmlite .
.
.
from numba .
clifford .
.
llvmlite .
.
error numba .
.
has requirement llvmlite .
.
.
but you ll have llvmlite .
.
which is incompatible.
figure building failure pandas 106 0 in bugsinpy et al.
optimized detecting dc issues by searching constraints from building necessities besides explicit libraries e.g.
python interpreter and system libraries .
this line of work focuses on detecting and reporting python dc issues.
another relevant line of work emphasizes alleviating dc building failures by improving libraryinstalling strategies.
for example pip after .
presented a backtracking strategy to better restore a building process when failed smartpip further optimized this process by controlling the backtracking cost with the aid of a dedicated constructed pypi dependency database.
however all these efforts assume sticking to original library version constraints and can unfortunately gain still limited benefits in resolving originally failed project building e.g.
completely helpless to originally unsolvable failures .
we hence dig into python s project building process to see how one can substantially resolve such dc building failures.
our indepth study discloses that some failures are indeed inevitable since their associated library version constraints are themselves unsolvable i.e.
no solution satifying all constraints .
we refer to such failures as type a failure ora failure for short which have to be resolved by rewriting constraints.
we also observe that some failures associated library version constraints are solvable in some cases but the used library installers must support backtracking otherwise the installation could be stuck in a local unsolvable situation .
we refer to such failures as b failure.
finally the remaining failures associated version constraints are essentially solvable in all cases but some installers may still fail due to their specialized search mechanisms.
we refer to such failures as c failure.
since dc building failures are so heavily associated with library version constraints we naturally ask instead of living with very limited or even no solutions by sticking to original low quality version constraints associated with project libraries mainly existing work s focus e.g.
can one step further by proactively refining these constraints for better quality to substantially resolve dc building failures with a better chance and if yes can this be done automatically?
to answer the question we first empirically study existing python dc issues to investigate how dc building failures have occurred due to improper library version constraints.
we observe that strict version constraints e.g.
pinned ones like llvmlite .
.
dominate the most unsolvable cases and limited solutions and can be refined to greatly alleviate failures by slightly loosening such constraints e.g.
loosening to one five more version s already resolving .
.
unsolvable cases .
however loosening library version constraints can be risky since allowing importing versions other than originally specified ones might introduce unexpected behaviors.
as such an immediate challenge is how to loosen version constraints while still assuring libraries consistent behaviors with respect to each specific project that uses these libraries.
with this regard we propose our behavior consistent loosening approach looco which automatically decides maximal boundaries rdfframework .
.
elasticsearch .
.
elasticsearch dsl elasticsearch dsl .
.
installed elasticsearch .
.
.
.
elasticsearch dsl .
.
installed elasticsearch .
.
.
.
loosened?unsolvable!
solvable!figure loosening illustration for dc issue ssmash .
.
fly circus .
.
.
pyyaml .
fly circus .
.
installed pyyaml .
.
.
.
fly circus .
.
installed pyyaml .
.
.
loosened?solvable!
more solutions figure loosening illustration for dc issue in loosening version constraints based on its sliced call graphs that capture truly invoked methods in these used libraries.
based on another observation from our empirical study only very limited library methods less than on average are actually invoked in a python project dependency.
then our loosening approach can be very attractive by providing a great chance to effectively resolve dc building failures via simply loosening library version constraints.
with looco one can solve originally unsolvable cases relating to a failures and b failures effectively resolving dc building failures produce more solutions for originally solvable cases relating to b failures and c failures potentially helping future failure resolution when projects and libraries evolve.
one example from fig.
2illustrates dc issue reported by watchman whose induced building can be resolved by looco buildingrdfframework .
.
requires intalling an elasticsearch version satisfying .
.
and this request conflicts with rdfframework s indirect version constraint .
.
.
.
on elasticsearch transitively instroduced by elasticsearch dsl then looco suggests loosening the library elasticsearch dsl s version constraint on library elasticsearch to .
.
.
.
behavior consistency validated and the building failure is resolved successfully.
another example from fig.
3suggests that ssmash .
.
can be built without any problem and looco can further loosen its version constraints e.g.
library pyyaml can expand its original constraint .
.
.
.
to .
.
.
with more solutions to avoid potential dc building failures in future.
we experimentally evaluate looco s performance and usefulness with real life python projects and their dc issues.
the evaluation results report that looco could effectively loosen projects library version constraints by .
new versions expanded for each library on average with library behaviors successfully validated by built in test cases and developer feedbacks looco could solve .
originally unsolvable cases in a and b failures and enhance .
from with solutions to with more solutions new solutions on average in b and c failures looco was highly efficient and its time overhead was .4s on average per library version loosening.
the remainder of this paper is organized as follows.
section introduces the dependency conflict background.
section 3presents our empirical study and findings for motivating a constraint loosening approach.
section 4elaborates on our looco s methodology for automatically resolving dc building failures.
section 5evaluatesautomatically resolving dependency conflict building failures via behavior consistent loosening esec fse december san francisco ca usa kingarthur .
.
.
.
redis .
.
kingarthur .
.
redis .
.
.
.6grimoire elk .
.
kingarthur .
.
.
.
redis .
.
kingarthur .
.
.
.
redis .
.
.
.
unsolvable for redis kingarthur versions .
.
can be classified into three cuts concerning their different redis dependencies figure dc issue with its three dependency cuts looco s performance and usefulness.
sections 6and7discuss our work and related work and finally section 8concludes the paper.
preliminaries .
dependency in python projects a python project usually depends on multiple third party libraries via its configuration script e.g.
setup.py orrequirements.txt .
in the script a list of version constraints would be written by developers each of which declares expected versions for a specific library.
this facilitates to better saving and restoring a correct execution environment for the project therefore running anytime and anywhere.
a version constraint usually follows pep specifications and can be divided into three classifications pinned constrained and unconstrained.
a pinned version constraint refers to declaring a specific library version e.g.
request .
.
.
a constrained version constraint refers to declaring library versions under constrained ranges !
.
e.g.
pyyaml .
.
and an unconstrained version constraint refers to only declaring a library by the name only without any specific version request e.g.
elasticsearch dsl.
note that code reuse is so pervasive in the python world and not only python projects depend on third party libraries directly dependent library to reuse library code libraries also depend on other libraries a.k.a.
indirectly dependent library for the project as well via version constraint declaration.
we consider those declarations in the project s configuration script for its directly dependent libraries as its direct version constraints and version constraints declared for its indirectly dependent libraries transitive imported as indirect ones.
based on version constraints declared for the project s directly or indirectly dependent libraries python library installers likepip and conda can accordingly install suitable versions for a project s all concerned libraries transitively thus saving and restoring a suitable execution environment for python projects.
due to popularity we consider pipas the typical library installer in this work and other installers like poetry pipenv virtualenv also share similar environment management mechanisms.
.
building failures and dependency conflicts however restoring a suitable execution environment is observed to be so difficult that developers usually spend hours or still fail to set up a correct execution environment .
that is because for the non trivial npc problem of dependency solving a typical installer like pipdoes not guarantee to always achieve a solution for each library due to its specialized strategy thus possibly leading to building failures in restoring execution environment.many building failures have been observed and affect restoring correct execution environments for python projects due to the conflicted version constraints for installing certain libraries.
this is known as dependency conflict issues dc issues which occur due to the conflict among a python project s concerned version constraints either direct or indirect during installation.
for example as aforementioned earlier fig.
1gives a real world building failure caused by dc issues.
this building failure occurred because to install library clifford .
.
for this project llvmlite satisfying .
.
.
would be transitively installed which would result in conflicting when installing the project s another direct dependency on llvmlite latter i.e.
.
.
.
this exhibits a clear dc issue between the project s direct version constraint llvmlite .
.
and indirect one llvmlite .
.
.
transitively introduced by clifford .
regarding resolving dc building failures there are two typical lines of work.
one line of work focuses on detecting dc issues more effectively by collecting complete dependencies for projects such as obtaining exhaustive dependency of projects besides third party libraries e.g.
local environment the python interpreter and system libraries.
another line focuses on solving existing version constraints better with improved installing strategy e.g.
pipbacktracking and smartpip .
different from existing researches generally on sticking to projects original version constraints to build execution environments we focus on how to refine version constraints automatically to resolve building failures thus greatly complementing existing researches.
empirical study and motivation .
research questions we raise the following research questions rq1 study on dc issues how did dc issues occur and lead to building failures?
what version constraints are desirable in resolving such failures?
rq2 study on developer practices how did developers write library version constraints in python projects?
what common practices can be leveraged for resolving dc building failures?
.
design and setup we collected two subjects for our empirical study on dc issues and common developer practices respectively.
.
.
subject a on dc issues.
we tracked all dc issues reported bywatchman which have also been studied in smartpip .
by removing un reproducible cases until jan if either the code repository of the related python project was removed or the bug report did not contain necessary reproducing information for analyses we finally obtained dc issues from python projects.
for example issue is reported because when building grimoire elk .
.
requires to install library kingarthur satisfying kingarthur .
.
and this request might transitively introduce constraint on redis .
.
supposing the situation when kingarthur .
.
is truly installed.
in this situation it conflicts with grimoire elk s other direct version constraint i.e.
redis .
.
.
.
as shown in fig.
.
this makes an installer impossible to find a suitable version to install for redis i.e.
root library that fails to be installed in this situation.
the issueesec fse december san francisco ca usa wang et al.
a package version0255075100125150 b average gap0200400600800 c project depend number19 a version a package version0255075100125150 b average gap0200400600800 c project depend number19 b gap a package version0255075100125150 b average gap0200400600800 c project depend number19 c version constraints projectlibrary .
.
.
.
.
.
.
.
.
.
1k 1k 5k 5k 10k 10k 50k 50k d loc statistics figure description about subject b describes a concrete building situation when dependency conflicts happen and can help us specify the root library that fails to be installed due to conflicting version constraints.
to simulate all possible building situations related to this issue we slice the related dependent and independent version constraints and simulate exhaustive building possibilities by different dependency cuts.
each dependency cut slices a conjunction situation of version constraints for the root library during building with some necessary library ranges specified.
as in fig.
all kingarthur versions in declaration .
.
can be divided into three cuts concerning their different dependencies on the root library redis .
when kingarthur is installed with a version satisfying .
.
.
.
cut redis .
.
would be introduced.
when kingarthur is installed satisfying .
.
.
.
cut redis .
.
.
.
would be introduced.
when kingarthur is installed satisfying .
.
.
.
cut redis .
.
would be introduced.
cut leads to an unsolvable conjunction for installing redis which is known as a dependency conflict resulting in a typical dc building failure.
the three cuts compose all situations that an installer might meet for dependency solving upon the root library redis s version constraints related to this dc issue.
we believe such cut analyses can help us study all building situations extensively and potential threats for those dc issues.
therefore we analyzed and obtained a total of dependency cuts for all the studied dc issues.
we consider these cuts to represent all possible situations for the studied dc issues that can meet during building and work as our subject a.k.a.
subject a for answering rq1 on symptoms and causes of dc building failures.
.
.
subject b on open projects.
we also collected open projects and libraries to investigate developers common practices in the real world to facilitate our resolution.
first we scanned python repositories from github with the top stars with the following requirements use python as its main language allowing typical script language like shell powershell bash etc.
and can be suitably deprecated by python .
evolve with more than one version during its versioning history and be imported as a library by at least one down stream project a.k.a.
dependent project .
we thus obtained libraries in total.
then we accordingly collected requests .
.
urllib3 .
.
.
requests .
.
corresponds to one cut unsolvable for urllib3 api indotel requests .
.
urllib3 .
.
1figure dc issue with its only dependency cut dependent projects for these libraries.
considering the limitations of storage space for libraries with over dependent projects we collected the top dependent projects sorted by stars.
finally we obtained dependent projects avg loc 12k max loc 5m for libraries avg loc 8k max loc 104k .
regarding the libraries we tracked all available versions across its development from both github and pypi repo and obtained a total of different library versions avg versions max versions .
fig.
illustrates the statistical information for the number of library versions versioning gaps the number of dependent libraries by each project and loc statistics in subject b. then we investigate how developers usually write and maintain version constraints for their imported third party libraries and investigate common practices to guide our approach.
more details about subjects can be found on our website .
.
rq1 issue symptom and cause considering all dependency cuts in subject a introduced in section .
.
we note that each cut specifies a conjunction of several version constraints for the dc issue s root library.
if the conjunction is unsolvable this dependency cut can never result in a solution of the root library satisfying all related version constraints thus leading to a building failure.
for example cut in fig.
4composes a conjunction with two version constraints on redis i.e.
.
.
and .
.
.
.
.
they conflict with each other and make it unsolvable for a redis solution.
in this case some installers may directly cause a building failure e.g.
piplegacy strategy before pip .
while some would proceed with fallbacks and further search the space simulated by remaining cuts for possible solutions e.g.
pipbacktracking strategy after pip .
.
however if unfortunately all dependency cuts are unsolvable even a perfect installer cannot find a solution for installation.
for example fig.
6gives dc issue forapi indotel corresponding to one cut only.
it is unsolvable for finding a solution of urllib3 because in its only dependency cut library request s introduced dependency i.e.
urllib3 .
.
.
is conflicting to the project s another direct dependency i.e.
urllib3 .
.
.
such dependency conjunction cannot be solved by any of the existing installers because for this project library urllib3 is always unsolvable for all situations during building as illustrated by the only cut .
we refer to such building failures separately and obtain the following symptoms.
symptom .
dc issues are unsolvable unless their associated version constraints are rewritten since all their corresponding dependency cuts are unsolvable a.k.a.
a failure .
symptom .
dc issues contain at least one unsolvable cut and resolving their building failures has to install fallback or backtracking a.k.a.
b failure .automatically resolving dependency conflict building failures via behavior consistent loosening esec fse december san francisco ca usa we observe that .
dc issues are unsolvable because all their dependency cuts are unsolvable and thus even a perfect installer cannot resolve such unavoidable building failures a failure .
besides .
dc issues contain at least one unsolvable cut and thus some existing installers without backtracking may result in building failures locally b failure .
we chose three representative installers piplegacy pipbacktracking and the state ofthe art smartpip .
we experimentally confirmed that none of them can build smoothly for the eight dc issues causing a failures because resolving such unsolvable dc issues requires rewriting declarations of version constraints among the python project and related libraries as echoed in existing work .
meanwhile for dc issues causing b failures piplegacy suffers from .
building failures while pipbacktracking and the state of the art smartpip can theoretically solve them all by allowing backtracking strategies or spending more search resources to maintain an upto date dependency database.
however in practice backtracking costs and database maintainence are non negligible.
for example pipbacktracking usually needs to retry times on average to obtain its eventual solution and may still result in building failure for complex scenarios when resources are limited .
finding none of existing efforts on improving installing strategies could resolve a failures while smart strategies with backtracking could resolve b failures with extra resources.
considering all unsolvable dependency cuts that cause either a failures or b failures we measure the number of library versions to loosen at least in order to connect associated version constraints of the concerned unsolvable cuts.
for example for the cut shown in fig.
there is only version redis .
.
to directly connect the two constraints i.e.
.
.
.
.
and .
.
.
we call thedistance i.e.
how far are the concerned version constraints connect to each other with the least expansions for this unsolvable cut being one.
we observe that among the unsolvable cuts cuts are with distance being one and can become solvable if one more version is allowed for version constraints e.g.
redis .
.
can be allowed if loosening .
.
.
.
to .
.
.
.
for cut in fig.
.
in our study cuts can become solvable with no more than five ten neighboured versions being loosened.
for example cut in fig.
6can become solvable if two neighboured versions are allowed for version constraints e.g.
constraint urllib3 .
being loosened to urllib3 .
.
.
finding loosening version constraints can be useful.
for unsolvable dependency cuts .
can become solvable by loosening one more adjacent version and .
.
can become solvable by loosening no more than five ten versions.
for the remaining dc issues that contain no unsolvable cuts we also observe that not all installers can smoothly install the root library due to their specialized installing strategies.
for example piplegacy strategy before .
would typically choose the latest version for the library that satisfies the concerned version constraints and conduct its installation following in a bfs alike order with guarantee upon a topological order only.
due to its specialized installing order we observe that it met building failures to those dc issues.
fortunately with extra resources allowedfor backtracking and knowledge base analyses pipbacktracking after .
and smartpip can build all these cases smoothly.
symptom .
dc issues contain no unsolvable cut.
still some installers may incur building failures due to their specialized installing strategies a.k.a.
c failure .
fortunately sota installers can resolve them smoothly.
by digging into the total of solvable dependency cuts associated with both b failures and c failures we observe that although solvable over dependency cuts are eventually with limited solutions no more than five acceptable versions which can leave threats for evolution.
for example as in fig.
there are only two acceptable solutions pyyaml .
.
and pyyaml .
.
for this solvable case.
more severely .
dependency cuts result in only one unique solution when solving the conjunction of the concerned version constraints.
this is mainly due to the involvement of a pinned version constraint e.g.
urllib3 .
.
which specifies one unique library version.
finding over solvable cuts can result in limited solutions in dependency solving leaving potential threats for evolution.
although limited solutions do not result in building failures at the moment it leaves potential threats for future evolution since any additional version constraint that may be introduced in the future can easily cause the unsolvable problem.
moreover among all unsolvable cuts there are over cuts involving at least one pinned version constraint and can result in extremely limited solutions only one acceptable library version .
therefore we can see that strict version constraints like the pinned ones can not only lead to unsolvable cuts but also limit solutions to solvable ones.
finding strict version constraints like pinned ones can lead to unsolvable or limited solutions in dependency solving and thus version constraint loosening can be desirable.
answering rq1 loosening version constraints especially pinned ones can be useful for both resolving dc building failures caused by unsolvable cuts and allowing more solutions for solvable cuts in dependency solving.
.
rq2 developing status and practice from fig.
we can see that the number of dependent libraries by a project ranges from several to hundreds and vary across projects over projects specify more than libraries in their dependency and around projects import more than libraries which may incur dependency conflict issues with high possibilities and libraries evolve quickly with versioning gaps of only several months for new versions with total versions on average.
these together put extreme pressures on developers to maintain suitable version constraints for importing third party libraries.
observation developers tend to import a large amount of thirdparty libraries and these libraries usually evolve quickly resulting in non trivial efforts on dependency maintenance.
from subject b we collect all written version constraints for those libraries from projects configuration scripts i.e.
a total of version constraints .
among all we observe that .
version constraints are pinned using to declare oneesec fse december san francisco ca usa wang et al.
api loc a loc and api between neighbored library versions 100alldirect b proportion for directed and all traced callings figure statistical data about library versioning or usage specific library version only .
such rates also hold consistently over concerning different scales of projects e.g.
1k 5k .
50k .
.
we conjecture that this may because in practice developers usually directly freeze and export their default execution environment during development into a default configuration script by pip freeze .
in this way default pinned version constraints can be generated and one can later restore this environment easily by pip install .
in this case as long as any upstream or downstream projects depend on the same library but require any other version unsolvable disasters leading to a failures and b failures as studied in rq1 would happen.
observation developers prefer to write strict version constraints and this can easily cause unsolvable cuts leading to both a and b failures.
as we studied in rq1 loosening might be optional for relaxing such strict version constraints as pinned ones to resolve dc building failures.
however loosening any version constraint safely needs to protect the project s behavior and it requires quite an effort for analyzing realizations for the concerned project and the library s all optional versions.
it can be tedious and somehow infeasible in practice to conduct a full analysis due to code scales.
we then dig into how libraries evolve and how developers call library apis in practice to facilitate a feasible loosening mechanism.
when investigating how each library evolves between its two neighbored versions we emphasize on those functions and lines of codes have been either modified or newly added a.k.a.
api and loc in the latter version are shown in fig.
.
we observe that after discarding the first version for each library versions evolve less than functions only and library versions evolve less than .
only versions evolve more than functions.
this denotes that during evolution libraries tend to evolve limited functions only.
we also investigate how projects usually invoke functions through apis from third party libraries.
for each projectlibrary pair in subject b a total of subjects concerning projects for third party libraries as aforementioned we dig into how the project invokes apis from its associated library in the collection.
typically one would use import or from import to import module s from libraries and then invoke apis whenever needed by developers in developing the project.
for each subject we recursively track all modules from its associated project that import the concerned library and then analyze how many apis functions from the library are truly invoked in the project clearly specified inthe project code and definitions successfully located in the library code .
for example project likyoo change detection.pytorch requires library albumentations with constraint .
.
.
we track apis directly invoked in the project and by manually inspecting their definitions in the library we can together track another inner functions indirectly called in this library which only occupies a minuscule portion of the library s functionalities with over functions supported in total .
similar observations hold in most of our subjects as shown in fig.
.
directly invoked apis usually take less than among all library functions and indirectly invoked ones may together increase the ratio to still no more than can be also analyzed by our looco later .
practice libraries typically evolve quickly but with very limited modifications and projects usually invoke only limited functionalities from libraries during development.
therefore we can see that upon practice and a feasible loosening mechanism to maintain the project s consistent behavior does not require a full analysis of the whole realization of both the project and library with candidate versions.
we only need to protect the library contexts that are truly used in the project thus motivating our loosening mechanism upon on demand call graphs starting from entrance apis.
answering rq2 only limited library functionalities participate in project development and this inspires one to potentially resolve dc building failures by loosening library versions with behaviorconsistency validation.
approach .
insight and overview to resolve dc building failures by loosening version constraints the kernel question is how to examine whether a project can behave consistently upon a new version v2of its dependent library l?
generally suppose a project depends on a library lwith an acceptable versionv1 base version to reuse library functionalities by a few l s apis.
we consider that if all called apis and any parts transitively called in the library have not been modified between v1andv2 the project should behave consistently in between.
thus looco can loosen the project s version constraint for ltov2.looco s workflow is shown in fig.
.
it would first scan the whole project to obtain all entrance apis for how project puses library lbased on a base versionv1 step and then tracking such entrance apis looco would trace the remaining library parts that are transitively called via constructing an on demand call graph step .
then looco would generate version diffs between v1andv2 step .
combining both version diffs and the constructed call graph looco can suggest to loosen version constraints to v2as long as they do not have any shared content suggesting that any library part in lthat are directly and transitively used by the project have not been evolved betweenv1andv2.
otherwise loosening is risky step .
.
step entrance api extraction this step aims to extract all project p s entrance apis for using libraryl.
typically to reuse library functionalities python projects can invoke the library apis by both long qualified names like img.img to graph t.img to graph np.reshape and shortenedautomatically resolving dependency conflict building failures via behavior consistent loosening esec fse december san francisco ca usa library version base calling snippet for library apis projectversion constraint call graph library version for examination version diffsv1 v2loosen constraint to v2?safe!risky!
v1step3 versioning diff generation step1 entrance api extraction step2 on demand cg constructionstep4 loosening analyses figure looco workflow ones like api name img to graph .
we model the entrance apis for the library no matter whether they are called by long or shortened api names to a consistent style of a fully qualified name a.b.c.api name which specifies the path module class and api name for any concerned library api.
therefore given project pand librarylwith base version v1 this step tries to exact entrance apis with fully qualified names to exhibit l s functionality used by p. considering that developers may follow diverse ways to import library looco adopts a two phase exaction mechanism extractfirst localize next for obtaining such entrance apis.
first looco adopted and refined an existing tool dlocator to extract all l s apis that have been called in the project code.
note that we addressed dlocator s limitations which can lead to unexpected entrance apis being missed during its extraction e.g.
failing in processing the import cases and ignoring apis called by noncall ast nodes.
note that solely scanning the project code may not precisely exact library apis and obtain the corresponding fully qualified names since the library codes are invisible now.
therefore in this phase looco aims to exact all possible entrance apis forlthat may be called by the project and aim to exact entrance apis conservatively first.
second to avoid possible mistakes in api extraction looco then conducts a localization phase to localize the realization body of any exacted library api in the last phase by scanning library l s code of base version v1.
this manages to filter out any mistakenly extracted calls for library apis and assign the expected fully qualified api names for all successfully filtered ones.
as such looco now exacts a set of entrance apis for library l concerning its api usage in project p i.e.
sa api0 api ... apin each of which specifies a specific api apiiinl with its fully qualified name being called by p. .
step on demand cg construction this step aims to construct a call graph slicing from the entrance apis obtained in the last step.
considering the set of entrance apis being extracted to be sa api0 api ... apin looco would track each entrance api in l sv1to slice all internal parts e.g.
function method class etc.
transitively called by project p. to obtain such looco would not need to construct a full call graph for library l but only a partial one that called from the obtained entrance apis in sa.
considering our observations in empirical study i.e.
limited l s apis are normally called by projects we can expect that such an on demand call graph would be much easier and feasible in practice.
therefore to slice a call trace including possible concerned library functions class methods and classes themselves indicating constructors called looco analyzes each obtained entrance apis transitively and thus composes anon demand call graph by merging all call traces for these obtained entrance apis.
since looco aims to loosen p s version constraints forl we consider capturing the possible calls in the sliced call trace forl s directly dependent library as well.
therefore for each sliced node in the call trace we logged a tuple of its necessary information including node name caller callee and dependency location.
for example for a inner called node function f method m classc that is called and realized by litself looco would collect f m c f2 a.b.c.f m c l representing f m cis called byf2and realized by library lina.b.c.f m c. for a outer called node f m c f2 l2 represents that f m cis called by f2and realized byl s dependent library l2 with realization unknown.
to do so looco refines code2flow to analyze possible calls traced from the obtained entrance apis in step by tracking all possible calls in the ast structure with an additional definitionmapped domain supported.
as a result looco s call graph analyses can exhibit comparable performance to the state of the art python analyzer pycg which would be further discussed in section .
.
step versioning diff generation this step is to construct the differences for library l s realization between its base version v1 and the version to loosen v2 .
we consider the contents of both l s code and configuration scripts.
concerning the difference of l s code looco comparesl sv1realization tov2by constructing code diffs with the aid of filecmp and difflib and records the full names of functions methods classes that are defined in v1 but modified except modifying comments only or deleted in v2.
this would produce a list of all modified components function method class during l s evolving from v1 tov2 namely diffcode f1 m2 c3 .
concerning the difference ofl s configuration looco comparesl s configuration scripts betweenv1tov2and obtained a list of l s dependent libraries whose dependencies have been modified during l s evolution from v1tov2 either deleted or modified with a new version constraint difflib.
.
step loosening analyses this step would analyze the on demand call graph obtained in step and versioning diffs diffcode anddifflib obtained in step to examine whether p s dependency on lcan be further loosened tov2.looco would suggest to loosen as long as all nodes in constructed call graph satisfy conditions if the node associates to an outer call ffrom an indirectly dependent library l2 l2must not be contained in difflib if the node associates to an inner call ffrom the library lunder examination fmust not be contained indiffcode.
otherwise looco would not suggest loosening p s dependency on ltov2.
note that looco works with its behindesec fse december san francisco ca usa wang et al.
insight of only loosening p s dependency on ltov2as long as all p s called parts in lhave not been modified.
however we do admit that even some modifications i.e.
equivalent code changing for these parts may not affect p s behaviors as well when using l s new version.
for safety we leave looco as such in a conservative way to facilitate its feasibility and automation at the same time.
.6looco realization and application looco is proposed to solve the kernel question for examining whether the analyzed python project can behave consistently upon its dependent library lwith a new version v2 a.k.a.
safe for looseningv2.
in practice suppose the project pand any of its imported libraryldeclared in the configuration script.
considering different types of version constraints originally written by developers looco can be applied as follows.
for the pinned constraint which specifies one concrete version only e.g.
l v0 looco can treatv0as the base version and examine any l s accessible versions recommend to start forward and backward from v0 in the market for possible loosening.
for the constrained one which may give a range of acceptable versions e.g.
v1 l v2 looco can choose any acceptable version satisfying the original constraint e.g.
v3 whenv1 v3 v2 as the base version and any version can be loosened as long as looco believes safe for loosening suggesting the project s consistent behavior between v1andv2.
by so upon the project s existing configuration script looco can examine all accessible library versions that are not included originally and loosen version constraints automatically as relaxed as possible.
after that looco would suggest revising the configuration script with concrete suggestions with loosened versions for any specific library.
moreover due to looco s superiority on tracking the project s called apis for each library e.g.
l looco additionally suggests removing some original version constraints if none ofl s apis is called in p i.e.
sa .
evaluation .
experimental preparation .
.
research questions.
we raised the following two research questions to evaluate looco s performance on loosening version constraints and resolving dc building failures.
rq3 loosening performance can looco effectively loosen version constraints for python projects imported libraries?
how efficiently can this be done?
rq4 resolving usefulness how useful is looco for resolving dc building failures by its automatic constraint loosening?
.
.
design and setup.
for rq3 to evaluate looco s performance on loosening version constraints for projects when importing third party libraries we use subject b in section which contains open projects for the collected third party libraries thus project library pairs for experiments with a version constraint written by developers originally.
for each pair we use looco to loosen the project s concerned version constraint upon the associate library as possible.
we evaluate looco s effectiveness by measuring the number of new library versions looco can loosen and use the consistency of behavior between the loosened version and the original version on test cases to validate the correctnesstable loosen levels of looco s results level l0 l1 l2 l3 pinned .
.
.
.
constrained .
.
.
.
all .
.
.
.
oflooco s loosening.
and we evaluate looco s efficiency by the time cost when applying looco to examine whether a project s version constraint can be loosened to a certain library version.
for rq4 to evaluate looco s loosening usefulness on resolving dc building failures we use subject a in section containing realworld dc issues with dependency cuts three removed due to only one version constraint for the root library representing dependency among all practical building possibilities.
by similarly applying looco to loosen each issue s related version constraints we examine whether and how the concerned dc building failures are resolved and thus evaluate looco s usefulness.
.
.
configuration.
all experiments were conducted on a server with two core intel r xeon r gold cpu .30ghz and 503gb ram installed with ubuntu .
.
lts and python .
.
.
rq3 loosening performance we evaluate looco s loosening effectiveness by measuring how many versions can be loosened for each project concerning the associated library in the pairs.
then we validate looco s loosening results by combining both test suite validation and developers feedbacks.
finally we measure looco s time overhead.
.
.
loosening results.
for the studied project library pairs we first measured how many new versions can be further loosened when applying looco to investigate its loosening effectiveness.
by classifying looco s loosen effectiveness by the number of loosened versions we design four levels with increasing numbers of loosened versions i.e.
l0 no new version loosened l1 versions loosened l2 versions loosened and l3 over versions loosened .
as shown in table looco successfully loosened version constraints for .
projects imported libraries with versions loosened l1 for .
projects versions loosened l2 for .
projects and over versions loosened l3 for .
projects with .
loosened versions on average.
.
.
loosening validation.
to validate looco s loosening results we filtered out pairs among all collected project library pairs with the following requirements the associated project is provided with built in test suites e.g.
pytest built in test suites can work smoothly under the original dependency configuration and work inconsistently when uninstalling the associated library thus covering necessary functionality for testing this library dependency looco suggests loosening new library versions.
for collected pairs the average test code coverage of those obtained projects test suites is .
min max .
then for each filtered project library pair we ran test suites under both library versions satisfying its original configuration and installing looco s suggested versions.
we examined whether test suites produce consistent behaviors between such two executions.
among all looco in total suggests loosening existing version constraints for newautomatically resolving dependency conflict building failures via behavior consistent loosening esec fse december san francisco ca usa library versions and test suites behave completely consistently for .
library versions.
the only exceptions are pair i.e.
project serverlesschaliceplatform upon library chalice and i.e.
project mlcomp upon library albumentations .
we dig a little deeper and find out that both their inconsistency behaviors under test are due to the conflict between looco s suggested versions and our local experimental environment i.e.
pytest and python .
.
after neglecting such conflicts and installing looco s suggested versions forcibly consistency behaviors remain hold.
.
.
feedback on looco.
we sent looco s suggestions to developers with loosened versions.
until aug we randomly sent over reports and received responses from developers covering project library pairs .
among these responses we achieved encouraging feedback with details on our website .
developers .
have confirmed looco s loosening plans and most developers have already refined their dependency following looco s suggestions either asking us for pull requests with merged already or resolving themselves exactly following looco s suggestions.
we also received valuable responses from developers.
developers do admit that they typically use pip freeze for convenience and may lack sufficient dependency analyses e.g.
using strict version dependency does seem like a mistake or rather something i overlooked while using pip freeze.
loosening is a good idea.
in report .
they indeed appreciate looco s loosening suggestions e.g.
thanks for the suggestion about the automatic tool for dependency analysis.
i appreciate the thought .
.
.
we don t have anything like that in place.
in report pr always welcome and really sorry that i just notice this issue.
in report and you re right.
i tested slips with redis .
.
and it s working fine.
in report .
.
.
overhead.
we also measured the time cost when applying looco to loosen a project s version constraint for a certain library.
on average looco spent .4s min .04ms max 54s to make its examination per candidate version to loosen.
despite of looco s analyses locs of each project library pair also affect the final time cost e.g.
the loc of the project in pair is about .7m somehow explaining its relatively large time overhead 54s .
considering the varying scales i.e.
project avg loc 12k max loc 5m library avg loc 8k max loc 104k we believe looco is efficient with nice scalability owing to its on demand cg analyses.
answering rq3 looco can loosen version constraints for python projects imported libraries effectively avg .
versions expanded and efficiently .4s overhead per loosening .
we received encouraging feedback .
confirmed in responses from developers.
.
rq4 resolving usefulness .
.
loosening constraints upon dependency cuts.
to investigate how looco s constraint loosening can help resolve dc building failures in practice.
we use subject a introduced in section containing real world dc issues with dependency cuts for building.
for each dependency cut looco is conducted to loosen version constraints accordingly.
table 2illustrates looco s results.for the dependency cuts that are originally unsolvable looco can effectively loosen version constraints for cuts .
besides those gray ones .
among all unsolvable cuts .
cuts can become solvable r1 and .
cuts although still unsolvable can bring closer distances for solving the conjunctions in dependency r2 .
for example concerning the unsolvable cut for issue as shown in fig.
looco would perform its analyses to both loosen project rdfframework s dependency on elasticsearch and also elasticsearch dsl s dependency on library elasticsearch .
as a result the former one would be loosened from .
.
to .
.
.
.
and the latter one would be loosened from .
.
.
.
to .
.
.
.
thus solvable.
this is tagged as c6 rdfframework in table .
for the remaining dependency cuts that are solvable originally looco effectively loosens version constraints for cuts .
.
among all solvable cuts looco s loosening brings new solutions for cuts .
with more solutions on average r4 .
for example concerning the solvable cut for issue as shown in fig.
as a result fly circus s dependency on pyyaml would be loosened from .
.
.
.
to .
.
.
.
therefore four more solutions can be obtained for dependency solving i.e.
from pyyaml .
to5.
.
.
this case is also tagged as c2 ssmash in table .
therefore we can observe that looco s loosening can effectively resolve unsolvable cuts to become solvable and bring more solutions to the solvable ones.
.
.
resolving dc building failures.
note that when all associated dependency cuts are unsolvable none of the existing optimizations on installing strategies can help and they would all suffer from severe building failures as studied in section .
this relates to dc issues with none solvable cut a.k.a.
causing a failures .
looco can successfully resolve of them by achieving at least one solvable cut now.
in this way state of the art installers like smartpip can now build them smoothly.
for the dc issues that contain at least one unsolvable cut a.k.a.
causing bfailures looco can resolve of them from being unsolvable anymore and alleviate the remaining by either letting any of its unsolvable cut with a closer distance or solvable cuts with more solutions avg more solutions .
for the remaining dc issues although with all solvable ones initially but may still fail under some specific installing strategies likepiplegacy a.k.a.
c failures looco can alleviate .
of them by making their associated cuts with more solutions avg more solutions and thus letting any accompanied installing strategy to find a possible solution much easier.
by comparing looco s suggestions with reports sent by watchman we observe thatlooco suggests similarly as watchman with concrete suggestions of loosened version constraints for cases .
among cases that have been confirmed and resolved by developers.
there are cases when looco s suggestions are precisely the same as the developers true resolutions supporting looco s usefulness on resolving dc building failures.
answering rq4 looco can effectively resolve .
unsolvable cases to be solvable and allow more solutions on average for solvable cases thus successfully resolving dc building failures unsolvable cases resolved for a failures and b failures and solutions expanded for b failures and .
c failures .esec fse december san francisco ca usa wang et al.
table loosening effectiveness upon dependency cuts for looco with comparisons loosening results for all dependency cuts with the name shortened to save space unsolvable cuts c2 runcible c1 cert issu c1 whats bot c1 coinmarke c1 coco styl c1 api indot c3 jawfish c4 jawfish c5 jawfish c6 jawfish c7 jawfish c8 jawfish c1 django cu c7 django cu c8 django cu c6 rdfframew c2 django te c3 django te c4 django te c5 django te c6 django te c7 django te c8 django te c9 django te c10 django te c11 django te c1 reana clu c1 osmedeus c3 dork c4 dork c5 dork c6 dork c2 scriptax c3 grimoirel c13 transifex c14 transifex c15 transifex c3 docker cr c4 docker cr c2 django we c3 cert mail c4 cert mail c6 agora wot c3 trio c4 trio c5 trio c1 discord w c4 imgsync c5 imgsync c3 rdfframew c7 rdfframew c2 textx lan c3 textx lan c1 django gl c4 django gl c1 django gl c4 django gl c2 crema c3 crema c1 zarp c2 ltiauthen c4 rdfframew c7 mockerena c8 mockerena c9 mockerena c10 mockerena c3 superdesk c2 zelt c1 imgsync c6 imgsync c3 django gl c2 django gl c3 django gl c5 django gl c6 django gl c2 django gl c3 django gl c5 django gl c6 django gl c3 agora wot c5 agora wot c2 piicatche c3 piicatche c4 piicatchesolvable cuts c1 aucome c2 aucome c1 kindred c1 crypto wh c1 orcasong c2 pypmml sp c3 pypmml sp c4 pypmml sp c5 pypmml sp c1 twitterbo c1 awsbucket c1 unblock y c1 auto craw c1 runcible c1 crema c1 hidden fr c1 jawfish c2 jawfish c1 dedis clu c6 django cu c1 flask mon c2 flask mon c1 program y c1 python bi c2 python bi c3 python bi c4 python bi c5 python bi c6 python bi c1 py redis c1 rdfframew c2 rdfframew c5 rdfframew c1 gmssl c1 target da c2 target da c1 django te c1 textx lan c1 twitter m c1 mockerena c6 mockerena c1 nornir c2 reana clu c1 spartacus c2 spartacus c1 ssmash c2 ssmash c1 tmo4ct c2 tmo4ct c1 bakerydem c2 bakerydem c3 bakerydem c4 bakerydem c5 bakerydem c6 bakerydem c1 dork c2 dork c1 pymacaron c2 pymacaron c1 scriptax c1 1a23 tele c2 1a23 tele c3 1a23 tele c4 1a23 tele c5 1a23 tele c6 1a23 tele c1 transifex c2 transifex c3 transifex c4 transifex c5 transifex c6 transifex c7 transifex c8 transifex c9 transifex c10 transifex c11 transifex c12 transifex c16 transifex c17 transifex c18 transifex c1 fossor c1 video fun c2 video fun c3 video fun c4 video fun c1 superdesk c1 docker cr c2 docker cr c1 djangoplu c1 django we c1 cert mail c2 cert mail c1 antinex u c1 superdesk c2 superdesk c1 trio c2 trio c1 incubator c1 indy node c1 ltiauthen c2 dedis clu c3 dedis clu c4 dedis clu c5 dedis clu c2 django cu c3 django cu c4 django cu c5 django cu c2 mockerena c3 mockerena c4 mockerena c5 mockerena c2 nornir c3 nornir c1 grimoirel c2 grimoirel c1 tensor2te c2 superdesk c1 molo.surv c2 incubator c1 zelt c1 zvt c2 zvt c3 zvt c1 django el c2 django el c3 django el c4 django el c5 django el c6 django el c3 aucome c2 orcasong c3 orcasong c4 orcasong c5 orcasong c6 orcasong c1 pypmml sp c1 toolium c2 toolium c3 toolium c4 toolium c5 toolium c6 toolium c7 toolium c8 toolium c9 toolium c10 toolium c11 toolium c12 toolium c1 wavesgate c2 wavesgate c1 scrapyred c2 scrapyred c3 scrapyred c4 scrapyred c5 scrapyred c2 imgsync c3 imgsync c1 iprange p c2 iprange p c3 iprange p c4 iprange p c5 iprange p c1 musco tf c2 musco tf c1 musco pyt c2 musco pyt c1 pyclics c c2 pyclics c c3 pyclics c c7 python bi c2 py redis c3 py redis c4 py redis c5 py redis c6 py redis c1 scvelo c2 scvelo c3 scvelo c4 scvelo c5 scvelo c1 sockeye c1 django gl c2 django gl c3 spartacus c4 spartacus c5 spartacus c6 spartacus c7 spartacus c1 xontrib r c5 video fun c1 agora py c1 agora wot c2 agora wot c4 agora wot c1 aiocontex c1 django cl c2 django cl c3 django cl c1 piicatche r1 loosening with new solutions for the unsolvable cuts r2 loosening but still with no solution for the unsolvable cuts closer distance r3 loosening but still with no solution for the unsolvable cuts same distance r4 loosening with new solutions for the solvable cuts r5 loosening but without new solution for the solvable cuts r6 no loosening by looco.
threat analyses and discussion threat analyses.
the subject selection for dc issues and open projects may threaten the validity of our empirical study.
to alleviate this threat for dc issues we leveraged dc issues collected and studied in the prior studies and manually ensured their reproducibility for nice data quality.
for open projects we select libraries with high popularities top stars on github multiple dependent projects avg dependent projects and varying program scales for both projects and libraries to be representative.
limitations of static analyses.
impreciseness in static analyses may also threaten the validity of looco e.g.
unsupported language features and complex python semantics.
therefore some analyzed calls for third party libraries may be missed during api entrances and cg tracking in looco.
this is a widely admit challenge for static analysis research not our focus in this paper .
we try to alleviate this by optimizing our static analyzer in looco for comparable performance to the state of the art tool pycg we do not directly use it since it does not support on demand cg construction and occasionally run into exceptions when analyzing large programs .
we compare looco s constructed call graphs with those generated by pycg upon its released benchmark where we achieve a .
precision and .
recall comparable to pycg precision .
recall .
.
still we admit that such limitations of static analyses may bring both false positives negatives to ouranalyses and this should be further investigated in the future to better show and improve the safety of looco s loosening.
looco s application.
in this work we use looco to analyze a project s directly dependent library for possible version loosening.
therefore it is possible that some outer calls are basically equivalent even version constraints for some indirectly dependent library change.
however since this would add obvious stresses to looco s analyses for simplicity we do not perform looco s analyses iteratively for outer calls in the analyzed library.
in practice one may choose to perform looco s loosening analyses with the control of certain depths for its loosening analyses along the dependency tree.
moreover due to the request of constructing call graphs looco is suitable when both source codes for projects and libraries are available at the moment.
we are working on adapting looco for analyzing third party libraries with binary releases only.
semver comparison.
semantic versioning semver uses structured versioning schemes major.minor.patch to suggest loosening plans for developers which is similar to our approach.
we discuss their differences from two aspects.
first in order to loosen semver indeed relies on developers to first follow certain specifications in versioning during the development which can hardly hold in practice.
in existing work around libraries are observed to violate semver specifications in some all versions thus unreliable to obtain compatible versions for loosening directly in this way.
when we attempt to loosen the studied projectsautomatically resolving dependency conflict building failures via behavior consistent loosening esec fse december san francisco ca usa with built in test suites as aforementioned following semver we observed that loosening using semver suggests versions with obviously inconsistent behaviors for .
projects exhibiting its unreliable loosening.
second since semver normally suggests loosening version constraints to new versions with consistent major or greater minor numbers this can be quite general and not sensitive with respect to each dependent project possibly too strict.
owing to looco s project aware analyses our loosening plan can be more delicate and relaxed with higher possibilities for loosening.
for example in our evaluation looco can loosen an original version constraint telepot .
for pair to versions a smaller version of minor e.g.
telepot .
or to versions with different major numbers e.g.
telepot .
and .
.
related work software ecosystem and library versioning.
third party libraries and sheets contribute to code and data reuse in developing intelligent and evolving software .
in practice projects co evolve with each other based on their intra dependencies in software ecosystems and many existing work studied these dependencies.
kula et al.
investigated dependency migrations for java and observed severe outdated dependency problems .
latendresse et al.
studied the differences between installed dependencies and production dependencies in javascript projects and suggested that production dependencies should be given a higher priority.
hejderup et al.
constructed an exhaustive dependency cg for the ecosystem.
zhang et al.
studied api compatibility issues by analyzing the characteristics of python api usages.
xing et al.
and johannes et al.
emphasized on avoiding api usage issues like api breaking changes and eric focused on api breaking changes by identifying problematic codes during versioning.
jia et al.
proposed depowl to avoid incompatible library versions e.g.
with backward or forward incompatible changes e.g.
removing or adding an interface .
ma et al.
focused on cross project bugs in the ecosystem and how they affect downstream and upstream projects.
wu et al.
studied potential threats of upstream vulnerabilities to downstream projects in the maven ecosystem by a fine grained analysis of calls from downstream projects to upstream projects.
dependency inference and conflict resolution.
towards inferring dependencies for python projects ye et al.
proposed pyego to construct knowledge graphs and inference environment dependency for python projects.
similarly pycre infers more exhaustively by analyzing the runtime environment via domain knowledge graphs.
based on inferred dependencies different strategies target resolving potentially conflicting issues.
wang et al.
detected typical patterns of dc issues in pypi ecosystem and artho et al.
conducted an empirical study on conflict defects and made recommendations for prevention and detection.
jafari et al.
surveyed a classification of dependency smells in javascript and proposed dependencysniffer for detecting dependency smells.
cao et al.
investigated three types of dependency smells in python projects i.e.
missing dependency bloated dependency and version constraint inconsistency and proposed pycd to extract such dependencies respectively.
maven leverages its package managementfor the java ecosystem by a nearest win strategy to resolve dependency for dc issues which is also studied by foo et al.
for resolution via an efficient static checking.
pip optimized its dependency solving strategy with backtracking and smartpip further optimizes it with a powerful strategy with controllable costs.
in addition some dc issues are due to conflicts with existing local dependencies in which case they can be solved by having the project use a separate python environment .
different from existing work that sticks to original version constraints we choose to automatically refine them for better quality to resolve dc building failures.
therefore we believe that looco can be a great complement to existing work with its refined version constraints.
static analyses for python projects.
looco constructs call graphs for python projects.
despite python popularities there are only a few python static analyzers .
pyan parses asts to extract python projects call graphs but faces drawbacks for inter procedural flows of values and module imports later optimized with visualization in code2graph .
depends obtains syntactical relations among source entities to generate call graphs more precisely but does not support higher order programming.
the state of the art pycg performs the best but does not support on demand call graph generation.
we realizes looco s static analyses with comparable performance to it.
conclusion python projects commonly suffer dc issues and thus incurred building failures.
in this paper we have proposed a constraint refinement approach looco to automatically loosen version constraints for dependent libraries assisting in resolving building failures without sacrificing libraries behavioral consistency.
the approach was inspired by our empirical findings from real world dc issues and characteristics of their associated library version constraints and exhibited promising performance by effective loosening avg.
.
versions expanded and efficient execution .4s overhead per loosening .
such automatic constraint loosening contributed to significant resolution of dc building failures by transforming .
originally unsolvable cases into solvable ones and producing more solutions more on average for original solvable cases.
nevertheless looco is currently still restricted by syntactic consistency in its code analysis conservative in expanding versions and we plan to extend its capability by exploring potential semantic consistency finding further loosening space in future.
data availability the source code of looco and other resources are available on .
acknowledgement the authors would like to thank the anonymous reviewers for their insightful comments and suggestions.
this work was supported by the natural science foundation of china under grant no.
and the natural science foundation of jiangsu province under grants no.
bk20202001 and bk20220771 .
the authors would also like to thank the support from the fundamental research funds for the central universities of china and and collaborative innovation center of novel software technology and industrialization jiangsu china.esec fse december san francisco ca usa wang et al.