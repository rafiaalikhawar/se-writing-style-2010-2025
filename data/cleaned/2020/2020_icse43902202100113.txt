interface compliance of inline assembly automatically check patch and refine fr d ric recoules univ.
paris saclay cea list saclay france frederic.recoules cea.fr matthieu lemerre univ.
paris saclay cea list saclay france matthieu.lemerre cea.frs bastien bardin univ.
paris saclay cea list saclay france sebastien.bardin cea.fr laurent mounier univ.
grenoble alpes verimag grenoble france laurent.mounier univ grenoble alpes.frrichard bonichon tweag i o paris france richard.bonichon gmail.com marie laure potet univ.
grenoble alpes verimag grenoble france marie laure.potet univ grenoble alpes.fr abstract inline assembly is still a common practice in lowlevel c programming typically for efficiency reasons or for accessing specific hardware resources.
such embedded assembly codes in the gnu syntax supported by major compilers such as gcc clang and icc have an interface specifying how the assembly codes interact with the c environment.
for simplicity reasons the compiler treats gnu inline assembly codes as blackboxes and relies only on their interface to correctly glue them into the compiled c code.
therefore the adequacy between the assembly chunk and its interface named compliance is of primary importance as such compliance issues can lead to subtle and hard to find bugs.
we propose rusti na the first automated technique for formally checking inline assembly compliance with the extra ability to propose proven patches and optimization refinements in certain cases.
rusti na is based on an original formalization of the inline assembly compliance problem together with novel dedicated algorithms.
our prototype has been evaluated on debian packages with inline assembly chunks finding issues in packages significant issues in packages including major projects such as ffmpeg or alsa and proposing patches for of them.
currently patches have already been accepted solving significant issues with positive feedback from development teams.
i. i ntroduction context.
inline assembly i.e.
embedding assembly code inside a higher level host language is still a common practice in lowlevel c c programming for efficiency reasons or for accessing specific hardware resources it is typically widespread in resource sensitive areas such as cryptography multimedia drivers system automated trading or video games .
recoules et al.
estimate that of debian packages written in c c directly or indirectly depend on inline assembly including major projects such as gmp or ffmpeg while of the top rated c projects on github contain inline assembly according to rigger et al.
.
thus compilers supply a syntax to embed assembly instructions in the source program.
the most widespread is thegnu inline assembly syntax driven by gcc but also supported by clang or icc.
the gnu syntax provides an interface specifying how the assembly code interacts withthe c environment.
the compiler then treats gnu inline assembly codes as blackboxes and relies only on this interface to correctly insert them into the compiled c code1.
problem.
the problem with gnu inline assembly is twofold.
first it is hard to write correctly2 inline assembly syntax is not beginner friendly the language itself is neither standardized nor fully described and some corner cases are defined by gcc implementation with occasional changes from time to time .
second assembly chunks are treated as blackboxes so that the compiler does not do any sanity checks3andassumes the embedded assembly code respects its declared interface.
hence in addition to usual functional bugs in the assembly instructions themselves inline assembly is also prone tointerface compliance bugs i.e.
mismatches between the declared interface and the real behavior of the assembly chunk which can lead to subtle and hard to find bugs typically incorrect results or crashes due to either subsequent compiler optimizations or ill chosen register allocation.
in the end compliance issues can lead to severe bugs segfault deadlocks etc.
and as they depend on low level compiler choices they are hard to identify and can hide for years before being triggered by a compiler update.
for example a compliance bug introduced in the libatomic obs library of lock free primitives for multithreading made deadlocks possible it was identified and patched only in commit 03e48c1 .
a similar bug was still lurking in another primitive in until we automatically found and patched it commit 05812c2 .
we also found a interface compliance bug in glibc leading to asegfault in a string primitive that was patched in commit 7c97add then reintroduced in after refactoring.
goal and challenges.
we address the challenge of helping developers write safer inline assembly code by designing and 1microsoft inline assembly is different and has no interface see sec.
ix c. 2from the llvm dev mailing list gcc style inline assembly is notoriously hard to write correctly .
3note that syntactically incorrect assembly instructions are caught during the translation from assembly to machine code.
ieee acm 43rd international conference on software engineering icse .
ieee developing automated techniques helping to achieve interface compliance i.e.
ensuring that both the assembly template and its interface are consistent with each other .
this is challenging for several reasons define the method must be built on a currently missing proper formalization of interface compliance both realistic and amenable to automated formal verification check patch refine the method must be able to check whether an assembly chunk complies with its interface but ideally it should also be able to automatically suggest patches for bugs or code refinements wide applicability the method must be generic enough to encompass several architectures at least x86 and arm.
fehnker et al.
published the only attempt we know of to inspect the interface written by the developer.
yet their definition of interface compliance is syntactic and incomplete for example they cannot detect the glibc issue mentioned above.
moreover they do not cover all subtleties of gcc inline assembly e.g.
token constraints consider only compliance checking neither patching nor refinement and the implementation is tightly bound to arm much simpler than x86 .
note that recent attempts for verifying codes mixing c and assembly simply assume interface compliance.
proposal and contributions.
we propose rusti na the first sound technique for comprehensive automated interface compliance checking automated patch synthesis and interface refinements.
we claim the following contributions a novel semantic andcomprehensive formalization of the problem of interface compliance sec.
iv amenable to formal verification a new semantic method sec.
v to automatically verify the compliance of inline assembly chunks to generate a corrective patch for the majority of compliance issues and additionally to suggest interface refinements thorough experiments sec.
vii of a prototype implementation sec.
vi on a large set of x86 real world examples all inline assembly found in a debian linux distribution demonstrate that rusti na is able to automatically check and curate a large code base packages assembly chunks in a few minutes detecting issues and solving of them a study of current inline assembly coding practices sec.
viii besides identifying the common compliance issues found in the wild sec.
vii a we also exhibit recurring patterns leading to the vast majority of compliance issues and show that of them rely on fragile assumptions and can lead to serious bugs sec.
viii .
as the time of writing patches have already been accepted by projects solving significant issues sec.
vii c .
summary.
inline assembly is a delicate practice.
rusti na aids developers in achieving interface compliant inline assembly code.
compliant assembly chunks can still be buggy but rusti naautomatically removes a whole class of problems.our technique has already helped several renowned projects fix code with positive feedback from developers.
note supplementary material including prototype and benchmark data is available online .
ii.
c ontext and motivation the code in fig.
is an extract from libatomic obs commit 30cea1b dating back to early .
it was replaced months later by commit 64d81cd because it led to a segmentation fault when compiled with clang.
by another latent bug was still lurking until automatically discovered and patched by our prototype rusti na commit 05812c2 .
179ao inline int 180ao compare double and swap double full volatile ao double t addr ao t old val1 ao t old val2 ao t new val1 ao t new val2 charresult asm volatile xchg ebx swap got ptr and new val1 lock cmpxchg8b setz xchg ebx restore ebx and edi m addr a result m addr d old val2 a old val1 c new val2 d new val1 memory return int result figure atomic ops sysdeps gcc x86.h 30cea1b what the code is about.
this function uses inline assembly to implement the standard atomic primitive compare and swap i.e.
write new val in addr if this latter still equals toold val where byte values old val andnew val are split in byte values old val1 old val2 etc.
.
the assembly statement syntax discussed in sec.
iii comprises assembly instructions e.g.
lock cmpxchg8b building an assembly template where some operands have been replaced by tokens e.g.
that will be latter assigned by the compiler.
it also has a specification the interface binding together assembly registers tokens and c expressions line declares the outputs i.e.
c values expected to be assigned by the chunk lines and declare the inputs i.e.
c values the compiler should pass to the chunk.
the string placed before a c expression is called a constraint and indicates the set of possible assembly operands this expression can be bound to by the compiler.
for instance d old val2 indicates that register edx should be initialized with the value ofold val2 while a result indicates the value ofresult should be collected from eax .
token introduced by m addr is an indirect memory access its address arbitrarily denoted 0here can be bound to several possibilities cf.
fig.
including esi or ebx .
fig.
gives the functional meaning of this binding along with the semantics of the assembly instructions where is the concatenation c a conditional assignment efh lg the bits extraction and zextn the zero extension to size n .
this example allows us to introduce the concept of interface compliance issues and the associated miscompilation problems a framing condition incomplete interfaces possibly z edx eax edx eax z ecx ebx 2 eax eaxf31 8g zext8z ebx edi result eaxf7 0g ebx edi edi new val1 ecx new val2 eax old val1 edx old val2 0addr cmpxchg8b 0xchg ebx edi lock setz al xchg ebx edi a result d new val1 c new val2 a old val1 d old val2 m addr figure assembly statement semantics leading to miscompilations due to wrong data dependencies b unicity ambiguous interfaces where the result depends on compiler choices for token allocation.
a an incomplete frame definition.
here register edx is declared as read only by default non output locations are whereas it is overwritten by instruction cmpxchg8b c.f.
fig.
.
edx should be declared as output as well.
impact the compiler exclusively relies on the interface to know the framing condition i.e.
which locations are read or written.
when this information is incomplete data dependencies are miscalculated potentially leading to incorrect optimizations.
here the compiler believes edx still contains old val2 after the assembly chunk is executed while it is not the case.
note that ebx and esi arenotmissing the output attribute while overwritten by the xchg instructions they are then restored to their initial value.
b ambiguous interface.
here while most of the binding is fixed the compiler still has to bind 0according to constraint m .
yet if the compiler rightfully chooses ebx the data dependencies in the assembly itself differ from the expected one pointer addr is exchanged with new val1 just before being dereferenced which is not the expected behaviour.
the problem here is that the result cannot be predicted as it depends on token resolution from the compiler.
impact the function is likely to end up in a segmentation fault when compiled by clang.
historically gcc was not able to select ebx and the bug did not manifest but clang did not had such restriction.
the problem.
these compliance issues are really hard to find out either manually or syntactically.
first there is here clearly no hint from the assembly template itself cmpxchg8b that register edx is modified.
second complex token binding and aliasing constraints must be taken into account.
third subtle data flows must be taken into account for example a read only value modified then restored is not a compliance issue.
rusti na insights.
to circumvent these problems we have developed rusti na an automated tool to check inline assembly compliance i.e.
formally verifying the absence of compliance errors and to patch the identified issues.rusti na builds upon an original formalization of the inline assembly interface compliance problem encompassing both framing and unicity .
from that our method lifts binarylevel intermediate representation sketched in fig.
and adapt the classical data flow analysis framework kill gen in order to achieve sound interface compliance verification especially rusti na reasons about token assignments.
from the expected interface it infers for each token an overapproximation of the set of valid locations and then computes the set of locations that shall not be altered before the token is used.
here it deduces that writing in register ebx may impact token .
also it detects that a write occurs in the read only register edx thus successfully reporting the two issues.
moreover rusti na automatically suggests patches for the two issues.
for framing fig.
highlights the core differences between the two versions edx is now rightfully declared as output with d a similar patch now lives on the current version of the function commit 05812c2 .
for unicity it suggests to declare ebx as clobber yielding a working fix.
yet it also over constrains the interface the syntax does not allow a simple disequality between 0and ebx .
developers actually patched the issue in in a completely different way by rewriting the assembly template commit 64d81cd such a solution is out of rusti na s scope.
asm volatile xchg ebx swap got ptr and new val1 ao t dummy asm volatile xchg ebx swap got ptr and new val1 lock cmpxchg8b setz xchg ebx restore ebx and edi m addr a result m addr d old val2 a old val1 xchg ebx restore ebx and edi m addr a result d dummy m addr old val2 a old val1 figure frame write corrective patch generic and automatic our approach is well suited to handle what expert developers failed to detect while a simpler bad patterns detection approach would struggle against both the combinatorial complexity induced by the size of architecture instruction sets and the underlying reasoning complexity dataflow token assignments .
overall rusti na found and patched many other significant issues in several well known open source projects sec.
vii .
iii.
gnu inline assembly syntax overview.
this feature allows the insertion of assembly instructions anywhere in the code without the need to call an externally defined function.
fig.
shows the concrete syntax of an inline assembly block which can either be basic when it contains only the assembly template or extended when it is supplemented by an interface .
this section concerns the latter only.
the assembly statement consists of a series of low level instructions that convert input parameters to output parameters .
the interface binds c lvalues i.e.
expressions evaluating to c memory locations and expressions to assembly operands specified as input oroutput and declares a list of clobbered locations i.e.
registers or memory cells 1238whose values could change .
for the sake of completeness the statement can also be tagged with volatile inline orgoto qualifiers which are irrelevant for interface compliance thus not discussed in this paper.
the interface bindings described above are written by string specifications which we will now explain.
templates.
the assembly text is given in the form of a formattedstring template that like printf may contain socalled token s i.e.
place holders .
these start with followed by an optional modifier and a reference to an entry of the interface either by name an identifier between square brackets or by a number denoting a positional argument.
the compiler preprocesses the template substituting token s by assembly operands according to the entries and the modifiers note that only a subset of x86 modifiers is fully documented and then emits it as is in the assembly output file.
hstatementi asm htemplate stringi hinterfacei houtputsi houtputi hinputsi hinputi hclobbersi hclobber stringi houtputi hconstraint stringi hclvaluei hinputi hconstraint stringi hcexpressioni figure concrete syntax of an extended assembly chunk clobbers.
they are names of hard registers whose values may be modified by the execution of the statement but not intended as output.
clobbers must not overlap with inputs and outputs.
the cc keyword identifies when it exists the conditional flags register.
the memory keyword instructs the compiler that arbitrary memory could be accessed or modified.
a f eaxgb f ebxgc f ecxg d f edxgs f esigd f edig u a c d q q a b c d i n z r r q s d f ebpg p frb k ri cforrb2r f espg f 0g andri2r f0gandk2f1 8g andc2ig m f pforp2pg g i r m figure gcc i386 architecture constraints constraints.
a third language describes the set of valid assembly operands for token assignment.
the latter are of kinds an immediate value a register or a memory location.
fig.
gives a view of common atomic constraints letters used in x86.
constraint entries can have more that one atomic constraint e.g.
rm in which case the compiler chooses among the union of operand choices.
the language allows to organize constraints into multiple alternatives separated by .
additionally matching constraint between an input token and an output token forces them to be equal early clobber informs the compiler that it must not attempt to use the same operand for this output and any non matchedinput commutative pair makes an input and the next one exchangeable.
finally output constraints must start either with for the write only mode or with for the read write permission.
iv.
f ormalizing interface compliance a. extended assembly assembly chunks.
we denote by c asm a standard chunk of assembly code.
such a chunk operates over a memory state m mstate that is a map from location registers of the underlying architecture or memory cells to basic values int8 int16 int32 etc.
.
we call a valueset the set of valid addresses for a given architecture.
the value of an expression in a given memory state is given by function eval mstate expression7!value .
the set of valid assembly expressions is architecture dependent fig.
is for i386 .
we abstract it as a set of expression s built over registers memory accesses and operations.
finally an assembly chunk ccan be executed in a memory state mto yield a new memory state m0with function exec asm mstate7!mstate .
fig.
recaps above functions and types.
exec asm mstate7!mstate eval mstate expression7!value mstate location7!value expression ase value register e e e e e ... location register value register eax ebx ecx edx ... case of x86 value int8 int16 int32 ... figure assembly types assembly templates.
inline assembly does not directly use assembly chunks but rather assembly templates denotedc asm which are assembly chunks where some operands are replaced by so called tokens i.e.
placeholders for regular assemblyexpression s to be filled by the compiler formally they are identifiers etc.
.
given a token assignment t token7!expression we can turn an assembly template c asm into a regular assembly chunk c asm using standard syntactic substitution denotedc t asm.
the value of tokentthrough assignment tis given by eval m t t .
formal interface.
we model an interfacei bo bi st sc f as a tuple consisting of output tokens bo tokenset input tokens4bi tokenset amemory separation flagf bool clobber registers sc register set andvalid token assignments st tset.
input and output tokens bind the assembly memory state and the c environment.
informally the locations pointed to by tokens in biareinput initialized by the value of some c expressions while the values of the tokens in bo areoutput to some c lvalues.
bo bicontains all token declarations and bo bimay be non empty 4actually a concrete interface also contains initializer and collector expressions in order to bind i o assembly locations input and output to c. we skip them for clarity as they do not impact compliance.
if the flag fis set to false then assembly instructions may have side effects on the c environment otherwise they operate on separate memory parts scandstprovide additional information about how the compiler should instantiate the assembly template to machine code the clobber registers in sccan be used for temporary computations during the execution their value is possibly modified by the chunk while strepresents all possible token assignments the compiler is allowed to choose the gnu syntax typically leads to equality disequality and membership constraints between tokens and sets of registers.
extended assembly chunk.
an extended assembly chunk x c i is a pair made of an assembly template c and its related interface i. the assembly template is the operational content of the chunk modulo token assignment while the interface is a contract between the chunk the c environment and low level location management.
b. detail from gnu concrete syntax to formal interfaces let us see how the formal interface iis derived from concrete gnu syntax .
tokens boandbicome from the corresponding output and input lists except that a if an output entry is declared using the modifier then it is added to bothboandbi and b if an input token and an output token are necessarily mapped to the same register they are unified.
each register in the clobber list belong to sc.
if the clobber list contains memory the memory separation flag fis false true otherwise.
the set stof valid token assignments tis formally derived in steps collection of string constraints splitting constraints by alternative i.e.
token7!string set architecture dependent e.g.
fig.
evaluation of string constraints token7!expression set set representing a disjunction of conjunctions of atomic membership constraints token2 exp .
.
.
exp flattening token7!expression set representing a disjunction of conjunctions of atomic equality constraintstoken expression still token assignments must respect the following properties and are filtered out otherwise every output token maps to an assignable operand either aregister or a eexpression every output token maps to distinct location eachtoken maps to a clobber free expression where a clobber free expression is an expression without any clobber register nor any early clobber sub expression i.e.
containing the mapping of an early clobber token introduced by the modifier .
fig.
exemplifies the interface formalization of fig.
s chunk introduced in sec.
ii.
tokens boandbisimply enumerate the present entries respectively in output and input lists l196 .
the 5thentry matches the same register eax as the second 4is unified with .
for the sake of brevity we split the set of token assignments into two parts one invariantw.r.t.
compiler choices and one that may vary we only list of them but there are other valid combination of memory