fork state aware differential fuzzing for blockchain consensus implementations wonhoi kim1 hocheol nam1 muoi tran2 amin jalilov1 zhenkai liang3 sang kil cha1 min suk kang1 1kaist wh.kim hcnam amin sangkilc minsukk kaist.ac.kr 2eth z urich dutran ethz.ch 3national university of singapore liangzk comp.nus.edu.sg abstract blockchain networks allow multiple client implementations of the same consensus algorithm by different developers to coexist in the same system.
ensuring correct implementations among these heterogeneous clients is crucial as even slight semantic discrepancies in their implementations can lead to safety failures.
while existing fuzzing frameworks have discovered implementation flaws in blockchain they suffer from several challenges in testing them with sequences of conflicting blocks called forks.
existing tools fail to adequately assess the forkhandling processes in blockchain implementations when relying on traditional code coverage feedback which lacks the granularity needed to navigate the diverse and complex fork handling scenarios.
this paper introduces f orky a fork state aware differential fuzzing framework designed to detect implementation discrepancies within the critical fork handling process with its novel fork aware mutation and fork diversifying feedback mechanisms.
we test f orky on the two most influential blockchain projects bitcoin and ethereum which are the representatives of the two major blockchain consensus algorithm families proofof work pow and proof of stake pos consensus algorithms.
index terms blockchain consensus differential fuzzing i. i ntroduction the open nature of blockchain projects allows heterogeneous implementations of clients with the same consensus algorithm to coexist in the same network.
major blockchain projects such as bitcoin and ethereum have maintained a strong community driven open client development culture where multiple independent teams of developers implement their consensus clients in different languages and maintain them independently.
as a result blockchains are often operated by multiple families of clients each of which has multiple versions coexisting at the same time.
for example as of march only .
of bitcoin clients run the most up to date bitcoin core version .
.
whereas run older versions of bitcoin core and run several other client families e.g.
btcd bcoin .
ethereum s four major client families i.e.
prysm lighthouse teku nimbus are used by respectively .
having some implementation diversity in distributed networks is desirable in general as the risk of single point of failures can be reduced yet special care must be taken to ensure that all these heterogeneous client implementations correctly agree on the same blockchain states.
in blockchain consensus both authors contributed equally to this work.
corresponding author.
split viewssingle converged viewblockchain input in time domainclient client client this branch is chosen as the main chainclient client client client client client problems client mayexecute wrong smart contracts wrong financial transactions etc.cbdacbdacbdaabctimeprocessinputdiscrepancytriggered?outputchain viewlogicalfork structureablock a a is parent of babvote voting to aalegendsd fork is created!
noyescbda different branches are chosen!fig.
.
an example of how discrepancies in blockchain clients fork handling logic can lead to split views among clients.
algorithms even a slight semantic difference between two implementations of the same algorithm can lead to a critical safety violation.
a simple example in figure illustrates how discrepancies in implementation can lead to safety violations in blockchain networks.
three clients or nodes and receive block messages and votes from the blockchain network in a particular sequence.
these clients encounter a fork a condition in blockchain inputs where two blocks b and c extend from the same parent block a creating two competing branches.1since competing branches such as b and c may contain conflicting transactions only one branch should eventually become the main or canonical branch.
ideally if the blockchain s consensus algorithm operates correctly without implementation bugs all client nodes in the network should eventually converge to a single view agreeing on the same branch.
however discrepancies in the consensus implementations across multiple clients may lead to divergent views e.g.
and may select a different branch than .
these divergent views whether permanent or transient can cause serious issues as a client operating on an incorrect view might mishandle transactions or smart contracts based on their divergent blockchain state.
this observation suggests a need for a practical testing tool capable of evaluating multiple blockchain clients with inputs exhibiting forks particularly to find discrepancies in the forkhandling logic.
while recent studies have made 1in this paper the terms forks and branches specifically refer to those within the blockchain data structure notto be confused with software code forks and branches.strides in fuzzing blockchain consensus implementations current blockchain fuzzers fall short in directly testing forkhandling logics and finding discrepancies in implementation.
a key technical challenge for existing fuzzers lies in their inability to grasp the complex state transitions found in blockchain consensus particularly concerning fork handling mechanisms.
blockchain consensus algorithms are distinct from traditional software in that they are highly stateful and have heavy state transitions.
particularly the arrival of each new block and other auxiliary messages e.g.
votes can significantly alter the blockchain state e.g.
one new block can tip the balance in favor of one branch over another as seen in figure .
the primary challenge in testing consensus implementations is to find an input sequence of blocks potent enough to significantly influence the states crucial to forkhandling logic.
unfortunately conventional code coverage feedback methods may not be effective enough for identifying such important blockchain inputs as two different blockchain inputs could yield the same branch coverage yet only one might alter the blockchain state in a meaningful way.
current fuzzers including fluffy tyr and loki can partially handle this problem by randomly varying blockchain transactions and block orders.
however relying only on code coverage feedback or random block generation based on a coarse grained state model these tools lack the ability to precisely represent intricate fork structure layout of blockchain inputs limiting their ability to test the fork handling logic in blockchain consensus algorithms reliably and effectively.
in this paper we tackle this challenge by addressing the intricacies of analyzing blockchain states especially fork structures within fuzzing processes.
our approach is the first to consider the complex blockchain fork states which we coin as fork state aware fuzzing testing a wide range of blockchain states to detect critical discrepancies in forkhandling logic found in consensus algorithms.
we employ two main strategies fork aware mutation strategies and a forkdiversifying feedback mechanism.
the former leverages a deep understanding of fork structures to test diverse blockchain states thus enhancing the detection of fork handling logic discrepancies beyond traditional mutation methods.
the latter introduces a novel feedback mechanism aimed at uncovering previously unseen fork handling events overcoming the limitations of conventional code coverage feedback.
by selecting fuzz inputs that present new and distinct fork events our approach ensures a wider range of blockchain states are tested leading to more effective and comprehensive testing outcomes.
we design and implement f orky an open sourced differential fuzzer based on our proposed fork state aware fuzzing methodology.
f orky effectively test fork handling logic in proof of work pow and proof of stake pos blockchain consensus algorithms.
our evaluation of f orky across bitcoin clients and ethereum clients demonstrates its effectiveness in finding several discrepancies in them.
in summary our contributions are as follows we propose a new fork state aware fuzzing methodology aimed at testing fork handling logic within blockchain consensus algorithms which is complementary to existing blockchain fuzzers.
we present fork aware mutation strategies that generate inputs exhibiting many fork conditions and a new forkdiversifying feedback mechanism that can reliably explore unseen fork handling cases.
we present f orky a differential fuzzer that implements our approach and evaluates it on bitcoin s pow and ethereum s pos consensus algorithms finding several discrepancies in their fork handling implementations.
we open source f orky for its wider use in other pow and pos blockchains .
ii.
b ackground in this section we first introduce several basic blockchain terminologies to understand the rest of the paper.
blockchains.
a blockchain e.g.
bitcoin ethereum is a distributed ledger storing transactions in a chain of blocks that are cryptographically linked together.
the blockchain is commonly maintained by a peer to peer p2p network of nodes or clients which store a replica of the blockchain locally.
blockchain client nodes collectively follow a consensus algorithm to agree on the validity of individual blocks aiming to have exactly the same view i.e.
identical copies of blocks .
typically each block consists of the hash of its previous block in the blockchain called the parent block and transactions.
users generate transactions that are periodically grouped into a new block that extends the head i.e.
the latest block of the winning branch by special clients e.g.
miners in pow consensus or validators in pos consensus .
a new block is then circulated in the p2p network and independently validated by clients.
proof of work algorithm.
many early blockchains such as bitcoin use the proof of work pow algorithm to achieve consensus among untrusted client nodes.
the pow algorithm operates through specialized client nodes known as miners tasked with creating blocks.
to create a block miners compete in finding a specific mathematical solution known as a nonce that when combined with block data produces a hash with a required number of leading zeros.
a chain of blocks with greater cumulative computational effort is regarded as the winning branch if multiple branches exist in the network.
in general the longest branch is regarded as the winning branch as the series of blocks that required the most substantial computational effort to construct necessitate smaller hash values.
proof of stake algorithm.
more recent blockchains have adopted the proof of stake pos algorithm which selects validators to create blocks based on their stake i.e.
the amount of cryptocurrency they hold .
in ethereum switched to pos from pow with the introduction of the gasper protocol .
in gasper one validator is chosen at random as the proposer who is responsible for creating a new block and proposing it to the network.
other validators must attest to the validityof the proposed block by casting votes or attestations in a timely manner otherwise they are penalized for rule violation i.e.
lose their deposit .
when two thirds of validators vote correctly on the chain head for two epochs in a row the block can not be reverted by other forks.
fork and fork choice rules.
when a client receives two or more blocks extending the same parent block it has multiple branches of blocks in its local blockchain copy or a fork.
forks are resolved quickly following a pre defined set of rules e.g.
favoring the longest branch in bitcoin .
the set of rules is called the fork choice rules because they determine which branch to choose when handling a fork and may vary depending on the consensus algorithms in different blockchain projects .
note that it is natural for a pow or pos blockchain to have forks in the first place because miners or validators may create blocks while being unaware of the existence of other blocks extending the same parent block.
reorganization.
when a newer branch gets chosen by the fork choice rules and thus has to overwrite the already accepted branch some blockchain states need to be rolled back e.g.
transactions in the overwritten blocks are marked as unspent and some new state changes need to be applied e.g.
transactions in the new branch are marked as spent .
we call this process a block reorganization or simply a reorg and it is a critical part of the fork choice rules in consensus algorithm.
iii.
t hreat model discrepancies in the fork handling implementation of blockchain clients pose risks due to potential exploitation by malicious actors.
the adversaries we consider in this paper aim to create inconsistent blockchain states e.g.
different branches being chosen by different clients in pow pos blockchain networks.
if attacks are successfully mounted target clients would have a blockchain state that differs from the rest of the network.
consequently services relying on these inconsistent blockchain states may experience undesired outcomes.
for instance a cryptocurrency exchange receiving blockchain states from a targeted client might produce incorrect trading results or a mining pool might generate a block that is rejected by the rest of the network thereby wasting its mining power.
the impact of these attacks depends on the size of the affected client population in the network.
when the target nodes of an attack constitute the majority of the network the adversary can cause global damage making his her branch the canonical chain permanently.
one reorg bug we discover in ethereum see viii b would fall into this category as the target client families prysm and teku together account for more than of the ethereum network.
in contrast when the target nodes are the minority the created fork or view split would eventually be resolved.
however the temporary split can offer a window of opportunity for attacks.
several centralized exchanges such as binance or bithumb rely on one block confirmation meaning a short lived e.g.
block time state inconsistency in the target clients can be exploited to cause localized damage.
the chain tip switching bug in bitcoin see viii a would be an example of suchlocal damage attacks.
or the temporary fork may persist for an extended period with certain strategies.
the recent balancing attack strategy that can maintain a long lived fork by balancing two branches for several slots in ethereum .
is one example.
to exploit these discrepancies in fork handling logic adversaries with some mining power or staking power should create and send one or more blocks and or attestations to the affected clients.
it is a realistic attack capability in modern pow pos blockchains because rational miners or validators in practice often use their power to generate blocks with malicious intent when the expected return is higher than the benign block reward.
for instance bitcoin has recently experienced intentionally created invalid blocks in both the mainnet and testnet by rational miners and ethereum has had more than validators slashed for attesting rule violations since its transition to pos in .
scope.
our main goal is to identify implementation discrepancies in fork handling logic that can be exploited to cause view splits in pow pos blockchain networks.
confirming whether a view split due to a discrepancy is permanent or temporary is beyond the scope of this work because it depends on external factors such as the affected client population as discussed above.
we target the fork handling logic implementations of pow pos systems not necessarily covering the entire blockchain implementations.
this makes f orky complementary to other more general blockchain fuzzers .
iv.
f orky overview in this section we introduce a motivating example that highlights a specific challenge in blockchain consensus fuzzing.
following this we briefly outline how f orky tackles this challenge by employing fork aware mutation strategies and fork diversifying feedback mechanisms.
a. motivating example blockchain consensus presents unique challenges to fuzzing due to the interconnected nature of multiple blocks through persistent state variables.
refer to the motivating example in figure which showcases a simplified pow blockchain consensus code.
this code contains persistent blockchain state variables and two primary functions for block processing.
although our system operates across different programming languages we have provided this example code in simplified cstyle to facilitate easier understanding.
first of all the global state variables play a crucial role in storing critical blockchain states undergoing consistent updates throughout the execution of input blocks.
the state variablechain manages the global state of the blockchain which encompasses all blocks in hash format from the genesis block and the reference pointer to the latest block in the main chain called the head.
additionally the variable mempool holds instances of coin which represents the cryptocurrency containing information of the amount and cryptographic proof of ownership.b work c workcbdainput1d cbac cbabab baaa a cbaaactimebug!dcbatimebcatimereorgreorgcbad try reorginput2input3assumptionblock body is invalidline 11line 8line 38line line 11line 8line 11line 25line 11line 11line 25time domain viewcovered branchesfork structure view1 global persistent state variables2chainstate chain chain state variable3mempool mempool mempool unspent coins 45function processblock block b ...7if sha256d b chain.target pow 8if chain.contains b.parent 9chain.add b 10if b.cum work chain.cum work begin fork choice11if b.parent chain.head 12chain.head b 13chain.cum work b.work 14mempool.delete used coin 15mempool.add new coin ... update other persistent state variables17 else reorganize b 19function reorganize block b 20common ancestor findcommonancestor chain.head b ... revert blocks from the current head to common ancestor22for block in 23if chain.verify block.header valid 24chain.head b ... update other persistent state variables25if mempool.contain used coin 26mempool.delete used coin 27mempool.add new coin else bug fig.
.
a simplified consensus program left and three example inputs right .
we illustrate how a series of blocks in each input lead to different fork structure states resulting in different covered branches of the consensus program.
when a client receives a series of blocks it processes each block in sequence.
for each block the function processblock is invoked first which checks the proof of work line and whether the block extends any block in the chain line next a fork choice operation begins cumulative works of bandchain head i.e.
head of the winning branch are compared line .
if the new block extends the current head line then the client adds the block at the end of the winning branch and updates chain mempool and other persistent state variables line .
otherwise the reorganize function is invoked.
the reorganize function rolls back all transactions in the old branch up to the common ancestor where the new branch diverges from.
note that many details are omitted for brevity yet we highlight the multi level nested conditions line for the bug to be triggered line .
this bug is triggered when the mempool does not have the memory of the coin to delete line and this condition depends on the global state variables which could have been altered by previous block processing e.g.
block body contains duplicate coins .
note that this simplified bug example is inspired by one of our own case studies outlined in viii a. at first glance satisfying the conditions within each function to trigger the bug may not appear so challenging.
for instance by presenting a series of blocks to the client see the example input 1in figure one could induce a fork notably at the insertion of c as shown in fork structure view with the assumption that block b s work exceeds that of block c. at the submission of d the block penetrates line and triggers reorganization because it tries to extend the losing chain line .
during the reorganization d is found to contain a coin i.e.
transaction that is not present in the mempool line while its header is valid line which in turn triggers the bug line .
generating such a precise sequence of inputs with state ofthe art fuzzers is however far from straightforward.
fuzzers lacking an understanding of blockchain s persistent state vari ables like the fork structure would require a rare chance to append a block at the end of the losing chain and satisfy the condition in line to activate reorganize .
furthermore penetrating through nested conditions to reach line would require a series of uncommon mutations to the input blocks and result in meaningful changes of the values of state variables.
taking input 1as an example a specific coin can be added to mempool through state changes line during the reception of c. this coin will trigger the bug after the reception of d if it gets deleted twice during reorganization line and eventually dissatisfying the condition at line .
although there exists a slim chance to discover a block input that satisfies all these conditions it is undesirable to depend on extremely rare luck through random mutations.
some might still argue that with enough time after random mutations of blocks and transactions state of the art fuzzers would ultimately discover inputs that form a specific fork structure.
for instance input 2in figure already triggers reorganize line visits line but not the bug line yet.
through some random mutations of block d a fuzzer could potentially find a critical input similar to input .
however we show that reliably testing such a specific sequence in blockchain is notas straightforward as it appears.
even if a sequence of input blocks is generated by randomly attempting various block orders achieving a reliable meaningful test is challenging because code coverage is not sensitive enough to the changes in the blockchain states.
for instance consider two block sequences input and input which achieve the same branch coverage because both should handle new fork cases and resolve them through reorganization.
thus if input 3is already present in the test case corpus the fuzzer would miss the opportunity to add input 2to the corpus despite its importance in covering significant inputs like input .
b. our approach forky tackles the highlighted challenges by emphasizing the analysis of persistent blockchain states specifically fork c depth first mode e balance first mode d breadth first modelongestchain headleaf block of non canonical chainpropagatedmutationmutate removeleaf blockmutatedstructure awaremutationbranch awaremutationselect modeblock levelmutationtransaction levelmutation addselect parentselect modenon leaf block b remove modeoriginal input a low level modemutation propagationbranch levelmutation f type f type f type f type f type f type fig.
.
overview of mutation operations in f orky .
structures during fuzzing processes.
with the knowledge of the fork structure of fuzz inputs f orky performs fork stateaware fuzzing to produce inputs that exhibit a wide range of blockchain states.
forky is a differential fuzzing framework that tests multiple target blockchain clients using the same blockchain inputs to detect discrepancies in their output blockchain states such as view splits.
inputs from the shared corpus are mutated to trigger potential discrepancies and the notable ones are later added to the corpus.
we highlight the two components that address the outlined challenges.
fork aware mutation strategies v .
forky performs state aware fuzzing and is able to generate inputs exhibiting highly diverse blockchain states enhancing the discovery of critical fork handling logic discrepancies.
unlike conventional structure aware mutations which randomly generate blockchain inputs at the transaction and block levels our mutation strategies are expressly designed to produce inputs with forks.
these strategies are also designed to promote or avoid certain types of fork handling events to render the testing more effective.
fork diversifying feedback mechanism vi .
our second contribution is a new feedback mechanism that can explore unseen fork handling events.
our feedback complements code coverage feedback by evaluating the novelty of fork events tested compared to those previously examined.
by selecting fuzz inputs showcasing new and different fork events for the corpus we ensure a broader array of blockchain states are tested leading to more efficient and effective testing like testing with the critical input 1in figure .
v. f ork aware mutation strategies the goal of our fork aware mutation design is to effectively adjust fuzz inputs with the knowledge of the fork structure of the inputs.
to achieve this we propose a number of mutation strategies for f orky .
a. mutating input fork structures in pow pos blockchains the fork structure of a blockchain input represents a tree of blocks where each block can contain a rare but interesting forks b ineffective mutationmutated child blocks become invalidhead change with reorg fig.
.
example fork mutations we promote a and avoid b .
multiple transactions.
thus we mutate the input fork structure at three levels branch level block level and transaction level as shown in figure .
f orky first determines the mutation level branch block or transaction and then applies the corresponding mutation operations to the input.
figure showcases five mutation modes a e that f orky uses for making effective fork structure mutations.
let us present three main mutation strategies of f orky and how these mutation modes are used.
mutation strategy .
mutating with fork structures .this first strategy describes how f orky in general mutates the fork structure of the input to test various fork handling logics effectively.
mutating the input at the branch level f orky modifies the fork structure of the input.
for example the remove mode in figure b deletes one block from the input fork structure.
figure c e show the three systematic mutation modes that f orky uses to add a new block to the input.
the depth first mode in figure c makes the chain longer by adding a new block to the longest branch of the tree.
the breadth first mode in figure d adds a new block at non leaf nodes creating a new branch.
the balance first mode in figure e is a special blockchain specific mode we introduce to create highly unlikely fork structures with longlived competing branches see more details later in this section.
forky uses a combination of these operations to test diverse fork structures.
notably f orky favors creating the fork structure that has notbeen tested before.
f orky evaluates whether the fork structure of the new mutated input has a new fork or overlaps with existing fork structures before conducting the mutation.
for this f orky checks the isomorphism of the unordered rooted tree of the mutated inputs.
to be more specific f orky assigns the tree isomorphism code of the root block of the mutated input denoted as f type in the figure and checks whether it is a new fork structure which can be computed in linear time .
this way the mutation can continuously guide the fuzzer to test unseen types of fork structure and thus potentially unseen fork handling cases.
mutation strategy .
promoting rare fork structures.
the above mutation strategy above already enables testing of inputs with various forms of fork structures.
yet it would require a significant amount of fuzz energy to test inputs with certain types of fork structures.
a blockchain input with longlived competing branches is one such example.
as shown in figure a two long lived branches of blocks compete as they grow over time trigger unique fork handling logics e.g.
overwriting and rolling back may block and transaction variables repeatedly over multiple fork handling events.
a mere fork aware mutation e.g.
figure c and d may notbe able to create such long lived competition between branches effectively.
for this we introduce a special mutation operation thebalance first mode in figure e that explicitly promotes the competition between branches by empowering the noncanonical yet long lived branch.
this mode is selected with a certain probability offering a chance to create highly unlikely fork structures with long lived competing branches.
mutation strategy .
avoiding ineffective mutations.
when the mutation is conducted at the block or transaction level the mutation operation may affect the validity of the blocks or transactions in the fork structure.
while this is useful for testing the robustness of the target client in general it may lead to ineffective fuzzing in the blockchain context.
see figure b as an example where a single block mutation that makes the block invalid may significantly reduce the efficacy of testing because the mutation invalidates many other blocks in the fork structure of blocks.
to handle this f orky propagates the mutation operations according to the forkstructure view of the blocks in the input.
figure a shows the low level mode that propagates the mutation operations in the downward order of blocks i.e.
from parent to all child blocks to avoid invalidating many blocks in the fork structure.
b. mutation for pos votes and times there exist two more dimensions in blockchain inputs that have been introduced by the proof of stake pos consensus algorithms votes and arrival times.
in pos systems each validator node can cast explicit votes as known as attestations in ethereum to blocks that it considers valid and more appropriate to be included in the main chain.
and the precise arrival time of each block and vote is also critical in pos because it can affect the weight of the block in the forkchoice rules .
therefore for the same given fuzz input mutating minute timing information and altering few votes in pos systems can create various fork handling events.
mutation strategy .
voting and timing mutation.
forky mutates several fields of the votes attestations in ethereum messages.
for example f orky randomly changes the target block of the vote at each mutation operation.
also the arrival time of each vote is mutated to test scenarios where some votes arrive late or early which is critical in pos systems.
vi.
f ork diversifying feedback forky s fork aware mutation strategies enhance its ability to test various mutations of block fork structures.
however the new mutation strategies alone are insufficient to test many critical fork structures because the code coverage feedback is insensitive to blockchain state changes as demonstrated in iv a. in this section we introduce a novel feedback mechanism based on fork structures designed to overcome the shortcomings of traditional code coverage feedback.
this new mechanism is intended to complement rather than replace the existing code coverage based feedback.
a. high level intuition recall from iv a that consensus implementations in blockchain are stateful thus discerning interesting inputssuch as input 2in figure is hard due to the insensitivity of traditional code coverage metrics.
losing input 2in the corpus would significantly reduce the chance of finding the discrepancy which can be triggered with input .
addressing this challenge would require f orky to continuously explore more diverse blockchain states or fork structures in addition to finding new code paths.
this additional feedback mechanism can help f orky to find fuzz inputs with more diverse fork structures even when they do not necessarily increase code coverage.
in the pow and pos blockchain contexts we characterize this additional feedback as forkdiversifying feedback.
b. new feedback we propose an additional fork diversifying feedback mechanism to complement code coverage.
we leverage our domain knowledge to quantitatively define the types of fork handling events and use these to add feedback on top of code coverage.
with this additional feedback and the knowledge of fork types forky finds the inputs that test new fork handling events and eventually test previously uncovered code paths more effectively.
we empirically find that the fork diversifying feedback shows noticeably faster discrepancy detection performance in both bitcoin and ethereum.
types of forks.
we quantify fork types within the input to enable continuous generation of new fork varieties.
this approach aims to examine previously untested fork handling logics.
our quantification centers on how a fork in a blockchain input is resolved or how blocks are reorganized by the consensus algorithm.
specifically a reorganization represents a form of fork handling operation requiring the rollback or restoration of many transactions and blocks.
by focusing on fork reorganizations we can quantitatively assess the diversity of fork handling logics.
notably different reorganization strategies have recently been exploited in attacks against bitcoin and ethereum as evidenced in literature .
by designing a quantitative metric of fork reorganization we can expect to test a broader range of fork reorganization events thereby uncovering more potential discrepancies in the fork handling implementations.
to that end we define reorganization type in the context of the environment and complexity in which each reorganization happens.
for example some reorg events can occur between long competing branches while some may involve a single block reorganization.
moreover the replacing block can be in a slot later than the replaced block i.e.
ex post reorgs or the replacing block can be in the earlier slot i.e.
ex ante reorgs .
we define a reorganization type to reflect these different styles of reorganization events with varying complexities.
a unique reorganization type is defined as the relationship between two branches critical condition for reorganizations e.g.
block order timing voting number of reorganized blocks etc.
let us present the reorganization type definition for ethereum first because reorganization events in ethereum s pos consensus algorithm are more complex than those inreorg typeeth replacing blocks replaced blocks size of replacing branch size of replaced branch weight gap exists bool score boosted bool epoch gap n th reorgs within input shape of the reorg eventcause of reorg eventother reorg event propertiesreorg typebtc replacingblks replacedblks n threorgswithininput shape and cause of the reorg event a reorg type for ethereum pos consensusother reorg event property b reorg type for bitcoin pow consensusreorg1reorg2 reorg1 s type reorg2 s type head change w o reorghead change with reorgvotes for blocksdelayed block reception c a blockchain input that triggers two reorg events see the two different reorg types fig.
.
the reorg type for a bitcoin pow and b ethereum pos consensus algorithm and c examples of reorg type in ethereum.
bitcoin s pow consensus algorithm.
the ethereum reorganization type in figure a contains eight elements.
the first four i.e.
the number of replacing replaced blocks and thesize of replacing replaced branch provide insights into the characteristics of the corresponding reorganization event e.g.
slot size ex ante reorganization .
note that thesize of replacing replaced branch is measured by the difference between the slot number of each head of the branch and the slot number of the common ancestor of the branches.
the next two elements i.e.
the presence of a weight gap and the occurrence of a score boost describe the underlying cause of the reorganization e.g.
when neither a weight gap nor a score boost is observed in a reorganization event it implies that the reorganization was triggered due to a tie break rule.
the next epoch gap indicates the number of epochs a reorganization event spans e.g.
it has a nonzero value when a fork straddles two or more consecutive epochs.
the inclusion of this element is important because recent attacks have shown that some attacks can occur at the boundary of epochs.
finally to help promote longlived competition the type includes the counter for how many reorgs occur within a given test case to differentiate multiple reorganization events in a single test case.
reorganization events in bitcoin s pow consensus algorithm are relatively simpler than those of ethereum.
figure b illustrates a simpler reorganization type of bitcoin.
we provide an example of reorganization types in ethereum in figure c .
this specific example input triggers two reorganization events see two red striped arrows.
while these two reorganization events look similar and the second does not increase code coverage we assign different reorganization types to them.
according to our reorganization type definition for ethereum found in figure a the two types differ inseveral elements see the figure for details and thus our fuzzer can potentially store this input as a new interesting seed in the corpus.
finally let us explain how our fork diversifying feedback mechanism adds novel fork inputs to the corpus.
after mutating and testing a blockchain input f orky evaluates it to compute reorganization types present in the input.
if an input exhibits a reorganization type that has not been previously encountered when compared to the record f orky maintains throughout the fuzzing campaign it is added to the corpus.
note that this feedback mechanism does not replace the existing code coverage feedback instead it enriches it by adding more interesting inputs to the corpus.
this feedback mechanism enhances the likelihood of uncovering yet untested discrepancies in the implementations of various fork handling logics.
vii.
i mplementation and evaluation we present our implementation of f orky for bitcoin and ethereum clients vii a and their performance vii b .
a. implementation with f orky we test bitcoin and ethereum the two largest in terms of market capitalization pow and pos blockchain projects respectively.
since their pow and pos consensus algorithms are incompatible with each other we test them separately with two fuzzers f orky bitcoin and forky ethereum.
we open source both implementations .
forky is built on top of the libfuzzer library using c for f orky bitcoin and rust for f orky ethereum .
particularly we base our implementation on code coverage feedback corpus maintenance and seed input selection from the default libfuzzer framework and further improve it with our fork aware mutation and fork diversifying feedback.
all bitcoin clients run in the regression test mode i.e.
regtest .
for f orky ethereum we build on top of the beacon fuzz and use the spec test environment that has been used for executing test cases.
for f orky bitcoin we test a total of bitcoin clients across four client families.
this includes bitcoin core c from .
.
to .
versions bitcoin knots c .
and .
versions btcd go .
.
and .
versions and bcoin javascript .
.
to .
.
versions .
for forky ethereum we test a total of four ethereum consensus2 clients across four client families.
this includes lighthouse .
.
rust prysm .
.
go teku .
.
java and nimbus .
.
nim .
b. evaluation we evaluate how effective f orky s main features i.e.
the fork aware mutation and fork diversifying feedback mechanism are at finding discrepancies in fork handling logic.
for this we compare the proposed full implementation of 2after switching to pos in september ethereum s execution clients such as geth no longer handle consensus logic and thus execution clients are out of the scope of this work.
100k 200k 300k 400k 500k fuzzing iteration01234 of discrepancies found 10k 20k 30k 40k 50k fuzzing iteration012345 of discrepancies found a bitcoin b ethereumforky baseline mutation baseline feedback baselinefig.
.
performance of f orky and its variants.
forky with several variants of f orky which are inferior implementations of f orky .
we show that the f orky s core features are indeed effective at finding discrepancies.
baseline denotes a coverage guided structure aware fuzzer baseline mutation denotes a coverage guided structureaware fuzzer with the fork aware mutation baseline feedback denotes a coverage guided structureaware fuzzer with the fork diversifying feedback mechanism and forky i.e.
baseline mutation feedback denotes a coverage guided structure aware fuzzer with the fork aware mutation and fork diversifying feedback.
findings table i lists the discrepancies detected by forky .
it identifies six previously unknown discrepancies two instances of rediscovered known bugs and one variant of an existing bug.
in bitcoin one discrepancy could lead to a view split in bcoin.
one known bug and a new variant of a known bug are detected.
also one unknown bug could disrupt chain growth by inhibiting the appending of new blocks.
in ethereum f orky detects discrepancies in the tick operation and the future attestation processing logic which could cause view splits among ethereum clients.
the discrepancy can cause resource exhaustion due to orphan threads.
the list also includes bugs in the standardized test suites i.e.
ethereum s spec tests .
this suggests that the current testing environment for ethereum consensus clients is unsatisfactory to test the correctness of the fork resolution logic in these ethereum clients.
fixing these discrepancies requires different levels of effort.
the discrepancies in bitcoin core can be mitigated by adding additional incorrect block verification .
the discrepancy in bitcoin core can be fixed by adding code for segwit handling .
the bcoin bug can be mitigated by reverting the chain tip after block body validation if the validation fails.
the orphan thread issue in nimbus can be prevented by adding lines of code for exception handling.
the remaining discrepancies in ethereum require more substantial changes to the clients fork resolution logic because they stem from ambiguous specifications.
for example prysm and teku would have to change their core data structure to address the conflicting future attestations .
performance figure shows the number of discrepancies found as f orky and three variants progress.
in both figure a and figure b we clearly see that the full f orky fuzzer finds the discrepancies faster than all other inferior versions of f orky showing the overall effectiveness of 50k 100k 150k 200k 250k fuzzing iteration0.
.
.
.5average number of reorgs per test 20k 40k 60k 80k 100k fuzzing iteration024681012average number of reorgs per test a bitcoin b ethereumforky baseline mutation baseline feedback baselinefig.
.
numbers of reorgs triggered per test case with f orky and its variants.
forky .
in figure a the baseline mutation strategy also finds all bitcoin discrepancies within 500k iterations about hours of execution but it took longer to find all discrepancies than f orky .
figure b shows that the baseline mutation fails to find one discrepancy i.e.
in viii b within 50k iterations about hours of execution .
we stop at 100k iterations but it still does not find this discrepancy.
in both bitcoin and ethereum the baseline feedback fuzzers show no improvement over the baseline fuzzers showing that the fork diversifying feedback alone would not be useful.
number of reorgs to better understand the effectiveness of f orky s fork aware mutation and fork diversifying feedback we measure the number of reorgs per test case during the fuzzing campaigns.
figure shows that f orky indeed generates more reorgs than all other variants.
also the baseline mutation fuzzers generate much more reorgs than the baseline fuzzers indicating that the fork aware mutation is indeed the key to generating more reorgs.
each line in figure represents the moving average with a window size of of the number of reorgs.
the effectiveness of the fork diversifying feedback in generating more reorgs though is not universal across bitcoin and ethereum and it appears to be dependent on the existence of the fork aware mutation in the fuzzing campaign.
in our bitcoin testing the fork diversifying feedback does not generate any noticeably more reorgs than the strategies without the feedback.
this is because the reorg types in bitcoin have a much lower dimension of freedom than those in ethereum see figure a and figure b for comparison.
the limited dimensions of freedom in bitcoin reorg types make the traditional coverage feedback dominate our new feedback.
yet the fork diversifying feedback shows a significant impact on the number of reorgs in ethereum especially when it is used with the fork aware mutation.
the effectiveness of the feedback reduces to none though when it is used without the fork aware mutation see the baseline feedback and baseline lines which confirms that the fork diversifying feedback alone is not useful.
notice the number of reorgs in bitcoin is generally lower than that in ethereum.
this is because the pow consensus algorithm in bitcoin is much simpler than the pos consensus algorithm in ethereum and thus it is less likely to trigger reorgs in bitcoin.
diversity of reorgs we measure whether the forkdiversifying feedback increases the diversity of reorg types in test cases.
we use the reorg type definitions in figure a table i discrepancies found by forky .
platforms clients implications descriptions known status bitcoinbitcoin core denial of service incorrectly handled reorg failure repeats every block arrival preventing its verification no reported bitcoin core view split clients reject blocks containing segwit data in regression test mode yes n a bitcoin core crash double spending verifying a double spending block results in a valid confirmation or a crash yes n a bcoin view split inconsistent block verification selects different branches after a reorg no confirmed ethereumprysm view split prysm spec test fails to handle future attestations no confirmed prysm view split prysm spec test fails to correctly handle multiple steps at a slot border no confirmed prysm teku view split prysm and teku handle conflicting future attestations in a non deterministic way no confirmed teku view split teku s spec test fails to handle some future attestations no reported nimbus orphan thread nimbus spec test may face resource exhaustion when multiple test cases fail no reported when exploited a view split may lead to a permanent chain split or a temporary one that gives adversaries a window of opportunity to launch attacks see iii.
directly reported to developers.
a replacing blocks0510152025 replaced blocks replacing blocks0510152025 replaced blocks b size of replacing branch01020304050607080size of replaced branch size of replacing branch01020304050607080size of replaced branch forky w o fork diversifying feedback baseline mutation forky fig.
.
diversity of tested reorgs with f orky and baseline mutation in ethereum.
to analyze how diverse the tested reorg types are.
note that when it comes to the diversity of reorg types we focus on the fuzzing on ethereum not bitcoin since the effect of the fork diversifying feedback is shown to be marginal in bitcoin.
figure shows the diversity of several elements in the reorg type that are used in feedback during fuzzing.
the results on the left hand side of the figure are from a fuzzing campaign with the baseline mutation fuzzers while the results on the right hand side are from f orky thus including the forkdiversifying feedback .
figure a and figure b show how replacing blocks replaced blocks and size of replacing branch size of replaced branch are distributed in all the feedback used in each fuzzing campaign.
the full forky fuzzers generate a more diverse set of reorgs i.e.
covering more combinations of these two features than the one without the feedback.
quantitative comparison with other tools last we provide a quantitative comparison between f orky and other existing blockchain fuzzers fluffy and loki .
we emphasize that a comprehensive comparison between these fuzzers with distinct scopes and specialized targets is inherently challenging.
yet we offer our best effort for this comparison with several caveats attached.
in particular to compare forky with fluffy and loki we re implement forky for ethereum .
i.e.
pow ethereum before using go fuzz on go ethereum .
.
geth and denote it as f orky eth1.
for this particular comparison.
we run f orky eth1.
fluffy and loki for 6table ii performance comparison between forky fluffy and loki.
forky eth1.
fluffy loki statement coveragecore trie rlp core vm p2p unique reorg types n a forky re implemented for pow based ethereum .
for comparison.
may increase to depending on the block time setting.
hours3.
table ii compares the performance of the three fuzzers in terms of statement coverage and the number of unique reorg types.
we select five packages in ethereum .
and measure the statement coverage of each fuzzer to highlight the relative strengths of f orky eth1.
and the other fuzzers.
forky eth1.
achieves much higher coverage in the core andtrie packages compared to fluffy and loki.
this is a clear indication of the relative strengths of f orky in testing the central components of the blockchain system including block verification and fork handling logic.
fluffy tops in the core vmpackage with extensive fuzz testing on evm bytecode.
loki shows a substantially high coverage in thep2p andrlp a message serialization method packages because it performs extensive testing on peer to peer networking and serialization methods.
forky eth1.
tests unique reorganization types while loki and fluffy do not test any unique reorg types.
fluffy is shown to be totally incapable of triggering any reorgs because it uses a block data structure only as a container for transactions.
while loki triggers unique reorg types in this fair comparison with the same ethereum block time setting we find that loki can often trigger one but not more unique reorg type when the block time is set smaller than the default seconds.
the tested reorg type in loki is yet limited to a simplest reorg type where one block replaces another due to network delays.
this quantitative comparison shows that f orky is clearly more effective at testing forkhandling logic in blockchains than the existing state of theart blockchain fuzzers.
this shows that f orky s superior capability of testing fork handling logic complements other blockchain fuzzers ensuring thorough testing across all critical packages.
we attach the qualitative comparison with other fuzzers including tyr in x.
3tyr has not released its code rendering comparison challenging.blockchain input in time domaintimelogicalfork structuredbcabitcoin corebitcoin knotsbtcdbcoinprocessinputcbdaoutputchain viewsplit viewsbcoinblock d has a valid header but an invalid bodycbdacbdalegendsablock a a is parent of bmain chain rejected block dabd all other clientsview split occur fig.
.
case all bcoin clients switch their main chain to when the header of block dis validated and do notswitch it back when the rest of block ddata turns out to be invalid.
all other clients do not switch their main chain until block dis fully verified.
viii.
c ase studies we present one case study in bitcoin viii a and another in ethereum viii b .
we end this section with a discussion on the implications of our findings in ix b. a. case reorganization bug in bitcoin with f orky we have found a semantic bug that causes every bcoin client we test version .
.
.
.
and .
.
to have their main chains different from the ones in all other bitcoin clients.
the root cause of this discrepancy is a subtle inconsistent interaction between block verification and chainhead management in different bitcoin clients.
bcoin builds the longest chain of blocks i.e.
the main chain based on the validity of their headers only while other clients verify the entire block header and transactions before adding it to the main chain.
this shows that f orky successfully generates a test case with a fork structure that triggers this bug in certain bcoin clients while the state of the art differential testing tools fail to do so.
we illustrate detailed steps of this bug in figure .
b. case data structure bug in ethereum forky also discovers a subtle bug in ethereum s forkchoice logic that causes non deterministic fork choice results in prysm and teku clients when handling future attestations.
future attestations occur when attestations arrive early from future slots due to local time differences or network delays.
figure illustrates the impact of this bug.
when this bug is triggered prysm and teku produce non deterministic forkchoice results while lighthouse and nimbus produce deterministic results.
the root cause of this discrepancy is the different data structures used in these clients to handle future attestations.
the map data structure used in prysm and teku does not guarantee the order of arrived future attestations while queues used in lighthouse and nimbus guarantees their submission order.
the problem arise from the fact that the ethereum consensus specification does not offer a precise interpretation for handling future attestations.
ix.
d iscussion a. limitations of forky while f orky has shown its effectiveness in testing forkhandling logic in bitcoin and ethereum it still has a limited blockchain input in time domaintimelogicalfork structurelighthouseprysmtekunimbusprocessinputoutputchain viewsplit viewsprysm tekulegendsablock a a is parent of bmain chain slot boundary vote attestation voting to aearly arrived vote x ab lighthouse nimbusview split may occurxdouble voting attestation x and y from the same validatoracbaearly arrivedcbacbacbanon deterministic fork choiceoracbxy xyyxfig.
.
case when double voting attestations xandyfrom a same validator arrive earlier clients that use queue switch to .
prysm and teku produce non deterministic fork choice results because they usemap while others use queue for handling future attestations.
scope of fuzzing capability features and target blockchain systems.
we discuss these limitations in this section.
limited fuzzing capability.
there are a few fork resolution scenarios we have not covered in f orky mainly due to the practical resource limitations.
for example discrepancies that are triggered only when a fork straddles two or more epochs are not covered in f orky because it would require too many blocks in an input.
we also have used only up to validators for a committee for each epoch because we cannot simulate all 890k validators for our tests due to resource constraints.
limited features.
we focus on detecting errors in consensus algorithms and particularly their fork resolution mechanisms.
our tool may therefore miss errors in other parts of the blockchain client implementations.
for example f orky is not designed to detect bugs in the crypto libraries peer topeer network protocol implementations data parsing etc.
limited experimentations on other blockchains.
we have implemented and tested f orky on bitcoin and ethereum .
and ethereum .
the model consensus algorithms for many other pow pos blockchains.
therefore many copycats of bitcoin and ethereum such as litecoin and dogecoin would require near zero effort for f orky to be applied.
different pow and pos consensus algorithms may require custom changes to f orky .
forky s design however is based on the general principles of pow and pos consensus algorithms and thus we believe that f orky can be applied to other blockchains without forklift changes.
to be specific our fork centric fuzzing strategies may need to be re implemented based on the domain knowledge of each target blockchain system e.g.
re defining the structure of block transaction or consensus messages while the core of f orky can be reused.
b. implications and responses many findings from f orky have been acknowledged by the developers.
for example the bcoin developers have acknowledged the bug viii a through private communication.
the prysm and teku teams have also acknowledged that the handling of future attestations in prysm is different from the two other clients.
some have not been acknowledged yet due to the lack of timely responses from the developers.
so far developers of the affected clients tend to refuse to fix the discrepancies as they consider them to be not critical or exploitable at present.
two most cited reasons are the discrepancies require someone to invest a significant amountof pow power to craft a malicious input to trigger them or the discrepancies are triggered only when validators are willing to be slashed e.g.
by sending double voting attestations .
yet we argue that these discrepancies are better to be fixed regardless of their exploitability at present for two reasons.
first it is now in the realm of possibility that some adversaries with mining or staking power would risk their power to cause these discrepancies.
there is a growing number of incidents where rational miners or validators are willing to risk their pow or pos power to gain other sources of profit such as exploiting mev opportunities e.g.
some bitcoin miners intentionally created invalid blocks in both the mainnet and testnet and some more than so far validators have been slashed for attestation rule violations .
bugs like case and case in this section could be triggered by such miners or validators.
second perhaps more fundamentally a latent bug that is unexploitable at present because of external constraints e.g.
particular input sanitization placed currently is essentially a latent bug that may be exploitable in the future when the codebase of the affected clients propagates to other projects or when the constraints are relaxed due to code changes.
blockchain codebases typically have regular updates and are often used as a reference implementation for other blockchain projects .
c. testing framework in ethereum one unexpected result from our evaluation is that there are not significantly many bugs in ethereum s fork resolution mechanism compared to that in bitcoin even though the former is much more complex than the latter.
we believe that this is because ethereum has practiced more systematic testing than bitcoin.
ethereum s official implementation spec.
bitcoin does not have a formal specification of their client implementations .
instead they have a reference implementation i.e.
bitcoin core that is considered as the de facto specification.
ethereum in contrast has improved the state of the art by providing an official specification of its client implementations written in python called pyspec .
when thirdparty developers implement their own ethereum clients they refer to this implementation spec to make sure that their implementations are consistent with the official one.
spec test.
in addition to having an official implementation spec ethereum has developed a systematic testing suit called spec test to test its diverse client implementations.
the spec test is a collection of test cases that are designed to test the client implementations.
while the spec test is a great tool for testing ethereum clients it supports only manual testing .
our contribution with f orky provides useful complementary tools to the spec test by automating the testing process and diversifying the testing scenarios.
x. r elated work we discuss related work to f orky the first fork state aware differential fuzzing for pow and pos blockchains.table iii comparative analysis of forky tyr loki and fluffy .
forky tyr loki fluffy differential testing yes no no yes feedback on code coverage yes yes no yes state awareness yes focusing on forks limited coarse grained no linear chain structure aware yes yes no yes fork structure aware yes no no no testing of forks comprehensive occasional occasional no ability to test rare forks yes no no no supported protocol types pow pos pow bft pow bft pow states are confined to selected state variables the number of elected leaders local transaction pool local blockchain data and the height of the chain.
states are defined by the observed consensus message types resulting in coarse grained client states.
bft stands for byzantine fault tolerant protocols such as pbft diembft .
fuzzing blockchain systems.
researchers have applied fuzzing to find bugs in the blockchains.
bitcoin core developers implement a grey box fuzzer and participate in an open source fuzzing framework called oss fuzz by google .
ethereum clients have applied fuzzing on a functional level with structure aware inputs .
some of the earliest studies are evmlab and evmfuzzer which use differential fuzzing to find discrepancies in the evm states between different ethereum clients.
a work chronos focuses on finding timeout bugs by fuzzing the deep priority transient delay in the distributed system.
while these efforts may find certain types of bugs such as crash and memory corruption they lack a specific focus on finding semantic bugs in consensus implementations by testing fork handling logic.
fuzzing blockchain consensus.
a few recent studies such as tyr loki and fluffy try to find bugs in blockchain consensus implementations.
while these fuzzing tools are shown to be effective they are different from f orky in several aspects as illustrated by our qualitative comparison in table iii.
in terms of fuzzing types f orky and fluffy are differential testing tools whereas tyr and loki test individual clients.
also f orky tyr and fluffy use code coverage feedback whereas loki does not.
additionally the types of blockchain protocols supported vary among these tools.
tyr and fluffy are only capable of recognizing the linear chain structures i.e.
transactions and blocks form a linear chain but unaware of how chains form forks and how forks are resolved.
therefore tyr and loki can only occasionally test forks relying on rare lucky circumstances see table ii .
xi.
c onclusion one unique feature of blockchain consensus algorithms is resolving conflicting inputs according to clearly defined forkchoice rules.
testing this highly critical feature in multiple client implementations has been a challenge in existing work.
with our tool f orky we show that automated testing of forkhandling logic is feasible and effective in finding implementation discrepancies in pow and pos blockchains.
acknowledgment this research was supported by the msit ministry of science and ict korea under the itrc information technology research center support program iitp rs supervised by the iitp institute for information communications technology planning evaluation .