a catalog of micro frontends anti patterns 1stnabson paiva souza da silva federal university of amazonas manaus am brazil nabson.paiva icomp.ufam.edu.br2nderiky rodrigues federal university of amazonas manaus am brazil eriky.rodrigues icomp.ufam.edu.br3thtayana conte federal university of amazonas manaus am brazil tayana icomp.ufam.edu.br abstract micro frontend mfe architectures have gained significant popularity for promoting independence and modularity in development.
despite their widespread adoption the field remains relatively unexplored especially concerning identifying problems and documenting best practices.
drawing on both established microservice ms anti patterns and the analysis of real problems faced by software development teams that adopt mfe this paper presents a catalog of mfe anti patterns.
we composed an initial version of the catalog by recognizing parallels between ms anti patterns and recurring issues in mfe projects to map and adapt ms anti patterns to the context of mfe.
to validate the identified problems and proposed solutions we conducted a survey with industry practitioners collecting valuable feedback to refine the anti patterns.
additionally we asked participants if they had encountered these problems in practice and to rate their harmfulness on a point likert scale.
the survey results revealed that participants had encountered all the proposed anti patterns in real world mfe architectures with only one reported by less than of participants.
they stated that the catalog can serve as a valuable guide for both new and experienced developers with the potential to enhance mfe development quality.
the collected feedback led to the development of an improved version of the anti patterns catalog.
furthermore we developed a web application designed to not only showcase the anti patterns but also to actively foster collaboration and engagement within the mfe community.
the proposed catalog is a valuable resource for identifying and mitigating potential pitfalls in mfe development.
it empowers developers of all experience levels to create more robust maintainable and welldesigned mfe applications.
index terms micro frontends microservices anti patterns software architecture empirical study i. i ntroduction as a monolithic application grows it becomes challenging to scale due to limitations like technology constraints the necessity for vertical scaling only and the need to reboot the entire application with each deployment .
to address these issues developers are adopting the microservice architectural style to create autonomous distributed and loosely coupled services .
this architecture enables teams to work independently reducing the development time for new features.
however different teams often still need to share the same codebase for the presentation layer.
micro frontends offer a solution by extending the principles of microservices to the frontend thereby enabling independent testing development and deployment of frontend components .
this architectural style breaks down a frontend application into smaller manageable slices.
many companies such as sap springer zalando newrelic ikea starbucks and dazn have successfully adopted the micro frontend architecture .
over time software architecture can deteriorate due to developers insufficient understanding of the specific architectural style .
this issue is particularly critical in micro frontend architecture as there is no well defined method for evaluating this type of architecture.
therefore we propose a catalog of anti patterns for micro frontends to preserve architectural integrity and assist developers in making wellinformed decisions.
anti patterns can address emerging issues common mistakes poorly implemented solutions misapplied best practices and deviations from established process models .
the anti patterns were defined based on microservices antipatterns given their similarity to micro frontends and the analysis of real problems faced by software development teams that adopt micro frontends.
each anti pattern includes a practical example to aid in understanding the associated problem.
to evaluate the issues and solutions associated with each anti pattern we conducted a survey to gather feedback from industry practitioners with experience in micro frontend development.
we assessed the severity of each anti pattern on a point likert scale ranging from not harmful to extremely harmful .
following a code reliability thematic analysis of the survey s qualitative responses we refined the catalog to generate its improved version incorporating the practitioners feedback.
we used cohen s kappa as a measure of agreement between two coders to ensure coding reliability.
the survey results revealed that all anti patterns have been observed in real world architectures with only one reported by less than of industry practitioners.
our findings indicate that out of anti patterns have a median harmfulness score above including and scores.
through qualitative feedback we identified that participants emphasized that the catalog serves as a guide for both new and experienced developers.
they highlighted its ability to address numerous real world problems encountered in daily work with micro frontends underscoring its potential to enhance development quality significantly.
based on participant feedback to improve the problems and solutions associated with each anti pattern we generated an improved version of the catalog which will be presented in this paper.
additionally we developed a web application to showcase all anti patterns allowing practitioners to collaborate on the catalog and propose new anti patterns.arxiv .19472v4 mar 2025the key contributions of this paper are a catalog of micro frontend anti patterns inspired by microservices antipatterns an empirical validation of these anti patterns with industry practitioners and a collaborative micro frontends anti patterns repository to facilitate knowledge sharing within the software development community.
by bridging the gap between academic research and industry practice this work aims to empower developers with actionable insights to avoid common pitfalls and enhance the overall quality of micro frontend applications.
ii.
b ackground this section delves into the fundamental principles of microservices micro frontends and anti patterns.
it provides readers with the necessary knowledge to appreciate the context and significance of our work.
a. anti patterns anti patterns are recurring design practices choices or solutions to common problems.
despite appearing reasonable and effective they lead to negative consequences and undermine the system s overall quality .
an anti pattern is similar to a pattern but instead of providing a practical solution it offers an approach that appears to be a solution on the surface.
however it ultimately leads to more problems .
while a problem and its optimal solution characterize patterns antipatterns involve two solutions .
the first solution is a commonly occurring solution that generates overwhelmingly negative consequences.
the second solution is a commonly occurring method in which the anti pattern can be resolved and reengineered into a more beneficial form.
there are three forms to define anti patterns degenerative form the most basic one is a textual description without any structure template or separate content sections for various aspects of the pattern mini antipattern a more structured approach consists of name problem and solution and formal definitions including the full antipattern template and the laplante neil structure consists of multiple fields detailing various dimensions of the anti pattern.
in this paper we will use the mini antipattern format due to its simplicity in proposing new anti patterns while maintaining a structured approach.
b. microservices microservice is an architectural style presented as an alternative to monolith architectures .
lewis and fowler first defined microservice as an approach to developing a single application as a suite of small services each running in its process and communicating with lightweight mechanisms.
a service is a self contained loosely coupled software unit designed to perform a specific business function.
this modular design ensures each service has a well defined and focused set of responsibilities promoting maintainability and scalability .
microservices enable technology heterogeneity autonomous teams independent deployment independent scale independent testing and easy experimenting and adoption of new technologies .
microservices anti patterns are well defined in scientific literature.
some of them can be correlated with corresponding micro frontends anti patterns owing the shared characteristics between both architectural styles cyclic dependency hub like dependency the knot or knot service microservice greedy nano service mega service wrong cuts no api versioning no devops tools or continuous integration ci continuous delivery cd microservices as the goal lack of microservice skeleton and golden hammer .
these anti patterns formed the basis for proposing micro frontend anti patterns.
c. micro frontends the term micro frontend was first coined by thoughtworks in as an architectural style inspired by microservices architecture.
the main idea is to decompose a monolithic frontend application into smaller parts that can be developed deployed and updated independently promoting greater flexibility and maintainability .
micro frontend mfe can also be considered an organizational approach.
the application is divided into vertical slices built from the database to the user interface and run by a dedicated team .
in an mfe architecture the web application integrates different features or business sub domains and each software team should have only one domain to handle .
many companies adopted the mfe architecture such as sap springer zalando newrelic ikea starbucks and dazn .
mfes share the main principles benefits and issues of microservices .
the motivations are development scalability and codebase growth and the benefits include support for different technologies autonomous cross functional teams development deployment management independence and better testability.
however the primary drawbacks are increased payload size complex monitoring and debugging state management and duplicated code .
each mfe implements a set of screens and fragments.
fragments are reusable user interface ui components that can be combined to form screens across different mfes .
some fragments might need context information but the team including the fragment in their mfe does not have to know the fragments state or implementation details.
the mfes must integrate a coherent application to deliver a unified user experience ux .
achieving this requires developers to make informed decisions regarding the composition communication and routing between the mfes.
the first decision is about composition the process of requesting the fragments and putting them in the correct slots in a screen .
there are three approaches to composing mfes server side edge side and client side.
client side composition csc an application shell loads microfrontends inside itself.
an application shell is technically represented by an html file alwayspresent during the user session containing a small javascript code for loading and orchestrating different mfes .
csc needs mfes specific frameworks such as single spa qiankun and garfish or with frameworkless technologies like webpack module federation iframes and web components.
edge side composition esc the web page is assembled at the content delivery network cdn level using an xml based markup language called edge side include esi .
one of the drawbacks of this implementation is that esi is not implemented in the same way by each cdn provider which can lead to many refactors and new logic implementation.
server side composition ssc the origin server is composing the view by retrieving all the different mfes and assembling the final page.
it can happen at runtime or compile time .
it is the simplest approach because it enables the development of mfes as packages .
however this approach does not meet some of the main principles of mfe such as technology agnosticism and independent delivery.
once the fragments are composed into a screen the team needs to decide how the mfes will communicate with each other.
effective communication outlines how the screen and fragments interact to deliver a seamless user experience ux .
geers defines three primary forms of communication parent to fragment fragment to parent and fragment to fragment.
parent to fragment communication a change in the screen is propagated down to one or more fragments so they can update themselves.
this form is also called parent child communication.
fragment to parent communication a change on a fragment sends a message to the screen so it can update itself.
this form is also called child parent communication.
fragment to fragment communication a change on a fragment sends a message to one or more fragments composed on the same screen.
this form is also called child child communication.
the final decision involves routing which delineates the navigation from one view to another .
usually hyperlinks are necessary to navigate between screens.
when adopting csc the application shell manages routing which knows all routes and mfes mapping urls to the correct mfe.
iii.
m ethodology figure illustrates the process of proposing and refining the mfe anti patterns which we detail in this section.
initially we used the systematic literature review slr of cerny et al.
as a basis for identifying microservices antipatterns.
this slr provided a comprehensive catalog of disjoint anti patterns derived from originally identified anti patterns for microservices.
drawing upon the microser vice anti patterns identified by cerny et al.
and further explored in taibi et al.
tighilt et al.
parker et al.
and bogner et al.
coupled with an analysis of real world problems faced by mfe development teams we proposed a catalog of mfe anti patterns.
each anti pattern follows the mini antipattern format name problem and solution and includes an example to illustrate the problem within an mfe context.
the initial proposal of the anti patterns can be found in our supplementary material section x .
we classified the anti patterns into four categories intra fronted category considers a single mfe component and its design.
inter frontend category considers the structural division and communication involving two or more mfes.
operations category related to the operational practices and continuous maintenance of the application.
development category related to the development team and their decisions around the architecture.
fig.
.
bpmn diagram illustrating the process we followed to propose and refine the mfe anti patterns.
to evaluate the proposed anti patterns we conducted a survey that included both open and closed questions.
the intended audience for the survey included software industry practitioners with experience in mfe development.
this approach allowed the validation of different aspects of the anti patterns by incorporating the insights of practitioners specialized in the mfe field.
we also included a consent form as part of our survey instruments allowing participants to provide their consent to participate.
we assured participants that their participation was voluntary and that they could withdraw at any time.
all collected data was anonymized ensuring privacy and enabling participants to share valuable insights without concern.
our survey comprised three sections and can be found in our supplementary material section x .
the survey s first section aims to understand the level of practitioner experience and the role of participants in the context of mfe development ensuring that the feedback provided comes from practitioners with practical knowledge in this area.
additionally the questions allowed the characterization of each participant.
the questions focused on determining whether the practitioners currently work with mfe theirexperience in this area quantified in years and their role in mfe related projects.
the survey s second section aimed to validate each of the anti patterns proposed in the catalog.
this involved analyzing each anti pattern through a series of questions designed to verify whether the descriptions of the problems and proposed solutions were clear and understandable to participants determine if the proposed solution effectively addresses the problem described in the anti pattern and if not gather alternative solutions identify the practical occurrence of the anti pattern in participants projects and assess participants perception of the anti pattern s impact on mfe projects by assigning a harmfulness value.
to define the harmfulness value of each anti pattern we used a point likert scale based on taibi et al.
where means not harmful and indicates extremely harmful .
each page of this section included the following questions to evaluate each anti pattern individually is the anti pattern problem clearly stated?
if you disagree please provide a description of what is not clear is the anti pattern solution clearly stated?
if you disagree please provide a description of what is not clear does the proposed solution address the problem presented in the anti pattern?
in case you have a different suggestion on the problem solution please provide a description have you ever encountered this problem in any project you have previously worked on or are currently working on?
how harmful do you think this anti pattern problem is?
the third section of the survey enabled participants to offer insights based on their practical experience providing additional feedback and suggestions for improving the catalog.
the questions were designed to identify any mfe related issues not covered in the catalog assess the potential impact of the catalog on the quality of mfe solutions and gather recommendations for enhancing the catalog.
after collecting participants responses to the survey we conducted a quantitative analysis to identify the most common anti patterns and calculated the median harmfulness score for each.
to further investigate the harmfulness scores we employed several statistical tests.
first we used the shapirowilk test to determine whether the score samples for each anti pattern were normally distributed.
since only half of the samples followed a normal distribution we opted for nonparametric tests.
as the same participants rated different antipatterns we treated the samples as dependent and selected the friedman test which is suitable for dependent samples.
we applied the av post hoc dunn test to compare pairs of medians as it is commonly used following friedman test when significant differences are found.
for the qualitative feedback we performed a thematic analysis grounded in coding reliability .
thematic analysis allows for organizing and categorizing feedback in a structuredmanner which helps identify recurring patterns themes .
this approach aids in understanding participants perspectives better and directing improvements based on the specific objectives of each piece of feedback.
we assessed intercoder reliability icr between two authors to ensure the robustness of the thematic analysis.
the second author was included to evaluate the consistency and objectivity of the coding process.
the first author conducted an initial open coding of all responses resulting in the definition of eight themes.
subsequently the second author independently applied these themes to the same quotations.
to measure agreement between the authors we calculated cohen s kappa and resolved any discrepancies through discussion to reach a consensus.
we used practitioners feedback to refine the catalog and finalize the anti patterns.
drawing on the collaborative repository model proposed by bogner et al.
we developed a web application1to present all the anti patterns.
the application was built with reactjs and is hosted on github pages making it publicly accessible.
community members can contribute to the catalog by submitting pull requests pr to the github repository2folowing the contribution guidelines outlined in the repository3.
all anti patterns are stored in thesrc anti patterns folder4 with each json file corresponding to a specific anti pattern.
thanks to github actions changes to the codebase are automatically reflected in the application when a pr is merged.
iv.
r esults in this section we present the analysis of the results obtained from the survey responses.
we directly contacted a total of practitioners to participate in the survey.
however due to the open access nature of the survey link precise control over participant recruitment was not feasible.
as a consequence we could not determine an exact response rate .
a total of practitioners volunteered to participate in the survey.
before responding each participant signed a consent form ensuring the confidentiality of the information.
on a brief overview of the participants characterization of the participants are currently involved in mfe software projects and have more than two years of experience working with mfe as well.
a total of of the subjects identified themselves as fullstack developers as frontend developers as software architects and as mobile developers and se team leaders each.
we assigned each participant an identifier ranging from p1 to p20.
more than half of the participants work at large companies with over software engineers and projects involving mfes and ms with engineering teams structured as independent units.
the remaining participants work on other software companies but in smaller projects.
this diversity ensures the contributing.md anti patterns index.tstable i overall results from quantitative analysis ranked by harmfulness score anti pattern problem clearly stated ratesolution clearly stated ratesolution addresses the problem rateap seen in practice rateharmfulness no ci cd .
.
.
.
no versioning .
.
.
.
common ownership .
.
.
.
cyclic dependency .
.
.
.
hub like dependency .
.
.
.
knot micro frontend .
.
.
.
lack of skeleton .
.
.
.
micro frontend as the goal .
.
.
.
mega frontend .
.
.
.
micro frontends greedy .
.
.
.
nano frontend .
.
.
.
golden hammer .
.
.
.
identified anti patterns are applicable across different scales and organizational structures.
the participants full characterization is available at our supplementary material section x .
subsection iv a summarizes the quantitative results whereas subsection iv b presents the thematic analysis findings identified from the collected qualitative data.
a. quantitative analysis the table iv summarizes our quantitative results which we ranked according to the harmful score values.
column presents the titles of the anti patterns evaluated in the survey.
columns and report the participants agreement rates regarding the clarity of the problem presentation and the proposed solutions of the anti patterns.
column presents the participants agreement rates regarding the effectiveness of the proposed solutions for the problems identified in the antipatterns.
column shows the percentage of participants who have encountered the problems described in the anti patterns in their practitioner experience within the software industry.
column presents the median values of harmfulness attributed to the anti patterns by the participants.
regarding the clarity of the problems and solutions presented in the anti patterns the results show that the participants had a thorough understanding as demonstrated by the high values in columns and which range from up to .
moreover the high values presented in column indicate a positive efficacy of the solutions on which a large majority of participants recognized the proposed solutions as effective means of addressing the issues posed by the anti patterns.
the values in column indicate that practitioners frequently encounter the anti patterns cyclic dependency knot frontend hub like dependency mega frontend and no ci cd in software projects.
notably seven of the remaining eight antipatterns were reported by more than of participants highlighting their common occurrence as well.
the only antipattern observed by less than of participants is the nano frontend in contrast to the mega frontend.
this suggests that practitioners are more likely to create larger mfes than smaller ones.
given the limited sample size we assessed the reliability of the harmfulness scores using several statistical tests.
first weapplied the shapiro wilk test with a confidence level to determine if the samples were normally distributed.
the test indicated that only half of the anti patterns namely cyclic dependency knot micro frontend nano frontend mega frontend and golden hammer follow a normal distribution.
fig.
.
boxplot illustrating the harmfulness ratings for each anti pattern.
we then used the friedman test to evaluate whether there were statistically significant differences in the harmfulness scores.
the friedman test yielded a p value of0.
.
which strongly suggests that there are statistically significant differences in harmfulness scores among the antipatterns.
subsequently the post hoc dunn test revealed that only two anti patterns exhibited statistically significant differences compared to others golden hammer differed from hublike dependency no ci cd lack of skeleton and common ownership and micro frontend as the goal differed from hub like dependency.
the implementation of the statistical tests and their results are available in our supplementary material section x .
while dunn s test did not indicate significant differences between most pairs the boxplot visualization figure revealsfig.
.
identified themes during the thematic analysis with accompanying example quotations.
the red themes relate to suggested improvements the green themes represent new proposals and the blue themes highlight insights and recommendations for using the catalog.
notable trends.
no ci cd is perceived as significantly more harmful than other anti patterns as evidenced by its higher median score.
conversely golden hammer is considered the least harmful with the lowest median harmfulness score .
these findings suggest that while statistical significance was not universally achieved there is a strong perception that the absence of ci cd is particularly harmful whereas the reuse of familiar technologies is seen as acceptable.
b. thematic analysis based on the open coding quotations the first author defined eight themes figure .
subsequently the second author independently categorized the same quotations using the established themes.
on measuring the icr we obtained a cohen s kappa with a value of .
.
according to landis and koch this is considered an almost perfect score highlighting the reliability of our coding process and the robustness of the identified themes.
in the following paragraphs we present a brief explanation of each category and its main findings.
the full thematic analysis is available in our supplementary material section x .
commendations to the catalog compliments to the catalog p2 acknowledged the novelty of the anti patterns due to the lack of ones that focus on the mfe development as stated in the term and technology is fairly new and such patterns are not well established in the software community yet.
p5 praised the catalog for addressing practical issues that practitioners face when working with mfe as commented in this catalog highlights several real world problems encountered in the day to day work with micro frontends.
how to use the catalog how the catalog can be used to improve the development and maintenance of mfe architectures p2 highlighted that the catalog may provide essential guidance for best practices and avoidables in mfe development as stated in it will serve as a guide for some dos and donts that are missing in the micro frontends world.
p7 commented on the practical utility of the catalog in educating and integrating new team members in mfe software projects as stated in training new team members and onboarding them to micro frontend projects.
p9 observed that the catalog may help in whether to use or not mfe architecture in think about architecture decisions and the decision to use micro frontends architecture or not.
improvements to examples proposals for new examples or enhancements to the presented ones for cyclic dependency p4 suggests that the example should include all necessary dependencies to fully close the cycle as noted the example only states a dependency between a and b but not another that would close the cycle between b and a. for hub like dependency p4 provided a practical scenario that emphasizes the importance of robust error handling in a main banking screen that has charts lists and balances.
if this screen implements its own data fetch function that fails and renders the screen useless then it is a problem.
improvements to problem definition enhancements to anti patterns problems definitions p8 suggested the need for a clearer definition in micro frontends greedy once they had difficulty in distinguishing it from the nano frontend or mega frontends anti patterns as stated in i can t separate this anti pattern from nano or mega frontends.
for common ownership p15 pointed out that small teams can also benefit from characteristics inherent of software modularization as mentioned in naturally larger software involves more people but i believe small teams can also benefit from software modularization such as separation of layers and responsibilities observability and maintainability.
improvements to solutions enhancements to antipatterns solutions p2 suggested that the knot micro frontend anti pattern should clearly define the difference between a good communication pattern and a bad one as stated in solution could state what is a good communication pattern vs a bad one.
for hub like dependency many participants suggested that the solution of avoiding aggregator screens does not address the problem correctly because in the context of mfe architecture screens will include many mfe fragments as p2 emphasized in it is inevitable to have aggregators and p20 in but not use it goes against the main idea of the mfe to be contextually segregated.
p5 emphasized that the solution for nano frontend will rely on the organizational context it is inserted in as stated the solution here will depend entirely on the organizational context.
improvements to the catalog enhancements to the catalog as a whole most of the participants focused their suggestions for improving the catalog adding visual aids for enhancing the readability of the catalog as p4 suggests in i would use some flow charts to exemplify most of the antipatterns and make it more readable and p18 complements in add some diagrams and images help to understand some examples.
new anti patterns proposals of new anti patterns p2 discussed the importance of choosing between build time and runtime integration based on team and user needs as stated in there are mainly two ways to integrate micro frontends build time and runtime.
the decision on which to adhere reflects deeply in the teams and users needs more than the technical pros and cons each of them offer.
p7 highlighted that data persistence on mfes may become an anti pattern due to the issue when different mfe manage the state as commented poor state management data persistence on mfes when each frontend manages the state independently.
lastly p8 suggests that inconsistent user experience is an existing issue in mfe.
proposal of new solutions proposals of different solutions for specific anti patterns for mega frontend p4 suggested that better discussions between the product team and the development team could help define when features should be treated as different products as stated in lack of communication between the product team and the development team.
it should be well discussed between the two teams to define when two or more features are different products.
for golden hammer p7 proposed adopting hybrid technology approaches for solving the problem as commented in adopting a hybrid technology approach supported by a common facade such as a backend for frontend bff layer and using feature flags to manage gradual migration and experimentation might be a better approach.
v. m icro frontends anti patterns in this section we present the improved version of the mfe anti patterns including refinements after analyzing practitioners feedback.
due to the page constraint we omitted the examples of the anti pattern.
these examples are available in our supplementary material section x and at our web application5.
cyclic dependency category inter frontends problem two or more mfes directly or indirectly depend on each other resulting in high coupling between screens and fragments compromising mfes independence and modularity.
thus changes in one mfe require coordination with the others.
circular dependencies lead to challenges in a system s maintenance and evolution compromising agility and the ability to scale developments efficiently.
solution high coupling between mfes can be effectively mitigated through event based communication which removes the need for direct dependencies between mfes.
instead interactions are handled indirectly via a centralized event store.
on implementing the publish subscribe pub sub pattern an mfe can publish an event to the browser allowing other mfes to subscribe and respond when the event occurs.
to ensure consistency and reduce errors it is recommended to centralize event definitions in a shared library.
b. knot micro frontend category inter frontends problem a knot is composed of three or more mfes whose communication with each other uses a context specific interface.
this means that navigation and data exchange between screens and fragments heavily depend on the unique context of each mfe involved.
adding new mfes exacerbates the problem as the number of mfes grows the interface complexity increases due to the introduction of new contexts creating a highly coupled knot that becomes difficult to maintain and integrate new functionalities.
solution a practical solution to address the problem of knots is to implement domain driven communication interfaces that are both generic and flexible.
these interfaces should define a contract based on the domain model specifying the essential fields required for each mfe to function correctly and interact with others.
on designing new fields or attributes it is essential to ensure their consistency and reusability and minimize tight coupling so other mfes can utilize them.
we recommend including a generic field in the interface containing a list of objects with standard properties such as label value and type allowing each mfe to display data on the screen without needing to understand the specific meaning or context of the values.
this approach reduces coupling between mfes while maintaining benefits such as modularity scalability and adaptability to new requirements.
c. hub like dependency category inter frontends problem a screen of an mfe integrates fragments from several other mfes becoming a central point of interdependence.
any issue occurring in the main screen or one of its fragments can affect all other fragments present on it.
solution to prevent a single fragment failure from crashing the entire main screen the screen should be kept as simple as possible and each fragment should implement robust errorhandling mechanisms.
this can be achieved by implementinga strategy where uncaught errors within a fragment gracefully degrade its functionality displaying a user friendly fallback message.
this approach ensures that users are informed of the issue without hindering their interaction with the remaining functionalities on the main screen.
d. nano frontend category intra frontends problem the frontend decomposes into numerous small mfes with few screens or fragments.
small mfes do not justify the cost of their maintenance.
furthermore the presence of nano frontends can lead to issues of high coupling and the manifestation of other anti patterns such as cyclic dependency.
solution the issue of nano frontends arises when the definition of boundaries is inadequately and excessively granular.
adhering to domain driven design principles is necessary to ensure an effective decomposition of mfes.
therefore the development team must work closely with the product team to gain a deep understanding of the domains and reflect them accurately in the architecture.
to solve this issue the architecture must be redesigned by grouping mfes with the same domain is necessary.
for minor variations within a domain consider using templates or component libraries.
this approach avoids creating a separate mfe for each slight variation promoting efficiency and code reuse.
e. mega frontend category intra frontends problem decomposing the architecture into a few mfes encompassing numerous screens and fragments manifests this anti pattern.
the mfe inherits the challenges of a monolithic frontend such as difficulties in testing slow builds and deployments high coupling between its components lack of modularity and limited scalability.
solution to avoid this problem the development team must work closely with the product team to gain a deep understanding of the domains and reflect them accurately in the architecture.
to fix this issue the team should reevaluate the architecture and divide the mfes into more granular units separating functionalities into smaller and specialized mfes based on domains.
this approach helps reduce complexity enhance maintainability and foster a modular and scalable architecture.
f .
micro frontend greedy category intra frontends problem when a developer is uncertain about creating a new mfe the common practice is to opt for its creation.
whenever a need arises to develop a new set of screens or fragments a new mfe is instantiated.
this can lead to an explosion in the number of mfes making the system difficult to understand and increasing the likelihood of both nano and mega frontends emerging.
solution to determine where to implement a new feature composed of a set of screens and or fragments the domain of the new feature must first be defined.
if it falls within thedomain of an existing mfe it should be implemented there.
in this case a summary of all mfes their contexts and domains can help identify the best fit for the new feature.
if it belongs to a brand new domain one or more mfes should be defined based on the domain definition.
establishing well defined domains relies on collaboration between the development and product teams to define boundaries accurately.
g. no ci cd category operations problem the company lacks an automated continuous integration ci and continuous delivery cd pipeline so developers must manually execute tests and perform deployments.
this manual process becomes burdensome especially with the potential existence of multiple mfes.
it increases development time reduces productivity and raises the risk of errors in the production environment.
solution implement an automated and replicable ci cd process that extends for new mfes ensuring they will have automated test execution and deployment consistently and efficiently.
this should be part of the definition of done dod of the architecture.
h. no versioning category operations problem the mfes are not versioned.
small and large changes can impact the integration between different mfes and cause errors.
consequently the mfes become less independent requiring coordinated deployments.
solution adopting a versioning approach like semantic versioning is essential to ensure that changes do not impact functioning versions.
for example consider a fragment that is used in screens across different mfes in a client side rendering scenario.
without versioning any change to the fragment s parameters or return values could break the interaction on all the screens it integrates with.
however with versioning such updates would not impact the current versions used by other mfes as they can continue to request the previous version of the fragment and update at their convenience.
this approach helps maintain a stable environment and minimizes disruptions caused by updates.
i. lack of skeleton category operations problem no skeleton or predefined boilerplate is available as a base for creating new mfes.
this leads to the creation of mfes from scratch or based on an existing mfe and inheriting its issues.
the consequences include wasted time increased risk of errors duplicated code across mfes and a need for more standardization in development.
solution whenever a new technology is used to implement an mfe the development team must create a repository containing the necessary base code known as a boilerplate.
the boilerplate should enable the creation of new mfes with the same technology by simply cloning it.
keeping the boilerplate updated with new design patterns and library versionsis crucial.
additionally the development team should create comprehensive documentation detailing the entire process of creating a new mfe regardless of the technology.
this documentation should provide instructions on adding automated ci cd integrating the mfe into the existing system and addressing other relevant aspects.
j. common ownership category development problem a single team is tasked with managing all mfes which can occur either due to a lack of team division or when teams are segmented based on technical aspects such as data frontend and backend.
however one of the key benefits of mfe architecture is independence so adopting mfe architecture without distinct teams to operate independently negates this advantage.
solution context should be the defining factor when structuring development teams.
therefore defining the boundaries of teams and mfes is essential according to domain driven design so a team will be responsible only for mfes within its domain.
creating shared libraries can facilitate boundary definition and promote greater team independence.
k. golden hammer category development problem all mfes utilize the same technology even if it does not meet the specific needs of each mfe.
it happens due to developers familiarity with only one specific technology.
this approach limits the architecture failing to take advantage of the benefits of the possibility of a heterogeneous architecture which is one of the main attractions of adopting mfes.
solution to choose the most suitable technology that addresses the specific challenges of each mfe which includes adopting the correct programming languages frameworks and libraries during its development.
when uncertain about a particular technology conducting a proof of concept poc can validate its suitability.
testing new technologies through pocs helps validate their suitability without compromising the establishment of standardized patterns within the company.
however it s important to note that increasing the variety of technologies can increase the complexity of the architecture.
l. micro frontend as the goal category development problem adopting the mfe architecture in inappropriate contexts can lead to more issues than benefits especially in systems with few screens and low complexity or in companies lacking a sufficient number of developers to create dedicated teams for different application domains.
in such situations the maintenance costs of the architecture may outweigh the expected benefits making its implementation unfeasible.
solution software teams must consider carefully different aspects of adopting mfe architecture.
considering the system s complexity the feasibility of maintaining automated ci cd pipelines and the team s restructuring according to different domains is necessary.vi.
d iscussion the proposed mfe anti patterns are closely aligned with their ms counterparts reflecting the inherent similarities between these architectural styles.
given the frequent evolution of software systems from monolithic architectures to ms and subsequently to mfe anti patterns related to development and operation like no ci cd and common ownership are likely to persist in mfe if they were previously encountered in ms. we observed that the proposed anti patterns have varying impacts on developers and end users.
the no versioning and hub like dependency anti patterns significantly affect end users potentially causing application crashes.
the golden hammer anti pattern has a moderate impact on both end users and developers stemming from poor experiences due to inappropriate technology choices.
the remaining anti patterns primarily impact developers complicating architecture maintenance and evolution though they have a low direct impact on end users.
by accessing our online catalog developers can learn how to avoid bad practices when working with mfe from an organizational and architectural point of view.
the catalog can act as a checklist or as a management resource for experienced or new members of software projects.
moreover the catalog may also help practitioners recognize bad practices that have become standardized within their organizations due to their routine use and familiarity.
anecdotal evidence suggests that the catalog is already valuable to developers.
for instance some survey participants reported using it in their daily work as p12 mentioned every time i have to implement a new feature on a micro frontend i consult the catalog to remember the anti patterns.
this feedback highlights the catalog s role in enhancing development practices and fostering awareness of best practices in mfe design.
while this study has revealed a strong correlation between ms and mfe anti patterns there remain specific anti patterns unique to mfe architectures that warrant further exploration.
issues related to ui inconsistency the management of the state through global versus local stores and the selection of inappropriate composition approaches have not yet been addressed by the proposed anti patterns.
future research should focus on identifying and mitigating these and other mfe specific antipatterns to enhance the overall quality and effectiveness of mfe architectures.
to ensure high quality system design and prevent software degradation it is crucial to identify anti patterns early and perform the necessary refactoring.
automating the detection of these anti patterns may allow for early intervention thus significantly mitigating their impact on software projects.
therefore future research should also prioritize the development of automated detection methods tailored to mfe architectures.
such advancements will not only improve system quality but also help prevent long term negative consequences.
lastly it is also important to address new anti patterns that occur during software development.
as presented in the thematic analysis result participants proposed new anti patternsrelated to inconsistent user experience fragmented state management complex inter mfe communication overhead of independent deployments security and authentication challenges performance bottlenecks security risks and observability.
these anti patterns problems and solutions must be clearly defined and validated by practitioners.
it highlights the need for ongoing research to address emerging challenges in the mfe field ensuring the development of efficient mfe architectures.
vii.
t hreats to validity internal validity.
the length of the form used to gather practitioner s feedback.
a long form may fatigue the participant affecting their responses.
to address this issue we provided an estimated completion time to participants when inviting them and structured the form to present each antipattern on a separate page allowing participants to focus on one anti pattern at a time.
we also included a progress bar to give participants a clear indication of how many anti patterns remained to be evaluated.
participants representativeness.
to address this we focused on inviting participants with previous backgrounds in working with mfe in the industry.
to ensure that participants were not biased by the results of previous works we did not propose a predefined set of bad practices to the participants.
external validity.
subjects sample size.
to address this threat we distributed the survey to a broader pool of software engineers encompassing frontend developers fullstack developers and team leaders.
it allowed us to capture a broader range of perspectives from practitioners with varying levels of mfe knowledge and involvement.
while the sample size may not be ideal for full population generalization the diversity of participant roles strengthens the applicability of our findings to real world mfe development practices.
conclusion validity.
one might reach incorrect conclusions given the data.
on addressing it multiple researchers were involved in the data interpretation.
for both the quantitative and thematic analysis two researchers handled the data interpretation and categorization of themes and a third who is an expert in software engineering with more than years of experience reviewed all the results.
the harmfulness scores calculated using the median may not fully capture the nuances of participants perceptions.
although we do not provide enough evidence on the harmfulness of ranking the anti patterns we illustrate which of them the practitioners consider the most harmful during software development.
we also emphasize that our survey focuses on validating the initial anti patterns instead of generating the ranking itself.
construct validity.
influence of researcher bias on the qualitative results.
to mitigate it we employed a two coder approach to the thematic analysis with the second author independently reviewing the qualitative data and conducting a separate thematic analysis.
following this we employed cohen s kappa to measure the level of agreement between the two coders.
the resulting score of .
classifiedas excellent agreement strengthens our confidence in the objectivity and trustworthiness of the identified themes.
viii.
r elated work although some practitioners have shared their experience on anti patterns in mfe applications on blogs and keynotes no scientific studies have been conducted to propose a catalog of mfe anti patterns.
we conducted a rapid review available at our supplementary material section x and found no studies proposing anti patterns for mfes.
mezzalira briefly mentions that sharing any state between microfrontends is considered an anti pattern but does not provide an in depth definition or exploration of this or other anti patterns.
peltonen et al.
conducted a multivocal literature review and stated that researchers have not yet deeply investigated mfes and patterns and anti patterns have not been defined.
taibi et al.
presented a set of development approaches based on their experience and reported the lack of pattern and anti pattern definitions.
moraes et al.
reported a case study findings which revealed that involuntary anti patterns may occur since they are not yet mature generating severe negative impacts on software projects.
several papers present case studies or experience reports on implementing mfe architectures.
m annist o et al.
presented their experience through the migration of a monolithic frontend to the mfe architecture.
capdepon et al.
proposed an approach to migrate from monolithic mobile architecture to mfe.
moraes et al.
provided an experience report demonstrating how the same application can be implemented using different mfe approaches.
perlin et al.
presented a case study of how to implement an mfe application with webpack.
kaushik et al.
proposed a framework for the design of web applications with mfes and microservices.
they conducted a case study to empirically analyze and evaluate the effectiveness of the proposed framework.
pavlenko et al.
implemented an mfe case study to report and discuss the issues arising during development.
all these papers can assist in making architectural decisions when implementing an mfe architecture.
however they cannot be used to evaluate an architecture or serve as a guide for identifying hidden problems within it.
given the shared characteristics of microservices and mfe architectural styles a study of microservices anti pattern was undertaken to propose the mfe anti patterns.
through a systematic literature review slr cerny et al.
crafted a catalog with disjoint microservice anti patterns grouped into five categories intra service inter service service interaction security and team anti patterns.
tighilt et al.
proposed a catalog with microservice anti patterns based on an slr and the analysis of systems examining them for potential violations of microservices principles and design practices that could be indicative of anti patterns.
building on practitioner experience taibi et al.
introduced a catalog and a taxonomy of the most common microservices antipatterns.
their three year interview study identified antipatterns including organizational and technical anti patterns.bogner et al.
conducted an slr to propose a taxonomy of microservices anti patterns.
additionally they developed a collaborative web application that allows users to explore and interact with their catalog.
while both architectural styles share common anti patterns a dedicated catalog for mfes is necessary to identify and address these issues specifically within the mfes context.
ix.
c onclusions this paper presents a catalog of mfe anti patterns derived from microservices anti patterns and the analysis of real world problems faced by mfe development teams.
to validate whether the identified problems are prevalent in mfe architectures and if the proposed solutions address them effectively we conducted a survey with industry practitioners.
based on their feedback we improved the anti patterns and showcased them in a web application to foster community collaboration.
the survey results show that all identified anti patterns have been encountered by participants in real world mfe projects each receiving varying harmfulness scores.
participants emphasized the catalog s utility as a valuable resource for improving mfe architecture highlighting its potential to guide both novice and experienced developers in avoiding common pitfalls.
additionally participants provided valuable insights by suggesting new anti patterns.
this highlights the importance of creating a collaborative platform where researchers and practitioners can jointly propose discuss and validate new anti patterns.
our web application facilitates this process by enabling practitioners to share their knowledge and experiences ensuring the catalog remains comprehensive and up to date.
for future work we plan to expand the anti patterns catalog by analyzing the suggestions the participants provided through the survey reviewing published mfe architectures to identify recurring issues that deviate from mfe guidelines conducting case studies in industrial settings to uncover common problems in real mfe architectures using our collaborative catalog on github to continuously collect feedback from practitioners helping to identify new anti patterns based on real world experiences.
we intend for industry practitioners to assess all newly proposed anti patterns.
we also aim to develop automated detection tools using dependency graph and static analysis tools to identify antipatterns automatically integrate these tools into code review systems and design visualization tools to aid in detecting antipatterns in mfe architectures.
for the web application we plan to use github insights and github discussions to establish contributor leaderboards helping to motivate developers to engage more actively and contribute to the catalog.
x. d ata availability the initial and improved version of the anti patterns including examples survey responses and the qualitative and quantitative analysis conducted in this research are currentlymaintained as an open source project accessible at https zenodo.org records .
acknowledgment we thank all the participants in the empirical study and uses research group members for their support.
the present work is the result of the research and development r d project signed with the federal university of amazonas and faepi brazil which has funding from samsung using resources from the informatics law for the western amazon federal law no .
and its dissemination is in accordance with article of decree no.
.
.
this work was carried out with the support of the coordination for the improvement of higher education personnel brazil capes proex funding code cnpq process cnpq process and cnpq process .
additionally this work was partially funded by the foundation for research support of the state of amazonas fapeam through the pdpg project.