modus a datalog dialect for building container images chris tomy university college london united kingdom chris.tomy.
ucl.ac.uktingmao wang university college london united kingdom tingmao.wang.
ucl.ac.uk earl t. barr university college london united kingdom e.barr ucl.ac.uksergey mechtaev university college london united kingdom s.mechtaev ucl.ac.uk abstract containers help share and deploy software by packaging it with all its dependencies.
tools like docker or kubernetes spawn containers from images as specified by a build system s language such as dockerfile.
a build system takes many parameters to build an image including os and application versions.
these build parameters can interact setting one can restrict another.
dockerfile lacks support for reifying and constraining these interactions thus forcing developers to write a build script per workflow.
as a result developers have resorted to creating ad hoc solutions such as templates or domain specific frameworks that harm performance and complicate maintenance because they are verbose and mix languages.
to address this problem we introduce modus a datalog dialect for building container images.
modus key insight is that container definitions naturally map to proof trees of horn clauses.
in these trees container configurations correspond to logical facts build instructions correspond to logic rules and the build tree is computed as the minimal proof of the datalog query specifying the target image.
modus relies on datalog s expressivity to specify complex workflows with concision and facilitate automatic parallelisation.
we evaluated modus by porting build systems of popular docker hub images to modus.
modus reduced the code size by .
compared to the used ad hoc solutions while imposing a negligible performance overhead preserving the original image size and image efficiency.
we also provide a detailed analysis of porting openjdk image build system to modus.
ccs concepts theory of computation constraint and logic programming software and its engineering virtual machines domain specific languages .
both authors contributed equally to this research.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
container build system docker datalog acm reference format chris tomy tingmao wang earl t. barr and sergey mechtaev.
.
modus a datalog dialect for building container images.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
introduction software sharing and deployment are hard because they impose the necessity of managing versions dependencies and execution environments.
containers such as docker containers can package software with all its dependencies simplifying sharing and deployment without considerable performance overhead.
containers are widely used in cloud computing continuous integration delivery and reproducible research .
containers are spawned from images filesystem snapshots accompanied by configuration files.
images consist of layers that store changes to the underlying filesystem such as file additions modifications and deletions that are combined in runtime using a union mount filesystem.
container images are constructed by executing instructions written in a build system s language the most popular of which is dockerfile .
dockerfiles describe a sequence of instructions or a directed acyclic graph dag of instructions in the case of multistage builds that run shell commands copy local files or files from other images into the constructed image or set image properties defined in the oci specification such as the working directory.
the layered design of container images enables software reuse in the form of building images on top of other images.
public container registries such as docker hub store more than public image repositories comprising over million layers .
since most software is configurable and evolving container images are intrinsically parameterised.
image parameters include software versions configuration parameters and compilation flags.
for example the official image python .
.
alpine3.
is parameterised with the version .
.
of python interpreter as well the name and the version of the linux distribution alpine .
.
these parameters can and often do depend on and interact with each other and these interactions determine how images are built.
for example installing an older version of python on a newer linux distribution may require executing extra instructions to add appropriate software repositories.
dockerfiles do not express dependencies betweenesec fse november singapore singapore chris tomy tingmao wang earl t. barr sergey mechtaev parameters and the build logic.
for example dockerfile specifies build parameters only as global variables that are used as arguments for build instructions but does not permit using parameter values to control the sequence of executed instructions.
dockerfile s lack of expressiveness forces developers to create ad hoc solutions specific to their domains.
in this paper we consider the problem of packaging popular software into containers.
openjdk the most popular implementation of java is distributed in multiple versions that are updated independently with different sets of features enabled and is built for different platforms.
because of the limitations of dockerfiles the official openjdk docker images use a templating approach that generates dockerfile via a combination of shell scripts and templates written in awk and jq .
the reliance on ad hoc solutions such as awk jqtemplates causes maintenance problems.
first developers must learn multiple languages or frameworks to maintain the build definitions.
second such build definitions are verbose.
to address the limitations of dockerfiles we propose modus a logic programming language for building container images.
its key insight is that an image build can be reduced to the problem of solving a set of horn clauses logical formulas in the form f x ... xn g y ... ym ... h z ... zl .
in modus images and layers are represented as logical facts e.g.the image python .
.
alpine3 .13is represented as python .
.
alpine .
.
build instructions correspond to logic rules the build dag is computed as the minimal proof of the fact representing the target image from truthful facts representing existing images.
expressing build rules as horn clauses leads to concise build definitions allows users to define the same build workflows as defined in ad hoc dockerfile templates and enables automatic build parallelisation.
horn clauses admit various semantics.
modus is a dialect of datalog a specific kind of horn clauses in which the computation of minimal proofs is decidable.
when designing modus we judiciously chose a set of datalog extensions that better model the domain of container builds.
broadly these extensions fall into four categories.
first we extended datalog with operators that implement container related operations and domain specific builtin predicates.
second string manipulations such as variable expansion are crucial for defining container builds.
however a na ve addition of string manipulations to datalog makes it undecidable.
to address this problem we adapted stratified construction to tractably support string operations.
third dockerfiles allow users to specify arbitrary parameters when launching a target s build.
in modus the target is specified as a goal of a datalog program however the standard datalog requires that all constants used in the goal are explicitly defined in the datalog program.
this requirement is impractical because of the large or even unknown number of possible configuration options in complex builds.
to address this usability limitation we implemented an approach that permits passing arbitrary build parameters through the goal of a datalog program without compromising the program s safety.
to evaluate modus we ported build systems of popular docker hub projects from dockerfile templates into modusfiles .
modus captured all linux build scenarios while reducing the code size by .
with a negligible performance overhead.
we also provide a detailed analysis of porting openjdk build system into modus.
the contributions of this work are the following we propose a novel application of datalog the definition of container image builds where images and layers are represented as facts build instruction as clauses and build trees are minimal proofs of facts representing target images we design and implement modus a dialect of datalog for container build definitions with a set of judiciously chosen datalog extensions our evaluation of modus on popular docker hub images shows that it concisely expresses build scenarios for realworld software with negligible overhead.
modus is released at all code scripts and data necessary to reproduce this work are available at overview modus formalises a container build as a query to a deductive database.
this helps to define build instructions in a more concise and intuitive way than using dockerfiles the most widely used approach.
this section explains dockerfile s lack of expressiveness and the disadvantages of this problem s popular workaround the templating approach.
it also shows how modus expresses container image builds in datalog and how it reduces code size and build time when packaging real world projects.
.
inexpressivity of dockerfiles assume we would like to package an application compiled with gcc and gnu make.
a typical dockerfile follows from gcc bullseye as bullseye dev release copy .
app run cd app make it defines a build stage called bullseye dev release that represents a container image.
this image is built on top of a public image gcc bullseye with gcc installed on debian bullseye by copying app s source into the container via copy then compiling it with run.
these instructions add filesystem layers on top of gcc bullseye .
during development it is typical to build a debug target of an application since it provides additional information about failures.
assume that the command make debug compiles a debug target of our application.
there are two approaches to add a debug target into dockerfile that we refer to as the duplication approach and the scripting approach.
the duplication approach copies the code of bullseye dev release to create the stage bullseye dev debug and replaces make withmake debug .
the scripting approach invokes an embedded shell script that processes a dockerfile argument controlling the target from gcc bullseye as bullseye dev combined arg target copy .
app run if then cd app make debug else cd app make fi in this example the shell script dynamically chooses the command to execute based on the value of the variable target .
although the second approach might appear to be superior since it avoids duplication it has several disadvantages.
first it cannotmodus a datalog dialect for building container images esec fse november singapore singapore app base dev target dev image base copy .
app make target .
dev image alpine from alpine run apk add gcc make .
dev image bullseye from gcc bullseye .
app base prod release prod image base app base dev release copy app app .
prod image alpine from alpine .
prod image bullseye from debian bullseye slim .
make debug run cd app make debug .
make release run cd app make .
figure modusfile defining the image appparameterised with base image build mode and compilation target.
be applied to any instructions other than run since other instructions such as copy cannot be expressed as shell scripts.
second using embedded scripts makes re building images slower because of ineffective caching the build system has to invalidate all cached layers following an argcommand if the value of argchanges even if the commands executed and the data copied do not change.
finally embedded scripts interfere with layer management they may enforce a particular placement of runs inducing a granularity of layers that does not coincide with one intended by the developer.
software is often packaged for different base linux distributions.
adding another base say alpine may require executing additional commands e.g.installing gcc and gnu make with apk add gcc make .
considering the disadvantages of the scripting approach we resort to the duplication approach and add two build stages from alpine as alpine dev release run apk add gcc make copy .
app run cd app make andalpine dev debug defined in a similar fashion.
the images dev are not designed for production since they contain redundant files such as the installed compiler and build system.
redundant files increase both image size and attack surface .
a solution to this problem is multi stage builds i.e.
copying the compiled program into a slim image from an auxiliary container using the copy from command to build a production mode as shown below for debian slim from debian bullseye slim as bullseye prod release copy from bullseye dev release app app when building bullseye prod release docker constructs and executes a build directed acyclic graph build dag in figure 2a.
since alpine and debian use different implementations of the c standard library libc binaries cannot be copied across them which introduces a dependency between the base of the production image e.g.debian bullseye slim and the stage used for compilation e.g.bullseye dev release .
dockerfile cannot express this dependency which forces us to duplicate bullseye prod release copy from bullseye dev release app app from debian bullseye slim run cd app make from gcc bullseyecopy .
app bullseye prod release image bullseye dev release image a build dag for the target bullseye prod release .
app bullseye prod release prod image bullseye from debian bullseye slim app bullseye prod release dev image bullseye from gcc bullseye copy .
app make release run cd app make copy app app b proof tree for the goal app bullseye prod release figure build dag and corresponding proof tree.
to create a stage alpine prod release that copies binaries from alpine dev release into the base image alpine .
in summary dockerfile s lack of expressiveness forced us to create four duplicates of the development stages and two duplicates of the production stages which is a code smell .
.
build instructions as datalog rules the key intuition of modus is that build instructions can be represented as a set of particular horn clauses formulas in the form img x ... xm img base y1 ... yk l t1 ... th ... ln z1 ... zg that can be interpreted as the image imgis constructed from the base image imgbase by adding the layers l1 ... ln .
figure shows a program written in our implementation of horn clauses a datalog dialect modus that concisely expresses all build scenarios from section .
.
in this example the image predicate app base mode target represents the target image.
this predicate is defined using two rules for the development mode dev and for the production mode prod .
the rule for the development mode selects the base image using the image predicate dev image copies the files into the container using the builtin predicate copy and builds the program using the layer predicate make .
themake predicate is a layer predicate because it is defined using the builtin layer predicate run.
the rule for the production mode copies binaries from the development image using the operator copy .
in modus operators are not part of the logical inference.
instead they implement container specific functionality such as copying files between containers or setting image properties.
compared to the dockerfile section .
the modusfile figure involves no code duplication each instruction such as copying files to the container or running compilation appears exactly once.esec fse november singapore singapore chris tomy tingmao wang earl t. barr sergey mechtaev if is alpine then from alpine alpine version run apk add no cache java cacerts env java home opt openjdk env.version elif is oracle then from oraclelinux oracle version slim run set eux if oracle version then yum install y else microdnf install end figure a fragment of dockerfile template for openjdk.
to build an image from a modusfile the user has to specify a goal.
for example the goal app bullseye prod release would build a production image of the appon debian bullseye.
the build dag for this image is computed as a minimal proof of the fact representing the goal from facts representing existing images.
figure 2a shows such tree computed for app bullseye prod release .
notice that modulo auxiliary predicates make and prod image this proof tree contains exactly the instructions from the build dag of the image bullseye prod release in figure 2a.
modus can build multiple images at once in parallel.
for example if the user specifies the goal app base prod release where base is a variable modus automatically deduces that it needs to build the images app bullseye prod release andapp alpine prod release and builds them in parallel.
.
code size and build efficiency the lack of dockerfile s expressiveness described in section .
has motivated developers to adapt an alternative solution to generate dockerfiles from templates which we refer to as the templating approach .
as of march out of most popular projects in docker hub use the templating approach.
we illustrate the templating approach using the build system for the widely used official openjdk images.
openjdk uses a combination of several string processing tools jqfor the json processing andgawk for advanced string processing to define dockerfile templates from which it generates dockerfile instances for different openjdk configurations.
each configuration is identified by the tuple of the java version the java type jdk or jre and the base linux distribution e.g.
jdk oraclelinux7 .
each openjdk configuration requires executing a different set of instructions to build an image.
the instructions are selected based on configuration parameters in a dockerfile template a fragment of which is shown in figure .
this template mixes three languages and are handled by a gawk script expressions such as if oracle version then are fromjq s query language and runandfrom instructions are from dockerfile s syntax.base image major version variant java home ... is alpine variant alpine version from f alpine alpine version ... is oracle variant oracle version oracle commands installer cleaner oracle version from f oraclelinux oracle version slim ... openjdk setup major version version ... openjdk config major version version ... base image major version variant ... run base setup command locale variant lang a a fragment of modusfile for building openjdk.
openjdk setup 8u322 jdk .
.
.
openjdk config 8u322 jdk .
.
.
base image oraclelinux7 .
.
.
is oracle oraclelinux7 oracle commands yum install y .
.
.
from oraclelinux slim append path usr java openjdk bin .
.
.
run set eux yum install y gzip .
.
.
locale oraclelinux7 en us.utf .
.
.
b a proof tree fragment for openjdk jdk oraclelinux7 figure a build dag and the corresponding proof tree.
the templating approach as used by openjdk has several disadvantages.
first it complicates maintenance since it requires supporting an ad hoc templating frameworks that mix several languages.
second string processing tools are inefficient and dockerfile generation can take a noticable portion of the build time.
finally string processing scripts are error prone and hard to debug.
modus concisely describes openjdk s build scenarios without using external tools.
openjdk images are represented via image predicate openjdk major version java type variant .
figure 4a shows a fragment of modusfile corresponding to the template in figure .
it shows that modus enables abstraction since it allows extracting reusable parts of the build logic such as selecting the base image via the predicate base image .
when launching a build modus generates proof trees for the specified goals.
figure 4b shows a fragment of the proof tree for the goal openjdk jdk oraclelinux7 .
this proof tree corresponds to the concrete dockerfile generated by the template and builds an identical image.
using modus enabled us to reduce the code size of openjdk container build system by .
and reduce build time by .
compared to the templating approach.
our case study on openjdk images is described in more details in section .modus a datalog dialect for building container images esec fse november singapore singapore background modus is a datalog dialect specialised for container builds via a set of extensions.
it uses buildkit to build images from proof trees.
.
datalog a datalog program consists of a finite set of rules and facts.
rules are horn clauses in the form l0 l ... ln where each liis a literal p t1 ... tn such that pis a predicate symbol and tiare terms.
a term is either a constant or a variable.
we denote variables and predicate symbols using alphanumeric strings with optional underscores e.g.
foo bar and constants using quoted strings e.g.
foobar .
the left side of a clause is its head the right hand side is its body.
datalog imposes structural restrictions on its rules.
first each predicate symbol has to be applied to the same number of arguments which defines its arity.
second each datalog program has to satisfy the following safety conditions that ensure the set of all facts that can be derived from a datalog program is finite definition .
safety conditions .
the following structural constraints should hold each fact is ground has no variables and a variable that occurs in the rule s head must occur in its body.
variables that occur in the head of a rule and also in the body of the same rule are called grounded.
variables that occur only in the head of a rule but not in the body are called non grounded.
a ground substitution x1 c1 ... x n cn is a mapping from variables to constants.
we denote an application of the substitution to the termtast and to the literal lasl .
in the proof theoretic interpretation of datalog the meaning of a program is defined as the set of all facts that can be inferred from the program.
for a given rule l0 l ... lnand a set of ground facts f1 ... fn we say that f0can be inferred in one step fromf1 ... fnif there is a substitution such that for any i ..n fi li .
we refer to this as elementary production principle epp .
a ground fact fcan be inferred from a program pif eitherf p orfcan be inferred by applying epp a finite number of times.
the sequence of applications of epp used to infer a fact ffrompforms a proof offfromp.
a proof can be represented using a proof tree.
definition .
proof tree .
for a given datalog program pand a ground factf a proof tree of ffrompis the tree f r t1 ... t n such thatn 0ifff p otherwise r l0 l ... lnis a rule fromp f l0 andtiare proof trees of li .
consider a datalog program defining graph reachability reach n n node n .
reach n1 n2 arc n1 n3 reach n3 n2 .
and truthful facts node node node arc andarc .
then a proof tree of the fact reach can be visualised as follows reach arc reach arc reach node datalog allows specifying a goal to select a subset of its outputs that are subsumed by the goal.
for example the fact f a a is subsumed by the goal f x x butf a b is not.
.
container images and dockerfiles containers a form of os level virtualisation are spawned from images filesystem snapshots accompanied by configuration files.
letfbe a set of all filesystems trees of files with their contents.
filesystems are defined recursively that is a subtree of a filesystem funder the path pdenoted as subtree f p is also a filesystem.
fhost is the filesystem of the host os.
container images as standardised by the open container initiative oci have layered design.
a layer is typically stored as a delta for two filesystems but to abstract over filesystem implementations we define a layer lnonconstructively as a pair of filesystems f1 f2 .
a container image i is a stack of layers such that for each i ifli f1 f2 andli f3 f4 thenf2 f3.
we denote the set of all images asi.
we assume that images can be referenced by their identifiers using the function image by ref id i. the runtime semantics of images is a function i f that is usually computed dynamically using a union mount filesystem such as overlayfs .
to abstract away irrelevant implementation details we define this semantics as simply the top filesystem on the stack that is snd peek i .
two common operations performed on images are runandcopy .
the operation run scripts i i takes a script sand an image i executesson the filesystem resulting in a new filesystem f and returns an image that is obtained by appending the layer f toi.
the operation copy !f paths i i takes a filesystem f a pathpand an image i and returns an image obtained by adding the layer containing funder the path pon top ofi.
dockerfile is a widely used format for specifying container image builds.
dockerfiles define build stages each of which consists of a single from idinstruction specifying the base image ibase image by ref id followed by a sequence of ninstructions.
eachi th instruction corresponds to a function fi i i .
if this instruction is run script thenfi run script .
if this instruction is copy src dst thenfi copy subtree fhost src dst .
the semantics of the build stage is the image fn ... f1 ibase .
dockerfiles also support instructions that set image properties such as workdir that sets the current working directory but such instructions do not create new layers.
the modus language this section introduces the syntax and semantics of modus describes and motivates datalog s extensions of that it implements.
.
syntax semantics modus syntax is based on datalog s syntax given in section .
.
modus extends this syntax via the notion of predicate kind .
modus has three kinds of predicates image predicates layer predicates and logic predicates.
image predicates correspond to container images.
an image predicate is either the built in predicate from that refers to an existing image by name or it is defined in a rule i1 x1 ... xm i y1 ... yk l t1 ... th ... ln z1 ... zg esec fse november singapore singapore chris tomy tingmao wang earl t. barr sergey mechtaev build image f t1 ... t n ifn 0then matchfwith from id image by ref id else letibase build image t1 in letfi build layer ti fori in fn ... f2 ibase build layer f t1 ... t n ifn 0then matchfwith run s run s copy src dest copy subtree fhost src dest else letfi build layer ti fori in fn ... f1 figure building images from proof trees.
wherei1andi2are image predicates and liare zero or more layer predicates.
layer predicates describe image layers.
a layer predicate is either runandcopy or a predicate defined in a rule l1 x1 ... xm l t1 ... th ... ln z1 ... zg whereliare layer predicates.
logic predicates are predicates that do not represent any container related entities they define build logic.
logic predicate can be defined through other logic predicates and can appear in any part of rules bodies.
for example the program in figure defines image predicates app dev image prod image and a layer predicate make .
the semantics of a modus program is a mapping from goals to sets of images.
for a given program pand a goalg modus computes all facts that can be inferred from pand are subsumed by g then constructs a proof tree for each fact.
a fact corresponds to the built image and its proof tree is the recipe to build the image.
since there can be multiple proof trees for a given fact we choose the minimal tree w.r.t.
the number of layers as it naturally optimises the resulting image size and build time.
multiple minimal proofs may exist.
for example the program f p. f q. p. q. provides multiples way to derive the goal f. in this case modus picks one deterministically based on an implementation defined ordering.
given a proof tree f r t1 ... t n modus builds an image that can be defined using the function build image prooftrees igiven in figure .
this function implements a top down proof tree traversal which visits tree nodes from left to right converts them to the layer building functions and then applies the composition of these functions to the base image.
note that this algorithm assumes that the proof tree is stripped of logic predicates.
an efficient implementation of build image is discussed in section .
.
.
extensions implementations of datalog often contain domain specific extensions e.g.to facilitate implementation of program analysers .
modus is the first datalog implementation designed for containerimage builds and we judiciously chose a set of extension to help modeling this new domain.
.
.
built in predicates and operators.
to facilitate definition of image builds we introduced a library of built in predicates.
apart from the predicates from run andcopy described above we introduce predicates for defining conditions on the input parameters.
notably the semver predicates define software version comparison as per the semver specification .
for example the following fact is true semver lt .
.
.
.
whereltmeans .
the key difficulty of adding built in predicates to datalog is that built in predicates such as semver lt are infinite relations which require special handling to retain datalog s decidability.
we used the standard approach to support built in predicates we defer the evaluation of a built in predicate until all arguments of this predicate are bound to constants.
some container specific operations are inconvenient to express using predicates.
for example in multi stage builds files are copied from a temporary image to the current image.
since images are identified with literals an operation expressing multi stage build would need to take a literal as an argument.
however datalog does not permit applying predicates to literals.
to address this we introduce operators that use the syntax literal operator t ... t n .
a notable example of an operator is copy that is needed to implement multi stage builds.
formally the semantics of copy are defined by adding the following rule in the match statement of the function build layer in figure literal copy src dest copy subtree src dest an example usage of copy is given in section .
.
.
.
string manipulation stratified construction.
string manipulations are often used in container builds systems to parse construct configuration options.
string manipulations are enabled in modus via the built in predicate string concat a b c that states that cis the concatenation of aandb.
modus also introduces pythonlike formatted strings that are defined through string concat .
for example foo f a x is equivalent to string concat a x y foo y whereyis a fresh variable.
a na ve incorporation of string concat a b c into datalog makes it possible to generate strings of arbitrary length making evaluating datalog programs intractable.
to address this problem we adapted stratified construction to forbid modus programs that involve recursive predicates that depend on arguments of string concat in the spirit of stratified negation .
as a result each modus program can apply string concat only up to a predefined number of times which is independent of the input.
this limitation did not impose any obstacles when porting realistic build systems presented in section .
.
.
non grounded variables.
datalog s safety conditions definition .
require that each variable that occurs in the rule s head must occur in its body.
when using built in predicates this variable should also be an argument of a non built in predicate in the body.
this condition can be naturally satisfied in datalog s traditional applications such as program analysis where all constants are presentmodus a datalog dialect for building container images esec fse november singapore singapore in the database.
in contrast this restriction in inconvenient for container builds as the following example demonstrates app cflags from gcc latest copy .
.
run f gcc cflags test.c o test .
the variable cflags is not grounded as it only appears as an argument of a built in predicate so this is an invalid datalog program.
dockerfiles allow users to specify arbitrary parameters when launching a target s build such as the gflag.
however gcc accepts a large number of flags so it would impractical to list all accepted flags in the modus program.
instead it would be natural to allow users to use this program to build the goal app g since the argument of runcan then be inferred from the goal.
to enable such usage scenarios we relaxed the safety conditions by allowing user defined predicates with non grounded variables.
at the same time we introduced the new restriction that during evaluation we defer the evaluation of these predicates until all of their arguments are bound to constants following the handling of built in predicates in section .
.
.
so enabled us to support the usage scenario above without sacrificing datalog s safety.
.
implementation to generate proof trees for a given goal we implemented a custom top down datalog solver based on sld resolution that supports our library of built in predicates described in section .
.
handles non grounded variables in a non standard way as explained in section .
.
and generates proofs that minimise the number of layers required to build a given image.
to build images from proof trees modus uses buildkit as the backend.
buildkit provides an intermediate representation llb which is described by buildkit s developers as llb is to dockerfile what llvm ir is to c .
llb is a dag where a node either refers to existing image or corresponds to runorcopy operation.
to implement the function build image modus translates the proof tree into llb and executes it with buildkit.
this approach has several advantages.
first buildkit automatically parallelises the build.
second it provides automatic caching i.e.it tracks changes to the filesystem and shell commands and only re builds layers and images that are affected by these changes.
currently buildkit does not support build graphs with multiple output.
to overcome this problem when building multiple images we construct a dummy image and attach the target images as children to this dummy image.
although this workaround enables us to build multiple images in parallel buildkit s api does not currently give us direct access these child images after they are built.
instead we must redundantly call the build system.
this cost is especially noticeable since these calls can only start after all builds are finished preventing modus from maximally exploiting parallelism.
we refer to this redundant step as exporting .
this step is not an essential part of modus build process but a workaround over the current limitations of buildkit s api.table corpus descriptive statistics.
project templating method outputs ubuntu bash redis sed awk nginx sed nodejs sed awk mysql awk jq traefik envsubst evaluation on docker hub images we now show that for a corpus of six popular docker projects modus reduces the overall size of code used to build images by an average of .
with a negligible performance overhead.
to build our corpus we considered images as ranked by docker hub suggested filter which closely follows downloads and selected the first six which used different sequences of commands for templating.
under this rule selecting mysql filtered out python and postgresql.
we also intended to rule out projects that either do not use parameters in their tags or build only one container image as the focus of modus is on parameterised builds but we did not need to employ this filter.
we have no reason to believe that this selection process introduces bias with respect to the object of our study namely builds conditioned on parameters.
using popular examples is common practice in empirical work.
any project considering modus would do so to adopt modus feature set precisely because modus promises to help them speed or ease the maintenance of their build.
porting each project to modus requires understanding the existing build and in turn substantial manual effort.
the six projects we selected collectively cover an interesting subdomain of the container build system space.
table summarises our corpus.
.
modus code reduction we now quantify and compare the size of the build systems of our corpus to their modus ports.
our key finding is that modus reduces build code size by .
on average over our corpus in lines of code by reducing repetition and avoiding scripting.
we measure code size after normalising the code by stripping comments whitespace and stop words i.e.the cooked 2normalisation described in section .
.
table shows our code reduction results calculated in two ways.
table 2a only counts the dockerfile templates not scripts that use them to generate dockerfiles in the templating columns and only modusfiles in the modus columns.
to the counts in table 2a table 2b adds the sizes of all templates and scripts used to build the images in the templating columns and any scripts needed to generate version lists but not templating in the modus columns.
we present both tables because the definition of build code is not well established.
one view is that a build system consists only of the dockerfile and modufiles.
another view is that a build system includes all the version fetching and templating scripts.
further complicating matters is the fact that some of these scripts may additionally perform tasks unrelated to building their project.
thus we present these two tables to establish lower and upper bounds on the true size of each project s build system.esec fse november singapore singapore chris tomy tingmao wang earl t. barr sergey mechtaev in table 2a the ubuntu project does not use templates but a bash script that prints its dockerfiles so we did not report its template sizes.
the nginx project s templating script contains most of its build logic written in bash and it simply writes results into its templates.
the script manipulates strings and constructs sets of packages to install inserted into the dockerfile in the form of a space separated string that get passed to apt.
porting this logic into a modusfile substantially reduces the build code needed from lines of bash script to lines of modusfile ignoring docker build instructions in either case .
this accounts for the swing in the results for nginx across table 2a and table 2b.
modus reduces build system code size by .
on average in lines and .
reduction in words.
modus owes this result to its expressivity.
in section we use a case study to illustrate how it achieves these savings in detail.
.
modus build time we now compare our corpus build systems to their modus ports.
these experiments were performed on aws c5.2xlarge which at the time of writing had cpus gib ram gbps bandwidth and an ssd disk with iops.
we used modus v0.
.
to build our modusfile and used the buildkit mode of docker build and gnu parallel to build our corpus dockerfiles.
some projects build images for platforms other than x86 64 but we only ran our tests on a x86 64 vm not for other architectures.
despite this our modusfiles include code to build other architectures when a project in our corpus does to ensure a fair code size comparison.
we exclude the redundant export step discussed in section .
from our results since it is a workaround for buildkit api limitations.
exporting averages .
sacross our corpus.
when buildkit exposes an appropriate api this overhead will disappear.
table shows our results.
each of the column is an average of runs.
the ci columns is the confidence interval for the true average.
in both table we did not include time taken to pull base images e.g.alpine ordebian because docker hub request limits meant that we could not do a fresh pull for each run and the time taken to pull images depends on network conditions and cpu speed for extraction two problems modus does not address.
modus increases average total build times by .
showing that modus reduces build code size with negligible overhead.
modus implementation is not yet optimised but still it achieves this negligible overhead.
even including the low and input independent overhead of the buildkit workaround section .
developers can safely adopt modus today to take advantage of its concision.
.
validating modus built images since our modusfiles are direct translation of our corpus existing build systems we expect modus images to closely match the dockerfile images in terms of image size and also space efficiency which is measured with a well known docker image analyzer known as dive .
the space efficiency score is a heuristic that penalises wasted space.
roughly it is the sum of the size of all visible files in the final image over the total image size.
our results shows that on average our image efficiency score is .
higher than theawk 4script jq cd ci builddockerfile templates images update script dockerfilesjq querydocker s openjdk build system versions.json source urls figure dobs build steps to produce openjdk images.
dockerfile counterpart.
in the worse case our efficiency score is not more than .
lower.
the average difference in image size is1.
mib .
and the maximum difference is .
mib .
.
we also ran simple smoke tests that runs the entry executable with flags to print its version on each image produced all modus images passed this test.
case study openjdk we conducted a case study to detail how we port build systems to modus and to explain how modus expressivity allows it to define build systems with concision.
we chose to study the official image packaging for openjdk because docker maintains it and it outputs images at the time of writing which is above .
the average number of images produced by the top five by github stars build systems maintained by docker.
we first describe openjdk s current build system and how we manually ported it while taking care to produce an equivalent modus build.
the modus port is concise using .
fewer words than openjdk s official build and fast achieving a total build time speedup of .
.
.
porting openjdk s build to modus the existing openjdk packaging uses a templating approach to handle parameter interactions.
figure presents the workflow of docker s openjdk build system dobs .
the build system accepts two inputs dockerfile templates and openjdk source urls.
step updates the version data by checking known sources of openjdk and generates the file versions.json .
in step awk an advanced string processing tool processes the dockerfile templates generating an appropriate jq expression according to the code within template delimiters and .
in step jqgenerates dockerfile instances by applying the expression constructed at step toversions.json in step .
a ci service performs step taking the dockerfiles from step and building oci images.
to port a build system to modus one needs to identify its parameters re encode into modus data format and translate its conditional logic into rules.
we ported the subset of dobs that generates linux images.
examining dobs source we learned that the directory structure1containing dobs dockerfiles encodes the parameters that dobs uses to identify an image major application version java type and base image variant.
these triples in turn index dobs json versions file where we found the additional parameters needed to build the image2 full version amd64 binary url and arm64 binary url.
modus primary data format is a set of modus facts which are essentially tuples.
we manually inspected both the 1for example consider alpine3.
.
2we omit parameters that do not relate to the image build itself such as checksums.modus a datalog dialect for building container images esec fse november singapore singapore table normalised code size for our corpus .
a modusfile and dockerfile templates only.
templating modus project cr words bytes cr words bytes mysql .
.
.
nginx .
.
.
node .
.
.
redis .
.
.
traefik .
.
.
ubuntu n a n a n a n a b including version fetching for both and templating scripts.
templating modus project cr words bytes cr words bytes mysql .
.
.
nginx .
.
.
node .
.
.
redis .
.
.
traefik .
.
.
ubuntu .
.
.
table build time for each project in our corpus .
a modus build and parallel docker build only.
project dockerfiles s modus s ci ci mysql .
.
.
.
.
.
nginx .
.
.
.
.
.
node .
.
.
.
.
.
redis .
.
.
.
.
.
traefik .
.
.
.
.
.
ubuntu .
.
.
.
.
.
b including version fetching for both and templating scripts.
project dockerfiles s modus s ci ci mysql .
.
.
.
.
.
nginx .
.
.
.
.
.
node .
.
.
.
.
.
redis .
.
.
.
.
.
traefik .
.
.
.
.
.
ubuntu .
.
.
.
.
.
existing json version data and templated dockerfile to learn how to convert the json data into modus facts.
for simplicity each fact that we generate for our build system includes all of the parameters.
we manually examined each conditional block in dobs and wrote an equivalent modus rule.
to ensure correctness of our port after each implementation of a modus rule we built images that correspond to those new branches of logic and used dive to compare the operations performed in each layer with the corresponding dobs image.
we contend that this development process established a close mapping between our linux.modusfile and their dockerfile linux.template the interested reader can build and examine the relevant artefacts using to confirm.
a simple metric that can act as a heuristic for correctness is the difference in image size so we set up a ci that computes this for every openjdk image we build.
the average difference in size is .38mb .
for comparison the largest openjdk image is currently 675mb3.
we spot checked five uniformly chosen images by tarballing the filesystems and then running pkgdiff on them to determine whether these differences are data or executables.
all the differences we inspected were in data like log files.
.
modus concisely builds openjdk modus expressivity makes it more concise than docker s openjdk build system dobs .
we quantify its concision show that this concision and readability comes for free the efficiency of the images that modus builds match those produced by dobs.
3this is openjdk jdk bullseye .table modus builds openjdk images with .
less words.
templating modus variant cr words bytes cr words bytes raw .
.
.
cooked .
.
.
cooked .
.
.
table displays the statistics of raw unedited files as well as two variants cooked 1and cooked .
cooked 1removes comments and empty lines to de emphasise formatting conventions.
cooked removes further tokens that are analogous to stop words like delimiters.
in particular we remove templating delimiters such as and we replace whitespace chains defined by with a single space to balance out different indentation choices.
as with whitespace we remove these tokens in an effort to make the comparison more fair and centered on tokens with more semantic content.
on openjdk modus achieves a reduction of .
words and .
bytes using the cooked 2code normalisation.
these size reductions provide evidence that modus can make build systems more maintainable.
much of modus concision is a result of its constructs and built in operators to handle conditionally selecting instructions.
in addition to concision modus constructs enhance readability.
with templating readability often breaks down when using nested conditional syntax like in the dobs templated 4the script that implements these variants can be found here record at openjdk images case study benchmark scripts code size.shesec fse november singapore singapore chris tomy tingmao wang earl t. barr sergey mechtaev table average build time results for openjdk images over runs.
tis the average time to perform template processing to construct parameter specific dockerfiles.
approach s t s openjdk dockerfilessequential .
.
parallel .
.
manual optim.
.
.
modustotal .
.
exporting .
n a dockerfile figure .
in this case it is often tricky to work out scopes.
such cases force developers to skim through an entire templated dockerfile to understand its behaviour.
the use of a rule such as in figure 4a explicitly restricts the scope of variables and nested expressions provide a convenient yet readable alternative to the nested conditionals found in dobs templated dockerfile.
in this way modus lends itself to more readable and reusable code.
another modus feature that promotes concision is its merge operator.
applied to a group of literals e.g.
l1 l2 merge this operator squashes all runandcopy commands into a single command during build dag construction which results in a single layer built.
we used dive section .
to estimate the efficiency of an image.
dobs images achieve image efficiency above but at a cost to their readability and separability.
to avoid recording redundant modifications in the layer diffs and bloating the image size nearly a half of the dobs dockerfile is a single runlayer .
using merge as in our linux.modusfile5 meant that we did not need to pack operations into a single command.
we extracted the steps of the build into logical rules and merged them resulting in the following efficiency scores dobs openjdk images average efficiency of .
.
modus openjdk images average efficiency of .
.
modus merge operator does not affect build time but optimises image size.
from the code quality point of view it facilitates the best of both worlds the readability of separating code sections without the inefficiency of more layers recording more diffs.
.
modus quickly builds openjdk this section compares the build time of docker s official build system dobs with our port using modus.
it shows that modus scales to builds that output a large number of images.
we used the same experiment setup as in section .
with docker library openjdk and modus continens openjdk images case study revisions as found in dobs uses separate github ci cd workflows to build the image while in our experiment we again used gnu parallel to build all dockerfiles at once.
table presents the results.
we included the build time with and without template processing since this can vary with different template engines.
dobs performs some duplicate copying of binaries.
the manual optimisation approach is our attempt to optimise dobs to fix this problem using docker s builder pattern 5found at lines of openjdk images case study linux.modusfile in our reproduction package a shell script separately builds and copies binaries6.
the exporting step in the final row of table is a subset of the time required to perform the image builds that could be reduced with future optimizations.
we performed n 10runs of each approach and computed the sample mean.
template processing steps and in figure was run separately with n 10runs leading to a sample mean of t .1s.
since template processing is necessary to output images modus outperforms every dobs approach when accounting for template processing time.
specifically modus s total build time is lower than the expected total time with templating t as143.1sis less than sequential .4s parallel .9s and our manual optimization .8s .
modus achieves a .
speed up over openjdk s official build system when including dockerfile generation.
this impressive speed up runs counter to the results reported in section where we report a negligible slow down.
this speedup is partly a result of modus being able to quickly perform sld resolution section so it avoids slow template processing.
dobs template processing is notably slow this is due to their awk script step of figure relying on inefficient user defined functions .
in fact t pwhere pis the mean time to solely build the images in parallel so dobs template processing setup is a significant factor in their total build time.
furthermore the expected time without the exporting step performed by modus is .
.
.1seconds which indicates potential for modus to outperform even step figure in isolation.
the results for our manual optimization from table suggest that this copying incurs a further penalty that outweighs any benefit from avoiding the extra network calls fetching duplicate binaries.
this motivates the use of a system like modus over shell scripts or ad hoc optimizations.
related work works relevant to modus include container build systems build systems based on logic programming and datalog implementations and extensions.
container build systems.
the most popular container build system which is distributed with docker uses dockerfiles as the build definition language.
in dockerfile build parameters must either be hard coded or set as global variables users have limited ability to describe how interactions of these parameters affect the build workflow.
this leads to substantial code duplication.
as a result developers resort to developing ad hoc dockerfile templating frameworks as in official openjdk images maintained by docker.
these frameworks are cumbersome as they typically mix several string processing languages and still verbose.
earthly extends dockerfiles with additional constructs.
since its conditional statements are evaluated during the build process the branches taken are not known in advance and therefore earthly does not automatically parallelise builds with such conditional instructions.
buildah embeds build instructions into a shell script and therefore it does not parallelise builds since shell scripts as turingcomplete programs cannot be automatically parallelised.
nix and guix are functional package managers that can also be 6found at openjdk images case study openjdk build.sh in our reproduction package a datalog dialect for building container images esec fse november singapore singapore used to build containers.
in order to package software with nix or guix all dependencies must also be packaged by these managers.
compared to these systems modus substantially reduced the code size enables automatic build parallelisation due to its static build dag construction with datalog and is package manager agnostic.
build systems based on logic programming.
biomake and prom are build systems based on prolog .
they both extend the capabilities of make and therefore are designed to model file dependencies turing complete i.e.allow expressing non terminating computations and non declarative i.e.the success of evaluation depends on the order of literals in clause bodies.
modus is designed to model a new domain of container images which differ from a traditional filesystem by their layered design section .
.
since modus is a datalog dialect it is not turingcomplete which guarantees that computations of the build dag for each target terminate and declarative which allows the developer to arbitrarily order image layers without being constrained by the horn clause evaluation strategy.
datalog implementations and extensions.
although datalog is a precisely defined fragment of horn clauses its numerous implementations implement different sets of non standard features called extensions that are chosen to better model the application domains.
to the best of our knowledge our work is the first that applies datalog and logic programming in general to the domain of container image builds.
modus as many other datalog implementation supports built in predicates.
although we used the standard approach to support them the set of predicates is different.
specifically modus implements container related predicates such as from andrun section .
as explained in section .
.
modus allows using rules with non grounded variables.
des also allows rules with non grounded variables but since it is implemented in prolog the semantics of such rules is different.
des may return literals with uninitialised variables as outputs.
in modus all variables must be initialised since all build parameters must be concrete to build an image.
thus we implemented a custom approach for handling non grounded variables discussed in section .
.
.
most datalog implementations are designed as query languages so their semantics is defined via the facts they infer.
in contrast modus semantics is defined via proof trees and it searches not for arbitrary but minimal proof trees.
previously minimal proof trees were used to assist in debugging datalog programs .
modus implements advanced support for string manipulation using the predicate string concat and adapts stratified construction to ensure the tractability of solving string constraints.
although stratified construction limits the number of concatenation applications during evaluation this restriction can potentially be lifted by for example implementing a generalized sequence transducer .
conclusion this paper introduces modus a novel application of logic programming to building container images.
the key intuition of modus is that proofs of horn clauses naturally map to container image builds and therefore horn clauses more specifically a decidable fragment of horn clauses called datalog is a suitable formalism for container image build definitions.
when designing modus weidentified several datalog s extensions including domain specific built in predicates and operators non grounded variables and advanced string manipulations that facilitate image build definitions.
an evaluation on popular docker hub projects revealed that modus substantially reduced the code size of container image build systems while introducing only a negligible performance overhead preserved the original image size and image efficiency.
data availability statement modus is released at all code scripts and data necessary to reproduce this work are available in a reusable artifact .