firmguide boosting the capability of rehosting embedded linux kernels through model guided kernel execution qiang liu cen zhang lin ma muhui jiang yajin zhou lei wu wenbo shen xiapu luo yang liu kui ren zhejiang university nanyang technological university the hong kong polytechnic university abstract linux kernel is widely used in embedded systems.
to understand practical threats to the linux kernel we need to perform dynamic analysis with a full system emulator e.g.
qemu.
however due to hardware fragmentation e.g.
varioustypes of peripherals most embedded systems are not currentlysupported by qemu.
though some progress has been made onrehosting firmware it mainly focuses on user space programs orsimple real time operating systems.
the goal of this work is to boost the capability of rehosting the embedded linux kernels in qemu.
by so dynamicanalysis systems can be firstly applied on embedded linux kernelsby leveraging off the shelf tools upon qemu.
accordingly weproposed a new technique called model guided kernel execution.
it combines the peripheral abstractions in the linux kerneland kernel peripheral interactions to semi automatically generate peripheral models that are then used to synthesize new qemu virtual machines to start the dynamic analysis.
we have implemented a prototype called firmguide.
it generates 9peripheral models with full functionality and 64with minimum functionality covering 26socs.
our evaluation with firmware images shows that it can successfully rehost more than of linux kernels in 2architectures and versions.
none of them can be rehosted in the vanilla qemu.
the result of the ltp benchmark shows the reliability and robustness of the rehosted linux kernels.
we further conducttwo security applications i.e.
vulnerability analysis and fuzzing on the rehosted linux kernels to demonstrate the usage scenarios.
i. i ntroduction with the proliferation of iot or embedded devices in recent years the firmware the software stack of these devices has become one of the most common attack targets .
many of them integrate the linux kernel in which vulnerabilities are still discovered every year .
what s worse the device vendors do not timely apply or backport security patches from the mainstream to the firmware exposing vulnerable devices in the wild.
once being exploited these devices can be fully controlled by attackers.
rehosting also known as emulation is used to load and run the analysis target e.g.
the linux kernel of the firmware inside an emulator e.g.
qemu and provides the capability to introspect the runtime states of the target.
after that various security analysis applications can be applied e.g.
vulnerability analysis and fuzzing.
running the linux kernel the first two authors contributed equally to this work.
corresponding author lei wu zju.edu.cn.of the desktop system in qemu is not an issue.
however embedded devices tend to use different types of system onchips socs that are currently unsupported by qemu.
hence it s still an underdeveloped research problem to dynamically run the embedded linux kernels inside an emulated environment.
in this work we focus on rehosting embedded linux kernels to lay the foundation of the dynamic analysis forthem.
though researchers have made progress in firmware rehosting these tools cannot serve our purpose.
first they target user space programs of the firmware instead of the linuxkernels .
for instance firmadyne rehosts userspace programs by using a customized linux kernel that can be loaded in qemu.
since the loaded kernel is different from the real one it cannot be used to analyze the original linux kernel.
second they pay attention to non linux kernels ofbare metal systems or leverage real hardware for analysis which is not scalable in the context of the linux kernel.
to the best of our knowledge no system can rehost the embedded linux kernel on a large scale yet.
rehosting the embedded linux kernel is challenging.
first the booting process depends on multiple peripherals.
for instance after analyzing device tree blobs in the linux kernel we found that each device has 32peripherals on average.
second the same type of peripherals usually has different hardware designs.
there are thousands of peripherals supported by the linux kernel and it is impractical to implement them one by one.
third peripheral interfaces have semantic diversity.
a peripheral usually exposes several interfaces hardware registers to the linux kernel to control its inner states and each register has its specific semantics.
a successful rehostingrequires an understanding of these interfaces semantics.
these challenges make the manual rehosting of these peripherals a tedious and error prone task.
our approach in this paper we aim to boost the capability of rehosting embedded linux kernels in qemu.
by so existing dynamic analysis tools built upon qemu can be easily applied to analyze the embedded linux kernels.
we have three observations to semi automatically generate peripheral models.
1rehosting the linux kernel only requires the full emulation 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee of a few peripherals called type i peripherals in this paper e.g.
interrupt controller and timer are two typei peripherals that require full functionality emulation.
for other peripherals called type ii peripherals in this paper we only need to emulate their minimum functionalities with properly initialized values such as network card and flash.
2the linux kernel has well defined abstractions for different types of peripherals.
for instance the linux kernelinterrupt subsystem abstracts common actions of the interrupt controller and defines these actions as callback functions for low level device drivers to register.
there is a similar design for the linux kernel time subsystem and the timer peripherals.
3the well defined abstractions and kernel peripheral interactions together can describe the peripheral interfaces.
for instance the interrupt subsystem draws the inner states ofthe interrupt controller.
if we can use kernel peripheral interactions to identify which callback function is executed we can then transit the inner states properly.
subsequently we propose a new technique called modelguided kernel execution .i tsemi automatically builds the peripheral models that qemu does not support yet by analyzingthe linux kernel source code.
the peripheral model consists of two parts the general model template and the specific model parameters.
the model template is manually built based on the linux kernel s abstraction layers for that type of peripherals e.g.
the interrupt subsystem which is a one time effort.
theseabstractions help us construct state machines that can cooperate with the linux kernel.
the state machine defines all the states and the state transition table but leaves the transition conditions events as blanks.
we then extract model parameters from the peripheral s driver code to fill these blanks to generate transition conditions.
the parameters are automatically generated by symbolic execution.
the peripheral models then can guide the kernel s execution in a synthesized qemu virtual machine.
we have developed a prototype called firmguide that has two components.
one is offline model generation analyzing the linux kernel source code to semi automatically generate peripheral models.
the other is online kernel booting checking the hardware dependency of the linux kernel with its device tree and rehosting the linux kernel with a synthesized qemu virtual machine.
note that firmguide requires the linux kernel source code during the first component to generate peripheral models but does not need the source code in the second component to rehost the linux kernel inside the firmware.
evaluation to evaluate the effectiveness of our method we manage to generate 9type i peripheral models and 64type ii peripheral models section vi b and synthesize corresponding qemu virtual machines for each embedded linux kernel.
with the virtual machines we ve rehosted the linux kernels in firmware images downloaded from the internet .
on one hand .
linux kernels are successfully rehosted entering into the user space and none of them can be rehosted in the vanilla qemu section vi c .
on the other hand the rehosted linux kernels cover 26socs 2architectures and kernel versions section vi d .
note that the rehosted linux kernel version is not necessarily as same asthe version to generate peripheral models.
this result together with the number of rehosted linux kernels demonstrated the scalability of our system.
furthermore we used the linux testing projects ltp to test the functionality of the rehosted linux kernels showing the feasibility to build security applications section vi e .
we further present two applications to show the usage scenarios with the support of the synthesized qemu virtual machines.
first we analyzed 6linux kernel cves.
with the help of the debugging capability of qemu we have successfully triggered 5and exploited 4of them respectively.
this shows the usage of the synthesized qemu virtual machines to trigger understand and exploit vulnerabilities of the rehosted linux kernels.
second we have ported two fuzzing tools unicorefuzz and triforceafl to demonstrate the capability of supporting other dynamic analysis tools to the rehosted linux kernels.
the applications themselves are notour contribution but can demonstrate the usage scenarios of firmguide .
nevertheless without the capability of firmguide to rehost the embedded linux kernels it s hard if not impossible to apply these security applications to them.
contributions our main contributions are as follows.
we summarized the problem of rehosting embedded linux kernels and proposed a new technique called model guided kernel execution tosemi automatically generate stateful peripheral models that are not supported in qemu.
we implemented a prototype called firmguide to boost the capability of rehosting embedded linux kernels.
evaluated with firmware the result shows that we can successfully rehost more than linux kernels covering 26socs architectures and 22versions.
firmguide lays a foundation to perform the dynamic analysis of embedded linux kernels.
we applied firmguide to vulnerability analysis and fuzzing to show the usage scenarios.
we have released the docker image to dry run our system .
to engage the community we will release the source code offirmguide .
ii.
b ackground embedded systems advanced embedded systems e.g.
routers are often based on the socs that have integrated cpu memory and basic peripherals.
among those peripherals interrupt controller and timer are two of the most important peripherals.
peripherals use interrupts to inform the processor of what is happening and an interrupt controller attached to a processor is responsible for delivering the interrupts.
after the interrupt controller notifies the processor that an interrupt is fired the processor then retrieves the interrupt request number irqn from it and jumps to the corresponding interrupt service routine isr .
an embedded system usually requires two kinds of timers.
one connected to the interrupt controller is used for periodically generating interrupts for task scheduling.
the other one which never raises an interrupt is used as the source 7931compatible plxtech nas7820 2cpu processor 3memory memory 4ic peripheral 5compatible arm arm11mp gic mmio memory space start size 7reg 0x47001000 0x1000 9ethernet peripheral fig.
an example of the device tree of ox820 nas7820 soc.
void gic mmio read gic offset state machine gic read offset void gic mmio write gic offset value state machine gic write offset value linux kernel qemugic write32 gic read32 full dummy void gic mmio read gic offset return get init value gic offset void gic mmio write gic offset value gic mmio write gic mmio read fig.
an example of qemu peripheral emulation.
firmguide supports both fully functional and dummy peripheral models.
of time counting.
the linux kernel maintains the timeline by periodically reading this timer s count register.
the device tree describes the hardware information of an soc.
it is passed to the linux kernel at the beginning of the booting process.
the linux kernel then uses it to correctly initialize peripherals.
it has a property named compatible which is the model number.
for example as shown in figure the top level compatible is the model number of the soc and the second level is the model number of the specific peripheral i.e interrupt controller .
besides the device tree has a rich description of a peripheral including its mmio ranges irqn input clock frequency etc.
we retrieve the description from the device tree for further analysis.
memory mapped i o memory mapped i o mmio is one kind of communication method between software and hardware.
with the help of mmio the linux kernel can map physical registers of a peripheral to the physical address space.
therefore from the linux kernel s perspective it can interact with the peripheral reading or writing registers as it interacts with the memory reading or writing memory .
the port i o pio is not considered in this paper due to the following consideration 1our key method also works for pio cases 2pio is rarely used in our target firmware.
qemu qemu is one of the most popular full system emulators that consists of peripheral models.
in figure the peripheral model implements read and write callback functions for its registers.
when the embedded linux kernel reads from an mmio address the read callback function will be invoked.
the write callback function works similarly.
a fully functional peripheral model has a state machine that emulates the peripheral s functionality.
if there is no such state machine we call this a dummy peripheral model.
leaving the real functionality unimplemented we usually need to initialize itsmmio address space with proper initialized values.iii.
p roblem statement and solution our goal is to boost the capability of rehosting embedded linux kernels in qemu.
to rehost these embedded linux kernels we first discussed with a well experienced embedded system engineer what he normally did to support a new device.
according to his experience we were surprised to know that given the source code of a linux based firmware extending itto support a new iot device till kernel booted successfully e.g.
spawn a userspace shell only requires the adaption of the driver code of certain peripherals.
this fact implies that the task for emulating the linux based firmware may not be as complex as it looks may only require several key peripherals .
to better understand this we systematically analyzed the booting process of the linux kernel and the emulation mechanism of a peripheral inside qemu.
we summarized the identified key challenges and observations for the rehosting as the following.
challenges 1a real physical embedded device usually has multiple peripherals and it is tedious and error prone to emulate them manually.
the statistics of device tree blobs of openwrt firmware shows that the number of peripherals per device ranges from to around on average.
2the embedded linux kernels share common types of peripherals for different socs e.g.
interrupt controller or timer but these peripherals follow different hardware specifications provided by different soc vendors which is impractical to manuallyimplement all of them.
3every peripheral s interfaces hardware registers have diverse semantics thus making the construction of a peripheral model more challenging.
thediversity resides in two aspects.
on one hand through the peripheral interfaces the linux kernel can retrieve the status and control the behavior of the peripheral.
the peripheralmaintains its inner states and reacts according to differentinterfaces.
on the other hand a peripheral interface itselfhas semantics as well.
for example an interrupt controller maintains the status masked unmasked etc.
of each interrupt source inside a register.
a single bit flip of this register can lead to the change of the hardware s inner states.
building a successful peripheral model usually requires the understanding of its inner states state transitions and hardware register semantics.
observations 1achieving our goal requires the full functionality emulation of only a few peripherals.
we define a successful rehosting of the linux kernel when the cpu has entered the user mode to execute the initialization process run init process .
though a successful rehosting process involves dozens of different peripherals 32on average they can be divided into two types.
specifically type i peripherals include the ones which have complicated interactions with the linux kernel and need to be emulated with their full functionality.
this type of peripherals includes interrupt controller timer and uart.
a popular ns16550a uart has been well supported in qemu and can be reused directly.
however the rest of type i peripherals i.e.
interrupt controller and timer require fully functional emulation.
we define type ii peripherals as the ones which only require minimum emulation define x1 reg mask define x2 0x1 void qemu mmio read addr if addr intc reg mask msk read true return x1 if addr intc reg status if irq 3 activate return x2 void qemu mmio write addr value if msk read value x1 0xfffffff7 x1 value a r w seq matches do transition event irq 3 mask static void handle irq callback ... u32 pending readl intc reg status while pending u32 irq ffs pending generic handle irq irq pending irq static void irq mask callback u32 irq u32 mask readl intc reg mask mask irq 0x1f writel mask intc reg mask linux kernel driver code qemu peripheral code a b c a l3 mmior intc reg mask x1 l5 mmiow intc reg mask x1 0xfffffff7 b l3 mmior intc reg status x2 state transition on r w seq d matches unmsk msk inactirq activate matches act fig.
examples for using r w seq to guide kernel s execution a b show recognition and control respectively c shows the r w seq matching in the peripheral model d details the state transition by r w seq.
the mmio operations in a b are marked in grey macro intc reg xxx represents the mmio register addresses and ffs is short for find first set .
as a dummy mmio memory region with proper initial values.
they only need to provide suitable values when the linux kernel reads specific peripheral registers mmio read during the booting process.
no inner states of the peripherals need to be emulated.
such peripherals include network card flash etc.
2the linux kernel has well defined abstraction models for different types of peripherals.
the linux kernel core upper layer abstracts a type of peripherals as one device with a set of common actions.
each device driver lower layer has to implement these actions.
for the typei peripherals interrupt controller and timer the upperabstraction layers are the interrupt and the time subsystems respectively.
the lower implementation layers are the low level device drivers of the peripherals.
for instance in the interrupt subsystem each interrupt controller is an instance of struct irq domain and the common actions are callback functions like irq domain irq mask irq domain irq unmask irq domain irq ack etc.
a low level device driver provides the functions implementation.
in the rest of the paper we use critical functions to represent these callback functions.
3well defined abstraction models and kernel peripheral interactions can be combined to describe the peripheralinterfaces.
the above mentioned kernel abstractions inspire us to build a peripheral model in qemu that combines kernelperipheral interactions to guide the kernel s execution to asuccessful rehosting hence the name model guided kernel execution .
specifically the peripheral model is a state machine summarized from the upper layer subsystem .
it defines the states and available state transitions.
this state machine can be manually extracted from the linux kernel source code which is a one time effort.
besides the peripheral model needs to recognize executed critical functions and then react accordingly.
a key intuition is that mmio read write sequences r w seq from the linux kernel to the peripherals are signatures to represent the execution paths of a critical function.
they can be used in recognizing the paths of critical functions that the linux kernel has executed and controlling the linux kernel s following execution by returning specific values to the linux kernel in an mmio read request.
a path s r w seq can be automatically inferred via symbolic execution.a motivating example figure shows an example of using r w seq to guide kernel s execution.
the mmio operation is marked as mmior mmiow addr expr where mmior mmiow is read write operation addr is read write address and expr is the value the linux kernel reads from writes to the peripheral model.
for simplicity we only consider irqn .
figure a shows a simplified irq mask callback function to demonstrate how to recognize its execution from the peripheral s perspective.
the linux kernel calls it to mask a specific interrupt source the irq argument .
given a concrete irq value e.g.
the r w seq is mmior intc reg mask x1 mmiow intc reg mask f x1 where x1is a symbol representing the mmio read value and f x1 x1 0xfffffff7 .
as shown in figure c by matching the r w seq the peripheral recognizes that the linux kernel is calling irq mask .
specifically the peripheral can figure out the irqn by checking whether x1 returned to the linux kernel and value written to the peripheral satisfies the equation f x1 .
after matching the r w seq the peripheral recognizes the event the linux kernel masks the interrupt source whose number is and shifts its state correspondingly.
figure b is an implementation of handle irq callback to demonstrate how to control its execution from the peripheral sperspective.
once the linux kernel receives an interrupt request from the interrupt controller it calls handle irq to dispatch the request of the irqn obtained from the interrupt controller.
the r w seq is mmior intc reg status x2 where x2 stands for the mmio read value.
the peripheral can control the execution times and the argument of generic handle irq by providing a crafted x2.
in figure c after matching the r w seq the peripheral returns 0x1 and tells the linux kernel that the interrupt source should be triggered after reading intc reg status .
lastly as shown in figure d we found that r w seq can behave as the state transition condition in the peripheral model by guiding the kernel s execution towards a specificcode path.
intuitively we can create a full state machine ofthe peripheral by manually building the general peripheral model of the states and transitions using the linux kernel s abstraction and extracting r w seqs as the transition condition use symbolic execution to analyze the critical functions .
795linux kernel source code parameters generationdevice models component offline model generation qemu virtual machine compositionbinary firmware component online kernel bootingfirmguide model template model parameterstemplate construction fig.
firmguide architecture.
model guided kernel execution based on the above observations we proposed a new method called model guided kernel execution to emulate the type i peripherals.
we split the peripheral model into two parts the model template peripheral independent part and the model parameters peripheral dependent part .
specifically for each type of peripherals we manually build its model template from the linux kernel subsystems section iv a and the model parameters are automatically generated from the low level driver code section iv b .
therefore our model generation for each specific peripheral works like a fill in the blanks process.
finally the generated models can guide recognize and control the kernel s execution to a successful rehosting.
we have developed a prototype named firmguide .
figure shows its architecture.
it consists of two components offline model generation and online kernel booting.
the first component analyzes the linux kernel source code to generate peripheral models while the second rehosts embedded linux kernels using synthesized qemu virtual machines equipped with the generated peripheral models.
note that though our system requires the linux kernel source code in the offline component there is no need for source code in the online kernel booting.
section iv and v detail these two parts respectively.
iv .
o ffline model generation in the offline model generation we use model guided kernel execution to semi automatically generate the peripheral models for interrupt controllers and timers with the linux kernel source code.
the generated peripheral models c code canbe compiled with qemu to provide the full functionalityof the peripherals.
figure shows its procedure.
the model generation process has two parts the manual model template construction and the automatic model parameters generation.
as shown in figure the model templates are inducted from the linux kernel subsystems.
the template for each type of peripheral contains a state machine that communicates with thelinux kernel subsystems via critical functions.
in other words if the model template knows exactly which critical function the linux kernel has executed it will react correctly by shifting its inner states and taking the following actions.
the model template implements the nodes states and the unidirectional edges state transition table of a state machine but leaves thetransition conditions as blanks triggering of events .
note that the model template construction is a one time effort for each type of peripherals.
the model parameters generated by analyzing the low level driver code are designed to describe the transition conditions.
note that the conditions for triggering these events are theexecutions of specific paths of the critical functions.f o r example in figure a the event of masking interrupt source irq means the calling of irq mask callback with argument irq.
to describe these events we combine three methods to extract all necessary information basic r w seq extraction section iv b cfsv handling section iv c and value s semantics inference section iv d .
the first one generates the basic r w seq of an execution path of a critical function.
the last two complement the first method and extract additional properties of the execution path for the cases where only using r w seq is not enough.
a. template construction the model template construction is to build a state machine containing all actions of that type of peripherals.
to do so we first studied the abstraction of the interrupt controller and timer subsystems in linux.
specifically there are three kinds of events that can be triggered for a given peripheral which are the linux kernel other connected peripherals and the peripheral itself.
for example an interrupt controller has events like masking an interrupt from the linux kernel requesting for firing an interrupt from other peripherals and selecting an interrupt to fire from itself .
based on the defined events we design the states and the state transition table but leave the transition condition triggering of the events as blanks.
note that only transition conditions from the linux kernel are handled as blanks while others have simple conditions like raising or lowering the interrupt signal.
we manually designed eight to nine events and four to five states for the edge and level triggered interrupt controllers.
similarly we have two models for clkevt timers with nine events and four states and clksrc timers with four and two.
you can find more detail about these manually built model templates in .
b. basic r w seq extraction a basic r w seq is a sequence of mmio read or write operations which used to represent a specific execution path of the critical function.
indeed more than half of the cases only use the basic r w seq to represent the transition conditions.
we apply symbolic execution to the critical functions to find out the mmio operation sequences of the paths which can represent specific functionality e.g.
mask interrupt source whose number is .
these operation sequences are called the basic r w seq.
figure shows its general workflow.
boot context preparation applying symbolic execution directly to a critical function needs an execution context.
we create a simplified booting process to get the initial context of the related kernel subsystems.
specifically the booting processis simplified from the linux kernel start kernel but only does necessary initialization of kernel subsystems i.e.
only keep 796irq subsystem timer subsystem low level drivers device tree blobmodel template model parameters read 0x1234 0x0 write 0x1238 0x3 ...intc init ... timer init ... ... qemu devicekernel subsystems device drivers linux kernelbasic r w seq extraction cfsv handling value s semantics inferencemanual induction template construction parameters generation fig.
overview of model guided kernel execution.
start ext iv cboot context preparationlast context used?replay contextlast tc profiled?set execution goalparameter inference n yny profile tc terminate fig.
general workflow of basic r w seq extraction.
tc stands for a transition condition.
the dotted arrow marks the extension mentioned in section iv c. interrupt and time subsystem initialization code .
applying the symbolic execution to this booting process we may get multiple paths that can successfully finish the whole booting process.
each path and its memory status initial values is one valid boot context because multiple hardware configurations can correctly boot the linux kernel in practice.
the initial values are obtained after the constraint solving.
moreover the context preparation also solves the problem of inferring initial values for type ii peripherals.
note that we introduce a new symbol for each mmio read operation in this and the following symbolic execution since it is indeed a volatile operation.
replay context after the boot context preparation the symbolic execution engine klee has maintained several booting contexts in memory.
before executing critical functions we additionally implement a context replay technique to recreate these booting contexts by rerunning the boot process with one valid boot context.
as klee only uses one host cpu to perform the state exploration for each booting context we analyze all transition conditions independently such that the replay technique can also make full use of the host cpu resources to speed up the analysis.obtain transition conditions the next step is to obtain the transition conditions based on the model template.
for instance the model template of interrupt controllers requires us to collect the transition conditions for critical functions including irq mask irq ack irq unmask etc.
for each interrupt source we obtain the list of the interrupt sources from the device tree .
each transition condition is noted as the pair execution goal critical function .
we first prepare the list of the pairs from the state machine and then obtain each transition condition by symbolically executing profiling the critical function with the execution goal.
we use a pass of analysis to represent the enumeration of this list.
set execution goal the execution goal is to describe the desired path that implies the transition condition.
each critical function may have multiple paths and the desired path is the1 define mask addr 0xffff0014 2voidirq mask u32 irq 3u32 mask 0x1 irq the mask cache is a cfsv i.e.
a non local variable and a symbolic value.
mask cache mask 7writel mask cache mask addr fig.
a simplified cfsv example one to finish its real functionality.
for example in figure b to find the execution path of the firing interrupt source whose number is the execution goal should be in the following it must call generic handle irq once and only once 2it must call generic handle irq and pass as the first argument 3it must return from the function without error.
profile transition condition the mmio operations in the path that satisfy the execution goal are traced as the profile.
parameter inference the following rules are used to infer the basic r w seq from the profile.
1for an mmio read if the symbol value has constraints we append a new node mmior addr value to the basic r w seq list where the value is the concrete value provided by the constraint solver.
this node tells the peripheral model to return a value when the linux kernel reads from this mmio address.
2for an mmio read if the symbol has no constraints we append a new node mmior addr use last value to the basic r w seq list.
this node tells the peripheral model to provide the last value written to the same mmio address when reading from it.
3for an mmio write we append a new node mmiow addr match expr where the match is a function used by the model to check whether the value written by the linux kernel satisfies the expr .
c. cfsv handling basic r w seq works well in cases where there is no data exchange between two critical functions in a pass of analysis.
from our experience this assumption is tenable for major cases.
however the data exchange can happen between two executions of the critical function.
specifically it happens through the read and the write operations to a non local variable in two executions.
a non local variable for a function is the variable whose life cycle is longer than that function e.g.
global variables and heap variables.
figure shows an example.
the mask cache in line is a heap variable.
it records the current mask status of all interrupt sources.
it is updated whenever the linux kernel invokes the irq mask orirq unmask and is also used in line .
this leads to a problem that the profiled expr in line cannot match the real scenario because the value 797algorithm cfsv detection input ctxt symbolic execution context output cfsv s recognized cfsv set 1init empty set cfsv s nonlocal rw 2do state merge begin label known cfsv s inctxt records do a pass of analysis using ctxt nonlocal rw extract memory r w info from records state merge end update cfsv s based on merged nonlocal rw 9while cfsv s has increased written in line can be changed.
therefore the mismatch will happen and the peripheral model cannot work properly.
cfsv definition we first introduce a concept called cross function symbolic v ariable cfsv .
cfsv is a non local variable that is both read and written after a pass of analysis.
since the value of a cfsv can be updated in one function and be used in another function its value depends on the execution amount and execution order of these critical functions.i fa critical function is cfsv free the basic r w seq is enough to describe the transition condition.
conversely if not cfsv free read or write cfsv we need to record cfsv read write operation extend the basic r w seq by adding the cfsv information then emulate the cfsv in the peripheral model.
cfsv detection algorithm depicts an algorithm that finds the cfsvs incrementally.
there are several assumptions to guarantee that the algorithm can finally converge 1no new allocated memory among all critical functions 2no symbolic pointers 3the critical function is at a reasonable size so that the symbolic execution can finish its exploration.
these assumptions ensure the amount of the cfsvs is finite and fixed.
therefore the cfsv s in algorithm is a monotonically increasing set with an upper bound.
consequently the algorithm can reach a fixed point at last.
note that line and line use a technique in klee called state merging .
we adjust it to support additional merges of cfsv related information.
merging state helps us aggregate the cfsv read write operations in a pass of analysis while keeping the number of contexts unchanged.
line labels known cfsv s in the context and all known cfsv s are regarded as fake mmio registers i.e.
every read of cfsv introduces a new symbol.
the reason is that cfsv can be changed during the execution.
thus we symbolize it as any possible value an over approximation to maximize the path exploration.
in line we collect all non local variables read write information in each state and then merge the information.
after that we use the information to update the cfsv s .
the cfsv detection is added at the dotted arrow in figure .
to handle the cfsv we emulate its data propagation in our model.
similar to the cfsv detection we treat the cfsv as a fake mmio register in the pass of analysis.
the introduced symbols are marked with cfsv labels in the profile.
then werecord its data propagation in parameter inference by extending basic r w seq with two new types of nodes called cfsvr addr val and cfsvw addr expr .
finally we allocateglobal variables and emulate the data propagation of cfsv along with the basic r w seq in the peripheral model.
d. mmio v alue s semantics inference the above two methods solve the problems of describing a path of critical function.
however to emulate a timer the model needs to understand the semantics of the mmio register s value for correct reaction to some critical functions.
one case is that our timer model needs to understand when the linux kernel wants to fire the next timer interrupt.
firstly the linux kernel determines a value in cycle t a tick for the timer device the smallest unit .
then it aligns the unit with the specific timer device.
the formula of the unit conversion can be collected during the symbolic execution.
however from the emulated timer s perspective understanding the time period represented by the linux kernel written value requires us to convert back the value s unit to the common one cycle t .
that means we need to perform the reverse operation for the formula.
mostly the conversion formula is as simple as y k xwhere kis a constant and x y are the time periods represented in two units.
we can directly detect these cases and handle them in a lightweight way hardcode their inverse functions .
if we meet a complicated conversion formula we need a constraint solver in the peripheral models.
to the best of our knowledge we did not meet a complicated formula in real world cases.
we again extend our basic r w seq by adding unit conversion information.
this extension helps our emulation to provide accurate time emulation for timer peripherals.
e. implementation detail in the offline model generation the model template has lines of c code for the interrupt controller for timer .
the parameter generation part is based on klee including lines of c code for static analysis lines of c code for patching klee and lines of python code for gluing.
preprocessing of source code firmguide leverages llvm and klee to perform static analysis on the linux kernel source code.
we preprocess the code for three reasons.
1we replace the inline assembly with the equivalent c functions because llvm cannot analyze assembly code.
2we simplify some libraries functions and change static variables to be visible to other modules to make the analysis easier.
note that this is a one time effort since we only change common header files 3moreover these changes targeting small functions and limited variables do not affect the static analysis results since we do not change the code semantics.
analysis based on symbolic execution our symbolic analysis is developed upon klee.
the input is the target linux kernel source code as well as its device tree.
theoutputs are generated model parameters.
these parameters will be rendered into the model template to generate peripheral models that can be directly compiled with qemu.
in detail we compile the target linux kernel source code as a linked llvm ir file and run the symbolic execution on the ir 798table i overview of representative openwrt subtargets.
subtargetsource code firmware rev.
of openwrtver.
of linuxkernarchitecture o f firmware o f socs o f vendors ramips rt305x .
.
.
mipseb ath79 generic .
.
.
.
mipsel kirkwood generic .
.
.
armel bcm53xx generic .
.
.
armel oxnas generic .
.
.
armel summary file.
the following strategies are applied.
1control the symbolic execution s flow by feeding the bogus entry point of the linked ir.
we add our main function to the llvm ir file and therefore the symbolic execution will start there.
inside the main function firstly the simplified kernel booting process e.g.
time init init irq will be executed to get the booting context then the analysis code is launched to generate the template parameters figure .
2hook an entire library of the linux kernel by linking our customized implementation rather than the original code.
our customized libraries cover the linux kernel s interrupt subsystem time subsystem devicetree libraries memory management and stdlib facilities.
this simplifies the symbolic execution and avoids the possible pathexploration.
3add auxiliary features facilitating the analysis mainly by extending the klee s specialfunctionhandler interface.
v. o nline kernel booting the online kernel booting component is implemented with several existing tools.
given a firmware image we first retrieve the linux kernel and the device tree from the image using binwalk .
we then extract the peripheral list from the device tree.
for each peripheral in the list we use its compatible property in the device tree entry to match the generated peripheral models in offline model generation.
this is feasible because we organize the generated peripheral models by the same compatible property.
the peripheral models c code will be compiled together with the qemu.
to add a new virtual machine in qemu we need to write a machine file in c language that initializes all peripherals.
we automatically generate a generic machine file and finally use the generated qemu virtual machine to rehost the linux kernel along with aprepared ram file system ramfs that is generated by buildroot.
this component is written in python with lines of code.
vi.
e v aluation a. experiment setup to evaluate the effectiveness of our system we conduct experiments using firmware images downloaded from openwrtcovering multiple socs.
the source code for a family of socs is organized in a subtarget.
we select the top five subtargets covering 26socs and 90vendors following three criteria they support device tree they cover different architectures and endianness they are popular due to a number of released firmware images .
table i shows the details of ourdataset.
the number of ramips rt305x firmware images is larger than others because openwrt has more firmware imagesreleased for ramips rt305x.
note that we conduct experiments on openwrt because this dataset has covered diverse socs vendors architectures and kernel versions making the dataset representative.
we conducted all experiments on a server with two intel xeon silver processors 128gb ram ubuntu .
.
lts system.
we have released the docker image of thegenerated qemu virtual machines and part of the firmware images used in our evaluation .
b. offline model generation model parameters generation as shown in table ii firmguide generates model parameters for 9type i peripherals.
note that we do not generate parameters for timers marked as not necessary in two mips subtargets.
because the qemu mips processors have implemented these timers.
specifically the 4th column shows the number of paths that the symbolic execution engine explores during the model generation.
the 5th column shows the final solutions our system finds for a successful rehosting.
the longest time to find the first solutionis still within one hour showing that our approach is faster than developing the peripheral models manually.
the 6th column details the time to get the first solution and all solutions.
the 7th column gives the existence of cfsv .
the 8th column presents the unit conversion formula used in the timer for thatsubtarget.
the xrepresents a time interval that aligns with the specific timer s unit yis the value in terms of cycle t .w e usex1 x2to represent two registers that the peripheral uses to present the time.
the last column lists the lines of the code for the generated peripheral models.
type ii peripheral for type ii peripherals we automatically generate their peripheral models without state machines but with the proper initial values of their hardware registers.
the values are calculated in the boot context preparation section iv b .
table iii shows the number of type ii peripherals emulated and of those having non zero initial values.
in total type ii peripherals out of have non zero initial values.
c. online kernel booting besides offline model generation we conduct experiments to rehost a number of firmware images.
the results show that our generated qemu machines can successfully rehost more than of the linux kernels.
during the evaluation we check whether the linux kernel image has switched to user mode by parsing the cpu register file traces provided by qemu debug option d cpu .
we also check whether the ramfs has spawned a shell by detecting the booting messages i.e.
welcome to buildroot .
the overall result is shown in table iv.
in total for6 firmware images of them are successfully unpacked.
we retrieved linux kernels.
among them .
enter the user space and .
successfully spawn shells.
we manually analyzed the reasonsfor the failed cases.
triggering of a double free bug some linux kernels in kirkwood generic suffer from a double free bug in the function orion nand probe where clk put will be called twice 799table ii results of offline machine model generation.
subtarget interrupt controller timer o f paths o f solutionsfirst all solution s exists cfsv y n timer semanticsloc ramips rt305x ralink rt2880 intc not necessary n ath79 generic qca ar7240 intc not necessary n kirkwood genericmarvell orion intc marvell orion bridge intcmarvell orion timer y y x bcm53xx generic arm cortex a9 gicarm cortex a9 global timer arm cortex a9 twd timer150 yy x1 x23 oxnas generic arm arm11mp gicarm arm11mp twd timer plxtech nas782x rps timer52 y y x table iii the fraction of type ii peripherals with non zero initial values of all type ii peripherals emulated in each subtarget.
subtar getramips rt305xath79 generickirkw ood genericbcm53xx genericoxnas generic count if the flash device does not exist.
this bug exists in the linux kernel before .
.
interestingly this bug will not be triggered ona physical router device since it usually uses the flash device as the external storage.
however it is triggered in firmguide since we only have a dummy flash device in the emulator.
unsupport of the root filesystem!
some linux kernels in oxnas generic do not support the ramfs that is supported by the linux kernel by default.
we suspect that the support of this file system is removed to reduce the image size.
d. firmware diversity we further study the scalability of firmguide by exploring the diversity of the rehosted linux kernels.
figure shows that firmguide can rehost diverse embedded linux kernels.
architecture firmguide supports linux kernel images in arm32 with little endian mips32 with both big and littleendian figure 8a .
our system is architecture independent.
kernel version firmguide can rehost 4major and distinct minor versions of embedded linux kernels no matter when they were released showing that the generated model is not binding to the particular kernel version figure 8b .firmware format we extended binwalk to support seven firmware formats listed in figure 8c.
among them the legacy uimage is the most popular firmware format.firmware size the size of supported firmware varies from mb to mb and the average is about .6mb figure 8d .
soc and vendor as shown in table iv firmguide has supported 26socs.
in figure 8e we list the number of firmware images for the top ten vendors.
e. functionality we conducted two experiments to demonstrate the functionality of the firmware booted by firmguide .
first we use the syscall testings of ltp linux testing project to these booted firmware images.
ltp contains testings of file systems io memory management scheduler etc.
in total for all system call tests of them have been passed of them were skipped since these tested system calls have not been introduced at the kernel version of these booted firmwareimages and of the tests failed.
we analyzed the failed tests and summarized the failure reason table vi .
most failures are caused by the dummy network devices or non implementedtable iv results of online kernel booting.
unpack number of unpacked firmware images.
kernel number of the linux kernels detected.
user space number of the linux kernels entering into user space.
shell number of the linux kernels spawning shells.
soc unpack kernelbooting validation user space shell ralink rt3050 .
.
ralink rt3052 .
.
ralink rt3352 .
.
ralink rt5350 .
.
subtar get ramips rt305x .
.
atheros ar7161 .
.
atheros ar7241 .
.
atheros ar7242 .
.
atheros ar9330 .
.
atheros ar9331 .
.
atheros ar9341 .
.
atheros ar9342 .
.
atheros ar9344 .
.
qualcomm atheros qca9531 .
.
qualcomm atheros qca9533 .
.
qualcomm atheros qca9557 .
.
qualcomm atheros qca9558 .
.
qualcomm atheros qca9560 .
.
qualcomm atheros qca9561 .
.
qualcomm atheros qca9563 .
.
subtar get ath79 generic .
.
broadcom bcm4708a0 .
.
broadcom bcm4709a0 .
.
broadcom bcm47189 .
.
subtar get bcm53xx generic marv ell 88f6192 .
.
marvell 88f6281 .
.
marvell 88f6282 .
.
subtar get kirkwood generic .
.
plx nas7820 .
.
subtar get oxnas generic .
.
!
overall .
.
table v results of system call tests.
models pass skipped failed total fully generated ground truth system calls the linux kernel contained in that firmware does not support that syscall .
second we compared the functionality of the peripherals generated by firmguide with the manually written peripherals.
plxtech nas7820 device is used for the comparison.
to manually write the emulation code of peripherals we first learn the driver source code of the type i peripherals then write the qemu emulation based on human understanding.
it costs around week person to write the emulation code of the type i peripherals for plextec nas7820 device assuming has already learned the driver development background and the cost time a architecture b kernel version c firmware format d firmware size e top vendors fig.
we can rehost linux kernels in different architectures linux kernel versions firmware formats firmware sizes mb and firmware vendors.
in figure 8b .
.x has sub versions .
.x has and .
.x has sub versions there are distinct versions in total.
table vi reasons of failed system call tests.
reason count bugs or vulnerabilities of the linux kernel are not patched netw ork device is not available some syscalls are not implemented other total table vii results of testing 6cves for the rehosted kernel.
indicates a successful trigger and indicates a successful exploit while indicates a failure.
the other three symbols square triangle represent different versions of the linux kernel on which we triggered or exploited the vulnerabilities square .
.
.
.
triangle4.
.
.
cve id cve type status version cve race condition n a cve race condition square cve integer overflow square cve integer overflow cve buffer overflow triangle cve null pointer dereference square includes both the code development and debugging .
table v shows the results where ground truth represents the manually written emulation code.
the results show that the generated board has identical functionality as the manually written one.
vii.
a pplications we applied two security applications on firmguide to demonstrate its usage scenarios.
note that these applications are demonstrative and not our main contribution.
other tools that build upon qemu e.g.
s2e can also be applied.
linux kernel vulnerability analysis we first collected linux kernel vulnerabilities shown in table vii and then analyzed them on several linux kernels targeting a plxtech nas7820 device with the ox820 nas7820 soc arm .
we then used firmguide to rehost the embedded linux kernels.
next with the debugging capability of qemu we managed to trigger of them develop linux kernel exploits and show the reasons for failed cases.
vulnerability triggering after inspecting this new execution environment with the debugging capabilities of qemu 5vulnerabilities have been successfully triggered laying a foundation for further exploitation.
the reason that cve a.k.a dirtycow cannot be triggered is the limitationof the target firmware itself.
the linux kernels inside these firmware images do not support madvise system call which is necessary to trigger the race condition.vulnerability understanding and exploiting for the rehosted vulnerable linux kernels we use the debugging capabilities of qemu to understand the vulnerabilities search the exploitable function pointers and successfully develop exploits.
for example cve a buffer overflow vulnerability is triggered when the packet processing routine switches from the ufo udp fragment offload path to the non ufo one.
to exploit it the skb prev lenand the offset of the hi jacked pointer have to be carefully calculated.
we used the qemu remote gdb to find an appropriate overflow size.
the detailed process of the exploit and the usage of the gdb are shown in .
fuzzing we also ported two fuzzing tools triforceafl and unicorefuzz to demonstrate the usage scenario of firmguide .
due to the page limitation the detailed running status of these fuzzing tools is shown in .
note that firmguide doesn t focus on any specific fuzzing technique but provides the infrastructure of dynamic analysis platforms towards embedded linux kernels.
viii.
d iscussion threats to validity the threats to validity comes from three aspects.
1in our method the model templates should be manually built by human experts.
this manual process possibly can be the bottleneck if the state machines of some complex type ii peripherals are too complex.
2to migrate the method to the same or other peripherals in the same or other oses our method requires a peripheral interface at a suitable layer in the target os.
the layer is suitable when it is a common interface and its functions have clear semantics of the peripheral otherwise the r w seq cannot effectively guide recognize and control the kernel s execution.
3we use symbolic execution to find usable booting context andr w seq.
if the critical function is complex the parameter generation process may fail due to the path explosion.
however from our experience in supporting linux path explosion isnot a fundamental threat as the critical function tends to be simple.
besides our context replay in section iv can make the generation process running in parallel klee itself doesn tsupport running in parallel .
furthermore we don t need to find all solutions for a given source code as finding one satisfying path for the boot process and one r w seq for each state transition condition is enough.
801full emulation of type ii peripherals full emulation of type ii peripherals can enable more interesting functionalities of the rehosted linux kernel like the network facility and make the rehosted linux kernel complete pass all syscall tests in ltp in evaluation .
since dummy type ii peripherals do not affect the successful rehosting of the linux kernel full emulation of them is out of the current work s scope.
however the lack of type ii peripherals limits the ability for conducting dynamic analysis on the code that relies on the functionality of these peripherals e.g.
fuzzing on these drivers.
therefore we leave the support of type ii peripherals as future work.
from our perspective fully emulating more type ii peripherals requires more engineering efforts and perhaps the current emulation methods should be adjusted or further improved according to the target peripheral s specification.
note that using dummy type ii peripherals doesn t mean their drivers in the rehosted linux kernel cannot be dynamically analyzed.
specifically thehardware independent code in these drivers can still be analyzed as long as their driver is successfully initialized as shown in ex vivo .
using the shell provided by firmguide these parts of code can be directly tested through their user space interfaces e.g related ioctl system calls.
ix.
r elated work firmware rehosting firmware rehosting is to dynamically run the firmware on a virtual execution environment.
onetype of firmware re hosting focuses on transferring codeexecution between the virtual execution engine like qemu and the physical device.
in this way avatar prospect surrogates and kammerstetter et al.
boosted thecapability of the dynamic analysis of embedded system firmware.
these systems are precise but suffer from hardware availability and debug interface availability.
the other approaches aim at full system emulation.
for bare metal devices gustafson et al.
managed to replace real devices by modeling the code execution between qemu and the physical hardware traced by avatar.
later p2im collected the instruction trace and then instantiated predefined models.
halucinator identified hal apis in firmware and replaced them without hardware emulation.
p2im and halucinator successfully performed dynamic analysis on the firmware of bare mental systems without physical devices.
our work instead focuses on the linux kernel.
for linux based devices firmadyne provides a utility to dynamically analyze the user space programs.
other similar systems also focus on user space programs.
firmguide is different from them because we can rehost and analyze the original linux kernels inside the firmware while others cannot.
luaqemu manipulated the code execution by a lua script while firmguide would not change it.
partemu extends qemu to support the analysis of trustzone oses rather than the linux kernel.
simics is a full system clock accurate simulator that is popular inhardware software co design.
theoretically firmguide can be used to further facilitate simics by semi automaticallygenerating the device emulation code using simics s own device modeling language.
firmware analysis researchers propose several static analysis tools to disclose vulnerabilities in the firmware .
meanwhile dynamic firmware analysis systems are also developed .
firmguide enables the dynamic analysis of the linux kernel on embedded systems which can be leveraged to develop dynamic security analysis frameworks.
application with qemu besides firmware rehosting and analysis qemu is also applied in other scenarios e.g.
malware detection and forensics .
however previous qemu based applications mainly target desktop or android.
firmguide aims to support embedded linux kernels which enriches the security applications in this area.
x. c onclusion in this paper we proposed a new technique called modelguided kernel execution to rehost linux kernels of embedded firmware.
it leverages kernel s abstraction for peripherals and kernel peripheral interactions to semi automatically generate stateful peripheral models.
then the generated model can be used to synthesize qemu virtual machines to rehost embedded linux kernels.
we have implemented a prototype system called firmguide .
it generates 9peripheral models with full functionality and 64with minimum functionality covering socs.
our evaluation with firmware images downloaded from the internet shows that it can successfully rehost more than linux kernels covering architectures and 22versions.
two security applications have been applied on the rehosted kernels to demonstrate firmguide can build the foundation of dynamic analysis tools for embedded linux kernels.
acknowledgment the authors would like to thank the anonymous reviewers for their insightful comments that helped improve the presentationof this paper.
special thanks go to mathias payer zhi wang for their constructive suggestions and comments.
this work was partially supported by the national natural science foundation of china grant no.
the fundamental research funds for the central universities zhejiang university ngics platform k20200019 leading innovative and entrepreneur team introduction program of zhejiang no.
2018r01005 hk rgc project no.
polyu 18e the nationalresearch foundation singapore under its the ai singaporeprogramme aisg2 rp the national researchfoundation through its national satellite of excellence in trustworthy software systems nsoe tss project under the national cybersecurity r d ncr grant award no.
nrf2018ncr nsoe003 .
any opinions findings and conclusions expressed in this paper are of the authors and do not necessarily reflect the views of funding agencies.