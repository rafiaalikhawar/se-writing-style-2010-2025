from leaks tofixes automated repairsforresource leak warnings akshayutture university ofcalifornia losangeles usa akshayutture ucla.edujens palsberg university ofcalifornia losangeles usa palsberg ucla.edu abstract resourceleaksareacommonandelusivesourceofbugsthatcanresultin crashes andsecurity vulnerabilities.
the mosteffective techniquetoidentifysuchleaksduringdevelopmentisstaticanalysis.
however empirical studies show that in addition to leak warnings developers often need help in the form of automated fix suggestions to correctly repair such leaks.
the only existing tool that can suggestresource leakfixesisthegeneral purposetoolfootpatch.
footpatch however performs poorly at this task it generates fixes for only ofthe leaks outofwhich only are correct.
in this paper we introduce rlfixer a specialized repair tool that generates high quality fixes for resource leaks identified by anyresource leakdetector.amajorchallengeforrlfixeristhat themostgeneralversionoftheresource leakrepairproblemisat least as hard as compile time object deallocation a well known hardproblemforcompilers.rlfixertacklesthisissuebyseparating the resource leaks that are infeasible for a compile time tool to fix from those that are feasible to fix.
rlfixer achieves this separation by using a new data flow analysis of resource objects to classify howtheyescapethecontextoftheirmethods.thesameanalysis also enables rlfixer to generate correct repairs for the feasibleto fix leaks.
rlfixer is demand driven and hence only analyzes statements relevanttothe leak thereby keepingoverheadlow.
weevaluatedrlfixerbyapplyingittowarningsgeneratedby fivepopularjavaresource leakdetectors.weshowthat onaverage rlfixergeneratesrepairsfor66 oftheirwarnings outofwhich are correct.ithas an averagerepairtime of14 seconds.
ccsconcepts software and its engineering automated static analysis software maintenance tools .
keywords static analysis resourceleaks automatedrepair acm reference format akshay utture and jens palsberg.
.
from leaks to fixes automated repairsforresourceleakwarnings.in proceedingsofthe31stacmjoint european software engineering conference and symposium on the foundations of software engineering esec fse december san esec fse december san francisco ca usa copyright heldby theowner author s .
acm isbn .
ca usa.
acm new york ny usa 13pages.
.
introduction motivation.
mostprogramsuse resourcessuchas files sockets and database connections.
resource leaks are a common bug introducedunintentionallybyprogrammers whichcanresultinsecurity vulnerabilities andseverefailures .resourceleaksareelusive because they only cause crashes when many resources leak andtheosrunsoutofthatresource type thistypicallydoesnot happen during testing.
an effective approach for identifying these resource leaks during development is static analysis .
today developers can choose from several open source static analysis tools that perform resource leak detection many of which provideaccuratewarnings.
whilestaticanalyzerscandetectresource leaks usersalsoneed tool support to fix these errors.
for example christakis and bird s empiricalstudy showsthatalackofsuggestedfixesisoneofthe toppainpointsreportedbystaticanalysisusers.otherdeveloper studies alsoreportverysimilarfindings.hence what we needis atooltofixresource leaks.
existingrepairtools.
sincetherearecurrentlynospecializedtools for resource leak fixing one could try using general purpose repair tools which workonawidevarietyoferrors.thesetoolsgeneratecandidate patches using a variety of techniques but they all validate a patch by checking if it passes the previously failing test case.
resource leaks however do not show up during tests and hence cannot be fixedbysuchtools.footpatch oneoftheonlygeneral purpose toolsthatdoesnotrelyontests isthecurrentbesttoolforfixing resourceleaks.however itsuffersfrom low qualityfixesfor java resource leaks it suggests fixes for only of the leaks out of which only are correct.
achieving a perfect fixable rate percentage of warnings for whichafixwassuggested and fix correctness percentageofcorrect fixes out of the suggested fixes for java resource leaks is a loftygoal.theproblemisatleastashardascompile timeobject deallocation i.e.replacingjava sruntimegarbagecollectorwithstaticdeallocation aknownhardproblemforcompilers.
furthermore inthisrepairproblem somecornercasesinvolving loopsoraliasingalsoreducetoundecidableproblems.hence there willalwaysbesomeresource leaksthatareinfeasibletofixfora compile time tool.
however we show that by separating the leaks that are infeasible to fix from those that are feasible to fix it is possibletohavebetterrepairabilitythanfootpatchinbothfixable rate andfix correctness.
thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 san francisco ca usa akshay u t ture andjens palsberg resource leak detectorparse warningsresource escape analysisapply repair template of warningswarningsprogram sourcerlfixer fixable rate fix correctnessfixesinfeasible to fix leaksresource alias identification figure overview oftherlfixerworkflow our approach.
in this paper we introduce rlfixer a specialized repairtoolforresourceleaksthatgenerateshigh qualityfixes.fig.
gives anoverview ofitsworkflow.the warningscomputed byan existing black box resource leak detector are first parsed to extract the location where the resource was created.
next the resource alias identification step identifies pairs of resource objects that use the same underlying system resource.
the third step tracks the data flow of theresource object using a new demand driven static analysiscalleda resourceescapeanalysis .thisanalysisservestwo purposes it identifies leaks that are infeasible to fix and it helps pick the correct repair template for the feasible to fix ones.
finally using repairstemplate the last stagegeneratesthe correctfix.
inadditiontogeneratingcorrectfixes wedesigned rlfixerto be fast because it will typically accompany static analysis warnings in ides which are time sensitive environments.
rlfixer s demand drivendesign enablesitto analyzeonlythose statements relevanttotheresourceleak.ittakes onaverage only1seconds perprogram excludingthe13secondsforsettingupthecall graph class hierarchy etc.
weevaluated rlfixerbyapplyingittothewarningsfromfive popular java resource leak detectors infer pmd checkerframework codeguru and spotbugs each of which is run onprograms from the njr dataset .
our contributions.
we begin with an example of rlfixer fixing aresourceleak section andthen we detailour contributions we introduce a newstaticanalysis resource escapeanalysis whichhelpsidentifyleaksthatareinfeasibletofix aswell as pick the repairtemplate for feasible ones section .
we designandimplement rlfixer aspecializedrepair tool for resource leaks that is based on the resource escape analysis and can repair leaks from multiple leak detectors section4 .
weshow experimentally that rlfixergenerateshigh quality fixes withlowoverheadfor five popularjava resource leak detectors.
out of resource leaks detected in njr it generates onaverage fixesfor66 oftheleaks outofwhich anestimated95 arecorrect section .rlfixeroutperforms the footpatch baseline which generates fixes for only of the leaks outofwhichonly are correct.1voidfoo file a throws ioexception filereader fr null try fr newfilereader a bar fr 5intdata fr .
read finally try fr .
close catch exception e e .
printstacktrace 7voidbar filereader f bufferedreader r null 9try r newbufferedreader f system .
out .
println r .
readline catch ioexception e figure example ofaresource leak fixed by rlfixer weendwithadiscussionofrelatedwork section andourconclusion section .
examples thissectionshowstwosimplifiedexamplesofhowthefiveresource leak detectors report leaks and how rlfixergoes about repairing them.
it highlights the need for suggesting fixes for resource leaks as well as someofthe challenges ingeneratingacorrectfix.
fig.2shows asimplified javacode snippet from one of the njr benchmarks.
it has two methods each with one resource object.
first letuslookatthemethod foo.foocreatesa filereader resource line which gets passed in to the barmethod line .
notethat foocontinuesusingthe filereader online5afterthe barfunctionreturns.the foomethodalsodeclaresthatitpotentially throws an ioexception .
this declaration is required by the java compiler s type and effect system when a resource s potential exception is not handled in a try catch block.
the lines highlighted ingreenconstitutethefixsuggestedby rlfixer theyhavenotbeen addedto the code yet.
next let sfocusonthemethod bar.itcreatesa bufferedreader resource object with the filereader parameter fas an argument line10 .here the bufferedreader isawrapperresourcethatprovidesbufferingfunctionalityforthe filereaderf .hencewesay that the resource variables fandrareresource aliases .
this means thateventhoughtheypointtodifferentresourceobjects fpointsto afilereader andrpoints to a bufferedreader the underlying systemresourcepointedtobythoseobjectsisthesame.thisimplies that closing one resource object closes all its resource aliases.
inthiscase neitherthe bufferedreader northefilereader have been closed andhence we getaresourceleak.
wenowrunfiveresource leakdetectors infer pmd checkerframework codeguru and spotbugs on this code and table showsthe outputgivenby each.pmd and infer identify a resource leakfor the bufferedreader whereaschecker frameworkidentifies a resource leak for the filereader .
codeguru and spotbugs 160from leaks to fixes automatedrepairs forresource leakwarnings esec fse december3 san francisco ca usa table1 outputsforthefiveresource leakdetectors when given thecodesnippet fromfig.
tool output infer resource of type bufferedreader at line 10is not releasedafter line pmd ensurethatresourceslikethisbufferedreader objectare closedafter use line checkerframework mustcall method close may not have been invokedon fr orany ofits aliases line codeguru n a resourceleakmissed spotbugs n a resourceleakmissed do not report any resource leak.
even after getting one of these warning messages a developer is still several steps away from a correctfix.
wealsorunthebaselinerepairtool footpatch onthisfile handle leak.footpatchistightlyintegratedwithinfer andreliesoninfer s warning output for identifying fix locations.
footpatch first generatescandidatepatchesbysearchingthecode baseforprogram fragmentsthatcloseafile andthenvalidatesthepatchesbycheckingifinferstopsreportingtheleak.inthiscase footpatchisunable to generate any patch candidates for the warning.
furthermore eveniffootpatchdidhypotheticallyfindapatch itwouldapplythe patchatthelocationin infer s warning after line .
closing the bufferedreader after line or anywhere in function bar will mean that the file pointed to by its resource alias filereader will be closed before it isread on line .
thisfix is dangerous since it introduces anewuse after closeerror.
finally letusexaminehow rlfixerdealswiththeresourceleak assuming the warning came from infer i.e.
for line .rlfixer startsoffbyperforminga resourcealiasidentification forthenew bufferedreader object line .thisanalysisrevealsthat fisa resource alias.
next rlfixerperforms a resource escape analysis a static analysis that computes how the bufferedreader and any of its aliases escapes the method.
the two ways the resource escapes thebarmethod are via the readline method call line and viatheparameter f. whena resource escapesviaa parameter we cannotclosetheresourceinthecurrentmethod sincetheresource is still accessible after the method returns.
instead we examine the callerinstructiononline whichisinthemethod foo.carryingout theresource escape analysis forfrinfooshows that it only escapes via method calls and hence can be closed in the method fooitself.
rlfixerthen picks the correct repair template and it suggests the fixhighlightedingreeninfig.
.therepair codecorrectlyfixesthe leakwithoutintroducingnewerrorsormodifyingthesemantics of the original program.
rlfixercomputes the same fix for the warnings given bypmd andchecker framework.
a resource leak that is infeasible to fix.
fig.3shows an example of aresourceleakthatmaybeinfeasibletofixatcompiletime.
rlfixer during its resource escape analysis tracks the filewriter resource line4 through the call to the method store and identifies that it isassignedthefield fwonline9.sincethisfieldisaccessibleaslong asitsparent u1d434objectisalive wecanonlysafelyclosethisresource whenthe u1d434objectisgettingdeallocated.thismakestheproblemat1classa filewriter fw 3voidcreate file b throws ioexception filewriter f newfilewriter b store f 8voidstore filewriter a fw a resource escapes to a field figure example ofaresource leak that is infeasible to fix least as hard as compile time object deallocation a known hard problem for compilers.
prior research has only managed to statically deallocate some objects in the program and the hardness of this problem is the reason why java uses a runtime garbagecollector.thisisjustoneoftheinfeasiblecasesforresourceleakrepair we discuss the full listof casesinsection .
there will always be resource leaks that are too hard to fix statically.
rlfixeraims to identify and separate out the hard to fix leaks like the one in fig.
while correctly fixing the rest of the resource leaks like the one infig.
.
approach this section gives an overview of rlfixer s approach to fixing resource leaks.
fig.
1shows the four main components of rlfixer the warning parser the resource alias identification the resource escape analysis and the application of repair templates we now discuss eachoftheseindetail.
.
warningparser thefirstcomponentparsestheresource leakdetector swarning and extracts the source file and line number where the leaked resource was created.
each resource leak detector needs a separate parser because each tool uses a different output format but this componentissimpleandsmall.onaverage ittakesonly15lines ofpythoncode per newtool.
.
resourcealiasidentification thesecondstepfor rlfixerisidentifyingresourcealiasesforthe leakedresourceobjects.thisisanimportantstepbecauseamajority ofresourceusageinjavainvolvesresourcealiasing.wehavealready seen anexampleof resource aliasing infig.
where the filereader andbufferedreader objectspointed to thesameos resource.prior research has studied resource aliasing from the point of view of pruning false positive resource leak warnings.
here we studyresource aliasingfromthepointofviewofgeneratingcorrect repairs.
below is the resource aliasing definition that rlfixeruses.
variables u1d465and u1d466.altare resource aliases if u1d465is a wrapper for u1d466.alt or u1d466.altisawrapper for u1d465.
resource u1d44aconstructed with the constructor u1d436 u1d44ais a wrapper for resource u1d445if a u1d445ispassedas aparameterto u1d436 u1d44a and b u1d445isamust alias of afield of u1d44aat the end of u1d436 u1d44a and 161esec fse december3 san francisco ca usa akshay u t ture andjens palsberg 1classwrappertype 2private resourcetype out 3public wrappertype resourcetype w out w 6public close out .
close .
.
resource leak reported here x newresourcetype a .
txt y newwrappertype x figure4 resourcealiasidentification checkingifthewrappertype objectisawrapperfortheresourcetype object c the must alias field always gets closed in the close functionof u1d44a allpointer aliasesare treatedas resource aliases.
this definition also serves as a specification for a static analysis whichrlfixerimplementstoidentifyresourcealiaspairs.letus use the example from fig.
4to check if the variables u1d465and u1d466.altare resource aliases.
the resource leak warning is reported for the resourcetype object on line .
theresourcetype cannot be a wrapper for any other object because its constructor only takes a string input and this will never satisfy condition 2a .
so let us check the conditions for the wrappertype to be a wrapper fortheresourcetype .wefirstperformadef useanalysis of u1d465 which identifies all uses of u1d465.
since u1d465is used as a parameter in the constructor for the wrappertype line14 condition 2a is satisfied.
next for condition 2b we check the wrappertype constructor and its callees for an assignment of its parameter u1d464 or one of its aliases to a field of the wrappertype .
in this case we have such an assignment line for the field u1d45c u1d462 u1d461 the condition is satisfied.
analyzing the closefunction reveals that the resource fromthefield u1d45c u1d462 u1d461getsclosedinit line andthissatisfiescondition 2c .thus allthreeconditionsare satisfied the wrappertype and resourcetype are resource aliases.
the final part of the definition saysthatallpointer aliasesareresource aliases.pointer aliasescan be foundusing atypicaldemand driven pointer analysis .
wenowknowhowtoidentify pairsofresource aliases butwe alsoneedtoconsiderresource objectsthatarelinkedbymultiple layers of resource wrapping.
this is quite common in java programs a resource can be wrapped in up to four or five layers of resource wrappers.
we identify this linking by computing a transitive closure over the resource aliasing relationship.
.
resourceescapeanalysis the third component the resource escape analysis computes all the types of program constructs that the resource can escape to.
this analysis is used by rlfixerfor two purposes it helps separate out the infeasible to fix leaks and it helps compute repairs for the feasible to fix leaks.
theresourceescapeanalysis iscarriedoutonthewalair because it is easier to write a data flow analysis on wala ir thanprogram c c .
.
.
c c cname ext impds fields f .
.
f methods m .
.
m m mname u1d4491 .. u1d449 u1d45b instructions i .
.
i i arraystore fieldwrite assgn phistmt returnstmt invoke fieldread conditionalbranch newstmt arrayload arraystore u1d449 u1d44e u1d45f u1d45f u1d449 u1d45fh u1d460 fieldwrite u1d449 u1d459h u1d460.
f u1d449 u1d45fh u1d460 assgn u1d449 u1d459h u1d460 u1d449 u1d45fh u1d460 phistmt u1d449 u1d459h u1d460 phi u1d4491 .. u1d449 u1d45b returnstmt return v invoke u1d449 u1d459h u1d460 u1d449 u1d45fh u1d460.
mname u1d4491 .. u1d449 u1d45b fieldread u1d449 u1d459h u1d460 u1d449 u1d45fh u1d460.
f conditionalbranch if u1d449 u1d44f u1d45c u1d45c u1d459goto instr index newstmt u1d449 u1d459h u1d460 new cname arrayload u1d449 u1d459h u1d460 u1d449 u1d44e u1d45f u1d45f v var name ext extends cname impds implements data structure interface figure simplified grammarforthe wala ir table the five escape mechanisms foraresource object escape type resource hasthisescape type if it field escape aliaseswithan instancefield orstaticfield data structureescapealiaseswithanelementinanarrayordatastructure.
return escape gets returned by the method it is created in.
parameterescapealiases with a formal parameter of the methoditiscreatedin invoke escape is passed as an argument to an invoke statement i.e.methodcall onjavasourcecode.walaisthestaticanalysisframeworkused byrlfixer andthe walair isvery close to java bytecode.
fig.5givesasimplifiedgrammarofthewalair.mostofthe grammar terms are common to most intermediate representations.
thephistmt is a specialinstruction inall ssa based irs to merge valuesfromasource variablethatappearsontwodifferentcontrolflowpaths.the impdsnon terminalspecifiesiftheclassimplements any of the data structure interfaces such as map collections etc.
.
the list of instructions in the grammar show that there are five programconstructstowhicharesourcecanescapefromitsmethod afield adata structure anarrayoradata structureclass areturn variable aparameter oran invoke i.e.method call .
we define five escape types corresponding to these five constructs field escape data structure escape return escape parameterescape invoke escape .
table2describes what each escape type means.aresourcecanhavemultipleescapetypes.byenumerating through the instruction types in fig.
we can see that the five escape types exhaustively cover all the ways a resource can escape the methoditiscreatedin.
fig.6gives pseudo code for the analysis.
it is designed to be demand driven and its output is the set of possible escape types for the resource.
the analysis procedure whose name is shortened torea takestwoarguments theresourcevariablewhoseescape mechanisms need to be analyzed and the method it is declared in.
162from leaks to fixes automatedrepairs forresource leakwarnings esec fse december3 san francisco ca usa procedure rea u1d45f u1d452 u1d460 u1d45c u1d462 u1d45f u1d450 u1d452 u1d449 u1d44e u1d45f u1d456 u1d44e u1d44f u1d459 u1d452 u1d45a u1d452 u1d461h u1d45c u1d451 u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 fori ingetuses u1d45f u1d452 u1d460 u1d45c u1d462 u1d45f u1d450 u1d452 u1d449 u1d44e u1d45f u1d456 u1d44e u1d44f u1d459 u1d452 do switchi.instructiontype do casearraystore u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 data structure casefieldwrite u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 field caseassgn u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 rea assgn.
u1d449 u1d459h u1d460 u1d45a u1d452 u1d461h u1d45c u1d451 casephistmt u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 rea phistmt.
u1d449 u1d459h u1d460 u1d45a u1d452 u1d461h u1d45c u1d451 casereturnstmt if u1d45a u1d452 u1d461h u1d45c u1d451 originalwarningmethod then u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 return end if for u1d450 u1d44e u1d459 u1d459 u1d452 u1d45fincallers u1d45a u1d452 u1d461h u1d45c u1d451 do u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 rea u1d450 u1d44e u1d459 u1d459 u1d452 u1d45f.
u1d449 u1d459h u1d460 u1d450 u1d44e u1d459 u1d459 u1d452 u1d45f.method end for caseinvoke form ininvoke.targets do ifm.isdatastructuremethod then u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 data structure else u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 invoke u1d45d m.matchingparam u1d45f u1d452 u1d460 u1d45c u1d462 u1d45f u1d450 u1d452 u1d449 u1d44e u1d45f u1d456 u1d44e u1d44f u1d459 u1d452 u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 rea p m end if end for casefieldread donothing caseconditionalbranch do nothing casenewstmt donothing casearrayload donothing end for ifisparameter u1d45f u1d452 u1d460 u1d45c u1d462 u1d45f u1d450 u1d452 u1d449 u1d44e u1d45f u1d456 u1d44e u1d44f u1d459 u1d452 then if u1d45a u1d452 u1d461h u1d45c u1d451 originalwarningmethod then u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 parameter end if for u1d450 u1d44e u1d459 u1d459 u1d452 u1d45fincallers u1d45a u1d452 u1d461h u1d45c u1d451 do u1d45d u1d450 u1d44e u1d459 u1d459 u1d452 u1d45f.matchingargument u1d45f u1d452 u1d460 u1d45c u1d462 u1d45f u1d450 u1d452 u1d449 u1d44e u1d45f u1d456 u1d44e u1d44f u1d459 u1d452 u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 rea p u1d450 u1d44e u1d459 u1d459 u1d452 u1d45f.method end for end if return u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 end procedure figure resource escape analysis name shortened to u1d45f u1d452 u1d44e u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 thesetofescapetypes isinitializedtotheemptysetin thebeginning.thebulkofthemethodisaforloopovertheuses ofthe resourcevariable.
foreachuse rlfixerperformsacaseanalysisbasedonthetype oftheuseinstruction line .thepossibleuseinstructionscome from the grammar in fig.
.
if theuse instructionisan arraystore it follows that the resource object aliases with an array element andaccordingtotable thisimpliesa data structureescape we addthisto u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460.similarly a fieldwrite impliesa fieldescape .
anassgnorphistmtrequiresustorecursivelytracktheassigned variable hence we call reaon it.
being used in a returnstmt in the warning s original method implies that returnshould be in u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460.
additionally since we need to track the returned variable inallcallers we addtheescape types ofthecallers call sites to u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 .iftheuse instructionisan invoke i.e.methodcall we splititintotwosub cases.ifthemethodbelongstoadata structure class weadd data structure to u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460.ifnot weadd invoketo u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 andtracktheescapetypesinthemethodcallbyrecursively calling reaon the matching argument in the invoke targets.
wedonotneedtodoanythingforthelastfourinstructiontypes.
afieldread doesnotpropagateanyescapeinformationfromthe resource variable because only the field is read.
conditionalbranch newstmt andarrayload do not even support the use of a resource variable.
in addition to checking for the uses of the resource variable we also need to check if it escapes to a parameter line .
if so we addparameter to u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460.additionally werecursivelytrackthe escapetypesinthecallermethods bycalling reaontheresource variable smatching argument inthe caller methods line .
finally theanalysisreturns u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 theaggregatesetofescape typesfor u1d45f u1d452 u1d460 u1d45c u1d462 u1d45f u1d450 u1d452 u1d449 u1d44e u1d45f u1d456 u1d44e u1d44f u1d459 u1d452 .sinceresourcealiasespointtothesame underlyingresource anescapetypeforonealiasappliestoallother aliases.hence theresourceescapeanalysismustberepeatedforall resource aliases of u1d45f u1d452 u1d460 u1d45c u1d462 u1d45f u1d450 u1d452 u1d449 u1d44e u1d45f u1d456 u1d44e u1d44f u1d459 u1d452 and their escape types added to u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460.
.
applyingrepair templates thefinalstepfor rlfixerisgeneratingrepaircode.therepaircode has the following specification it should close the leak after the lastuseoftheresource withoutintroducingnewerrors suchas anewleak ause after closeerror oranullpointerexception or modifyingthe semantics of the originalprogram.
rlfixeruses the decision tree from fig.
7to pick the correct repair strategy.
if a resource escapes to a field or data structure rlfixermarksitas infeasible tofix.ifthe resource does not escape toafieldordata structure butdoesescapetoareturnorparameter rlfixercreatesdummyleakwarningsatthecallermethods and closes the leak there.
if it does not have any of these four escape types we can close the resource in the same method as it was created.basedonhowtheresourceisused wethenapplyoneof three repair templates.
since the decision tree covers all the five escapetypes itexhaustivelycoversallthewaysasingleresource can leak.letusnowexamine eachdecision tree node indetail.
field escape.
resourceswitha fieldescape areinfeasibletofix.
closing a resource that escapes to an instance field like in the example from fig.
is at least as hard as compile time object deallocation.
closing a resource that escapes to a static field is not possiblebecuasestaticfieldsarealivethroughouttheprogram slife.
furthermore incaseswherewedon thaveaccesstoallthecodeat compile time such as when designing a library it is impossible to staticallyevenidentifyallusesofafield inthiscase a field escape willnever be safe to close.
163esec fse december3 san francisco ca usa akshay u t ture andjens palsberg resource is defined in a try catch block and all its uses and aliases are contained in the same block resource has a post dominatorif the resource is not defined in a trycatch blockparamter esctypesreturn esctypesdata structure esctypes or field esctypes no no no no noinfeasible to fixyes yescreate dummy warning at the callers returned variables resource either has an invoke escape or no escape.
it can be closed in this method itself.
resource or alias uses are partly inside a try catch block and partly outside yes noinfeasible to fixcreate dummy warning at the callers argumentyes apply the throws template apply the contained try catch template apply the escaped try catch template yes yes figure7 decision treedepictinghowrlfixerdecideswhich leaksareinfeasibletofix andpicksthecorrectrepairtemplate to apply.
data structure escape.
fixingdata structure escapes ishardbecauseitiswell knownthatunbounded datastructures suchasarrays are hard to accurately model using static analysis .
hence staticanalysistoolsmodeldatastructuresusing over approximation .
inthecaseofanarray theover approximationistoassumethat areadorwriteto the arraycould affectany possible index.
such anover approximationissafeforresource leakdetectionbecause it will never miss out on a leak that occurs in a possible execution.
however itisunsafeforourrepairproblembecauseclosingaresourcefromanarrayrequiresus toknowtheexactindexthatthe resource is at.
a similar argument applies to other data structures.
hence rlfixerdoes not generateany repairsfor this case.
return escape.
at the u1d445 u1d452 u1d461 u1d462 u1d45f u1d45b u1d452 u1d460 u1d450 u1d447 u1d466.alt u1d45d u1d452 u1d460 node of the decision tree wealreadyknowthattheresourcedoesnotescapetoafieldor data structure.iftheresourcedoes escape viaa return wecreate one dummy warningfor each caller at the returnedvariable.for example in the snippet resource r getres a resource objectgets returnedbythe getresmethod and henceisstill alive after the getresmethod returns.
consequently we cannot close the resource inside the getresmethod.
instead we create dummy leak warning at the returned variable rin this case .
we then recursivelyapply rlfixertothedummywarning s andsuggest theirrepairsas afixfor the originalwarning.parameter escape.
theparameter escape case is similar to the returnescape case wherewecreateadummywarningatthecaller methods.theonlydifferenceisthatthedummywarningiscreated at the corresponding argument of the paramter in the caller.
we alreadysawthisstrategybeingappliedtotheexampleinfig.
.the resourceleakwasreportedatthenewbufferedreaderinthe bar method of fig.
line10 .
the buffered reader resource escapes to theparameterviaitsresourcealias filereaderf .hence wecreate adummywarningfortheargument fratthemethodcallto barin thecallermethod foo line4 .wethenrecursivelyapply rlfixer on the dummy warning s and suggest their repairs as a fix for the originalwarning.
invoke escapeand non escape.
at thedecision treenode where wehaveneithera data structure field returnorparameter escape we are left with resource leaks that eitherhave an invoke escape or noescapetypes.inthesetwocases theresourceisnotusedafter themethodcompletes andhenceshouldclosedinthesamemethod.
basedonwhethertheresourceisdefinedinsideatry catchblock ornot wedefinethreerepairtemplates the throwstemplate the containedtry catchtemplate andtheescapedtry catchtemplate .
fig.8illustrates these templates.
the lines highlighted in green give the fixsuggestedby rlfixer.
thethrowstemplate seefig.8a applieswhentheresourceis not created or used within a try block.
the repaired code places allthe resource andalias useswithina try finally block.the try block starts at the first line where the resource is used.
the finally block starts afterthe last line where the resource is used but with adjustmentstomatchthescopeofthenewlyaddedtry block.note that the new close statement is placed within its own try catch block to handle any exception related to resource access nullpointers etc.
itmaythrow therebyavoidingmodifyingthecontrol flow of the original program.
modifying the control flow of the originalprogrammodifiesitssemantics andthisgoesagainstour repairspecification.wewillseethesamepatternwiththenexttwo templates.
thecontained try catch template see fig.8b is applied when the resource creation and all its uses and resource aliases are contained within a tryblock.
in this case the correct repair is to attachacorresponding finallyblockthatclosestheresource.ifa finallyblockisalreadypresent rlfixeraddstheclosestatementto theexistingfinallyblock.the finallyblockinjavaalwaysexecutes afterthetry catch block evenifthe tryblockhasareturnstatement oranexception.hence withthisfix theresourceisclosedonall program paths includingones involving an exception.
theescaped try catch template see fig.8c applies when resourcecreationandusestatements andresourcealiases arepartly insideatryblockandpartlyoutside.forexample theuseonline isinside whereastheoneonline 8isoutside.here rlfixerfirst placesallstatementsthatareoutsidea tryblock e.g.line inanew try catch block this prevents control from escaping the method barbefore the resource can be closed.
note that rlfixerre throws the exception in the fix code to preserve control flow to any exception handler in the caller method of bar.
finally the resource needstobeclosedatitsearliest post dominator .apost dominator foraresourceisaninstructioninthemethodthatappearsonevery control flow path from a resource use to the end of the method.
in 164from leaks to fixes automatedrepairs forresource leakwarnings esec fse december3 san francisco ca usa 1voidfoo throws exception resource r null try r newresource .
.
r .
useresource finally try r .
close catch exception e e .
printstacktrace a throws template1 resource r null 2try r newresource .
.
r .
useresource catch ioexception e e .
printstacktrace finally try r .
close catch exception e e .
printstacktrace no resource use after this b containedtry catch template1voidbar throws exception resource r null 3try r newresource .
.
r .
useresource catch exception e some code in between try r .
useresource catch exception e try r .
close catch exception f throwe some code in between no resource use after this try r .
close catch exception e e .
printstacktrace c escapedtry catch template figure rlfixer s repair templates fig.8c assuming the earliest post dominator for the resource is online10 rlfixerclosestheresourceatthispoint.iftheearliest post dominatorisinsideatry catchblock theclosestatementgoes insideafinallyblock.choosingtheearliestpost dominatorforclosing theresource is always safe but incorner cases with a method havingmultipleexitpoints aresourcemayhavenopost dominator rlfixerdoes not suggestany fixinthis corner case.
we avoid java s try with resources statement because it only appliestoresourcesthatimplementthe autocloseable interface.
additionally itsupressesexceptionsinthetry withstatementin some cases thereby modifying the control flow.
futhermore it cannot handle the resource usage pattern from the escaped trycatch template.
.
loopsandexistingclosestatements there are two more details we need to handle in the repair code loopsandexisting close statements.
dealing with loops.
we can divide the resource leaks in loops into two sub cases.
the first more common sub case occurs when the resource is created during a loop iteration and is never used aftertheendofthatiteration.
rlfixerdealswiththissub caseby extractingthe loop bodyand computingthe fixon thisloop body asitwouldforanyloop freeresourceleak.fortheveryraresubcase where a resource created in a loop stays alive beyond the end of a loop iteration rlfixerdoes not suggest a fix this sub case gives an undecidable problem.
deletingexistingclosestatements.
inadditiontoaddingrepair code rlfixeralso needs to remove unnecessary closestatements added by the programmer to avoid a double close.
we design each ofourrepair templatestorequireasingleclosestatement hence 1fixing the leak in this rare sub case requires us to identify the last loop iteration to closethe leak whichis a known hard problem for compilers.rlfixerdeletesanyexistingclosestatementsthatwereaddedby the programmer.
for example in fig.
8b if the programmer had inserted a close statement inside the tryblock after line rlfixer would need to delete it in addition to generating new repair code .
implementation thissectiondiscussestheimplementationdetailsfor rlfixer.rlfixeris primarily implemented in the wala static analysis frameworkforjavabytecode .wewrote rlfixer s analysesonwala s ir instead of java s source ast because the ir has simpler control flow fewerinstructiontypes andisalreadyinssaform.furthermore wala automatically sets up the core information needed by any static analysis such as computing the class hierarchy callgraph using the cfa algorithm and basic blocks.
the repairtemplate stage of rlfixeradditionallyuses javaparser to scan the java sourceasts for scopingandlinenumber information.
theresource escapeanalysis call graph andresource aliasanalysisalluseacontext insensitiveanalysis.context sensitivityisnot needed because we know of no way to represent context in repair code.
our analyses automatically get partial flow sensitivity because of the wala ir s ssa form.
field sensitivity is redundant becauseallresourcesaliasingfieldsbecome fieldescapes anddonot getfixed.reflectionsupportcantriviallybeaddedbyturningon wala sreflectionanalysis butweskipthisoption itonlybenefits a tiny fraction of repairs while increasing call graph computation timebymanyfold.inourexperiments outofthe150resource leaks that were manually examined none were affectedbyreflection.
theoutputformatofthetoolismuchlikethatinfig.
andcan easilybeincorporatedintoanideorexistingstaticanalysistool.
note that rlfixerdoes not automatically adjust variable scopes in its generatedfix itisupto the programmer to correctthis.
165esec fse december3 san francisco ca usa akshay u t ture andjens palsberg resource leak warnings reported050010001500 infer pmd cf codeguru spotbugs figure9 warningsreportedbythefiveresource leakanalyzers whenapplied to thenjrdataset.
dataset weusethenjr 1dataset availablehere asourbenchmark set.
itconsistsofadiversesetof293java 8programsfromgithub and hasbeenusedinseveralrecentstaticanalysispaperssuchas .itiswell suitedtoevaluate rlfixerbecauseithasseveral resourceleaks andrunsoff the shelfwithseveralexistingresourceleak detectors and java analysis tools like wala and javaparser.
weleaveout6ofthe293njr 1benchmarks footpatchrunsout ofmemoryforthreebenchmarks andthreearemissingalibrary class.
this leaves uswith287benchmarks for our experiments.
we run five popular java resource leak detectorsonthis dataset infer pmd checker framework shortened to cf codeguru andspotbugs .thewarningsgivenbythesetools arethenfedto rlfixer.weranallthetoolswiththeirdefaultoptions and after post processing the warnings to filter out duplicate warnings etc.
wegotatotalof2205uniqueresource leaks.during theduplicatefiltering iftherearetwowarningsforaresource alias pair i.e.samerootcause onegetsremoved.fig.
9liststhenumber of warnings given by each tool after duplicate filtering.
cf gets the most resource leaks probably because of its commitment to soundness i.e.
catching as many possible leaks .
spotbugs gets the fewestresource leaks probablybecause soundness wastraded off for speed.
similarly the other tools differ in their set of reported leaksbecause ofdifferentdesigndecisions.
table3reportssomestatisticsaboutthefrequencyofresource leaks in the njr dataset.
out of programs have at least one leak.bytakingaunionoftheresourceleaksbythefivetools we get an estimated total of unique resource leak warnings.
this averagesto8resourceleaksperprogram.giventhattheaverage number of lines of application code in the njr dataset is almost 10k we can expect one resource leak in every lines of code.
thus resource leaks are prevalent in the dataset developers need bettertool support for fixing theseleaks.
experimentalresults in this section wediscuss our experimental results which answer the following fourresearchquestions rq1 howmanywarnings can rlfixersuggestfixes for?
rq2 howmanyofrlfixer s suggestedfixes are correct?
rq3 howdoes rlfixercompare to footpatch?table statistics about the frequency of resource leaks in thenjrdataset tool output total number ofprograms programs withat leastone resourceleak estimatednumberofuniqueresourceleaks across the five tools linesofapplicationcode per benchmark rq4 howlongdoes rlfixertake to generaterepairs?
thefourquestionsareansweredbythefollowingfourclaims whichareinturnvalidatedinthenextfoursubsections allnumbers are averagesacrossthe five resourceleakdetectors .
rlfixersuggestsfixesfor66 oftheresource leakwarnings.
ofthe fixes suggestedbyrlfixerare correct.
rlfixerproduces higher quality fixes thanfootpatch.
rlfixertakes onaverage 1secondsperprogram excluding the secondwalasetuptime.
the experiments were carried out on a machine with intel r xeon r silver4116cpucoresat2.10ghzand188gbram.for the jvm the default heap size of 32gb and default stack size of 1mb wasused.
.
rq1 fixable rate fixable rate is the percentage of warnings for which a fix was suggested.itisdefinedas fixable rate warnings for whichafixwassuggested total warnings fig.10givesasplitupofthefixableandunfixableresource leaks forrlfixeron each of the five tools.
on average rlfixergets a fixablerate withpmdgettingthehighestfixable rate .
the unfixable resource leaks are further split based on the reason they are not fixed from the graph we see that the main reason for unfixed leaks are field escapes .
cf gets a lower fixablerate than theothertools because ofa large percentage ofits leaks beingfieldescapes .asmallercontributortounfixedleaksare datastructure escapes .
some of resource leaks escape to both a data structureandafield.wereporttheseasdata structureescapes tosimplifythegraph.thelast5 ofleaksarenotfixed inredcolor because asdiscussedinsection .
therearecornercasesforsome templates that result inundecidable problems.
.
rq2 fix correctness another important metric is fix correctness the percentage of correctfixes outofthe suggestedfixes.
itisdefinedas fixcorrectness warnings withacorrectfixsuggestion warnings withafixsuggestion we picked asampleof150fixes perresource leakdetector suggested by rlfixerto estimate the fix correctness.
we re ran the resource leak detector on the fixed code to ensure that the old leaks disappeared.
for fixes the old leaks remained and 166from leaks to fixes automatedrepairs forresource leakwarnings esec fse december3 san francisco ca usa percentage of resource leaks infer pmd cf codeguru spotbugs average fixable rate unfixed because of data structure escape unfixed because of field escape unfixed for other reasons figure fixable rate for rlfixer for each resource leak detector along with reasons fortheunfixed leaks.
these were marked as incorrect.
for the remaining fixes we had volunteer programmersclassify thefixes ascorrect or incorrect.
thevolunteers noneofwhomareauthors arecomputer science graduate students who are familiar with java and resource leaks.
the volunteers classify different subsets of the fixes but each fix is classifiedbyatleast3volunteers.eachvolunteerusesthefollowing criteria to evaluate correctness and a fix is considered incorrect even if one ofthesecriteriaisnot met.
the fixrepairsthe leak.
the fixdoes not introduce anull pointer error.
the fix does not introduce a use after close error e.g.
file written after being closed .
the fixdoes not introduce adoubleclose.
the fixdoes not modify the behaviorofthe program.
finally wecomputedthefix correctnessbytakinganaverage over the scores of the volunteers.
the inter rater agreement calculatedusingkrippendorff salpha is0.
.thescoresforeachtool areshowninfig.
.onaverage rlfixer s fix correctnessis95 with infer and codeguru getting near perfect fixes.
given that less than one in twenty fixes by rlfixerare incorrect we can put high confidence inits generatedrepairs.
examining the small fraction of incorrect fixes shows that there aretwomajorroadblocksto rlfixerreachingperfectfix correctness.
the first is that the definition for resource alias analysis works well inmostcases butitdoesnotexhaustivelycaptureallthewaysthat twojavaobjectscansharearesource.missedresource aliasesin turn giveincorrect fixes.designingaperfect resource aliasanalysisishard.thesecondroadblockisthat rlfixer s templatesare designedtofixindividualresource leaks andhencedonotwork perfectly when multiple resource leaks occur in the same code block.
another correctness issue that most repair tools need to deal withisfalse positivewarnings andwhetheronesuggestsrepairs forthesefalsewarnings this however doesnotseemtobeanissue in practice for rlfixer.
to get a measure of false positive warnings we asked the volunteers to also examine the same repairs and decide whether the original leak detector warning was a false positive.
all five resource leak detectors gave zero false positive percentage of correct fixes infer pmdcf codeguru spotbugsaveragefigure percentage of correct fixes by rlfixer i.e.
fixcorrectness forthefive resource leak detectors warningsfortheleaksfixedby rlfixer.thislowfalse positiverate is expected since these are all mature tools that have been heavily engineered to weed out false positive warnings.
note that there could still be false positive warnings among the infeasible to fix leaks but this doesn taffect rlfixer.
.
rq3 comparisonwith footpatch table4summarizesthecomparisonbetweenfootpatchand rlfixer.
weonlyusetheinferwarningsforthecomparisonbecausefootpatch is tightly integrated with infer it cannot be used with other resource leakdetectors.wesplittheresultsintotwoparts thefirst part columns and shows the results on the warnings from the njrbenchmarks and thesecond part columns 4and gives the results onthe apktoolbenchmarkfrom the footpatch paper .
forthenjrbenchmarks infergenerates730warnings forwhich footpatchgenerates46fixes givingusa6 fixable rate.thefixablerateforrlfixer onnjristhesameastheinferentryinfig.
.
for the njr fix correctness we chose a random sample of fixes for each tool and evaluated for correctness using the criteria from section6.
.
out of the sample of footpatch fixes were correct givinga27 fix correctness.
rlfixer s fix correctness isthe sameastheentryforinferinfig.
.thus onthenjrbenchmarks rlfixer performs significantly better on both fixable rate and fixcorrectness.
forapktool the only benchmark from the footpatch paper with java resource leaks infer gives warnings.
out of these are duplicates and we remove them.
for the remaining warnings footpatchattemptsafixfor1warning fixable rate8 and rlfixerattemptsafixfor12warnings fixable rateof92 .both toolsproduceonlycorrectfixesforthisbenchmark fix correctness .
thelargegapinfix qualitybetweenfootpatchand rlfixeris expected footpatchisamoregeneralpurposetoolthatworkswith multiple kinds of errors as well as on both c and java.
rlfixer on the other hand is specialized for resource leaks in java and hence isableto vastlyoutperform footpatch onthis task.
167esec fse december3 san francisco ca usa akshay u t ture andjens palsberg table comparing the repair quality of rlfixer and the footpatchbaselinewhenfixingtheinferwarnings.weshow theresults separately forthenjrbenchmarks and apktool.
njrbenchmarks apktool tool fixable ratefix correctnessfixable ratefix correctness footpatch rlfixer table5 splitupofthetimetakenperprogrambyrlfixer andtheresource leak detectors tool leakdetector overallfixtime time s walasetup time s rlfixer time s infer pmd spotbugs cf average .
rq4 repair time table5showsthetimetakenperprogramby rlfixerandfourof theresource leakdetectors.wedonotreportthetimeforcodeguru becauseitisonlyaccessibleviaawebservice.onaverage resourceleak detection takes seconds per program but this varies widely acrossthefourdetectors.pmdandspotbugsareveryfast whereas inferandcftakemuchlonger.theoverallrepairtimeis14seconds perprogram.amajorityofthistime 13seconds istakenbythe wala setup whereas rlfixer as described in section takes just second per program because of its demand driven design.
its fix time per leak is even lesser.
the wala setup includes tasks like constructingtheclass hierarchy call graph basic blocks etc.
but amajority ofthe time istaken for call graphconstruction.
call graph construction is unavoidable for any inter procedural analysis but we could eliminate this component by integrating rlfixerwithawalabasedresource leakdetector.since rlfixer is implemented in the wala framework such a design allows rlfixertoreusethewalasetupinformationfromtheresourceleakdetectorphase.thiscouldbringthetotalfixtimedowntojust 1second.
a direct comparison of repair times with footpatch is not meaningfulbecause footpatch suggestsvery fewfixes anditishardto factor out the time taken by unsuccessful fix attempts and fixes for other kinds of bugs.
however results from the footpatch paper show that it takes several minutes per java program which is at least an order of magnitude larger than rlfixer.
there are two reasonswhy rlfixerisfaster itisdemand driven andunlikeother footpatch itdoesnotneedtoperformasearchoverpossiblerepair codes itconstructsfixes from repairtemplates.
.
threatsto validity thefirstthreattovalidityisthatthehumanvolunteerswhoparticipated in the experiment presented in section .2could makemistakes in their evaluation of the fixes.
we mitigate this threat by averaging scores over multiple volunteers and and a large number of leaks in total from different tools.
furthermore we also re rantheresource leakdetectorsonthefixedcodetoconfirmthat the resource leakwarning disappeared.
thesecondthreatisthatourevaluationwascarriedoutonjava8 programs from the njr dataset.
the assumption is that our results willgeneralize to otherjava benchmarks.
the third threat is the applicability of rlfixer s approach to other langauges and platforms since rlfixer s design and our experiments only focusonjava code.
related work theresearchdirectionclosesttothisworkisautomatedprogram repair andonecansplitthiscategoryintogeneral purpose specialpurpose andlinter basedrepairtools.moredistantlyrelatedare escapeanalysisandrepairingandroidresourceleaks.wediscuss eachoftheseinturn.
general purposerepairtools.
general purposerepairtoolsaim to fix a wide variety of program errors.
most of these tools are test basedtechniques andcanbesplitintothreeparadigms.the first paradigm generate and validate generates candidate patches by searching through existing patches and code.
the second is the deep learning based paradigm thatusesdeep learningtofindpatches oftenbyapplying neuralmachinetranslationmodelsfromnlp.thethirdsemanticsbased paradigm generates patches by casting the repairproblem asa constraint satisfactionproblem.
ultimately all three paradigms validate each patch by checking if it passes the previously failing test case.these paradigmscannotbe appliedto resource leaksbecause resource leaksdo not cause test failures.
footpatch is the only general purpose tool which can be appliedtoresource leaksbecauseitreliesontheinferstaticanalysis tool instead of tests to verify the fix.
it generates patches by searching thesame code base for program fragments that address thegiven bugclass.
itis semi specialized toheap errors including null pointer errors resource leaks etc.
however footpatch has three shortcomings compared to rlfixer.
firstly rlfixerhas an order of magnitude better fixable rate and fix correctness see section6.
.
footpatch pays for its generality with a lower fix quality.
secondly rlfixer s repairtemplates bydesign donot modify the semanticsoftheprogramorintroduceanynewerrors.ontheother hand footpatch s notion of correctness is limited to re running infertoensuretheleakdisappreas.thisdoesnotensurethatthe semantics of the program are unmodified and no new errors are introduced.
thirdly rlfixeris also much faster it takes seconds instead ofminutesorhours.
special purpose repair tools.
special purpose repair tools as opposed to general purpose tools focus on repairing a single kind of error this enables them to produce much higher quality fixes.
most of these tools report fixable rates of and a high fixcorrectness which is very similar to what we see with rlfixer and this is usuallysignificantly higher than what general purpose tools can achieve.
the kind of errors tackled by special purpose toolsincludenull pointererrors integeroverflows 168from leaks to fixes automatedrepairs forresource leakwarnings esec fse december3 san francisco ca usa bufferoverflows concurrencyerrors performance bugs andmemory leaks .
among theexisting special purpose repairtools memory leak fixing is the closest to rlfixerbecause it has a similarspecification repairthe leakwithoutmodifying the program s semantics.however thesetoolsfocusoncprograms andmemoryleaks present differentchallenges than resource leaks.
forexample features such as java s exception mechanism its reliance on try catchblocksforresourcehandling resourcealiasing andthe presenceofclassfieldsaresomechallengesinjavaresource leak fixing that donot appear when dealingwithmemory leaksinc.
unlike all these specialized repair tools rlfixerfocuses on resource leaks a problem that has not been tackled by any specialized tool before.additionally rlfixer s demand drivendesign makes it significantly faster than most special purpose tools.
most othertoolsusetime budgetsofafewminutesormoreperprogram whereasrlfixerfinishesin1second plusthe13secondsittakes for walato setupthe call graph etc.
linter basedrepairtools.
lintersscancodeforstyleorcodingconventionviolationsusingpatternmatchingontheast abstract syntax tree .
linter based repair tools use a similarastpattern matchingapproachtoapplyrepairsforalinter s warnings.thesetoolsvaryinthecoding conventionstheytarget andintheirmethodoflearningrepairpatterns.phoenix mines patches from a corpus of github programs and uses it to learn generalizedrepairstrategiesthatarerepresentedasexecutableprograms in a domain specific language dsl .
styler similarly learnsfixpatternsforcode formattingviolationsfromacorpus but it learns using an lstm neural network.
getafix applies a hierarchical clustering algorithm to effectively summarize fix patterns andthenusesanovelrankingtechniquebasedonpasthumanfixes topickthemostplausiblefix.tfix formulatesthelinter repair problemasatext to textpredictiontaskandthenusesapre trained text to text transformer model to generate fixes.
spongebugs and sorald create manually definedfix templates for a handful oflinter violations.
the errors targetted by linter based repair tools are often localandcanberepresentedusingastpatterns.hence unlike rlfixer their techniques will not work for a more complex bug such asresource leakswhichrequiresdata flowtrackingandaninterproceduralanalysis.
escape analysis.
escape analysis isaresearch direction that sounds similar to our resource escape analysis from section .
but ithas verydifferent designs and goals.
escape analysis characterizeshowobjectsallocatedinoneregionoftheprogramescapeto codeoutsidethisregion.itcareslessaboutthekindofprogramconstruct suchasanarrayorfield itescapesto.ontheotherhand our resource escape analysis computes the kinds of program constructs suchasafieldorparameter thataresourcealiaseswith andhasno conceptofregions.hence thetwoanalysesenduphavingdifferent abstract domains constraints anddesigndecisions.
repairing android resource leaks.
android resource leaks are leaksinvolvingevent drivencontrolflowfromandroidevents and aredifferentfromthejavaresourceleaksdiscussedinthispaper whichinvolvesequentialcontrolflow.letustakeacloserlookathowthesetwokindsofleaksdiffertounderstandwhytheyneed different kinds of repair tools.
an android application is an eventdriven system with event handlers responding to a sequence of events such as user interaction or the application life cycle events.
for example android defines the event handlers onpause and ondestroy for when the user pauses and closes an application respectively.
androidresourceleak detectors modelthese eventsequencesandfindonesthatcanleaksomeandroidresource.
forexample ifaresourceisnotclosedinthe onpauseorondestroy eventhandlers wemaygetan androidresourceleak .liuet.al prepareadatabaseofsuch androidresourceleaks .androidresource leakrepairtoolssuchas thensuggestthecorrecteventhandler to close the resource in.
hence all these leak detection and repair tools for android resource leaks focus exclusively on android s event driven control flow.
on the other hand tools such asrlfixerandfootpatch focusonjavaresourceleaksresulting from thecontrol flowinsequentialjavacode.thus they solve a completely different problem than android resource leak repair tools.
conclusion resource leaks are an important bug type that need better toolsupportforautomatedfixsuggestions.inthispaper weintroduced rlfixer thefirstspecializedrepairtoolforresourceleaks.wehighlighted several challenges for the resource leak problem including identifyingresource leaksthatareinfeasibletosolve identifying resourcealiases andconstructingfixesthatdonotmodifythesemanticsoftheexistingprogram.wethendiscussedhow rlfixer tackles these challenges using a new demand driven static analysis calledresourceescapeanalysis .finally weexperimentallyshowed thatrlfixerrepairsamajorityofresource leaksinourbenchmarks withnear perfectcorrectness andvery lowrepairtime.
therearetwointerestingfuturedirectionsthatweforsee.the firstistoinvestigateifthereareanyspecialcasesoffieldordatastructure escapes that are feasible to fix.
the second is applying rlfixer s templates and resource alias analysis to other object oriented languages like python or c which have a similar trycatch finallyexception handling style.
data availabilityand experiment replication the dataset used for this paper njr is publicly available at thefollowinglink .the anonymizedartifactforthepaper includingthesourcecode experimentalresults anddetaileddocumentation arepubliclyavailableat thefollowingrepository .
theartifactalsoincludesavmimagethatcomeswithpre installed dependencies and can be used toquickly reproduce the resultsof the paper byrunning afewsimplescripts.