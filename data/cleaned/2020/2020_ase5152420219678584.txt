ase a value set decision procedure for symbolic execution alireza s. abyaneh department of computer sciences university of salzburg salzburg austria alireza.abyaneh cs.uni salzburg.atchristoph m. kirsch department of computer sciences university of salzburg salzburg austria and czech technical university prague czech republic christoph.kirsch cs.uni salzburg.at abstract a symbolic execution engine regularly queries a satisfiability modulo theory smt solver to determine reachability of code during execution.
unfortunately the smt solver isoften the bottleneck of symbolic execution.
inspired by abstractinterpretation we propose an abstract symbolic execution ase engine which aims at querying the smt solver less often bytrying to compute reachability faster through an increasinglyweaker abstraction.
for this purpose we have designed andimplemented a value set decision procedure based on stridedvalue interval svi sets for efficiently determining precise orunder approximating value sets for variables.
our ase enginebegins reasoning with respect to the svi abstraction and thenonly if needed uses the theory of bit vectors implemented insmt solvers.
our ase engine efficiently detects when the formerabstraction becomes incomplete to move on and try the nextabstraction.
we have designed and implemented a prototype of our engine for a subset of bit risc v .
our experimental evaluationshows that our prototype often improves symbolic executiontime by significantly reducing the number of smt queries while whenever the abstraction does not work the overhead for tryingstill remains low.
index t erms symbolic execution value set decision procedure strided value interval set abstraction i. i ntroduction symbolic execution computes inputs to a given program that make the program run into an error state such as division by zero within a given number of steps during con crete execution.
for this purpose a symbolic execution engineconstructs during program execution a satisfiability modulotheory smt formula for a given program path to a control flow location called path condition that is satisfiable in thetheory of program expressions if and only if the location isreachable on that path.
a variable assignment that satisfies thesmt formula corresponds to an input that makes the programrun into the location on that path.
conversely an unsatisfiablesmt formula indicates that the location is unreachable forall inputs that take the program onto that path.
the engineregularly queries an smt solver to determine reachabilityof the execution branches appearing in the program.
despiterecent advances constraint solving is a scalability bottleneckin symbolic execution of code .
employing a lightweightreasoning procedure to make decisions about the reachabilityof each of the execution branches enables the symbolic exe cution engine to scale and to penetrate deeper into the code.while symbolically executing code the generated constraints are typically modeled in the theory of bit vectors tobe passed to an smt solver.
a constraint solver for the theoryof bit vectors with a solving algorithm which is designed tooperate on an arbitrarily general set of constraints including awide range and combination of operations may be inefficientfor a set of constraints which use a small number of operationsand have specific features .
in this paper we propose anabstract symbolic execution ase engine exploiting an inte ger decision procedure for constraint solving which performsa theory integration in a layered manner by considering twoabstractions strided value interval svi set abstraction and bit vectors .
the respective decision proceduresfor each abstraction in this design strategy are organized ina layered order of increasing capability and complexity.
allthe decisions are made without querying the smt solver forthe set of constraints which can be solved using the svidecision procedure in the first layer.
otherwise the theoryof bit vectors implemented in smt solvers is responsible foranswering reachability queries.
the decision procedure in the first layer employs a lightweight value set analysis technique designed for symbolicexecution which uses the svi abstraction to propagate valuesand speedup the process of reachability decision making.
thesvi abstraction uses a set of strided value intervals to specifyvalues of program variables precisely.
an svi in this setis represented by a wrapped strided interval whichmaintains an incrementing step of possible values in additionto the value bounds and allows wrapping in case of overflow.keeping the incrementing step enables us to reason aboutmultiplication which introduces steps in possible values.
byemploying the svi abstraction the decision procedure analyzesthe constraints at a higher level than bits e.g.
words anddouble words in contrast to bit precise reasoning used intypical smt solvers which may be inefficient because of costlybit blasting in their backend .
the strided intervals and value set analysis technique are typically used in the context of static analysis to over approximate the values of variables in the program .however in the context of symbolic execution the precisionof the decisions over reachability matters.
therefore the sviabstraction in ase is used to represent values that variables 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee can certainly take no false positive .
such a value set enables us to make reachability or unreachability decisions precisely.the ase engine is aware of when the svi decision procedureis able to provide precise decisions over the set of under lying constraints and when this cannot be achieved becauseof a high imposing complexity or incapability the baselineabstraction is upgraded to bit vectors.
when the representation of precise values for variables is not possible using the svi abstraction we propose a techniquein the svi abstraction layer that under approximates the set ofpossible values for involving variables in an operation whenapplicable.
the technique employs an incomplete lightweightextension of the propagation technique used for our precisesvi decision procedure to make satisfiability decisions andreduce the number of queries sent to the smt solver andspeed up the symbolic execution time.
the following contributions are made by this paper we propose an ase engine which employs a theory integrationin the constraint solving component of the symbolic executionprocess and benefits from a novel value set analysis techniqueto propagate values at a higher level than bits.
we proposea value set decision procedure based on the svi abstraction define the theory behind it and provide conditions under whichthe analysis provides precise values for program variables.
assuch the decision procedure detects when such an abstractionleads to exact satisfiability and unsatisfiability decisions forsymbolic execution section iv .
in order to benefit fromthe efficiency of our precise svi decision procedure we intro duce an extension technique which enables the ase engine tomake satisfiability decisions using an under approximation ofthe set of possible values for variables section v .
our experimental evaluation on a set of benchmarks shows on average .
and .
reduction in symbolic execu tion time compared to the state of the art approach andthe approach which always queries an smt solver respec tively.
ii.
o verview the principled idea of abstract symbolic execution is to integrate symbolic execution with decision procedures thatleverage domain specific reasoning to speedup constraintsolving by employing increasingly weaker abstractions.
thedecision procedure we propose here is able to reason aboutthe set of constraints generated out of a program with respectto an abstract domain definition .
a constraint satisfaction problem on finite domains csp is defined by a triplet angbracketleftx d c angbracketrightwherex x ... x n is a set of variables d d1 ... d n is the set of variables domains x i di andc c1 ... c m is a set of constraints over variables.
a valuation is definedasv v ... v n wherevi di.
a solution to the csp is defined as a valuation swhich satisfies the set of constraints c. the set of all solutions is denoted as s. given a specific abstract domain to represent the possible values of variables the set of all solutions sfor a set of constraints ccan be represented precisely or approximated.definition .
given an abstract domain aand a corresponding set of solutions sa this set is precise if sa s and is an under approximation if sa s. in case of an underapproximation we write safors.
in this paper we present a decision procedure employing a propagation technique which considers an svi set as itsunderlying abstract domain to find the precise or the under approximating set of all solutions to a csp.
to do so weemploy a refinement model wherein initially variables cantake any value in their domain.
while symbolically executingcode constraints are generated and gradually variables valuesare refined so that they satisfy the currently seen set ofconstraints.
when the svi decision procedure cannot providea decision the abstraction is upgraded to bit vectors and thedecision procedure implemented in an smt solver is used tomake a decision.
section iv presents the precise svi decision procedure and discusses the conditions under which the analysis provides theexact set of all solutions.
in section v we propose a techniquewhich continues propagating an under approximation of theset of solutions when representation of the precise solutionsis not possible.
keeping the under approximating solutionss afor the currently seen constraints enables us to check the satisfiability and not unsatisfiability of subsequent constraintsappearing in the program while still using the efficient propa gation technique of the decision procedure of section iv.
theproposed symbolic execution algorithm and its implementationdetails are explained in section vi.
iii.
r elated work in this paper we employ an abstract domain in the process of symbolic reasoning about the set of generated constraintsout of a program.
abstracting values using interval domain is awell studied and efficient technique in the context of abstractinterpretation and program analysis.
the concept of stridedintervals was introduced by reps et al.
representing fixed precision value intervals with incrementing steps.
however astrided interval in their definition does not permit wrapping .
the application of the interval abstract domain becomesharder when it comes to the analysis of machine arithmeticwith wrap around semantics in case of overflow.
integerwrapped intervals extends the classical intervals byconsidering wrap around semantics.
gange et al.
providea sound analysis for wrapped interval abstract domain.
theyuse intervals to over approximate the set of all possible valueswhich one variable can take.
in our svi decision procedurewe use their soundness conditions however we extend theabstraction to wrapped strided intervals propose completenessconditions for operations and define the detailed semantics ofreachability decision making when the comparison operationis involved.
in particular we define the inverse semantics of op erations while propagation intervals backward section iv b .
sen et al.
employ the wrapped interval abstraction with steps where they propose a new abstract domain calledcircular linear progressions clps to combine the efficiencyof interval abstract domain with the discreteness of linear 204congruence domain.
in our svi decision procedure we use their defined semantics however we extend those by definingsoundness and completeness conditions for each operationsince in the context of symbolic execution the precision ofdecisions matters.
moreover we discuss the inverse semanticsof operations while propagating constraints backward sec tion iv b and investigate the semantics of the remainderoperation during the forward propagation section iv a .
the strided interval abstraction has been used in several research works .
balakrishnan et al.
propose valueset analysis vsa which uses a combined numeric and pointeranalysis algorithm to over approximate the set of values.
later to increase the precision shoshitaishvili et al.
extends thevsa of balakrishnan et al.
to detect memory corruptionsby developing a new abstraction called strided interval set implementing a lightweight algebraic solver and adopting asignedness agnostic wrapped interval domain.
however theyomit discussing the detailed semantics of their algebraic solver.both papers use vsa as a static analysis technique to over approximate possible values that registers or abstract locationsin a program can take.
we also use strided interval sets toanalyze possible values however since we employ our svidecision procedure in symbolic execution it is necessary to beable to make exact decisions.
therefore additionally we derivecompleteness conditions under which our analysis providesexact values for variables and leads to exact reachabilitydecisions.
moreover the provided under approximating valuesby ase can also lead to exact reachability decisions.
the layering design strategy which refers to employing a set of theory solvers in an increasing order of capabilityand complexity is another related research topic .bruttomesso et al.
proposed a three layered theory solverincluding a solver for the logic of equality of uninterpretedfunctions as first layer an incomplete solver which is basedon term rewriting technique and inconsistency detection forbit vector constraints as second layer and a complete solverfor bit vectors as third layer.
hadarean et al.
proposed alazy layered approach for the theory of bit vectors targetingequality and inequality constraints.
their proposed inequalitysolver applies a polynomial time algorithm to check satisfia bility given a set of constraints.
in this paper we also use alayering design strategy in our decision procedure.
however we propose an svi decision procedure as the first layer.
in the context of symbolic execution there are many tools which implement the symbolic execution algorithm targetingdifferent languages and by applying different techniques .
in this paper we extend the idea of parti which proposed an optimization technique to reduce thenumber of accesses to the constraint solver by implementingan incomplete solver for interval theory.
variable s values insuch a solver are represented by a data structure called multiinterval.
the expressions and operations which can be handledby this incomplete solver are solved efficiently and the restof the queries are passed to a complete smt solver.
thecontributions of this paper over parti are as follows.
we extend the employed abstraction in parti which isa set of non wrapped value intervals to a set of wrappedstrided value intervals.
the strided value intervals introducean incrementing step for possible values needed to reasonabout linear multiplication.
given the svi abstraction wepropose the corresponding propagation algorithm by definingthe precise formal semantics of each operation together withsoundness and completeness conditions section iv .
theextraction of such conditions is essential to make exact reach ability decisions.
parti omits to define the theory behindits engine formally including the detailed semantics of theoperations.
when a complete analysis is possible aseextents the theory by supporting several more operationsincluding linear multiplication division and remainder.
we propose an optimization technique based on the sviabstraction which aims at solving satisfiability by keeping anunder approximating set of values for variables section v .on the other hand parti supports features that ase doesnot such as signed integer arithmetic and type casting.
iv .
p recise svi d ecision procedure int x y interval x y x if y ... else ... listing code example.in this section we present the value set decision proce dure which is used in the aseengine with respect to the sviabstraction.
listing shows acode example where a sym bolic input is provided to the program.
the execution of theprogram at line assigns a symbolic value which varies in arange from 10to20into variable x. then at line variable yis assigned through a symbolic expression which therefore assigns values ... toy.
these values cannot be represented by only bounds because some values in betweenare missing.
in order to handle such a case which is the resultof a multiplication we also need to keep the incrementingstep of possible values in addition to the bounds denotedas a tuple angbracketleftlo up step angbracketright.
thus the possible values for yare represented as angbracketleft20 angbracketright.
the assignment of an arithmetic expression to a variable is evaluated by the substitution ofvariables appearing on the right hand side.
we call this processforward propagation of constraints.
afterwards the executionof the conditional expression at line creates two executionbranches.
the evaluation of the branch to true and false tightens the possible values of yto angbracketleft20 angbracketrightand angbracketleft30 angbracketright respectively.
since the assignment at line created an aliasrelation between variables yandx the values for xhave to be updated in consequence of the tightened values fory.
therefore the new values for xon the true and false execution paths are angbracketleft10 angbracketrightand angbracketleft15 angbracketright respectively.
as it is manifested in this example the evaluation of aconditional expression may need to update previously storedvalue intervals for involving variables and those which werein relation with them through an assignment which createsmemory aliasing .
we call this process backward propagation of constraints .
the value intervals of variable xat each endpoint is used to generate test inputs which trigger each of twoexecution paths in listing .
205in the context of fixed width machine arithmetic with overflow semantics integer variables can only take a finite range of values representable by wbits.
the performed operations on these integers are denoted by a subscript w e.g.
w .
in this paper we assume all arithmetic operations are unsigned and forintegers.
in fact integer values are represented by a sequence ofbits of fixed length and signedness is an interpretation of thosebits by using a method like two s complement to representsigned numbers.
definition .
strided value interval .
a strided value interval svi with wrap around semantics is a tuple angbracketlefta b s angbracketright w wheres each of a b andsare represented by w bit integers and s b wa .
the tuple indicates the set of integer values a wi s i imax whereimax is the smallest integer value which satisfies a wimax s b. the elements a b andsspecify the lower bound upper bound and stride or step of the values.
definition .
cardinality .
the cardinality of a svi denoted as card angbracketlefta b s angbracketrightw is the number of integer values in that interval and it is computed as b wa s w1where is an integer division.
definition .
strided value interval set .
a strided value interval set represents a set of svis with an identical strideindicating the values that a variable in the program can take.
following the wrap around semantics the bounds for a range of values are represented on a number circle as opposed tonumber line .
the values for an unsigned integer startwith 0and proceed clockwise to the maximum value which is2 w .
the representation of numbers in a circular manner enables us to depict the overflow concept.
for example theaddition of maximum integer value i.e.
w and 1results in0when a variable is represented by wbits.
given a value interval angbracketlefta b s angbracketrightw in the circular representation the starting point of the interval can take place in a position where eithera bora b .
the latter case specifies the occurrence of an overflow which indicates a wrapping.
interval i angbracketlefta b s angbracketright w represented on a number circle can be decomposed into atmost two sub intervals which do not wrap as follows braceleftbigg angbracketlefta b s angbracketright w arrowhookleft angbracketlefta b s angbracketrightw a b angbracketlefta b s angbracketrightw arrowhookleft angbracketlefta max s angbracketright w angbracketleftmin b s angbracketrightwotherwise wheremin glbi andmax lubi 2w .
the lubi i function maps its argument ito the largest value that belongs to the interval i angbracketlefta b s angbracketrightwand is less than or equal to i. the glbi i function maps ito the smallest value that belongs to the interval i angbracketlefta b s angbracketrightwand is greater than or equal to i. the multi interval data structure used in parti considers a set of non wrapped intervals which only keeps valuebounds.
it always splits the values when an overflow occurs.moreover representation of values with an incrementing step may not be efficient using the multi interval data structure.for example considering unsigned bit integers the set contains values where 1is the maximum representable value for an unsigned bit integer.given the multi interval abstraction this set is representedas whereas using the sviabstraction this can be represented by angbracketleft264 angbracketright64.
in the rest of this section we define the semantics for forward and backward propagation of an svi.
since we designa decision procedure for symbolic execution it is critical toextract conditions under which the analysis provides correctand exact decisions based on the employed svi abstraction.
a. f orward propagation of constraints this section presents the forward semantics of arithmetic operations and specifies the conditions under which the resulting value interval s represent the exact possible values.
addition subtraction the addition and subtraction of a non empty interval angbracketlefta b s angbracketright wand a concrete integer value k are computed as follows angbracketlefta b s angbracketrightw k angbracketlefta wk b wk s angbracketrightw angbracketlefta b s angbracketrightw k angbracketlefta wk b wk s angbracketrightw k angbracketlefta b s angbracketrightw angbracketleftk wa k wb s angbracketright w k angbracketlefta b s angbracketrightw angbracketleftk wb k wa s angbracketright w given two value intervals angbracketlefta b s angbracketrightwand angbracketleftc d s prime angbracketrightwwhere cardinality of each is greater than the addition and subtractionof those are computed as follows angbracketlefta b s angbracketright w angbracketleftc d s prime angbracketrightw angbracketlefta wc b wd gcd s s prime angbracketrightw angbracketlefta b s angbracketrightw angbracketleftc d s prime angbracketrightw angbracketlefta wd b wc gcd s s prime angbracketrightw wheregcdcomputes the greatest common divisor of two integers.
the resulting interval computed in formula is a soundover approximation of all possible resulting values when thefollowing condition is satisfied card angbracketlefta b angbracketright w card angbracketleftc d angbracketrightw 2w which means that the length of the resulting interval i.e.
b a d c should not be overflowed.
for the case wherein both operands are symbolic and the condition informula is satisfied formula may provide an intervalwhich is a superset of the exact possible values in twofollowing cases.
first case may happen when the steps of twointervals corresponding to the operands are not identical.
forexample the addition of l angbracketleft0 angbracketright 64andr angbracketleft0 angbracketright64 value intervals results a proper subset of angbracketleft0 angbracketright64containing values such as 88which cannot be inferred from l r. we derive a condition under which the resulting interval informula can provide the exact resulting values s prime s card angbracketlefta b s angbracketrightw s prime s or s s prime card angbracketleftc d s prime angbracketrightw s s prime the second case is when the operands are related to each other for example x xorx x. in such a case the resulting interval will be an over approximation of possible values.
multiplication the multiplication of a non empty interval angbracketlefta b s angbracketright wand a concrete integer value k is computed as angbracketlefta b s angbracketrightw k angbracketlefta wk b wk s k angbracketright the conditions under which the above formula provides anexact resulting values are defined as follows b a k wands k 2w which implies that the length of the resulting interval after multiplication and the resulting 206step must not be overflowed.
parti supports left shifts by using a so called left shift attribute in its decision stage.otherwise non constant multiplications are not supported byparti since it introduces value steps.
division given a non empty interval angbracketlefta b s angbracketright wand a concrete integer value k the division angbracketlefta b s angbracketrightw kis computed as follows braceleftbigg angbracketlefta k b k s r angbracketrightw a b angbracketleftmin k max k s r angbracketrightwa b wheremin andmax have the same definition as in formula .
sris computed as s k whens kand otherwise is equal to .
formula provides a sound over approximation of possiblevalues as result of division.
in order to derive the resultinginterval which represents the exact possible values we needto specify two conditions.
first when a negationslash b by checking whether the step sand the divisor kare divisible or not which means s k ifs k. the second condition applies on when a b .
in this case the interval angbracketlefta b s angbracketright wshould be split into two sub intervals angbracketlefta max s angbracketrightwand angbracketleftmin b s angbracketrightw according to formula .
the resulting values can be repre sented as the two following intervals angbracketlefta k max k s r angbracketrightand angbracketleftmin k b k s r angbracketright.
parti only supports right shifts by constant.
remainder given a non empty interval angbracketlefta b s angbracketrightwwhere a band a concrete integer value k the remainder operation angbracketlefta b s angbracketrightw kcan be computed as angbracketlefta k b k s angbracketright wb k a k angbracketlefta k istart gcd s k a k iend gcd s k gcd s k angbracketrightwb a lcm s k s b k negationslash a k angbracketleft0 k angbracketrightw otherwise whereinlcm is the least common multiple function istart a k gcd s k andiend k a k gcd s k .
all the arithmetic operations in the above formula are modulo 2w.
when one of the two first conditions in formula are satisfied the resulting interval represents the exact values.however in case of violation the otherwise case represents an over approximation of the possible values.
in case of a b the resulting values should be the remainder of both kand2 w. whenb a lcm s k s andgcd k 2w k then the resulting values can be represented by the second rule in formula .
otherwise if theconditions are not satisfied interval angbracketlefta b s angbracketright wshould be split into two sub intervals according to formula and each isanalyzed separately.
the remainder operator is not supportedby parti .
comparison the unsigned comparison expressions xcmpy where cmp negationslash can all be converted into an equivalent expression using only operation.
for operations cmp negationslash the equivalent versions are1 y x y x x y y x and y x respectively.
therefore we only need tox?
yevaluationresulting interval x y ifb cfalse true angbracketlefta b s x angbracketright angbracketleftc d s y angbracketright ifd afalse angbracketlefta b s x angbracketright angbracketleftc d s y angbracketright true ifc d false angbracketleftc b sx angbracketright angbracketleftc d s y angbracketright a c btrue angbracketlefta lubx c s x angbracketright angbracketleftc d s y angbracketright ifa b false angbracketlefta b s x angbracketright angbracketleftc a s y angbracketright c a d true angbracketlefta b s x angbracketright angbracketleftglby a d s y angbracketright table i the exact evaluation of less than operation.
reason about operation.
given two intervals x angbracketlefta b s x angbracketright andy angbracketleftc d s y angbracketrightwherea bandc d table i shows the conditions under which the evaluation of x y can be decided by specifying the exact values that each operand can take.
if the intervals for both operands are wrapped then the precise operands values cannot be efficiently computed.
how ever if only one of them is wrapped and the other operand isa concrete value then a precise decision can be made.
in thiscase the evaluation is done by splitting the wrapped intervalinto two sub intervals based on formula and then comparingthe operands accordingly.
moreover if either of the intervals for operands are represented by more than one svi the other operand has to be aconcrete value so that exact decisions can be made.
b. backward propagation of constraints taking each branch of a conditional expression might tighten the bounds of possible values for each operand.
in consequence all the other variables in the program whichwere in relation with those operands through an assignmentexpression and up to the current program location have to beupdated.
for example if we consider the interval angbracketleft10 angbracketright for variable xand execute y xthe resulting interval for y is angbracketleft20 angbracketright.
now the program may contain either if y orif x statements which forms two different types of bound propagation.
the first one should revise the value inter vals back to the variables from which ywas computed i.e.
x through the expression y x and the second one should update resulting variables of the assignment expressions inwhichxwere involved i.e.
yin the expression y x .
we call these two types of backward propagation as left to right and right to left propagations respectively.
in our example the condition if y tightens the constraint on yto angbracketleft20 angbracketright and then this new constraint should be propagated to updatethe value interval of xto angbracketleft10 angbracketright.
furthermore for the rightto left propagation type the condition if x tightens the constraint on xto angbracketleft10 angbracketrightand then this new interval is propagated through the expression y xwhich updates the value interval of yto angbracketleft20 angbracketright.
the right to left propagation is the same as what is done in forward propagation of constraints as described in sectioniv a. in order to deal with the left to right propagation weneed to define the inverse semantics of each operation.
let us assume that the values for variable xare represented as angbracketlefta b s x angbracketright.
if we execute the expression y x kwhere andk 0is a concrete integer value the resulting values for ywill be represented by angbracketleftc d s y angbracketright.
now the execution of the conditional expression if y t may tighten the possible values of yto angbracketleftc prime d prime sy angbracketrightwherec prime d prime angbracketleftc d s y angbracketright.
in order to update the values of xbased on the new values of y we need to inverse the applied operation as follows.
operation new bounds x kork xa prime c prime k b prime d prime k x ka prime c prime k b prime d prime k k xa prime k d prime b prime k c prime table ii inverse of addition and subtraction opera tions.
addition subtraction the addition can be reversedby subtraction and thesubtraction is reversed usingeither addition or subtraction.table ii shows how to reversean addition or a subtractionby indicating expressions tocompute bounds of variable x. the semantics of addition andsubtraction to do reversion is the same as what is explainedin section iv a. multiplication the multiplication can be reversed using division as follows a prime a c prime c k andb prime a d prime c k for example considering angbracketleft263 angbracketright64as the value interval ofx then multiplication of xby2results in angbracketleft0 angbracketright64 when the arithmetic is modulo .
now we execute if y and thus the tightened interval for yis angbracketleft0 angbracketright64.
the original bounds for xcan be updated as 2and .
parti omits explaining the details of how multiplication is reversed using a division especiallywhile wrapping occurs.
division whenever for the original interval of xconditiona bis satisfied the new bounds for xare as follows a prime braceleftbiggac prime k a glbx c prime k c prime k a b prime lubx d prime k offset moreover offset is computed as braceleftbiggb d prime kb d prime k k k 1b d prime k k in fact the purpose of offset is to reverse the side effect of integer division.
in integer division the result loses its decimalpart e.g.
and in order to be able to reverse that we need to compute offset.
for example we assume x angbracketleft11 angbracketrightand we execute y x 2theny angbracketleft5 angbracketright and the execution of if y results in a new value interval y angbracketleft7 angbracketrightand thus x angbracketleft15 angbracketright.
in case of a b inversion should be applied with respect to two non wrapped sub intervals angbracketlefta max s x angbracketrightand angbracketleftmin b s x angbracketright ofxcomputed according to formula .
the backward propagation of division is not supported by parti .
remainder to reverse remainder we need to compute values inside the interval angbracketlefta b s x angbracketrightfor which x k results a value in angbracketleftc prime d prime sy angbracketright.
the analysis of this operation may lead to a large number of value intervals and thus may be costlyusing the svi abstraction.
therefore we omit to apply theexact backward propagation on remainder operation.c.
time complexity the time complexity of the decision procedure proposed in this section depends on the number of instructions and theircost.
given an execution path in a program we assume that n indicates the number of instructions on the path kidentifies the maximum number of value intervals returned by applyingan operation and crepresents a constant indicating the upperbound on the cost of applying an operation.
while propagation the time complexity of each addition orsubtraction is o k c .
moreover multiplication division modulo and comparison operations each can be computed ino k c .
backward propagation of intervals takes o n k c since the depth of backward propagation might be proportionalto the number of executed instructions on the path.
therefore the total time complexity of the analysis for an execution pathis computed as o n k c o n2 k c .
let us assume that a symbolic expression is represented by an abstract syntax tree.each intermediate node of this tree represents an arithmeticoperation and each leaf node represents a concrete or a sym bolic input value.
when the symbolic expressions representingvariables and operands have shallow depth and can be boundedby a constant value d then this time complexity order tends too n k c o n d k c .
v. u nder approximating svi d ecision procedure in section iv we explained the conditions under which our svi abstraction can provide exact decisions over a set ofconstraints.
in order to exploit the efficiency of the decisionprocedure presented in section iv we propose a techniquewhich enables us to still reason about the satisfiability of aset of constraints efficiently for the cases which conditions intable i are not satisfied anymore.
for example considering theexpression x ywherex angbracketleft0 angbracketrightandy angbracketleft2 angbracketright the striped region in figure 1b illustrates the values for each of x andywhich satisfy x y. the values of the operands intersect each other on interval angbracketleft2 angbracketrightand for this intersection area in addition to the value intervals a less than equal relation hasto be set between variables.
representing the precise set ofvalues which each of xandyvariables can take is inefficient using the svi abstraction since it may lead to many relativecases and may increase the complexity of the analysis.
theinterval theory proposed by dustmann et al.
does notsupport the backward propagation of such constraints to theinvolving variables.
in learning stage of their theory onlybinary operations whose one side is a constant is analyzed.
in such cases where the intervals of the operands in a comparison expression overlap each other the analysis canstill be continued by maintaining an under approximating setof values s a. keeping a set of values which satisfy the currently seen set of constraints on the path condition asopposed to only one generated witness by an smt solver may help deciding the satisfiability of the constraints whichwill appear further on the execution path the unsatisfiabili ty unreachability decisions cannot be proved using the under approximation since the set of all values are not available .
thesatisfiability of a set of constraints which can be determined by 208xy bbbbbbbbbb1111bbbbbbbbbbbbbbb222222222 a xy bbbbbbbbbbb b fig.
a boxes b1andb2indicate two candidate underapproximating regions for the evaluation of x yto true.
b boxbindicates an under approximating region for the evaluation of x yto true.
this set of values does not need to be checked by a complete bit vector decision procedure i.e.
smt solver .
definition .
given a constraint satisfaction problem angbracketleftx d c angbracketright a solution box is defined as b i1 ... in whereii direpresents a value interval for xi satisfying c. an under approximating set of possible values can be indicated by a box.
figure shows the region striped where x yis evaluated as true where x angbracketleft0 angbracketrightandy angbracketleft2 angbracketright.
choosing any box or set of boxes in this region determinescandidate intervals for each of the operands which under approximate the possible resulting values.
we avoid selectinga set of boxes since it increases the complexity of the propaga tion algorithm which harms the efficiency.
to keep the analysislightweight one of the design factors is to trade off accuracy ofthe resulting candidate box es for faster selection of those.
wepropose and evaluate two methods for the under approximatingbox selection based on the following observations.
giventhe conditional expression x yon an execution path of a program depending on the further usages of xandyon the path the selection of different boxes can be useful.
observation .
in a program which computes the maximum of elements in an array the comparison of two array elementsxandyalways takes the greater variable and continues the execution with that i.e.
yforx y andxfor the negation x y .
therefore the best choice is a box which prioritizes the greater variable.
the variable prioritization means thatwe assign the largest possible value interval satisfying thecondition to that variable.
the story is reverse while computingthe minimum of elements in an array where the comparison oftwo array elements xandyalways takes the smaller variable and continues the execution with that i.e.
yforx y andx for the negation x y .
here the best choice is the box which prioritizes the smaller variable.
based on this observation wepropose a heuristic which considers two candidate boxes thebox in which variable yis prioritized over x and the box in which variable xis prioritized over y. for example the true evaluation of x y as depicted in figure 1a leads to the following choices respectively x angbracketleft0 angbracketrightand y angbracketleft2 angbracketright x angbracketleft0 angbracketrightandy angbracketleft10 angbracketright.w e keep the above two choices as candidate boxes for the trueevaluation of x yand continue the execution.
the first upcoming decision point on the execution path which involvesone of the operands will select one of the boxes which canprovide a decision and the execution is continued with thatchoice.
for example if after the true evaluation of x ythe execution reaches the condition y zwherez angbracketleft0 angbracketrightthen for the rest of the execution on this path the box x angbracketleft0 angbracketright andy angbracketleft2 angbracketrightis chosen for the true evaluation of x y since this choice leads to decisions for both true and falsebranches of the currently processing condition y z. observation .g i v e nx yon an execution path of a program the second observation is when we cannot prioritizeone variable over the other one because both of them are usedfurther on the execution path.
in this case we need to select arange of values for each of the involving variables instead ofone concrete value.
therefore we propose a heuristic whichtakes the middle point in the intersection of the operands intervals and derives the respective boxes accordingly.
themiddle point provides equal chance to each of the operands.any other choice prioritizes one of the operands over the otherone.
in figure 1b the middle point of the intersection of theintervals representing variables xandyis6 and thus the derived box for the x ywill be represented as x angbracketleft0 angbracketright andy angbracketleft6 angbracketright.
once the under approximating box es is selected the execution will be continued accordingly.
any satisfiability decisionwhich can be made base on the selected under approximatingvalue boxes does not need to be checked with the smt solver.
vi.
i mplementation details this section explains the implementation details of the proposed symbolic execution engine.
machine state representation.
symbolic inputs to the program are denoted by set in 1 ... n where iis represented as a value interval ii.
the symbolic execution engine has to keep track of the machine state transitionsas a consequence of executing instructions using symbolicvalues.
the machine state at each step of the executionis represented by the current state of the registers and thememory.
the stored values inside the registers and memoryaddresses may be symbolic or concrete.
the stored value isthe result of applying binary and unary operations on initialsymbolic or concrete input values expressed as a symbolicexpression e. the registers and memory states are indicated by a mapping from register numbers and memory addressesto symbolic expressions and values which are guarded by thepath condition.
definition .
a symbolic value is represented as a tuple angbracketlefte pc v a angbracketrightwhereepcspecifies the symbolic expression guarded by the path condition aindicates the abstraction and vdenotes the set of values with respect to a. a symbolic memory address m or a symbolic registerriis represented by a symbolic value tuple which is associated to the memory address or the register.
the elementaof a symbolic value tuple associated to each memory address indicates the abstraction which has been used so far 209to reason about the set of constraints involving that memory address.amainly takes three values of pvi ubox andbvt representing precise value interval under approximating valuebox and bit vector abstractions.
a pvianda ubox mean that our svi decision procedure provides precise and under approximating analysis for the involving variable.
otherwisewhen the theory of bit vectors is used to reason about theconstraints involving that memory address ais set tobvt.
the value set vis represented by a set of wrapped strided value intervals which specify the precise or under approximatingvalues.
in the worst case vonly contains one value which is obtained from the smt s witness.
we use a trace of executionhistory to keep track of memory state transitions which iscalled the memory trace data structure.
definition .
a trace entry te for memory address addr is represented by a tuple angbracketleft lscript prev m angbracketright where lscriptis the location of the instruction which caused creating the trace entry prev points to the previous symbolic value tuple of addr andm represents the new symbolic value tuple for addr .
the operations which update the memory trace are any instructions whose execution affects the symbolic value of amemory address.
these operations include storing a symbolicexpression into a memory address evaluating a symbolic con ditional expression and executing a system call such as read orbrk.
at each point of the execution of a program the trace should return the most recently updated symbolic value tuplewhich is stored into a specific memory address.
this is done bykeeping track of pointers which assign memory addresses tothe corresponding trace entries which contain the most recentlyupdated values.
the previously stored values into a memoryaddress by previous instructions and on different pending pathsduring symbolic execution of code are kept on the trace forfurther backtracking.
ase algorithm.
algorithm illustrates the symbolic execution algorithm.
the execution starts at the initial programlocation lscript .
depending on the instruction which is currently under execution the engine updates its state.
when a memoryaddress variable is specified with a symbolic input then asymbolic value tuple representing its value is stored at thatmemory address line .
for example if we assign a rangeof values between 10and20to variable a then this is done by assigning an interval angbracketleft10 angbracketrightfor our value interval abstraction and a symbolic expression denoting a .
a symbolic expression is represented as an abstract syntaxtree.
a symbolic expression which is evaluated as a concretevalue is stored accordingly in the memory.
the content of a memory address m is loaded by putting a symbolic value tuple angbracketlefte pc v a angbracketrightstored at that memory address into a destination register line .
each store which may be interpreted as an assignment in high level code updates the memory with the symbolic value of a register line9 .
moreover it keeps track of the memory aliases which iscreated between variables through this assignment e.g.
thealiasing relation between aandbthrougha b .
during the execution whenever a conditional expression r d ricmprjis reached where cmp negationslash thenalgorithm abstract symbolic execution engine input program p lscript 2while true do switch op lscript do case read m angbracketleftepc v pvi angbracketright case load ri m case store m ri caseif rd rd ricmprj cmp negationslash false reachability evaluate r d false iffalse reachability true then save context r d false end true reachability evaluate r d true iftrue reachability true then pc pc rd true else backtrack end case end point generate witness backtrack default propagate forward op lscript abstraction end lscript next lscript if lscript 0then terminate 29end the reachability of the true and false branches is evaluatedby calling the evaluate function.
the reachability of the false branch is tried first and if it is reachable the symbolicexecution context for the false evaluation of the conditionalexpression is saved for further backtracking line .
after wards the reachability of the true branch is examined and ifit is reachable the true evaluation of the condition will beadded to the explored path condition so far line .
if thetrue branch is not reachable the execution will be continuedwith the false branch by backtracking line .
theevaluate function as depicted in algorithm takes the conditional expression as input and returns the reachabilitydecision as its output.
in this function the decision proce dures are tried in order.
dp pvi .
anddpubox .
functions refer to the evaluation of the comparison operation in thedecision procedures of sections iv and v respectively.
thepropagate backward function implements the semantics explained in section iv b. the newly evaluated svis for eachof the operands r iandrj are propagated backwards with respect to the underlying abstraction.
this function refines thepossible values of the involving variable in each operand andall expressions in which those were involved until it reachesan input variable.
while propagating backwards if the enginedetects that further propagation is not possible for examplebecause of an unsupported operation such as remainder thefunction returns a failure.
in case neither of the precise and theunder approximating decision procedures can provide a deci sion the reachability is decided by the smt solver line .
in 210algorithm evaluate input constraint rd ricmprj output true or false 1ifa ri pvi a rj pvi then dppvi rd ifcan handle true then ifreachability result false then return false ri propagate backward r iwhenrd pvi rj propagate backward r jwhenrd pvi ifri true rj true then return true end 9end 10ifa ri negationslash bvt a rj negationslash bvt then dpubox rd ifcan handle true then ri propagate backward r iwhenrd ubox rj propagate backward r jwhenrd ubox ifri true rj true then return true end 17end 18ifcheck sat smt solver r d true then upgrade abstraction bvt return true 21else return false 23end case of a satisfiability decision the abstraction of the involving symbolic variables are upgraded to bvtand the value set vof each is updated with the generated witness of the smt solverusing the upgrade abstraction function line .
the default case at line of algorithm applies the forward propagation of the other operations including addi tion subtraction multiplication division and remainder.
theforward propagation function applies forward propagation of the current instruction based on the semantics explainedin section iv a when the abstraction is svi or keeps trackof symbolic expressions to be used for bit vector abstractionlayer.
while symbolically executing the program the targetmay be to generate test inputs which trigger an end point forexample the exit point of the program on a path or an errordetection line .
moreover reaching an end point triggers abacktracking line .
through the backtracking the machinerestores its previous state for a given pending path.
thus itundoes the effect of instructions which were executed after agiven branching point.
this includes un trace entries byrestoring the previous value for each memory address pointedbyprev element of the trace entry and updating the pointer to the most recent value of that memory address.
moreover the path condition is retrieved to the previous state.
considering the example of listing a conditional expression is evaluated as follows using evaluate function.
variables xandytake two symbolic values represented as two svis and their abstraction is set to pvi lines and .
when the execution reaches the conditional expression at line4 the reachability of the false evaluation of the branch istried first by using the precise svi decision procedure.
anexact decision for evaluating angbracketleft10 angbracketright 45can be made by dp pvi .
.
thus the values for xwill then be refined to angbracketleft16 angbracketrightusing propagate backward functionwithpviabstraction and evaluate returnstrue.
the current execution context will be saved for further backtracking andthen the reachability of the true branch is examined.
theevaluation of angbracketleft10 angbracketright 45is done accordingly usingdp pvi .
and the values for xwill then be refined to angbracketleft10 angbracketrightwithpviabstraction and evaluate returnstrue.
the recently evaluated constraint will be added to the pathcondition and the execution continues on the true branch.
int x y x y if x if x y if x ... else ... else ... else ... listing an example toshow how reachability isevaluated using ase.at line to decide the reachability of the false branch x y firstdp pvi .
is tried since the abstraction used for representingxandyis stillpvi.
however since the operands value inter vals overlap each other the pre cise backward propagation is notpossible see section v .
thus at next step dp ubox .
is tried to check if it can provide a decision.using observation of section v a decision can be made by setting angbracketleft13 angbracketrightand angbracketleft10 angbracketright under approximating svis for operands xandy respectively.
hence the abstraction for xandyare set to ubox and evaluate returnstrue.
the execution context will be saved and next the reachability of the true branch is investigated.
theevaluation of x y is done accordingly using observation of section v and the values for xandywill then be refined to angbracketleft10 angbracketrightand angbracketleft12 angbracketrightusingubox abstraction andevaluate returnstrue.
the path condition is updated and the execution continues on the true branch.
later whenline is reached the current abstraction for xisubox and thusdp ubox .
is first checked whether it can provide an exact decision over reachability of the false branch angbracketleft10 angbracketright based on the operands svis.
the satisfiability is decidedby considering values angbracketleft10 angbracketrightforxusingubox abstraction.
the current execution context for false branch is savedand then the true branch is evaluated.
the evaluation of angbracketleft10 angbracketright however cannot be decided using dp ubox .
since we only keep an under approximation of possible valuesand those values do not satisfy the condition.
therefore theabstraction is upgraded to bvtand a query including the symbolic constraint guarded by the path condition will be sentto the smt solver to be decided.
the value sets for xandy will be refined by the generated witness of the solver e.g.
v x angbracketleft14 angbracketrightandvy angbracketleft14 angbracketright and their abstraction is set tobvt.
now that we reached to an end point the execution backtracks to traverse the false evaluations of the conditionsstarting at the saved context for the false branch of line .it is worth mentioning that the interval theory proposed inparti cannot reason about this example.
vii.
e v aluation in this section we demonstrate the effectiveness of our proposed ase engine in speeding up the symbolic analysis.
insection iv c we discussed the asymptotic time complexity ofthe proposed svi decision procedure.
in this section the goal is 211benchmark pathsase o1 ase o2 parti baseline reduction in execution time for ase time s queries time s queries time s queries time s queriesversus parti versus baseline o1 o2 o1 o2 bubble sort .
.
.
.
.
.
.
.
bubble sort .
.
.
.
.
.
.
.
bubble sort all .
.
.
.
.
.
.
.
heap sort .
.
.
.
.
.
.
.
heap sort .
.
.
.
.
.
.
.
heap sort all .
.
.
.
.
.
.
.
insertion sort .
.
.
.
.
.
.
.
insertion sort .
.
.
.
.
.
.
.
insertion sort all .
.
.
.
.
.
.
.
merge sort .
.
.
.
.
.
.
.
merge sort .
.
.
.
.
.
.
.
merge sort all .
.
.
.
.
.
.
.
quick sort .
.
.
.
.
.
.
.
quick sort .
.
.
.
.
.
.
.
quick sort all .
.
.
.
.
.
.
.
selection sort .
.
.
.
.
.
.
.
selection sort .
.
.
.
.
.
.
.
selection sort all .
.
.
.
.
.
.
.
dijkstra .
.
.
.
.
.
.
.
kruskal .
.
.
.
.
.
.
.
bellman ford .
.
.
.
.
.
.
.
binary search all .
.
.
.
.
.
.
.
linear find all .
.
.
.
.
.
.
.
ispermutation .
.
.
.
.
.
.
.
gcd .
.
.
.
.
.
.
.
loop invgen .
.
.
.
.
.
.
.
min max all .
.
.
.
.
.
.
.
dirname .
.
.
.
.
.
.
.
fibonacci .
.
.
.
.
.
.
.
half .
.
.
.
.
.
.
.
outer product .
.
.
.
.
.
.
.
table iii the number of explored paths the symbolic execution time the number of reached queries to the smt solver for each of the ase the parti and the baseline approaches.
o1 and o2 stand for observation and observation which areapplied in the ase approach.
the reduction in symbolic execution time for the ase compared to the parti and the baselineapproaches is reported in percentage and illustrated in last four columns.
to show the efficiency of employing the proposed svi decisionprocedure in practice by running the ase engine on a set ofbenchmark programs.
we evaluate the engine by comparingthe following approaches ase o1 and ase o2 which refer to the proposed engine and its decision procedure in thispaper by applying the heuristic methods of observation andobservation proposed in section v respectively.
parti refers to the state of the art approach .
baseline is a design strategy which uses an smt solver for the constraintsolving component of the symbolic execution.
in baselineall the generated symbolic constraints out of the benchmarkprograms are sent to the smt solver as query to be solved.
a. experimental setup we ran our experiments on a 512gb numa machine with four core .
ghz amd opteron processors and linux kernel version .
.
for our experiments we usedboolector version .
.
with cadical as backend satsolver and incremental mode enabled.
we used gcc andg version .
to build boolector smt solver and compileour implemented ase engine source code.
we set depth first search dfs strategy to explore the paths in benchmark programs.
the witnesses for each explored path are computedbut they are not printed for none of the approaches.
whileexecuting depending on the underlying abstraction the enginekeeps the set of values v precise or under approximation for variables on a path updated for all the approaches.
we run our experiments on a set of benchmarks from different classes of programs typically used in evaluatingsymbolic execution approaches includingsorting searching graph and computational algorithms.
thesource code of the benchmark programs which is written ina subset of c are compiled to a subset of risc v using anon optimizing compiler .
b. experimental results table iii reports the execution results of running all approaches on a set of benchmarks.
the reported data includes the number of explored paths which are identical for allapproaches the symbolic execution time and the number ofqueries that reached the smt solver.
the suffixes added tothe names of the benchmarks indicate the number of involvedsymbolic values in their input data e.g.
array graph namelyall and .
for example in bubble sort 1and bubble sort the input arrays for sorting contain one and three symbolic val ues respectively and the rest are concrete values.
similarly allthe values in the input array for bubble sort allare symbolic.
the last four columns of table iii report the reduction in symbolic execution time caused by employing ase usingtwo different heuristic methods of observations and 212explained in section v. compared to the parti and the baseline approaches on average the ase engine which isbased on observation led to .
and .
reductionin symbolic execution time respectively.
the application ofthe ase engine based on observation showed an averageof .
reduction in symbolic execution time comparedto the parti approach and an average of .
reductioncompared to the baseline.
the results show that the aseengine using either of the heuristic methods of observations1 and performs effective while whenever it does not work the overhead remains low.
moreover the usage of the heuristicof observation for generating under approximating valueintervals often helps deciding more queries and consequentlyleads to better performance than the heuristic of observation .
the array sorting benchmark programs provide a useful case study for our evaluation.
by inserting different number of sym bolic values inside the input array to be sorted we can examinethe effectiveness of the techniques used in our engine.
the sizeof input arrays for benchmarks with and allsuffixes are and respectively.
the inserted symbolic values arerepresented by value intervals angbracketleft0 size angbracketrightwheresize is the array length.
selecting an interval with a larger upper boundsuch as angbracketleft0 max angbracketrightdoes not influence the number of explored paths for none of the approaches.
however selection ofthe larger interval angbracketleft0 max angbracketrighton average causes the underapproximating decision procedure to perform more effectively.as it is shown in table iii for the array sorting benchmarksase performs almost as good as the parti approach when thenumber of symbolic values in the input array is one.
however when this number is increased ase outperforms the partiapproach.
when the number of involving symbolic values islimited to one the precise svi decision procedure is enoughto make decisions over the set of generated constraints.
forsorting algorithms this means that always one side of theinvolving comparison expressions on the path condition isevaluated to a concrete value.
however when this number isincreased the precise svi decision procedure may not be ableto decide all sets of constraints generated out of the program.in particular when the analysis involves the comparison ofvariables with overlapping symbolic values e.g.
x y where x angbracketleft0 angbracketrightandy angbracketleft0 angbracketright .
the interval theory in parti does not support the backward propagation of suchconstraints.
whereas ase tries to continue the analysis usingthe svi abstraction with under approximation section v and thereafter if the engine still could not provide a decisionusing the under approximation abstraction it sends the set ofconstraints to the smt solver.
as depicted in table iii theapplication of the svi abstraction with under approximationperforms effective for the array sorting benchmarks when morethan one symbolic value in the input is involved and it reducesthe number of sent queries to the smt solver.
the results for bellman ford and gcdprograms show cases that the application of the under approximating svi deci sion procedure does not perform effective.
however theinduced overhead is very low which is the result of apply ing lightweight heuristics to compute under approximatingboxes and therefore this causes the ase engine to workalmost as good as parti.
on the other hand the under approximating svi decision procedure performs effective toanalyze binary search alland linear find allprograms for which all the required decisions are made by the precise andunder approximating svi decision procedures.
as depicted all the generated constraints out of dirname fibonacci benchmarks can be solved by the precise svi decision procedure.
thus ase performs almost as good as parti.the half and outer product benchmark programs contain expressions with linear symbolic multiplication operation.
asexplained in section iv this kind of expression has to bedealt with the value interval abstraction with step.
hence theinterval abstraction proposed in parti which only considersvalue bounds cannot reason about such expressions.
this is thereason why ase outperforms parti for these benchmarks.
in summary we learned that many of the constraints generated out of the programs use a handful of operationswith special features that can be solved by the svi decisionprocedure.
therefore employing our theory integration in alayered manner of increasing capability and complexity forconstraint solving of symbolic execution is effective.
however a key design factor is to keep the former layers as lightweightas possible so that it does not harm efficiency and performancecompared to smts or when former layers fail.
viii.
c onclusion we presented abstract symbolic execution ase with the goal of speeding up reachability decision making in symbolicexecution.
the ase engine benefits from a theory integrationinside the constraint solving component of symbolic executionin a layered manner of increasing capability and complexity byemploying svi and bit vector abstractions.
we learned throughexperiments on a set of benchmark programs that many of theconstraints generated out of the programs can be solved by theless complex svi decision procedure.
therefore employingour theory integration for constraint solving is often effectivein reducing symbolic execution time and the number of queriesreaching the smt solver.
however keeping the former layerslightweight is a key design factor to preserve the efficiency ofthe analysis compared to smts or when former layers fail.
extending the ase engine to make decisions over floatingpoint arithmetic is a promising future direction.
our conjectureis that employing the existing more complicated propagationtechniques for the box abstraction leads to an even betterspeedup for floating point numbers compared to integers.
a cknowledgment we thank the ase reviewers for their thoughtful comments.
this work has been supported by the czech ministry ofeducation youth and sports from the czech operationalprogramme research development and education undergrant agreement no.
cz.
.
.
.
.
and the european research council erc under the europeanunions horizon research and innovation programme under grant agreement no.
.
213references r. baldoni e. coppa d. c. d elia c. demetrescu and i. finocchi a survey of symbolic execution techniques acm computing surveys vol.
no.
pp.
.
c. cadar d. dunbar and d. engler klee unassisted and automatic generation of high coverage tests for complex systems programs in proceedings of the 8th usenix conference on operating systemsdesign and implementation pp.
.
b. korel a dynamic approach of test data generation in proceedings.
conference on software maintenance pp.
.
j. c. king symbolic execution and program testing communications of the acm vol.
no.
pp.
.
d. kroening and o. strichman decision procedures an algorithmic point of view.
springer berlin heidelberg .
m. brain d. kroening and r. mccleeary algebraic techniques in software verification challenges and opportunities in proceedings of the 1st workshop on satisfiability checking and symbolic computation pp.
.
s. bardin n. bj rner and c. cadar bringing cp sat and smt together next challenges in constraint solving dagstuhl seminar indagstuhl reports vol.
no.
.
schloss dagstuhl leibniz zentrumfuer informatik .
r. sen and y .
n. srikant executable analysis using abstract interpretation with circular linear progressions in proceedings of the 5th acm ieee international conference on f ormal methods and modelsfor codesign pp.
.
y .
shoshitaishvili r. wang c. salls n. stephens m. polino a. dutcher j. grosen s. feng c. hauser c. kruegel and g. vigna sok state of the art of war offensive techniques in binary analysis inieee symposium on security and privacy pp.
.
t. reps g. balakrishnan and j. lim intermediate representation recovery from low level code in proceedings of the acm sigplan symposium on partial evaluation and semantics based program ma nipulation pp.
.
g. balakrishnan and t. reps wysinwyx what you see is not what you execute acm transactions on programming languages and systems toplas vol.
no.
pp.
.
n. redini r. wang a. machiry y .
shoshitaishvili g. vigna and c. kruegel bintrimmer towards static binary debloating throughabstract interpretation in international conference on detection of intrusions and malware and vulnerability assessment pp.
.
o. s. dustmann k. wehrle and c. cadar parti a multi interval theory solver for symbolic execution in proceedings of the 33rd acm ieee international conference on automated software engineering pp.
.
b. mayoh e. tyugu and j. penjam constraint programming.
springer berlin heidelberg .
g. gange j. a. navas p. schachte h. s ndergaard and p. j. stuckey interval analysis and machine arithmetic why signedness ignoranceis bliss acm transactions on programming languages and systems toplas vol.
no.
pp.
.
a. gotlieb m. leconte and b. marre constraint solving on modular integers in proceedings of the ninth international workshop on constraint modelling and reformulation .
r. bruttomesso a. cimatti a. franz en a. griggio z. hanna a. nadel a. palti and r. sebastiani a lazy and layered smt bv solver for hardindustrial verification problems in proceedings of the 19th international conference on computer aided v erification pp.
.
l. hadarean k. bansa d. jovanovi c c. barrett and c. tinelli a tale of two solvers eager and lazy approaches to bit vectors in proceedings of the 26th international conference on computer aided v erification pp.
.
c. barrett c. l. conway m. deters l. hadarean d. jovanovi c t. king a. reynolds and c. tinelli cvc4 in proceedings of the 23rd international conference on computer aided v erification pp.
.
s. anand c. s. p as areanu and w. visser jpf se a symbolic execution extension to java pathfinder in tools and algorithms for the construction and analysis of systems pp.
.
d. beyer t. a. henzinger and g. th eoduloz program analysis with dynamic precision adjustment in proceedings of the 23rd ieee acminternational conference on automated software engineering pp.
.
s. anand c. s. p as areanu and w. visser symbolic execution with abstraction international journal on software tools for technology transfer vol.
no.
pp.
.
j. geldenhuys m. d. b and w. visser probabilistic symbolic execution in international symposium on software testing and analysis pp.
.
t. a. henzinger r. jhala r. majumdar and g. sutre lazy abstraction in proceedings of the 29th acm sigplan sigact symposium on principles of programming languages pp.
.
a. niemetz m. preiner and a. biere boolector .
system description journal on satisfiability boolean modeling and computation vol.
no.
pp.
.
c. saumya j. koo m. kulkarni and s. bagchi xstressor automatic generation of large scale worst case test inputs by inferring path condi tions in proceedings of the 12th ieee conference on software testing v alidation and v erification pp.
.
sv comp software verification competition .
c. m. kirsch selfie and the basics in proceedings of the acm sigplan international symposium on new ideas new paradigms andreflections on programming and software pp.
.
a. s. abyaneh and c. m. kirsch you can program what you want but you cannot compute what you want in principles of modeling essays dedicated to edward a. lee on the occasion of his 60th birthday pp.
.
selfie an educational software system of a tiny self compiling c compiler a tiny self executing risc v emulator and a tiny self hostingrisc v hypervisor