jvm fuzzing for jit induced side channel detection tegan brennan university of california santa barbara santa barbara ca usa tegan cs.ucsb.eduseemanta saha university of california santa barbara santa barbara ca usa seemantasaha cs.ucsb.edutevfik bultan university of california santa barbara santa barbara ca usa bultan cs.ucsb.edu abstract timing side channels arise in software when a program s execution time can be correlated with security sensitive program input.
recent results on software side channel detection focus on analysis of program s source code.
however runtime behavior in particular optimizations introduced during just in time jit compilation can impact or even introduce timing side channels in programs.
in this paper we present a technique for automatically detecting such jit induced timing side channels in java programs.
we first introduce patterns to detect partitions of secret input potentially separable by side channels.
then we present an automated approach for exploring behaviors of the java virtual machine jvm to identify states where timing channels separating these partitions arise.
we evaluate our technique on three datasets used in recent work on side channel detection.
we find that many code variants labeled safe with respect to side channel vulnerabilities are in fact vulnerable to jit induced timing side channels.
our results directly contradict the conclusions of four separate state of the art program analysis tools for side channel detection and demonstrate that jit induced side channels are prevalent and can be detected automatically.
acm reference format tegan brennan seemanta saha and tevfik bultan.
.
jvm fuzzing for jit induced side channel detection.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
introduction side channel vulnerabilities occur when a non functional but observable behavior of a system such as its execution time leaks information about the secret values that the system accesses.
although side channel vulnerabilities due to hardware such as vulnerabilities this material is based on research sponsored by nsf under grants ccf and ccf and by darpa under the agreement number fa8750 .
the u.s. government is authorized to reproduce and distribute reprints for governmental purposes notwithstanding any copyright notation thereon.
the views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements either expressed or implied of darpa or the u.s. government.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
.
.
.
exploit the cache behavior have been extensively studied software side channels have only recently become an active area of research .
in recent years several techniques have been proposed for detecting sidechannel vulnerabilities in programs.
in this paper we demonstrate that the most recent analysis techniques and tools proposed for detection of side channels in java programs miss a class of vulnerabilities and incorrectly label programs safe.
the main cause of this failure is that side channel detection tools do not take dynamic behavior of the java virtual machine jvm into account.
runtime performance of java programs significantly depends on just in time jit compilation techniques which compile and optimize portions of the code based on the runtime behavior of the program.
in this paper we demonstrate that programs labeled safe with respect to timing side channels by four different program analysis tools do in fact contain side channel vulnerabilities if the runtime behavior of the program is sufficiently biased.
we call side channel vulnerabilities that are due to jit optimizations jit induced side channels and we present an automated approach for finding jit induced side channel vulnerabilities.
our contributions in this paper are an automated pattern based approach for finding input partitions that are likely to be separable by a timing side channel.
an automated technique to generate input belonging to different partition cells using branch instrumentation.
an automated search strategy for a jvm state vulnerable to a timing channel using priming input generated via fuzzing.
an evaluation of our approach on widely used side channel detection benchmarks demonstrating its ability to automatically induce timing side channels in programs labelled safe by four other recent analysis tools blazer themis coco channel and difffuzz .
the rest of the paper is organized as follows.
in section we discuss jit induced timing side channels and provide an overview of our automated detection process.
in section we discuss our approach for pattern based identification of partitions of secret input which are likely to be separable by a timing side channel.
we detail how we instrument the program to generate test input data belonging to these partition cells.
we also discuss how we use grey box fuzzing to generate a set of priming inputs.
in section we present an algorithm to use the generated test input data and priming input to fuzz the jvm for vulnerabilities to jit induced timing side channels.
in section we evaluate our technique discuss our experiments and highlight key results.
in section we discuss related work.
in section we present our conclusions.
ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea tegan brennan seemanta saha and tevfik bultan public static boolean sanity unsafe int a int b int i b int j b if b return false if a return true else while i i return false public static boolean sanity safe int a int b int i b int j b if b return false if a while i i else while j j return false a b figure two examples from the blazer benchmark.
overview timing side channel detection techniques investigate the following question assume a program pis a function on some input i consisting of secret input hand non secret input l. for some fixed l are there at least two mutually exclusive non empty subsets of the secret domain hsuch that by observing the execution time of the program on a secret value one can determine to which of the subsets the secret belongs?
note that precisely determining the answer to this membership question may not be possible due to either noise in the observations of the execution time or to overlapping execution time behavior of secret values belonging to different subsets of the input.
so typically the answer we get to the question of does the secret belong to a particular subset?
is not a discrete yes or no answer but a quantitative answer that indicates our assessment of how likely it is that the secret belongs to that particular subset.
to automate the analysis we have to frame the problem in more detail.
first we need to characterize what type of information about the secret can be leaked from the program.
at a high level the type of information that can be leaked about the secret will characterize the subsets of the secret domain for which the membership question is most likely answerable.
one avenue through which information can be leaked is program branches.
each branch in the program can potentially influence the execution time.
therefore the branches that depend on the secret can result in timing side channels.
consider a secret dependent branch and the corresponding branch condition and assume that we divide the set of secret values to two subsets the secret values that cause the branch condition to evaluate to true the secret values that cause the branch condition to evaluate to false.
now also assume that by observing the execution time we can tell if the branch condition evaluates to true or not this would be possible for example if the evaluation of the branch condition to true causes more expensive computation to be undertaken .
in this case we can conclude that there is a timing side channel and the program leaks information about the secret since we are able to distinguish which subset that the secret belongs to.
let us make our discussion more concrete with an example.
figure a shows the sanity unsafe method taken from the blazer side channel detection benchmark .
in this example the secret is the value of the argument a. the second if statement in the program corresponds to a branch that is dependent on the secret.
if argument bis particularly large it would be possible to detect if the then or else branch is taken.
this would enable us to tell if the secretvalue is less than zero.
so we can define two subsets of the secret domain integer values less than zero and integer values greater than or equal to zero and by observing the execution time of the method we can tell which subset the secret belongs to.
hence we can conclude that this method has a side channel vulnerability and is unsafe.
and this is exactly what the side channel detection tools report.
profiling the execution time of the sanity unsafe method shows a clear timing side channel.
the violin plot in figure a shows the execution time distributions for the sanity unsafe method for partitions a 0anda 0for a fixed bvalue.
now let us look at the sanity safe method in figure b .
again the secret is the value of the argument a and the second if statement in the program corresponds to a branch that is dependent on the secret.
however for this case both branches contain equivalent computations so the same computation is performed regardless of the evaluation of the branch condition.
this should imply that we cannot tell which branch is taken by observing the execution time.
all modern side channel analysis tools perform this reasoning in one form or another and conclude that the method sanity safe is indeed safe and does not contain a side channel vulnerability.
let us again check this conclusion by profiling.
figure b demonstrates the execution time distribution for the sanity safe method for partitions a 0anda 0with the same constant value for bas used in figure a .
it is clear from these distributions that an attacker cannot determine if the secret value is greater than zero or not by monitoring the execution time of the sanity safe method since the timing behaviors for two cases are very similar and hence there is no side channel.
unfortunately this conclusion is wrong!
the sanity safe method shown in figure b does contain a timing side channel vulnerability.
to understand why we need to realize that the source code of sanity safe is not the only factor on its execution time.
the runtime environment itself plays a pivotal role in the program s behavior.
jit induced side channels.
the runtime environment can introduce timing channels into deceptively secure looking programs as it attempts to optimize paths that it deems hot .
just in time jit compilation is performed dynamically based on runtime behavior.
the jit compiler generates optimized native code so that the most commonly executed paths in a program execute as fast as possible.
the result is that the prior input distribution to a program impacts its execution time on new input.
hence if a program is called repeatedly in a way that causes the jit compiler to optimize a particular execution path then calls to the program on unknown input can leak information about what path that input follows.
the profiling data we show in figure b was taken with jitdisabled.
if we enable jit and then execute the sanity safe method with a biased distribution where a 0is highly favored jit compilation will optimize this case.
this leads to more efficient execution time for inputs where a 0and introduces a timing side channel leaking information about whether a 0ora .
we profile again to determine if this hypothesis holds.
figure c shows the execution time distribution for the sanity safe method again for the partitions a 0and a .
we obtained these distributions by enabling jit and repeatedly executing sanity safe with an input distribution heavily favoring values where a .
after this priming stage we timed calls to sanity safe on input 1012jvm fuzzing for jit induced side channel detection icse may seoul republic of korea a a partition cell0.
.
.
.
.
.
.
microseconds a sanity unsafe with jit off a a partition cell14.
.
.
.
.
.
microseconds b sanity safe with jit off a a partition cell010203040 microseconds c sanity safe with jit on figure execution time distributions for the sanity safe and sanity unsafe methods.
ib ib i i fuzzer afl kelinci instrumenter asm i pattern detectorirprimer evaluatorinput generation jvm fuzzing p pinstdependency analyzer figure automated jit induced side channel detection values from different partition cells and created a violin plot of the resulting timing distributions.
we again kept the value of the public input bconstant.
the timing side channel is apparent from the clearly separable distributions for the two partition cells.
currently all side channel analysis detection tools miss this vulnerability.
this is due to its inception in the runtime behavior and in the biased input distribution provoking the jvm into favoring some program paths.
currently no side channel analysis tool can detect this class of side channel vulnerabilities.
a bias in the input distribution can arise for a variety of reasons.
if an attacker can call a method repeatedly then the attacker can force the jit compiler to optimize a particular execution path going through a secret dependent branch.
there might also be a natural bias in the input distribution.
for example if it is the case that most users call the sanity safe method with a secret value a or visa versa then a jit induced side channel can arise based on this common behavior.
ultimately the key factor in forcing jit compilation to induce a side channel is bias in the input distribution.
this is a dynamic characteristic and the same program can be fed inputs in a countless variety of ways.
we use the term priming to mean the act of executing a program repeatedly with a certain distribution of program input.
three factors determine a priming strategy the program input used the number of program calls made and the bias in the input distribution.
this huge search space of possible priming strategies calls for a systematic strategy of exploration if we have any hope of automatically detecting a program s vulnerability to jit induced side channels.
automating jit induced side channel detection.
our automated approach consists of two main phases outlined in figure .
thefirst phase is the input generation phase.
this phase has two end goals.
given a program ptaking secret input we first will generate pairs of partition cells ib ib where each cell is a subset of the secret domain.
these pairs of partition cells are candidates of mutually exclusive non empty subsets of the secret domain that may be distinguishable via a jit induced side channel.
in order to generate these partition cells we define six program behavior patterns to identify input partitions potentially prone to side channel vulnerabilities.
we use static dependency analysis to identify secret dependent branches to use in these patterns.
then we create an instrumented version of the program pinst introducing two counters for each branch.
the first counts how many times the branch condition is reached.
the second counts how many times branch condition evaluates to true.
we generate a set of inputs ir runpinston these inputs and collect information for each input based on the branch counter values.
we match these values to predefined behavior patterns which partition irto yield the desired ib ib pairs.
the lower half of the input generation block of figure overviews this generation of ib ib evaluation pairs.
the second goal of the input generation phase is to generate a set of priming inputs i .
values from i are used to prime the jvm to favor certain program paths in an attempt to introduce timing side channels.
we use the grey box fuzzer afl to generate inputs executing different paths through the program.
input values that cover different program paths enable us to search different ways of priming the jvm while searching for a jvm state vulnerable to timing side channels.
the completion of the input generation phase yields a set of priming inputs i and a set of pairs of test partition cells ib ib .
1013icse may seoul republic of korea tegan brennan seemanta saha and tevfik bultan the following jvm fuzzing phase answers the question for any given pair ib ib ib ib of input partition cells does priming the jvm in favor of some input i i result in a timing side channel through which input from ib andib are distinguishable by their execution time?
to answer we systematically explore different priming strategies by iterating over different priming amounts and priming ratios.
we evaluate if we successfully induced a timing side channel by quantifying the information leakage.
input generation below we discuss generation of input partitions and priming inputs.
.
secret dependent branch detection the first step of our approach is to identify secret dependent branches.
a branch is secret dependent if the evaluation of the branch condition depends on the value of a secret program input.
given a program and a set of inputs marked as secret we use static dependency analysis to identify the secret dependent branches.
we used janalyzer an existing static analysis tool to perform this dependency analysis.
janalyzer constructs the system dependence graph sdg for a given program.
a sdg is constructed by first extracting the call graph for the program and the procedure dependence graph pdg for each procedure.
nodes of the pdg are either statements or branch conditions and edges represent dependencies.
a data dependence is a triple d u v calculated using reaching definitions analysis wherevis a variable anddanduare pdg nodes vis defined in node d used in node u there is a path from dtou andvis not redefined in between.
for example for the sanity unsafe procedure shown in figure a one such data dependence triple is argument a if a a .
using sdg and pdgs we do forward dependency analysis from all the marked secret program inputs and identify the program statements and branch conditions dependent on those inputs.
we filter out all other statements keeping only the branch conditions as we are concerned about secret dependent branches only.
in our experiments we observed that using both data and control dependencies introduces too many spurious dependencies.
hence we consider only data dependencies during pdg construction but track both explicit direct data flow using reaching definitions analysis and implicit flows data flows to voccurs inside a branch whose predicate is dependent on secret following .
the end result is a set of secret dependent branches.
removing control dependencies leads to unsoundness in the dependency analysis and our side channel detection technique can generate false negatives in the sense that if we are unable to detect a jit induced side channel that does not guarantee that the program is free of jit induced side channels.
on the other hand our side channel detection technique does not generate false positives i.e.
when we do report a jit induced side channel it means that there is demonstrable side channel in the program.
although ignoring control dependencies reduces the number of spurious dependencies data flow analysis can still lead to spurious dependencies.
however since we actually execute the program on input values we generate these will not lead to any false reports of jit induced side channels.
.
pattern detection a timing side channel is present if there are at least two mutually exclusive subsets of the secret domain such that an attacker who is able to observe the execution time of the program can determine which of the two subsets an unknown secret value belongs to under the constraint that the secret does belong to one of the two .
it is not feasible to explore the entire set of possible partitions of the secret domain to look for such subsets and randomly chosen partitions are unlikely to yield meaningful results.
to reduce the space of potential partition choices we observe that timing side channels typically arise due to secret dependent branches whose evaluation leads to an observable difference in the execution time.
we identify six program behavior patterns with respect to branch conditions corresponding to if statements and use these patterns to define partitions of secret input.
matches to these patterns can be detected via instrumentation as we describe later in this section.
one can define more patterns and corresponding partitions however our experiments demonstrate that these six are rich enough to effectively detect jit induced side channel vulnerabilities.
letidenote the set of all inputs for a given program p where given an input i i p i denotes the run that corresponds to executing program pon input i. we use hto denote the secret part of the input and lto denote the non secret public part.
given an input i ito the program we write i l h to denote that the input consists of concatenation of public and secret parts.
given a program p letbpdenote the set of branches in the program and bh bpdenote the set of branches with branch conditions that are dependent on the secret h. for any run p i of the program and any b bp let p i b be the total number of times the branch bis reached during the run p i i.e.
the number of times the condition guarding bis evaluated during the run p i .
let p i b denote the number of times the branch condition for bevaluates to true and p i b denote the number of times the branch condition for bevaluates to false.
note that for all p b and i p i b p i b p i b .
given a set of inputs i our goal is to partition iusing a secretdependent branch b bh.
given a branch b bh we partition i into ib ib andi0where i ib ib i0andib ib andi0 are mutually exclusive.
below we define six patterns we use for obtaining ib ib andi0.
we first consider the following pattern b bhcorresponds to an if statement which is not in a loop or a recursive function and can be reached at most once per each run of the program.
we call thissingle visit sv branch pattern.
for the sv pattern we define ib ib andi0as follows i ib ib p i b .
i ib p i b .
i ib p i b .
ib ib .
i1 i2 ib ib b1 bh bl b1 b p i1 b1 p i2 b1 p i1 b p i2 b .
intuitively this partition divides the set of inputs iinto those that generate runs in which bis reached and the branch condition evaluates to true ib and those that generate runs in which bis reached and branch condition evaluates to false ib subject to the condition that all these runs agree on all other branch condition 1014jvm fuzzing for jit induced side channel detection icse may seoul republic of korea evaluations .
we also require ib andib to be non empty .
all inputs that cannot be put into ib orib are put into i0.
as an example for the sanity unsafe procedure shown in figure a using the sv pattern we obtain the following partition of the input domain ib a a ib a a andi0 ib andib define two subsets of the secret domain whose separability via timing observations we wish to evaluate.
note that multiple partitions can satisfy the above criteria depending on the behavior of the runs that are generated by the inputs in ib and ib regarding other conditional branches.
we can explore different partitions and if we can find one partition in which membership to ib orib can be determined by timing observations then we can conclude that there is a timing side channel.
the requirement that runs generated by inputs in ib andib must agree on all branch condition evaluations barring those on b itself is strong.
it is possible that there might be no such partition cells ib andib .
for example the evaluation of bto true could generate runs that reach a branch condition unreachable should bevaluate to false.
this motivates our single visit relaxed svr branch pattern.
under this pattern ib andib are defined using the same rules for the sv pattern except the rule is modified as i1 i2 ib ib b1 bh bl b1 b p i1 b1 p i2 b1 p i1 b1 p i2 b1 p i1 b p i2 b .
now runs generated from ib andib need only agree on all branch evaluations reached by every run.
through another lens this means that all runs share a common possibly empty prefix and common possibly empty suffix.
in practice we look for partitions that maximize the size of this shared prefix and suffix.
next let us consider a branch b bhcorresponding to an if statement where bis either in a loop or in a recursive function.
hence bmight be reached multiple times.
again there are many ways to partition the input domain based on such a branch condition.
we will focus on four patterns multiple visit all true mvat and multiple visit all false mvaf and the relaxed variants of these two patterns multiple visit all true relaxed mvatr and multiple visit all false relaxed mvafr which we define below.
in the mvat pattern the branch bis visited multiple times.
ib consists of input values that generate runs where every time b is reached the branch condition evaluates to true.
ib consists of input values that generate runs where at least one time when bis reached the branch condition evaluates to false.
we formalize the mvat pattern as follows i ib ib p i b .
i ib p i b p i b .
i ib p i b .
i1 ib i2 ib p i1 b p i2 b .
ib ib .
i1 i2 ib ib b1 bh bl b1 b p i1 b1 p i2 b1 p i1 b p i2 b .
as with the sv pattern we require that ib and ib are nonempty .
we also require that all runs generated from inputs in ib orib reach the branch bsame number of times and agree on all branch condition evaluations other than the ones for the branch b .
all inputs that cannot be put into ib orib due to above constraints are put into i0.in the mvaf pattern the branch bis visited multiple times.
ib consists of input values that generate runs where at least one time when bis reached the branch condition evaluates to true.
ib consists of input values that generate runs where every time b is reached the branch condition evaluates to false.
we formalize the mvaf pattern as i ib ib p i b .
i ib p i b .
i ib p i b p i b .
i1 ib i2 ib p i1 b p i2 b .
ib ib .
i1 i2 ib ib b1 bh bl b1 b p i1 b1 p i2 b1 p i1 b p i2 b .
we also define two more patterns by relaxing the requirements for the mvat and mvaf patterns.
for the mvatr pattern ib and ib are defined as i ib ib p i b .
i ib p i b p i b .
i ib p i b .
ib ib .
i1 i2 ib ib b1 bh bl b1 b p i1 b1 p i2 b1 p i1 b p i2 b .
where the requirement that branch condition bis reached the same number of times across runs generated by input in ib orib is relaxed.
this extends the applicability of the pattern to programs where the choice on condition bmight cause the loop or recursive function containing bto terminate.
similarly we define the mvafr pattern as i ib ib p i b .
i ib p i b .
i ib p i b p i b .
ib ib .
i1 i2 ib ib b1 bh bl b1 b p i1 b1 p i2 b1 p i1 b p i2 b .
in the mvatr and mvafr patterns similar to the the svr pattern the requirement that all runs generated from input in ib orib agree on all branch evaluations bar bitself is relaxed.
we only require agreement on all branch conditions reached the same number of times across the runs.
once again in practice we choose partitions that maximize the number of conditions agreed upon.
.
branch instrumentation given a program pwe use dependency analysis discussed earlier to determine the set of secret dependent branches bh.
then we instrument the program in order to generate sets of inputs based on the patterns above.
given the program pand the secret dependent branches bhwe use java bytecode manipulation and analysis framework asm to generate an instrumented program pinstby introducing two counters i.e.
integer variables for each secret dependent branch b. one counter cbis initialized to and is incremented by one every time program execution reaches b. the other counter cb is initialized to and is incremented by one every time the program execution reaches band the branch condition for bevaluates to true.
the instrumented program pinstprints the values of these counters when the program terminates.
given an input i letpinst i and pinst i denote the values of cbandcb printed by pinstwhen 1015icse may seoul republic of korea tegan brennan seemanta saha and tevfik bultan it is run using input i. then we have the following equivalences p i b pinst i p i b pinst i p i b pinst i pinst i .
next we generate a set of inputs ir iand run pinston each i ir.
we focus on programs where the secret input is either string or numeric and we use built in java functions returning pseudorandom values to build ir.
then we look at the output of each pinstand using the patterns sv mvat and mvaf and their relaxed variants we identify subsets ib irand ib irfor each secret dependent branch bif the outputs generated by pinston irmatch these patterns.
the result of this step is pairs of subsets ib ib ib ib ... one per branch condition.
we denote them as vectors ib ib and use them to search for jit induced side channels during the jvm fuzzing phase.
.
input generation for priming jit induced side channels arise when a bias in the input distribution to a program causes a program path to heat up speeding up its execution relative to other program paths.
to automate the detection of possible side channels arising from jit we generate a set of possible priming inputs i i. the ideal set of priming inputs are values that exercise different program paths.
during jvm fuzzing phase we evaluate each priming input i i to determine its effectiveness at inducing a timing side channel.
we use kelinci an interface to run the grey box fuzzer american fuzzy lop afl on java programs to generate i .
afl is a genetic fuzzer designed to automatically discover interesting test cases that trigger new behaviors in the targeted program.
afl has been widely and successfully used finding hundreds of high impact vulnerabilities and has a large community of active users.
afl is a coverage based fuzzer employing a variety of strategies and heuristics to generate inputs that traverse different paths in the program.
it uses several different techniques such as bit flipping and sequential insertion of known interesting integers to effectively trigger new program behaviors.
afl stores a witness i ifor each new program state found.
we use the complete set of witnesses found upon termination of fuzzing as i .
though there is no guarantee that afl will be able to generate an input for every program path it has low overhead and less limitations in comparison to heavy weight analyses such as symbolic execution making it a better choice for our automated analysis.
jvm fuzzing for side channels our goal is to determine if there is any priming input i i such that priming in favor of i results in a timing side channel allowing an attacker to distinguish ib from ib for any two parition cells of the input domain as defined in section .
priming the jvm.
we provide the pseudocode for our priming procedure in algorithm .
given a certain priming amount n a distribution a priming value i and a set of other input values i i the program pis called ntimes in total.
of those ntimes an fraction of the calls are on the input i .
the rest of the calls are on a randomly chosen input value drawn from i i .
intuitively the ratio exists to model the case where the attacker does not have complete control over the jvm and therefore cannot primeinput n priming amount ratio i i i priming inputs numitersbothsides n n numitersremaining n numitersbothsides fori 1tonumitersbothsides do ifiis odd then callp i else callp random i i end end fori 1tonumitersremaining do callp i end algorithm priming perfectly in favor of i .
the lower the ratio is the less control we assume the attacker has.
we experiment with varied values to explore what percentage of calls to pan attacker needs to control in order to induce a timing side channel.
similarly we vary the value of nto explore the needed amount of priming.
both of these parameters inform under what scenarios an attacker will be able to induce a timing side channel in program p. evaluating jvm vulnerability.
for a given priming of the jvm we wish to evaluate if a timing side channel has been introduced that leaks information about the membership of some secret input ito setsib andib based on the timing of p i .
algorithm outlines this evaluation process.
given the subsets ib andib we first prime the jvm as described above and then time a call to pon a random input idrawn from ib .
we collect a timing distribution for ib by repeating this process ntimes.
various sources of non determinism from system noise to variations in runtime decisions made by the jit compiler affect the time measurements.
the higher the value of n the more robust the statistical profile is to such noise.
we repeat this process to also collect a timing distribution for ib .
given the timing distributions for ib andib we compute the conditional entropy between the membership of iand the timing ofp i after priming the jvm.
from this we report how much information about the membership of iwe can expect to be leaked from a single time measurement.
the membership of iencodes one bit of information.
therefore a value of means full leakage of the membership of iand a value of means no leakage.
parameter exploration for jvm fuzzing.
for each program p we have a set of pairs of input cells ib ib generated as described in section .
we also have a set of priming inputs i generated for the same program using kelinci and afl as described in section .
now we iterate over these parameters in essence fuzzing the jvm in an attempt to find a jvm state vulnerable to a timing side channel.
this process is described in algorithm .
for each i i and pair of input sets ib ib ib ib we evaluate if priming in favor ofi induces a side channel allowing us to learn the membership of an input iin sets ib andib .
the runtime decisions controlling jit compilation are complex meaning that the number of priming iterations and priming distribution can influence whether a timing channel is induced.
therefore we also explore those parameters iterating over a set of potential priming amounts and distributions.
1016jvm fuzzing for jit induced side channel detection icse may seoul republic of korea input n profiling amount n priming amount ratio imore iless priming inputs ib ib profiling test input sets vb vb two empty vectors to store timing profiles fori 1tondo prime n i i i vb .append time p ib random ib start with fresh jvm end fori 1tondo prime n i i i vb .append time p ib random ib start with fresh jvm end computeconditionalentropy vb vb algorithm evaluation input n profiling amount n priming amounts a ratios i priming inputs ib ib profiling test input sets for ib ib ib ib do fori i do forn n do for ado vulnerabilityevaluation n n i i i ib ib end end end end algorithm jvm fuzzing experimental evaluation datasets.
theblazer dataset consists of benchmarks drawn from a combination of challenge programs from the darpa stac program classic examples from the literature and microbenchmarks constructed by the blazer authors.
the benchmarks consist of unsafe programs and their safe variants.
table 3a shows the loc for the safe blazer variants unsafe variants are similar.
four different program analysis tools for automated side channel detection have used this benchmark for evaluation.
blazer themis and coco channel are state of theart static analysis tools for detecting timing side channels in java bytecode.
they each report the vulnerability of the unsafe program variants and the safety of the patched versions.
difffuzz is a dynamic analysis tool for the detection of side channels.
difffuzz catches an overflow bug resulting in a timing side channel in loopandbranch safe and considers that the safety of gpt14 safe is questionable depending on an observability threshold.
otherwise difffuzz agrees with the verdicts of the other tools.
thethemis dataset consists of unsafe programs and their safe variants.
we evaluate on the unsafe programs that contain timing side channels and their safe variants.
table 3b shows the loc for the safe themis variants.
outside of a benchmark from jdk6 the rest are java programs collected from github.
themis coco channel anddifffuzz have all used this benchmark for evaluation agreeing on the safety of all safe variants bar jetty safe where difffuzz detects a subtle side channel.
thedifffuzz dataset consists of unsafe programs with timing side channels and their safe variants used in addition to the blazer andthemis benchmarks to evaluate difffuzz .
table 3c shows the loc for the safe difffuzz variants.
four of these programs and their corresponding safe variants are drawn from the open source project apache ftpserver and the last is from an open sourceauthentication plugin for minecraft servers available on github .
we exclude ibasys from the difffuzz dataset since its secret input is an image.
such complex data structures can be handled by our approach by providing pseudorandom input generators for such domains.
however as previously stated our current implementation focuses on numeric and string secret domains.
hardware setup.
all experiments were run on a computer equipped with an intel i5 6600k cpu at .
ghz and gb of ram running ubuntu linux .
linux .
.
and the java platform standard edition version .
.0 162 from openjdk.
experimental setup.
each program variant comes with a set of inputs marked as secret.
for each safe program variant we first conducted dependency analysis as described in section .
yielding a set of secret dependent branches.
using these branches we generated the instrumented programs per section .
.
we then proceeded to generate random secret input to the instrumented program.
we used our pattern detection scheme described in section .
on the results to generate sets of possible partitions cells.
focusing on programs with numeric or string input values enabled us to write a pseudorandom input generator for each variant.
for the modular exponentiation cases and password comparison functions we placed an upper bound on the bit length of the input integer or length of the input string.
we fixed any public input value arbitrarily.
we began matching with the more strict patterns sv mvat mvaf but if no partitions were found we proceeded to their relaxed variants.
we stopped the process for each applicable pattern as soon as a partition was found.
the end result is a vector of sets ib ib .
we wrote a driver for kelinci to generate the set of priming input values i for each safe variant.
as afl requires a directory of well formed seed input we generated one or two seed inputs per variant.
we allowed kelinci to run on each variant for at most one hour and used the set of witnesses for different program states found as i for the variant.
with the input generation phase complete we performed the jvm fuzzing given in algorithm .
we used a set of priming numbers n and distributions .
.
.
.
.
.
.
to determine the vulnerability of the resulting jvm primed in favor of each i i .
we used a profiling amount of n .
as a baseline we ran each safe variant with jit disabled and gathered timing information for each ib ib pair.
since priming the jvm does not matter in this case we did not explore the parameter space for these runs.
to determine the strength of the resulting timing channel we calculate the entropy of partition cell membership conditioned on timing observation.
the leakage reported is this conditional entropy.
we profile multiple times to gain probability distributions for observed execution times.
as noted by the authors of difffuzz anullpointerexception inunixlogin safe prevents it from being executable.
we fixed the issue by replacing the culprit hash comparison with a dummy comparison.
as discussed by the authors of coco channel some secret dependent conditionals such as certain null pointer checks in the themis dataset were manually marked by the themis authors as secret independent.
we ignored the same set of secret dependent branches in order to obtain comparable results.
1017icse may seoul republic of korea tegan brennan seemanta saha and tevfik bultan table experimental results for blazer top themis middle and difffuzz bottom safe variants.
pr ogram variantinst.
patternbest leakage limite d leakage leakage w o jit leakage n avg.
time ns leakage n avg.
time ns leakage avg.
time ns ib ib diff ib ib diff ib ib diff array safe sv .
.
.
.
.
loopbranch safe sv .
.
.
.
.
sanity safe sv .
.
.
.
.
straightline safe sv .
.
.
.
.
unixlogin safe mvaf .
.
.
.
.
modpow1 safe mvat .
.
.
.
.
modpow2 safe mvat .
.
.
.
.
pwdequal safe mvaf .
.
.
.
.
pwdequal safe mvat .
.
.
.
.
pwdequal safe sv .
.
.
.
.
k96 safe mvat .
.
.
.
.
gpt14 safe mvat .
.
.
.
.
login safe sv .
.
.
.
.
jetty safe sv .
.
.
.
.
jetty safe mvaf .
.
.
.
.
jetty safe mvat .
.
.
.
.
spring safe sv .
.
.
.
.
tomcat safe svr .
.
.
.
.
pac4j safe svr .
.
.
.
.
apache clear safe sv .
.
.
.
.
apache stringutils safe mvaf .
.
.
.
.
table experimental results for blazer top themis middle and difffuzz bottom unsafe variants.
pr ogram variantinst.
patternbest leakage w orst leakage leakage n avg.
time ns leakage n avg.
time ns ib ib diff ib ib diff array unsafe sv .
.
.
.
loopbranch unsafe sv .
.
.
.
notaint unsafe sv .
.
.
.
sanity unsafe sv .
.
.
.
straightline unsafe sv .
.
.
.
unixlogin unsafe mvaf .
.
.
.
modpow1 unsafe mvat .
.
.
.
modpow2 unsafe mvat .
.
.
.
pwdequal unsafe mvaf .
.
.
.
pwdequal unsafe mvat .
.
.
.
pwdequal unsafe sv .
.
.
.
k96 unsafe mvat .
.
.
.
gpt14 unsafe mvat .
.
.
.
login unsafe sv .
.
.
.
bootauth unsafe mv atr .
.
.
.
bootauth unsafe mvafr .
.
.
.
jdk unsafe mvatr .
.
.
.
jdk unsafe mvafr .
.
.
.
jetty unsafe sv .
.
.
.
jetty unsafe mvafr .
.
.
.
jetty unsafe mvatr .
.
.
.
orientdb unsafe mvatr .
.
.
.
orientdb unsafe mvafr .
.
.
.
picketbox unsafe mvatr .
.
.
.
picketbox unsafe mvafr .
.
.
.
spring unsafe sv .
.
.
.
tomcat unsafe svr .
.
.
.
pac4j unsafe svr .
.
.
.
apache clear unsafe sv .
.
.
.
apache md5 unsafe mvafr .
.
.
.
apache stringutils unsafe mvaf .
.
.
.
authmereloaded unsafe mvafr .
.
.
.
table size of experimental subjects a dataset information for blazer pr ogram variantprogram size loc array safe loopbranch safe nosecret safe sanity safe straightline safe unixlogin safe modpow1 safe modpow2 safe pwdequal safe k96 safe gpt14 safe login safe ?
b dataset information for themis pr ogram variantprogram size loc bootauth safe jdk safe jetty safe orientdb safe picketbox safe spring safe tomcat safe pac4j safe c dataset information for difffuzz pr ogram variantprogram size loc apache clear safe apache md5 safe apache saltedpw safe apache stringutils safe authmreloaded safe ?
1018jvm fuzzing for jit induced side channel detection icse may seoul republic of korea we also evaluated our approach on the unsafe program variants in order to explore how jit can impact timing side channels already present at the source code level.
in most cases the secret dependent branches of the safe variants can be matched to corresponding branchs in their unsafe variants.
hence we evaluate the separability of the same ib ib pairs across the safe and unsafe variants.
this allows us to evaluate the appearance of the same timing side channel across both versions.
likewise we used the same priming input across matching variants.
we note that the public values chosen are not necessarily those which maximize the existing side channel in the unsafe variants.
in fact the ib ib pairs do not even necessarily correspond to the timing channels originally present in the unsafe variant.
the experiments on the unsafe versions are not aimed at finding the strongest side channels but are shown as a comparison for the behavior found in the safe variants.
the nosecret safe bootauth safe jdk safe orientdb safe picketbox safe and authmereloaded safe variants have no secret dependent branches and the apache md5 safe andapache salted safe variants have no secret dependent branches where both evaluations of the branch are possible.
therefore we performed our instrumentation and fuzzing technique on their unsafe variants to generate ib ib andi in order to evaluate those programs.
.
experimental results and discussion the results of our experiments on the safe blazer themis and difffuzz variants are given in table .
we report the name of the variant under test and the partition template matched.
we report the highest leakage we observed the parameters priming number and distribution leading to that leakage and the average execution times of the program on input values from the sets ib and ib and the difference between these average execution times.
we report the average execution times to give a sense of the observability of the resulting side channel.
this is a consideration for an attacker with more limited timing capabilities and provides a more refined characterization of the side channel.
blazer themis cocochannel anddifffuzz all report a static variant of the maximal cost difference across program paths what we report is the runtime counterpart which is a more realistic measure for observability.
we additionally report two other scenarios.
first we report the leakage and difference in execution time when jit is disabled.
these results provide a base line and are used to evaluate to what degree jit optimization is responsible for any timing side channels as opposed to secret dependent timing imbalance in the source code.
then we report the maximum leakage and difference in execution time under what we call the limited priming scenario.
in this scenario the number of priming iterations is capped at and the strongest distribution considered is .
.
this scenario gives us a sense of how well an attacker with limited capabilities could leverage jit to induce side channels.
our automated framework was able to induce large timing side channels in all safe program variants in the blazer dataset with the exception of notaint safe .
these results contradict the results reported by four state of the art analysis tools.
we were able to induce large timing side channels in the themis variants jetty safe andspring safe and the difffuzz variants apache clear safe and apache stringutils safe .
we also observed timing side channelsintomcat safe andpac4j safe though we found these side channels to be present though mitigated even when jit is disabled.
the remaining safe themis variants along with difffuzz authmereloaded safe and blazer variant notaint safe do not contain any secret dependent branches.
the difffuzz variants apache md5 safe andapache saltedpw safe contain a secret dependent branch but only one evaluation of that branch is satisfiable.
our results are validated at runtime demonstrating the existence of the timing channels.
in many cases the conditional entropy reported is close to meaning that an attacker would be able to deduce the membership of the secret input with almost certainty after one timing observation.
additionally the difference in the average execution time of input from ib and those from ib can be on the order of tens of microseconds even for blazer variants where the largest safe variant has only basic blocks.
there are two scenarios in which no side channel was found in the safe variants when there is no secret dependent branch and when any secret dependent branch always evaluates to the same result.
for password checking functions safe variants were created by replacing secret dependent branches with bit wise manipulation code and hence these safe variants are resilient to jit induced side channels.
our observations point to potential mitigation techniques against jit induced side channels.
our results for the case when jit is disabled confirm that jit compilation is responsible for the timing side channels.
in almost all cases disabling jit eliminates the timing side channel and the information leakage.
in loopbranch safe a small timing channel is reported.
this is consistent with source code level analysis which reports a small imbalance between the relevant program paths.
the small magnitude of this side channel implies that it is not likely to be observable in scenarios where our much larger jitinduced timing channels would be.
a timing side channel is also present in modpow2 safe .
we believe this is because of slightly different multiplication done across the relevant paths which may vary in cost.
similar reasoning explains the timing side channel in apache stringutils safe where a variable cost instruction is likely the cause of the smaller side channel observed.
we believe the side channel in pwdequal safe mvat might be due to cpu level branch prediction.
finally the small side channel reported in login safe is likely due to the small number of samples taken relative to the noise of the program.
as mentioned earlier tomcat safe andpac4j safe both contain side channels even when jit is disabled.
in the case of tomcat safe this is congruous with the observation made by both the themis and coco channel authors that the side channel is mitigated in the safe variant but not removed.
significant non trivial computation is performed in this application and it is possible that the static models used in previous tools did not capture the program cost realistically.
likewise tomcat safe involves error handling code concerning interactions with an external database and it is likely that the static models for these computations were approximate.
our results in the limited priming scenario are also informative.
in all cases except apache string safe the amount of leakage about the membership of the secret input is higher than the scenario when jit is disabled.
in some cases such as jetty safe the resulting timing side channel is significantly smaller than the best priming scenario and only tens of nanoseconds separate the timings of input 1019icse may seoul republic of korea tegan brennan seemanta saha and tevfik bultan i b i b partition cell0510152025 microseconds a array safe under best priming i b i b partition cell0.
.
.
.
.
.
.
.
microseconds b array safe under limited priming i b i b partition cell0.
.
.
.
.
.
microseconds c array safe with jit disabled figure execution time distributions for the array safe variant under the best priming limited priming and without jit.
from the partition cells.
in other cases such as k96 safe however a timing side channel of tens of thousands of nanoseconds separates the timing distributions.
thus even an attacker with more limited capabilities may be able to leverage jit induced side channels.
the results of our experiments on the unsafe blazer themis anddifffuzz variants are given in table .
we do not report results for the apache saltedpw unsafe variant of difffuzz since we do not find any input matching one of our partition patterns.
again we do not aim to find the strongest side channel in the unsafe variant but to evaluate the impact of different priming strategies on the behavior of side channels.
for example our results on bootauth unsafe show that a powerful side channel present in some jvm states all but disappears in others.
in some cases most notably modpow1 unsafe andmodpow2 unsafe no extremely strong side channel is detected.
as mentioned previously the public input values used in these experiments are not guaranteed to be values for which the intended side channel is strong in the unsafe variants.
additionally the programs do differ from their safe variants so a priming strategy successful in inducing a timing side channel in the safe version might not be in the unsafe one.
we believe this explains the lower leakage for some programs.
overall our results on the unsafe variants further demonstrate the significant impact the runtime can have over timing side channels.
coverage of secret dependent branches.
in a few safe variants additional branches were marked as secret dependent.
in both loopbranch safe andlogin safe an additional branch was marked but as in the apache md5 safe andapache saltedpw safe variants the condition associated with the branch could only ever be evaluated one way.
any path with the opposite evaluation is unrealizable.
therefore there are no results reported for these cases.
k96 safe gpt14 safe modpow1 safe modpow2 safe andapache stringutils safe all have a branch condition nested within a loop but we only report results for either the mvat or mvaf pattern.
the other pattern is not applicable as the branch condition must evaluate to true or false in the case of apache stringutils safe at least once.
unixlogin safe also marks a branch condition inside a loop as secret dependent but only the mvaf pattern is evaluated.
neither the input generation responsible for ib ib orafl could find input satisfying the mvaf pattern.
in this case such an input exists but is very specific.
running afl for longer or providing better seed input might enable it to find the input.
evaluation of apache md5 unsafe and authmereloaded unsafe is limited to mvafr for the same reason.
importance of priming input.
table reports the leakage values for the best priming input i per variant.
a more nuancedlook at the experiments is needed to understand the impact of the choice of priming value.
in some cases such as straightline safe all priming input values generated by kelinci were effective at introducing a timing side channel.
this simple program has only one secret dependent branch and the timing side channel is introduced regardless of which of the two program paths is favored.
in other cases such as pwdequal safe mvat only a single priming input effectively introduced a timing side channel.
relation of ib ib to the secret input.
how much danger an attacker being able to separate ib ib poses can be answered in part by considering the size of the ib ib relative to the entire input domain.
in some programs such as straightline safe and array safe ib ib is the entire secret domain for the fixed public input.
in others such as the mvaf pattern of jetty safe ib ib is the entire domain of possible secret input of a fixed length we chose length .
this means that if an attacker is aware that the secret input is of length she will be able to determine the membership of that input.
another part of the answer depends on the relative sizes of ib ib to each other.
in sanity safe for instance the set of possible secret inputs is evenly divided between ib andib .
however in the mvat pattern of jetty safe the only string of length always matching a public string of length is that public string itself.
therefore answering the membership query is equivalent to determining whether or not the secret is a certain exact string.
there are certainly applications where even this is dangerous suppose a branch condition allows you to learn if an anonymous user is in fact a particular celebrity however less information about the secret itself can be learned in this case.
ultimately we demonstrate the existence ofaside channel.
this is the same question that blazer themis coco channel anddifffuzz concern themselves with.
the follow up question of how much information the side channel leaks about the secret itself is left to other analyses.
potential patches.
our results indicate that any jit enabled system is vulnerable to a timing side channel arising from biased input distributions.
one potential patch is to disable jit.
however so critically impacts the performance of the jvm.
for example the execution time of one call to login safe is under nanoseconds with jit optimization and over seconds when jit is disabled.
disabling jit slows this program by a factor of more than times.
such performance loss would render java programs unusable for many applications.
selectively disabling jit only for highly sensitive security critical code would mitigate this performance loss but ultimately results in a trade of between performance and security that needs to be reconciled.
another potential option would be 1020jvm fuzzing for jit induced side channel detection icse may seoul republic of korea replace just in time compilation with ahead of time compilation aot where all optimization and code generation is done before running the program and runtime statistics are not used in optimization decisions.
it is thus likely to be more robust against side channels introduced at runtime and this additional security could be another reason to adopt it for certain security critical methods.
finally our results on variants such as notaint safe motivates replacing secret dependent branches with bit wise manipulation code as a mitigation.
related work jit induced side channels.
the fact that dynamic compilation can introduce side channel vulnerabilities has been noted before .
more recently jit compilation has been shown to be responsible for side channel vulnerabilities in open source java applications that leak information even over the noisy public internet .
our work addresses a hitherto unexplored dimension of jit induced side channels the automation of their detection.
we present a framework for systematically exploring the huge set of possible jvm states and evaluate their vulnerability to side channels.
our focus on automation and the framework we present for automation clearly differentiates our contributions from earlier work on this class of side channels .
we also evaluate our technique on widely used datasets from the literature providing the first evaluation of this new class of side channels on existent datasets.
compiler based mitigation strategies.
compiler based mitigation techniques for side channel vulnerabilities have been considered .
in fact leveraging the statistical profiling information which is the crux of jit induced side channels has been proposed as part of a mitigation strategy .
we believe that integrating these strategies into the jvm has potential as a possible remedy for jit induced side channels though their effectiveness would require investigation.
however at present none of these techniques have been integrated with the most widely used jvm hotspot which remains vulnerable to jit induced side channels.
side channel detection.
a significant body of research has been done in the field of software side channel detection.
blazer performs a grammar based analysis to decompose execution traces into different partitions and then verifies properties of each partition to prove a program s resilience to timing side channels.
themis introduces a variant of cartesian hoare logic concerned with a program s resource usage to generate proofs about the maximal cost difference across program paths.
coco channel performs a compositional analysis generating a symbolic cost expression for each program component and using smt solvers to answer pertinent questions about the maximal cost difference incurred by components.
all three of these static analysis tools are ignorant of any potential impact the runtime might have over a program s execution time.
they only consider the source code of a program under test and as such they are unable to detect jit induced side channels.
difffuzz is a differential fuzzing technique aimed towards finding program executions that maximize a cost difference.
this dynamic tool confirms the safety of the safe blazer variants because like its static counterparts it does not consider the jvm s state during its exploration.
differential analyses are also used to automatically detect vulnerabilities in ssl tls .
other dynamicapproaches to side channel detection analyze the network traffic of web applications in a black box manner .
type based approaches to side channel detection and approaches specific to cache side channels have also been proposed.
currently no static or dynamic approach to side channel detection considers the state of the jvm as a factor in assesing side channels.
other research is aimed towards the quantification of side channel vulnerabilities .
research in this area aims at asking not simply if a program leaks information through a side channel but how much information about the secret is leaked.
these analyses rely on symbolic execution and suffer from poor scalability.
extensions to these approaches to perform attack synthesis on programs vulnerable to side channels have also been explored.
cpu induced side channels.
other classes of side channel attacks such as cache attacks and branch prediction analysis bpa attacks leverage the runtime dependent behavior of cpus.
cache based side channel attacks have been theoretically analyzed for years and have also been demonstrated as very powerful techniques to recover sensitive information in pragmatic scenarios.
side channels can also be introduced into security sensitive code through the branch prediction mechanism of the cpu .
as a result the cpu s branch predictor unit has been exploited in different flavours of timing side channels .
all this work considers the impact of runtime behavior on the processor.
we instead concern ourselves with its impact on the jvm.
jvm testing.
there is prior work on testing jvm implementations .
our work does not look for errors in jvm implementations but rather investigates if and when jit compilation causes timing side channels.
conclusions we demonstrated that timing side channels in software are not a static phenomenon but can be introduced dynamically into programs through biased input distributions.
in particular the justin time jit compilation mechanism which is critical for the performance of java programs can be leveraged to introduce timing channels into programs that do not contain side channel vulnerabilities when jit is disabled.
we have developed and evaluated an automatic technique to fuzz the jvm in order to detect jit induced side channels.
we use this technique to show that the previously safe labeled variants of the well known and studied benchmarks are vulnerable to jit induced timing side channels contradicting the results of four state of the art analysis tools.
we conclude that jit induced side channels are prevalent and the side channel vulnerability detection techniques have to take into account the impact of a program s runtime during side channels analysis.