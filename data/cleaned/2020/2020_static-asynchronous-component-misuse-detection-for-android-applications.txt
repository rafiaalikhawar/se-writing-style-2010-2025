see discussions st ats and author pr ofiles f or this public ation at .researchgate.ne t public ation static asynchronous component misuse detection for android applications conf erence paper no vember .
.
citations 10reads author s including jiwei yan chinese ac ademy of scienc es publica tions citations see profile jian zhang tianjin univ ersity publica tions citations see profile all c ontent f ollo wing this p age was uplo aded b y jiwei yan on june .
the user has r equest ed enhanc ement of the do wnlo aded file.static asynchronous component misuse detection for android applications linjie pan state key lab.
of computer science institute of software cas univ.
of chinese academy of sciences beijing china panlj ios.ac.cnbaoquan cui state key lab.
of computer science institute of software cas univ.
of chinese academy of sciences beijing china baoquan iscas.ac.cnhao liu beijing university of technology beijing china lansedeyu94 live.com jiwei yan tech.
center of softw.
eng institute of software cas univ.
of chinese academy of sciences beijing china yanjw ios.ac.cnsiqi wang state key lab.
of computer science institute of software cas univ.
of chinese academy of sciences beijing china wangsiqi emails.bjut.edu.cnjun yan state key lab.
of computer science institute of software cas univ.
of chinese academy of sciences beijing china yanjun ios.ac.cn jian zhang state key lab.
of computer science institute of software cas univ.
of chinese academy of sciences beijing china zj ios.ac.cn abstract facing the limited resource of smartphones asynchronous programming significantly improves the performance of android applications.
android provides several packaged components to ease the development of asynchronous programming.
among them the asynctask component is widely used by developers since it is easy to implement.
however the abuse of asynctask component can decrease responsiveness and even lead to crashes.
by investigating the android developer documentation and technical forums we summarize five misuse patterns about asynctask.
to detect them we propose a flow context object and field sensitive interprocedural static analysis approach.
specifically the static analysis includes typestate analysis reference analysis and loop analysis.
based on the asynctask related information obtained during static analysis we check the misuse according to predefined detection rules.
the proposed approach is implemented into a tool called asyncchecker.
we evaluate asyncchecker on a self designed benchmark suite called asyncbench and real world apps.
asyncchecker finds corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa association for computing machinery.
acm isbn .
.
.
.
misused asynctask instances in real world apps .
.
the precision recall and f measure of asyncchecker on real world applications are .
.
and .
respectively.
compared with existing tools asyncchecker can detect more asynchronous problems.
we report the misuse problems to developers via github.
several developers have confirmed and fixed the problems found by asyncchecker.
the result implies that our approach is effective and developers do take the misuse of asynctask as a serious problem.
ccs concepts theory of computation program analysis .
keywords android asynctask asynchronous programming static analysis misuse detection acm reference format linjie pan baoquan cui hao liu jiwei yan siqi wang jun yan and jian zhang.
.
static asynchronous component misuse detection for android applications.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
introduction android has long occupied the dominant position in the mobile operating system market.
as of june there are more than .
million available apps in the google play store .
in recent years computation power and memory size of smartphones are 952esec fse november virtual event usa linjie pan baoquan cui hao liu jiwei yan siqi wang jun yan and jian zhang growing rapidly.
however compared with desktop computers resources of smartphones are still limited which always decreases the responsiveness of applications and even leads to bugs .
under limited resources asynchronous programming is a significant technique to keep application responsive.
in asynchronous programming the main thread only accounts for the ui update while time consuming and cpu io blocking tasks are encapsulated into background threads.
in order to simplify asynchronous programming android provides several packaged asynchronous components such as asynctask and intentservice.
among them asynctask is easy to implement and thus widely used by android developers .
in fact asynctask is merely suitable for short operations .
the improper use of asynctask can lead to many problems that can decrease the performance and even lead to the crash of applications.
however many developers still choose asynctask as their first choice because of its convenience.
to solve this problem lin et al.
proposed a methodology to refactor asynctask into intentservice which evades the problems caused by asynctask yet intentservice cannot totally replace asynctask in all cases and developers still prefer to use asynctask.
fan et al.
proposed three rules for async programming and detected async errors based on these rules.
in fact these common rules are not precise enough to instruct the developers to use specific async components such as asynctask.
from these previous works we can find that the misuse of asynctask widely exists in real world applications.
moreover misuses of asynctask can lead to the crash of apps.
currently the research community pays little attention to asynctask and there is a lack of detection on the misuse of asynctask.
therefore it is necessary to carry out a thorough analysis of asynctask.
in this paper we propose and detect five kinds of misuse patterns of asynctask i.e.
strongreference notcancel notterminate earlycancel and repeatstart.
these patterns are summarized from the android documentation and technical forums such as stackoverflow .
these misuse patterns can lead to problems such as memory leak result loss energy waste and wrong semantics.
some of them can even cause the crash of applications.
these patterns are related to code segments defined in both asynctask and activity which makes the detection more difficult.
in accordance with the feature of asynctask we propose a static analysis approach to detect the misuse of asynctask.
considering the characteristics of asynctask we construct the asynctask state transition atst model to depict how the state of an asynctask object an object whose type is asynctask or subclass of asynctask transits in accordance with operations defined in asynctask.
based on the atst model we carry out typestate analysis to detect notcancel earlycancel and repeatstart.
besides we define possess operation to perform reference analysis so that we can identify through which fields an asynctask object holds strong reference to activity.
last but not least we also perform loop analysis to detect notterminate.
in other words we identify loop segments in and determine whether developers check the status of asynctask to jump out of the loop.
to summarize the contributions of this paper are as follows.
.
problem description this paper systematically depicts the misuse problems of asynctask and proposes five misuse patterns .
methodology we provide a flow context and field sensitiveinter procedural static analysis methodology to detect the misuse patterns of asynctask .
tool we have developed asyncchecker a static analysis tool that specializes in detecting misuses of asynctask .
evaluation this paper designs asyncbench an open micro benchmark containing apps as a test suite for asynctask misuse detection.
we have evaluated asyncchecker on both asyncbench and real world apps.
the result shows that the misuses of asynctask widely exist up to .
of the apps .
the tool and benchmarks can be viewed at pangeneral asyncchecker.
background in this section we first perform an empirical study to show how async components are used in real world apps.
then we present a brief introduction to asynctask a widely used async component in android.
at last we show the problem caused by misuse of asynctask via a motivating example.
.
async components in real world apps in order to understand the usage of async components in real world applications we perform an empirical study.
in particular the study tries to answer the following empirical questions eq1 what are usage frequencies of different async components in android applications?
eq2 what are the differences in usage of async components among different repositories?
repository.
in order to answer these questions we built three repositories including apps from f droid an open source app market apps from google play store and apps from wandoujia a chinese commercial app market.
for fdroid we collect all available apps.
for google play store and wandoujia the number of applications is so huge that it is difficult to download all of them.
therefore we downloaded apps under each category of the market.
apps that cannot be decompiled are excluded from repositories.
methodology.
we pay attention to six common async components i.e.
asynctask intentservice handlerthread asynctaskloader threadpoolexecutor and thread.
considering the features of async components our empirical study is based on static analysis which is carried out on soot framework and jimple intermediate representation.
on one hand some of the six kinds of async components mentioned above are abstract classes which cannot be instantiated directly.
technically developers can only instantiate subclasses of an async class.
it is quite reasonable to carry out static analysis so that we can obtain the class inheritance relationships accurately.
on the other hand through soot and jimple we can analyze apps under an exclusive intermediate representation that simplifies the disposal to some language features such as inner class and anonymous class.
besides according to li et al.
soot and jimple are the most adopted basic support tool and format for static analysis of android apps respectively.
results.
table shows the information about six async components in three repositories.
the column class denotes the number of the corresponding async classes the column app denotes the 953static asynchronous component misuse detection for android applications esec fse november virtual event usa number of apps that contain the async classes and the column perc denotes the percentage of apps that contain the async classes.
from the empirical results we can obtain some useful findings.
first asynctask is the most popular async component in all of the three repositories.
thread is nearly as popular as asynctask.
yet thread is not an android specific async component.
considering the popularity of asynctask it is necessary to conduct further study on it.
second the usage of six async components in f droid is much lower than googleplay and wandoujia.
from the results we can see that the difference between open source and commercial apps is obvious.
.
asynctask in android when an application is launched android activates a thread which is called main thread or ui thread to run the application .
if the main thread executes cpu blocking or io blocking tasks then the application will be blocked which may lead to a problem known as application not responding anr .
to avoid unresponsiveness time consuming tasks need to be executed in background threads.
in order to ease asynchronous programming android provides asynctask an encapsulation of the concurrency framework.
with the help of asynctask developers can perform background operations and publish results on the ui thread without direct threads manipulation .
technically asynctask encapsulates the functionality of background operation and interaction with ui thread into five callback methods i.e.
onpreexecute onprogressupdate onpostexecute andoncancelled .
among these methods only runs in the background thread.
it encapsulates tasks that need to be executed in the background thread.
the rest run in the ui thread and take charge of communication between background thread and ui thread.
since asynctask is designed as an abstract class developers cannot instantiate it directly.
instead developers can only instantitate a non abstract subclass of asynctask.
in this paper we use the terminology asynctask class to denote a non abstract subclass of asynctask.
we use asynctask object to denote the object whose type is a subclass of asynctask class.
figure shows the execution sequence of methods defined by asynctask.
to start a background thread developers need to create an instance of asynctask class and then invoke its execute or executeonexecutor method to start a background thread.
after the asynctask is started ui thread first executes onpreexecute then is executed.
while the background thread is running it interacts with ui thread through publishprogress andonprogressupdate .
after finishes onpostexecute is executed to update ui.
note that developers can invoke cancel method to cancel an asynctask.
if cancel method is invoked before finishes then oncancelled instead of onpostexecute will be executed after finishes.
asynctask provides iscancelled method so that developers can check whether cancel is invoked.
main threadbackground thread execute executeonexecutor onpreexecute publishprogress onprogressupdate loopcancel alt oncancelled onpostexecute figure sequence diagram of asynctask .
motivating example in this section we show the typical problem caused by misuse of asynctask via a motivating example.
listing defines two activities main line and dialog line .
we can switch from main to dialog via switchbutton line defined in main activity.
in dialog activity we define a large array line and we can start an asynctask line via clicking the button called asyncbutton line .
in method line we simulate a long running task via thread sleeping operation.
listing problems caused by misuse of asynctask 1class main extends activity protected void oncreate bundle savedinstancestate switchbutton.setonclicklistener new onclicklistener public void onclick view v intent newintent new intent ... startactivity newintent ... class dialog extends activity private tasker currenttask private textview tv private int bytearray new int large array protected void oncreate bundle bundle tv textview findviewbyid r.id.tv asyncbutton button findviewbyid r.id.asyncbutton asyncbutton.setonclicklistener new onclicklistener public void onclick view v currenttask new tasker tv strong reference currenttask.execute ... class tasker extends asynctask string string string private textview referencetv public tasker textview showtv referencetv showtv protected string params thread.sleep return null ... 954esec fse november virtual event usa linjie pan baoquan cui hao liu jiwei yan siqi wang jun yan and jian zhang table the usage frequency of async components in three different repositories async componentsf droid googleplay wandoujia class app perc class app perc class app perc asynctask .
.
.
intentservice .
.
.
handlerthread .
.
.
asynctaskloader .
.
.
threadpoolexecutor .
.
.
thread .
.
.
we can trigger an out of memory oom error through following manipulations first click switchbutton to switch from main to dialog second click asyncbutton to start an asynctask then press back key to switch into main at last click switchbutton and the app will crash.
the crash occurs because the memory of dialog cannot be garbage collected as asynctask holds strong reference to dialog line and line .
when the user clicks switchbutton again allocating memory for a new large array line triggers the oom error.
in other words the misuse of asynctask leads to memory leak which may crash applications.
misuse patterns of asynctask in this section we introduce five misuse patterns of asynctask.
these patterns are related to both functional and performance problems.
.
strongreference if an instance of asynctask class holds strong reference to gui elements of activity when the instance is started then the memory of activity cannot be garbage collected while the instance is running which leads to memory leak and may cause application crash directly.
here the gui element denotes the instance of gui classes i.e.
the subclasses of view .
technically asynctask holds the reference of activity via its fields.
in the following code segment we show an example of strongreference pattern 1public class mainactivity extends activity private textview view1 private asynctask task protected void oncreate bundle bundle super.oncreate bundle view1 textview findviewbyid r.id.view1 task new tasker view1 holding strong reference task.execute protected void ondestroy super.ondestroy task.cancel class tasker extends asynctask private textview view2 public tasker textview view1 view2 view1 ... the instance of asynctask class tasker holds strong reference ofmainactivity via a gui element textview line and line when it is started line .
note that if an asynctask class isa non static inner class belonging to activity then it holds the reference of activity by default.
according to the grammar of java an anonymous inner class must be a non static class.
in other words developers should not define asynctask class as the anonymous inner class of activity.
in order to achieve balance between memory leak and ui update asynctask can hold weak reference of activity which will not cause memory leakage.
the detailed information about weak reference can be viewed at .
.
notcancel the invocation of the ondestroy method leads to the destruction of activity s gui.
if cancel method is not invoked before the destruction of activity then onpostexecute will be executed.
if onposteexecute method contains ui update operation and the gui does not exist any more the invocation of onpostexecute will be meaningless and even crash the applications.
the following code segment shows an example of notcancel which could lead to crash if dialog is dismissed line while the activity has been destroyed.
1public class mainactivity extends activity private progressdialog searchdialog private asynctask task protected void oncreate bundle bundle ... task new tasker searchdialog task.execute not cancel private static class tasker extends asynctask private weakreference progressdialog dialog public tasker progressdialog thedialog dialog thedialog protected void onpostexecute dialog.dismiss potential crash ... to avoid the potential error caused by improper invocation of onpostexecute developers should invoke cancel method of asynctask before the activity is destroyed such that oncancelled instead of onpostexecute is invoked after finishes.
to do so we recommend developers assign the instance of asynctask classes to the field of activity so that they can operate asynctask instances in any callback method of activity including ondestroy .
otherwise we cannot operate asynctask objects which are only assigned to local variables across the different lifecycle methods of activity.
955static asynchronous component misuse detection for android applications esec fse november virtual event usa apkpreprocessingclass hierarchy relationdummymain methodloopanalysistypestateanalysisreferenceanalysisstatic analysisloopidentificationatst modelpartialinter proceduralstrategydetectionmisusepatternsbugreport figure overview of misuse detection for asynctask .
notterminate the invocation of cancel method can avoid improper interaction between background thread asynctask and main thread gui of activity yet it cannot terminate .
in fact it only changes the status of asynctask object.
apparently it is a waste of energy to continue running after cancel is invoked.
in order to save energy developers should terminate the background thread represented by asynctask as soon as possible if it is cancelled.
more specifically developers should check the return value of iscancelled periodically within a loop in and terminate asynctask if iscancelled returns true .
1class tasker extends asynctask protected string arg while ... loop should terminate if cancel is invoked return message .
earlycancel developers can cancel a running asynctask by invoking cancel method.
however if an asynctask instance is cancelled before it is started then onpostexecute will never be executed which is incorrect semantically.
in other words cancel method should be invoked after asynctask is started.
we show an example of earlycancel in the following code segment 1protected void oncreate bundle bundle ... task new tasker task.cancel true task is cancelled before it is started task.execute ... .
repeatstart according to android developer documentation an instance of asynctask can only invoke execute orexecuteonexecutor once.
if a second execution is attempted then an exception will be thrown which means developers should create a new instance of asynctask each time they want to start a background thread.
1class mainactivity extends activity private tasker task protected void oncreate bundle bundle task new tasker ... protected void onstart task.execute task will execute twice if user navigates back ... the above code segment contains a potential repeatstart error.
according to the lifecycle of activity onstart will be invoked again when users navigate back to the activity which means the instance of asynctask pointed to by the variable task will be executed twice.
static misuse detection figure shows an overview of our approach to statically analyze asynctask related misuse patterns.
there are three steps in our approach preprocessing.
the input is an apk file.
during preprocessing we first obtain its class hierarchy relation through apis provided by soot .
then we unify lifecycle callback methods and user defined callback methods into a dummy main method for each activity just as flowdroid does.
static analysis.
after preprocessing we perform flow context object and field sensitive inter procedural static analysis to collect typestate reference and loop information about asynctask.
956esec fse november virtual event usa linjie pan baoquan cui hao liu jiwei yan siqi wang jun yan and jian zhang detection.
at last we detect whether usage of asynctask is correct via predefined detection rules based on the collected information during static analysis.
any code segments containing asynctask misuse will be recorded in bug reports.
partial inter procedural strategy.
the typestate analysis and reference analysis take the dummy main method of activity as the entry method.
apparently most of the operations in an app are asynctask irrelevant.
in order to improve efficiency we need to eliminate irrelevant operations and concentrate on asynctaskrelated ones.
in view of this we only perform inter procedural analysis for methods that contain asynctask related statements i.e.
statements that contain asynctask variables.
due to the feature of polymorphism it is difficult to determine which method is invoked at the non static call site.
in order to keep precision we first generate a list of possible invoked methods based on class hierarchy relation.
then we traverse the statements of these possible invoked methods one by one.
if any of the methods in the list contains asynctask related statements then we take the call site as asynctask related one.
in other words we perform interprocedural analysis at any call site that may be asynctask related.
for call sites that must not be asynctask related we take the invoked method as a library method and do not unfold it.
.
typestate analysis a typestate denotes the state an object can occupy during execution .
as mentioned in section the operations on an asynctask object such as execute andcancel can change its state.
therefore we define the asynctask state transition atst model for asynctask objects based on which those typestate related misuse patterns of asynctask can be easily detected.
definition .
atst model .the atst model is a tuple m q s0 where q initial running canceled wrong is the set of states of asynctask object.
among the four states wrong is abnormal.
if an asynctask object is in wrong state then an error occurs.
s c is the set of operations where sdenotes starting an asynctask via invoking execute orexecuteonexecutor andcrepresents canceling an asynctask via invoking cancel .
q qis the state transition function which is shown in figure .
s0 initial qis the initial state of asynctask object.
during typestate analysis we keep the state of each asynctask object.
whenever a start operation or cancel operation is detected we first determine which asynctask object is under manipulation.
the object sensitivity is achieved through a store based heap model.
specifically we maintain a map from reference variables to asynctask allocation sites when an asynctask object is instantiated via newexpr.
then we transfer the typestate of the asynctask object according to the atst model.
through typestate analysis we can directly check some state related misuse patterns.
besides it is also the foundation for reference analysis.
c s cs running runningwrong wrong canceled canceleds cinitial initialfigure asynctask state transition function .
reference analysis in order to check whether an asynctask object holds strong