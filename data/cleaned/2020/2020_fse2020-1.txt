sinkfinder harvesting hundreds of unknown interesting function pairs with just one seed pan bian bianpan ruc.edu.cn school of information renmin university of china key laboratory of deke renmin university of china beijing chinabin liang liangb ruc.edu.cn school of information renmin university of china key laboratory of deke renmin university of china beijing chinajianjun huang hjj ruc.edu.cn school of information renmin university of china key laboratory of deke renmin university of china beijing china wenchang shi wenchang ruc.edu.cn school of information renmin university of china key laboratory of deke renmin university of china beijing chinaxidong wang wangxidong ruc.edu.cn school of information renmin university of china key laboratory of deke renmin university of china beijing chinajian zhang zj ios.ac.cn state key laboratory of computer science institute of software chinese academy of sciences beijing china abstract mastering the knowledge about security sensitive functions that can potentially result in bugs is valuable to detect them.
however identifying this kind of functions is not a trivial task.
introducing machine learning based techniques to do the task is a natural choice.
unfortunately the approach also requires considerable prior knowledge e.g.
sufficient labelled training samples.
in practice the requirement is often hard to meet.
in this paper to solve the problem we propose a novel and practical method called sinkfinder to automatically discover function pairs that we are interested in which only requires very limited prior knowledge.
sinkfinder first takes just one pair of wellknown interesting functions as the initial seed to infer enough positive and negative training samples by means of sub word word embedding.
by using these samples a support vector machine classifier is trained to identify more interesting function pairs.
finally checkers equipped with the obtained knowledge can be easily developed to detect bugs in target systems.
the experiments demonstrate that sinkfinder can successfully discover hundreds of interesting functions and detect dozens of previously unknown bugs from large scale systems such as linux openssl and postgresql.
ccs concepts software and its engineering automated static analysis .
corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa association for computing machinery.
acm isbn .
.
.
.
interesting function pairs bug detection machine learning word embedding acm reference format pan bian bin liang jianjun huang wenchang shi xidong wang and jian zhang.
.
sinkfinder harvesting hundreds of unknown interesting function pairs with just one seed.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
introduction software bug detection is critical to protect system security and reliability.
to effectively detect certain bugs current methods especially the static ones need to master related bug knowledge in advance .
for many types of bugs the essence of this prior knowledge is which functions can potentially result in the target bugs.
for example only if a static analysis tool knows brelse is a memory deallocation function can it successfully discover the use after free bug shown in .
in practice the security sensitive functions can be manually collected from known secure programming knowledge or dataset such as common weakness enumerations cwe common vulnerability enumerations cve or even usage specifications of public functions.
obviously this requires a great deal of human effort which is tedious and error prone.
worse it is very difficult to manually identify application specific security sensitive functions in a largescale system.
in fact many of them are often less well documented and less well understood by analysts e.g.
the function brelse in the linux kernel.
naturally the machine learning technique was employed to automatically infer security sensitive functions.
the basic idea is to use a training set to train a classifier and then use it to identify whether a given function is security sensitive or not.
for example rasthoferesec fse november virtual event usa pan bian bin liang jianjun huang wenchang shi xidong wang and jian zhang et al.
developed susi to train a support vector machine svm classifier to flag unknown taint sources and sinks in the android framework.
this kind of method has been proven to be effective in inferring unknown security sensitive functions.
susi successfully identified thousands of taint sources or sinks from android framework v4.
which have been used to support practical taint analysis on android applications .
unfortunately this straightforward supervised learning mode requires considerable prior knowledge i.e.
enough labelled training samples.
in fact the training set of susi consists of labeled android framework apis.
this is indeed a great limitation when applying to other large scale systems.
in practice so much prior knowledge is not always available.
for example an analyst who wants to find memory corruption bugs in the linux kernel may only be aware of a very limited number of memory allocation and deallocation functions e.g.
kmalloc and kfree .
it is very difficult if not impossible to train a usable classifier only with a few known positive functions.
the problem may become more serious when facing a less popular target system.
in this paper we propose a method called sinkfinder to solve the above problem.
the basic idea is to employ the unsupervised learning technique and only rely on very limited prior knowledge to automatically discover enough positive and negative samples and then use them to train an effective classifier of interesting function pairs.
we refer to functions that we desire to extract as interesting functions which are often security sensitive ones in bug detection.
considering that many security sensitive functions come in pairs e.g.
kmalloc and kfree we choose to use a pair of known interesting functions as the seed to infer unknown interesting ones.
those functions e.g.
memset that do not pair with certain functions are out of our consideration.
sinkfinder takes just one pair of functions called the seed pair of the target system and its source code as inputs and employs the word embedding technique to infer function pairs that are analogous to the seed pair.
all functions are first embedded in vectors just like vectorizing words in nlp .
as the learned vectors embody semantics of functions the desired unknown interesting function pairs are identified by measuring the semantic distance between their vectors and the given seed vector.
subsequently these identified function pairs are used to train a svm classifier to gain more positive ones that are difficult to be found by analogical reasoning.
finally all discovered positive function pairs are integrated into some static checkers to detect bugs in the target system.
however there are two issues need to be addressed.
first traditional word embedding methods e.g.
word2vec only consider contexts that the word appears but ignore the name of the word.
but for a function its name is also important as well as its calling contexts when encoding its semantics .
second blindly combining all functions into candidate pairs would introduce unacceptable overhead.
there would be n2pairs need to be handled for a target system with nfunctions.
in other words the pairing space will explode with the increase of the number of functions.
in practice a real world large scale system may have hundreds of thousands of functions which would result in a huge pairing space.
we employ sub word word embedding and data mining techniques to address above two issues respectively.
first the state ofthe art word embedding method fasttext is used to vectorizefunctions which can encode sub word level semantics besides interword relationships.
second to reduce the pairing space a specially designed frequent sequence mining algorithm is used to mine candidate pairs of functions that frequently co occur.
we implemented sinkfinder and have evaluated it on the linux kernel.
we select six different well known function pairs as seeds to identify different categories of unknown interesting functions.
with these seed pairs sinkfinder successfully discovers a large number of unknown interesting pairs with an average precision of .
.
for example given security sensitive pairs kmalloc kfree and mutex lock nested mutex unlock sinkfinder automatically discovers pairs of alloc free functions and pairs of lock unlock functions respectively.
in the knowledge of such security sensitive functions we can easily design checkers to detect bugs.
without loss of generality we developed two checkers to detect use after free and mismatched alloc free bugs according to the obtained alloc free functions.
using the two checkers suspects are detected in the linux kernel v4.
.
we have written patches for these suspects and submitted them to the kernel community.
up to now out of them have been confirmed to be real bugs and fixed in latest kernel versions.
the others are waiting for further confirmation.
we believe that the evaluation results are amazing and encouraging considering that all findings are derived from just two well known security sensitive functions.
we also evaluated it on two other large systems openssl and postgresql with different initial seed pairs i.e.
crypto alloc crypto free for openssl and fopen fclose for postgresql.
according to the identified functions four suspects are detected and have been confirmed to be real bugs by the project developers.
this paper makes the following contributions.
novel methodology.
by combining supervised and unsupervised learning techniques sinkfinder can successfully discover unknown application specific security sensitive functions to effectively support bug detection.
as far as we know sinkfinder is the first practical learning based interesting functions extraction method only requiring very limited prior knowledge.
practicable solution.
by introducing sub word word embedding and data mining techniques sufficient training samples are produced and the pairing space is dramatically reduced making sinkfinder applicable to large systems.
encouraging results.
hundreds of security sensitive functions are identified and dozens of confirmed bugs are detected from three real world large scale systems1.
the rest of this paper is organized as follows.
provides the motivating example.
presents the framework of sinkfinder and describes the two checkers.
presents our evaluation result.
after discussing the limitation and possible future works in we review related work in .
finally concludes the paper.
motivating example in this section we use a real use after free uaf bug we found in the linux kernel v4.
to motivate our method.
figure illustrates the simplified code snippets related to the bug.
the function ext2 xattr set calls sb bread to read a specified block from a block device line .
the function sb bread returns the buffer harvesting hundreds of unknown interesting function pairs ... esec fse november virtual event usa file linux v4.
fs ext2 xattr.c 2int ext2 xattr set struct inode inode ... struct super block sb inode i sb ... int not found error char end ... if ext2 i inode i file acl bh sb bread sb ext2 i inode i file acl error eio if !bh goto cleanup ... header hdr bh ... 18cleanup brelse bh only decrements the reference count bh b count if !
bh header hdr bh kfree header up write ext2 i inode xattr sem return error file linux v4.
fs buffer.c 27int try to free buffers struct page page struct address space const mapping page mapping ... spin lock mapping private lock ret drop buffers page buffers to free ... if ret cancel dirty page page spin unlock mapping private lock 37out if buffers to free struct buffer head bh buffers to free do struct buffer head next bh b this page free buffer head bh calls kmem cache free to release bh bh next while bh !
buffers to free return ret thread a thread b race window crash figure a use after free bug in linux kernel.
head of the block on success.
a buffer head is a shared memory with a reference count which records how many objects are using it.
in sb bread the reference count is incremented by .
when it is no longer needed the function brelse should be called to decrement the reference count of the buffer head line .
if the reference count of the buffer head reaches zero it will be released within the function try to free buffers line .
the problem in figure is that the buffer head bhis used again line after its reference count is decremented line .
if another kernel thread is executed to release the buffer head during the window between calling brelse bh and dereferencing bh a use afterfree bug may occur resulting in a system crash or other security impacts.
challenges in previous works.
to detect the bug static analysis methods need to know that the function brelse behaves like a free function .
however brelse is not as well known as other kernel deallocation functions such as kfree .
in fact as far as we know brelse is not configured as a free function in static analysis tools including both commercial ones e.g.
coverity and fortify and open source ones e.g.
coccinelle andk miner .
besides a precise inter procedural analysis does not work because the function brelse just decrements the reference count of the buffer head and there is no explicit execution path to the real point where the buffer head is actually released.
dynamic methods may also find it difficult to detect the bug.
dynamic symbolic execution methods are confronted with the same problem in static methods .
they also need to know the semantics of brelse to simulate the behavior of brelse .
fuzzing methods have to run a very long time before observing the crash due to the small race window and the unknown interactive threads that can result in the bug .
our solution.
an intuitive but effective approach is to automatically identify the semantics of the functions closely related to thebug e.g.
sb bread and brelse .
despite that the two functions may have other purposes they can be viewed as allocation and deallocation functions when detecting memory corruption bugs.
with the knowledge that brelse is a free like function static and dynamic methods can be applied to detect the bug.
as an example we replaced kfree with brelse in a coccinelle s uaf detection rule and the bug was successfully uncovered.
however semantics inference is non trivial.
as discussed in section manual identification for a large scale system is nearly impossible due to lack of documentations.
for example there is no entry describing the semantics of the function brelse in the linux kernel documentations.
besides a typically supervised machine learning method always demands sufficient labeled functions for training an effective classifier while such prior knowledge is usually extremely difficult if not impossible to obtain.
in this paper we propose a two stage method sinkfinder which requires merely a couple of known functions to infer the semantics of the other unknown ones.
the high level idea is to utilize the analogical reasoning ability of modern word embedding techniques with which the semantic relations between functions can be captured by subtraction of function vectors .
we can learn a vector for each function pair and use it to discover semantically similar function pairs.
we will show below how sinkfinder infers the fact that the relationship between sb bread andbrelse is similar to that between kmalloc and kfree .
sinkfinder first discovers pairs that are quite similar or dissimilar to a given interesting function pair in both naming conventions and usage contexts.
for example given kmalloc kfree the pair vmalloc vfree is identified to be similar while lp gpio reg outl is dissimilar.
then sinkfinder discards the preference on function names to discover interesting pairs that look different to the given pair.
specifically the pairs found in the first stage are taken as samples to train a svm classifier with which sinkfinder labelsesec fse november virtual event usa pan bian bin liang jianjun huang wenchang shi xidong wang and jian zhang the rest function pairs.
as a result sb bread brelse is reported analogous to kmalloc kfree .
with this knowledge existing static analyzers could easily report the use after free bug in figure .
our approach .
overview in this section we present sinkfinder an approach to discovering analogous function pairs of a given function pair which is expected but not limited to consist of security sensitive functions.
the given function pair is referred to as the seed pair the function pairs analogous to the seed pair i.e.
pairs that we desire to identify are viewed as positive pairs and all the other pairs that we are not interested in are treated as negative pairs .
as shown in figure sinkfinder works in a two stage schema.
the first stage tries to infer a set of reliable positive pairs as well as a set of reliable negative pairs.
to begin with sinkfinder mines frequent function pairs from the source code .
to enhance the effectiveness as blindly paired functions contain massive but mostly meaningless pairs.
then it extracts function call sequences from the source code and learns vector representations of all functions .
.
according to the findings that the function names also provide an important source to understand the functions semantics we accomplish the function embedding with fasttext to take both the function names and the invocation contexts into account.
at the end sinkfinder performs analogical reasoning to output the positive negative and unlabelled pairs .
.
in the second stage taking the positive and negative function pairs as training samples sinkfinder trains a svm classifier to further identify more positive pairs from the unlabelled ones .
.
to avoid being limited to only acquiring positive function pairs that have similar names as the seed word2vec is used to transform functions to vectors which discards the naming information of functions also done in .
.
as a result sinkfinder can discover the especially semantically similar pairs with the seed e.g.
sb bread brelse for kmalloc kfree .
eventually the interesting functions identified in the second stage can be used for further analysis e.g.
crafting rules for static bug detection targeting on the specific system.
.
mining frequent function pairs as mentioned in .
we mine frequent function pairs from source code of the target system.
the desired pairs identified in .
and .
come from the frequent ones mined in this section.
we are interested in pairs of functions that have strong data flow relationships.
we concentrate on two types of data flow relationships data dependence datadep and data sharing datashare .
within a function definition function gis data dependent on function fif gtakes the output value of fas one of its arguments.
functions g1 andg2have data sharing relationship if they both take the same variable value as their arguments and there is at least one feasible path between them in the control flow graph.
a path is feasible if all conditions on it are satisfiable .
a pair of two functions g1 andg2is denoted as the tuple g1 g2 whereg2is data dependent on or is data sharing with g1.
taking the code snippets in figure as an example.
in the function ext2 xattr set the first argument of brelse at line comesfrom the return value of sb bread called at line .
obviously there is a data dependence relationship between the two functions.
whereas there is a data sharing relationship between drop buffers andcancel dirty page because both of them take the variable page as their first argument in the function try to free buffers .
a function definition is considered to contain a function pair p g1 g2 if it calls both g1andg2 and there is either datadep or datashare relationship between g1andg2.
the number of function definitions that contain a pair pis referred to as the support ofp.
we considerpis frequent if its support is larger than a given threshold min support .
for example throughout linux v4.
there are functions containing the pair p1 sb bread brelse .
assuming the thresholdmin support of p1is a frequent pair.
.
embedding functions mapping functions to vectors can benefit the semantic similarity computation for discovering analogous function pairs see .
.
to capture the semantics of functions we leverage the advanced word embedding techniques in natural language processing to convert functions into continuous vectors.
state of the art word embedding methods attempt to learn a convolutional neural network model that connects a word with its contexts.
the most widely adopted method is word2vec proposed by mikolov et al.
.
the basic idea behind word2vec is that words appearing in similar contexts are similar or closely related in semantics.
thus word2vec attempts to map words with similar contexts to similar vectors.
word2vec ignores the name of words and treats them as distinct ones even if the names are merely slightly different e.g.
kfree v.s.kzfree .
bojanowski et al.
proposed fasttext to encode the sub word information of a word into the resultant vector as well as its contexts .fasttext works similarly to word2vec except that the sub word information is also taken into account during learning vectors.
specifically it first learns a vector for each constituent part of a word called character n grams .
then the word is represented as a sum of the vectors of its n grams.
sinkfinder uses both fasttext andword2vec to learn vector representations for functions.
we refer to the function vectors learned with fasttext asfasttext vectors and those learned with word2vec asword2vec vectors .
a function definition acts as a context of the enclosed function invocations.
sinkfinder performs a random walk on the control flow graph of each function definition intra procedurally.
during the random walk loops are expanded only once and at most random paths are extracted to mitigate the path explosion.
every feasible random path is transformed into a sequence of functions invoked on the path.
then all the sequences generated from the target system are fed to fasttext andword2vec respectively.
each tool returns a vector for each function appearing in the sequences.
we represent the vector of a function fasv f .
the vector of a pairp f g is denoted as v p and computed via the vector subtraction v p v f v g vectorv p embodies possible semantic relationships between f andg such as co occurrences and invocation orders .sinkfinder harvesting hundreds of unknown interesting function pairs ... esec fse november virtual event usa mining a seed pair kmalloc kfree frequent function pairs p desired pairs vmalloc vfree sb bread brelse source code embedding fasttext analogical reasoning embedding word2vec function vectors n ufunction vectors training predicting outputsamples stage reasoning stage classifying source code figure a high level overview of sinkfinder .
.
inferring reliable function pairs given one pair of functions sinkfinder performs an analogical reasoning to infer a set of reliable positive and negative function pairs.
the core idea of analogical reasoning is that two pairs have similar semantics if they are close to each other in the vector space .
the essence of reasoning is to find pairs that are close to the seed pair i.e.
positive pairs as well as those that are far away from the seed pair i.e.
negative pairs .
to achieve a high precision sinkfinder works on the fasttext vectors in this phase such that the names of functions also act as a criterion for identifying semantically similar or dissimilar functions.
to quantitatively evaluate how much a pair is interesting each pairpis associated with a positive confidence denoted by pconf p and a negative confidence denoted by nconf p reflecting how much we believe the pair is in our interest or not respectively.
initially the seed pair is assigned a positive confidence of .
and a negative confidence of .
.
ideally we can take the function pairs with high positive confidence as positive ones and those with low positive confidence as negative ones.
however we confront a challenge of how to determine the boundary of high and low confidence values.
specifying an absolute confidence threshold is not a good idea as it may not work well for all target systems.
we overcome the problem by first screening out a set of reliable negative pairs that are highly dissimilar to the seed pair and then using them as