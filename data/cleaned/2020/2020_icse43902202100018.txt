domain specific fixes for flaky tests with wrong assumptions on underdetermined specifications peilun zhang1 yanjie jiang2 anjiang wei3 victoria stodden1 darko marinov1 august shi4 1university of illinois at urbana champaign usa2beijing institute of technology china 3peking university china 4the university of texas at austin usa email peilunz2 illinois.edu yanjiejiang bit.edu.cn weianjiang pku.edu.cn vcs stodden.net marinov illinois.edu august utexas.edu abstract library developers can provide classes and methods with underdetermined specifications that allow flexibility in future implementations.
library users may write code that relies on a specific implementation rather than on the specification e.g.
assuming mistakenly that the order of elements cannot change in the future.
prior work proposed the nondex approach that detects such wrong assumptions.
we present a novel approach called dexfix to repair wrong assumptions on underdetermined specifications in an automated way.
we run the nondex tool on open source java projects and detect tests that fail due to wrong assumptions.
the majority of failures are from iterating over hashmap hashset collections and the getdeclaredfields method.
we provide several new repair strategies that can fix these violations in both the test code and the main code.
dexfix proposes fixes for tests from the detected tests.
we have already reported fixes for tests as github pull requests have been merged with only rejected and the remaining pending.
i. i ntroduction underdetermined specifications admit multiple implementations.
these different implementations can return different output for the same input even if each implementation itself is deterministic.
for example consider the method getdeclaredfields from the java standard library class java.lang.class .
the javadoc specification for this method states that it returns an array of field objects reflecting all fields declared by the class or interface represented by this class object and also the elements in the returned array are not sorted and are not in any particular order.
library developers sometimes provide methods with such underdetermined specifications to allow flexibility for future implementations.
the latest implementations as of this writing from both oracle jdk and openjdk provide the fields in the order in which they are declared in the class source code but this ordering could change in the future.
if library users write code that relies on a specific deterministic implementation rather than on the underdetermined specification of a method from the library the code can break when the library developers provide a new implementation of the same specification.
for example the java standard library from sun and then oracle has changed the implementation over time of several widely used methods such as object hashcode hashmap and hashset iterators and class getmethods which on several occasions broke substantial amounts of code .shi et al.
developed nondex a technique to find the tests that fail due to making wrong deterministic assumptions on underdetermined specifications.
lam et al.
recently used nondex in a larger study of flaky tests which can fail seemingly nondeterministically .
they reported that of the flaky tests in their dataset are due to such wrong assumptions.
they call these flaky tests implementationdependent id tests we use the same name in this paper.
gyori et al.
provided a nondex plugin for the maven build system to automate running tests with nondex and also provided some partial support for manual debugging by locating one or a few random choice s which they call root causes that can make each test fail.
they wrote in the future we plan to explore automated fixing .
however no automated fixing technique has been developed before.
we present a novel technique called dexfix that can automatically propose fixes for id code.
inspired by the growing body of work on program repair including a survey paper and test repair we provide a set of novel domainspecific and simple but effective!
repair strategies that can fix implementation dependency in both the test code and the main code1.
to the best of our knowledge no existing program or test repair tools can handle these cases.
we first perform a formative study.
we run the nondex tool on open source java projects and detect id tests where nondex provides a specific root cause.
our inspection of these root causes finds that the vast majority are from the hashmap hashset class iterations and the getdeclaredfields method .
we also identify a number of tests that fail due to test assertions comparing json strings the serialization of java objects into json strings can produce json strings with different order of fields the json specification does not specify the order of fields.
we derive new automated repair strategies that can fix the failing tests by changing the code to work properly with underdetermined specifications.
intuitively our strategies aim to make each output deterministic or each test assertion order agnostic.
for example consider some code that calls getdeclaredfields and then a test exercising this code fails 1following maven we use the term main code for what may be called production code or code under test .
ieee acm 43rd international conference on software engineering icse .
ieee because an assertion expects a particular order of elements in the array returned by getdeclaredfields .
one repair strategy is to sort the fields in the array e.g.
by field name.
the order then does not depend on the particular implementation ofgetdeclaredfields .
however the new order may differ from the old order for a specific implementation so some assertions may fail after sorting.
we can then apply a testrepair technique to automatically repair these assertions that now fail when run on a more deterministic implementation.
another repair can be to change the assertions so that they are order agnostic e.g.
treat fields as a set rather than an array.
we automate our strategies by building upon nondex and reassert.
the latter is a tool that can automatically repair failing test assertions .
we derive our strategies from themost common cases that we encounter in the process of inspecting tests detected by nondex.
the effort of adding a new dexfix strategy is usually about a day ifthe support already exists for the right technology e.g.
we did not have initial support for the assertj style of assertions so it took additional work to add that support.
this paper makes several contributions dataset we provide a novel dataset of id tests.
this dataset is the largest for id tests showing the prevalence of this problem among open source projects.
debugging support we extend the existing nondex tool to provide more info for debugging id tests.
repair strategies we derive novel strategies that can help to automatically repair the code exercised by id tests.
our new strategies are complemented by the old reassert strategies for repairing tests .
we automate these strategies by building on top of nondex and reassert.
evaluation we apply the dexfix technique on tests and we find that dexfix can propose fixes for tests.
after dexfix proposes code changes we check that the fix indeed passes with nondex.
inspired by the fixes proposed by dexfix we have opened github pull requests for tests and have been already merged with only rejected and the remaining still pending.
our dataset and links to pull requests submitted from anonymous github accounts are publicly available as a part of a larger dataset of flaky tests .
ii.
b ackground a. detecting id tests following lam et al.
we call a flaky test that fails due to wrong assumptions on underdetermined specifications animplementation dependent id test .
such id tests can be detected proactively by exploring different possible implementations of underdetermined specifications finding one that makes the test fail.
one specific technique and tool that detects id tests due to wrong assumptions on specifications in the java standard library is nondex .
another tool that can detect not only id tests but also more kinds of flaky tests in c code is the mozilla chaos mode .
in this paper we use nondex to detect id tests in java code.nondex detects id tests by randomizing the output of several methods with underdetermined specifications .
nondex is implemented as a maven plugin that can be integrated into any maven based project that runs using java .
nondex also provides a debugging feature invoked through the command mvn nondex debug .
given a detected test that fails for some random seed nondex attempts to find if one random choice location can make the test fail e.g.
a dynamic invocation of getdeclaredfields .
nondex uses binary search across all the random choices executed during the round where the test fails localizing to the one point where a single random choice can make the test fail.
nondex then reports the stack trace of this single point.
b. automatic repair of test assertions test assertions can fail after developers make changes to the main code.
assuming the main code is correct test assertion repair aims to update an assertion to pass when run on that main code e.g.
changing the assertion s expected value with the new actual value produced by running the test on the new main code or even changing the failing assertion to a different kind that more properly captures the proper test behavior.
challenges in test assertion repair involve handling the numerous kinds of test assertions that developers use.
reassert is a technique and tool for repairing test assertions in junit.
given a failing test reassert instruments the code executes the test and records the failure message including the expected and actual values for comparisons.
reassert then applies several repair strategies to repair the assertion so that the test no longer fails.
for example the strategy replaceliteralinassertion works on assertions where the expected value is a literal e.g.
an integer or a string and replaces that literal with the actual value it observes during the test execution .
iii.
e xamples we next discuss several example id tests that nondex detects and for which dexfix proposes a fix.
the examples show a variety of root causes and repair strategies used to change the code.
we introduce these examples in order of perceived simplicity .
a. simple fix in main code apache hadoop is a widely used open source project.
nondex detected several id tests in hadoop which shows that even well tested projects can have problems with underdetermined specifications.
one such id test was testmetricssystemimpl testinitfirstverifycallbacks .
this test passes when run normally but fails with nondex reporting an error message that appears challenging to debug java.lang.assertionerror element formetrics expected metriccounterlong finfo metricsinfoimpl fname c1 description c1 desc g value 1g but was metricgaugelong finfo metricsinfoimpl fname g1 description g1 desc g value 2g g 51fortunately nondex can provide debugging info for each failing test and the prior nondex debugging output provides useful info for this case specifically the root cause java.lang.class.getdeclaredfields class.java org.apache.hadoop.util.reflectionutils.
getdeclaredfieldsincludinginherited reflectionutils.java dexfix has a general automatic strategy that sorts arrays of fields returned by getdeclaredfields which makes the order of the elements in the array deterministic.
based on the nondex output reporting the root cause in the reflectionutils class dexfix proposes the following fix import java.util.arraylist import java.util.arrays import java.util.comparator import java.util.list ... while clazz !
null f for field field clazz.getdeclaredfields f field sortedfields clazz.getdeclaredfields arrays.sort sortedfields new comparator field f publicintcompare field a field b f return a.getname .compareto b.getname g g for field field sortedfields f fields.add field ... rather than introducing its own sorting dexfix uses the java standard library classes arrays andcomparator .
because arrays sort sorts the input array in place and does not return the sorted array dexfix introduces a fresh variable sortedfields sorts the array comparing fields by name and uses sortedfields in the forloop.
after dexfix makes a change we compile and rerun the test with nondex in this case the test passed after the above fix.
we submitted this fix as a github pull request and the developer promptly accepted our fix with the message committing.
we all hate flaky tests.
thanks for this .
b. multiple changes with the same strategy in this example dexfix proposes a fix with multiple changes in both main and test code but all changes follow the same strategy.
in the quarkus project nondex detected several id tests including compilerflagstest defaulting .
when the test failed with nondex it produced an error message that included the following org.opentest4j.assertionfailederror expected compilerflags f b ag but was compilerflags f a bg while the prior debugging output from nondex provides some partial info for this failing test unfortunately it does not provide enough info java.util.hashmap hashiterator hashiteratorshuffler.
init unknown source java.util.hashmap hashiterator.
init hashmap.java we can see that the failure stems from an iteration over a hashmap but the nondex output did not provide the code location that allocated this object and whether it indeed allocated a hashmap orhashset that internally uses hashmap .
we extended nondex to include the allocation location section iv c reporting that the object was a hashset allocated on line of the class compilerflags .
dexfix has another general automated strategy for replacing allocations of hashmap hashset with linkedhashmap linkedhashset .
the linkedhash classes have a precisely defined iteration order hash table and linked list implementation of the mapinterface with predictable iteration order.
and also this implementation spares its clients from the unspecified generally chaotic ordering provided by hashmap .
based on the debugging output from our nondex extension dexfix proposed the following change this.defaultflags defaultflags null ?new hashset new hashset defaultflags this.defaultflags defaultflags null ?new linkedhashset new linkedhashset defaultflags each linkedhash class is a subclass of its respective hash class so the changed code can compile after importing the class with no other changes.
after applying this change and rerunning the test with nondex unlike in the first example where the test passed after the first change this test again failed after the change.
the new failure was again due to iteration over a hashmap and our extension reported that the object was allocated on line of the same class compilerflags .
dexfix proposed a similar fix changing hashset tolinkedhashset on that line but rerunning nondex yet again resulted in a different failure due to iteration over another hashmap this time allocated on line of the class compilerflagstest .
once again dexfix proposed a similar change on that line.
after dexfix changed all these three lines along with adding import statements the test finally passed with nondex.
we submitted this fix and the developer accepted it merged thanks!
.
c. multiple changes with different strategies this example illustrates a case where dexfix proposes a fix that changes both main and test code but uses different strategies.
in the alibaba fastjson project nondex detected several id tests including writeduplicatetype test duptype2 .
as in the previous example the problem was with a hashmap iteration specifically line of writeduplicatetype and dexfix proposed the following change hashmap string object obj new hashmap hashmap string object obj new linkedhashmap after this change the test fails even without nondex indicating that the cause is not an underdetermined specification any more.
in particular this test fails on line of the class writeduplicatetype which compares two strings.
at this point we run reassert to repair the failing assertion.
for these cases of assertequals with a string literal 52reassert replaces the expected string with the actual string that the test produces.
specifically reassert generates the following change for the assertion assert.assertequals n typen n idn text1 assert.assertequals n idn n typen text1 these two changes now make the test pass both with and without nondex.
the developers merged our submitted fix .
d. a novel strategy for comparing collections when a test has an assertion that compares some actual collection value against an expected collection whose iteration order is known to be underdetermined we can change the assertion to a more suitable one that is order agnostic.
in the project graylog2 server nondex detected an id test v20161215163900 moveindexsetdefaultconfigtest upgrade .
according to the nondex debugging output this test has a root cause in a third party library where the hashset is initialized.
the assertion that fails in this test is containsexactly an assertion from the assertj library that checks if a collection contains given elements in the given order.
dexfix in this case changes the assertion to another assertj assertion containsexactlyinanyorder that allows any order of elements and is thus order agnostic assertthat ... .containsexactly ... ... assertthat ... .containsexactlyinanyorder ... ... we submitted this fix and the developers merged it yeah that makes sense.
thank you very much .
e. a novel strategy for json strings our final example is a case where dexfix proposes a fix just for comparing json strings.
in the project nutz nondex detected several id tests including jsontest test enum .
according to the nondex debugging output this test also has a root cause in getdeclaredfields but in a location that is in a third party library not in the nutz project itself.
however the failed assertion on line of jsontest just compares a json string to an expected value.
as such dexfix has a general automatic repair strategy to change such comparisons to use another assertion method jsonassert assertequals from a specific library import static org.junit.assert.assertequals import static org.junit.assert.fail import org.json.jsonexception import org.skyscreamer.jsonassert.jsonassert ... string expected fnn n namen n tn nn n index n 1nn g asserte quals expected json.tojson tt.t former line1031 tryf jsonassert.assertequals expected json.tojson tt.t false gcatch jsonex ception jse f fail not comparingjson strings.
gthe parameter false instructs the assertion to ignore the ordering of fields in the json object making this assertion order agnostic.
the change also requires wrapping the call in a try catch block to fail when the assertion does not compare json strings.
another required change is to modify pom.xml to add the org.skyscreamer.jsonassert .
.
.jar dependency.
because this same jsontest class had four similar failures all detected automatically using nondex we manually extracted all try catch blocks in a helper method called assertjsonequalsnonstrict and replaced calls to assertequals with calls to assertjsonequalsnonstrict .
these changes make all the tests pass both without and with nondex.
the developers merged our submitted fix thank you very much .
iv.
t echnique the input to our technique dexfix conceptually consists of the project source code including the main and test code and an id test to be repaired.
the output of our technique is a fix consisting of one or more code changes that makes the test pass when run with nondex.
inspired by reassert dexfix proceeds by applying various repair strategies on the code and checking if the test passes with nondex.
a. overview figure presents the pseudo code of the dexfix top level repair function that changes a project s codebase.
we did not use this exact pseudo code in our early experiments but over time developed this current pseudo code based on our experience.
specifically repair takes as input the id test to repair.
it first runs nondex to get the initial test result which should be fail the failing assertion areported by junit the root cause creported by nondex e.g.
that the failure is caused by use of hashset as obtained from the nondex debug feature and the code location lreported by our extension of nondex.
dexfix also keeps track of the locations already attempted for fixing lines and in figure .
dexfix first tries to apply the changecontainsexactly strategy section iv b which only changes test code assertions to make them order agnostic.
while the strategy does not introduce any new dependencies to the project it only applies when the project already uses a specific assertion from the assertj library of so called fluent assertions commonly used to supplement standard assertions provided by junit.
we first attempt this strategy that fixes only test code because developers are more likely to consider fixes to test code than fixes to the main code.
furthermore nondeterminism used in the main code is not necessarily incorrect so we believe it is preferable to reduce flakiness in tests by making the test code agnostic to the nondeterminism.
if the changecontainsexactly strategy does not apply i.e.
the test does not use the relevant assertion dexfix then calls repair location to attempt to repair the code location itself.
if the location is in a library dependency and not in the source code of the project being analyzed then dexfix cannot change the source code at that location but could still 53change the test code later .
if dexfix can change the source code it checks whether the root cause is hashmap hashset orgetdeclaredfields for which it can apply an appropriate strategy section iv b .
if dexfix changes the code it also checks whether the test fails while the change makes the order deterministic the resulting deterministic order may not match the assumed order encoded in the current test assertions.
dexfix then needs to update the failing test assertion by applying the traditional reassert strategies e.g.
as shown in section iii c. if reassert cannot repair the assertion then dexfix stops and reports unrepaired line in figure .
ifrepair location does not repair the test dexfix tries to apply its jsonassertion strategy section iv b .
although this strategy like the changecontainsexactly strategy changes only test code we use this strategy last because it can add new third party dependencies to the project and developers tend to be cautious about adding more dependencies.
after all these changes we need to run the test again with nondex for a configurable number of rounds .
if the test fails with nondex dexfix uses the potentially new failing assertion a root cause c and debug location lto continue the repair process again e.g.
as illustrated in section iii b. if the new debug location has been attempted before line in figure then dexfix stops reporting unrepaired to avoid an infinite loop.
in our experiments we never encountered a previous location showing up again.
by keeping track of all attempted repair locations and not allowing repeats the overall loop eventually stops.
if the test passes with nondex dexfix considers the test repaired and exits the loop.
we then manually inspect the fix to prepare a pull request.
while figure shows how dexfix proposes one fix we can easily adapt it to propose multiple possible fixes so the user can choose the best fix.
b. repair strategies we develop four strategies for dexfix.
changecontainsexactly strategy this strategy changes an assertj assertion that uses containsexactly which can check if a mapor asetcollection contains exactly the expected elements in the given order.
for example the assertion can beassertthat actual .containsexactly expected .
the strategy changes containsexactly tocontainsonly if checking a mapor to containsexactlyinanyorder if checking a set.
these other assertions from assertj check if the collection contains the expected elements in any order.
this strategy changes only test code as illustrated in section iii d. hashtolinkedhash strategy this strategy replaces new hashmap resp.
new hashset with new linkedhashmap resp.
new linkedhashset .
the strategy applies when the root cause is iteration over some hashmap hashset object.
while nondex provided the stack trace at the iteration point it did not provide the stack trace of the allocation until we extend nondex.
this strategy may need to add an appropriate import statement for some class.
this strategy may change both main and test code depending on the location of the allocation.
input output project source code that gets changed input failing test t output status repaired unrepaired 4defrepair t rl repaired locations failing assertion a root cause c debug location l result a c l run nondex t num rounds while result fail iflinrl stop if the location has been tried return unrepaired rl.add l applies apply strategy changecontainsexactly t a if not applies status repair location t a c l ifstatus unrepaired applies apply strategy jsonassertion t a if not applies return unrepaired run nondex again to see if there is more to handle result a c l run nondex t num rounds return repaired defrepair location t a c l iflinlibrary return unrepaired ifcishash apply strategy hashtolinkedhash l elifcisgetdeclaredfields apply strategy sortfields l else return unrepaired ifcompile and run t fail apply strategy reassertstrategies t a ifcompile and run t fail return unrepaired return repaired fig.
.
pseudo code of dexfix repair process sortfields strategy this strategy adds sorting of field arrays returned by the method getdeclaredfields .
the strategy applies when the root cause is the underdetermined order of the elements in such an array.
nondex already provided the stack trace at the point where the method is invoked.
if the method invocation is the only expression in a statement e.g.
fields clazz.getdeclaredfields then adding sorting is easier.
a more challenging case is handling method invocations that appear in more complex expressions e.g.
as illustrated in section iii a. our solution is to use a fresh variable to store the array sort it and finally replace the original invocation with this variable.
this strategy may need to add two appropriate import statements for comparing and sorting.
this strategy may change both main and test code depending on the location of the invocation.
jsonassertion strategy this strategy repairs failing assertions that compare json strings.
if the assertion is junit s assert.assertequals the strategy replaces the call with jsonassert.assertequals from the skyscreamer jsonassert library specifically version .
.
as illustrated in section iii e we call this substrategy jsonassertion j. replacing the method call is conceptually 54easy but there are some additional details.
first it needs to handle the potential jsonexception .
second it needs to provide a value for an additional boolean argument for the new assertion s strict parameter.
setting strict totrue ignores the order of field value pairs in the json string representation but does not ignore the order of elements in a json array.
the json string representation for a hashset is a json array making it necessary to set strict tofalse to ignore the order of elements.
however setting strict tofalse is not ideal because it also allows json strings that contain more elements than expected as long as they contain all the expected elements.
as such jsonassertion jfirst sets strict totrue and if the test still fails then it sets the value to false .
if the failing assertion is from the assertj library this strategy instead changes the assertj assertthat invocation to assertthatjson from the jsonunit library specifically version .
.
we call this substrategy jsonassertion a. unlike jsonassertion jthat replaces the failing assertion method jsonassertion achanges the assertthat invocation that creates an assert object from assertj.
for example consider assertthat actual .isequalto expected while it is the call to isequalto that fails jsonassertion adoes not replace that call but instead changes the entire expression toassertthatjson actual .isequalto expected .
jsonassertion is similar to changecontainsexactly in the sense that both affect only test assertions but jsonassertion requires adding a new third party dependency either jsonassert or jsonunit to the project if not already included.
adding a dependency is sometimes undesirable to developers.
c. implementation for evaluation we implement dexfix through several modifications to the existing nondex and reassert tools along with automated and manual steps to connect everything together as per the overall dexfix process shown in figure .
nondex.
our key modification to nondex is the collection of additional debugging info.
specifically for every allocation of a hashmap hashset object our extension records the stack trace.
when nondex reports the stack trace at the iteration point where it performs its random choice our extension also reports the stack trace at the allocation point of the object being iterated.
our extension then finds the code location from this stack trace by looking for the first stack frame whose source code is in the project being analyzed and not in a library either the standard or third party .
reassert.
our key modifications to reassert are to implement the changecontainsexactly and jsonassertion strategies.
for the jsonassertion jsubstrategy we reuse the prior reassert code for its existing strategy that fixes assertequals calls section iii c .
the prior code already instruments tests to capture the expected and actual values for a string comparison and the test code location that invokes the comparison.
our extension checks whether the strings are likely json strings by the presence of the f characters and whether the expected and actual strings when sorted purely character ordering not considering any of the json format end up equal.
unlikethe existing reassert strategy that just replaces the expected string literal in assertequals our extension has to perform somewhat elaborate changes to replace the invoked method add a new parameter and add a try catch block to handle the case when the actual value is not a json object.
for both changecontainsexactly and jsonassertion a we also need to extend reassert to handle the so called fluent assertion style from assertj which uses assertthat .
daniel et al.
supported related assertions in reassert but for the old junit style of assertthat not for assertj.
we modify reassert to specially capture failures stemming from assertj assertions.
an example assertj assertion is of the form assertthat actual .method expected where the assertthat method wraps the actual value into an assert object which is the receiver for the method e.g.
containsexactly orisequalto the method checks the value inassert against expected .
reassert captures the failure that comes from the method call.
if the captured failure is from containsexactly changecontainsexactly applies and it replaces that containsexactly with containsonly orcontainsexactlyinanyorder .
for jsonassertion a while theisequalto call fails the strategy changes the receiver expression namely change assertthat toassertthatjson .
the prior reassert code parses java files using an old version of the spoon library which does not support most modern java features.
we update the spoon dependency and appropriately modify the reassert code.
however the spoon version that we use still does not support all java features e.g.
lambda expressions .
spoon does have newer versions but they break backwards compatibility and using them would require a substantial rewrite of the existing reassert code.
dexfix.
our key new additions besides nondex and reassert modifications are to implement the hashtolinkedhash and sortfields repair strategies.
we use the javaparser library to parse the input java files main and test code change the code and output it.
the javaparser library supports all latest features of java we analyze java projects when running nondex .
our implementation directly follows the descriptions in section iv b and the examples in section iii.
to support the overall dexfix process presented in figure we had to manually apply some of the steps in our experiments.
while we automated the key repair location function that fixes a location we had to manually apply the steps in the top level repair function that loops calling repair location as long as nondex detects the id test.
we also manually invoke the changecontainsexactly and jsonassertion strategies which themselves automatically change assertions because these two strategies rely on reassert which needs a failing test integrating reassert s instrumentation for capturing failing test assertions and nondex s instrumentation to run a test to trigger a failure is not straightforward.
v. e xperimental setup we first describe how we select projects for our evaluation and how we use nondex to detect id tests within these projects.
we then describe how we use dexfix to propose 55fixes for these detected tests and how we send pull requests based on these proposed fixes.
a. selecting projects and detecting tests with nondex for our evaluation we select open source java projects that use the maven build system because nondex was originally developed to support running tests for maven based projects .
we queried github to find the top java projects by the number of stars then randomly chose projects of the that have a top level pom.xml file used to configure maven.
for each project we use the latest commit as of september and create a separate docker image that has the cloned project including the main and test code installed using mvn install dskiptests and our modified version of nondex.
we build all java code using java .
for each docker image we start a docker container where we run nondex on all tests using mvn nondex nondex .
we configure nondex to run rounds with varying random seeds using the one mode where nondex randomizes the order for each method with an underdetermined specification only once for the first call and then reuses that randomized order for subsequent calls with the same receiver .
we choose the one mode because tests that fail in this mode most likely indicate real problems due to wrong assumptions that developers are motivated to fix.
this mode puts a lower bound on the number of id tests that nondex detects in the full mode nondex could detect even more test failures by randomizing allcalls for methods with underdetermined specifications.
we collect all the tests that pass when run without nondex but fail with nondex randomization.
for each detected id test we run mvn nondex debug to obtain debugging info.
the prior nondex debugging reports a single method call location where nondex random choice leads the test to fail .
when the call iterates over a hashmap hashset our nondex extension also reports the location where that object is allocated section iv c .
nondex debugs by rerunning the test while randomizing only a subset of method calls with underdetermined specifications.
during this process nondex can find that some tests pass or fail even when rerun for the same random seed so we remove such flaky tests.
also the prior nondex debugging occasionally crashes altogether and produces no output so we remove such tests as well.
because these tests have no info about any method call location our extension cannot report where the receiver object for that method is allocated.
these crashes are infrequent and hard to reproduce so we have not debugged them in nondex.
b. fixing tests using dexfix and opening pull requests for each id test we start a new docker container based on the docker image for the test s project.
we copy into this container the corresponding nondex debug file and then run dexfix for the test.
this procedure ensures that dexfix proposes a fix for each test when run on the same code version where nondex detected the test.
an alternative to fix multipletests in the same container would have run a later test on a different code version that contains the fix for a prior test.
when dexfix needs to rerun nondex we configure it to run rounds to check if the test after the applied change can still fail.
if the test fails in any of these rounds dexfix has to use the info collected from the nondex run to propose additional changes to the code section iv a .
this process loops until either dexfix generates a fix or reports that it cannot fully repair the test after potentially making some changes.
we inspect all proposed fixes potentially modifying them to prepare github pull requests to the developers of each project.
the fixes for different tests can contain the same or similar code changes because we use dexfix to fix each test individually on the same code version where nondex detected the test.
if fixes for multiple tests share some changes to the main code or the test code even if they still have separate changes to their test assertions these fixes can be safely combined because they address the same root cause.
moreover all the changes to test assertions need to be combined together along with the changes to the main code otherwise the tests will fail when run without nondex.
some pull requests we send fix multiple tests at once and combine fixes for these related tests with all the fixes sharing the same changes to the main and test code modulo changes to the test assertions.
most pull requests simply fix only one test.
as we prepare a pull request we manually make stylistic changes so that our code patch matches the coding style that the project uses.
for each new project for which we have not yet sent pull requests we send one pull request to that project for review.
while the pull request remains pending we do not send more to not spam developers with pull requests that they may not have time to review.
we send additional pull requests only after developers accept the initial one.
also if a pull request is rejected we do not submit other similar pull requests to that same project.
we describe more of our cases when we do not send pull requests in section vi c. vi.
r esults our evaluation addresses the following research questions rq1 what is the breakdown of the root causes and debug locations for id tests detected by nondex?
rq2 how many tests can dexfix fix and which repair strategies propose the fixes?
rq3 how effective is dexfix at proposing fixes that developers actually accept?
our dataset and pull requests are publicly available .
note that we sent some pull requests before finalizing the pseudo code presented in figure .
our results accumulate our experience from sending pull requests while refining dexfix to create fixes that developers are more likely to accept.
a.rq1 detected tests after we run nondex on projects it detects id tests in projects.
table i lists these projects.
the pid column shows the short id we use for later reference.
the commit column is the git commit sha on which we 56run nondex.
the remaining columns show the breakdown of the root causes and debug locations for test failures.
the hash column is the number of tests due to iteration over a hashmap hashset collection.
the gdf column is the number of tests due to getdeclaredfields .
the rest column shows the remaining tests of which are due to getmethods and the others due to six various causes.
these columns show the one cause from the debugging file that mvn nondex debug outputs on the first run but a test may have multiple root causes section iii b .
the columns under source?
show whether the debug location reported by our nondex extension is in the project s source code or in a library.
the final column shows the total number of id tests detected per project.
while nondex implements random exploration for over methods with underdetermined specifications only a few of them cause most test failures.
the majority of the detected tests fail due to some hashmap hashset out of tests .
the second most common root cause is getdeclaredfields out of tests .
together these two causes lead to of all detected tests.
prior reports from running nondex also found these two causes to be the most common but interestingly the ranking between these two is reversed in our findings compared to prior work.
the difference in ranking is due to the differences in projects and versions but the fact that these two causes remain the most common among detected tests increases confidence that our repair strategies for dexfix can apply broadly for fixing tests detected by nondex.
compared to prior work the number of tests that nondex detects in our experiment tests in out of projects is greater than the previously reported proportion e.g.
shi et al.
detected tests in out of projects.
while we run on some much larger maven projects it could be also that the problem of id tests continues to increase.
in terms of debug locations the majority are in the main and test code rather than in a library.
this ratio also increases confidence that our repair strategies for dexfix could be effective because they mostly work on main and test code.
two strategies changecontainsexactly and jsonassertion can work even if the location is in library code but they apply only in some cases for certain assertions or for json strings .
b.rq2 fixed tests table ii shows statistics about the fixes that dexfix proposes overall for out of tests.
the table shows the breakdown of fixed tests per root cause and the strategy dexfix uses cc for changecontainsexactly l1 lm and la are for hashtolinkedhash corresponding to only one allocation site multiple allocation sites and one allocation site but also updating test assertion s ja for jsonassertion sf for sortfields at only one site we never observe the need to change more than one site and sa for sortfields with some updates of test assertion s .
note that changecontainsexactly and jsonassertion apply to both top root causes.
for the hash cause nearly half the fixes that dexfix proposes use hashtolinkedhash only once out of tests without changing any test assertion .
the tests can stilltable i projects used in the study and breakdown of root causes and their locations for id tests detected by nondex root causes source?
pid project slug on github commit hash gdf rest y n p1 apache flink 23c9b5a p2 alibaba fastjson d4a6271 p3 apache hive 90fa906 p4 graylog2 graylog2 server 87d63f6 p5 apache commons lang 7c32e52 p6 flowable flowable engine 399ab58 p7 apache incubator shard... 038232e p8 dropwizard dropwizard 616ed86 p9 square retrofit 8c93b59 p10 rest assured rest assured d3602d9 p11 alibaba jetcache d280196 p12 apache hadoop 14cd969 p13 graphhopper graphhopper 91f1a89 p14 abel533 mapper p15 apache pulsar 505e08a p16 nutzam nutz 97745dd p17 stanfordnlp corenlp 08f6dca p18 apache avro bfbd2d1 p19 ctripcorp apollo 24062ad p20 liquibase liquibase 31a2256 p21 apache kylin 31ab936 p22 kiegroup optaplanner dff7457 p23 vipshop vjtools 60c743d p24 alluxio alluxio e6d7680 p25 eclipse jetty.project 9cede68 p26 elasticjob elastic job lite b022898 p27 intuit karate 2ca51ac p28 quarkusio quarkus 84128ce p29 querydsl querydsl 2bf234c p30 seata seata d334f85 p31 openfeign feign 744fd72 p32 classgraph classgraph d3b5aeb p33 hs web hsweb framework 9eb96c4 p34 mybatis mybatis 0ca4860 p35 pedrovgs algorithms ed6f8a4 p36 spring cloud spring ... 922590e p37 zhangxd1989 spring ... e3966d7 assert on the same expected values as before but now the values are deterministic and cannot be affected by evolution of the implementation of the library methods in the future.
jsonassertion helps in a number of cases with a total of tests fixed for both causes highlighting that tests often make incorrect assumptions on json serialization.
most of the tests fixed this way are caused by getdeclaredfields in fact jsonassertion fixes the highest number of tests for this cause.
dexfix cannot fix most of these tests with sortfields because the call to getdeclaredfields is in library code.
changecontainsexactly the first strategy that just changes the test code without introducing new dependencies to the project applies to few places fixing only tests all in one project p4.
we note that one test in p8 that we fix using hashtolinkedhash also could have been fixed using changecontainsexactly marked with y under column l1 .
we initially developed hashtolinkedhash first before changecontainsexactly and the developers accepted our fix using hashtolinkedhash.
as such we count the test under hashtolinkedhash.
regardless the number of tests changecontainsexactly fixes is relatively small suggesting that developers tend not to directly assert upon these collections.
table ii also shows whether dexfix changes assertions for 57table ii statistics for tests repaired strategies used per root cause assertion changes repair locations and pull requests hash total gdf total assert.changes repair locations pull requests pid cc l1 lm la ja cc sf sa ja yes no test main both a p r u p1 p2 p3 p4 p5 p6 p7 p8 y3 x3 p10 p11 p12 p13 p14 p16 p18 p20 p21 p23 p28 p29 p30 p31 p34 p35 p36 proposed fixes yes means it does no means it does not.
almost half of the fixes out of involve assertions showing the importance of using reassert.
table ii also shows where the repair locations are only in the test code only in the main code or in both.
we see a variety demonstrating the importance of considering both main and test code.
for repair cost dexfix strategies take relatively little time to change the code because the strategies apply only targeted changes and run each test at most times unlike automated program repair that may explore thousands of changes and run many tests hundreds or thousands of times .
running dexfix on all tests takes under hours an average of 90sec per test ranging from 32sec to 388sec.
c.rq3 pull requests we have sent pull requests for out of tests for which dexfix proposes a fix.
table ii also shows the pull request status for the tests accepted a pending p rejected r or unsubmitted u .
overall developers have accepted pull requests that we submitted for a majority of the fixed tests tests .
this high ratio of accepted pull requests shows the effectiveness of the fixes that dexfix proposes and developers welcome the changes e.g.
recall the messages in section iii.
we have tests whose pull requests are still open on github pending review or final judgment from developers.
overall of the tests in the accepted pull requests across the two root causes of are for hash and of are for gdf.we next discuss tests whose pull requests were rejected or for which we did not send pull requests.
rejected.
we have tests whose pull requests have been rejected across two projects p8 and p13.
for the tests in p8 the developer did not accept our pull request because the fix involves jsonassertion and adds a new dependency on the jsonunit library to the project.
however the developer acknowledged the potential problem with the tests and fixed all these tests in another way through a combination of projectspecific annotations for specifying order and using some sorted maps.
the developer closed this pull request with the message i ve changed the tests accordingly.
thanks for the hint!
.
we mark x on the cell for p8 under r in table ii to indicate that the developer found our report useful.
in the other project p13 the developer rejected the pull request for one test for a similar reason because it adds a new dependency on the jsonassert library .
the developer commented we never had a problem with this test and so i would not want to change it.
especially when we need a big dependency for something small.
based on the feedback from these two projects we see that while jsonassertion effectively changes just the test code when comparing json strings the cost of including a new library dependency is too high for some developers.
for the final rejected pull request in p13 the fix was from hashtolinkedhash but the developers did not provide any feedback before rejecting so we do not know their reason for rejection.
unsubmitted.
we did not submit fixes for tests spread across three projects.
for p1 we have not sent pull requests 58for tests yet because they are quite similar to some initial ones we sent that are still pending review so we do not want to bother developers with additional similar fixes until we get proper feedback from the initial ones.
for p2 we have tests with unsubmitted pull requests.
for of these tests the fixes are similar to an initial pull request we sent.
that initial pull request received positive feedback from developers but has yet to be officially merged into the codebase we plan to send the followup pull requests for these other tests after the merge.
for the remaining tests we ourselves rejected the fixes after our manual inspection.
we believe the developers truly want to use a hashmap no deterministic ordering at the location where dexfix proposes to use a linkedhashmap .
in our inspection we find the code has a flag to determine if a linkedhashmap should be used.
this flag does not help to fix the unsubmitted tests.
however we manually change the test code in p2 to set the flag which fixes other tests marked under p in table ii.
finally for p13 of the tests with unsubmitted pull requests tests that dexfix automatically fixes on an older code version on which we started our experiments are no longer id tests in the latest code version.
the remaining tests have fixes very similar to previously rejected ones we sent so we do not send these additional ones.
vii.
d iscussion a. limitations dexfix currently cannot propose a fix for of tests detected by nondex.
we inspected most of these tests at least one unfixed test from each project with some unfixed test s .
some of the cases are limitations of our general repair strategies and some are so rare that they do not merit developing general strategies.
we next show a breakdown of the reasons why dexfix could not fix the tests.
tool engineering .
reassert crashes altogether when run on tests.
also reassert cannot run on tests that use junit or testng as reassert currently supports only junit and junit .
our attempt to upgrade reassert to support junit revealed that it would require a major re implementation effort.
finally our toolset cannot handle source languages beyond java tests are written in scala but nondex can still detect their failures as its instrumentation works at the level of bytecode .
unsupported root cause .
the current dexfix strategies focus on addressing the two top root causes iterating over hashmap hashset and the order of fields returned by getdeclaredfields as reported by prior work and confirmed in our experiments section vi a .
tests fail for other root causes.
the largest number of tests is forgetmethods but they come from only two projects.
we inspect such tests in p6 and they all fail because a class has two methods named equals one declared in the class itself and another inherited .
we could easily build a new strategy to sort these methods by name but it would not be widely applicable.
in fact the project has a comment by convention the implementing class should have one method with the samename .
the remaining test for getmethods is interesting in that its root cause is not just one random choice but two random choices.
the fix would again be overly specialized to this one case.
in the future we believe it worthwhile to develop more strategies only for more general cases.
library location .
only two dexfix strategies changecontainsexactly and jsonassertion can apply if the root cause is in a library i.e.
the source code is not accessible for dexfix to change.
tests have such root causes and the two strategies do not apply because the tests are not using containsexactly or comparing json strings.
others .
finally dexfix cannot handle tests due to one off instances such as creating hashmap through reflection or using java language features in repair locations not handled by our prototype implementation of dexfix strategies.
b. making all code deterministic it is interesting to consider whether the four new strategies that dexfix provides section iv b should be applied inallcases i.e.
should all sets maps be compared using containsexactly should all hash objects be linkedhash should all arrays from getdeclaredfields be sorted and should all json strings be compared with something like jsonassert ?
in the limit should the java standard library have any underdetermined specification?
developers of the java standard library could have specified that hashmap behaves like linkedhashmap even when deterministic iteration is not required.
for example in python all dictionaries since version .
are specified to behave similar to linkedhashmap .
considering that the java standard library has notmade the underdetermined specifications deterministic like python did we believe that underdetermined specifications remain valuable.
we approach fixing of id tests with the goal to first prioritize changing the test code.
our assumption is that the developers are fine with an underdetermined specification and do not require determinism in their main code.
the problem is that the tests are overly specific to the current implementation and would fail if the implementation changes.
thus our strategies first help fix the test code before changing the main code.
we do have strategies that change main code but dexfix attempts them only if it cannot repair only test code without adding dependencies.
ultimately we send fixes to developers so they can decide how to best address the problem.
c. overhead while dexfix aims to make tests no longer implementationdependent the changes could introduce other side effects to the main and test code such as extra execution overhead.
compared to hash linkedhash objects provide a small overhead in both space linkedhash objects need to maintain a list in addition to a hashtable maintained by hash and runtime to manipulate the list for most operations.
however that overhead is negligible for all applications but microbenchmarks and some operations on linkedhash can be even faster including resizing containsvalue and ironically iteration which becomes not only predictable 59but also faster in certain situations.
some java developers still raise concerns about the overhead e.g.
one of our pull requests had a discussion about it but later the developer still accepted the fix.
sorting getdeclaredfields provides an even smaller overhead as a library usually sorts only once and caches for later calls.
in contrast to java python s interface for reflection includes the inspect module s getmembers function that returns a list of members and since python .
is precisely specified return all the members of an object in a list of name value pairs sorted by name.
finally changing containsexactly or using jsonassert affects only the test code not the main code so the overhead is less important but still almost negligible.
viii.
t hreats to validity our overall results may not generalize to all projects.
our evaluation uses a diverse set of popular projects from github and due to our use of existing tooling our evaluation uses java projects that build with maven.
however the projects we use are among the most popular java projects on github so we believe they are fairly representative of all java projects.
our fix strategies may be overfitted towards the id tests we use in our evaluation.
we developed our strategies based on the most common root causes for id tests we found these common root causes match findings in prior work .
we believe the common root causes should still be relevant for id tests in projects beyond those in our dataset so our strategies could still be effective in repairing those id tests.
our implementation of dexfix strategies may have bugs that affect our results.
to reduce this threat we build on top of existing tools nondex reassert and javaparser which have been used in past research.
furthermore multiple authors reviewed some of our new code and discussed the proposed fixes.
the id tests that nondex detected are true positives and we can reproduce the failures from all id tests.
the number of tests detected in our evaluation is a lower bound on the true number of id tests in these projects.
finally the key threat is the quality of the fixes dexfix proposed.
we confirm that these fixes are useful by sending pull requests to developers so they make the final judgment call.
ix.
r elated work mora et al.
proposed the concept of client specific equivalence when two library versions are equivalent with respect to a specific client to study how changes in upstream library code affect downstream clients.
shi et al.
studied when tests fail due to wrong assumptions on underdetermined specifications developing nondex to detect such tests.
our work focuses on automated fixing for such tests by modifying both the main and test code as needed.
the id tests nondex detects can be considered a type of flaky tests which nondeterministically pass or fail on the main code .
luo et al.
reported unordered collections as one reason for flaky tests.
lam et al.
used nondex in a longitudinal study of flaky tests finding 684of the flaky tests in their study to be the id tests that nondex detects.
other prior work focused on detecting different types of flaky tests .
automatic program repair apr aims to automatically generate patches to fix bugs in main code .
apr techniques often generate patches by searching and mutating existing code e.g.
applying pattern based transformations learned from prior fixed bugs or through symbolic execution.
these techniques rely on test failures to indicate that the bug still exists and the aim is to make all tests pass.
dexfix is most similar to patternbased repair which uses transformations inspired by existing bugs.
however these techniques rely on test outcomes to guide them and do not aim to fix the test code.
also their general transformations do not apply to fixing the id tests.
in contrast there is prior work on fixing test code repairing tests that become outdated when main code evolves.
for flaky tests shi et al.
proposed ifixflakies to fix specifically order dependent flaky tests.
our technique dexfix aims to fix id flaky tests.
our approach of fixing id tests is not restricted to changes to the test code but sometimes also involves making changes to the main code.
we utilize reassert to automatically repair assertions that have to be updated after changes are made to the main code.
x. c onclusions and future work we present the dexfix approach for automatically fixing id tests that fail due to wrong assumptions on underdetermined specifications.
dexfix extends the work on program and test repair with novel domain specific and simple yet effective automated repair strategies that can propose fixes for id code.
unlike most prior work that focuses on fixing exclusively either the main code or test code dexfix can fix either or both as necessary.
the empirical results are encouraging of id tests dexfix proposed fixes for tests we have opened pull requests for tests and have already been merged with only rejected and the rest pending.
in the future as more root causes for id tests are found we envision the set of domain specific strategies for these causes growing into a general solution that handles a large fraction of id tests.
we believe domain specific program repair is highly effective at fixing id tests.
we hope dexfix inspires more research into domain specific repair not just for id tests but also for other types of flaky tests and bugs in main code.
xi.
d ata availability our input data and links to pull requests are archived and available .
per email from the open science chair we do not include the git histories of projects used in this paper.