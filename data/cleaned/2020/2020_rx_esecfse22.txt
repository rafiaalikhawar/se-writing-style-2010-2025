cross device record and replay for android apps cong li state key lab for novel software technology and department of computer science and technology nanjing university nanjing china congli smail.nju.edu.cnyanyan jiang state key lab for novel software technology and department of computer science and technology nanjing university nanjing china jyy nju.edu.cnchang xu state key lab for novel software technology and department of computer science and technology nanjing university nanjing china changxu nju.edu.cn abstract cross device replay for android apps is challenging because apps have to adapt or even restructure their guis responsively upon screen size or orientation change across devices.
as a first exploratory work this paper demonstrates that cross device record and replay can be made simple and practical by a one pass greedy algorithm by the rx framework leveraging the least surprise principle in the gui design.
the experimental results of over replay settings encouragingly show that our implemented rx prototype tool effectively solved non trivial cross device replay cases beyond any known non search based work s scope and had still competitive capabilities on same device replay with start of the art techniques.
ccs concepts software and its engineering software maintenance tools application specific development environments .
keywords android app testing record and replay acm reference format cong li yanyan jiang and chang xu.
.
cross device record and replay for android apps.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
introduction record and replay is a trending technology .
in the context of android apps record and replay refers to collecting runtime log and replaying the log on later app runs to reproduce a past app execution .
record and replay for android apps is the foundation of a broad spectrum of testing and debugging technologies failure reproduction regression testing test case minimization to name a few.
the ability of cross environment adaptation is preferred for modern software which is expected to grow with continuous evolution permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
pixel xl 1440x2960 pixel xl 1440x2560 figure the gui layout of google calculator is responsively restructured to adapt to different screen sizes posing challenges to cross device record and replay.
for changable environments .
this paper thereby studies a relevant problem about cross environment adaptation a variant of traditional record and replay for android apps namely cross device record and replay or r r cfor abbreviation where an app execution is replayed on a distinct device of different screen size or orientation.
r r cenables developers to record once and replay everywhere and benefits various testing and debugging practices.
with r r c cross device compatibility test cases only need to be recorded on a single device and regression test cases can be automatically ported to different hardware platforms.
r r cis challenging because an app s gui layout responsively adapts to the screen size and orientation and the restructured gui layout may cause exercising the same action on different devices to require quite different event sequences figure .
to our surprise assuming that each recorded event e s receiver object should present on the replay time gui noknown replay work is sensitive to gui restructuring and well supports cross device record and replay even for the android s default calculator app.
although it is theoretically possible to search for a replay e.g.
via test migration search based approaches are limited in scalability for industrial size apps and practical usage scenarios because state space search incurs costly backtracking and app restarts.
this paper presents the rx replay framework to develop practical r r cimplementations especially for apps with responsive gui restructuring.
the framework also works for apps without any gui restructuring.
specifically this paper treats an app to have 395esec fse november singapore singapore cong li yanyan jiang and chang xu responsive gui restructuring if it follows the responsive ui design principle defined officially .
the framework leverages the least surprise principle in the field of gui design that gui widgets have spatial locality.
specifically functionally related widgets are spatially adjacent in the gui layout and cross device gui adaptation typically obeys a limited set of responsive patterns officially recommended by android documentation .
accordingly to replay an event ewhose receiver widget is not present on the current gui layout the rx framework follows a natural greedy procedure without backtracking or app restart by performing ui segmentation such that spatially adjacent widgets belong to the same segment and matching to identify the replay time correspondence segment of e s receiver object.
for example the button left is matched with the green bar middle in figure .
tentatively applying a list of revertible responsive actions untile s receiver widget appears e.g.
clicking the green bar .
in the case that any reasonable attempt fails the effects can be reverted by executing its pre defined inverse action.
this paper further demonstrates that the rx framework enables practical cross device record and replay even empowered with wellknown heuristics for ui segmentation matching and simple responsive patterns.
the experimental results are encouraging that our prototype implementation can correctly complete cross device replay tasks beyond any known non search and event based replay work s scope with an .
successful rate and still have a competitive same device replay capability with state of the art same device only replay techniques.
in summary this paper s contributions are the first exploratory work to demonstrate that cross device record and replay can be made simple and practical and publicizing the rx prototype tool and supplementary materials to facilitate future research via the rest of this paper is organized as follows.
the cross device record and replay problem is defined and analyzed in section .
the rx record and replay algorithms the framework are described in section .
a simple practical realization of the framework including a prototype implementation and evaluation results are presented in sections and respectively.
finally we discuss related work in section and conclude the paper in section .
problem and insights this section presents the problem of cross device record and replay and our insights to mitigate the challenges.
particularly we present a formulation of our problem in section .
analyze the challenges in section .
and elaborate on our insights in section .
.
.
problem formulation event based record and replay .
this paper s scope is limited to event based record and replay the most practical and widelyadopted replay technique by replaying re a captured sequence of gui or system events on another app execution.
though limited in replaying pixel precise gestures and system i o e.g.
network traffics the lightweight nature of event based record andreplay still makes it a best practice for android app testing and debugging .
in this paper an event eis an object a key value mapping in which obj.field denotes the value of the key field where e.type is the event type e.g.
ui click e.recv denotes the event s associated receiver object an android view1for a gui event or null for a system event e.params contains the event s parameters that can not derive frome.recv e.g.
an input string for ui input events e.context is the event s context object consisting of the timestamp gui layout etc.
to replay a logged event eon a replay device a typical eventbased replay implementation can either deliver the logged lowlevel event coordinates click the same receiver object by matching widget id e.recv.id or conduct semantic aware widget matching based on e.recv.text and e.context.ui .
cross device event based record and replay .
to replay an event sequence on another device existing work widely assumes that any ei s receiverei.recv should exist at the replay time .
unfortunately this assumption breaks for real world r r ccases when an app s gui is responsively restructured to adapt to a device s screen size or orientation.
for example all known replay work failed cross device replaying the calculation of 2 in figure .
figure depicts a more complicated but practical case that inserting a table in microsoft word requires quite different event sequences 4on a phone v.s.
2on a tablet.
.
challenges conceptually r r cis a search problem.
given any replay oracle that can determine replay success e.g.
triggering the same crash manifesting the same gui changes or producing a similar log one can exhaustively try all possible event sequences until an oraclesatisfying one is successfully replayed .
however both the replay oracle and the search are far from trivial in implementing a practical r r c challenge .
replay oracle there lacks an automatic replay oracle for determining cross device replay success for responsive apps that display different gui layouts across devices.
existing replay oracle either targets same device replay or optimistically assumes that an app s gui changes follow limited patterns on distinct devices e.g.
resizing a scrollable list.
such replay oracles insensitive to gui restructuring cannot be adopted to realworld r r cbecause an event possibly has no correspondence on the replay device e.g.
1for microsoft word in figure .
challenge .
search space replaying practical usage scenarios for industrial size apps yields huge search spaces.
although it is theoretically possible to search for a replay e.g.
via test migration search based approaches are limited in scalability for industrial size apps in which a single gui 1view is the basic gui widget in android.
following android we use the term view to replace widget in the following paper.
396cross device record and replay for android apps esec fse november singapore singapore pixel xl phone portrait pixel c tablet landscape scenario step 1scenario step 2scenario step 2scenario step record and replayview segmentmatched segmentsmatched segments figure microsoft word responsively adapts to screens of different sizes.
the event sequences for inserting a table are 4and 2on a phone tablet respectively.
screenshots are cropped such that only a receiver object s adjacent views are displayed.
key events have a correspondence on different devices 3v.s.
1and 4v.s.
.
to replay 2on a phone 1and 2are required to reveal the insert button.
in the reverse replay direction 1and 2have no correspondence on a tablet and thus should be discarded.
layout may contain tens or even hundreds of clickable views.
the attempt to even replay a single event e.g.
1for microsoft word may produce a sub search space of millions of event sequences.
efficient implementation of the search is also challenging because backtracking often requires costly app restarts.
.
observations and insights structure of an event sequence .
an execution to be replayed represents a meaningful usage scenario .
natural observation is that all events in a usage scenario are not created equal there are key events indicating a functionally critical action to be performed while the others are triggering events for exposing key events receiver objects2.
consequently an event sequence can be decomposed into a series of scenario steps each of which ends with a single key event for completing the action preceded by a prefix of triggering events.
for example to insert a table in microsoft word the usage scenario in figure there are two scenario steps activate the insert tab and click the table button.
the key events for them are 3and 4for the phone or 1and 2for the tablet respectively.
replay oracle .
despite that not all event receivers have correspondences on another replay device key events should maintain a mapping between the record and replay devices since a key event denotes a purposed action in a scenario step and should be executed regardless of device.
our replay oracle thus can be defined asthe in order replay of all key events .
nevertheless the definition of key triggering events of a usage scenario is subjective to the concerned developer or app user.
for example a developer may consider 1to be the triggering event for 2while another may consider 1and 2to be different scenario steps.
pragmatically maximizing the successfully replayed events instead of searching for key events is a reasonably well automatic replay oracle.
this is because replaying a triggering event 2such an observation has been exploited in other android related tasks e.g.
benchmarking test case reuse .
whose receiver object exists on both devices is not expected to break the replay procedure.
search space .
instead of an enumerative search we greedily maximize the number of events to be replayed by optimistically assuming that each event e is a key event and attempting small gui perturbations to expose e.recv .
if the attempt to replay efails eshould be a triggering event on the replay device and we should proceed the replay with ebeing dropped.
the validity of such a surprisingly simple greedy algorithm is threefold first well designed apps very likely follow the least surprise principle with the spatial locality of views i.e.
functionally related views are positioned in a visually adjacent block namely a view segment in this paper .
therefore even if a key evente s receiver e.recv is not present on the replay device a human should have no obstacle in identifying e.recv s corresponding view segment on the replay device given the record time gui layout.
red boxes in figure denote our identified segments.
second view segments would pragmatically obey limited responsive patterns a small set of officially recommended ui design rules material design for adapting view segments to different sizes.
each responsive pattern also defines what responsive actions a human should perform when interacting with that segment.
to reveale.recv on the replay device one can attempt to perform any responsive action to e.recv s corresponding view segment.
for example listview is associated with the scrolling action which is useful in finding e.recv on a smaller device.
another example is that 1clicks the android s official more options button with a customized icon by microsoft word .
this is a natural responsive action for revealing a menu for subsequent actions.
focusing only on responsive actions is the key insight to avoid an exhaustive search.
finally even if applying a responsive action e.g.
calling out a menu scrolling a view etc.
fails to reveal e.recv its effects can easily be reverted by performing its inverse action e.g.
closing a menu or scrolling in the reverse direction every responsive action 397esec fse november singapore singapore cong li yanyan jiang and chang xu algorithm the rx replay framework.
underlined functions are implementation customizable.
input an appato be replayed on device d 1function rxreplay foreach evente do r empty sequence repeat s findsegment e ife.recv sthen the receiver object is revealed sendeto d break replay the next event e e findrespaction e s if e then eshould be a triggering event send rto d break revert side effects send eto d r r until true 13function findsegment e 14s segmentui e.context.ui s segmentui d.ui 16m maxweightbipartmatch s s w where ws s similarity s s fors s s s return s swheree.recv sand s s m 18function findrespaction e s forp resppatterns do e e p e s applying a pattern returns a pair of events e e such that e 1reverts e s side effects if e then return e e return should be reversible in a well designed ui.
if trying all responsive actions still cannot reveal e.recv eis considered a triggering event on the replay device and thus discarded yielding our one pass greedy replay algorithm without costly backtracking or app restart.
in figure when replaying 4on a tablet 1and 2are dropped because all attempts to manifest them fail while and 4are successfully replayed by 1and respectively.
when replaying 1on a phone consecutively applying two responsive actions further explained in section .
reveals s receiver object thus 3can be replayed calling out a menu revealing a sibling tab and 2is directly replayed by .
the rx framework the greedy replay framework .
following the previous analyses given a recorded event trace on deviced the rx replay framework algorithm is an online algorithm that can handle a stream of events without backtracking or app restarts as contrast to prior work .
for each event eto be replayed the algorithm tries to reveal e.recv s correspondence on the replay device dand replaye3.
upon failure line the algorithm reverts all responsive actions and proceeds with ebeing discarded.
3this paper s visual notation convention is that denotes s replay time counterpart.algorithm spatial locality guided ui segmentation.
1function segmentui s 2p sl sr sl sr s there exists a horizontal vertical line separating sl sr s l s r arg max sl sr pnaturalness sl sr ifnaturalness s l s r threshold then return s return current segment else return segmentui s l segmentui s r considering that both spatial locality and responsive patterns are design principles from a human perspective rx as an extensible framework leaves the three human related components free customizable which are underlined in algorithm segmentui s for partitioning a given ui s a set of views into disjoint view segments.
views within the same segment should be spatially adjacent and functionally related.
similarity s s for measuring the similarity between segmentsand sin terms of app functionality.
resppatterns is a list of supported responsive actions.
for each pattern pin the list p e s returns an event and its inverse e e for applying and reverting pto s. ifpis not applicable to s e e .
ui segmentation and matching .
to find an event s receiver object on the replay device we first segment both guis e.context.ui and d.ui into view segments by invoking segmentui line lines .
we argue that any non surprising gui design should make e.recv s containing segment sto also appear on d. therefore we attempt to find the global maximum weighted bipartite matching between view segments in the two guis and narrow the scope of our replay to s s s correspondence on d lines .
in case that e.recv finds its equivalent counterpart in s we directly send eto d lines and complete the replay of e. applying responsive patterns .
oncee.recv has no correspondence in s the algorithm applies a sequence of responsive actions to reveale.recv .
sometimes multiple patterns in resppatterns can be applied e.g.
options and tranx are applied when replaying 1on the phone in figure .
we generally recommend that the list of responsive patterns resppatterns can be sorted by the simplicity simpler patterns are closer to the list head such that the algorithm lines automatically returns the simplest pattern following occam s razor line .
the insight is that ui design should be simple without surprising a human and simplest patterns should involve the least perturbation of gui and the least side effects.
the attempt to reveal e.recv may be repeated several times the loop in lines .
each time a responsive action eis performed its inverse e 1is pushed to a stack r line .
if all attempts are failed line eshould be a triggering event on d and events in the stack are popped to revert all side effects of responsive actions line .
the replay proceeds with trying to replay the next event.
sometimes the greediness of the algorithm may cause an unintended event e a triggering event on d but neither key nor 398cross device record and replay for android apps esec fse november singapore singapore table .
list of experience responsive patterns.
rk name precondition r e.recv s e e expand v ss.t.
v.text starts withr.text or r.text starts with v.textclick v click back expand v parent s s.t.
v.text starts with r.text orr.text starts with v.textclick v click back expand v ss.t.
v.desc r.text orr.desc v.textclick v click back scroll r.parent is scrollable and v ss.t.
vis r.parent s counterpartscroll v scroll v options v ss.t.
vis android s official more options buttonclick v click menu v ss.t.
v.desc contains text close open navigation drawer click v click back tranx ris ataband v ss.t.rand vare siblings click v click back tranx v s. v ss.t.vis parent ofr vis atab and visv s counterpartclick v click back pager r.parent is a pager and v ss.t.
vis r.parent s counterpartclick v click back pager v ss.t.
v.parent ispager andris a child of vclick v click back divide s d. v s s.t.
s is anavui with a nested list v and sis afrag uiclick back click v divide l s. v s. v ss.t.v s parentlis a list vis selected and visv s counterpartclick v click back navigate v ss.t.
vis android s official navigation up buttonclick v click v 1responsive patterns rows are listed in the order of simplicity.
a responsive pattern returns e e when its precondition is satisfied otherwise is returned .
patterns correspond to expand reveal transform and divide patterns defined in material design .
patterns also appear in android s fragment documentation .
2 v isv s most semantically related view on d. our implementation selects the view of a maximum similarity with s. triggering on d to be replayed.
such triggering events usually do not cause breaking ui changes and thus replaying them will not likely result in subsequent replay failures.
the greedy nature of the algorithm may also drive the replay to a dead end in which no responsive pattern is applicable and all subsequent events are discarded.
as shown in our evaluation section such failure cases are mainly due to the app not strictly following responsive patterns.
discussions .
there can be alternatives to implement the interfaces segmentui similarity and resppatterns required by the rx framework.
since all the three functions are classifiers related to computer human interaction data driven approach e.g.
statistical learning certainly applies.
however considering that there is no publicly available dataset for the cross device replay task collecting data and training classifiers is generally less relevant to the r r cproblem and data driven approach has its unique challenges e.g.
interpretability hyperparameter tuning and privacy issues for using end user traces we demonstrate the power of rx framework by leveraging wellknown heuristics and simple rules for which all designs can be well explained and justified.
a practical realization of rx we encode android and ui design domain specific knowledge as heuristic algorithms and responsive patterns as our proof ofconcept rx instantiation.
despite being simple the encouragingevaluation results in section confirmed the practical merits of the rx framework.
.
segmentui similarity and resppatterns ui segmentation .
our segmentui algorithm algorithm creates an interpretable ui segmentation following the vips algorithm .
intuitively the algorithm resembles printing out all views inson a paper and conducting the most natural horizontal or vertical cutting off following the intuition that horizontal vertical lines are the most natural way for human beings to separate functional blocks.
we enumerate all possible cut off lines line and find the partition s l s r that best bisects unrelated functionalities line .
such paper cutting is recursively conducted on both parts s lands r line until splitting syields an unnatural bisection of views lines .
the naturalness of a bisection is measured by the function naturalness .
specifically a natural bisection expects that views in the same part are both spatially and functionally close to each other whereas views in different parts are far away from each other.
such close faraway measurements are captured by a set of functions i i n the smaller the closer e.g.
bg v v regardsvandv as close if they have similar background colors.
given iand their weights wi naturalness sl sr measures the bisection s naturalness by a weighted combination naturalness sl sr 1 i nwi i nwi v sl v sr i v v v sr v sr i v v v sl v sl i v v a in which for vandv that are far away from the other splitting them intoslandsrmakes positive contributions to the naturalness while pairing them into slorsrmakes negative contributions.
we explored functions i.e.
i who share the same weight i.e.
in our prototype.
we tuned threshold bycalculator andms outlook and it generalizes well to other subjects in our experiments .
our supplementary material provides more details on how these functions work.
similarity measurement .
we measure the similarity between segmentssand svia the textural information of views.
for each viewv we collect textual descriptions from v.text v.desc v.id and v.hint .
collected texts are pre processed with stop words removed tokenized into words and bagged up as a document.
afterward we calculate the tf idf vectoruand ufors s and s s document respectively.
finally similarity s s is measured by the standard cosine similarity of their corresponding vectors similarity s s u u u u .
responsive patterns .
we investigated the top apps in the google play store and distilled frequently used patterns for gracefully responding to different screen sizes and orientations as listed in table .
each patterns is either defined by material design i.e.
expand reveal divide and transform or explicitly mentioned and recommended by android documentation for user friendly uis.
for example on smaller screens the options 399esec fse november singapore singapore cong li yanyan jiang and chang xu table .
information of evaluated apps app name short category install calculator gc tools .
youtube yt video pla.
edi .
ms todo mst productivity .
ms outlook mso productivity ms word msw productivity adobereader aar productivity .
firefox ff communication doodlemaster dm art design adobesparkpost asp art design zedge zdg personalization collagemaker cm photography .
calm ca health fitness audible adb books ref.
kingjamesbible kjb books ref.
webtoon wt comics .
espn es sports .
discord dc communication udates ud dating .
remind rm education spotify sp music audio .
reddit rd news magazines .
summary first set apps second set apps pattern hides some function related and less important buttons via a more options button while the divide pattern divides a layered ui into multiple layers uis .
readers may refer to our supplementary material for illustrative descriptions of these responsive patterns.
.
the rx prototype tool we implement a prototype named rx which includes the framework section and a complete reference implementation of the algorithms in section .
in lines of typescript and lines of kotlin.
segmentui similarity and resppatterns are implemented as modules and can be flexibly replaced by other implementations.
the rx recorder traces the events by running the app under record in a virtualxposed container which does not require any root access to the android system.
it hooks system level apis e.g.
activity dispatchtouchevent to trace runtime events right before an event is consumed by the app.
the rx replayer depends only on standard android tools ui automator to capture gui layouts and android debugging bridge adb to exercise gui events.
evaluation our evaluation is designed around the following two research questions rq1 to what extent does rx push forward the state of the art of cross device record and replay?
rq2 what is the time and space logging overhead of rx on crossdevice record and replay?
rq3 what are the causes of replay failures for rx?table .
case study results of rx over top commercial apps adopting non trivial responsive patterns id app scenario cross device replay gc simple calc a b a c b c gc advanced calc a b a c b c gc show history a b a c b c gc show fraction a b a c b c gc show his.
fra.
a b a c b c yt explore app a b a c b c yt enable dark theme a b a c b c yt browse trending a b a c b c yt subscribe tbs a b a c b c mst goto categories a b a c b c mst new del.
task a b a c b c mst accom.
task a b a c b c mst edit task a b a c b c mst del.
list a b a c b c mso goto folders a b a c b c mso check email a b a c b c mso don t disturb a b a c b c mso filter email a b a c b c mso mark email a b a c b c msw open doc a b a c b c msw ins.
del.
table a b a c b c msw ren.
doc a b a c b c msw new save doc a b a c b c msw goto settings a b a c b c aar check toup a b a c b c aar open welcome a b a c b c ff nav.
to google a b a c b c ff new privacy tab a b a c b c ff delete browser data a b a c b c ff change site perm.
a b a c b c summary .
.
.
arrow direction indicates a replay success.
for example a cdenotes that a trace record on ais successfully replayed on cbut not vice versa a c denotes that the replay is successful in both directions.
.
methodology experimental subjects .
to answer these two questions we evaluate rx using two sets of top commercial apps from google play store and conduct record and replay on three typical emulated android devices of different screen sizes and densities pixel xl phone a portrait 560dpi pixel xl phone b portrait 560dpi pixel c tablet c landscape 320dpi.
the first set of apps for evaluation first half of table are topdownloaded apps that adopt non trivial responsive patterns whose replay should be sensitive to gui restructuring and is out of the capability of any known available non search based record andreplay technique.
this list contains heavy apps e.g.
ms word and youtube and interesting non trivial apps e.g.
android s official calculator app which adopts a non trivial reveal responsive 400cross device record and replay for android apps esec fse november singapore singapore table .
experimental results of comparing rx with reran and sara id app scenario same device replay cross device replay rx reran sara rx sara dm create new canvas ab c ab c ab c a b a c b c a b a c b c dm rate as like ab c ab c ab c a b a c b c a b a c b c asp goto craft ab c ab c ab c a b a c b c a b a c b c asp switch tabs ab c ab c ab c a b a c b c a b a c b c asp search sea ab c ab c ab c a b a c b c a b a c b c asp create post ab c ab c ab c a b a c b c a b a c b c asp edit post ab c ab c ab c a b a c b c a b a c b c zdg goto feat.
g.i.u ab c ab c ab c a b a c b c a b a c b c zdg goto cate.
tech.
ab c ab c ab c a b a c b c a b a c b c zdg search video w.p.
ab c ab c ab c a b a c b c a b a c b c cm explore shop ab c ab c ab c a b a c b c a b a c b c cm change settings ab c ab c ab c a b a c b c a b a c b c cm make grid ab c ab c ab c a b a c b c a b a c b c cm make f.s.
ab c ab c ab c a b a c b c a b a c b c cm make m.f.
ab c ab c ab c a b a c b c a b a c b c ca random nav.
ab c ab c ab c a b a c b c a b a c b c ca explore home medi.
ab c ab c ab c a b a c b c a b a c b c ca search music love ab c ab c ab c a b a c b c a b a c b c ca change settings ab c ab c ab c a b a c b c a b a c b c adb explore app ab c ab c ab c a b a c b c a b a c b c adb search lovecraft ab c ab c ab c a b a c b c a b a c b c adb filter lovecraft ab c ab c ab c a b a c b c a b a c b c kjb explore app ab c ab c ab c a b a c b c a b a c b c kjb search love ab c ab c ab c a b a c b c a b a c b c kjb edit font settings ab c ab c ab c a b a c b c a b a c b c wt explore app ab c ab c ab c a b a c b c a b a c b c wt choose ori.
sup.
ab c ab c ab c a b a c b c a b a c b c wt sort canvas ab c ab c ab c a b a c b c a b a c b c wt check app ver.
ab c ab c ab c a b a c b c a b a c b c es explore app ab c ab c ab c a b a c b c a b a c b c es search lakers ab c ab c ab c a b a c b c a b a c b c dc explore app ab c ab c ab c a b a c b c a b a c b c dc send message ab c ab c ab c a b a c b c a b a c b c dc check chan.
info ab c ab c ab c a b a c b c a b a c b c dc set status ab c ab c ab c a b a c b c a b a c b c ud explore app ab c ab c ab c a b a c b c a b a c b c ud chat with diane ab c ab c ab c a b a c b c a b a c b c rm explore app ab c ab c ab c a b a c b c a b a c b c rm create class ab c ab c ab c a b a c b c a b a c b c rm edit class ab c ab c ab c a b a c b c a b a c b c sp explore app ab c ab c ab c a b a c b c a b a c b c sp browse hip hop ab c ab c ab c a b a c b c a b a c b c sp search rapcaviar ab c ab c ab c a b a c b c a b a c b c sp cre.
del.
playlist ab c ab c ab c a b a c b c a b a c b c rd explore app ab c ab c ab c a b a c b c a b a c b c rd join typescript leave ab c ab c ab c a b a c b c a b a c b c rd check andr.
comm.
ab c ab c ab c a b a c b c a b a c b c summary .
.
.
.
.
.
.
.
.
for same device replay a colored device icon a b c indicates a replay success and a dotted gray device icon a b c indicates a replay failure.
for cross device replay arrow direction indicates a replay success.
for example a cdenotes that a trace record on ais successfully replayed on cbut not vice versa a cdenotes that the replay is successful in both directions.
401esec fse november singapore singapore cong li yanyan jiang and chang xu pattern .
to the best of our knowledge all known existing r r c techniques including those not evaluated will fail in cross device replaying calculator figure .
the second set of apps for evaluation second half of table are top downloaded apps whose replay falls into existing work s scope.
particularly we select the state of the art open source record and replay tools reran for single device record and replay and sara for both single and cross device record and replay as our comparison baselines4.
to ensure a fair comparison within sara s scope sara only supports the simplest expand responsive pattern we adopted the following filtering process to select the second set of experimental apps top or top apps of each category ranked by appbrains are selected any app that is beyond the expand responsive pattern or incompatible with emulated environments is excluded.
we downloaded these apps from apkcombo and the filtering process yielded apps.
to ensure a fair comparison we also excluded apps that sara failed to parse finally yielding the set of apps for evaluation5.
for each evaluated app we followed existing work to select and create usage scenarios.
particularly we created scenarios for each app that represent its most common functionalities.
we list them in column of table and table .
readers may refer to our website for detailed information on all experimental subjects including detailed descriptions reproduction steps and key events of each usage scenario.
answering rq1 .
the first part of the evaluation concerns whether rx is practically useful in cross device replay .
particularly we conducted a case study and evaluated rx on the usage scenarios of the first apps in table each consisting of six runs a b a c and b c. specifically we record a usage scenario on each device phone or tablet and replay them on the other two.
for this set of apps we did not compare rx with any existing technique because the replay goes beyond the capabilities of them.
we tried to run sara and reran on these cases but they failed for almost every usage scenario.
the second part of the evaluation compares the effectiveness of rx with existing record and replay techniques within their scopes .
this involves two sub cases same device replay in which we record and replay a usage scenario on the same device a b and c over the usage scenarios of the subjects for comparison.
all three techniques reran sara and our rx are evaluated.
cross device replay of the simplest expand responsive pattern which falls into the scope of sara.
in this experiment the same usage scenarios are reused each with six replay settings a b a c and b c. in this r r ccase we only compare rx with sara because reran is designed for same device replay and failed for almost every usage scenario.
4for closed source tools we contacted the authors of randr and v2s for tool binaries but received no response.
we also tried to compare with appetizer which was state of the practice.
unfortunately we have to exclude it because it was extremely unstable and frequently lost events.
5however we also evaluated the excluded apps only on rx and reran and the experimental results are available on our website.
overall rx received a .
and .
successful rate in cross and single device record and replay respectively while reran obtained a .
single device successful rate.following our analysis in section .
we adopt the following oracle to determine the success of cross device replay for both parts of the evaluation objectively all key events are replayed in order subjectively we confirm that the goal of the usage scenario is successfully achieved.
for the same device replay of the second part we follow existing work to determine a replay a success if all events are replayed in order and all visual state transitions meet a human developer s expectation.
answering rq2 .
we collect record replay time statistics and compare them with the original execution without our instrumentation for each rx s successful cross device replay to evaluate the runtime overhead of rx.
we also collect the disk usage of all logs without compression generated by rx to measure the space overhead.
answering rq3 .
we manually inspect failed cases and categorize their root causes.
the detailed analyses can be found in section .
.
experimental environments .
overall the experiments consist of different replay settings technique usage scenario device .
we observed negligible flakiness in the replayed usage scenarios and we consider a replay success if twoconsecutive replays both satisfied the replay oracle.
all experiments were conducted on a quad core intel i7 desktop with 32gib ram running ubuntu .
.
lts with android api .
rx and the two baselines are evaluated under the same emulated hardware software configuration.
.
evaluation results for rq1 effectiveness case study .
table displays the case study results.
this experiment involves usage scenarios with each replayed six runs a b a c and b c yielding replay runs in total.
overall rx succeeded in .
in which .
scenarios succeeded in all six runs.
we would like to emphasize that these usage scenarios are out of any known non search based technique s capabilities.
for example sara attributes its replay failure of calculator resembles a b to breaking ui changes .
however this is a reveal responsive pattern recommended by the android s official guideline.
on the other hand rx succeeded in all five usage scenarios of thecalculator app.
readers may refer to our website for further information including a video of a c areplay for calculator where cross device replaying the event trace consisting of clicks and swipe on ayields a different trace of clicks and swipe to make the replay successful.
same device record and replay .
the same device replay column in table displays the evaluation results.
we compare rx reran and sara using the scenarios in table .
we record and replay each scenario on the same device a b c yielding replay runs for each evaluated technique.
rx succeeded in .
replay runs.
the numbers are .
for reran and .
for sara.
overall rx has a competitive successful replay rate with the pixel precise state of the art same device replay technique reran even though the rx replayer has a much more complex workflow.
402cross device record and replay for android apps esec fse november singapore singapore on the other hand rx is the most stable tool in the evaluation that produces consistent results over devices.
for rx .
of the usage scenarios were successfully replayed on all three devices.
the numbers are .
for reran and .
for sara.
rx has better stability than reran because replaying raw events in reran suffers from minor non deterministic device behaviors e.g.
scrolling has small non determinism across replay runs .
in contrast rx s semantic aware matching mechanism can tolerate such behaviors.
furthermore the analyses in section .
show that the failure cases for app collagemaker are due to missing accessibility information.
it is a surprise that sara failed in so many cases.
sara frequently froze or even crashed at record time due to flushing large amounts of logs6.
the offline self replay of sara also contributed to many replay failures.
the self replay of sara is expected to be a faithful same device replay used to translate raw information e.g.
coordinate to views.
however self replaying a scrolling event may unfaithfully yield different scroll distances due to minor nondeterminism of ui and sara s replay thereby fails if self replay diverges.
rx does not suffer from this because rx grabs the view information when recoding and does not need a self replay phase to translate.
cross device record and replay .
the cross device replay column in table displays the evaluation results.
this experiment is based on the previous usage scenarios created for same device replay.
we excluded reran in this experiment because replaying raw input events on another device of a different screen makes nonsense.
each scenario consists of six runs yielding replay runs in total.
rx succeeded in .
cases in which .
scenarios succeeded in all the six replay runs.
despite that all these usage scenarios have been carefully chosen to fit into sara s scope the numbers for sara are .
and .
resulting from similar failure causes to the same device replay.
.
evaluation results for rq2 overhead the performance evaluation results are summarized as follows and detailed results are available in the supplementary materials the record time logging costs 372ms and 23kib of log without compression per event on average.
this includes the time 300ms to capture guis and space 23kib saving gui s layout dump.
such a cost is required by any gui layout based replay technique .
the replay time ui segmentation responsive pattern matching and responsive action execution cost 411ms on average where applying a responsive action occupies 350ms.
for events whose receiver does not exist at the replay time averagely .
triggering events are additionally performed to expose the key event receiver on the replay device.
6our evaluation was conducted on an android emulated device with hardware virtualization over a mainstream desktop intel i7 processor which is significantly faster than a mobile processor.
therefore the performance issue of sara should be considered an implementation limitation.overall the runtime and space overhead is considered affordable for a human operator replayer indicating that our rx implementation enabled practical r r cuses e.g.
cross device unit testing for an app developer.
compared with existing event based replay tools which are not sensitive to gui restructuring and assume any event e s receiver should exist at the replay time rx pays only .
time overhead and .
additional triggering events to gain the crossdevice replay capability towards gui restructuring.
this result is consistent with the least surprise principle in gui design that a human should be able to find the key event with least gui perturbation.
moreover capturing gui layouts and executing events occupy of the runtime overhead.
this conforms to wang et al.
s study and thereby the performance of rx can be further improved by replacing ui automator with toller.
the average log size of rx is 23kib .3kib per event and 198kib 29kib per usage scenario without with compression .
such a low7space usage is within our expectation because rx s logging is intentionally designed to use as less disk space as possible while record the gui dump of every event.
specifically rx s log maintains a pool to deduplicate strings and views.
each view and view s property in the gui layout is represented by its index in the pool and the gui layout tree is then serialized as a flattened index sequence by the pre order of residing views.
.
evaluation results for rq3 failure cases though largely outperforming existing work rx still failed at out of replays .
including both single and cross device replay cases affecting usage scenarios of apps in tables and .
we analyze them in detail to shed light on future improvements.
the visual convention is that an italic text denotes the cause of a replay failure and underlined numbers denote the case counts.
framework limitations .
.
all event based replay algorithms including rx assume that both record and replay are conducted in a deterministic environment.
however a perfectly deterministic environment simply does not exist.
even though the experiments demonstrated that rx can better handle minor ui nondeterminism than a pixel precise replay mechanism rx produced consistent and stable results over devices in the same device replay experiments apps may contain dynamic contents that change over time e.g.
real time news feeds and result in replay failures.
similar to prior work rx is limited in replaying pixel precise complex gestures e.g.
pinch and network traffic.
considering that both deterministic replay usually for failure reproduction and pixel precise replay are out of the scope of event based replay we believe that the rx framework has wellsupported cross device record and replay.
implementation limitations .
.
rx framework relies on the interfaces segmentui similarity and resppatterns that are implementation specific for performing human related ui understanding.
our current implementation is limited and results in some replay failures.
the most frequent failure cause that affects our segmentui implementation is overlapping views where a horizontal vertical 7should note that our evaluation includes apps that are deemed to have complicated guis e.g.
ms word espn and webtoon .
403esec fse november singapore singapore cong li yanyan jiang and chang xu split cannot yield a correct partition.
in these cases a correct segmentation must cut through at least one view which is strictly prohibited in algorithm .
ourresppatterns are also limited in identifying particular patterns.
for example the pex sl pattern tries a fixed percentage of scrolling offset for a scrollable list.
however sometimes unstable scroll events may cause the replayer to over scroll the list and miss the target event.
other related failure causes include failing to model a pattern and failing to recognize a known pattern .
considering that our tool is designed to be extensible these limitations can be mitigated by either adding new patterns or rewriting existing patterns for adapting to specific apps.
finally our tool implementation has its limitations .
for example rx does not support self rendered apps e.g.
webview and game engine empowered apps by far because ui automator fails to dump them.
app bugs .
.
to our surprise the basic usage scenarios for experimental evaluation even revealed functional bugs in these top commercial apps.
a crash bug is from adobereader usage scenario specific to c causing replay failures which non deterministically hits a null pointer deference in the app s native library libadccomponents.so .
the triggering is nondeterministic potentially due to concurrency issues.
another noncrash bug is from kingjamesbible usage scenario all devices where the view displaying the font of the current text failed to refresh over font changes.
considering that the latter bug did not affect replay we still consider it a replay success in table .
the final major cause of replay failures is app s accessibility bugs because our rx similarity andresppatterns are based on precise accessibility information particularly view s textual descriptions that enable visually impaired people to use the phone with text to speech technologies.
these accessibility bugs can be further classified into incomplete or incorrect accessibility information.
rx cannot conduct correct ui segmentation and responsive pattern recognition on empty accessibility information likecollagemaker .
rx can be erroneously trapped into an unexpected replay state on incorrect accessibility information like ms outlook andremind .
for a similar reason people with vision impairment will suffer from using these apps.
in this sense replay success is expected if similarity andresppatterns do not depend on accessibility information.
we reported the accessibility bug in ms outlook with usage scenario in which close open is labeled in the opposite the only evaluated app that provides an explicit in app bug report mechanism8.
we received positive confirmation from the developers and they claimed a bug fix in version .
.
.
.
discussions rq1 effectiveness and overhead of the rx framework .
overall rx succeeded in of replays .
with affordable overhead.
the evaluation results indicate that rx well handles cross device replay cases over apps that have gui restructuring.
for usage scenarios that are within existing work s scope rx gains 8accessibility bug is a well known source of android app s bugs and thus we did not report the other bugs.
regarding more apps in the play store approximately of guis have at least one imagebutton that misses accessibility textual description .a competitive or better capability than state of the art techniques.
furthermore rx s results are considerably more consistent and stable across devices.
rq3 a call for practical r r c. the analyses of failure cases first revealed that only very few replay failures less than in all replays are out of the capability of the rx replay framework algorithm .
perhaps this is our most significant implication event based replay even for the challenging cross device case can be done greedily online .
considering the other failure cases this paper could be regarded asa call for future research along r r c. it is expected that a heuristic algorithm like the one in section .
cannot handle all real world cases overlapping views cause segmentui to perform incorrect segmentation and the quality of accessibility information significantly impacts similarity andresppatterns .
these limitations can be potentially resolved by data driven approaches e.g.
by learning distributed representations of views.
we are optimistic that learning based approaches e.g.
v2s will facilitate better implementations of segmentui similarity and resppatterns .
threats to validity .
the first threat to validity is that only the most popular apps are selected in the evaluation.
most of them are commercial apps developed by professional teams.
therefore the evaluation results may not generalize to other apps e.g.
less wellmaintained open source apps.
we intentionally chose these most popular apps because they usually incorporate complex patterns in adapting to different screen sizes.
the major conclusion concerning the effectiveness of rx replay framework should remain positive on simpler apps with less complex responsive patterns9.
another threat is that all usage scenarios are created by the authors which may be subject to bias.
to best alleviate this issue we tried our best to select the most typical usage scenarios by following existing work .
we also provide detailed descriptions of these usage scenarios on our website to enable reproducible research in the future.
the final threat is that the replay success is determined by a human even though such a human in the loop seems unavoidable.
the analyses in section show that key events are a good basis for determining replay success.
we strictly followed this guidance as the replay oracle to avoid bias from humans.
related work record and replay is a fundamental enabling technology for a broad spectrum of testing and debugging practices and has been extensively studied in various contexts.
record and replay for android apps .
reran exploits linux s input subsystem dev input event for logging and replaying pixel precise hardware level input events in which views are located by absolute coordinates.
pixel preciseness is a desirable property for deterministic apps.
however as shown in our experiments even minor non determinism can result in replay failure.
other pixel based approaches include valera a customized system and mobiplay record and replay on a remote desktop .
such a pixel precise treatment can easily fail to replay a trace on a device of different screen size or orientation.
to enable cross device 9however rx does not well support apps that refuse a correct application of officially recommended responsive patterns.
404cross device record and replay for android apps esec fse november singapore singapore replay to some extent one may proportionally scale the coordinates or localize a logged event e s receiver object at replay time by its attributes e.g.
using textural information of views .
however all these techniques made a fundamental assumption that each logged evente s receiver object exists on the replay time gui.
unfortunately modern apps often adopt android s responsive design that could extensively restructure the ui layout across devices usage scenarios .
this paper is the first to consider these cases as in scope.
finally as discussed in section one may incorporate an exhaustive search for an oracle satisfying event sequence .
a sufficiently efficient search will ultimately solve r r c and many other problems e.g.
test input generation and is still an open problem.
on the other hand this paper as an exploratory demonstrates that search may not be required for a practical r r c. record and replay for other event based systems .
there is record and replay work for other event based systems e.g.
web applications.
web applications have a simpler single threaded event model whose execution is easier to be deterministically traced .
upon that a developer friendly interactive debugger or further sophisticated dynamic analyses can be implemented.
generally web applications are simpler in the execution model and responsive patterns and have a particular focus on the network side .
thus the record and replay of web application is a considerably different scope.
deterministic replay for other systems .
a general program s execution can also be made fully or partially deterministic via runtime tracing.
such deterministic replay techniques may involve input tracing instruction tracing or memory tracing .
these deterministic approaches could incur significantly higher overhead and are more intrusive than a lightweight event based record and replay this paper s scope .
we do not discuss them further because they target a different replay purpose.
gui understanding and analyses .
finally the implementations of ui segmentation and responsive patterns are related to gui understanding e.g.
learning probabilistic distribution of gui layouts for detecting and repairing gui bad smells and flaws.
uis hunter and seenormly exploit computer vision techniques to detect violations with respect to material design s don t do that guidelines.
labeldroid and coala repair missing textual descriptions for imageview like views using data driven approaches.
gvt and owleye detect gaps between gui designs and their implementations.
we are optimistic that these techniques orthogonal to this paper s scope can facilitate further development of cross device record and replay technologies.
conclusion record and replay is a foundational technology for a broad spectrum of android app testing and debugging practices.
this paper made the cross device record and replay practical for industrial scale apps with respect to responsive gui restructurings by leveraging the principle of least surprise in gui design i.e.
spatial locality and responsive patterns with promising experimental evaluationresults.
we hope this work which pushes forward the state of theart of cross device record and replay for android apps will serve as a call for future research along this line.