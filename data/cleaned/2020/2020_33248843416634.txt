scaling client specific equivalence checking via impact boundary search nick feng fengnick cs.toronto.edu university of torontofederico mora fmora cs.berkeley.edu university of calfornia berkeley vincent hui vhui cs.toronto.edu university of torontomarsha chechik chechik cs.toronto.edu university of toronto abstract client specific equivalence checking csec is a technique proposedpreviouslytoperformimpactanalysisofchangestodownstreamcomponents libraries fromtheperspectiveofanunchanged system client .existinganalysistechniques whethergeneral regression verification equivalence checking or special purpose when applied to csec either require users to provide specifications or do not scale.
we propose a novel solution to the csec problem called 2clever that is based on searching the control flow of a program for impact boundaries.
we evaluate a prototype implementation of 2clever on a comprehensive set of benchmarks and conclude that our prototype performs well compared to the state of the art.
acm reference format nick feng federico mora vincent hui and marsha chechik.
.
scaling client specific equivalence checking via impact boundary search.
in 35th ieee acminternationalconferenceonautomatedsoftwareengineering ase september21 virtualevent australia.
acm newyork ny usa pages.
introduction software systems are often composed of multiple independently developed but related components.
upgrades to these components even those that do not alter apis can hinder the stability of thesystem making component upgrades a complex and timeconsuming task.
several existing techniques such as moddiff rvt symdiff andr ve canbeusedforvalidating behavioralequivalencebetweentwoversionsofaprogramorfor identifying the precise set of changes between them.
yet these techniquesdonotexploitthe usagepattern ofaparticularlibrary component within its client.
inourearlierwork wearguedthattheequivalencechecking problem becomes more tractable when the usage pattern is considered.
we further defined the client specific equivalence checking csec problemasthatofdeterminingtheimpactofchanges todownstreamcomponents libraries fromtheperspectiveofan ase september virtual event australia copyright held by the owner author s .
acm isbn .
system client .
we also argued for the practical relevanceofcsecinanapplicabilitystudy andproposedasolutionto csec in a symbolic execution based tool called clever.
while clever performs better than the general purpose differentialprogramanalysistechniquesoninstancesofthecsecproblem it is still unable to handle realistic programs.
specifically cleverstruggles in cases of complex clients multiple library calls andcases where a finite set of paths is insufficient to solve the csecproblem.
existing techniques share this scalability issue because theyproduce monolithicqueries thattheir reasoningengine can t handle e.g.
r ve theyarepath based e.g.
moddiff ortheydepend on expensive invariant inference techniques e.g.
symdiff.
instead ofgeneratingonedifficultquerytoanunderlyingreasoningengine we propose an approach that generates a sequence of smaller simplerqueries.thesesmallerqueriesfrequentlyhaveafinite number of paths can be handled by invariant inference techniques and imply overall equivalence.
illustrative example.
consider the client and two libraries in fig.
.fig.1ashowstheclient sum primes whichtakesaninteger xandreturnsthesumofallprimesbetween 0andx.sum primes depends on a library composite to check if numbers are prime.
figs.1band1cshowtwoversionsof composite .thefirstlibrary version composite 0 returns 0if its input is prime and the number of factors of the input otherwise.
the second composite 1 returns 0if its input is prime and 1otherwise.
existing techniques in particular clever moddiff symdiff rvt andr ve failtoprovethat composite 0 andcomposite 1 are client specific equivalent for sum primes .
clever and moddiff struggle because the problem has an infinite number of paths symdiffandr ve sreasoningenginesareunabletoidentifyarelational invariant that is strong enough to prove equivalence and rvt s bottom up approach fails to use the crucial client context.
in this paper we propose a novel approach 2clever that scales better than existing tools.
2clever hinges on two key observations inpractice asmallportionofclientcontrol flowgraph cfg is often sufficient to prove that a library call does not affect the client we call such a sub cfg an impact boundary and if all librarycallshaveanimpactboundary thenthelibraryupdatedoes not affect the client.
for example 2clever determines that sum primes in fig.
1a is unaffectedbythechangeto composite infigs.1band1cbybounding the impact of the library call in sum primes .
more specifically 2cleverprovesthattheimpactiscontainedwithintheloop i.e.
thattheredoesnotexistavaluefor x j and sumsuchthatasinglepassof 35th ieee acm international conference on automated software engineering ase this work is licensed under a creative commons attribution noderivs international .
license.
int sum primes int x int sum int j while j x if composite j s u m s u m j j return sum a sum primes in c.int composite 0 int num int count int i while i num if num i count i return count b composite 0 in c.int composite 1 int num int i while i num if num i return i return c composite 1 in c. figure the client sum primes returns the sum of all primes less than x. the client calls composite to check for primality.
theoriginalversion composite 0 returnsthenumberoffactorsofitsinput thenewverison composite 1 returns 1ifitfinds a factor and 0otherwise.
the client is unaffected by their difference.
theloopusing composite 0 producesdifferentvaluesfor x j and sumattheendoftheloopcomparedtousing composite 1 .sinceno librarycallaffectstheclient 2cleverconcludesthat composite 0 andcomposite 1 are client specific equivalent.
using the same strategy 2clever is able to efficiently solve many other instances that other existing tools are unable to handle.
furthermore 2clever can be implemented as a strategy on top of existing techniques withrelativelylowoverhead.thismeansthat ingeneral 2clever can handle any instance that existing tools can handle.
contributions.
this paper makes the following contributions.
we observe that the csec problem can usually be solved using limitedportionsoftheclientcfg.theseportionsare extractable sub cfgs that imply equivalence we call them impact boundaries.
wedevelopanapproach 2clever thatsearchesforimpactboundaries.
it makes a novel connection between the classic literature on procedure extraction and equivalence checking.
we describe an efficient realization of 2clever with two important components an algorithmforfindingextractable sub cfgsandabespoke equivalence checking algorithm.
we report on a prototype implementationof2cleverandempiricallyevaluateitonasuiteof568 benchmarks taken or constructed from related work.
organization.
therestofthispaperisorganizedasfollows.sec.
gives the necessary formal background.
sec.
describes our approachatahighlevel includingthedefinitionofimpactboundaries andanaiveimpactboundarysearchstrategy.sec.4describesan advanced impact boundary search.
sec.
reports on the implementation of these ideas.
sec.
evaluates the performance of 2clever comparedtostate of the arttechniques.sec.7surveysrelatedapproaches.
we conclude in sec.
with the summary of the paper and discussion of future research directions.
formal background this section describes control flow automaton cfa formally defines the csec problem in terms of cfas and defines the cfa analyses that we use in sec.
to describe our approach.
.
control flow automaton cfa weborrowthedefinitionofcfasfrombeyeretal.
.sincethe original definition does not handle function calls we extend cfas to allow us to express and reason about libraries and clients.
inparticular we make five small changes m1 add a final location m2 adda vectorofinputs m3 adda vectorofoutputs m4 allowcallstoothercfas and m5 allowmoredatatypesthanjust rational numbers.
we use m1 m3 to enable m4 .
we use m4 to formalize the notions of client and library clients are cfas that call other cfas libraries are cfas that are called by other cfas.syntax.
ac f a l li lf vecx vecr g is a finite set of program locations l aninitiallocation li afinallocation lf avectorofinputvariables vecx avectorofoutputvariables vecr andafiniteset g l o lof control flow edges.
the set oof program operations consists of assignment and assumption operations.
assignments are denoted byx t wherexisavariablein vecxor vecrandtisatermofthesame type.assumptionsaredenotedby wherebisabooleanterm.
the set of terms is defined inductively.
every constant is a term every variable in vecxor vecris a term and if fis a cfa and vectis a vector of terms matching the input type of f thenf vect is a term.
in other words a call to the cfa fwith the arguments vectis a term and this term is represented by f vect .
forexample thecfasofthecfunctionsinfig.1aredepicted in fig.
where locations are numbered nodes initial locations are shaded final locations are double circled and operations appear as labels on edges.
in particular the cfa of the client sum primes hasl l0 lf vecx angbracketleftx angbracketright vecr angbracketleftr angbracketright and uses fas a placeholder for either composite 0 orcomposite 1. semantics.
letf l li lf vecx vecr g b eac f a .aconcrete state of fis a pair l wherel lis a location and is a variable assignment.
when the location of a concrete state is obvious or irrelevantweabusenotationandomitit.everyedge g gdefinesa transitionrelationbetweenconcretestatesg c g c where cisthe setof allconcrete statesof f. forany twoconcrete states aandb wewrite ag bif a g b g andweuse a btomean thatthereexistssome g gsuchthat ag bholds.forexample for the cfa of composite 1 in fig.
2c a20 num r i b21 num r i areconcretestates g i isacontrol flowedge and we can write a20 b21 sincea20g b21holds.
letc1 e1 ... e n cnbeasequenceofalternatingconcretestates andedgessuchthat logicalandtext.1n i 1ciei ci 1holds.wecall c1 e1 ... e n cn j j 1sum j c f j sum sum j r sum a sum primes cfa.
i i 1count i count count r count b composite 0 cfa.
i i 1r i r c composite 1 cfa.
figure cfas corresponding to c functions in fig.
where locations are nodes initial locations are shaded final locations are double circled operations are labels on edges and fstands for either a call to the cfa in 2b or to the cfa in 2c.
atraceif the location of c1isl0and the location of cnislf.
we call c1 e1 ... e n cnarunotherwise.
for a trace c1 e1 ... e n cnwe call the pair c1 cn ani o pairand denote it c1 cn.
in other words ifc1 cnis an i o pair of f then executing fstarting at c1will result in c2.
for example for the cfa of composite 1 in fig.
2c and concrete states c19 num r i c25 num r i c19 c25isani opairbecause19istheinitiallocation 25isthefinallocation andthereisasequenceofconcretestatesthatconnects c19andc25 following the sequence of locations .
given a concrete state the term f vect denotes prime prime vecr where prime prime primeisani opairof fand prime vecx vect istrue.inotherwords f vect representsthereturnvalueofacallto fwiththearguments vect using call by value semantics.
for example at the concrete state j ... in the cfa of sum primes the meaning of the termf j is regardless of the version of composite that you plug in for f both composite 0 andcomposite 1 will return when given the input .
.
formal problem definition the csec problem is that of determining whether a change to a libraryaffectsitscallingclient.inthispaper wefocusonfunctional effects the input output behaviour of the client.
formally let f f prime g andg primebe cfas such that fcallsg and f primeisthesameas fbutwithcallsto greplacedbycallsto g prime.w e callftheclient and we call gandg primetwo versions of the library.
we say that gandg primearefunctionally client specific equivalent cse forfiff vectf vect f prime vect .inotherwords wesaythatthelibraries are cse for the client if the input output behaviour of the client is unaffected by the version of the library that it uses.
thegeneralfunctionalequivalencecheckingproblemisthesame ascsecbutwithoutrestrictions and .inotherwords thegeneralfunctional equivalencecheckingproblemisto checkwhether two functions will always return the same output when given the same input.
this means that we can use equivalence checkers tosolvethe csecproblem.however weargue thatusingthecsec problem restrictions improves performanceand makes many previouslyinfeasiblecasessolvable.forexample ourapproachfully automatically proves that composite 0 andcomposite 1 are cse forsum primes while moddiff symdiff rvt and r ve all fail to prove the corresponding general equivalence checking problem within a day.
there are two crucial insights behind our approach.
first we often only need a portion of the client to prove that the client is unaffectedbythelibrarychange.wecallsuchaportionoftheclient animpactboundary.second certaincandidateimpactboundaries are relatively easytocheck.ourapproachcombinestheseinsights by searching the cfa of the client for relatively easy to check candidate impact boundaries.
the search stops when it finds a true impact boundary or a counterexample to equivalence.
this search requires a guarantee that the client remains unchanged.
.
cfa properties before describing our approach we provide a few cfa definitions culminatinginthedefinitionofa hammock.hammocksarepartsof acfathatare extractable.
thatis thereisasemanticspreserving transformation that replaces hammocks with calls to new standalonecfas.weusehammockstodefinethestructureofimpact boundaries in sec.
.
thefirstsetofdefinitions path simplepath domination postdomination backedge and reducible are standard graph theory termsusedinprogramanalysis .letfbeacfa l li lf vecx vecr g .
apathinthecfaisasequenceoflocationsin lthatareconnected byedges in g.a pathisa simplepath ifno locationappearsmore than once in the path.
we say that a location i ldominates a locationj lif every path from l0tojpasses through i.w e say that a location j lpost dominates a location i lif every path from itolfpasses through j. an edge j iis abackedge ifidominates j.agraph gisreducible ifgbecomesacyclicafter removing all backedges.
for example in fig.
2a the label dominates the label the label post dominates the label the edge between and is a 736backedge and the entire graph is reducible since removing the edge between and gives an acyclic graph.
we use the second set of definitions strongly connected component entry point and exit point in our impact boundary search algorithm of sec.
.
let f l li lf vecx vecr g be a cfa.
a strongly connectedcomponent scc soffisthemaximalsub graphof g withthepropertythatthereisapathfromeverylocationin sto every other location in s. we call a location ianentry point ofsif i sand there exists a location n ssuch that n iholds.
we callalocation janexitpoint ofsifj sandthereexistsalocation n ssuch that j nholds.
forexample infig.2a thesub graphcontaininglocations3 and and all edges between these locations is an scc.
for this scc the locations and are the entry and exit point respectively.
the third set of definitions sub cfa andinduced sub cfa depend on the first set and will give us the main structure of impact boundaries.
let f l li lf vecx vecr g beac f a .asub cfa of fi sac f ah lh i j vecv vecv gh such that lh l j lh i lh vecv vecx vecr andgh g.i f vecv vecx vecrandghis exactly the set of edgesoffthatconnectpairsoflocationsin lh thenwesaythat histhesub cfaoffinducedbylh i andj.whenghisanscc ofg the entry point of gisi and the exit point of gisj then we callhan scc of f. for example for the cfa in fig.
2a the sub cfa induced by the subset of locations initial location and final location doesnotcontainthelocations2 8or9 oranyedgestouching them.infact itonlycontainstheedgefrom7to3.thisexample demonstrates the problem with induced sub cfas they are too unrestricted for our needs.
this can make their behaviour too hard to reason about and make the guarantees they can give too weak.
thefinaldefinition hammock comesfromkomondoorandhorwitz butisadaptedtoourcontext.hammocksarerelatedto thefoldable sub graphs of lakhotia and deprez .
intuitively both are portions of a cfa that can be extracted into a standalone cfa.
a sub cfa h lh i j vecv vecv gh induced by lh i andjis a hammock iff thefollowing hold forevery l lh idominates l inf forevery l lh jpost dominates linf everylocation oneverysimplepathfrom itojisinlh and forevery l lh every simple path in fbetweenjandlcontainsi.
for example for the cfa in fig.
2a we can define a sub cfa induced by the subset of locations initial location andfinallocation3.thisinducedsub cfaisahammocksince3 dominatesandpost dominatesexactlythelocations4 and7 thereisno missing locationthatcanbereachedfromtheinitial locationandleadstothefinallocation andthereisnopathfrom the final location to the sub cfa that evades the initial location.
intuitively ahammockiseasiertoreasonaboutbecauseitacts like a a standalone cfa.
we use this fact in the soundness proofinsec.
.specifically weusethefactthatif hisahammockof f then all traces of fare of the form l0 0 ... i k i ... j k j ... ... lf f where isthestandardkleenestar i k i and j k j arethekth concrete states at location iandj respectively and locations iand jdonotappearinanyellipses.inotherwords everytraceof fhas zeroormorerunswithlocationsin h andeverysuchrunstartsat i c f j a c f j sum sum j b figure the two smallest candidate impact boundaries ofsum primes from fig.
2a.
both are induced sub cfas.
andalwaysleaves hexactlyatthelocation j.sinceeverytraceof f hastheseproperties wecanthinkoftherunsfrom itojascallsto anexternalcfa.weusethistracepatterntoreducetheanalysisof a trace of fto one of the candidate impact boundary runs inside.
2clever at a high level in this section we formally define impact boundaries provide a simple impact boundary search strategy and prove the soundness and relative completeness of our approach.
the completeness isrelative because our search strategy depends on an equivalence checking oracle.
intuitively our approach decomposes the cfa of the client into smaller equivalence checking queries.
this query size reduction can often make intractable problems tractable.
for simplicity of presentation we assume that every client cfa containsonlyonecalltothelibrary andthateveryclientcfais reducible.
we relax the first assumption in sec and note that the secondassumptionisinnocuoussinceirreduciblecontrol flowis rare in practice .
for the remainder of this section let gbe the old version of the library cfa g primebe the new version of the library cfa and fbetheclientcfawithasinglelibrarycallonanedge e. .
impact boundaries acandidate impact boundary h lh i j vecv vecv gh is a hammock of f l l0 lf vecx vecr g such that hcontainse.
intuitively a candidate impactboundaryisaportionoftheclientwiththespecialproperty that ifthe candidate impactboundary isunaffected by thelibrary change then the client is unaffected by the library change.
animpact boundary is a candidate impact boundary hsuch that gandg primeare cse for h. for example fig.
depicts the two smallest candidateimpactboundariesof sum primes fromfig.1a.thecfa in fig.
3b is a true impact boundary while the cfa in fig.
3a is not.
.
impact boundary search we call our boundary search algorithm 2clever.
it takes in a client and two versions of one of the client s libraries.
it returns cse if it finds an impact boundary and not cse otherwise.
in this section we describe a simple realization of 2clever called 2clevernaive andreasonaboutitscorrectnessandcompleteness.themore sophisticated realization is described in sec.
.
2clever naiveenumerateseverysub cfaoftheclient filtersout those that are not candidate impact boundaries and then checks each candidate for cse using an existing equivalence checker.
for 737example when given the client and libraries from fig.
2clevernaive will enumerate the two candidate impact boundaries in fig amongothers checkeachforcse andreturn cse sincethecfa infig.3bisatrueimpactboundary.inthenextsection weprovethe soundnessofthisstrategy.fornow weassumecorrectnessandnote that it is cheaper to check if composite 0 andcomposite 1 are cseforthecfainfig.3businganexistingequivalencechecker than to check the original problem.
in fact the cfa in fig.
3b corresponds to removing an entire unbounded while loop from the original cfa in fig.
2a.
.
analysis in this section we prove two theorems about 2clever if 2clever claimsgandg primeare csefor f then theytruly are soundness and ifgandg primearenotcsefor fandourequivalencecheckingoracle terminates on every query then 2clever will terminate relative completeness .
theorem soundness .
if 2clever finds an impact boundary thengandg primeare cse for f. proof.letf l l0 lf vecx vecr g betheclient let f primebefbutwith thecalltogreplacedbyacallto g prime.similarly let h lh i j vecv vecv gh betheimpactboundary andlet h primebehbutwiththecallto greplaced byacallto g prime.bythedefinitionofcandidateimpactboundaries all traces offandf primeare of the form l0 0 ... i k i ... j k j ... ... lf f t1 l0 0 ... i k i ... j k j ... ... lf f .
t2 we want to prove that if 0 0then f f. sincetheclientisunchangedapartfromthecalltothelibrary weknowthatif 0 0then 1 i 1 i.wealsoknowthat forany mandn if m j n jtheneveryconcretestatein t1 after j m j isguaranteedtobeequaltothecorrespondingconcretestatein t2 after j n j untilbothtracesreachaconcretestatewithlocation i. in other words all the code outside of the impact boundary remains untouched and two copiesof syntacticallyidentical code thatstartatthesameconcretestatewillproduceidenticaltraces.
given these two facts we need to prove that the runs i k i ... j k j t3 i k i ... j k j t4 insideof t1 and t2 respectively areequal.bythesemanticsof function application every run t3 is equivalent to the term h vecv .
similarly everyrun t4 isequivalenttotheterm h prime vecv .sincegand g primearecsefor h h vecv h prime vecv therefore t3 and t4 areequal.
square theorem2 relativecompleteness .
ifgandg primearecse for f then there is an impact boundary.
furthermore if every call to an equivalence checker oracle terminates 2clever finds an impact boundary.
proof.
if gandg primeare csefor f thenfisan impactboundary.
sincethesetoflocationsofacfaisfinite thenumberofcandidate impact boundaries 2clever checks is finite.
square4 realizing 2clever in this section we describe the actual impact boundary search algorithm used by 2clever a bespoke equivalence checker that we use inside the search algorithm and a resource time allocationscheme to improve 2clever s chance of termination.
2clever also extends2clever naivetohandleclientsthatcallthelibrarymultiple times.atahighlevel 2cleverconfirmsthecseonlyifitfindsan impact boundary for every call site of the library.
.
impact boundary search revisited finding and checking every candidate impact boundary is impracticalforcomplexclients.inpractice 2cleverfocusesonfindingand checkingasubsetofcandidateimpactboundaries.someofthese are still difficult to reason about so we transform them to cyclebroken candidates.
while easier to check confirming a cycle broken candidate implies confirming the impact boundary that it replaced.
given this and since 2clever keeps the client fin the subset of candidate impact boundaries to check the proofs of soundness thm.
and completeness thm.
still hold.
given a candidate impact boundary h whose initial and final locationsarethesamelocation l weproducea cycle broken candidatehcbbyseparating linhcb.forexample thecfashownin fig.4bisacycle brokencandidateoftheclient f seefig.2a whose initial and final locations both belong to location in f. locations and form a strongly connected component shown infig.
4a which is hard to check for cse.
on the other hand thecycle brokencandidate hcbbreaksallcyclesinvolvinglocation3 the final location does not have outgoing edges hence makes checkingcseon hcbeasier.eventhough hcbistechnicallynota sub cfa of the client f we still refer to it as a candidate impact boundary for the rest of the paper because it is a sub cfa of anequivalent client f where the common location lis extended to l liandlf l. .
.
candidate search.
the extended search algorithm search alg.
identifiesasequenceofcycle brokencandidates boundseq foreachlibrarycall site e.boundseq includesthecall site eitself and the client fas its first and last element respectively line and .
to identify cycle broken candidates for a call site e the algorithmfirst looksfor thestronglyconnected component scc sthatcontains e.search usesanauxiliaryprocedure normalize totransform sintoanscc s withauniqueentryandexitpoint i. thealgorithm thenconstructsa cycle brokencandidate hcbfrom s and adds hcbtoboundseq .
finally the algorithm updates the search context h hcb line and recursively looks for a new cycle brokencandidatein h untilhhasnoscccontaining e line8 .
the discovered hcbis always pushed to the head of the sequence.
for example for the client fin fig.
2a search identifies the sccsin fig.
4a containing the call site 4g .
location is the unique entry and exit of s and it is replaced with liandlfincyclebrokencandidate hcb whereliisacopyof3withonlyoutgoingedge li andlfis another copyof with only internalincoming edges lf .
the resulting cycle broken candidate hcbis shown in fig.
4b.
2clever then attempts to find an scc inside hcbbut fails.
finally the call site and the client are added to boundseq.
738algorithm search require client cfa fand library cfas gandg prime ensure boundarymap contains a sequence of candidate impact boundaries for each call site procedure search f g e call sites of ginf boundarymap dict for eache edo for each call site boundseq stack first in last out sequence boundseq.push f h f search on hammock h whilehhas scc containing edo s scc containing einh s i normalize s h hcb hammock induced from s andi boundseq.push hcb h hcb update cycle broken candidate end while boundseq.push e boundarymap boundseq end for return boundarymap end procedure j j c lib j sum sum j a li lf j j c lib j sum sum j b figure 4b shows the cycle broken candidate constructed from the strongly connected component in 4a.
theorem correctness .
every sub cfa hinboundseq returned by search is a candidate impact boundary.
proof.
boundseq containstheclient f thecall site e andcyclebroken candidates hcb.
bothfandeare trivially candidate impact boundaries.
every hcb boundseq is constructed from an scc s with a unique entry and exit i. therefore idominates and postdominateseverynodein s includingthesourceandtargetof e. moreover every path from itoemust go through i. therefore s is a candidate impact boundary and hcbis acycle broken candidate constructed from s .
square theorem monotonicity .
for every boundseq returnedby search foralliinrange0 i n hiisacandidate impact boundary for hi .
proof.for i n hiis the cycle broken candidate constructed from thescc s wheres is a sub cfa of hi .search algorithm check require boundarymap is returned by search ensure ret latticetopiffgandg primeis cse for f procedure check boundarymap f g g prime e call sites of ginf contained for eache edo for each call site boundseq boundarymap while boundseq e contained do h boundseq.pop ifeq h g g prime then for each call sitee primeginhdo contained.add e primeg end for end if end while end for ret contained e returnret end procedure ensures that s has a unique entry and exit location in hi .
therefore hisatisfiestheconditionsof cycle broken candidatefor hi .
the last item in boundseq hnis the client f. by correctness of search thm.
hn 1is a candidate impact boundary for f. square monotonicitysuggestsagoodcheckingorderofcandidates hi is smaller and likely easier to check than hi and confirming hiis sufficient for proving cse.
.
.
checking candidates.
after finding candidate impact boundarieswith search 2cleveruses check tocheckeach.specifically foreachcall site einf check fetchesthecorrespondingsequence ofcandidateimpactboundaries boundseq from boundarymap line5 anditeratesthroughthesequencetofindatrueimpactboundary fore lines .
during each iteration check checks whether g andg primeare cse for hby calling anequivalence checker eq line .
ifeqdetermines equivalence then his an impact boundary for everycall site eg including e inh.therefore thealgorithm adds eginto the set contained line which represents the set of call siteswithconfirmedimpactboundaries.
check stopsiterating over boundseq when it either reaches the end or the target call siteeis added to contained line .
finally the algorithm determines whether every call site has an impact boundary by comparing contained ande line and returns the result.
theorem5 partialcorrectnessof check .ifcheck terminates then gandg primeare cse for fiffcontained eat line .
proof sketch.
forward if gandg primeis cse for f thenfis an impact boundary for all call sites.
since fis in the boundseq for every call site then every call site is eventually added to contained.
backward eis added to contained only if it has an impact boundaryin boundseq .
when contained e every call site has an impact boundary.
by thm.
for every call site e the state difference caused by visiting edge eis contained before reaching the final location lf.
square 739algorithm 2clever eq require his a candidate impact boundary of g. require every scc in hhas single entry and single exit.
ensure returns proof or counterexample.
procedure 2clever eq h g g prime e call sites of ginh callee merge e pre caller before h callee post caller after h callee pre pre condition summary pre caller post post condition summary post caller callee product callee callee prime return verify pre callee post end procedure .
bespoke equivalence checking algorithm check calls procedure eqto confirm or reject candidate impact boundaries.
while any sound equivalence checker can be used for eq wedevelopedanin housealgorithm 2clever eq thatexploits the structure of our queries to achieve the best performance.
2clever eq is given in alg.
.
it takes the caller hand two versions of the callee gandg prime and requires that every stronglyconnected component scc in hhas a single entry and a single exit.
2clever eq first identifies all call sites in hand then merges themintoasinglecall site callee line3 .specifically theprocedure mergefinds the smallest hammock w that contains all the call sites and then returns the largest scc containing winh or returnswif no scc exists .
intuitively his an impact boundary for all call sites if and only if it is an impact boundary for w since wcontains all call sites.
the scc returned by mergeis the next smallest possible impact boundary and it is called at most once inh.weknowtheformersince bymonotonicity thm.
atthe time of checking h check has already checked the cycle broken candidate constructed from callee the previous candidate impact boundary in boundseq and failed.
we use the latter to partition h bycallee as discussed next.
2clever eq partitions hintopre caller andpost caller the portions of hbefore and after callee respectively lines and .2clever eq then summarizes pre caller andpost caller lines6and7 andconvertsthesummariesintoapre condition pre and a post condition postas described in sec.
.
.
.
2clever eq then creates a product function callee via self composition line8 .whenthesummariesof pre caller andpost caller are definedforallpossibleinputs candidate hisanimpactboundaryif and only if pre callee post is a valid hoare triple .
we check this hoare triple using conditional modeling checking by combining three existing program verifiers.
we describe the detailed workflow in sec.
.
.
.
summary pre and post condition computation.
afunction summary of fis a first order formula over vec and vec if m m vecx m f vecx where vecxandf vecx are input and output of f andm is the interpretation of vec in the model m. a function summary is completeif it is defined for all possible inputs.
similar to clever 2clever eq computessummariesbysymbolicallyexecuting pre caller andpost caller whilerecordingprograms pathconditions and effects.
during symbolic execution calls to calleeare uninterrupted.
if pre caller andpost caller have finite executionpaths thenthesummarybysymbolicexecutioniscomplete.
otherwise otherproceduresummarizationtechniques e.g.abstraction refinement may be used.
given pre thecompletefunctionsummaryof pre caller the pre condition of callee is assume vec pre vec vecx where vec is the input of pre caller and vecxis the the output of pre caller andtheinputof callee .intuitively thepre condition captures the possible invocations of callee .
given post the complete function summary of post caller the post condition ofcallee is assert vec post vecr vec post vecr prime vec where vecrand vecr primearetheoutputsfrom calleeandcallee prime respectively and vec issettobetheoutputof post caller oninput vecoand veco prime.intuitively apost conditionassertsthat post caller mitigates the difference if any in the outputs of calleeandcallee prime.
for example consider the candidate of impact boundary hin fig.
3b and the libraries g g primein fig.
2b and fig.
2c respectively.
we know that his an impact boundary because the hoare triple pre product g g prime post is valid where the pre condition pre isassume j x num j andthepost condition postaftersimplification removing latticetopand from conjunctions and disjunctions respectively is assert lib j lib prime j lib j lib prime j .
.
time bounded equivalence checking theprocedure eqmaynotterminateduetotheundecidabilityof equivalence checking.
since check calls eqmultiple times over boundseq weneedastrategyforresource time allocationtomaximizethechanceoftermination.weachievethisbyaddingatimeout argument ttoevery eqcall andmanaging theuristically.weuse the following time allocation scheme for a candidate sequence boundseq we start by calling eqwith some initial t e.g.
seconds.
if a timeout occurs we double the value of tfor the next call.
ifeqproducesananswerwithinhalfof t wereduce tbyhalffor the next call.
when eqis called on the last candidate f w es e ttto the maximum possible value.
intuitively thetimeallocationschemeusestheresultfromthe previous eqcall to predict the difficulty of the next call.
we use thisschemebecausecandidatesin boundseq havemonotonically increasing contexts.
therefore the difficulty of the previous call usually correlates with the difficulty of the next one.
implementation we implemented a prototype of cleverusing lines of python code .
the prototype see fig.
consists of three main components denoted i iii the front end c to cfa and the implementationofalgorithm search alg.
and check alg.
respectively.
c to cfa translates c99 source programs shown as a t o cfaf g g prime shown as b .
it uses pycparser for source parsing andabstractsyntaxtree ast transformation.wechosepycparser 740search candidate impact boundary sequences c to cfacfa f g g c program client lib lib i iib calleecallerf callee caller calleecallerh2 callee caller calleecallerh1 callee callerca csefind impact boundariesmiss an impact boundarycheck iii e f not cse eq cc2 eq or reve figure 2cleverarchitecture and workflow.
i iiandiiiare the components of the architecture.
cc2 eq calleecaller callee callerselfcomposition seahorn cbmc kleeconditional model checking answer answer answertimeout timeout timeoutd gh ij i ih hprecondition postcondition timeoutcallee callee e f figure internal workflow of 2clever eq.
because like our implementations of search andcheck i ti s written in python.
thesearch implementation iiin fig.
identifies a sequence ofcandidateimpactboundariesforeverycall site.analyzingthe sequences allows search to identify dependent and redundant equivalence checking tasks across different call sites when their boundseq overlap enablingoptimizationsthroughtaskplanning and redundancy pruning.
in addition independent equivalence checking tasks on different sequences are parallelizable.
check iiiin fig.
uses eqfor equivalence checking of individual candidate.
in addition to r ve we also implement 2clever eq the in house checker for eq illustrated in fig.
.
2clever eq usesconditionalmodelchecking tocombinethree distinct verification approaches bounded model checking using cbmc symbolicexecutionusingklee andic3 pdrusing seahorn .
effectively 2clever eq combines the strengths of the supported verifiers by allowing them to communicate their progress on a verification problem through a common information exchange method.
beforecheckingforequivalence 2clever eq appliesself composition ontheinputstoexpresstheequivalencecheckingproblemasaverificationproblem dinfig.6andline8inalg.
againstpreandpost conditionscomputedfromthecaller ssummary shown as e .self composition facilitates mutual invariant learning on the merged program f for proving relational properties and in our case functional equivalence.
duringtheequivalenceverification line9inalg.
2clever eq calls the verifiers in turn with a timeout gin fig.
.
when a verifier times out its progress is saved as program conditions and passed to the next verifier to guide the exploration towards the unverified state space step h .
the verification process terminates if 2clever eq answerstheequivalencequestion step i orexhausts all of the verifiers step j .
limitations.
ourcfamodelassumedtheinputfunctionsarenonrecursive see sec.
and reducible see sec.
.
additional constraints may be introduced by the equivalence checker for eq.
the implementationofthein housechecker 2clever eq hasthefollowingconstraints duetosourcelevelself compositionandconditional modelchecking respectively functionsmustbewell structured and they must exit from their last statement and datatypes are limited to chars integers booleans and non parametric arrays.
we use2clever eq as the default checker and automatically switch to r ve for any instances that do not satisfy these constraints.
evaluation inthissection wepresentasetofcsecbenchmarks andcompareourprototypeimplementationof2clevertothestate of the art.we aim to answer the following research questions.
rq1 how does 2clever s performance compare to state of the art on benchmarks fromrelatedwork?
rq2 howdoes2cleverscalecomparedtostateof the art as the algorithmic complexity of the input programs varies?rq3 howdoes2clever scalecomparedtostate of the art as the number of library calls in the input programs increases?
.
subjects and setup we compare 2clever clever and r ve on benchmarks.
each benchmark consists of a pair of c programs before and after some changestothelibrary.atahighlevel clevergenerateslogicalsummariesoftheclientandthelibraries composesthem andchecks for cse using an smt solver.
clever s performance depends on two main features eager counterexample detection andlazy library summarization.
the former is a method to disprove equivalence whilegeneratingthelogicalsummaries thelatterisamethodfor only summarizing those parts of the libraries used by the client.
the original clever tool checks python programs.
we use a our reimplementation of clever for c programs.
r ve translates the equivalence checking problem into a constrained horn clause query that can be discharged by an offthe shelf solver.
at a high level r ve uses a solver to find coupling predicates over the two input programs.
for optimal performance we evaluate r ve on the benchmarks with library calls inlined.
we started with publicly accessible benchmarks collected fromrelatedwork thatfollowedtheclient libraryformat.
we removed five cases that had recursive calls and included the examplefromsec.
.mostcasesintheresultingsetweretoosimple and therefore insufficient as test subjects for performance evalu ation of the cases are solved by all three tools in under five 741seconds.thissetalsohasnonestedloops allloopsiteratefewer than times and each case has only one library call.
we thus added15benchmarksthatr ve sauthorssourcedfrom glibcimplementations.
thesebenchmarksdid not fit ourclient libraryformat but we were able to find client functions for these benchmarks on github.
this yielded the set b origof cases equivalent and eight non equivalent.
tofurtherincrease b orig sdifficulty wesystematicallygenerate528benchmarks referringtotheresultingsetas b hard.b hard consistsofcombinationsof b origbenchmarksinvolvingatleast oneapplicable b origcasefromthe75thpercentileoftheslowest cases i.e.
those that timed out or had a solution time of 5s ec ondsforatleastonetool .below wedescribethetwotemplates seqmerge andnestmerge thatweusetogeneratethevariouscombinations.
seqmerge takes an arithmetic operator two clients f1andf2 and their corresponding libraries g1andg2 respectively.
seqmerge returns two merged clients fm1 f1 f2 and fm2 f1 f2 wherethesubstitution f1 means replacing every call to g1inf1withg2.
this process guarantees thattheresultingprogramshavetwolibrarycalls mitigatingfor theabsenceofmultiplelibrarycallsin b orig.italsocreatesnew examples with library calls under different client contexts.
nestmerge takesthesameinputas seqmerge butreturnsclient functions computed by fc1 f1 andfc2 f2 .
intuitively nestmerge uses one client s context to call the other client function as its library.
nestmerge creates additional cases withlibrarycallsundermorecomplexclientcontexts andincreases the variety of control flow patterns in benchmarks.
weranexperimentsonubuntu18.04withanintel coretmi7 cpu processor and gb of ram.
each case was run with timeout set to seconds and memory limit set to gb.
.
rq1 performance of 2clever weevaluatetheoverallperformanceof2cleverrelativetoclever and r ve by comparing their running times on all benchmarks both the b origcases and b hardcases.
results.
the cactus plot in fig.
shows the number of benchmark casescorrectlysolvedbyeachtoolunderthespecifiedtimelimit.
timeismeasuredinsecondsandplottedonalogarithmicscale.undera300 secondtimelimit 2clever cleverandr verespectively solved40 and19ofthe40 b origcases.on b hardbenchmarks 2cleversolved498of528caseswith30instancestimingout clever solved368 anddidnotsolve160 whiler vesolved231 andwas unabletosolve297.r vetimedouton55cases anddidnotprovide correct solutions on .
individually 2clever clever and r ve solved out of seqmerge instances and out of nestmerge instances respectively.
in particular on equivalent benchmarks every case correctly solved by either r ve orcleverwasalsosolvedby2clever withoneexception.2clever remained competitive with clever on non equivalent benchmarks solving vs. clever s despite the early detection of counterexamplesfeatureofthelatter.astheaveragesolutiontimefor casesincreased 2cleversignificantlyoutperformedr veandclever.
even though cc2 s static analysis for searching candidate of im pact boundaries see alg.
adds a near constant time cost itsfigure all benchmarks sorted by the solution time.
benefitinrestrictingclientcontextsignificantlyoutweighsthecost on non trivial instances and ultimately makes cc2 scale better.
beyond performing well on our new benchmarks 2clever also correctly handled the four original cases that contained unbounded loops ultra prime sum pos pos2andodd which no previous tool was able to solve under the given time limit.
2clever s success on these cases supports our claim that impact boundary search ismoreeffectivethanpriortechniqueswheneverinputprograms have unbounded loops with a non trivial loop condition.
answer to rq1.
2clever s performance on solving hard clientspecific equivalence instances is superior to state of the art while its performance on easy instances remains competitive.
.
rq2 varying program complexity we now study how 2clever scales with respect to the total program complexity of the input programs.
complexity objectively categorizes variation in control flow patterns while having external validity.
intuitively we take complexity to be a rough estimate of the difficulty of equivalence checking for the benchmark cases.
to investigate we present the results fromthe experiment conducted in sec.
.
but this time we sort the benchmark cases bythe total benchmark complexity as a function of n the size of input to each program and organize them into four complexityclasses.
whenever an input program pair has two different complexities the benchmark is assigned the higher one.
the first class denoted constant contains o cases.
the second class denoted linear contains100 o n cases two o nlogn cases and 38o logn cases.thethirdclass denotedquadratic contains50 o n2 cases.thefourthclass denotedhigher order contains cases and includes four o n3 cases as well as cases with nonterminatingprogrampaths.wecomparethepercentageofcases solved by each tool across the complexity classes.
results.
fig.8displaysthenumberandthepercentageofinstances solvedby2clever cleverandr ve overeachcomplexityclass.the mean solution time for each tool over all solvedcases is shown underneath each complexity class.
time is measured in seconds and all cases where tools time out or do not provide a solution are 742figure all tools over all benchmarks sorted by benchmarkcomplexity.meansolutiontimesareover solvedcases.
disregarded.
we observe that 2clever outperforms clever and r ve oneverybenchmarkcomplexityclass.although2cleversolvesa smallerpercentageofcasesascomplexitygrows asexpected itsadvantageovercleverandr ve intermsofdifferenceinsolvedcases increases.
in particular while clever and r ve remain competitive on lower complexity cases 2clever significantly outperforms existing tools on higher complexity benchmarks this provides further evidencethatourimpactboundarysearchscalesmoreeffectively to difficult cases than do r ve and clever.
specifically clever does not scale to benchmarks with higher complexities because it ispath based and terminates only when exploring a finite numberof program paths is sufficient to produce an answer this is not thecasewheneverunboundedloopsexistanywhereintheinput programs.r ve sscalabilityislimitedinsteadbyitsunderlyingreasoning engine while verification conditions are produced quickly theresultingmonolithicqueriescannotbehandledbythereasoning engine.
2clever s ability to both handle unbounded client loops and decompose large queries is key to explaining its significant performance advantage on higher complexity benchmarks.
answertorq2.
2cleverscalesmoreeffectivelythanexistingtools as the complexity of the input program increases.
in particular 2clever srelativeperformance intermsofthepercentageofsolved cases improves as complexity grows.
.
rq3 scaling library calls we now study how 2clever scales as the number of library calls in the input programs increases since real software clients can calltheir libraries at multiple program locations.
we believe that the number of library calls correlates with the difficulty of equivalence verification because each library call site can be a potential source of difference that splits the input programs control and data flows.
for this study we generate another set of benchmarks with the seqmerge template focusing specifically on the number of calls.
to do so we merge b origcases see sec.
.
with themselves sequentially applying seqmerge from one to fifteen times.
this yields fifteen new cases for every applicable b origcase with figure scaling number of library calls over b multcall .
eachnewcasecontainingadifferentnumberoflibrarycalls.the resultingbenchmark denoted b multcall consistsof25 cases.ourexperimentcompares2clever sperformancetoclever and r ve on b multcall in terms of the percentage of cases solved by each tool.
results.
fig.
plots the percentage of b multcall cases solved correctlyandindexedbythenumberoflibrarycallsinthebenchmark.
2clevernotonlyalwayssolvesthehighestpercentageofcasesbutitalsoextendsitsleadovercleverandr veasthenumberofcallsin creases.specifically 2clever sleadovercleverandr vegrowsfrom to and from to respectively.
moreover a regressionline fittoeachtool sperformancedata seefig.
suggests 2clever s rate of performance decrease is not only smaller over the observedrangeoflibrarycalls butwillstaysmallerevenoutside therange.2clever sregressionlinehasagreaterslopecoefficient .
comparedtoclever s .
andr ve s .
.theseresults show a noticeable performance advantage of 2clever compared to other tools as the number of library calls increases.
answertorq3.
2clever sperformancescalesbetterthanthestate oftheart intermsofthepercentageofsolvedcases asthenumber of library calls increases.
.
threats to validity our strategies for determining ground truth and program complexities of new benchmarks are possible threats to validity.
to mitigate the absence of ground truth two authors first manually classified equivalence of all possible combinations of client contexts and libraries from the original benchmarks and recorded results as known facts.
we then automatically established ground truthofeachmergedcaseusingconservativeinferencerulesand theseknownfacts.for example wesaythata seqmerge case see sec.
.
isequivalentifbothargumentstothechosenarithmeticoperator are equivalent.
similarly we say that a nestmerge case see sec.
.
isequivalentifitsinnerfunctionisunaffectedbythelibrary change.theseinferencerulesappliedto229outof264 seqmerge and191outof264 nestmerge cases.wedeterminedgroundtruth of the remaining seqmerge cases and nestmerge cases by 743examiningconsensus ifreached betweenthedifferenttools.disagreements and random instances were manually inspected.
in caseswheredisagreementsarosefromtool sdifferencesindefinitionsofequivalence e.g.
theequivalencerelationovererrorstates or modeling semantics e.g.
whether integer overflows can occur bothanswerswereacceptedascorrect.modellinganddefinitions ofequivalenceareimportantconsiderations butwedonotfocus on them here.
wedeterminedcomplexitiesbyfirstanalyzingthecomplexity ofeachclientcontextandlibraryseparately andthencombining resultstodeterminethecomplexityofthecomposedbenchmark cases.
finally we note that our combined benchmarks could give an unfair advantage to our technique if either our original benchmark cases or our templates for combining them i.e.
seqmerge and nestmerge favorit.wemitigatetheformerthreatbygenerating new examples exclusively from benchmarks found in related work.
wemitigatethelatterbyusingtemplates i.e.
sequentialandnested compositions that reflect how real programs are constructed.
related work inthissection wedescribethetoolsandtechniquesmostrelatedto 2clever.afterrevisitingclever wedescribetoolsthatperform general equivalence checking dividing them into those that prioritizeprovingequivalence thosethatprioritizedisprovingequivalence and those that deal with similar input programs.
we end by examiningincrementalverification arelatedverificationtechnique.
client specificequivalencechecking.
cleveristheonlyother toolthatspecificallytargetsthecsecproblem.wedescribedclever in sec.
.
and analyzed it extensively in sec.
.
clever is effective when there is a single library call per client path and when a finite number of paths is sufficient to solve the csec problem.
the main difference between 2clever and clever is that 2clever targets more realistic programs i.e.
those with multiple library calls and nonconstant time complexity.
proving program equivalence.
barthe et al.
reduce equivalencecheckingtothetaskofverifyingaproductprogram.many others extend this work.
for a recent example churchill et al.
optimize the construction of the product program by comparing program traces.
we incorporate the reduction idea into our approach seesec.
.
.however unlikebartheetal.
ourformulation avoidstheneedforhumaninput andunlikechurchilletal.
our main contribution is in the identification of impact boundaries.
symdiff usesmutualfunctionsummariestocheckpartial equivalenceoftwoproceduresbydischargingverificationconditionstoboogie .morerecentimprovements lessensymdiff s user burden by automatically inferring common invariants.
unfortunately symdiffwith thisextension isunable toautomati callysolve ourexamples.
wedo notcompare 2cleverwithbarthe et al.
churchill et al.
or symdiff because they do not disprove equivalence.
disproving program equivalence.
differential symbolic execution dse by person et al.
uses symbolic execution to characterize the difference between two programs.
dse is similar to clever butitdoesnotspecificallytargetcsec.
directedincrementalsymbolic execution dise extends dse.
it uses static analysis to guide symbolic execution to areas of the program that are likely to differ.
shadow symbolic execution sse is similar to dise in that it is based on symbolic execution and it prioritizesthe exploration of paths that are likely to expose a difference inthetwoinputprograms.incontrasttodise sse sheuristicsare dynamic.
like clever none of dse dise or sse are able to prove equivalenceofinfinitepathprograms.forthisreason wedonot compare 2clever with these tools.
regression verification.
wedescribedr ve insec.
.1and evaluated its performance in sec.
.
r ve is similar to the work by barthe et al.
and churchill et al.
.
however unlike the former r ve is fully automatic unlike the latter r ve is more sensitivetothesyntacticsimilarityoftheinputprograms unlike both it is able to disprove equivalence.
rvt uses a fixed set of proof rules to prove the equivalence of two related programs.
rvt deals with function calls bottom up making it difficult to reasonabout client contexts.
we do not compare against rvt because itdoesnotdisproveequivalence.moddiff extendsdsewith modular symbolic execution and abstraction.
moddiff is similar toclever butitdoesnottargetthecsecproblem andthusdoes not take advantage of the top down exploration.
we also do not compare against moddiff because it is unable to handle programs with multiple library calls.
incremental verification.
incremental verification tools aim to reduce the cost of verifying a system over time by reusing veri fication results of previous versions .
for example evolcheck maintains function summaries logical overapproximations of the input system s functions that satisfy the system s specification that are updated if necessary for each new version of the system.
the goal of incremental verification tools is related to client specific equivalence checking but the problem differs in that it requires specifications.
conclusion inthispaper wedefinedthenotionofimpactboundary andpresented an algorithm 2clever that solves the functional csec problem by searching for impact boundaries.
we implementeda prototypefor2cleverandcompareditagainstthestate of the artona novel set of benchmarks.
we found that 2clever s performance scalesbetterthanthestate of the artintermsofthecomputational complexity and number of library calls of the input programs.
inthefuture weintendtoextend2clever sapplicability scalability andinterfaceevenfurther.specifically weaimtosupportthe analysisofrecursiveprogramsandprogramscontainingvariability.intermsofscalability weintendtoequip2cleverwithparallelsolv ing capabilities.when candidate impactboundariesdo not overlap they can be checked independently in parallel with a potentialof improving performance on inputs with more than one library call.
2clever s naive parallelization approach is promising and weintendtofurtherourexplorationsinthisdirection.finally in termsofinterface weintendtostudyhow2clever canuseimpact boundaries tocommunicate the reason for equivalenceto client developers.
744references alfred v. aho ravi sethi and jeffrey d. ullman.
.
compilers principles techniques.
addison wesley.
mikebarnett bor yuhevanchang robertdeline bartjacobs andk.rustanm.
leino.
.
boogie a modular reusable verifier for object oriented programs.
inproc.
of fmco .
springer berlin heidelberg .
gillesbarthe juanmanuelcrespo andc sarkunz.
.
relationalverification using product programs.
in proc.
of fm .
springer berlin heidelberg .
gilles barthe pedro r d argenio and tamara rezk.
.
secure informationflow by self composition.
mathematical structures in computer science .
dirk beyer sumit gulwani and david a. schmidt.
.
combining model checking and data flow analysis.
springer international publishing cham .
dirk beyer thomas a henzinger m erkan keremoglu and philipp wendler.
.
conditionalmodelchecking atechniquetopassinformationbetween verifiers.
in proc.
of sigsoft fse .
acm.
cristian cadar daniel dunbar and dawson engler.
.
klee unassisted and automaticgenerationofhigh coveragetestsforcomplexsystemsprograms.
inproc.
of osdi .
usenix association berkeley ca usa .
cristiancadarandhristinapalikareva.
.
shadowsymbolicexecutionfor better testing of evolving software.
in proc.
of icse nier hyderabad india .
.
sagar chaki edmund clarke natasha sharygina and nishant sinha.
.
verification of evolving software via component substitutability analysis.
formal methods in system design .
berkeley churchill oded padon rahul sharma and alex aiken.
.
semantic programalignmentforequivalencechecking.in proc.ofpldi .acm new york ny usa .
edmundclarke danielkroening andflaviolerda.
.
atoolforchecking ansi c programs.
in proc.
of tacas .
springer .
christopherl.conway kedars.namjoshi dennisdams andstephena.edwards.
.
incremental algorithms for inter procedural analysis of safety properties.
in proc.
of cav .
springer .
elibendersky.
.
completec99parserinpurepython.
eliben pycparser.
grigoryfedyukovich ariegurfinkel andnatashasharygina.
.
propertydirected equivalence via abstract simulation.
in proc.
of cav .
springer .
dennis felsing sarah grebing vladimir klebanov philipp r mmer and mattias ulbrich.
.
automating regression verification.
in proc.
of ase .
acm .
n. feng v. hui f. mora and m. chechik.
.
cc2.
cc24life cc2.
benny godlin and ofer strichman.
.
regression verification proving the equivalence of similar programs.
j. software testing verification and reliability .
thomas a henzinger ranjit jhala rupak majumdar and marco aa sanvido.
.
extreme model checking.
in proc.
of vstte .
springer .
charles antony richard hoare.
.
an axiomatic basis for computer programming.
commun.
acm .
iso.
.
iso iec programming languages c. jamescking.
.
symbolicexecutionandprogramtesting.
commun.acm .
raghavankomondoorandsusanhorwitz.
.
semantics preservingprocedure extraction.
in proc.
of popl .
.
anvesh komuravelli arie gurfinkel and sagar chaki.
.
smt based model checking for recursive programs.
formal methods in system design .
shuvenduk.lahiri chrishawblitzel mingkawaguchi andhenriquereb lo.
.
symdiff a language agnostic semantic diff tool for imperative programs.
in proc.
of cav .
springer verlag .
shuvendu k. lahiri kenneth l. mcmillan rahul sharma and chris hawblitzel.
.
differential assertion checking.
in proc.
of esec fse .
arunlakhotiaandjean christophedeprez.
.
restructuringprogramsby tucking statements into functions.
information and software technology .
federico mora yi li julia rubin and marsha chechik.
.
client specific equivalence checking.
in proc.
of ase montpellier france .
acm .
raymondh.myersandraymondh.myers.
.
classicalandmodernregression with applications.
vol.
.
duxbury press belmont ca.
suzette person matthew b. dwyer sebastian elbaum and corina s. p as areanu.
.
differential symbolic execution.
in proc.
of sigsoft fse .
suzetteperson guoweiyang neharungta andsarfrazkhurshid.
.
directed incremental symbolic execution.
in proc.
of pldi .
acm .
julia rubin and martin rinard.
.
the challenges of staying together while moving fast an exploratory study.
in proc.
of icse .
.
ondrejsery grigoryfedyukovich andnatashasharygina.
.
incremental upgradecheckingbymeansofinterpolation basedfunctionsummaries.in proc.
of fmcad .
ieee .
james stanier and des watson.
.
a study of irreducibility in c programs.
software practice and experience .
anna trostanetski orna grumberg and daniel kroening.
.
modular demand drivenanalysisofsemanticdifferenceforprogramversions.in proc.
of sas .
springer .