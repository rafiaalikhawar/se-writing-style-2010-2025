pending constraints in symbolic execution for better exploration and seeding timotej kapus imperial college london united kingdom t.kapus imperial.ac.ukfrank busse imperial college london united kingdom f.busse imperial.ac.ukcristian cadar imperial college london united kingdom c.cadar imperial.ac.uk abstract symbolic execution is a well established technique for software testing and analysis.
however scalability continues to be a challenge bothintermsofconstraintsolvingcostandpathexplosion.
in this work we present a novel approach for symbolic execution whichcanenhanceitsscalabilitybyaggressivelyprioritisingexecutionpathsthatarealreadyknowntobefeasible anddeferring all other paths.
we evaluate our technique on nine applications includingsqlite3 makeandtcpdumpandshowitcanachievehigher coverage for both seeded and non seeded exploration.
ccs concepts software and its engineering software testing and debugging.
keywords symbolic execution klee acm reference format timotej kapus frank busse and cristian cadar.
.
pending constraints insymbolicexecutionforbetterexplorationandseeding.in 35thieee acm international conference on automated software engineering ase september virtual event australia.
acm new york ny usa pages.
introduction symbolic execution is a dynamic program analysis technique that has established itself as an effective approach for many softwareengineering problems such as test case generation bug finding equivalencechecking vulnerabilityanalysis and debugging .
even with well engineered tools like klee symbolic execution still faces important scalability challenges.
these fall intotwo broad categories constraint solving and path explosion.
assymbolic execution proceeds the complexity of constraints and the number of paths typically increase often making it difficult to make meaningful progress.
inthiswork weproposeanovelmechanismthataggressively explorespathswhosefeasibilityisknownviacachingorseeding.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september virtual event australia copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
approach tackles both scalability challenges of symbolic execution.
on the one hand it enables more efficient use of solvedconstraints thus reducing the burden on the solver.
and on the other hand it provides a meta search heuristic that gives a way to guide the exploration towards interesting parts of the program.
before presenting our idea we briefly summarise symbolic execution.
we focus here on the egt style of dynamic symbolic execution embodied in tools such as klee which unlike concolic execution tools storepartiallyexploredpathsinmemory.
symbolicexecutionworksbyrunningtheprogramonsomesymbolic inputs which means theycan initiallytake any value as theyareunconstrained.duringexecution ifabranchconditiondepends on a symbolic value symbolic execution queries an smt solver for the feasibility of each of the two branches under the current path conditionwhichisinitiallyempty .ifboththe thenandtheelse branchesarefeasible itforkstheexecutionexploringbothpaths andaddingtherespectivebranchconditionstoeachpathcondition pc .aftereveryfork symbolicexecutionusesasearchheuristicto decidewhatpathtoexplorenext.eachpathexploredinsymbolic execution is encoded by a statewhich keeps all the information necessarytoresumeexecutionoftheassociatedpath pc program counter stack contents etc.
.
thecoreofouridearevolvesaround inverting theforkingprocess.
instead of an expensive feasibility check first and then forking the execution we fork the execution first.
the branch condition is then added as a pending constraint which means its feasibility has not been checked yet.
werefer tostates or paths with pending path constraints as pending states.
the responsibility for feasibility checking of pending path constraints is passed to the search heuristic.
this gives the searchheuristic the capability to decide when and for which states it wantstopaythepriceofconstraintsolving.forexample itcould solve pending states immediately thus restoring the original algorithm or could take into account the estimated cost of constraint solving in its decisions.
in our approach we take advantage of an important characteristic of symbolic execution runs the feasibility of some paths states canbequicklydeterminedwithoutusingaconstraintsolver.there are two common cases.
first modern symbolic execution systems like klee make intensive use of caching and many queries canbe solved without involving the constraints solver .
second symbolicexecutionisoftenbootstrappedwithasetofseeds from which to start exploration these can come from regression test suites or greybox fuzzers in hybrid greybox whitebox fuzzing systems .
by aggressively following paths for whichfeasibilitycanbequicklydeterminedwithoutusingaconstraint solver our approach can minimise the constraint solving 35th ieee acm international conference on automated software engineering ase algorithm standard symbolic execution.
setstates function fork state s symexpr condition ifissat s.pc condition issat s.pc condition then falsestate s falsestate .pc s.pc condition s.pc s.pc condition searcheradd s falsestate end if end function function searcheradd state s1 states2 states states s1 s2 end function function searcherselect returnsearchheuristic states end function costs as well as provide an effective exploration of the program search space.
therestofthepaperisorganisedasfollows.in 2wepresent in detail the design of our technique.
then in we give further implementation specific details in the context of building our technique in klee.
we finally evaluate our approach in discuss related work in and conclude in .
algorithm algorithm presents in simplified form the forking and search heuristics components of the standard symbolic execution algorithm.
the symbolic executor is exploring program paths encoded as a set of states line .
as discussed before a state keeps track of alltheinformationnecessarytoresumeexecutionoftheassociated path program counter stack contents etc.
and particularly its path condition pc.
when a symbolic state sencounters a symbolic branchcondition the fork function is called line .
forkfirstchecksifthe condition canbeboth trueandfalseunder thecurrentpathcondition line4 .ifso thestateisduplicatedintoa falsestate line5 whichwillbethestaterepresentingtheexecution of the false branch.
the path conditions of the two states are then updatedaccordingly lines6and7 andthenewstateisaddedtothesetofstatesofthesearchheuristicbycallingsearcheradd line8 .
if thecondition cannot be both true and false the path condition is notupdatedand scontinuestoexecutetheonlyfeasiblesideofthe branch the updates to the program counter are omitted for ease of exposition .
after each instruction the symbolic executor calls searcherselect lines16 toselectthestatetobeexecutednext.inthecase of standard symbolic execution searcherselect simply forwards calls to the searchheuristic.
for instance the search heuristic mightchoosestatesaccordingtodepthorbreadth firststrategies or randomly pick a state.
below we introduce the three search heuristics which we explore in this project depth first search is a standard graph traversal algorithm that explores states as deep as possible before backtracking.algorithm symbolic execution with pending constraints.
setfeasiblestates pendin states function fork state s symexpr condition feasiblestates feasiblestates s s.pendin condition condition falsestate s falsestate .pendin condition condition searcheradd s falsestate end function function searcheradd state s1 states2 foreachstates s1 s2 do iffastissat s s.pc s.pendin condition then s.pc s.pc s.pendin condition s.pendin condition feasiblestates feasiblestates s else pendin states pendin states s end if end foreach end function function searcherselect whilefeasiblestates do s searchheuristic pendin states ifissat s.pc s.pendin condition then s.pc s.pc s.pendin condition s.pendin condition feasiblestates feasiblestates s end if pendin states pendin states s end while returnsearchheuristic feasiblestates end function random path search introduced in the original klee paper worksby randomlyselecting apath throughtheexecution treeof exploredstates.thealgorithmstartsattherootofthetreeandwith probabilityfollowstheleft handsubtreeand50 probability theright handone.theprocessrepeatsuntilaleafstateisreached which is selected for further exploration.
by design this search heuristic favours states closer to the root of the execution tree.
depth biased search is a form of non uniform random search provided by klee.
it works by randomly selecting states weighted bytheirdepth thehigherthedepthofastate themorelikelyforit tobeselected.bydesign thissearchheuristicfavoursstatesdeeper in the execution tree.
.
pending constraints algorithm note that the calls to issat in standard symbolic execution are potentiallyvery expensiveandthusare theoptimisationtargetof our proposed approach.
algorithm shows the same three functions in the pending constraintsversionofsymbolicexecution.inthisversion wemaintaintwodisjointsetsofstates feasiblestates whichstoresregular states which we know are feasible and pendingstates which stores pending states for which feasibility is still unknown line .
116algorithm fast satisfiability checking.
function fastissat state s symexpr condition assi nments getassignmentsforstate s foreachassignment a assi nments do ifsubstitute a condition truethen returntrue end if end foreach returnfalse end function in our version of fork the issat feasibility checks are skipped and executionis forked unconditionally.
first we remove thecurrent state sfrom the list of feasiblestates line and assign the condition to a special pending condition field associated with s line5 .second weduplicate sintoanewstate falsestate line6 and assign the negation of condition to its pending condition field line .
when a state becomes pending as sandfalsestate here it means that it should not continue execution until its pending conditionischeckedforfeasibility.wecalltheprocessofcheckingthe pendingconditionandaddingittothepathconditionas reviving the state.
finally we call searcheradd line to let the searcher decide whatto dowith thenewly createdpending states.for eachof the twostates searcheraddcheckswhetherthependingcondition is feasible using a fast satisfiability checker line .
if so the pending condition is added to the path condition line thependingcondition field is reset line and the state is added to the set of feasiblestates line .
if the fast satisfiability check is unsuccessful the state is added to the set of pendingstates line .
the fast satisfiability solver is discussed in .
.
the searcherselect function operates as in standard symbolic execution as long as there are feasible states available line .
however whenallthefeasiblestateshavebeenexhausted itkeeps picking a pending state line until it finds one that can be revivedsuccessfully.thisisdonebyaskingthesolverwhetherthe pendingconditionisfeasible line26 andifso byaddingthepending condition to the state s path condition line clearing the pendingcondition field line28 andaddingthestatetothesetof feasiblestates line .
.
fast satisfiability checking asdiscussedintheintroduction thefastsatisfiabilitycheckerrelies onthefactthatweoftenhaveexistingassignments solutions to symbolic constraints.
there are two common scenarios that occur inpractice first modernsymbolicexecutionenginesuseasmart form of caching to speed up constraint solving .
.
and second symbolic exploration often starts with a set of seeds .
.
.
algorithm shows the fast satisfiability checking algorithm.
moreformally an assignment isamappingfromsymbolicvariables toconcretevalues e.g.
x y .thesubstitutefunction takes a symbolic condition and an assignment and evaluates theconditionundertheassignment line4 .thatis itsubstitutesallthe symbolic variables in the condition with the values specifiedin the assignment.
if all the symbolic variables in the expressionare mapped by the assignment substitute will return a concrete value either trueorfalse .
otherwise it will return false.
fastissatfirstgetsalltheassignmentsassociatedwiththegiven stateusingthegetassignmentsforstatefunction line2 wewilldiscusshowthisfunctionworksbelow.theconditionisthenevaluated on every assignment returned by getassignmentsforstate and if the evaluation results in true fastissat returns successfully line5 .ifnoneofthereturnedassignmentssatisfythecondition then fastissat returns unsuccessfully line .
.
.
caching.
when issuing satisfiability queries to the solver modern symbolic execution engines typically also ask for a sat isfying assignment when the query is satisfiable.
this is becausecaching these assignments can be highly effective .
in thiswork wesimilarlyusecachedassignmentstoimplementour fast satisfiability checks.
substituting all assignments that were returned bythe core solver at anyprevious point inthe execution can be expensive and here we want to ensure the check is fast.
so instead weusethesamemechanismusedbyassignmentcaching in klee and have getassignmentsforstate line return only theassignmentsassociatedwithasubsetofthepathconditionof states.
the idea behind the pending constraints approach is to use existing assignments as long as it is possible and only ask forexpensive new solutions when absolutely necessary.
as a result thesearchgoesdeepintotheexecutiontree becauseitexploresthe solutionsithastocompletion.therefore combiningthisstrategy with a search heuristic that goes wide when picking a pending state can be really effective.
note that the search heuristics thatoften perform best such as random path search tend to behavelike this .
another way of understanding our approach is as a meta searcherthatenhancesagivensearchheuristic enablingittoexplore deeper parts of the program.
intuitively this is achieved by picking a path and sticking to it while normally the same searcher wouldkeepchangingbetweenpaths.importantly thepathitsticks to issues no additional queries to the smt solver and therefore completes quickly.
tomake things more concrete consider the program in figure withdfs friendly undefined.
it has two symbolic variables a booleanisspace and a string str.
it first branches on isspace on line and writes space as the first character of stron the thenbranch or a zero on the elsebranch.
the two loops between lines then introduce a large number of symbolic branches.
aftertheseloops itcomputesthefifteenthfibonaccinumberusing an inefficient recursion.
this represents some large concrete workload.finally weassert isspaceisfalse.notethatreachingthis assertionfailureonlydependsonthefirstbranchandiscompletely independent of the large number of paths spawned in the loops.
vanilla klee executes around million instructions taking around seconds to reach the assertion failure using the ran dom path search strategy.
by contrast the pending constraints approach executes only around 67k instructions taking less than a second.thereasonisthatvanillakleeneedstocomputealarge numberofsolutionstothesymbolicbranchesintheloops which arenotneededtofindtheassertionfailure.whereasthepending constraints approach only needs one solver solution for str.
because random path search is the underlying search strategy it is 1171unsigned fib unsigned n if n return0 if n return1 returnfib n fib n 7intmain boolisspace 9klee make symbolic isspace sizeof isspace isspace charstr 11klee make symbolic str sizeof str str ifndef dfs friendly if isspace str elsestr else if isspace str elsestr endif for inti i i for charj j str j str 2425fib 26assert !isspace return0 figure an example program where pending constraints find the failing assertion faster.
also more likely to pick the pending states produced by the branch on line as it is closer to the root of the process tree.
note that dfs reaches our one hour timeout in this case.
however it performs similarly to the pending states if the order of branches on line is swapped by defining dfs friendly .
with dfs friendly defined both pending states and upstream klee find the assertion in about 33k instructions.
this shows that while dfs can be as efficient it is highly dependent on the order of branches unlike the pending constraints approach.
.
.
seeding.
a seed is a concrete input to a program which is giventosymbolicexecutiontobootstrapexploration.aseedcan make symbolic execution of the program easier for two reasons.first it is used to guide symbolic execution toward parts of theprogram that are executed by real inputs.
second it provides a solutionforcomplexpathconstraints thereforeremovingtheneed for expensive constraint solving.
seeding has been shown to be effectivewhensymbolicexecutioniscombinedwithregressiontest suites as well as when it is integrated with a greybox fuzzer .
our pending constraints approach can be easily extended to supportseeding.infastissat wemodifythegetassignmentsforstate function to return the seeds as assignments line .
as a result onlythe states that satisfythe seeds arefollowed first and there are no calls to the smt solver until all the paths followed by the seeds are explored.
in this use case pending states represent thepossibledivergencesfromtheseeds fromwherewecanpick up exploration once the seeding is completed.when seeds areavailable random path search is unlikely to be themosteffectivestrategy.oncethepathsfollowedbytheseeds arecompleted randompathsearchwouldpickastateveryclose to the start of the program as the probability of picking a state halvesateverysymbolicbranch.thismeansthattheexploration will behave similarly as to when no seeds are available.
ontheotherhand depth biasedsearchwouldmostlikelypicka state toward the end of the path executed by the seeds meaning it willstarttoexplorepathsthatareveryhardtoreachfromthestart oftheapplication.inotherwords itbenefitsfromtheseedandcan start exploring code out of reach of normal symbolic execution.
however there are two limitations to this search heuristic.
first bydesign thisstrategymissescodethatiseasytoreachfromthe start of the program.
therefore it is best combined with a more wide reachingstrategysuchasrandompathsearch.second this heuristic is more likely to select pending states that are infeasible asthepathconditionsforthosestateshavemoreconstraintsand thus the pending condition is more likely to be infeasible in that state.
implementation we implemented our approach in klee a state of the art symbolic execution system that operates on llvm bitcode .
our prototype is based on klee commit 0fd707band is configured to use llvm and stp .
.
.
we discuss below some of the most important implementation aspects.
wemakeourprototypeandassociatedartefactavailableathttps srg.doc.ic.ac.uk projects pending constraints and .
m9.figshare.
.
.
fast satisfiability solver klee sconstraintsolvingchainconsistsofaseriesofcachesand other partial solvers finally delegating the query to an externalsmt solver.
for our fast solver we simply used this solver chain without the final potentially expensive call to stp.
seeding is easily implemented with klee s counterexample assignment cache as we simply add the seed to the cache as anadditional assignment at the start of execution.
note that this isdifferent from how vanilla klee implements seeding.
however tomakethecomparisonbetweenvanillakleeandpendingconstraints fair we also added the seed to the cache in vanilla klee.
.
error checks during execution klee performs various checks to find errors.examples include checks for division by zero and out of boundsmemory accesses.
one option would be to treat these checks as we treat regular branches and create pending states.
however that would mean that errors wouldn t be caught as soon as that code is covered asinvanillaklee andinfacttheymightneverbecaught if those pending states are killed later on due to memory pressure .
therefore we treat these checks specially by always performing them instead of creating pending states.
however ifhighercoverageismoreimportantthanbugfinding deferringthesecheckstopendingstatesmightmakemoresense.
therefore we also run our benchmarks without these checks in a 118version that we call pending constraints with relaxed checks.w e explore this version in .
and observe significant coverage gains.
.
branching without a branch instruction in klee there are several cases where forking happens without abranchinstruction.forinstance inthedefaultconfiguration a switchinstructionishandledasabranchwithmultipletargets.this fitslessneatlyinourmodelthereforewesimplyconfigurekleeto lower all switch instructions to a series of if elsestatements.
whenasymbolicpointerisencountered kleescanstheaddress space to find all memory objects to which it can point.
if multiple objects are found it forks execution for each object adding appropriate constraints .
in the default version of our approach we don t create pending states in this case instead we eagerly fork as necessary as in vanilla klee.
however with relaxed checks for eachmemoryobjecttowhichthepointercanrefer thestategets forkedintotwopendingstates onein boundsoftheobjectandthe otheroneout of bounds.thissecondpendingstateencompasses all other resolutions of the symbolic pointer.
.
releasing memory pressure kleeoftenhitsthememorylimitforlargeprogramsduetothevast sizeofthesearchspaceandgenerallybroadsearchheuristics .
when exceeding the memory limit klee terminates a number of randomly chosenstatestogetbackbelowthememorylimit.we could follow the same approach with pending constraints but this could delete both feasible and infeasible pending states.
feasible pending states potentially represent large parts of the search space and we should avoid their termination.
by reviving pending states we can select and terminate infeasible pending states.
but this comesataprice asrevivingstatesrequiresexpensiveconstraint solving.
in our implementation we decided to stop reviving states when the remaining number of pending states equals the number of states we still need to terminate to fall below the memory limit.
atthatpoint westarttorandomlychoosestatestoterminateasin vanilla klee.
evaluation ourevaluationisstructuredasfollows.wepresentourbenchmarksin .1andexplainwhyweevaluatedthemoninternalcoveragein .
.weevaluatependingconstraintsontheirabilitytoenhance symbolic execution in a non seeding context in .
and then in a seeding context in .
.
we also evaluate the version with relaxed checks in .
.
finally we discuss our approach in further detail in .
via a case study on sqlite3.
we run all experiments in a docker container on a cluster of identical machines with intel i7 .60ghz cpu 16gib of ram and ubuntu .
as operating system.
we repeat our experimentsthreetimesandwherepossibleplottheaverageand the minimum and maximum as an interval.
in cases where wecombineexperiments there arenointervalsshownaswemerge all the repetitions.
.
benchmarks our aim is to demonstrate the capability of pending constraints to increasetheexplorationpotentialofsymbolicexecution.therefore we chose benchmarks that are challenging for symbolic execution.
sqlite31isoneofthemostpopularsqldatabasesystems.we used version .
.
via its default shell interface with symbolicinput and without custom drivers.
however we adjusted somecompile time flags such as simplifying the allocation model to make it easier for symbolic execution.
magick2is a command line utility for performing various operationsonimages.weusedversion7.
.
68intwoconfigurations converting symbolic jpeg images to png images and back which makes use of libjpeg3andlibpng4.
tcpdump5is used for capturing and printing network packets.
weusedversion4.
.0toprintinformationfromasymboliccapture file.
gnu m46isamacroprocessor.weusedversion1.
.18toprocess a symbolic file.
gnu make7is a widely used build system.
we used version .
on a symbolic makefile.
oggenc8is a tool from the ogg vorbis audio compression formatreferenceimplementation.weusedversion1.
.0toconverta symbolic .wavfile to the .oggformat.
gnu bc9isanarbitraryprecisioncalculator.weusedversion1.
on symbolic standard input.
gnu datamash10isatoolforperformingcommand linecalculationsontabulardata.weusedversion1.5bothwithsymbolicinput and symbolic arguments.
table1givesamoredetailedoverviewofthebenchmarks showing their size arguments we used and a brief description of the seeds.theprogramsizeismeasuredintermsofllvminstructions asreportedbyklee.thethirdcolumnshowstheargumentswe usedtorunthebenchmarks.theargumentsprefixedwith symare replacedwithsymbolicdata.forexample sym arg3 isreplaced with a three character symbolic argument sym stdin is a 20byte symbolic standard input stream and sym file100 creates a file named awith bytes of symbolic content.
thelasttwocolumnsoftable1giveanoverviewoftheseeds we used.
where possible we give the exact data used as in the case ofbc.
however in the case of magickand similar utilities that wouldnotbetooinformative sowegiveinsteadabriefdescription of the seed.
we took the smallest valid files from some seeds were padded with zeroes as necessary to make the seed size match the number of symbolic bytes as specified by the arguments.
figure shows the percentage of time spent in the solver by vanillakleeonourbenchmarks on2 hourruns usingdifferent 119table overview of symbolic arguments and used seeds for our benchmarks.
the benchmark size is given as number of llvm instructions in the bitcode file.
benchmark size arguments seed set s1 seedset2 s2 bc sym stdin x sqrt x datamash sym arg sym arg sym arg sym arg sym stdin sum mean on a3 3matrix md5 sha1 on2 3matrix m4 g h37 sym arg sym arg sym stdin g dm withm is m also m is b g dm withifdef m ha nah magickjpg1 jpeg fd png fd sym stdin smallest valid jpeg file 1jpeg image created with gimp magickpng1 png fd jpg fd sym stdin smallest valid png file 1png image created with gimp make n f a sym arg sym arg sym file n bfds with info helo ther n bfds witha info a oggenc 142a sym file smallest valid wav file sine wave wav file created by scipy sqlite3 sym stdin select from t create table t i tcpdump r a k n sym file byte captured packet another byte captured packet bc datamashm4 magickjpg magickpngmakeoggenc sqlite3tcpdumprelative solver time rp depth dfs figure relative time spent in the smt solver stp by vanilla klee in our non seeded experiments with the random path rp depth biased depth and dfs strategies.
searchstrategies.ascanbeseen mostofourbenchmarksaresolverbound meaningtheyspentaveryhighproportionoftimeinthe solver forexample bcandmake.datamash istheonlybenchmark thatisnotsolver boundinanysearchstrategyconsidered meaning klee spends very little time constraint solving.
sqlite3is only solver bound with the dfs search strategy.
.
internal coverage vs. gcovcoverage whenmeasuringthecoverageachievedbyvanillakleeandour pendingconstraintsextension wecanuseeithertheinternalcoverage reported by klee or the coverage reported by gcov11when running the test inputs generated by klee.
the internal coverage reported by klee includes the lines of codethatkleeexecutedsymbolically atthellvmbitcodelevel.
bycontrast the gcovcoverageisthecoveragereportedby gcov at the source code level when rerunning the test inputs generated bykleeonaversionoftheprogramcompiledwith gcovinstrumentation.bothapproacheshaveadvantagesanddisadvantages.
4500covered llvm instructionscovered source lines unique faults foundinternal coverage gcov coverage bcoggencdatamashm4 tcpdumpmake sqlite3magick jpgmagick png bcoggencdatamashm4tcpdump makesqlite3magick jpgmagick png figure dual axis scatter plot of internal coverage left yaxis and gcovcoverage righty axis againstthenumberof injected faults found.
on the one hand gcovcoverage has the advantage of being disconnected from klee and llvm often developers just want a tool like klee to generate a high coverage test suite and assess this coverageindependently atthesourcecodelevel.ontheotherhand gcovcoverage includes parts of the program that klee did not executesymbolically thesepartsofcodewerenoterror checked by klee and thus bugs could be missed.
it is important to note herethatwhenkleeperformsanerrorcheck itfindsabugifthere areanyvaluesthatcantriggeritonthatpath.bycontrast atest case that covers the buggy path might not necessarily reveal the bug.therefore ifkleeisusedprimarilytorevealbugs internal coverage is more appropriate.
to illustrate this issue we injected a division by zero error in everybasicblockofsomeofourbenchmarks.thesedivision byzero errors are triggered by a different value in each basic block.
we then run vanilla klee for two hours on these fault injected programs and measure both internal and gcovcoverage.
bc datamashm4 magickjpg magickpngmakeoggenc sqlite3tcpdumpcovered instructions 1000vanilla pending combined a random path bc datamashm4 magickjpg magickpngmakeoggenc sqlite3tcpdumpcovered instructions 1000vanilla pending combined b depth biased bc datamashm4 magickjpg magickpngmakeoggenc sqlite3tcpdumpcovered instructions 1000vanilla pending combined c dfs figure instructions covered by vanilla klee and pending constraints alongside their combination in 2h non seeded runs.
figure shows a dual axis scatter plot of both internal coverage on the left y axis and gcovcoverage on the right y axis against the number of unique injected faults found.
as can be seen internal coverage seems to highly correlate withuniquefaultsfound whereas gcovcoverageshowsnosuch correlation.
we discuss this in more detail in a blog post .
inourwork weobservedthatpendingconstraintsdonotnecessarilyimprove gcovcoverage butsignificantlyimproveinternal coverage.therefore whileacceptingtheformer weshowinour experiments that it can improve the latter and thus report internal coverage in our experiments.
.
non seeded experiments to evaluate pending constraints in a setting without seeds we ran eachofourbenchmarksfor2hourswiththerandompath dfsand depth biasedstrategies.theresultsareshowninfigure4.forsomebenchmarks suchas bcandmake pendingconstraintsconsistently covermoreinstructionsforallsearchstrategies.forothers such asm4andtcpdump therelativeperformanceisdependentonthe search strategy.
ifwelookatthecombinedcoverageofvanillakleeandpendingconstraints weseethatthere issomecomplementarity tothe approaches.for instance whilevanillaklee obtainsbettercoverageform4withthedepth biasedsearch thependingconstraints reachcodethatisnotcoveredbyvanillaklee.overall pending constraints reached and more instructions across ourbenchmarkswithrandompath dfsanddepth biasedsearchrespec tively.theseresultsshowthatpendingconstraintscansignificantly increase the power of symbolic execution on some benchmarks by themselvesand orcoverdifferentpartsofthecodewhencompared to vanilla klee.
therefore they seem to be an effective tool for non seeded exploration in symbolic execution.
comparing the search strategies for pending constraints we observe that for these experiments dfs performs best overall covering more instructions than random path which in turns covers more instructions than depth biased search.
one advantage of the pending constraints approach is that it usuallyspendslesstimesolvingqueriesthatturnouttobeinfeasible.
figure shows the time spent constraint solving queries that turn0 bc datamashm4 magickjpg magickpngmakeoggenc sqlite3tcpdumprelative infeasible query solving timevanilla pending figure5 relativetimespentsolvingqueriesthatwereinfea sible averaged across all three search strategies.
out to be infeasible relative to total constraint solving time.
weaveraged across all search strategies for brevity and clarity.
for mostbenchmarks pendingconstraintsspendsignificantlylesstimeconstraint solving queries that are infeasible.
the only exception issqlite3 where the absolute time spent solving infeasible queries is stilllowerforpendingconstraintsacrossallthreesearchstrategies.
.
seeded experiments to evaluate our approach in the context of seeding we ran both vanillakleeandpendingconstraintsfor2hourswitheachseed fromtable1.bothversionsaregiventheseeds vanillakleeas assignment in the counter example cache and additionally as concrete input.
figure6showsthecoverageachievedbyvanillakleeandpendingconstraints foreachsearchstrategy.coverageresultsforthe two seeds are merged in each configuration.
bc datamashm4 magickjpg magickpngmakeoggenc sqlite3tcpdumpcovered instructions 1000vanilla pending combined a random path bc datamashm4 magickjpg magickpngmakeoggenc sqlite3tcpdumpcovered instructions 1000vanilla pending combined b depth biased bc datamashm4 magickjpg magickpngmakeoggenc sqlite3tcpdumpcovered instructions 1000vanilla pending combined c dfs figure covered instructions by vanilla klee and pending constraints alongside their combination in seeded runs on our benchmarks.eachseedsetisrunfor2hoursineachconfigurationandthecoverageresultsforthetwoseedsarethenmerged.
for some benchmarks such as magickpng sqlite3andtcpdump pendingconstraintssignificantlyoutperformvanillakleeforall search strategies.
for others such as datamash andmake there does not seem to be a large difference.
finally for m4 pending constraintsperformslightlyworsethanvanillaklee.thisisdue to dereferences of symbolic pointers being very common in m4 which do not benefit from pending constraints.
from the combined coverage bars we can observe there is very littlecomplementaritybetweenthetwoapproaches withtheex ception of tcpdump under dfs where the combined coverage is significantly higher.
in this case both runs explore the seed butpending constraints go deeper in the exploration.
we discuss in moredetailtheadvantagesprovidedbypendingconstraintswith seeding in the sqlite3case study of .
.
overall pendingconstraintscover25 moreinstructionswith random path search more with depth biased search and more with dfs.
in the pending constraints experiments depthbiasedsearchcovered2 moreinstructionsoverallwhencompared to random path search which in turn covered .
more than dfs.
figure shows the coverage achieved with only seed set between our pending constraints approach and vanilla klee withthe random path search strategy.
for most utilities we can drawsimilar conclusions as for the experiments of figure where the coverage for the two seed sets is merged.
oggencis an exception as it shows no coverage improvement on only seed set .
.
pending constraints with relaxed checks figure also shows the coverage achieved with relaxed checks for criticalinstructions section3.
.ascanbeseenforsometoolslike bcorsqlite3 relaxingthesecheckscanleadtolargeincreasesin number of covered lines.
in the case of bcthe instruction coverage more thandoubles.
for mostother utilitiesthe increase issmaller but not insignificant with oggenc magickpngandtcpdump being the notable exceptions showing no or small decreases in coverage.
theseresultsshowthatpendingconstraintswithrelaxedchecks can be used to effectively reach deeper into the program but with the downside of errors being missed during exploration.
bc datamashm4 magickjpg magickpngmakeoggenc sqlite3tcpdumpcovered instructions 1000vanilla pending relaxed pending figure7 coveredinstructionsonseedset1ofvanillakleeagainst pending constraints with both strong and relaxedchecks with the random path search strategy.
.
case study sqlite3 to provide more insight into our approach we now discuss one of ourbenchmarks sqlite3 inmoredetail.inparticular welookatthe evolutionofcoverageonlong runningexperimentsandexamine variouspairwisecombinationsofconfigurationstouncoverhow different seeding approaches and search strategies complement each other.
.
.
hour non seeded runs.
we first performed hour experiments with sqlite3without seeding with each of the three consideredsearchstrategies.eachexperimentwasrepeated3times to account for the randomness of the depth biased and random path strategies.
the results are shown in figure 8a.
dfs performs surprisingly well for this benchmark.
however with vanilla klee it achieves no additional coverage after the first 20covered instructions time hours pending dfs pending depth pending rpvanilla dfs vanilla depth vanilla rp a non seeded 20covered instructions time hours pending dfs pending depth pending rpvanilla dfs vanilla depth vanilla rprelaxed depth b seeded figure coverage of sqlite3over a hour run.
the experiments were repeated times represented as lines of the same type.
both non seeded and seeded runs are shown.
hour.
by contrast pending constraints with dfs continue to make progress and end up achieving the highest coverage overall.
we inspected the test inputs generated using dfs to understand whyitperformssowell.vanillakleewithdfsappearstobelucky asitmanagestofindtwoshortkeywords suchas asandby which seem to be located close to the edge of the search space.
these two keywordsarenotfoundbyvanillakleeusingtheothertwosearch strategies.
pendingconstraints with dfsdoes notfind these short keywords but instead finds longer ones such as insert filter vacuumandwindow.thisisnotsurprising asthesearchspaceof pendingconstraintswithdfsisoftenquitedifferentfromthatof regular dfs.
pending constraints with random path gain coverage quickly duetoitsbroaderexploration butmakeslimitedprogressinthelast hours.
pending constraints with the depth biased strategy make littleprogressforalongtime butgainalotofcoveragetowardsthe endofthe run achievingcoveragesimilar tothatofrandompath.
vanilla klee makes steady progress with both search strategies but does not overtake pending constraints.
.
.
hour seeded runs.
we also performed hour experiments with sqlite3with seed set with each of the three considered search strategies.
in addition we also run in this settingpending constraints with relaxed checks using the depth biased strategy.
as in the non seeded runs each experiment was repeated times.
figure8bshowstheresults.theseedcovers37.2kinstructions.
vanillakleeperforms similarlyacrossthethree searchstrategies allthelinesforthevanillakleerunsareatthebottomoffigure8b and never manages to complete the seeded path stalling around 13kcoveredinstructions.itmakesveryslowprogress coveringless than new instructions in the final hours of its run.
this isduetoklee seagerfeasibilitychecks withlargeconstraintsthat take a long time to solve.
our pending constraints approach manages to cover all instructionsontheseededpath.witherrorchecksinplace ittakesupto3 hours to complete the seeded path whereas with relaxed checks it only takes minutes.
there are about memory bounds checks on the seeded path and solving the associated constraints accounts forthemajorityofthetimedifferencebetweentheconfiguration without and with relaxed checks.
note that minutes is still significantly slower than the pure interpretation time of klee on thisinput.
our approach still performs some solving activities suchas computing independent sets and substituting the seed in the constraints.
there is no difference between search strategies in the initial seeding phase as the exploration is guided by the seed.
after pending constraintsfinish withthe seeding theymake littleprogressfor up to several hours.
during this time they are attempting to revivependingstates mostofwhichareinfeasibleandtherefore killed thusgivingnoadditionalcoverage.finally dependingonthe search strategy a feasible state is revived leading to the execution of a different path potentially giving large coverage gains.
the depth biased search which picks good states to revive in outof3ofourruns achievessignificantnewcoverage.however random path search outperforms the depth biased search in all of the runs and seems to generally achieve higher coverage.
due to determinism ofdfs there isno difference betweenits runs.
they all achieve coverage in between the random path and depth biased search strategies.
weinspectedthegeneratedtestinputsforthedepth biased dfs and random path runs.
the test inputs generated by the depthbiased runs were mostly very similar to the seed with only a small 123figure heatmaps of coverage combination pairs for vanilla klee lower triangle and pending constraints upper triangle for sqlite3.
number of characters changed e.g.
select temp .
.
instead of the seed select from t .12even when it manages to find new keywords such as filter having update vacuum and window thetestinputisclosetotheinitialseed e.g.
update from t .... .
similarly dfs generated test inputs are almost identical totheseed withonlythelast2characterschanginginadepth first fashion.
the random path search strategy on the other hand also findsseveralmorenewkeywords suchas before having insert filter andvaccum but diverges early from the seed and finds additional keywords by exercising different code in the parser e.g.
.
.c.... explain.... .
this difference between the generated test inputs across the three search strategies is expected as depthbiased search and dfs pick states towards the end of the path where the seed has a greater impact.
.
.
pairwise coverage combinations.
finally wewantedtoexplore how the different combinations non seeded seeded with seed sets and and different search strategies complement each other.
therefore we looked at the pairwise combinations of coverage for hour runs of each configuration.
we decided to omitshowing the dfs runs in this case to illustrate the complementaryaspectsofseedingversusnon seedingrunsmoreclearly.as showninfigure4c dfsisreallyeffectivein sqlite3withoutseeds.
the union of non seeded dfs and other approaches cover only 100moreinstructionsthandfsby itself.however we notethat dfs is not always the best performing strategy as shown by other benchmarks.
12inputsshorterthanthespecifiedsymbolicinputsizearepaddedwith 0andnewlines n r are shown as .
analysing this amount of data is hard so we devised the visualisationinfigure9 whichshowspairwisecomparisonsofcombined coverageacrossthe6differentconfigurationsfor sqlite3.thelabels indicate the search strategy used and the seed set is indicated in the subscript.
un subscripted labels indicate non seeding runs.
the figure consists of three different heatmaps.
the upper right triangle red shows the coverage achieved by pending constraints.
the lower left triangle green shows the coverage achieved by vanillaklee.thediagonal blue showstheratiobetweenpending states and vanilla for non combined runs.
the data in the two triangles is normalised with respect to their upper left corner that isthe2hdepth biasedrunwithoutseeds.thehypotenusesofthe triangles therefore show the non combined coverage.
as this graphic is dense with information we will walk through acoupleofexamples.lookingatthetop leftcornerofourtriangles weseethatbothpendingandvanillakleewithdepth biasedstrategyhavethevalueof1 .
thisisbecauseeverythingisnormalised tothisvalue.however theblue1 .82valuetellsusthatourpending constraintsapproachcovered82 moreinstructionsthanvanilla klee with depth biased search strategy.
nowfocusingontwoconfigurationsfromthelowergreentriangle depth biased without seeds and depth biased with seeds for vanilla klee.
the coverage of the run with a seed from set is .
higher thanthat ofthe non seededrun whilethe combined coverage of both achieve .
more coverage.
this indicates that there is complementarity between the coverage achieved with and without a seed.
lookingatthesame2combinationsintheupperredtriangle we can see that with pending constraints seeding with set achieves .
morecoveragethanthenon seedingrun.furthermore theircombinationachieves97 .
morecoveragethansolelythenon seedingrun.thatindicatesagainthatthereiscomplementarity between seeding and non seeding runs as with vanilla klee.
therandompathsearchstrategywithoutseedingachievesmore thantwicethecoverageofthedepth biasedsearchstrategyinboth vanillaklee .
andwithpendingconstraints .
.however pendingconstraintscover129 .
morelinesthanvanillaklee.
there is also some complementarity of coverage between depthbiased search and random path with pending constraints.
their unioncovers217 .
moreinstructionsthanjustdepth biased asopposedto211 .
achievedbyrandompath.vanillaklee behaves similarly.
finally looking at the union of coverage between non seeded andseededruns wecanseethatforpendingconstraintsseeding complementswellwithdepth biasedexploration achievingover points .
to .
and .
to .
more coverage when combined.
with random path we don t see any such complementarity .
.
vanilla klee follows a similar pattern.
.
zesti zesti isapromisingextensionofkleethatcombinesegtstyle symbolic execution with seeding via regression test suites.
unfortunately its original implementation was never upstreamed partly because it is quite large and intrusive.
in this section we showthatpendingconstraintscanbeusedtobuildalightweight and effective version of zesti.
124zesti consists of several parts.
the two most important ones aretheabilityto useavarietyofinputsasseedsand thesocalled zestisearcher whosepurposeistoexplorepathsaroundsensitive instructions.
the idea of the zestisearcher is to take a single seedandexecuteittocompletion whilerecordingsensitiveinstructions and divergence points.
a divergence point is a symbolic branch where the path not taken by the seed is feasible.
zesti then starts bounded symbolic execution from the divergence point closest to a sensitiveinstruction.itthenmovestothenextclosestdivergence point and so on.
re implementingzestiontopofpendingconstraintsisstraightforward.
consider a symbolic execution run with pending constraints after a single seed has been executed to completion.
there are no normal states and many pending states representing thedivergence points described above.
the zesti searcher is implementedbyconsideringpendingandnormalstatesseparately.we prioritise normal states but only if their depth does not exceed the depth ofthe lastrevived pendingstate plussome bound.pending states are revived in the order of distance to sensitive instructions.
this is equivalent to the zesti searcher and is easy to implement.
for simplicity our implementation currently considers only memory accesses as sensitive instructions.
wefoundthebenchmarksusedforevaluationtobetoohardfor zesti.
for example as seen in .
.
it takes hours to executea simpleseedwith sqlite3.
thusrunning thewhole testsuite of sqlite3andexploringasignificantamountofpathsaroundaseedis impractical.
therefore we chose three tools that klee can execute more comfortably dwarfdump13 readelf14andtar15.
these are inspired by the original zesti paper where we replaced gnu coreutils withtaras recent modifications in the coreutils build system make it harder to use with zesti.
to capture the seeds we replaced each binary with a script and ran the application test suite.
we then removed large seeds of over .1mib to keep the execution time associated with an individual seedshort.thisresultedin1273 313and5seedsfor dwarfdump tarandreadelfrespectively.
since we wanted to run each seed for minutes as per the original zesti paper and keep the overall time under hours we ran at most seeds per benchmark.
these experiments found one bug in dwarfdump16and one in tar17which have already been confirmed and fixed by the developers.bothofthesebugswerefoundbythezestisearcherandwere not triggered by the original seed.
vanilla klee seeded with the seed zesti mutated was not able to find these bugs with a hour timeout.
related work concolic executors such as crest dart o rs a g e also drive each test input to completion which is similar to the behaviour of pending constraints.
however these tools suffer from thedisadvantagesofconcolicexecutorssuchasre executingpath prefixes and exploring a single path at a time.
our approach brings june update dd1a6bd37a0d57eb4f002f01f49c51fa5c6bb104some of the strengths of concolic execution to egt style tools like klee while maintaining their advantages.
klee hasanexistingseedingmechanism whichisalsoused byzesti andkatch .however whenfollowingaseed kleeeagerlyperformsfeasibilitychecksateverysymbolicbranch unlike pending constraints which defer these checks for when apending state is revived.
this in turn can have a big impact on coverage as we have shown in .
.
kluzzer awhiteboxfuzzerbasedonklee implements asimilarideaofdelayingthesatisfiabilitychecksbyonlyfollowingthecurrentlysatisfiedbranchgivenbyaseed.however their approach goes further by trading off the benefits of egt style symbolic execution completely and reverting to concolic execution.
uc klee introduces lazy constraints.
here the executor continuesexploringpathsalthoughtheunderlyingconstraintsolver can t determine the feasibility in a given amount of time.
the corresponding expensiveconstraint is addedas lazyconstraint to the respective path condition and only evaluated when some goal is satisfied e.g.
a bug is found to suppress false positives.
this leads to more states in memory and thus to more solver queries but can also reduce the overall solver time as the additional constraints alongsuchpathsnarrowdownthesolutionspacefortheconstraint solver.
our approach explores a different design point which alwaysfavoursstatesthatareknowntobefeasible eitherviacaching or seeding and when just pending states are left they are only explored further if they are determined to be feasible.
hybrid fuzzing approaches such as driller qsym o r savior passconcreteinputsbetweenagreyboxfuzzeranda symbolicexecutor.theseapproachescoulddirectlybenefitfrom pendingconstraintstoachieveatighterintegrationbetweenfuzzing and symbolic execution.
conclusion we have presented pending constraints a strategy that achieves a moreefficientuseofconstraintsolvingandadeeperexplorationof programs with symbolic execution.
the key idea is to aggressively follow paths that are known to be feasible either via caching or seeding while deferring all other paths by storing states withpending constraints.
weimplemented this approach in klee andevaluated it on nine hard benchmarks including make sqlite3 andtcpdump.ourevaluationshowsthatpendingconstraintscan significantly increase the coverage achieved by symbolic execution in both seeded and non seeded exploration.