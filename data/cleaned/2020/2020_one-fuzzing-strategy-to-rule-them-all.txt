one fuzzing strategy to rule them all mingyuanwu southernuniversityof science and technology shenzhen china and the university of hong kong hong kong china mail.sustech.edu.cnling jiang jiahong xiang southernuniversityof science and technology shenzhen china mail.sustech.edu.cn11812613 mail.sustech.edu.cnyanwei huang zhejianguniversity hangzhou china huangyw zju.edu.cn heming cui theuniversityof hong kong hongkong china heming cs.hku.hklingming zhang universityof illinois urbana champaign usa lingming illinois.eduyuqun zhang southernuniversityof science and technology shenzhen china zhangyq sustech.edu.cn abstract coverage guided fuzzing has become mainstream in fuzzing to automatically expose program vulnerabilities.
recently a group of fuzzers are proposed to adopt a random search mechanism namely havoc explicitlyorimplicitly toaugmenttheiredgeexploration.
however they only tend to adopt the default setup of havocas an implementation option while none of them attempts to explore its power under diverse setups or inspect its rationale for potential improvement.
in this paper to address such issues we conductthe first empirical study on havocto enhance the understanding of its characteristics.
specifically we first find that applying the default setup of havocto fuzzers can significantly improve their edge coverage performance.
interestingly we further observe that even simply executing havocitself without appending it to any fuzzercanleadtostrongedgecoverageperformanceandoutperform most of our studied fuzzers.
moreover we also extend the execution time of havocand find that most fuzzers can not only achievesignificantlyhigheredgecoverage butalsotendtoperform similarly i.e.
their performance gaps get largely bridged .
inspired bythefindings wefurtherpropose havoc mab whichmodelsthe havocmutation strategy as a multi armed bandit problem to be solved by dynamically adjusting the mutation strategy.
the evaluationresultpresentsthat havoc mabcansignificantlyincreasethe edgecoverage by11.
onaveragefor allthe benchmarkprojects comparedwith havocandevenslightlyoutperformstate of the art qsym whichaugments itscomputing resourceby adoptingthree parallel threads.
we further execute havoc mabwith three parallel mingyuan wu is also affiliated with the research institute of trustworthy autonomoussystems shenzhen china.
yuqun zhang is the corresponding author.
he is also affiliated with the research institute of trustworthy autonomous systems shenzhen china and guangdong provincial key laboratory of brain inspired intelligent computation china.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may21 pittsburgh pa usa association for computing machinery.
acm isbn ... .
and result in higher average edge coverage over qsym upon all the benchmark projects.
acm reference format mingyuan wu ling jiang jiahong xiang yanwei huang heming cui lingmingzhang andyuqunzhang .
.onefuzzingstrategytorule themall.in 44thinternationalconferenceonsoftwareengineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction fuzzing or fuzz testing refers to an automated software testing methodology that inputs invalid unexpected or random data to programs for exposing unexpected program behaviors such as crashes failing assertions or memory leaks which can be further inspected or analyzed to detect potential vulnerabilities bugs .
in particular many existing fuzzers tend to facilitate their vulnerability bugexposureviaoptimizingcodecoverageofprograms .
given an initial collection of seeds such coverageguidedfuzzersusuallydevelopstrategiestoiterativelymutatethem forgeneratingnew seeds that can trigger higher code coverage.
notably anumberofrecentcoverage guidedfuzzers e.g.
afl afl mopt qsym andfairfuzz integrate alightweightrandomsearchmechanismnamely havoc1totheir respective fuzzing strategies for increasing their code coverage.
forinstance weobservethatwhilethemajorfuzzingstrategyof fairfuzz can explore 12k program edges within around hours its adopted havoccan explore .8k program edges within only around3hours.incontrasttomanyexistingfuzzerswhichadopt only onemutator under eachiterative execution havocrandomly selectsmultiplediversemutators e.g.
flippingasinglebitandinserting deletingarandomly chosencontinuouschuckofbytes and applies them altogether for generating one seed during each iteration.
typically under each iteration havoccan be integrated with fuzzerseithersequentially i.e.
executing havocupontheseedscollected after executing their major fuzzing strategies or in parallel i.e.
executing havocand their major fuzzing strategies at the same timein different processes threads upon their seed aggregation.
1while such mechanism may have different names according to different fuzzing papers we adopt havocfollowingafl.
.
ui oufsobujpobm pogfsfodf po 4pguxbsf ohjoff sjoh authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may21 pittsburgh pa usa mingyuan wu ling jiang jiahong xiang yanwei huang heming cui lingming zhang and yuqun zhang although havochas been widely adopted by existing fuzzers they tend to include havoconly as an implementation option without further investigating its rationale or exploring its potentials.
forinstance afl afl andfairfuzzsimplyadopt havocasan additional mutation stage and qsym utilizes havocto generate seeds for its concolic execution to increase code coverage.
that said they simply adopt havocunder its default setup i.e.
none of the prior work attempt to study the impact of different havoc settings exploredifferentwaystointegrate havoc orfurtherboost thehavocstrategyitself.
inthispaper weconductthefirstcomprehensivestudyof havoc to unleash its potential.
in particular we first collect recent binary fuzzers and the pure havoc i.e.
applying havoconly without appending it to any fuzzer as our studied subjects and construct a benchmarkbycollectingtheirstudiedprojectsincommon.then weconduct anextensivestudy toinvestigate howenabling havoc inthestudiedsubjectscanimpacttheirperformance e.g.
codecoverageandbugexposure .ourevaluationresultsindicatethatfor allthestudiedfuzzers appending havoctothemunderitsdefault setup can significantly increase their edge coverage upon all the benchmark projects from .
to .7x on average.
meanwhile we alsofindthatevendirectlyapplyingthepure havoconlycanresult in surprisingly strong edge coverage and significantly outperform mostofourstudiedfuzzers.moreover whiledifferentfuzzerscan achievequitedivergentedgecoverageresults applying havoctothe studiedfuzzersundersufficientexecutiontimecaningeneralnot onlysignificantlyincreasetheiredgecoveragecomparedwiththeir defaulthavocintegration butalsostronglyreducetheperformance gapoftheiredgecoveragewhenapplyingtheiroriginalversions.
lastly havoccan also help all the studied fuzzers expose more uniquecrashesthantheircorrespondingmajorfuzzingstrategies.
inspired by our findings we propose an improved version of havocnamelyhavoc mab whichmodelsthe havocmutation strategy as a multi armed bandit problem mab to be further solvedbydynamicallyadjustingthemutationstrategy.theevaluation results indicate that under hour execution havoc mab canoutperformthepure havocsignificantlyby11.
intermsof edge coverage on all the benchmarks on average.
havoc mabcan also slightly outperform state of the art qsym which augments its computing resource by adopting three threads in parallel.
moreover wealsodesign havoc3 mabbyexecuting havoc mabwiththree threads in parallel.
the evaluationresult indicates that havoc3 mab canoutperformstate of the artqsymby on average.
to summarize this paper makes the following contributions weextensivelystudytheperformanceimpactbyapplying havocto a set of studied fuzzers on real world benchmarks.
we find that applying havoccan substantially improve edge coverage and crash detection for all the studied fuzzers.
weproposealightweightapproach havoc mabbasedonour findings which can boost the pure havocby .
under a hour execution and outperform all the other studied fuzzers.
background havocwas first proposed in afl and later further adopted by many other fuzzers .
while their adoptions ofhavoccan be slightly different they typically integrate havocwith theirmajorfuzzingstrategies i.e.
thecorefuzzingstrategies for theiriterativeexecutions i.e.
undereachiteration havocrepeatedly mutates each seed provided by or aggregated to its own seed collection from executing the major fuzzing strategy via applying multiplerandomlyselectedmutators simultaneously.
figure1 presents the basic workflow of havoc.
for each seed in the seed corpus havocfirst determines the count of its mutations based on the real time seed information e.g.
queuing time of seeds and the existing interesting seed number i.e.
the number of the seeds which can explore new edges defined by afl .
next each time when mutating a seed havocimplements mutator stacking i.e.
mutating it by randomly applying multiple mutators e.g.
for afl mopt etc.
in order from a set of mutators.
note that havoc usuallyenablesamaximumsizeofsuchmutatorstack e.g.
128for afl mopt etc.
and one mutator can thus be selected multiple timeswhenmutatingagivenseed.ifthegeneratedmutantis interesting i.e.
exploringnewedges itwillbeincludedasaseed for further mutations.
havocrepeats such process until hitting the mutationcount.accordingly itsfuzzercanresumetheexecution of its major fuzzing strategy when needed.
seed mutator stackinghavoc mutationseed corpus .c program llvm instrument yestrigger new edge?
gger new ed discardnoedge coverage mutant unit unit unit mutant unit chunk unit mutant chunk unit chunk figure the framework of havoc table mutation operators defined by havoc type meaning mutator bitflipflip a bit at a random position.bitflip interesting valuesset bytes with hard coded interesting values.interest interest interest arithmetic increaseperformaddition operations.addition addition addition arithmetic decreaseperformsubtraction operations.decrease decrease decrease random valuerandomly set a byte to a random value.random byte delete bytesrandomly delete consecutive bytes.delete chunk bytes clone insert bytesclone bytes in otherwise insert a block of constant bytes.clone insert chunk bytes overwritebytesrandomly overwrite the selected consecutive bytes.overwrite chunk bytes authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
onefuzzingstrategyto rule them all icse may21 pittsburgh pa usa .
mutators and mutator stacking table presents the details of havocmutators.
note that in the mutator column thenumberfollowedbythemutatornamerefers tothebit wisemutationrange.forinstance bitflip refersto flippingonerandombitatarandomposition.toourbestknowledge mostfuzzers enableatotalof15mutators forhavoc.inthispaper wecategorizethemintotwodimensions unitmutators labeledinredintable1 and chunkmutators labeled inblue .ingeneral unitmutators refertomutatingtheunitsofdata storage in programs e.g.
bit byte word.
for example applying the bitflip mutator in table can flip a bit i.e.
switching between and1.meanwhile chunkmutators tendtomutateaseedinterms of its randomly chosen chunk.
for instance the delete bytes mutator in table first randomly selects a chunk of bytes in the seed and then deletes them altogether.
whilemanyfuzzers mainlyapplyonemutator toaseedeachtime havocenablesmutatorstackingtostackand apply multiple mutators on a seed to generate one mutant each time.
typically havocfirst defines a stacking size for the applied mutatorswhichisusuallyrandomlydeterminedbythepowerof twotill128 i.e.
... foreachmutation.accordingly havoc can randomly select mutators into the stack where one mutator can be possibly selected multiple times.
eventually all the stacked mutatorsareappliedtotheseedinordertogenerateamutant.note thatwhilemost fuzzersuniformlyselectmutatorsfortheir havoc mopt and afl adopt a probability distribution generated by particleswarmoptimization for havocto select mutators.
.
integration havoccan be typically integrated with fuzzers in two manners.
oneisthe sequential manner i.e.
appending havocasalatermutation stage to their major fuzzing strategies.
for instance afl launches havocupon the seeds generated after applying its deterministicmutationstrategytogeneratemoreseedsundereach iterative execution.
the other is the parallelmanner i.e.
applying havocand the major fuzzing strategy of a fuzzer in parallel.
for instance qsym enables three threads which execute havoc afldeterministicmutationstrategy andconcolicexecution respectively more specifically the first two threads are independentlyexecutedinparallelandtheirrespectivegeneratedseedsare continuouslyaggregated to be used for the concolic execution.
whilehavochas been widely adopted by the aforementioned fuzzers it is simply utlized as an implementation option whilenone of the fuzzers has explicitly explored its potential power e.g.
assessing its mechanism and adjusting its setup.
therefore our paper attempts to explicitly investigate havoc i.e.
extensively assessing its performance impact to fuzzers and its mechanisms forbetterleveragingitspowerandprovidingpracticalguidelines forfuture research.
3havocimpact study .
subjects benchmarks .
.
subjects.
in general we determine to adopt the following types of fuzzers as our study subjects.
first we attempt to include the fuzzers which originally adopt havocto expose how havoccan impacttheirperformance bydefault.
next we alsoattempt to explore the fuzzers which do not originally adopt havocbut can possibly integrate havocunder appropriate effort.
accordingly we can investigate whether and how havoccan be effective in a wider range of fuzzers.
at last we also include the pure havoc i.e.
using onlyoneseedtolaunch havocforgeneratingnewseedswithout appendingittoanyfuzzer foranalyzinghowthepowerof havoc can be unleashed.
note that while there are many existing fuzzers which can meet ourselectioncriteriaabove wealsoneedtofilterthemforselecting the representative ones.
to this end we first determine to limit our searchscope within thefuzzers published inthe top software engineering andsecurity conferences i.e.
icse fse ase issta ccs s p usenix security and ndss of recent years.
furthermore we can only evaluate the fuzzers when their source code are fully available and can be successfully executed.
at last it is rather challengingtointegrate havocwithcertainpotentialfuzzersdueto the engineering concept wise challenges.
therefore in this paper weonlytargetaflvariantsduetotheappropriateworkloadsfor implementing havocforthem.
eventually we select representative fuzzers as our studied subjects including fuzzers with havoc afl afl mopt fairfuzz qsym fuzzers without havoc neuzz mtfuzz and the pure havocitself.
note that such subjects can be rather representative in terms of technical designs i.e.
includingafl based concolic execution based and neuralprogram smoothing based fuzzers.
.
.
benchmarkprograms.
weconstructourbenchmarkbasedon theprojectscommonlyadoptedbytheoriginalpapersofourstudied fuzzers .inparticular weselect12frequentlyused projects out of the papers to form our benchmark for evaluation.
morespecifically wefirstselectall6projectsthatareadoptedbyat least papers then we further randomly select another projects whichare adoptedbyoneortwo papers.theselectiondetails are presented in our github page .
table presents the statistics of our adopted benchmarks.
specifically we consider our benchmark to be sufficient and representative due to following reasons these12benchmarkprojectscover7differentfileformats forseed inputs e.g.
elf jpeg and tiff the sizes of these programs that range from to over 120kloccanrepresentawiderangeofprogramsinpractice theycoverdiversefunctionsincludingdevelopmenttools e.g.
readelf objdump codeprocessingtools e.g.
tiff2bw graphicsprocessingtools e.g.
djpeg networkanalysistools e.g.
tcpdump etc.
.
evaluation setups our evaluations are performed on esc servers with core .
ghz amd epyctm rome 7h12 cpus and gib ram.
the serversrunonlinux4.
.
genericubuntu18.
.theevaluations that involve deep learning model training i.e.
neuzz and mtfuzz are executed with four rtx 2080ti gpus.
we strictly follow the respective original procedures of the studied fuzzers to execute them.
specifically we set the overall execution time budget for each fuzzer hours following prior works .notethatweruneachexperimentfive authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may21 pittsburgh pa usa mingyuan wu ling jiang jiahong xiang yanwei huang heming cui lingming zhang and yuqun zhang table statistics of the studied benchmarks programslocpackage target class readelf elf nm elf binutils .
objdump elf size elf strip elf libjpeg 9c djpeg jpeg tcpdump .
.
tcpdump pcap libxml2 .
.
xmllint xml libtiff .
.
tiff2bw tiff mupdf .
.
mutool pdf harfbuzz .
.
harfbuzz ttf jhead .
jhead jpeg times for obtaining the average results to reduce the impact of randomness.
notably all the studied fuzzers are executed with the programs based on afl instrumentation to collect the runtimecoverageinformation.tothisend weapplytheafl v2.
llvm mode llvm .
to instrument the source code during compilation.
we also follow the instructions mentioned in previous work to construct initial seed corpus.
in particular wecollectinitialseedsfor libjpeg libtiffandjheadfrom afl official seed corpus and for the rest projects from their own test suites.
weadopttheedgecoveragetoreflectcodecoveragewherean edge refers to a transition between program blocks e.g.
a conditionaljump.wethenmeasureitviatheedgenumberderivedbythe aflbuilt intoolnamed afl showmap whichhasbeenwidelyused asaguidancefunctionbymanyexistingfuzzers .
note that the afl authors also refer to such metrics as a better predictor of how the tool will fare in the wild .
.
research questions we investigate the following research questions for extensively studying havoc.
rq1 howdoesthedefault havoc i.e.
thedirectapplication ofhavocwithoutmodifyingitssetupormechanism perform on different fuzzers?
for thisrq we attempt to investigate the performance impact of the default havocused in the studied fuzzers.
rq2 howdoes havocperformondifferentfuzzersunder diverse setups?
for this rq we investigate the performance impactof havocbyenabling havocinthestudiedsubjects underdifferent execution time setups.
.
result analysis .
.
rq1 performanceimpactofthedefaulthavoc.
wefirstinvestigatetheimpactofthedefault havoconthefuzzerswith havoc.as mentioned in section .
there can be typically two default setting types for integrating havocto fuzzers.
for many fuzzers which appendhavocas a later fuzzing strategy to their major fuzzing strategies under each iterative execution havocis launched upon the termination of their major fuzzing strategies and terminated after hitting the mutation count determined at runtime illustratedinsection2 withoutanyspecificexecutiontimecontrolbydefault.
asaresult wecaninferthattheexecutiontimeofthedefault havoc cannot bedeterministic.
onthe other hand for thefuzzers which executehavocand their major fuzzing strategies in parallel the defaulthavocisusuallyexecutedallalongundertheexecutiontime.
therefore itsexecutiontimecanbetypicallyequaltotheoverall executiontime.figure2presentstheexecutiontimedistribution ofallthestudiedfuzzersunderthetotalexecutiontime24hours notethatneuzzandmtfuzz markedinred donothavethe havoc stagebydefault andwillbediscussedlater .wecanobservethat whileafl afl andfairfuzzallowquitelimitedtotalexecution time ofhavocby default i.e.
from .
hour to .
hours mopt and qsym allow much longer execution time for havoc.
note that the default setting of qsym utilizes three threads including the defaulthavoc.thushavocisexecutedinqsymforthewhole24 hoursas mentioned in section .
.
havoc afl afl fairfuzz mopt neuzz mtfuzz qsym .
.
.
magor fuzzing strategy havoc0.
.
h .
.
h .
.
h .
.
h .
.
h .
.
h .
.
h .
.
h figure execution time distribution within hours we first study the havocimpact on the five fuzzers with havoc.
specifically wecreatetheirvariantsbydeleting havocfromtheir original implementations i.e.
only retaining their major fuzzing strategies.
table presents the edge coverage results of the five fuzzerswith havocintermsoftheirmajorfuzzingstrategies representedas major and theoriginal implementations represented as original respectively.generally wecanobservethattheedge coverageofallthestudiedfuzzersdecreasesignificantlyafterdeletinghavocfrom their implementations averagely i.e.
.
in afl .
in afl .
in fairfuzz .
in mopt and .
in qsym.
combining figure we can further infer that the .
edge coverage decrease for mopt is caused by reassigning .
hours .
of all time budget originally spent on havocto its majorstrategy the62.
edgecoveragedecreaseofqsymiscaused by excluding the thread executing havoc.
even for afl and afl which executes their havoconly less than hour excluding havoc decreases .
in afl and .
in afl in terms of edge coverage.
all such facts indicate that havoccan significantly increase theedge coverage over the major fuzzing strategies.
we also attempt to append the default havocinto the fuzzers withouthavoc i.e.
neuzz and mtfuzz and further investigate howthedefault havoccanimpacttheiredgecoverageperformance.
specifically theirintegrationfollowsthesequentialpatternadopted by many existing fuzzers mentioned in section .
i.e.
appending havocafter executing the original fuzzing strategies of neuzz and mtfuzzundereachiterativeexecution.therefore theexecution time of the default havocadopted by them cannot be deterministic.
in particular their execution time distributions are presented in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
onefuzzingstrategyto rule them all icse may21 pittsburgh pa usa table the edge coverage performance of fuzzers with havoc programsafl afl fairfuzz mopt qsym original major original major original major original major original major readelf nm objdump size strip djpeg tcpdump xmllint tiff2bw mutool harfbuzz jhead average table the impact of havocon neuzz and mtfuzz programspure havocneuzz mtfuzz originintegrationoriginintegration havoc major havoc major readelf nm objdump size strip djpeg tcpdump xmllint tiff2bw mutool harfbuzz jhead average figure where neuzz spends .
hours and mtfuzz spends hourson executing the default havoc.
table presents the edge coverage results where origin refers to the original versions of neuzz and mtfuzz while integration referstoneuzzandmtfuzzintegratedwith havoc.wecanobserve that overall for the new integrated version havoccan achieve .
.
higher edgecoverage thanthe majorfuzzing strategy of neuzz mtfuzz on average.
moreover the integrated fuzzers can achieve rather significant performance gain i.e.
.
over the original neuzz and .
over the original mtfuzz.
to summarize wecanderivethatforallthestudiedfuzzers nomatteroriginally integratedwith havocornot appendingthedefault havoctothem cansignificantlyenhancetheirmajor originalfuzzingstrategies.
finding1 applyinghavocbythedefaultsetupcansignificantlyimprovetheedgecoverageperformanceofthestudied fuzzers.
interestingly we can find from table that the pure havoc i.e.
using only one seed to launch havocand executing it all along withoutappendingittoanyfuzzer preformsratherstronginterms of edge coverage i.e.
31k edges on average on all the benchmark projects.
more specifically thepure havoccan significantlyoutperform most of the studied fuzzers e.g.
over afl over afl overneuzz whileobtainingcloseperformancewith moptandqsym.notethatwhilewecandefinitelyenablemultiple ways e.g.
applyingmorethanoneseed tolaunchtheexecutionofthe purehavoc the fact that using one seed can already achieve such superior performance can be a strong evidence that havoc itselfis a powerful fuzzer.
finding havoc is essentially a powerful fuzzer executing havocunderoneseedwithoutbeingappendedtoanyfuzzer forsufficienttimecanalreadyachievesuperioredgecoverage over many existing fuzzers.
wetheninvestigatethecorrelationbetweentheedgecoverage performance and the execution time of havoc.
we can observe thatwhilemtfuzz qsym andthepure havoccanachievemuch strongeredgecoverageovertheotherfuzzersaccordingtotables3 and they also have longer execution time for havocas shown in figure2.morespecifically therankingoftheedgecoverageperformancecanalmoststrictlyalignwiththerankingoftheexecution time ofhavocamong all the studied fuzzers except for neuzz and fairfuzz .
therefore we can infer that for most fuzzers executing havocfor longer timepotentially results in higher edge coverage.
finding executinghavoc for a longertime upon a fuzzer canpotentiallyresultinstrongeredgecoverageperformance.
.
.
rq2 performanceimpactofhavocunderdiversesetups.
inspiredbythepreviousfindings weattempttofurtherinvestigate theperformanceimpactof havoconthefuzzersunderdiverseexecutiontimesetups.specifically whileimplementingthedefault havocdoes not concern its execution time executing havocunder diverseexecutiontimesetupsessentiallydemandsthemodifiedimplementation of integrating havocto the fuzzers i.e.
the modified havoc .
implementation.
notethatinthispaper wefirstmodifythe implementationforintegrating havoctofuzzersinthesequential manner.tobeginwith itisessentialtofigureouthowtocontrol the execution time of the major fuzzing strategy and havocof a fuzzer.
specifically our insight is to retain the fuzzing states of the major fuzzing strategy and havocwhen they are halting.
to this end while realizing such insight by directly integrating the source codeofhavocintodifferentfuzzersessentiallydemandssubstantial engineering effort we decide to adopt socketprogramming as an alternative solution which can execute the major fuzzing mechanism and its appended havocin different processes since its authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may21 pittsburgh pa usa mingyuan wu ling jiang jiahong xiang yanwei huang heming cui lingming zhang and yuqun zhang table edge coverage results of fuzzers with modified havoc programs havoc qsymafl afl fairfuzz mopt neuzz mtfuzz orig new orig new orig new orig new orig new orig new readelf nm objdump size strip djpeg tcpdump xmllint tiff2bw mutool harfbuzz jhead average table average edge coverage results under different execution time setups setupafl havoc afl havoc fairfuzz havoc mopt havoc neuzz havoc mtfuzz havoctotal iteration 1h 24h 2h 4h 12h built inblockingmechanismcanprovidethe wakeup function for both monitoring the execution time of an event given its preset timeout and retaining the fuzzing states while halting.
note that suchsolutioncanbequiteconsistentwithasingle processfuzzerin terms of cpu resource consumption.
specifically in the beginning weexecutethemajorfuzzingstrategyofafuzzerfortimeduration t to generate new seeds.
subsequently we transmit the file names of thegeneratedseedsto havocbysocket.aftercompletingthewhole seed transmission havocis executed for time duration tas well while the execution of the original fuzzing strategy is paused.
note thatinsteadofdynamicallysettingamutationcountforcontrolling itsexecutionasthedefault havoc ourmodified havociteratively generates new seeds based on the updated collection of the interesting seedswithintimeduration t.similarlyafterexecuting havoc we transmit the file names of its generated seeds to the original fuzzing strategy of the fuzzer via socketfor further seed generations.
such process is iterated until hitting the total time budget.
evaluation.
we first evaluate havocby setting the iterative time duration tof the major fuzzing strategy havocas hour i.e.
executing them for hour respectively under each iteration .
as a result for each fuzzer its modified havoccan be executed within a total of hours under our hour budget.
table presents the evaluationresultsofthefuzzerswithandwithoutapplyingsuch modified havocwhere orig represents the original fuzzers with their default implementation and new represents the associated fuzzer integrated with the modified havoc.
note that since such setupdoesnotfitfortheessentialmechanismsofthepure havoc and qsym which execute havocfor the whole execution i.e.
hours we retain their results of the previous evaluations in table simplyforillustrationandcomparison.
we can observe that while mopt with the modified havoccan incur quite close edge coverage compared with its default havocintegrationas in table the rest fuzzerswith the modified havoc can achieve much higher edge coverage compared with their original versions e.g.
.8x for afl.
such result can further validate our finding .
specifically the original mopt can already incur quite long execution time for havocby default i.e.
.
hours and thus can result in rather strong edge coverage.
on the other hand the execution time of havocfor the other fuzzers turns to bemuchlongerwithournewhybridstrategy andthusresultsin a significant performance gain.
note that for the fuzzers which originally adopts no havoc i.e.
neuzz and mtfuzz their edge coverageperformancecanalsobesignificantlyimprovedcompared with theiroriginalversions.
moreinterestingly wecanfindthatformostfuzzers theycan incur quite close edge coverage with the modified havocon all the benchmark projects averagely i.e.
around 31k.
moreover their project wise performance can be quite close as well e.g.
around 71kinproject readelfand38kinproject objdump.comparedwith theedgecoveragefromtheiroriginalversions theirperformance gaps are significantly reduced.
to illustrate we adopt the std standard deviation of the average edge coverage for the studied fuzzers.specifically thestdofallthefuzzerswithournewstrategy for integrating havocis compared with that of when using their default strategies for integrating havoc while their average edge coverage is compared with .
such result canindicatethatbyexecuting havocforsufficienttime theedge coverage performance gaps of different fuzzers can be significantly reduced.ontheotherhand whiletheperformanceofmanystudied fuzzers are significantly improved by extending the execution time ofhavocinasequentialmanner theirperformanceareratherclose to the pure havoc.
such factsindicate that havoccanpotentially dominatemanyfuzzersin terms of edge coverage.
wealsoincludeblockcoveragerate i.e.
thenumberofaccessed basicblocksdividedbythetotalnumberofbasicblocks to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
onefuzzingstrategyto rule them all icse may21 pittsburgh pa usa figure3 blockcoverageofdifferentfuzzerswithmodified havoc strengthen our findings.
we can observe in figure that almost all the studied fuzzers significantly increase block coverage compared with their original implementations e.g.
.
for afl and .
formtfuzz.moreover allthestudiedfuzzersachievequiteclose blockcoverageratesafterintegrating havocwiththeaverageblock coverage rate of .
and std of .
which are consistent withtheedge coverage trends.
finding executing havoc for sufficient time can dominate the performance of the studied fuzzers and significantly reduce their performance gaps.
we further attempt to investigate how changing the integration mode ofhavocwith fuzzers can impact their edge coverage performance.tothisend wefirstenablediversesetupsoftheiterative time duration tofhavocin terms of hours hours and hours under the total execution time of hours.
table presents the evaluation results under such setups.
we can observe that overall there is no significant performance difference under all the setups.
specifically thelargestgapoftheaverageedgecoverageofagiven fuzzer is only .
.
such fact can indicate that the edge coverage performance is somewhat resilient to time duration t i.e.
under sufficienttotalexecutiontime adaptingtheexecutiontimeof havoc under each iteration results in rather limited impact on the edge coverage of the associated fuzzer.
figure edge coverageof different fuzzerswith thehybrid integrationof havocfinding as long as the total execution time of havoc is fixed howtoadaptitsiterativeexecutioncanhavelimited impactontheedgecoverageperformanceoftheassociated fuzzer.
while the performance gaps between different fuzzers can be significantlyreducedbyapplyingthemodified havoc qsymcan still outperformthe other fuzzers by at least .
accordingly we hypothesizethatexecutingmultiplefuzzingstrategiesinparallel canbepotentiallymoreadvancedinboostingedgeexploration.we then attempt to validate such hypothesis by also adopting additionalthreadsforexecuting havocinparallelinourstudiedfuzzers i.e.
while retaining the execution of their modified havocin the sequential manner for hours we also execute havocfor the whole24hoursinparallelinadditionalthreads.inparticular we adoptoneandtwoadditionalthreadsforexecuting havocrespectively.
figure presents our evaluation results.
we observe that when adopting one additional thread to execute havoc labelled as hybrid averagely the edge coverage of all the studied fuzzers can be increased by .
.
moreover we can also observe that compared with adopting one additional thread for havoc adopting two additional threads for havoc labelled as hybrid can further increasetheedgecoverageperformanceby2.
ontopofallthe studiedfuzzers.comparedwithqsymwhichoriginallyachieves theoptimalperformanceviausingthreethreadsforfuzzing mopt andaflcannowevenincurperformancegainsof1.
and0.
.
ontheotherhand sincetheperformancegainbysimplyincreasing additionalthreads forexecuting havocbecomesmarginal wecan infer that simply investing more computing resource on executing havocmaynot be cost effective.
finding6 investingmorecomputingresourceinexecuting havoccanpotentiallyreduceitsexecutiontimeforapproachingtheperformance bound but may not be cost effective.
whilethepreviousfindingsrevealthatundersufficientexecution time of havoc multiple fuzzers can approach quite close edge coverage performance we further attempt to investigate how commontheirexplorededgescanbe.tothisend wedeterminetoadopt theconceptof jaccarddistance todelineatethesimilarityof the explored edges from different fuzzers.
in particular jaccard distanceisusuallyusedtomeasurethedissimilarity betweentwo sets by dividing the difference of their union size and intersection size by their union size.
figure presents the evaluation results of seed dissimilarity between the pure havocand the other fuzzers with the modified havoc on average ranging from .
to .
.
suchresultindicatesthatapplying havoctodifferentfuzzerscan potentiallyexplorequitecommonedges.notethatqsymhasthe biggestjaccarddistance althoughitexecutes havocfor24hours.
the main reasons can be that qsym invests more computing resource i.e.
leveragingthreethreadsrunninginparallel and2 qsym leverages concolic execution that may explore different pathscomparedwithfuzzing.furthermore mtfuzzandneuzzalso havelarge jaccarddistance mainlybecausetheyfurtheruseneural networks to guide the fuzzing process.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may21 pittsburgh pa usa mingyuan wu ling jiang jiahong xiang yanwei huang heming cui lingming zhang and yuqun zhang figure the average jaccard distance of different fuzzers in all studied programs.
finding applying havoc to different fuzzers potentially explores rather common edges while fuzzers guided by concolic execution or neural networks can better complement havoc.
at last we investigate the impact of appending havocon exposingprogram vulnerabilities.
to this end we attempt to collect the programcrashescausedbyexecutingthegeneratedseedswithand withoutappending havoctoallthestudiedfuzzers.notethatwhen we append havocto fuzzers we ensure that it can be executed undersufficient timeto fully leverage its power.
to begin with it is essential to identify unique crashes since it is likely that many crashes are caused by the same program vulnerability.
in this paper we follow prior work to identify the unique crashes only if they increase edge coverage.
note that in this paper all of the crashes are explored byall of our previous evaluations.
while a crash can only be reported once among all the fuzzing strategies including havoc within a fuzzer it can be possibly explored by different fuzzers.
we then divide crashes into two sets i.e.
the ones explored by the involved havocmechanisms and the ones explored by the major fuzzing strategies.
at last we count the unique crashes for the two sets respectively.
table7 presentstheresults oftheunique crashes.overall we derive unique crashes from a total of crashes where are exposed by havocand are exposed by their original fuzzingstrategies e.g.
theconstraint solving basedmutationsin qsymandthegradient drivenmutationsinneuzz.notethatwe exposed69uniquecasheswhichhavebeenfixedinthelatestversions of their associated projects .
we also report the rest unknown crashes i.e.
they can be exposed in the latest version to thecorrespondingdevelopers .thedetailedbugreportcan befoundinourgithubpage .moreover applying havoccan exposethecrashesin7ofthe12totalbenchmarkprojectsandbe powerfulinexposinguniquecrashesinprojects nm 78outof79 andjhead out of .
such facts indicate that applying havoc can not only successfully advance program vulnerability exposure but also potentially dominate the vulnerability exposure on certain projects.table the unique crashes found by havoc programs crashesunique crashes havoc major readelf v2.
nm v2.
objdump v2.
size v2.
strip v2.
djpeg v9c jhead v3.
total finding havoc can also play a vital role in exposing potentialprogram vulnerabilities.
enhancing havoc so far our presented powerful performance of havocis simply caused by modifying its setups including its execution time and integrationmodeswithfuzzers.inthissection weattempttoinvestigatewhetherthepowerof havoccanbefurtherboosted.to thisend wefirstinvestigatetheperformanceimpactofthemutator stacking mechanism adopted by havoc and then propose an intuitive and lightweight technique to improve its performance accordingly.
.
performance impact of the mutator stacking mechanism notethatasasimplifiedmutationstrategy themutatorstacking mechanism containstwo steps determining stackingsize andrandomly selecting mutators to impact the performance of havoc.w e then investigate the performance impact caused by each step.
in particular wefirstattempttoinvestigatetheperformanceimpactof stackingsize .tothisend insteadofrandomlydetermining stacking sizefor mutating seeds at runtime of havocoriginally we implementhavocunderafixed stackingsize forallitsmutations.figure6 presentsourevaluationresultsoftheedgecoverageratioresultsin terms of all the possible fixed stacking size i.e.
... on top of all the studied benchmark projects.
note that the edge coverage ratioofoneprojectiscomputedasthetheexplorededgenumberin termsofonefixed stackingsize overthetotalexplorededgenumber ofallthefixed stackingsize s.wecanobservethatoverall the stackingsizewhichcausestheoptimaledgecoverageperformancefor each studied project can be quite divergent e.g.
selecting stacking size8 and32canoptimizetheedgecoveragein tcpdump djpeg andmutoolrespectively.
such results suggest that it is essential to adapt the stacking size setup for different projects to optimize their respective edge coverage.
we then investigate the performance impact from mutators.
to thisend insteadofuniformlyselectingmutatorsoutofatotalof15 mutators wefirstuniformlyselect chunkmutators orunitmutators and then randomly select their inclusive mutators under the given stacking size for mutating one seed.
figure presents the edge coverageratioresultsintermsoftheselectedmutatortypesontop of all the studied benchmark projects.
note that the edge coverage ratio is computed as the explored edge number by either chunk authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
onefuzzingstrategyto rule them all icse may21 pittsburgh pa usa algorithm1 the framework of havoc mab input seed output newseed function multi armed ucb selection newseed seed stacksize selectstackarm mutatortype selectmutatortypearm stacksize foriterationinstacksize do mutator randomselectmutatorbytype mutatortype newseed generatenewseed mutator newseed reward ifisinteresting newseed then reward updatestackbandit reward stacksize updatemutatortypebandit reward stacksize mutatortype returnnewseed mutators orunit mutators over their total explored edge number.
we can observe that overall the distribution of the edge coverage ratio performance can be quite divergent among different projects e.g.
theedgecoverageratioofthe unitmutators rangesfrom18.
xmllint to94.
tiff2bw .suchresultssuggestthatitisalso essentialtoadapt the selectionof the mutatortypes for different projects to optimize their respective edge coverage performance.
figure edge coverage for different fixed stack sizes figure7 edgecoveragefor unit mutators andchunk mutators .
approach inspired by the evaluation results above we attempt to propose solutionstoenhance havocviadynamicallyadjustingtheprojectwiseselectionson stackingsize andmutators.also notethatour previousfindingsrevealthattounleashthepowerof havoc itis essentialtoinveststrongcomputingresourcesfor havoc.accordingly our design adopts the following principles.
first we onlyenable single thread process i.e.
enhancing havocvia only applying our specifically designed technique instead of leveraging more threads for more computing resource as found already.
second our technique should be lightweight.
in particular when designing a technique for adjusting havocgiven the deterministic computing resource ideally we aim for minimizing its overhead while maximizingtheexecution time for the havocmechanism itself.
in this paper we propose a lightweight single threaded techniquehavoc mab mabrefersto multi armedbandit forthepure havocto automatically adjust its selections on stacking size and mutators at runtime for facilitating its edge exploration.
specifically we determine to model our task as a multi armed bandit problem which typically refers to allocating limited resources to alternative choices i.e.
stacking size and mutator selections for this problem to maximizetheir expected gain i.e.
edge coverage forthisproblem .morespecifically wedesignatwo layermultiarmedbanditmachine i.e.
a stackingsize levelbanditmachineand amutator levelbanditmachine whichispresentedinfigure8.note thatthestackingsize levelbanditmachineenables7armswhere each arm is designed corresponding to a stacking size choice i.e.
... .
after an arm of stacking size is chosen the mutator level bandit machine which enables arms representing chunk mutators andunitmutators wouldfirstmake achoiceoutof themandthen proceedtoselecttheexactmutatorsviauniformdistribution.eventually havoc mabgeneratesamutantviatheselectedmutatorsand executes it on the program under test for obtaining environmental feedback for further executions.
stacking size bandit ... bandit bandit bandit stacking size mutator typeseed corpus seed mutant .c program explore new edges?
mutator type bandits mutator stackingmutator mutator mutator mutator input havoc mab mutation stage execution outputseed corpus updating bandits yesno discard discar figure the framework of havoc mab 24edge coverage time hours havoc havoc mab havoc3mab qsym p1 .
507p2 .
figure the average edge coverage of havoc mabover time weadoptthewidely useducb1 tuned algorithmtosolveour proposed multi armed bandit problem.
equation demonstrates authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may21 pittsburgh pa usa mingyuan wu ling jiang jiahong xiang yanwei huang heming cui lingming zhang and yuqun zhang 24readelf nm objdump size strip djpeg tcpdump xmllint ti 2bw mutool harfbuzz jhead time hours edge coveragehavoc havoc mab havoc3mab qsym figure edge coverage of havoc mabover time how to select an armunder such algorithm for a given bandit machine at time t. in particular xjrefers to the average reward for arm jtill timet nrefers to the total execution count for the bandit machineand njreferstotheexecutioncountfor arm j jrefersto thesamplevarianceof arm j. arm t argmax j parenleftbigg xj radicalbigg lnn njmin j 2lnn nj parenrightbigg notethatwedefinetherewardattime taswhether havoc mabhas explored new edges or not for all the eight bandit machines.
if a seed generated by a chosen stacking size and its selected mutators canexplorenewedges therewardsreturnedtothe stackingsize level bandit machine and its corresponding mutator level bandit machineare both otherwise they are both .
algorithm1presentsouroverallapproach.
havoc mabfirstselectsstacking size for the executing seed and then selects its corresponding mutator type lines to .
next havoc mabgenerates a mutant by uniformly selecting the mutators of stacking size under thechosentype lines5to .eventually ifsuch mutantexplores newedges wesettherewardas1foritscorresponding stackingsize level and mutator level bandit machines otherwise to update equation1 for further executions lines to .
.
evaluation toevaluate havoc mab weincludeqsymforperformancecomparisonsinceitpresentstheoptimaledgecoverageperformanceinour previousstudies.furthermore wedesignavariantof havoc mab namelyhavoc3 mabwherehavoc mabisexecutedinthreethreads in parallel for comparing with qsym under identical computing resources.
we also include the pure havocas a baseline.
similar as section3.
weexecute eachvariant forfive timesfor eachbenchmarkproject to reduce the impact of randomness.
figure9presentstheaverageevaluationresultsofedgecoverage ofthestudiedapproachesontopofallthebenchmarkprojectsunder hour execution.
we can observe that havoc mabachieves significantlybetterperformancethanpure havoc i.e.
increasingthe average edge coverage among all the benchmark projects by .
574vs31 126explorededges .moreover weapplythemannwhitneyutest toillustratethesignificanceof havoc mab.thefact that the p value of havoc mabcomparing with havocin terms oftheaverageedgecoverageis0.00507indicatesthat havoc mab outperforms havocsignificantly p .
.
interestingly although havoc mabonly adopts one thread for execution it can slightly outperform qsym which leverages three threads for execution by .
on average among all runs with the std of .
.
it can also outperform qsym for out of runs.
on the other hand executinghavoc3 mabcan result in edge coverage gain over qsym 614vs34 495explorededges witha p valueof0.
.such results altogether can demonstrate the strength of our proposed havoc mab.
figure10presentstheedgecoveragetrendsofourstudiedapproaches upon each benchmark for hour execution.
overall havoc maboutperforms pure havocin most of the benchmarks significantly.
moreover havoc mabcan outperform qsym by at least morein tiff2w intermsofedgecoverageonfiveprojects while incurring rather close performance on the rest projects with asinglethreadexcept jhead.meanwhile havoc3 mabcanachieve theoptimaledgecoverageperformanceoneightbenchmarks.note that qsym outperforms all other fuzzers in jhead averagely vs. .thisdemonstratesthatgrey boxfuzzingstrategiesalone are ineffective for jheadwhile the effectiveness can be largely improved by concolic execution leveraged in qsym.
based on this observation and finding we highly recommend future research toinvestigatemorepowerfultechniquesforcombining havoc concolicexecution and learning based fuzzing.
threats to validity threatstointernalvalidity.
onethreattointernalvaliditylies in the implementation of the studied fuzzers in our evaluation.
to reduce this threat we reused their original source code for our implementationand experimentationdirectly.moreover thefirst authors manually reviewed all the code carefully to ensure its correctness and consistency.
threats to external validity.
the threats to external validity mainlylieinthesubjectsandbenchmarks.toreducethethreats weselect8representativestate of the artfuzzers includingaflbased concolic execution based and neural program smoothingbasedfuzzers.wealsoadopt12benchmarkprojectsaccordingto authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
onefuzzingstrategyto rule them all icse may21 pittsburgh pa usa their popularity i.e.
the most frequently used benchmarks by the originalpapersofourstudiedfuzzers.anotherthreattoexternal validity may lie in the randomness of the evaluation results.
to reduce this threat all the evaluation results are averaged upon five runsto reduce the impact of randomness.
threats to construct validity.
the threat to construct validity mainlyliesinthemainmetricusedinthispaper i.e.
edgecoverage toreflectcodecoverage.toreducethisthreat whiletherecanbe various ways to measure edge coverage we choose to follow many existingfuzzers andleveragetheaflbuilt intool named afl showmap forcollectingedgecoverage.furthermore we havealsoevaluatedfuzzingeffectivenessintermsofthenumberof uniquecrashes.
related work fuzzing.
afl isoneofthemostpopularfuzzersandhasinspired many other recent fuzzers for different application domains.
fioraldietal.
integratedmultipletechniques e.g.
tainttracking intothebasicframeworkofafl.liangetal.
alsointroduced a path aware taint analysis fuzzer to facilitate the efficiency of fuzzing.
b hme et al.
utilized a markov chain model to allocate energy for seed selection.
peng et al.
proposed t fuzz which removes sanity checks from the target program and then leveragesasymbolicexecutionenginetogenerateapathtothebuggy pointifitfindsanycrash.honggfuzz boostedtheefficacyof fuzzingundermultipleprocessesandthreadswhilechenetal.
proposed a synchronization mechanism for integrating different fuzzers.
wangetal.
proposedsyzvegastofuzzthekernel ofoperatingsystemsbydynamicallyadjustingfuzzingstrategies via reinforcement learning.
li et al.
introduced steelix which integrates light weight static analysis to coverage guide fuzzing.
wang et al.
proposed skyfire which leverages the knowledge in the vast amount of existing samples to generate well distributed seed inputs for fuzzing programs that process highly structured inputs.
they have also proposed a grammar aware coverage based greybox fuzzing approach named superion to fuzz programs that process structured inputs.
in more recent years researchers have alsoproposed various techniquesfor fuzzingdifferent types ofsoftwaresystems .wuetal.
pr oposedto detect cuda synchronization bugs via fuzzing and repair them automatically.zhangetal.
proposeddeeproadtogenerateimagestofuzzimage baseddrivingsystems.zhouetal.
generated realistic and continuous images to fuzz such systems.
in this paper we propose a technique to dynamically adjust mutation selections forhavocandresult in strong edge coverage performance.
studiesonfuzzing testing.
shenetal.
investigateddifferent bugs on different deep learning compilers.
metzman et al.
introducedaplatformfordevelopersandresearcherstoevaluate different fuzzers.
although they studied havocassociated with fuzzers theydidnotevaluateitindependently.
kleesetal.
surveyed the recent research literature and assessed the experimental evaluationstoillustratetheessentialexperimentalsetupforreliable experiments for fuzzing.
we actually follow the instruction of this work to construct our initial seed corpus.
furthermore herrera et al.
systematicallyinvestigatedandevaluatedhowseedselection affects the performance of a fuzzer to expose vulnerabilitiesin real world systems.
many researchers studied the rationales behindfuzzingapproaches.wuetal empiricallyevaluatedthe neuralprogram smoothing basedfuzzersandimprovedthemby proposing lightweight learning based mutation strategies.
liang etal.
presented themainobstaclesandcorrespondingtypical solutions for fuzzing.
tonder et al.
presented a technique to mapcrashing inputsto unique bugs using program transformation.
in this paper we conduct the first extensive study on havocto demonstratethat havocis a powerful fuzzer and have also shown thatit is possible to further advance havoc.
conclusion in this paper we investigate the impact and design of a random fuzzingstrategy havoc.wefirstconductanextensivestudytoevaluatetheimpactof havocbyapplying havoctoasetofstudiedfuzzers onreal worldbenchmarks.theevaluationresultsdemonstratethat the pure havoccan already achieve superior edge coverage and vulnerability detection compared with other fuzzers.
moreover integrating havocto a fuzzer or extending total execution time forhavoccan also increase the edge coverage significantly.
the performance gap among different fuzzers can also be considerably reduced by appending havoc.
at last we also design a lightweight approach to further boost havocby dynamically adjusting its mutationstrategy.
acknowledgement thisworkispartiallysupportedbythenationalnaturalscience foundation of china grant no.
guangdong provincial key laboratory grant no.
2020b121201001 and shenzhen peacockplan grantno.kqtd2016112514355531 .thisworkisalso partiallysupportedbynationalsciencefoundationundergrant nos.ccf 2131943andccf as well as ant group.