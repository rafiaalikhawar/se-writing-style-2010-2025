sadt syntax aware differential testing of certificate validation in ssl tls implementations lili quan college of intelligence and computing tianjin university chinaqianyu guo college of intelligence and computing tianjin university chinahongxu chen school of computer science and engineering nanyang technological university singapore xiaofei xie school of computer science and engineering nanyang technological university singaporexiaohong li college of intelligence and computing tianjin university chinayang liu school of computer science and engineering nanyang technological university singapore jing hu college of intelligence and computing tianjin university china abstract thesecurityassuranceofssl tlscriticallydependsonthecorrect validationofx.509certificates.
therefore itisimportanttocheck whetheracertificateiscorrectlyvalidatedbythessl tlsimplementations.
although differential testing has been proven to be effectiveinfindingsemanticbugs itstillsuffersfromthefollowing limitations the syntax of test cases cannot be correctly guaranteed.
currenttestcasesarenotdiverseenoughtocovermore implementationbehaviours.thispapertacklestheseproblemsby introducing sadt a novel syntax aware differential testing framework forevaluating thecertificate validationprocessin ssl tls implementations.
we first propose a tree based mutation strategy toensurethatthegeneratedcertificatesaresyntacticallycorrect and then diversify the certificates by sharing interesting test cases among all target ssl tls implementations.
such generated cer tificates are more likely to trigger discrepancies among ssl tls implementations which may indicate some potential bugs.
to evaluate the effectiveness of our approach we applied sadt on testing widely used ssl tls implementations compared withthestate of the artfuzzingtechnique i.e.
afl andtwodifferentialtestingtechniques i.e.
nezhaandrfccert .theresultsshowthat sadtoutperformsothertechniquesingeneratingdiscrepancies.
in total unique discrepancies were discovered by sadt and of them have been confirmed as bugs or fixed by the developers.
qianyuguocontributesequallywithliliquantothispaperandistheco firstauthor.
xiaofei xie xfxie ntu.edu.sg and jing hu mavis huhu tju.edu.cn are the corresponding authors.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
concepts software and its engineering software testing and debugging.
keywords differentialtesting certificatevalidation ssl tlsimplementation acm reference format lili quan qianyu guo hongxu chen xiaofei xie xiaohong li yang liu and jinghu.
.sadt syntax aware differentialtesting ofcertificate validation in ssl tls implementations.
in 35th ieee acm international conferenceonautomatedsoftwareengineering ase september21 virtual event australia.
acm new york ny usa pages.
https introduction thesecuresocketslayer ssl anditsdescendanttransport layer security tls protocols are the foundations of internet security.forexample hypertexttransferprotocolsecure https usesthemtoprovidetrustedauthenticationandsecurecommunication.
ssl tls authenticates a server or client by validating the x. certificate during the handshake phase to ensure a secure connection.
the authentication on a server means that the client validates the certificate presented by the server to determine whether it is a genuine communication server.
the authentication on a client is also the similar way.
after the server client is authenticated subsequent communications can be launched.
therefore it is critically important to ensure the correctness of certificate validation by ssl tls implementations.
acommunicationmaybedangerousifaninvalidcertificatesent bymaliciousserver clientisfalselyaccepted.similarly anormal communication requirement may be denied if a valid certificate sentbybenignserver clientisfalsely rejected.ho wever thecertificate validation is a complex process involving many aspects such as checking multiple fields e.g.
validity public key extensions inacertificateandverifyingeachcertificatealongthecertificatechain.
existing ssl tls implementations conduct the validation 35th ieee acm international conference on automated software engineering ase conforming to the specifications in request for comments rfcs i.e.
rfc rfc rfc rfc rfc rfc and rfc .
however the developersmayhavedifferentunderstandingsonthesespecifications which may further lead to the incorrect implementations.
thismakesthecertificatevalidationremainasaweakpartinthe whole network ecosystem.
therefore a systematic testing technique is still in urgent need for evaluating the quality of certificate validation of ssl tls implementations.
recently someapproacheshavebeenproposedtoevaluatethe ssl tls certificate validation process based on the differential testing technique .
the basic idea is to cross check thebehavioursamongmultiplessl tlsimplementations.ifone implementationacceptsaninputwhileanotherrejectsit thediscrepancy occurs which can be considered as a potential bug.
however existing differential testing based techniques still suffer from the following three limitations existing techniques are inefficientbecausetheyheavilyrelyonalargenumberofcertificatesfor constructing a well behaved corpus to discover semantic bugs.
for example frankencert finds only unique discrepancies among 15ssl tlsimplementationsusing243 246seedcertificatesasinputs.
thediversityofgeneratedcertificatesisnotenoughtocover all validation behaviours in ssl tls implementations which may miss some corner cases.
a typical example is rfccert which aimsatgeneratingcertificatesthatviolatetheextractedrules.however therulesmaybeincomplete andmanycertificatesthatsatisfy the rules but may rev eal bugs are missed.
some mutation based differential testing techniques cannot guarantee that the generated certificates are syntactically correct.
such invalid certificates aremore likely to be filtered making the testing ineffective.
for instance nezha directlymutatesthecertificatefiles regardless of the structured x. syntax and generates enormous amount of test cases that are syntactically incorrect e.g.
.
syntactically incorrect certificates after mutations in our experiments .
to tackle these problems we propose sadt a novel syntaxaware differential testing based framework for detecting bugs in the certificate validation process of ssl tls implementations.
the maindifferencebetweenourapproachandpreviousworkisthatthecertificatesgeneratedbysadtaremorelikelytotriggerdiscrepancies meanwhile the syntax is ensured to be correct.
specifically a tree based mutation strategy is first proposed to guarantee the syntaxcorrectnessofgeneratedcertificates.thenaglobalcoverageonalltargetedimplementationsisintroducedtoguidetheselectionofthe certificate.
finally such generated certificates are employed forthe cross validation in different implementations.
in order to evalu atetheperformanceofsadt wedesignexperimentson6ssl tls implementations to answer the following research questions rq1 how effective is sadt in discovering discrepancies?
rq2 how does sadt perform compared to the state of the art differential testing frameworks?
rq3 how does sadt perform compared to the state of the art fuzzing technique i.e.
afl ?
in summary this paper makes the following main contributions tree basedmutation.
weintroduceanovel tree basedmutation strategy which parses the certificate into a tree according to the!
!
!
!
!
!
!
!
!
!
!
.
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
.
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
.
!
!
!
!
!
!
!
figure general structure of a certificate chain.
x.509syntaxandmutatesthenodesonittoobtainnewcertificates.
this method can guarantee syntactical correctness of the generated certificates and it may be applicable in the generation of other syntactically complex inputs.
the global coverage guidance.
we propose the global coverage guidance by sharing interesting test cases across all tested implementationstodiversifythecertificategenerationthataremore likely to trigger discrepancies.
implementation and evaluation.
we implement sadt by extendingaflandcompareagainstthestate of the artdifferentialtesting techniques i.e.
nezha and rfccert on popular ssl tls implementations.theresultsshowthatsadtimprovesthecapability of bug detection in these ssl tls implementations.
communityfeedback.
wehavereportedthebugsfoundbysadt.
to date bugs have been confirmed or fixed by developers.
the remainder of this paper is organized as follows.
section brieflyintroducesx.509certificateandcertificatevalidation.section 3presentsthe technicaldetails ofour approachincluding the certificate generation and cross validation.
section shows the effectiveness and performance of sadt.
related work is discussed in section and this paper is concluded in section .
background .
x. certificate thex.509certificateisasigneddatastructurethatbindsapublic keytoaperson computer ororganizationanditisusedinmanyinternet protocols including ssl tls.
however it is also complex in structureandsyntax.asshowninfigure1 eachcertificateconsists ofasequenceofthreerequiredfields tbscertificate signaturealgorithm and signaturevalue.thefirstpart tbscertificate containsasubject anissuerandotherbasicinformation.compared withtheversion 1certificate theversion 2certificateaddsthe subjectuniqueid subjectuniqueidentifiers and issueruniqueid issuer uniqueidentifiers fields.inaddition extensions areaddedtothe version certificate.
the second part signaturealgorithm contains theidentifierofthesignaturealgorithmusedbycertificateauthority ca to sign this certificate.
as the third part signaturevalue records the digital signature computed upon tbscertificate.
inpublickeyinfrastructure pki acertificateisusuallyorganized into a certificate chain together with it s issuers.
figure shows the general structure of a certificate chain.
in general each !
!
!
figure overview of sadt certificate chain starts with a leaf certificate followed by all the issuersandeachcertificateinitissignedbythenextcertificateand the last certificate i.e.
the root certificate is a trusted self signed cacertificate.moreover the issuerofacertificateisequaltothe subjectof the next certificate.
more details about x. certificate can be found in rfc .
the x. certificate is encoded by the distinguished encoding rules der .
the transfer syntax used by der always follows theformat angbracketlefttag length value angbracketrightthatisusuallyreferredtoasatlv tripletinwhicheachfield t l orv containsoneormorebytes.
thetagspecifiesthetypeofthedatastructure.forexample the tag0x02represents the current data type is integer and the tag 0x06representsthecurrentdatatypeis objectidentifier.the length specifies the number of bytes of valuefield and the valuestores data content.
according to der transfer syntax basic and string types are encoded by using primitive forms while constructed types are encoded in a constructed form.
note that the valuefield is triplet if the data type is constructed form as shown in figure .
figure the der data structure .
certificate validation certificate validation is the key of authentication since it checks the genuineness and validity of certificates.
it usually requires two inputs the trusted ca certificates and a certificate chain to be validated.
during the validation process ssl tls implementationsfirst check whether the content of the leaf certificate is valid at the current time including checking the validity periodand basic constraints of other fields.
then they check whether the certificate is issued by a valid ca through checking the validity of the next certificate issuer certificate in the certificate chain and validating thesignature value by the signature algorithm.
this process continues along the certificate chain until the certificate be checked appears in the trusted certificate set.
a certificate will be accepted if and only if all of checks mentioned above are passed.
otherwise it is rejected.
more information about certificate validation can be found in rfc and rfc .
approach this section presents the technical details of our approach.
we introducetheoverviewofsadt andthendiscussthealgorithms of certificate generation and cross validation.
.
overview figure presents the overview of sadt which consists of two phases the certificate generation section .
and the cross validation section .
.
in the phase of certificate generation new testcases i.e.
certificates are generated with the help of tree based mutation andglobal coverage guidance.
specifically before starting to generate certificates all of the target ssl tls programs are instrumentedbytheinstrumentationmodule see sothatthe code coverage information can be obtained in execution see .
next sadt randomly selects a seed certificate from the certificate corpus see which will be first parsed from a nested tlv based der format section .
into a tree based structure by the cert parser section3.
.
see 4and5 .suchtree basedstructureisalso known as generic certificate tree gct in this paper.
then sadt conductsthetree basedmutationbyrandomlychangingtheleaf nodes and recursively updating the tree section .
.
see .
the mutatedtreeisthenparsedbacktoader formatcertificate see .
afterwards we run the generated certificate on those instrumented programs in parallel with the support of a global guidance engine section .
.
see .
note that the guidance engine is designed here to cover the code paths of all ssl tls tools as many as possible.
it determines whether the mutated certificate is able to triggernewcodecoverageinanyofthetargetedssl tlstools see .
if yes sadt adds the mutated certificate into the certificate corpusforfurtheriteration otherwise sadtdiscardsit see .
werepeatedlyconducttheaforementionedstepsformultipletimes i.e.
a time budget to obtain an extensive certificate corpus.
thecertificatecorpusisfurtherdeployedforcrossvalidation section3.
whenthecertificategenerationphaseiscompleted.inthis phase each certificate in the corpus is fed to all ssl tls toolsin parallel see and the output vector for each certificate is recorded see .
as shown in figure 2b an output vector consists of a certificate name cn and the validation results on each implementation where0means accept thecertificateandthenon zero number means reject it with different return values.
we get alarge number of validation vectors corresponding to individual a der code snippet b the initial gct c the mutated gct figure the examples of data structure for der and gct.
testcases.sadtchecksthesevectorstoidentifywhetherthereare discrepancies.adiscrepancyisfoundwhenthereareatleasttwo implementationsexhibitdifferentoutputs.finally wesummarize the discrepancy report for further bug confirmation see .
.
certificate generation theperformanceofsoftwaretestinglargelydependsonthequality oftestcases especiallywhenthetargetprogramrequireshighlystructuredinputs.specifictossl tlsvalidation weneedalarge numberofrepresentativecertificatesastestcases.however asmentioned earlier the certificates generated by previous work suffer fromvariouslimitationssuchasthesyntacticalincorrectnessand high redundancy.
sadt aims to address such problems by introducingtwonovelsolutions atree basedmutationstrategyfor ensuring the syntactical correctness during certificate generation and2 aglobalcoverageguidance fordiversifiedtest caseselection.
.
.
certificate parsing.
toobtainhigh qualitycertificatesthat conformtothestrictsyntaxrequirementsinmutation weneeda deep understanding on the certificate composition.
in other words given a certificate we need to address the following two concerns howtopreciselylocateeachfieldandhowtoextractthefieldvalue.
as described in section .
the certificate is composed of a nested angbracketlefttag length value angbracketrighttriplet a.k.a.tlvtriplet encodedbytheder.
thestructureis nestedinthatwhenwegetafield valueinatlv triplet thevalueitselfmaybeanothernestedstructure whichneeds toberecursivelyobtained.thisissimilartotraversingvalueson thetree.therefore thecertificatecanberepresentedasatree based structure so as to facilitate the field location and value acquisition.
thecert parser is introduced for parsing the der format certificateintoatree basedstructure whichwecallthe genericcertificate tree gct inthispaper.specifically thegctisatreewithmultipletypednodes whereeachnodeisatlvtriplet representing a particular certificate component.
it should be noted that each subsequent node next to the root node represents a certificate field whose value is recursively determined by its sub tree.
as to the bottomoftree theleafnoderepresentsanatomiccontentwhich can be directly translated by der e.g.
an integer number .
figure shows an example converting der to gct.
consider the der snippet in figure 4a it is a nested tlv triplet where theroottag intermediatetagsandendtagaremarkedasthered box i.e.
blue boxes i.e.
30and02 and green box i.e.
respectively.
specifically for the root triplet the tag 30means it is asequence.
the length 0a a hexadecimal number indicatesthatthevaluesofthis sequence occupythefollowing10bytes ranging from the index 2to index11.
similarly we can identify the twointermediatetriplets i.e.
theindices 6and7 respectively and the end triplet i.e.
the indices .
note that the value of end triplet is a one byte integer number 02which cannot be further split.basedonaboveobservations wecanbuildthegctbylinking the containment relationship between each triplet.
as shown in figure4b node aandnode ccorrespondtotheroottripletandend tripletinfigure4a whilenode bandnode dcorrespondtothetwo intermediate triplets respectively.
algorithm1presentsourcertificateparsingmethod whichtakes ader formatcertificate i.e.
d asinput andoutputsagct i.e.
t corresponding to d. since the certificate is a nested tlv structure wecanfirstextracttheroot tag i.e.
t length i.e.
l andvalue i.e.
v fromd lines2to4 .thenweconstructaninitialnodeforgct line which also consists of three parts corresponding to the tag length and valueinthetlvtriplet respectively seefigure4b .
wedirectlyassigntheobtainedtagandlengthtothisnode line6 .
whenitcomestothenodevalue weadoptsdifferentassignment solutionsdependingonthestructuretype i.e.
nodetag .according tothederencodingspecification ifthetagbelongstotheprimitivetypes line such as the bit string i.e.
andinteger i.e.
it means we get an atomic tlv triplet.
thus we consider the current nodeasaleafnode anddirectlyassigntheextracted valuevtothe valuepartofthisnode line8 .otherwise itmeanswegetanested tlvtriplet wherethe valuevcanbefurthersplit.therefore we considerthecurrentnodeasanrootorintermediatenode which needstorecursivelyconductthesameprocedureforbuildingthe childnodesunderitsvaluepart line13 .notethat fortheobtained valuev itmaybeawrapperofmultiplesubsequenttlvtriplets thus we need to traverse all sub tlv triplets on v lines to .
asaresult wewillbuildmultiplesub treesunderthecurrentnode.
finally afterrecursivelyassigningorlinkingnodesbasedonthe der triplet we can build a hierarchical structure a.k.a.
the gct.
.
.
tree based mutation.
weperformcertificatemutationbased onthetransformedgct.toensurethegeneratedcertificatesare syntacticallycorrect weapplyabottom upmutationstrategyon gct which can be divided into two phases the leaf selection and the backtracking repair.
leafselection.atthebeginning wefirstneedtoselectatarget componentincertificateastheentryformutation.withthehelp ofgct wecaneasilyobtainanycomponentbytraversingalong thetree.theoretically eachcomponentcanbeconsideredasthe candidate for mutation.
however as mentioned earlier for some componenttlvtripletsinacertificate thevaluepartitselfmaybe another sub tlv triplet.
as a result a direct mutation on the value partofsuchtripletswillinevitablydestroythecertificatesyntax generating a large number of low quality certificates.
with respect to gct such triplets can be mapped to the intermediate nodes.
by contrast the leaf node on gct is the atomic triplet that cannot be further split making it syntax free to change the value.
therefore we select the leaf nodes as the mutation entry.
specifically we recursively apply the breadth first search bfs strategy on the gct for randomly localizing a leaf node to conduct the mutation.
backtrackingrepair.givenaleafnodeongct wethenapply thebuilt inmutationstrategies e.g.
bitflip ofafl tochangeits 527algorithm certificate parsing input d angbracketleftt l v angbracketright an der certificate output t a gct corresponding to d 1function certparse d 2t gettag d 3l getlength d 4v getvalue d 5t initnode 6t t t l assignnode t l 7ifisatomic t then t v v leaf node assignment 9else p firsttlv v 11i repeat t vi certparse p assign recursively p nexttlv v i i untilp 17returnt valuepart i.e.
not the tagpart orlengthpart .
suppose the data value before and after mutation on the valuepart arevoandvm respectively.
it is very likely that vmdiffers from voin both data value and data length due to the randomness in mutation.
since thecertificateiscomposedofaseriesofnestedtriplets anychange in the data length of the underlying triplet will inevitably affect the data length of the upper one.
therefore we need to recursively repair the node lengthpart along the gct from bottom to top.
in this way we ensure that the generated certificates always conform to the syntax requirement.
figure 4b and figure 4c give an example on how the syntaxawaremutationisconductedalongthegct.considertheleafnode cininitialgct figure4b wemutatethevaluefrom 02to01 andget anewleaf node c prime with thelengthof2 bytes figure4c .
sincethelengthofthenodechangesfrom1to2duringmutation whichviolatesthesyntaxrestrictionofder weneedtorecursively repair the length of upper nodes to ensure the correctness of the syntax of the certificate.
consider the intermediate nodes i.e.
b andb prime in two figures the node length is updated from 03to04.
thelengthoftherootnode aisfurtherupdatedfrom 0ato0b as shown by the node a primein figure 4c.
algorithm2detailsthecertificatemutationprocess whichtakes a gcttas input and outputs a updated gct i.e.
t prime after mutationont.ourobjectiveistofindaleafnodeasquicklyaspossible sothatwecanstartthemutation.forthispurpose weconducta breadth first search bfs from the root node on and randomly selectasub tree tsub lines2to3 .if tsubisaleafnodeasexpected wemutateitsvaluepart line5 .notethat thechangeofdatavalue i.e.
tsub vtov prime may also result in a change on the number of bytes occupied by this value which may further affect the number of bytes occupied by the length part of the node.
consider the mutation example in figure 4b and figure 4c we mutate the valuealgorithm tree based mutation input t a gct for mutation output t prime a new gct after mutation 1function mutateandrepair t 2n random 3tsub randombfs t n 4ifisleaf tsub then 5v prime mutate tsub v 6l prime len v prime 7l tsub l 1 l prime tsub l 2 len l prime len l tsub v v prime update value tsub l l prime repair length returntsub 1 2 13else 1 mutateandrepair tsub l t l t l t l 1 repair length 2 len t l len l returnt 1 2 19t prime mutateandrepair t 20returnt prime partofleafnode cfrom02to01 resultingalengthadditionby1.
thecurrent1 bytelengthpartinnodesufficestostoretheupdated length.however ifthevalueof cismutatedtoalongvalue e.g.
a byte number then the current allocated space for the node lengthpartisnotenoughtorepresentsuchanumber andneeds onemorebyteforaccommodation.therefore weneedrecordthese twolengthchanges lines6to9 andthenupdatethevaluepart i.e.
tsub v andlengthpart i.e.
tsub l inthecurrentnode lines to .
the updated node and the total length change are returned line12 .forthecasesthattheselected tsubisanintermediate node we need to recursively apply the random bfs strategy on the gct until a leaf node is found line .
similarly for each recursion we repair thelengthpartinthecurrentnodecausedby its child node line and calculate the changes in the number of bytes the node length part takes which is raised by the repair just now line .
then the total change in byte count 1 2 and thecurrentsub tree i.e.
t arereturnedtouppernode line18 .
when backtracking to the root node we get the updated gct t prime.
it should be noted that the subsequent nodes next to the root of treerepresenttheroottripletofeachcertificatefield.thuswhen applying bfs on the root node we can identify the field name according to the random number which facilitates the further discrepancy localization.
.
.
global coverage guidance.
thebuilt incoverageguidance engine in afl is not suitable for differential testing because it only maximizes the coverage of a single program during the input generation leaving more coverage information on other programs unused which may help to trigger discrepancies.
in this work !
figure the workflow of global coverage guidance.
we extend the guidance engine of afl by using global coverage information of all tested programs.
our objective is to generate the inputsthatcancoverasmanydifferentialbehavioursaspossible amongmultipleprograms.intuitively atestinputthatisinteresting forsomeprograms maybenotinterestingforotherprograms.the interesting inputherereferstoaninputthatcancovernewedges orachieveanewhitcountforanalready exercisededge.therefore sharinginterestinginputscanimprovethediversityoftestcases whicharemorelikelytotriggerdiscrepanciesamongdifferenttools.
the motivation can be illustrated in the following example.
supposeaandbare two programs used for differential testing.
i1andi2standfortwoinputs.wealsosupposethatonly aisfuzzed by afl to generate test inputs and the generated test inputs arefurtherusedfordifferentialtestingbetween aandb.asaresult the input i1covers the edges a1 a2 o naand the edges b1 b2 onb respectively.
the other input i2covers the edge a1 o na andtheedges b2 b3 onb respectively.however despitecovering new edge on b i.e.
b3 i2still cannot be selected for further mutation under the built in guidance engine of afl because only the new coverage of acan be captured by afl.
such situation can beaddressedwhenweusetheglobalcoverageofbothprograms.
then the input i2would be included for further mutation.
it is similar to the case that only bis fuzzed to generate the test inputs.
theglobalcoverageguidanceengineisimplementedbysharing interestinginputsamongallprogramsinvolvedinthedifferential testing.thegeneralworkflowofglobalcoverageguidanceinsadtispresentedinfigure5.whenamutationiscompleted allssl tls tools are executed in parallel with respect to the mutated certifi cate.
these tools have been instrumented in advance to captureedge coverage and edge hit counts at runtime.
subsequently theedge coverage of each program is obtained and then it is used to guide the selection of the interesting input from different ssl tls tools.finally thoseinterestinginputsaresharedamongdifferent programsby maintainingthesame queuefortest cases.different ssl tls programs can be implemented differently and these differ encescanbecapturedbytestinputs.therefore sharinginterestinginputscanimprovethediversityoftestcases whicharemorelikely to trigger discrepancies among different tools.
algorithm presents the details about the global coverage guidance in sadt.
given an initial certificate corpus i.e.
q and a series of instrumented ssl tls tools i.e.
a we aim to extend the corpus with a lot of mutated certificates which expand the overall coverage whenrunning these tools in parallel.specifically weinitializeacoveragesetofallssl tlstoolsfortest a.k.a the globalcoveragecoverage i.e.
c inline1.wealsorecordthelatest time that the global coverage is no longer updated line .
next aalgorithm global coverage guidance input a angbracketleft 1 ... n angbracketright instrumented ssl tls tools q the certificate corpus output q the extended certificate corpus const t a timeout threshold 1c 2tlatest currenttime 3repeat 4d randomselect q 5d prime mutate d 6for ado 7c execute d prime single coverage c c uniontext.
c global coverage 9tcur currenttime 10ifnewcov c then 11q q uniontext.
d prime add interesting cert 12tlatest tcur 13t tcur tlatest 14untilt t 15returnq new certificate d primeis generated by mutation on a seed certificate d whichisrandomlyselectedfromthecorpus lines4to5 .we rund primesimultaneously on all tools and capture the global coverage bymergingthecoverageundereachtool lines6to8 .acritical checking is thenperformed on d primeto seewhether it produces new coverageonatleastoneofthetools line10 .ifyes weconsider d primeas an interesting input and add it into the corpus line .
meanwhile weupdatethetimewhenthenewcoveragewaslast generated line .
we repeatedly conduct above procedures until the global coverage isno longerupdatedwithin agiven periodof time line .
finally we obtain an extended corpus with a lot of interesting certificates added.
.
cross validation differential testing is a popular software testing technique that aims to detect semantic bugs by providing the same input toaseriesofsimilarapplicationsordifferentimplementationsof the same application and observing discrepant behaviours in their executions.
any discrepancy in outputs of targeted applications indicatesapotentialbugbecausethespecificationsoftheseapplications are theoretically identical.
we propose a novel syntax aware differentialtestingframeworkbasedonthecertificategeneration described in section .
.
in order to facilitate statistics and analysis ofdiscrepancy wedefinean m dimensionalvalidationvector certfor each tested certificate cert cn result1 result2 ... result m wheremis the number of tested implementations cnis the certificatename andthe result i i m indicatesthevalidation result returned by the ithimplementation.
result iis if the certificate is accepted.
otherwise it is the returned code of the rejection.
these vectors are used as metrics in the following ways.
ifresult i andresult j i j m i j the vector is considered as a discrepancy.
for a vector result1 ... result m x if it is not equivalent to any result1 ... result m yamongkdiscrepancies found x y k x y the vector is considered as a unique discrepancy.
furthermore in orderto measure the diversityof certificates in acert corpus we define the metric diversity udcert cert where udcert indicates the number of unique discrepancies triggered by cert corpus and the cert indicates the number of certificates in cert corpus.
it is clear that given certain number of certificates whentherearemoreuniquediscrepancies thecertificates in the cert corpus are more diverse.
in addition it is non trivial to localize the root cause of each unique discrepancy due to the large number of reported discrepancies and targeted implementations.
to mitigate this problem sadtstoreseachmutatedcertificatealongwithitsoriginalseed certificate and recordsthe mutated field namefor each certificate as described in section .
.
.
then the root cause of a detected discrepancycanbeimmediatelypinpointedbycomparingthecontent of mutated field in thediscrepancy revealing certificate with the seed certificate it originates from.
evaluation we implement sadt based on the state of the art tool afl using c and python.
to evaluate the effectiveness of sadt and understand theroot causeof thediscrepancies andbugs weaim to answer the research questions as mentioned in section .
.
experimental setup toevaluatesadt thefollowing6popularssl tlsimplementations are selected openssl v1.
.1d gnutls v3.
.
mbedtls v2.
.
nss v3.
wolfssl v4.
.
and libressl v3.
.
.
to capture discrepancies we need to run different implementationswiththesamecertificateandcomparetheoutputs.hence we modify these implementations such that the outputs are returned respectively.specifically ifthecertificateisaccepted the outputvalue0isreturned.otherwise wereturnthespecificcode oftherejection.werandomlydownload61realcertificatesfrom theexistingwebsites whichareusedastheinitialcertcorpusof sadt.notethat allcertificatesinthecertcorpusdonotcauseany discrepancies among these implementations.
allexperimentsare conductedonahigh performanceworkstation equippedwitha64 bitubuntu16.04ltssystem a32gbram and two core .3ghz intel xeon e5 cpus.
.
rq1 how effective is sadt in discovering discrepancies?
to detect the discrepancies between the popular ssl tls implementations we apply sadt to continuously generate test cases until there is no interesting testcase generated within minutes.
finally sadtranfor3hoursandgenerated2305interestingcertifi cates incertcorpus .thenwecomparetheresultsfrom6differenttable1 numberofuniquediscrepancybetweeneachpairof ssl tls implementations openssl gnutls mbedtls nsswolfssl libressl openssl gnutls mbedtls nss wolfssl libressl implementations.wesayacertificatecouldtriggerthediscrepanciesifthereareatleasttwoimplementationsreturnthedifferent results.
finally 64unique discrepanciesare generated andthe diversityis2.
.theresultsshowthatsadtcouldgeneratediverse certificates that are more likely to trigger unique discrepancies.
thetotalnumberofuniquediscrepanciesdependsonthenumber oftestedimplementations.intuitively themoreimplementations tested themoreuniquediscrepancies.then wefurthershowthe uniquediscrepancies foreach pairimplementations.
forexample supposetwooutputvectors and are returned from two inputs which are regarded as the same discrepancyforthe p1 p2 pair.itisbecausetheoutputdifferenceisthe same i.e.
.
table shows the number of unique discrepancies ineachpairofimplementations.overall thereareanaverageof .
unique discrepancies between each pair of ssl tls implementations.specifically wecanobservethatsadtdetectedthemost unique discrepancies between nss and wolfssl i.e.
.
more over sadt detected one unique discrepancy between openssl and libresslalthough theyfork thesamecode base.such results demonstrate that sadt can effectively detect unique discrepancies between any two ssl tls implementations.
wefurtherinvestigatetherootcauseofeachdiscrepancybycomparing the content of fields by mutating which during fuzzing the discrepancy is generated.
thus based on checking the mutated field the unique discrepancies are classified into different categories that show the root causes.
table lists the results of classification.
the first column shows different fields where spki aki eku and aia indicates the subject public key info authority keyidentifier extendedkeyusage andauthorityinformationaccess respectively.theresultsshowthatsadtcoulddetectmorediversediscrepanciesbetweenthe6ssl tlsimplementations.specifically thedetecteddiscrepanciesarefrom11fieldsincludingsomecritical fields e.g.
validity key usage aki et al.
.
in addition most of the discrepancies are caused by the extensions.
wehavereportthedetectedbugsfoundbysadttothedevelopers.to date 13bugshavebeenfixed orconfirmedasdescribed below.
more detailed case studies are shown in section .
opensslhasconfirmed2bugs opensslacceptsa version1 certificatewith extension .
opensslacceptscertificates including two instance of a particular extension .
gnutls has confirmed and fixed bugs gnutls accepts a certificate whose notbefore field is a non digits string .
gnutlscannotcheck objectidentifier correctly .
gnutls acceptscertificatesincludingtwoinstanceofa particularextension .
gnutls can not check issuercorrectly .
gnutls accepts notbefore with length .
530table the distribution of unique discrepancies found by sadt in terms of infected fields field name version serialnumber subject issuervalidity signature spkiextensionstotalkeyusage akiekuaia number mbedtlshasconfirmed1bug mbedtlsacceptsinvalidcertificateswhose keyidentifier oftheauthoritykeyidentifier isnot the same as subject key identifier of issuer certificate .
nsshas confirmed2bugs nss acceptsa version1certificate withextension .
nssaccepts notbefore withlength11 .
wolfsslhasfixed3bugs wolfsslacceptsacertificatewith authoritykeyidentifier thatdoesnotmatchissuercertificate .
wolfsslacceptsacertificatewithaninvalidtimeformat .
wolfsslacceptsacertificatewhose issuerdoesnotmatchthe subjectof issuer certificate .
answer to rq1 sadt is effective in finding unique discrepancies.specifically sadtfinds64uniquediscrepancies including 13confirmedbugs across6ssl tlsimplementationsandfinds average6.06uniquediscrepanciesbetweeneachpairofimplementations.moreover thediscrepanciesarediverseandcouldcover most of fields in the certificate.
.
rq2 how does sadt perform compared to state of the art differential testing frameworks?
we select two state of the art techniques as the baselines i.e.
rfccert and nezha which have been shown effective in detecting discrepancies between ssl tls implementations.
we do not select mucert and frankencert due to that rfccert has been demonstrated to be the more effective one than them.
sincethesourcecodeofrfccertisnotapplicable were implement it according to the algorithm described in .
note that unlike sadt and nezha rfccert is a rule based framework whichonlygeneratescertificateswiththeexistingrules extractedfromrfcs.tomakeafaircomparison sadtisrestricted to only mutate the certificate fields involved in the rules used byrfccert.
the same cert corpus are also provided for sadt and nezha.furthermore nezhahastwokindsofguidance gray box guidanceand black boxguidance.
sincesadtis gray boxframeworkguidedbyglobalcoverageguidance thegray boxguidanceof nezhaisusedinallcomparison.inourexperiment 11rulesare extractedfromrfc5280 andtheserulesinvolve10common fields of x. certificate.werun each frameworks five times and calculatetheaverageresultsforcomparison.theperformanceof sadt nezha and rfccert are compared in terms of the number of unique discrepancies and the diversity of certificates.
.
.
the number of unique discrepancies.
figure 6a shows the averagenumberofuniquediscrepanciesdiscoveredbysadt nezhaandrfccertunderdifferentiterations.wecouldobservethatsadt finds moreunique discrepanciesthan nezhaand rfccertunder the same iterations.
for example sadt finds about .
timesand4 timesunique discrepancies than nezha and rfccert respectively a the number of unique discrepanciesfoundbysadt nezhaand rfccert under different iterations b the distribution of unique discrepanciesfoundbysadt nezha andrfccertunder100 000iterations figure the performances of sadt nezha and rfccert under100 000iterations.furthermore thenumberofuniquediscrepancies found by sadt keeps increasing in different iterations while nezha and rfccert stop detecting new discrepancies after iterations.
the results demonstrate that sadt outperforms nezha and rfccert in finding unique discrepancies.
the mainreason is that nezha mutates the inputs without knowing the structureinformationoftheinput.rfccertconsidersthesyntaxinformation and ensures the syntactical correctness of the generated certificates butitlacksthecoveragefeedback.differently sadt considers both of the two perspectives i.e.
generating interestingtestcasesbasedonthesyntacticalstructureandthecoverage guidance making sadt more effective.
figure 6b shows the distribution of the unique discrepancies foundbyeachtoolunder100 000iterations.asseeninfigure6b thenumber ofunique discrepanciesfound bysadt nezhaand rfccert are and respectively.
the results show that these toolscouldgeneratedifferentdiscrepancies.forexamples and6uniquediscrepancies areonlyfoundbysadt nezhaand rfccert respectively i.e.
the discrepancies cannot be found by other two tools.
this is due to differences in their respective methodswithregardstothecertificategeneration.nezharandomly mutates certificates at the granularity of the entire certificate thus many test cases generated by nezha violate the syntax of thecertificate.
in other words nezha may find more discrepancies at the syntax parsing stage.
for example in our experiment certificates .
generatedbynezhaaresyntacticallyincorrect after mutations.
however certificates generated byrfccert have correct syntax but are not diverse enough i.e.
all ofthegeneratedcertificatesviolaterfcspecifications.however the tree based mutation and global coverage guidance make sadt address the above two problems making sadt more effective.
in addition nezha and rfccert miss .
and .
of the discrepancies found by sadt respectively.
we also found that some of discrepancies detected by rfccert and nezha are missed by sadt.
this is because the current mutation strategies of sadt mightbeincomplete.inordertoensurethatthegeneratedcertificate have the valid syntax sadt focuses on changing the value of 531table the discrepancy diversity of sadt nezha and rfccert under different mutation iterations.
iterationssadt nezha rfccert uniq.
certificates diversity .
.
.
.
.
the certificate field but does not change the structure of the certificate suchasaddingordeletingcertificatefields.despitethefact that the mutation operators of sadt may be limited sadt still detectsmorebugsthannezhaandrfccertduetothecombinationofsyntax guidedandcoverage guidedmutation.weplanto extend more mutation operators on sadt in the future.
.
.
the diversity of certificates.
asshowninfigure6a nonew unique discrepancies are discovered by nezha and rfccert after60 000iterations whilenewuniquediscrepanciescontinueto befoundbysadt.hence the diversity ofcertificatesgenerated bynezhaandrfccertdecreasesasiterationsincreases.table3 shows that the diversity of certificates generated by each framework and row uniq.indicates the number of unique discrepancies.
asshownintable3 after60 000iterations 6638and60 certificatesaregeneratedbysadt nezha andrfccert respectively and each of them find and unique discrepancies respectively.
therefore the diversity of certificates generated bysadt nezha and rfccert are .
.
and0.
respectively.itisobviousthatthediversity of certificates generated by sadt is much greater than that of nezhaandrfccert.notethat thediversityofsadtunder80 and iterations are also close to that under iterations andtheyarestillmuchgreaterthanthatofnezhaandrfccert under iterations.
these results demonstrate the certificates generated by sadt are more diverse than nezha and rfccert.
answerto rq2 compared with state of the art differential testing techniques sadt is more effective to generate diverse certificates that could detect more unique discrepancies.
.
rq3 how does sadt perform compared to the state of the art fuzzing technique i.e.
afl ?
sadt is implemented by extending the built in mutation and guidance engine of afl.
therefore we compare the performance ofsadt with the general purpose afl in terms of the number of uniquediscrepanciestofurtherillustratetheeffectivenessofour approach.sinceafldoesnotsupportdifferentialtesting weadapt aflfordifferentialtestingasfollows usingafltogeneratecertificatesbasedonasinglessl tlsimplementation i.e.
openssl and then invoking the validation routines from different implementationswiththesegeneratedcertificates.moreover toevaluatethe contribution of components in sadt i.e.
the tree based mutation and theglobal coverageguidance weconduct anothervariant of sadt named s sadt which performs the tree based mutationfigure the number of unique discrepancies found bysadt s sadt and afl under different iterations butthedefaultcoverageguidanceofafl.thenwefeedthesame initialcert corpus certificates to sadt s sadt and afl and obtain theresults.
toreduce the randomness each tool isrun five times and the average results are compared.
the number of unique discrepancies discovered by sadt ssadt and afl under different iterations are presented in figure .
it can beobserved that afl only finds 2unique discrepancies and the number of unique discrepancies remains the same as iterations increase.whereas sadtands sadtfindmoreuniquediscrepanciesthanaflundersameiterationsandthenumberofunique discrepancieskeepsincreasingduringtheiterations.thenumber of unique discrepancies discovered by sadt is about timesthan that of afl under iterations.
consider the results between s sadtandafl wefoundthats sadtfinds 9timesmoreunique discrepancies than afl under iterations which demonstratesthatthetree basedmutationiseffectiveindetectingdiscrepancies.
consider the results between sadt and s sadt we found thatsadtcoulddetectmuchmorediscrepancies e.g.
morethan2times thans sadtunderthesameiterations whichdemonstrates the effectiveness of the global coverage guidance in improving the performanceofsadt.ingeneral sadtimprovesthecapabilityof afl to find bugs in ssl tls implementations.
answer to rq3 sadt finds about timesmore unique discrepanciesthans sadt.s sadtfinds 9timesmoreuniquediscrepanciesthan aflunder100 iterations.itis clearlythatsadt and s sadt outperform afl in finding unique discrepancies.
the results demonstrate that both of tree based mutation and the global coverage guidance are effective in detecting unique discrepancies.
.
case studies of bugs to understand the root cause of the bugs reported by sadt we manually analyze the detailed implementation and summarize the root causes of these bugs into two categories lack of checking ofcornercase.thessl tlsimplementationdevelopersmayignoresomecasesthatmaynotbeclearlystatedintherfcs.forexample gnutls lacks some checks on whether the validityvalue is digital stringasshowninlisting1.
incorrectimplementationofrulesinrfcs.thedeveloper swrongunderstandingofrulesmayleadtothe rules not being implemented correctly.
the code for finding issuer on wolfssl was implemented incorrectly as shown in listing 5321statictime t utctime2gtime const char ttime 2charxx intyear if strlen ttime gnutls assert return time t 8xx 9memcpy xx ttime year is if xx is non digits year atoi xx ttime if year year else year returntime2gtime ttime year listing gnutls cannot parse validity field correctly whichisatypicalexample.inthissection werespectivelyintroduce the two typical bug cases in detail.
.
.
gnutls incorrect validation of validity.
thevalidity includingnotbefore andnotafter ofthex.509certificatehastworepresentations utctime yymmddhhmmssz andgeneralizedtime yyyymmddhhmmssz whichcontain13and15characters respectively.
it is obvious that the value of notbefore andnotafter cannot be a non digital string.
however we find that gnutls erroneouslyacceptsamalformedcertificatewhose notbefore ornotafter contain non digital characters while other ssl tls implementations reject it.
after manually debugging the implementation from thediscrepancy wefoundthatgnutlslacksthecheckonwhetherthevalidityvalueisdigitalstringasshowninlisting1.forexample while other implementations reject a certificate whose notbefore field is utctime 01010101000z since it is a incorrect time format.
however gnutls incorrectly interprets the time as otc 001900gmt .thisisbecausethefunction atoi xx returns whenxxis non digits line in listing .
we have reported thisbugtothecorrespondingdevelopersandcommittedamerge request to fix it.
the gnutls team has confirmed this bug and has fixed it in gnutls v3.
.
.
there are no such rules like validity must be digital string in rfcs which makes rfccert unable to generate such certificates.
thereforethisbugcannotbediscoveredbyrfccert.theresultalso demonstrates that sadt could be a supplement to rfccert.
.
.
wolfssl incorrect validation of issuer.
asdescribedinsection .
.
.
of rfc5280 the subject keyidentifier of a ca certificate mustmatchthe authority key identifier ofcertificatesissued bytheca.however ourexperimentsshowthatwolfsslacceptsa certificatethatviolatesthisrulewhileotherssl tlsimplementations rejectsuch certificatebecause theycould not findthe issuer.
through debugging we find that the code for finding issuers in wolfssl are not implemented correctly.
as shown in listing wolfsslwilllookuptheissuercertificatebymatchingthevalueof issuerwhenitcouldnotfindthecorrespondingissuercertificateby matching authoritykeyidentifier lines7to12inlisting2 .inthis case wolfssl will accept the certificate if the issuermatches the1intparsecertrelative decodedcert cert inttype intverify void cm ... 3if verify !
no verify type !
ca type type !
trusted peer type cert ca null ifndef no skid ca certificate is found if one field matches the cert 7if cert extauthkeyidset cert ca getca cm cert extauthkeyid 9if cert ca null cert extsubjkeyidset cert ca getca cm cert extsubjkeyid if cert ca null cert ca getcabyname cm cert issuerhash ... listing wolfssl cannot find issuer correctly subjectoftheissuercertificate.wolfsslhasconfirmedandfixed this bug and mbedtls has also confirmed it .
.
threats to validity the selected versions of ssl tls implementations in our study couldbeathreattovalidity.thisworkmainlyfocusesonthedifferentssl tlsimplementations.thethreatcouldbereducedby selectingmore differentversions ofthe ssl tlsimplementations.
theinitialcertcorpusmaybeathreat.wemitigatethisissueby randomlyselectingdiversecertificationsfromtheexistingwebsites.
another threat would be the randomness when comparing discrepancies detection between sadt and the baselines.
to mitigate this issue weruneachtoolfivetimesandcalculatetheaverageresults.
related work we summarize the related work in following two aspects the security of ssl tls implementations and the mutation based testing.
.
security of ssl tls implementations recently manyresearcheshavebeenproposedtoevaluatethesecu rityofssl tlsimplementations.marlinspike foundseveral vulnerabilitiesinthecertificatevalidationprocessofssl tlsimplementations.kaminskyetal.
demonstratedtwonewtypesof collisionattacksagainstthex.509certificate.georgievetal.
analyzedseveralvulnerabilitiesthatarecausedbybadlydesignedapis ofsslimplementations i.e.
openssl .theirresultsrevealedthe security risks in ssl tls implementations.
these results motivate ustodetectbugsofcertificatevalidationinssl tlsimplementations through automated methods.
frankencert isproposedforthefirsttimetotestcertificatevalidationlogic inssl tlsimplementations.
chenetal.
further appliedaguidedtechniquetoimprovefrankencert i.e.
mucert .
different from our work frankencert is unguided and mucertguides certificate generation based on a single implementation instead of multiple targeted implementations.
drlgencert first applied deep reinforcement learning to the automated testing of ssl tls implementations.
it needs to extract features from a large number of certificates which is not required in our work.
tlsattacker evaluated the security of tls libraries by two step fuzzingapproach.sivakornetal.presentedhvlearn tofind 533bugs in hostname verification.
they are orthogonal to our work as they mainly focus on protocol level or hostname verification while sadt focuses on certificate validation process.
the most relevant work to sadt are nezha and rfccert .ourworkdistinguishesfromtheminthefollowingaspects rfccert assembles certificates depending on the rules extracted from rfcs while we generate certificates in a rule independent way guidedbytheglobalcoverageofallssl tlsimplementations nezha directly mutates the certificate files regardless of the certificate syntax while sadt leverages a tree based mutation to generatesyntacticallycorrectcertificates and3 weproposeamore fine grained bug localization than nezha.
.
mutation based testing in the recent years there are many mutation based techniques proposed for software testing e.g.
afl libfuzzer fairfuzz steelix cerebro hawkeye muzz and uafl whichmutatetestcaseswiththeguidanceofcustomized domain specific code coverage.
their guidance is ill suitable for differentialtestingbecauseitguidesmutationbasedonasingleimplementationinsteadofmultiple implementations.slowfuzz and perffuzz generate test cases based on the resource usage.
vuzzer and angora use taint analysis to identify which bytesshouldbemutated.theymutatetestcaseregardlessofthe syntax of test case while sadt leverages a tree based mutation to ensuremutatedtestcaseissyntacticallycorrect.however therearesometechniquesareproposedtogeneratesyntacticallycorrecttest case.
4sqli generates executablesqls by applying mutation operatorsonvalidsqls.superion leveragesgrammar aware trimming strategy and two grammar aware mutation strategies to ensurethemutatedtestcaseissyntacticallycorrect.domato generatestest casesby specifyingthe syntaxof html cssstructure and javascript objects.
skyfire generates well distributed testcasesbyleveragingtheknowledgeofmanyexistingsamples.it should be noted that above techniques are orthogonal to our work as they mainly focus on generating highly structured inputs such as javascript instead of x. certificate.
conclusion inthispaper wedesign implementandevaluateasyntax aware differential testing framework i.e.
sadt for testing certificate validation in ssl tls implementations.
specifically the tree basedmutationandtheglobalcoverageguidanceareextendedonafl to effectively mutate and diversify x. certificates while keeping thecertificatesyntacticallycorrect.thesegeneratedcertificatesare leveraged to identify the discrepancies between different ssl tls implementations.ourexperimentalresultsdemonstratethatsadtis more effective thanthe state of the artdifferential testingframeworks i.e.
nezha and rfccert in detecting discrepancies and thegeneral purposefuzzingtechniqueafl.overall sadtfinds unique certificate validation discrepancies on widely usedssl tls implementations.
in particular bugs have been confirmed or fixed by the developers.