debugging inputs lukas kirschner cispa helmholtz center for information security saarbr cken germany s8lukirs stud.uni saarland.deezekiel soremekun cispa helmholtz center for information security saarbr cken germany ezekiel.soremekun cispa.saarlandandreas zeller cispa helmholtz center for information security saarbr cken germany zeller cispa.saarland abstract whenaprogramfailstoprocessaninput itneednotbetheprogramcodethatisatfault.itcanalsobethattheinputdataisfaulty for instance as result of data corruption.
to get the data processed one then has to debug the input data that is identifywhich parts of the input data prevent processing and recoveras much of the valuable input data as possible.
in this paper we present a general purpose algorithm called ddmaxthat addresses these problemsautomatically.throughexperiments ddmaxmaximizesthe subset of the input that can still be processed by the program thus recoveringandrepairingasmuchdataaspossible thedifference between the original failing input and the maximized passing input includes all input fragments that could not be processed.
to thebestofourknowledge ddmaxisthefirstapproachthatfixes faults in the input data without requiring program analysis.
in our evaluation ddmaxrepaired about of input files and recovered about of data within one minute per input.
introduction in the last decade techniques for automated debugging and repair have seen great interest in research and practice.
a recent survey lists more than papers on automatic fault localization andrepair.recently socialnetworkinggiantfacebookprovideddevelopers with automatically generated repair suggestions for every failure report of its apps .
almost all of these techniques focus onprogramcode attemptingtoidentifypossiblefaultlocationsin thecodeandsynthesizingfixesforthiscode.however whenaprogramfailsonsomeinput itneednotbetheprogramcodethatisat fault.
hardware failures hardware aging transmission errors may allcausedatatogetcorrupted.incomputerhardware radiationcan impact memory cells leading to bit flips and again data corruption.
and finally data can be corrupted through software bugs with the processingsoftwarewritingoutmalformedorincompletedata.if data is corrupted the easiest remedy is to use a backup.
but if abackupdoesnotexist oristooold orfailstobeprocessed onemay want to recover as much data as possible from the existing data or in other words debug the data.
someprogramscomewithapplication specificmeanstorecover data.
input parsers can recover from syntactical errors by applying sophisticatedrecovery strategies in aprogramming language this may involve skipping the current statement or function and publication rights licensed to acm.
acm acknowledges that this contribution was authoredor co authoredbyanemployee contractororaffiliateof anationalgovernment.assuch thegovernmentretainsanonexclusive royalty freerighttopublishor reproduce this article or to allow others to do so for government purposes only.
icse may seoul republic of korea copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
figure failing json input figure failing input reduced with ddmin item apple price .
figure failing input repaired with ddmax figure difference between failing and repaired input resuming with the next one .
when detecting a corrupted or incomplete file microsoft office programs may attempt to recover from the error using a number of undisclosed approaches .
when a program does notimplement a good recovery strategy though usersare leftto their owndevices usinggeneral purpose editors to identify file contents and possible corrupted parts.
as listed above general purpose automated debugging techniques focus on faults in code and do not provide much help in suchsituations astheywouldregularlyidentifytheinputparser and its error handling code as being associated with the fault.
the deltadebugging ddmin algorithm however focusesonidentifying error causes in the input in repeated runs with reduced inputs itsimplifiesafailure inducinginputdowntoaminimum thatreproducestheerror.unfortunately deltadebuggingisnota goodfit appliedtoinvalidinputs itproducesthesmallestsubset of the input that also produces an input error typically a singlecharacter.asanexample considerfigure1 ajsoninputwithasyntax error ddminproduces the reduced input in figure consisting ofa single character whichalso producesa syntax error.
this is neither helpful for diagnosis nor a basis for data recovery.
in this paper we introduce a generic input repair method that automatically identifies which parts of the input data prevent processing and recoversas much of the valuable input data as possible.
like ddmin our approach runs the program under test repeatedlywithdifferentsubsetsoftheinput assessingwhetherthe subset can be processed or not.
also it does not need anykind of program analysis and can thus be used in a wide range of settings.
unlike ddmin however which aims at minimizing the failure inducinginput our ddmaxalgorithmaimsat maximizing ieee acm 42nd international conference on software engineering icse thepassinginput.itsresultisasubsetoftheinputthat canbe successfully processed and is maximal no further element from the failing input can be added without causing the input to become invalid again.
applied on our example from figure ddmaxproduces the repaired passing inputsubsetinfigure3 inwhichtheconfounding characters and nothing else are removed.
the difference betweentheoriginalinput figure1 andtherepairedinput figure3 listed in figure actually makes a precisediagnosis of the failure cause and can be given to developers for further debugging steps.
note that while ddmaxrecovers a maximum of data it does not recover a maximum of information in our example we do not know whether .45actually is the correct price.
however the repaired input can now be read and processed by the programathand enablinghumanstoreadandchecktheirdocumentand engage into additional recovery steps.
although many applications produce error messages when processinginvalidinputs mosterrormesagesarevague.often applica tionssimplyreportthataninputiscorrupted withoutrepairingthe inputorprovidingthereasonfortheinvalidity.however ddmax identifies the invalid input fragment quickly for debuggers while also preserving a maximum of content for end users .
the remainder of this paper makes the following contributions an empirical study of invalid inputs in practice.
weevaluate the prevalence of invalid input in the wild section .
we crawled thousands of input files from githuband determine the set of valid and invalid files.
we find that invalid inputsare common in practice about four percent files of all input files files crawled from github were invalid.
generic input repair with minimal data loss.
weintroducethe ddmaxalgorithm automaticallyrecoveringamaximumof datafromagivenfailure inducinginput section .tothe bestofourknowledge ddmaxisthefirstinputrepairtechniquethatcanbeappliedtoarbitraryinputsandprograms without additional knowledge on input formats or program code.
in its evaluation on eight subjects and three input formats using real world invalid inputs as well as synthetic corruptions wefindthat ddmaxiseffective itrepairs69 ofcorruptedinputsandrecoversabout78 ofdata withina time budget of one minute per input.
an efficient syntactical input repair technique.
weintroduce avariantof ddmaxthatmakesuseofa grammar toparseinputsintoderivationtreesandtomaximizeinputsbypruningpartsofthetreethatcouldnotberead section4 thisvastly speedsupinput repair.
in its evaluation syntactic ddmaxis faster and more efficient than the lexical variant.
identifying faults in input data.
thedifferencebetweenthe repaired inputby ddmaxandtheoriginalinputcontainsall parts of the input that prevented the data from being processed in the first place.
section shows that this difference precisely characterizes the fault in the input.
afterdiscussing limitations section6 threatstovalidity section and related work section we close with conclusion and future work section .table subject programs subject input prog.
size maturity program format lang.
in kloc 1stcommit blender obj c c jan. assimp obj c .
july appleseed obj c .
may jq json c .
july jsonsimple json java .
nov. minimal json json java .
feb. graphviz dot c sep. gephi dot java .
july table input grammar details grammar size loc parserrules lexerrules json wave.
obj dot prevalence of invalid inputs before we start repairing inputs let us first answer the question of howrelevantthe problem is.
is it actually possible that some applicationcannotopenadatafile?andwouldtherebefilesclaiming toadheretosomeformatifinfact theyarenot?toanswersuch questions let us go and catch some invalid inputs in the wild.
.
evaluation setup subject programs.
in this paper we use eight programs as test subjects namely blender assimp appleseed jq json simple minimal json graphviz and finally gephi .eachinputformatwasevaluatedwiththreesubjects exceptfor dotwhichwasevaluatedwithtwoprograms.allour subject programs are open source c c orjavaprograms.
on average these programs have kloc and a maturity of over years.
table highlights the properties of our subject programs.
grammars.
wehavecollectedthegrammarsforoursubjectsfrom theantlr grammar repository .
we chose complex and large grammarsfordata richinputformatsusedintwopopulardomains namely graphics domain i.e.
wave.
obj and dot and data exchangedomain i.e.json .toensurethegrammarsweresound we testedthemwith50validcrawledfilesforeachinputformat.we modified the wavefront obj grammar since its antlr grammar was only a subset of the official wavefront obj specificiation .
thejsonanddotwereusedunmodifiedsincetheymatchedtheofficialspecificiations .onaverage thegrammarsarewritten in loc with parser rules and lexer rules cf.
table .
mining and filtering input files.
table highlights the details oftheinputfilesinourcorpus.wecrawledforaspecificfileformat usingthefileextension e.g.
.json forthejsoninputformat .in total we collected a corpus of input files cf.
crawled files in table3 usingthe githubapi forcrawling .then wedeletedall filesthatareemptyorduplicated aswellastheinputfilesthathave adifferentinputformatdespitehavingtheintendedfilenamesuffix 76table mined input files input crawled unique valid invalid cause of invalidity files rejected by mean valid mean invalid format files files files files grammar subject all subjects size kib size kib json .
.
wave.
obj .
.
dot .
.
e.g.
a wavefront obj file has the same suffix .obj as a binary obj filethatwascreatedbyacompiler .thisresultedin7835unique input files cf.
unique files .
we also separated files that contain unsupportedgrammarextensions.inparticular forjsonanddot weremoved166inputfiles cf.
grammarfiles thatonlycontain literals like a number or a string e.g.
which are invalid json andjsonfilesthatcontainmultiplejsonfilesappendedtoeach other as written by some programs.
to determine actual invalid input files cf.
invalid wefilter out the valid input files from the set of unique files by checking that the file does not lead to a lexing parsing error when parsed byantlrand the file was successfully opened by all subject programs of the input format without crashing using the test oracleinsection2.
.intotal 7702inputfiles cf.
validfiles passed the check of the filtering process and the remaining input filesrepresentoursetofreal worldinvalidfiles cf.
invalidfiles .
exactly inputs were rejected by antlr this is shown in table cf.
cause of invalidity grammar .
test oracle.
in our setup the test oracle forddmaxis acrashing oracle.aninputistreatedas invalidifitcrashesthesubjectprogram or the result of the subject is empty or the subject takes more than seconds to process the input1.
a program run is considered a crashifthesubjectprogramreturnsanon zeroexitvalue.evenifa subjectreportsanerror itisonlyconsideredacrashifitalsoreturns a non zero exit value.
opening a validfile however produces a non empty output after seconds and does not crash the subject program.
the test oracle does not use antlr as an invalidity criterium for lexical ddmax because the goal is to repair an input withfeedbackfromasubjectprogram withouttheknowledgeof the input grammar.
although syntactic ddmaxemploys antlr to build its initial ast it does not obtain feedback from antlr during repair i.e.
when the ast is being modified.
to automate tests we ensure that all subject programs have a fullcommand lineinterface cli supportora java python api.
the test oracle was implemented in loc of javaand loc ofpythoncode.
.
evaluation rq1 how prevalent are invalid inputs in practice?
invalid input files are common.
about four percent of all inputs in our corpus 295files wereinvalid cf.table3 theywereeitherrejectedbysubjectprogram s ortheinputgrammar.specifically abouttwo percent of the input files files in our sample were rejected by atleast onesubjectprogram however lessthan1 files were rejected by allsubject programs in our evaluation setup.
1thisexecutiontimeof10secondswasdeterminedasamaximumopeningtimeto successfully process all valid input files in our evaluation corpus.a common cause of invalidity is wrong syntax missing or nonconforming elements.
many input files were invalid because of single character errors such as a deleted character a missing characteroranextraneouscharacter.forinstance somejsoninputs wereinvalidduetodeletionsofcharacterssuchasquotes parenthesesandbraces.theseerrorsaredifficulttofindbecausetheyare oftenhiddeninlargedocuments.forexample oursetofcrawled obj files contained many files of about 300kib with one corrupted line e.g.aninvalidcharacterinsidea usemtl statement .tofix suchanerrorbyhand onewouldhavetoscrollthroughthousands of lines of code and find this single corrupted character.
other sourcesofinvalidityincludetheadditionofelementsthatdonot conformwiththeinputspecification.somejsonfilescontainedcomments that begin with the character.
comments are notpermitted in json however this was common practice in some json files and a few parsers support comments e.g.
google gson .
in our sample of github files four percent could not be processed either by the input grammar or at least one subject program.
lexical repair now that we have established that there are actually files that cannotbeproperlyparsedoropened letusintroducethe ddmax algorithm for recovering and repairing invalid input.
ddmaxworks on a character by character basis we thus call it lexical ddmax .
.
delta debugging ourddmaxtechnique can be seen as a variation on the minimizing delta debugging algorithm a technique for automatically reducing failure inducing inputs by means of systematic tests.
the reduction problemis modeled as follows configurations consisting of individual input elementswhichmayormaynotbepresent.there are two configurations a passing configuration c and afailing configuration c .
the passing configuration c typically stands for an empty or trivial input c and the failing configuration c c stands for the failure inducing input in question.
in our example from section the failing configuration would be c item apple price .
zelleretal.
definethe ddminalgorithmasfollows.
ddmin producesoneset c prime withc c prime c wherec prime hasaminimalsize overall.
it works by testing sets c primethat liebetweenc andc i.e.
c c prime c .
a test involves running the original program on the newlysynthesizedinput c prime.theoutcome test c prime ofthetest either passing failing or unresolved determinesalgorithm progress whenever a subset c prime c fails test c prime ddmin further narrows down the difference between c primeandc .i no u r 77maximizing delta debugging algorithm lettestandc be given such that test test c hold.
the goal is to find c prime ddmax c such that c prime c test c prime and c c prime is minimal.
themaximizing delta debugging algorithm ddmax c is ddmax c ddmax2 where ddmax2 c prime n ddmax c i if i ... n test c i increase to complement ddmax2 parenleftbigc prime i max n parenrightbigelse if i ... n test c prime i increase to subset ddmax2 parenleftbigc prime min c 2n parenrightbigelse ifn c c prime increase granularity c prime otherwise done .
where c c prime 1 2 n all iare pairwise disjoint and i i c c prime nholds.
the recursion invariant and thus precondition for ddmax2istest c prime n .
figure maximizing lexical delta debugging algorithm example from section figure shows a typical ddminoutputc prime the one character in the input suffices to cause the syntax error.
whenchoosinganewcandidate c prime ddmininitiallysplitsthesets to be tested in half as long as tests always pass or fail this is as efficient as a binary search.
if tests are unresolved say because the input is invalid ddminresorts to cutting quarters eighths sixteenthsoftheinput ddmin .eventually ddmintestseachremaining element character for its relevance in producing the failure.
.
the ddmaxalgorithm our definition of ddmaxis shown in figure .
ddmaxuses the samesettingas ddmin however ratherthan minimizing thefailureinducinginput c itstartswithapassinginput c prime c likeddmin it assumes for simplicity that c holds.
it then maximizes c prime systematically minimizing the difference between c prime andc using thesametechniquesas ddmin firstprogressingwithlargedifferences then smaller and smaller differences until every remaining difference would cause c prime to fail.
this makes ddmaxact in exact symmetryto ddmin andcomplementstheoriginaldefinitionsof ddandddmin .
.
addmaxexample how does ddmaxwork?
let us illustrate it on the example from section1.wehave c definedasinequation above andevaluate ddmax c to obtain c prime the maximal subset of c that passes the test i.e.
that can be still be processed by our json application at hand .
we now invoke ddmax c and getddmax2 that is c prime andn .the set c prime willcontinually holdmoreand more characters and nwill hold the current granularity.
ddmax2determines c c prime c c and splits it into two parts 1 2 1 price .
2 item apple aspartof increasetocomplement ddmax2firsttests c 1 which is 2 and then c 2 which is 1 .
neither of both is a valid json input hence the tests do not pass.
in increase tosubset the sets to be tested are c prime 1 1 1andc prime 2 2 2 wealreadyknowthatthesetestsdonot pass.
hence we increase granularity and double nton .
withn we now split into four parts 1 4 1 item 2 apple 3 price 4 .
in increase to complement the tests run on the failing set c withoutthe individual i that is c 1 apple price .
c 2 item price .
c 3 item apple .
c 4 item apple price none of these inputs is syntactically valid json and no test passes so ddmaxfurther increases granularity to n .
in this round againnoneofthe ipass butoneofthecomplementsdoes c 6 item apple price with 6 .
thesetc 6isindeedasyntacticallyvalidjsoninput and test c 6 passes increasetocomplement .atthispoint we have recovered31 of the input data already.
canweaddmorecharacters?followingthe ddmaxdefinition we reinvokeddmax2withc prime c 6.now theremainingdifference between c prime andc is 6as above.
we restart with n and decompose the remaining c c prime 6into 61and 62 61 62 .
now c 61passes yielding the syntactically correct input c 61 item apple price .
a further iteration will also recover the space character before the number eventually yielding the repaired input in figure and the remaining difference in figure .
the example demonstrates two important properties of ddmax 78corrupted filessyntactic ddmax lexicalddmaxparse treeantlrgrammar repaired file subject program differencing size change levenshteinp hash mutatevalid crawled files ddminreal world invalid filessize changefilterall crawled filestest driver delta debuggingantlr figure workflow of the ddmaxevaluation ddmaxisthorough.
itsresultc prime is1 maximal thatis adding any further character from c will no longer pass.
formally this means that i c c prime test parenleftbigc prime i parenrightbig nequal holds.
ddmaxcan beslow.
the complexity ofddmaxis the same as ddmin in the worst case the number of tests carried out byddmax c is c c andinthebestcase ifthereis only one failure inducing change i c and all cases that donotinclude ipass then the number of tests tis limited byt 2log2 c .
in practice as with ddmin things will be somewhere between the two extremes but keep in mind that at maximum granularity ddmaxrunsatleast c c prime tests thatis one testfor everycharacter thatpossibly stillcouldbe restored.
with these properties what we get with ddmaxis an algorithm that guarantees a maximum of data recovery albeit at the price of possibly running a large number of tests.
.
evaluation setup workflow.
figure6showstheworkflowofourevaluation.first wecollectreal worldinvalidinputfilesfromthesetof crawledfiles accordingtosection2.thosefilesarethenfilteredintoasetofvalidfilesandasetofinvalidfiles step.
andduplicatesandfileswitha wrong format are deleted.
secondly we select and mutate valid crawled files to produce an additional set of corrupted input files step.
.
then we feed a invalid file to eachsubject program and theantlrparser framework step.
.
antlrexecutes its default errorrecoverystrategy whilegeneratingaparsetreefortheinput.
next we feed the invalid file to lexical ddmax step.
.
lexical ddmaxteststheinputunderrepairrepeatedlyusingthefeedback from the subject program step.
.
then we feed the original crawled files and the resulting repaired file from each technique to thedifferencing framework step.
which computes the change in filesize levenshteindistance andperceptivehashvalue forbothfiles.
wesavethefeedbackfromoursubjectprogram step.
.finally 2both maximality and complexity properties are proven in a way analogous to the properties of ddminin .to ensure the quality of our approach we also execute ddminon thereal worldinvalidinputs step.
andreportthecontentand size of the result.
lexicalddmax wasimplementedin595locof javacode.antlr also implements an inbuilt error recovery strategy which is designedtorecoverfromlexingorparsingerrors e.g.missing wrong tokens or incomplete parse trees .
mutations.
in addition to the real world invalid inputs cf.
section we also simulate real world data corruption by applying byte level mutations on valid input files.
these mutations were chosen because they are similar to the corruptions observed in real worldinvalidfiles seesection2andsection5 .weperformthe followingmutationsatarandompositionineachvalidinputfile byte insertion byte deletion andbyte flip.
to simulate single data corruption we randomly choose one of these mutations and apply it once on the valid input file.
for multiple data corruptions w e perform up to random mutations on each input file.
a mutation isonlysuccessful foraninputformat if atleastoneofthesubject programs thatpassesbefore failsafterthemutation.thesecriteria is similar to how we collected invalid input files in the wild.
metricsandmeasures.
inordertodeterminethequalityof ddmax repair we use the following metrics and tools filesize wemeasurethe filesizeoftheinputsrecovered byddmaxand thedifference in file size between the original validinput andtherepairedfile.weusethesemeasurements to account for the amount of data recovered by ddmaxas well as the amount of data loss incurred.
levenshtein distance additionally we measure data loss usingthelevenshteindistancemetric measuringthe edit distance betweenvalid input andrepaired file.
perceptiveimagedifference inordertomeasurethe semantic information loss incurred by ddmax we calculate thehashvalueofour3dimages i.e.
wavefront obj format.
wecomputetheimagedistanceofour3dimagefilesbyrendering both the repaired image and the original valid image 79intoseveral2dimagesfromthreedifferentcameraangles andthreescales thenmeasuringthe2dimagedistanceof all nine images.
we compare these images using the python imagehash library inordertoobtainagoodapproximationoftherealimagedifferencebetweenthosetwo3d modelsasa perceptiveimagedifference betweenbothimages.
in our setup we use two rendering engines blender and appleseed to render the images.
researchprotocol.
for eachinput format we collectreal world invalidinputfiles.secondly weperformsingleandmultiplemutationson50validinputdocuments.then weexecuteallfileson thedifferentsubjectprograms inordertodeterminethenumber of input files which fail for each subjectprogram.
we proceed to runlexical ddmax on each invalid or mutated input file.
in particular weareinterestedindeterminingthefollowing .
baseline thenumberofinvalidinputfileswhichareacceptedbyasubject program as valid inputs i.e.
non failure inducing inputs processed bytheprogramwithoutleadingtoacrash inordertomeasurethe effectiveness of the built in error recovery feature of the program and .
antlr thenumber ofinvalid inputswhichare repaired byantlrinbuilt errorrecoverystrategy lexical thenumber of invalid inputs which are repaired by lexical ddmax.
all experiments were conducted on a lenovo thinkpad with fourphysicalcoresand 8gbofram specificallyanintel r core i72720qm .20ghz 8virtualcores running64 bitarchlinux.
all our prototypes are single threaded.
.
evaluation baseline antlr lex.
ddmax syn.
ddmax repaired input files techniquesreal world invalid inputs single mutationsmultiple mutations figure number of repaired files for each technique rq2 how effective is lexical ddmax in repairing invalid inputdocumentswithinatimebudgetofoneminuteperfile?
lexical ddmax repaired about two thirds of all invalid inputs cf.table4 .italsooutperformedboththein builtrepairstrategy ofthesubjectprograms baseline andtheantlrerrorrecovery strategy antlr bothofwhichrepaired14 and40 ofallinvalid input files respectively.
specifically lexical ddmax repaired over four times as many invalid input files as the baselineand more invalidinputfilesthanantlr cf.figure7 .theperformanceof lexical ddmax was significantly better for both all mutations.table ddmaxeffectiveness on all invalid inputs invalid.
format possible repaired input files type subjects repairs base.
antlr lex.
syn.
real worldjson obj dot single mut.json obj dot multiple mut.json obj dot total real single mult.
real single mult.
real single mult.
real single mult.file size kb techniquesmean data recovered mean data loss syn.ddmax lex.ddmax antlr baseline figure data recovered and data loss for all inputs lexical ddmax repaired about two thirds of all invalid inputs and significantly outperforms both the basline and antlr.
rq3 howmuchdatais recovered bylexicalddmax andhow much is the data loss incurred by lexical ddmax ?in terms of recovery rate lexical ddmax performs slightly worse than the other techniques with a recovery rate of on real world invalid inputs onsingledatacorruption andabout43 onmultiple data corruption see figure .
for both types of data invalidity the baselineandantlrmaintain an almost perfect data recovery rate approximately .
lexicalddmax recovered most and of the data in real world invalid inputs and mutated input files respectively.
intheory lexical ddmax isguaranteedtoensureminimaldata loss for all repairs.
however due to large file sizes and timeout constraintsinourexperimentalsetup lexical ddmax oftenhaltsbefore the maximal valid data is recovered.
in our experiment lexical ddmaxhadtimedoutfor163inputfilesduringrepair.inorderto inspect the data recovery rate of each approach in a more balanced setting we examined the set of input files that were repaired bybothantlrandlexical ddmax beforelexical ddmax timed out.
in total repairs were accomplished by both lexical ddmaxand 80table5 ddmaxefficiencyonallinvalidinputsforeachtechnique a baseline b antlr c lexical ddmax d syntacticddmax.
invalid.
inp.
runtime sec.
runs type form ab c d cd real worldjson obj44 dot48 single mut.json obj491 dot58 multiple mut.json10 obj624 dot60 mean antlr beforeatimeout.thedatalossof lexical ddmax isminimal and comparable to antlr this holds for bothsingle and multiple datacorruptionfortheintersectingsetbeforetimeout.infact on average lexical ddmax recovered .
kib of data and antlr recovered .
kib.
overall lexical ddmax incurs minimal data loss during repair it recovers similar amount of data from invalid input files in comparison to antlr.
rq4 how efficient islexical ddmax in repairing invalid input documents?
onaverage ittooklessthantwominutes .
minutes torepairafile cf.figure13 .incomparison boththe baselineandantlrhadanexecutiontimeof3and4secondsperinput file respectively.
this indicates that lexical ddmax is more timeconsuming than both the baselineandantlr.
this is expected sinceddmaxrequires multiple executions of the subject programs as indicated in lexical runs in table .
lexicalddmaxisrelativelyfastinrepairinganinvalidinputfile it takes less than two minutes seconds on average.
syntactic repair we have seen that ddmaxis general but also slow if one wants to recoveramaximumofdata itrunsasingletestforeverycandidate character that can be recovered.
is it possible to s peed things up possiblybyleveraginginformationontheinputformat?tothisend weintroducethe syntactic ddmax algorithm whichimprovesthe performance of ddmaxusing the knowledge of the input grammar.
the key insight is to execute ddmaxon theparse tree of the input insteadoftheinputcharacters.here weanalyzetheinput at the syntactical level rather than the lexical level.
this improves the runtime and general performance of the ddmaxalgorithm.
the mainbenefitoftheapproachisthatitenables ddmaxtoreasonata more coarse grained level by testing on the input structure.
lexical ddmaxmaytakethousandsoftestruns dependingonthesizeofthe input infactitsnumberofrunsisboundtothenumberofcharacters in the input.
however syntactic ddmax is bound to the numberof terminal nodes in the parsetree which is typically smallerthan thenumberofcharactersintheinput.thus syntacticddmax caneasily exclude corrupted parse tree nodes or subtrees during test runs.
additionally the knowledge of the input structure ensures that the resulting recovered inputs are syntactically valid.
this helps in the case of syntax errors large corrupted input region s and multiple data corruptions on the input structure .
item apple price .
figure failing json input with missing colon specifically thesyntactic ddmaxalgorithmtakesasinputa parse treefor the corrupted input file cf.
figure and obtains a preorderlistofterminalsintheparsetree.forinstance considerthe corrupted json input in figure .
repairing this input using the lexical ddmax algorithm results in the json input in figure whichwouldtakeover 100testruns.evenforthissmallexample syntacticddmax enhancestheperformanceof ddmaxwiththeinput grammar reducingthenumberoftestrunsof ddmaxtonineand improving performance by ten fold.
item apple figure repaired json input by ddmax torepairtheinput cf.figure9 syntactic ddmaxfirstparsesthe inputintoaparsetree3 showninfigure11.next werunthe ddmax algorithmontheparsetree removingterminalnodes insteadof single characters in each iteration of ddmax4.
we define c as our failing configuration which contains the terminal nodes of the parse tree from figure .
let us run the ddmaxalgorithm on our example terminal nodes.
weinvoke ddmax c whichresultsin ddmax2 soinside ddmax2 we havec prime andn .
at first our is split into two parts5 1 item apple 2 error runningtest c 1 andtest c 2 bothfail .weareatthe first run so with c prime c prime 1 c 2andc prime 2 c 1 which also both fail in the increase to subset step.
next we set n and restart ddmax2 c prime n .
withn in the increase to complement and increase to subset steps we get 1 item 2 apple 3 error 4 3antlris capable of generating a parse tree for corrupted input files it summarizes syntactically wrong symbols or trees into error nodes similar to figure .
4removing only the error node in the parse tree does not necessarily result in a non failure inducing input.
5note that checking for only syntactically valid subsets of the programs e.g.
using thegrammaronly isnotsufficienttorepairtheinput.weleveragetheapplication sincethe semanticsandintendeduse oftheinput fileareencodedin thelogicofthe applcation.
angbracketleftjson angbracketright angbracketleftdict angbracketright angbracketleftstring angbracketright item apple error figure parse tree of figure inthe increasetocomplement step wefindthat test c 3 sowerepeatouralgorithmwith c prime c 3andn getting 1 2 error since neither test c i nortest c prime i passes for any iand n c c prime wearedoneandendupwiththeremaininginput seeninfigure10.forthisexample the syntacticddmax runneeded only test runs of the subject program to repair the faulty input.
let us now take a look at the complexity of our algorithm.
as mentioned in section ddmaxhas a worst case complexity of t c c testrunsandabest casecomplexityof t 2log2 c .
intuitively the complexity of syntactic ddmax is similar to the complexityof ddmax exceptthatitisboundedbythenumberof terminalnodesinsteadofthenumberofcharacters.intheworst case aninput sparsetreehasasmanyterminalnodesascharacters.
however real world input formats have keywords data types and characterclassestoaggregrategroupofcharactersintoterminals e.g.
string and integers .
this reduces the number of terminal nodes and the required number of test runs for syntactic ddmax .i t therefore speedsup ddmaxby decreasing thenumber of elements tomaximizewith ddmax.considertheexampleinfigure9 there are single characters to search with lexical ddmax which are parsedinto7terminalnodesfor syntacticddmax .ingeneral wecan assume that with an average terminal node length of ncharacters we have a worst case complexity of parenleftbig c n parenrightbig2 c ntest runs and a best case complexity of t 2log2 c n test runs.
.
evaluation setup implementation.
syntacticddmax wasimplementedin1084loc ofjavacode this implementation is built on top of the antlr4.
parser generatorframework foreach input grammar.overall theimplementationof syntacticddmax differsfromthatof lexical ddmaxin section .
because of its use of the input grammar and parsetree.specifically syntactic ddmax usestheantlrparsetree from step.
in figure to repair invalid inputs.
in our evaluation we feed the invalid real world files into our syntactic ddmax w e proceedtorun syntactic ddmax oneachinvalidinputfileandevaluate the change in file size i.e.
the data loss on byte level .
syntactic ddmaxteststheinputunderrepairrepeatedlyusingthefeedback from the subject program step.
.
in addition to the research protocolinsection3.
wefeedallinvalidinputfilesto syntacticddmax and measure the number of invalid files which are repaired by oursyntactic ddmax using the input grammar this measure is termed syntactic.
.
evaluation rq5 how effective is syntactic ddmax in repairing invalid input documents within a time budget of one minute per file?syntactic ddmax repaired about three quarters of all invalid inputs in our evaluation cf.
table .
overall it is about more effective than lexical ddmax cf.
figure .
it significantly outperformed both the built in repair strategies of the subject programsand antlr itrepairedfivetimesasmanyfilesasthesubject programs and almost twice as many files as antlr cf.
table .
thisconfirmsourhypothesis inrq2 thatddmaxcanbenefitfrom the knowledge of the input grammar.
syntacticddmaxrepairedaboutthree quartersofallinvalidinputs and it is more effective than lexical ddmax for all invalid inputs.
rq6 how much data is recovered bysyntactic ddmax and howmuchisthe dataloss incurredby syntacticddmax ?on average syntactic ddmax has a higher data recovery rate in comparison to lexical ddmax for all invalid inputs.
for single data corruption the data recovery rate of syntactic ddmax is similar to that of antlrand thebaseline when using mean file size as a metric.on multiple data corruption syntactic ddmax recoveredabout84 ofthedataintheinputfiles cf.figure8 .forall invalid inputs the baselineandantlrmaintain an almost perfect datarecoveryrate approximately100 .evidently thedataloss incurred by both antlrand thebaselineis negligible.
syntactic ddmax hasa high data recovery rate recovering most of the data in invalid input files.
thedatalossincurredby ddmaxisverylow intermsoftheedit distance between the recovered file and the valid file.
across allmutations it is less than worse off than antlr as captured bythelevenshteindistance cf.figure12 .inparticular themean edit distance of the repaired file and the originally valid inputfile is less than four for the baselineand about for antlr.a s expected the levenshtein distance is lower for single data corruptions for lexicalandsyntactical ddmax respectively and higherformultiplecorruptions .oninspection wefound that the high loss of ddmaxis due to early timeouts for large input files indeed ddmaxfindsavalidsubset buttimesoutbeforethe maximal subset is reached.
for wavefront obj files the perceptive image difference shows us similar scaling result as the levenshtein distance.
while it shows small results for baseline and antlr .
and .
respectively the results for lexicalandsyntactical ddmaxarehigher .4and51.
thusthedifferencebetweenthe unmodified image and the repaired image is larger.
we conduct our evaluation of minimal data loss similarly to the setting in rq3 cf.
section .
.
as expected syntactic ddmax recoveredslightlylessdata exactly1.720kibonaverage.thisis becausesyntactic ddmax removes terminal nodes a terminal node maycontainmorecharactersthanthenumberofmutatedcharactersinthenode.insummary withahighenoughtimeout lexical ddmaxisguaranteedtoachieveminimaldataloss thisguarantee baseline antlr lex.
ddmax syn.
ddmaxdata loss techniquesmean difference in file size kb mean levenshtein distance mean perceptive image difference phash figure data loss incurred for all mutations does not hold for syntactic ddmax since it operates at the parse tree level rather than the byte level.
overall syntactic ddmax incurs comparatively similar data loss during repair as lexical ddmax.
rq7 how efficient issyntactic ddmax in repairing invalid input documents?
syntactic ddmax improves over the runtime performance of lexical ddmax cf.
rq4 section .
.
it improves overlexical ddmax by its execution time is about two third of the running time of lexical ddmax.
specifically syntactic ddmax is quicker ittook approximatelyone minuteto repaira singlefile but requires a grammar and a parse tree6.
syntactic ddmax is faster in repairing an invalid input file it takes less than one minute to repair a file on average.
.
1x106 1x107 baseline antlr lex.
ddmax syn.
ddmaxruntime ms techniquesmean runt ime per repa ired input file .
.
.
.
figure13 meanruntimeperinputfileforeachtechnique 6depending on the grammar and on the input file size generating a parse tree should take less than a second.
diagnostic quality even though ddmaxis primarily meant for repairing data its maximized input can also be useful for diagnostics and debugging.
in particular ddmaxdiagnosis is the difference between the failing and maximal passing input.
this is a minimal failure cause which isnecessarytodebugtheinput.mostnotably the fromddmax includes allinput characters that are failure inducing whereas ddmininclude only a minimal subset.
.
evaluation setup tocomparativelyevaluatethediagnosticutilityof ddmax w ecopareddmaxdiagnoses to the established state of the art input diagnosisapproach ddmin.inourevaluation wecomparethe ddmax diagnosis to ddmin we do not compare to the general delta debugging dd algorithm.
this is because dd is not suited for repairing inputs.
although dd would produce a passing and a failing input with a minimal difference between them.
this dd difference could beassmallastheddmaxdifferencebetweenthemaximalpassing input and the original failing input and have similar diagnostic quality also dd would likely be faster.
however dd does not havethegoalofminimizingdataloss andthusthepassinginput resultingfromgeneralddmayactuallybeclosetoaminimalinput cutting away all the original context.
byconstruction dd and ddmin canminimize andthuslose all the context of the original failure.
for instance if there is aflag in the input that activates the faulty function and dd andddmin will remove that flag causing the program to pass then this single flag will end up as failure inducing input.
on the other hand ddmaxwould preserve as much of the original context as possiblebyconstruction.itistheseexperiencesthathavedriven us to experiment with dd alternatives such as ddmaxandddmin.
weimplementeda ddminalgorithmfollowingthedeltadebuggingalgorithmin in450locofjavacode.our ddminimplementation uses both the subject program and antlr as oracles to minimize an invalid input in order to ensure that ddmindiagnosisissyntacticallyvalid.thisensuresthat ddmindoesnotreport a valid subset that may trigger a failure due to syntactic invalid ity e.g.
in cf.
figure in section since antlr can parse the ddmindiagnosis butthesubjectprogramcrashes.then wefeed the real world invalid files into our ddminimplementation as seen in figure step.
and compare the diagnosis generated by ddmin to that of ddmax.
weareinterestedinevaluatingthesoundnessandcompleteness of bothddmin usingddmaxdiagnoses as the ground truth .
to be fair to both approaches we consider the intersection of the diagnosesforboth ddminandddmaxthatfinishedexecutionbefore a time out this a set of input files in total cf.
table .
.
evaluation rq8 how effective isddmaxin diagnosing the root cause ofinvalidinputs especiallyincomparisonto ddmin?given thatddmaxwas completely executed without a timeout the repair ofddmaxis themaximal passing input andddmaxdiagnosis is the minimal failure cause.
as expected ddmindiagnosis is significantly larger 21timesmore thanthe ddmaxdiagnosis hence itcontains a significant amount of the maximal passing input which 83table6 diagnosticqualityonreal worldinvalidinputsfor a circlecopyrtddminandb circlecopyrtddmaxdiagnoses and c circlecopyrtddmaxrepair.
format diagnosis b repair b intersection inputs ab ca ba c json .
.
.
.
.
obj .
.
.
.
.
dot .
.
.
.
.
mean .
.
.
.
.
is considered noise in the diagnosis cf.a cin table .
additionally ddmindiagnosisonlycontainsasmallportion of the minimal failure cause required to diagnose the input invalidity cf.a bintable6 .thisresultshowsthat ddmaxdiagnosisis more effective for input debugging in comparison to the state of the art ddmin.
on average only one eighth of a ddmin diagnosis contains the minimal failure cause and about one third of ddmin diagnosis contains the maximal passing input.
limitations bothddmaxvariants are limited in the following ways repair to subsets only.
bothddmaxvariantswillreturnastrict lexicalorsyntactical subsetoftheoriginalfailure inducing input.theassumptionisthatonlydatashouldberestored that already is there rather than synthesizing new data for instance .iftheinputformathasseveralcontext sensitive dependencies such as checksums hashes encryption or