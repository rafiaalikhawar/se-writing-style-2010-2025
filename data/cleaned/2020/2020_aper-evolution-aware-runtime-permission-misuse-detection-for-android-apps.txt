aper evolution aware runtime permission misuse detection for android apps sinan wang southern university of science and technology shenzhen china wangsn mail.sustech.edu.cnyibo wang northeastern university shenyang china yibowangcz outlook.comxian zhan the hong kong polytechnic university hong kong china chichoxian gmail.com ying wang northeastern university shenyang china wangying swc.neu.edu.cnyepang liu southern university of science and technology shenzhen china liuyp1 sustech.edu.cnxiapu luo the hong kong polytechnic university hong kong china csxluo comp.polyu.edu.hk shing chi cheung the hong kong university of science and technology and guangzhou hkust fok ying tung research institute hong kong china scc cse.ust.hk abstract the android platform introduces the runtime permission model inversion6.
.thenewmodelgreatlyimprovesdataprivacyand user experience but brings new challenges for app developers.
first itallowsuserstofreelyrevokegrantedpermissions.hence developers cannot assume that the permissions granted to an app would keep being granted.
instead they should make their apps carefullycheckthepermissionstatusbeforeinvokingdangerous apis.second thepermissionspecificationkeepsevolving bringing newtypesofcompatibilityissuesintotheecosystem.tounderstand the impact of the challenges we conducted an empirical study on popular google play apps.
we found that .
apps useddangerousapisasynchronouslyafterpermissionmanagement and61.
appsusedevolvingdangerousapis.ifanappdoesnot properly handle permission revocations or platform differences unexpectedruntimeissuesmayhappenandevencauseappcrashes.
sinan wang is affiliated with the research institute of trustworthy autonomous systems and department of computer science and engineering of sustech.
ying wang is also affiliated with hong kong university of science and technology.
yepang liu is the corresponding author.
he is affiliated with the research institute of trustworthy autonomous systems guangdong provincial key laboratory of brain inspired intelligent computation and department of computer science and engineering of sustech.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
call such android runtime permission issues as arp bugs.
unfortunately existing runtime permission issue detection tools cannoteffectivelydealwiththearpbugsinducedbyasynchronous permission management and permission specification evolution.
tofillthegap wedesignedastaticanalyzer aper thatperforms reaching definition and dominator analysis on android apps to detect thetwo types ofarp bugs.to compare aper with existing tools webuiltabenchmark arpfix from60realarpbugs.our experiment results show that aper significantly outperforms two academictools arpdroidandrevdroid andanindustrialtool lint on arpfix with an average improvement of .
on f1score.inaddition apersuccessfullyfound34arpbugsin214opensource android apps most of which can result in abnormal app behaviors suchasappcrashes accordingtoourmanualvalidation.
we reported these bugs to the app developers.
so far bugs have been confirmed and seven have been fixed.
keywords android runtime permission compatibility issues static analysis acm reference format sinan wang yibo wang xian zhan ying wang yepang liu xiapu luo and shing chi cheung.
.
aper evolution aware runtime permission misuse detection for android apps.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction thepermissionmechanismontheandroidplatformservesasan essentialguardtousers dataprivacy.inordertoaccesssensitive data or critical system functions an android app should obtain correspondingpermissionsfromtheuserbeforeinvokingrelated ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa sinan wang yibo wang xian zhan ying wang yepang liu xiapu luo and shing chi cheung permission protectedapis.priortoandroid6.
i.e.
apilevel22or earlier which we call legacy platforms the permission granting process happens when an app is installed .
after the app is granted with its required permissions and gets installed users can no longer revoke the permissions1.
such a static permission model was considered to be vulnerable as the installation time permission warnings cannot effectively help users make their security decisions .
to address this weakness in android .
api level theruntime permission model was introduced.
the new model brought several changes dangerous permissions are requested duringanapp sexecution userscaneithergrantordenysuch requests users can also revoke granted permissions from the systemsettingsatanytime.thesechangesgreatlyimprovedataprivacy and users experience with android apps .
however this android runtime permission arp mechanism also brings technical challenges to developers as users can freely revoke granted permissions starting from android .
developers cannot guarantee that the required permissions are always held by their apps.
to avoid app crashes they need to properly insert permission check and request statementstoensureeverydangerousapiusedbytheirappsisnever invoked without the required permissions .
this is a nontrivial task even for experienced developers.
for example in issue o fk mail a famous email client for android the developers had discussed how to support runtime permissions for almosttwo years until they functionally covered the user experience of requesting runtime permissions .
apart from moving the permission granting process to run time the android platform has also changed the behavior of permissiongroups alteredmanyapis correspondingpermissions andsupportedone timepermissions .without trackingandproperlyhandlingsuchchanges appdeveloperscannot easily implement permission protected functionalities .
previousworkmostlystudiedhowtoadaptappstargetinglegacy platforms to the new platforms or detect arp issues fromthesecurityperspective .theproposedtoolscannoteffectively detect arp induced functional bugs for two reasons permission protected apis and their permission specification keepevolving whichisoverlookedbyalmostallexistingtools causing many arp related compatibility issues undiscovered.
most existing tools like arpdroid and revdroid leverage flowdroid s dummy main classes to model the implicit control flows within each component of an android app.however asdevelopersmaymanageruntimepermissions asynchronously across app components performing such an intra component analysis would produce false alarms.
tofurtherunderstandthelimitationsoftheexistingtoolsand thepracticesofarpmanagement weconductedanempiricalstudy byanalyzingthesourcecodeoftheandroidplatformand13 popularandroidapps.theresultsshowthatalargenumberofapps may be affected by the active changes of dangerous permissions and dangerous apis and asynchronous permission management is common in real world apps.
1afewcustomizedlegacyplatformsallowuserstorevokepermissionsafterinstallation .
they are out of the scope of this work.
requirespermission anyof access coarse location access fine location public void requestlocationupdates ... ... figure permission specification of a dangerous api drivenbyourempiricalfindings wedesignedandimplemented aper anandroidruntime permissionmisus ebugdetecto r.aperis anevolution andasynchrony awarearpbugdetector.itperforms both intra and inter component static analyses to find missing permissionandruntimeversionchecks.toevaluateaper webuilt a benchmark from real arp bugs.
the experiment results on thebenchmarkshowthataperoutperformsexistingtoolsbyan average improvement of .
on f1 score.
to further evaluate the usefulness of aper we applied it to analyze open source apps.
itsuccessfullyfound34realarpbugs.wesubmittedbugreportsto the app developers.
at the time of paper acceptance submitted bugshavebeenconfirmedbythedevelopersandsevenhavealready been fixed.
in summary we make the following contributions to the best of our knowledge we conducted the first empirical study on the evolution of arp specification and real world developers practices in runtime permission management.
weproposeda staticanalyzer aper fordetectingarpbugsin android apps with a special focus on evolution induced issues.
we performed an evaluation of aper including both control experiments on our prepared benchmark and an in the wild study on real world open source apps.
the results show that aper can significantly outperform existing tools.
we provided a reproduction package for future research at which includes aper s source code the benchmark of arp bugs and their patches and 34realarpbugsdetectedbyaper alongwithourissuereproducing videos detailed descriptions and developers feedback.
preliminaries .
permission specification android framework provides apis to perform sensitive operations suchasaccessingcontactsorusingthecamera.theseapisareprotectedbycorresponding dangerouspermissions andwecallthem dangerous apis.
for instance to open the camera an app should request the user to grant the camerapermission before invoking the dangerous api cameramanager.opencamera .
unlike dangerous permissions normal permissions e.g.
network vibration can be automatically granted when the app is installed .
generally androidpermissionshavefourprotectionlevels normal dangerous signature signatureorsystem where a bmeansthat the permission with a protection level bhas a higher risk than that ofa and thus granting them should follow different procedures.
inandroidframework startingfrom6.
apermission protected apicanusethe requirespermission annotationtospecifyits requiredpermissions.figure1showstheapi requestlocation updates and its annotation based permission specification.
according to this annotation any of the access coarse location or the access fine location permission should be granted beforeinvokingthisdangerousapi.similarly ifalllistedpermissions arerequiredbytheapi theywillbespecifiedbytheelement allof instead of anyof.
such annotations can help developers and static authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
aper evolution aware runtime permission misuse detection for android apps icse may pittsburgh pa usa if checkselfpermission access fine location granted dolocationingactions ... calls dangerous api else requestpermissions new string access fine location figure2 permissioncheckandrequestexample simplified checkers e.g.
lint to determine whether an api is protected by any permissions.
besides the annotation the permissions can alsobeimplicitlyspecifiedusingthe link android.manifest.
permission ... tag in an api s javadoc.
.
runtime permission management to acquire a permission an android app should declare it in the manifest file using the uses permission xml element.
this however does not guarantee that the permission can always be grantedaftertheappisinstalled.thelegacyplatformsprovideapis forappstochecktheirpermissionstatusesatruntime.underthe runtime permission model users are allowed to dynamically grant andrevokedangerouspermissions.thus thenewplatforms api level23andabove provideadditionalapistohandleusers runtime behaviors.
figure shows an example from the official documentation which involves permission check and request.
generally the permission management apis fall into four categories a checking permission status beforeinvokingapermissionprotectedapi anappwillcheckwhetherithastherequiredpermissionsbyinvokingthe checkapis e.g.
contextcompat.check selfpermission .
these apis typically accept a permission string and return whether the permission is granted or not.
b requesting for dangerous permissions to request dangerous permissions at runtime an app will call request apis likeactivitycompat.requestpermissions .thiswilltrigger a pop up dialog that prompts the user to either grant deny the permissionrequest orblocksubsequentpermissionrequests.unlike checkapis the request apis accept an array of permission strings to spawn multiple permission request dialogs.
c handling user response thehandle api onrequest permissionsresult int string int is an empty callback defined in the base gui classes.
it is invoked by the system after the user reacts to the permission request and its parameters store the user s granting results.
developers can override this callback to check the user s decisions and take actions accordingly.
d explaining permission usage theexplain api should showrequestpermissionrationale returns a boolean value of whether the user has denied the permission request and selectedthe neveraskagain option.developersmayuseittocheck whether the permission requests are blocked and explain to the user why the requested permission is essential accordingly.
empirical study to understand the practices of runtime permission management and the limitations of existing work we conducted an empirical study to investigate the following three research questions rq1 evolution of permission specification how do the permission protected apis and their permission specification evolve in the android platform?
rq2 impact of evolution how many android apps may be affected by the evolution of api permission specification?figure category distribution of the google play apps rq3 permission management practices how many android apps implement asynchronous permission managements?
inthefollowing wepresentourdatacollectingprocedures analysis methods and results.
.
dataset construction .
.
collecting api permission mappings.
forrq1 wecollected the api permission mappings from the android framework .
foreachapilevel wetraversedalljavafilestofindthoseapimethods that have requirespermission annotations or use link tags to specify their permission requirements .
the declared permissions are extracted from the framework s manifest file.
we did not adopt the existing mappings because their released datasets are outdated or the mapping extraction tools are unavailable or cannot be easily applied to analyze the new android versions.
more importantly as discussed in a recent work these mappings are neither precise nor complete.
since ourstudyneedsthelatestandpreciseapi permissionmappings we decided to extract mappings from the source code and docs.
.
.
collecting android apps.
rq2andrq3investigatethepermission management practices in real world apps.
to this end we crawled google play apps from androzoo according to two criteria ranking at top in each of the categories indexed byappbrain i.e.
theappsshouldbepopular containing call sites of both dangerous api s and permission management api s .asweimplementedouranalyzerontopofsoot awellmaintainedjavaprogramanalysisframework weexcludedallapps in the game category because they are mostly built using game engines that are not developed in java .
finally wecollected13 352popularappsthatinvolvedangerous permissionusages.thecategorydistributionoftheseappsisshown in figure .
in general our collected apps are evenly distributed among different categories thus studying them can reveal developers practices of arp management without bias toward certain app categories.
it is worth noting that we only focus on dangerous apis in rq2 andrq3.thereasonisthatnormalandsignaturepermissionsdo not require runtime management since they are granted at thetime of installation.
an app can use any api protected by such permissionswithoutusers explicitapprovals.inthiscase thesafety ofanapicallcanbeguaranteedbysimplycheckingwhetherthe required permissions are declared in the manifest file of the app.
.
rq1 evolution of permission specification .
.
analysis method.
westudiedpermissionsandpermissionprotectedapis byinvestigatingtheirdistributionsandhowthey have changed across android versions from .
to .
we grouped authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa sinan wang yibo wang xian zhan ying wang yepang liu xiapu luo and shing chi cheung table distribution and evolution of permission specification apilevel version number permissions apis protected by permissions evolved apis change of permissions normal dangerous signature total normal dangerous signature added deleted changed restricted relaxed same level .
.
.
.
.
we say a permission protected api is changedif its required permissions are changed.
the apis according to their required permissions protection levels.
wealsomerged signature andsignatureorsystem permissions .
into one protection level because they are restrictively used by specific apps and cannot be accessed by all developers .
.
.
results.
table summarizes the evolution of permission specification from android .
to .
columns show that the numberofpermissionsgenerallyincreasesastheandroidplatform evolves regardlessoftheirprotectionlevels.signaturepermissionsgrowthefastest whichisinlinewithpreviouswork .columns show how many api methods are protected by permissions ofspecificprotectionlevels.notethatthemappingbetweenapi methods and permissions is not bijection.
it is possible that an api requiresmultiplepermissions orapermissionisboundtoa constantfieldratherthananymethods.columns9 11reportthe evolution of permission protected apis in consecutive versions interms oftheiraddition deletion andmodification.asandroid platformevolves morepermission protectedapisareadded.meanwhile the numbers of deleted changed apis are also increasing.
thepermissionchangesofapisareshowninthelastthreecolumns.
wesayachangedapibecomes restricted ifitrequiresapermission withahigherprotectionlevelinnewversions and relaxedonthe contrary.besides anapicanalsoswitchtoanotherpermissionwith thesameprotectionlevel thelastcolumn .asshownincolumns thechangedapistendtorestricttheirpermissionsinnew versions or change to other permissions with the same protection level.
only a few require permissions with lower protection levels.
fromtheresults wecanseethat dangerouspermissionsand apisconstantlyevolvealongwiththeandroidplatform .for example 29outofthe580newapisrequiredangerouspermissionsinandroid11 andsevendangerousapisaredeletedfromandroid .forthoseapisthatchangetheirrequiredpermissions 20are related to dangerous permissions becoming either restricted or relaxed .
as dangerous apis are commonly used to implement sensitive features their usages and compatibilities should be carefully checked to avoid unexpected runtime behaviors.
.
rq2 impact of evolution .
.
analysis method.
tostudyrq2 wefirstanalyzedalldangerousapissinceapilevel23.intotal therewere246dangerousapis withdifferentmethodsignatures uptoapilevel30 .wefoundthat of them have undergone changes which account for a large proportion.whenusingsuch evolvingdangerousapis developers shouldcarefullyexaminetherunningdeviceversionsanddealwithtable top commonly used evolving dangerous apis rankdangerous api used appsdangerous api appid only used apps appid only getdeviceid getdeviceid getserial getline1number setrequireoriginal getaccounts getcelllocation getsubscriberid getline1number oncallstatechanged getsubscriberid getsimserialnumber getsimserialnumber getserial getimei getimei getaccounts getcelllocation getdeviceid int getgpsstatus the permission changes to avoid unexpected program behaviors e.g.
crash .rq2aimstoquantifythepotentialimpactofthe evolving dangerous apis on real world apps.
given an android app for each call site of the evolving dangerousapi weextractedallpossiblecallingcontexts which are paths in the call graph cg starting from an entry method including lifecycle callbacks e.g.
oncreate event handlers e.g.
onclick threads runnable.run etc.
andendingwiththat api.weusedflowdroid toconstructcgsandidentifyentry methods.
if an app contains calling contexts to an evolving dangerousapi wesay theapp usestheapi.
thisstatic analysismay produceover estimated results with infeasible calling contexts.
in particular the dangerous apis may be called from third party libraries tpls butarenotusedbythehostapps .to eliminate the influence of tpls we dropped those contexts whose entry methods lie in packages that are different from the app s package id .
this strict condition may filter out more contexts thannecessary e.g.
whenpackagenamesareobfuscated hence producing under estimated results.
to answer rq2 we analyzed both the over estimated and under estimated results.
.
.
results.
table lists the top commonly used evolving dangerousapis.theleftpartpresentsthe over estimatedresults .
under this setting the api getdeviceid is used by apps rankingatthefirstplace.thisapirequiresadangerouspermission read phone state inapilevel23to28.since29 itshouldbeused with the signature permission read privileged phone state and thus can no longer be used by general apps.
as described inthe documentation for apps targeting or above calling this api will result in a securityexception .
in our dataset we found that each app has a median number of three calling contexts that can reach this api.
if developers do not carefully deal with authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
aper evolution aware runtime permission misuse detection for android apps icse may pittsburgh pa usa figure4 fourtypesofpermissionmanagements twoentry methods are distinct callbacks in the same component the permission changes in api level the affected apps may encountercrashesatruntime.intotal weobservedthat69outof the evolving dangerous apis are used in our dataset and .
of the apps use at least one of these apis.
therightpartoftable2presentsthe under estimatedresults .
even with our strict filtering condition we still found that apps invoke dangerous apis while .
of them invoke at least one evolving dangerous api.
in addition getdeviceid is still the most commonly used evolving dangerous api.
in summary we can see that a largenumber of apps maybe affected by the evolution of permission specification.
.
rq3 permission management practices .
.
analysis method.
ideally an app should always check the permissionstatusbeforecallingdangerousapis andrequestthe permissionsiftheyarenotgranted.thiscanbeaccomplishedby callingcheckandrequest apissynchronouslybeforeeachdangerousapicall asshowninfigure2.theandroiddeveloperguide alsosuggestssucha synchronous permission management .
however synchronouspermissionmanagementcanbeimpeded by many factors e.g.
developers maintaining effort or user experi enceconcern .inpractice developersmaychoosetoimplement permission management beyond the synchronous way.
figure illustrates four types of permission managements.
in figure a and b the dangerous api and the corresponding permissionmanagement apiareinvoked synchronously.the only differencebetweenthetwocasesisthatthe check request is wrapped in another method call in figure b .
it is noteworthy that we only consider checkandrequest apis here because they are indispensable for runtime permission management theother two types of apis mentioned in .
are optional .
apart fromthesynchronousway developerscancalldangerousapisandpermissionmanagementapisasynchronouslyindifferentcallbacks sinceandroidprogramsareevent driven .forexample adangerousapiandthecorrespondingpermissionmanagement apicanbeinvokedfromdifferentcallbacksinthesameappcomponent figure c .
it is also possible that dangerous api and the corresponding permission management api are invoked from the entrymethodsin twodistinctcomponents withinter component communication icc figure4 d .werefertothelasttwocases asasynchronous permission management.to study rq3 wefirst extracted the calling contexts ofdangerous apis dangerous contexts and permission management apis check request contexts from each of the apps.
then we categorized these contexts into the above mentioned four types of permissionmanagements.forexample adangerouscontextand a check context will be considered as the intra procedure case if bothcontextshaveidenticalprefixesexcepttheirlastnodes.dueto pagelimit wedonotfurtherelaborateonothercases.itisworth explainingthatadangerouscontextmayhavemultiplematching checkcontexts.imaginingthatthereisanothercalltoa checkapi inside dolocationingactions infigure2 thenthedangerous api called in dolocationingactions would match both the intra proceduralandinter proceduralchecks.inthiscase wewould match the dangerous api with the closest one according to theprinciple of locality .
also note that the same dangerous api may have different permission mappings in different android versions.
here we only consider the mapping in the app s target sdk version which is specified in its manifest file.
ourstaticanalysisalsoneedstoinferstringvalues.forexample when analyzing the code in figure we should know the stringarguments access fine location ofthecheckand request api calls to match the permission management api calls with the dangerous api call in dolocationingactions .
such string analysis is difficult in general .
however we observed that developers often employ permission string literals e.g.
those defined in the class android.manifest.permission for permissionmanagements withoutperformingcomplexstringoperations .
hence we modeled our string analysis task as a classic reaching definition dataflowanalysisproblem sisastatement pred s returns the predecessor statements of s gen s andkill s are the dataflow facts generated or killed by s respectively in s uniondisplay.
p pred s out p out s gen s in s kill s when the iterative equation solving converges the possible string values on a call site ccan be retrieved from the set in c .t oa v o i d unnecessarycomputation weonlypropagatedataflowfactsrelated to string and string array variables.
most android specific analyses such as identifying app components and building intra component cgs rely on flowdroid.
to analyzeicc weusedtheicclinkextractionrulesintroducedin iccta .
we did not directly apply the iccta tool as it relies on ic3 whichisoutdatedandfailedtoanalyzemostofourapps.to realize inter procedural reaching definition analysis we employed theifdssolverheros .toensurethatthepermissionusages are implemented in the apps rather than tpls we only considered the calls to dangerousand permission management apis from the apps packages.
apps in our dataset satisfy this condition.
.
.
results.
figure5presentsthedangerousapicallingcontexts with respectto the four types of permissionmanagements using violin plots.
for better visualization we excluded apps with an extremely large number over of dangerous api calling contexts.
for ease of understanding we explain the first violin plot.
the left part of the violin has a median of three the right part has a median of two and the violin is labeled with .
this means authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa sinan wang yibo wang xian zhan ying wang yepang liu xiapu luo and shing chi cheung figure distribution of dangerous api calling contexts with respect to the four types of permission managements thatthereare465appsthatimplementintra proceduralpermission checksorrequests.amongtheseapps amediannumberofthree dangerousapicallingcontextsareprotectedbyintra procedural permissionchecks whileamedianoftwodangerousapicalling contexts have intra procedural permission requests.
intuitively the area of each violin reflects the adoption of the corresponding permission management practice.
for instance the right part of the first violin is the smallest meaning that only a fewappsrequestpermissionsinsidethesamemethodwherethedangerous apis are called.
in fact only apps contribute to this part.
the intra procedural permission checks are also the least commonasshownintheleftpart.incontrast 621appsadoptinterprocedural permission managements which usually happen when developers wrap the check request api calls in self defined methods for code reuse e.g.
in syncthing issue .
asynchronous permission managements are more common than synchronous permission managements according to the results of the apps perform inter callbackpermissionmanagementand899appsperforminter componentpermission management.
in total out of the .
apps adopt asynchronous permission management.
we further investigated the calling contexts of asynchronous checks andrequests andfoundthatmostoftheirentrymethodsare onclick and oncreate .
there is a large number of request calls starting from onstart in which ui elements are suggested to be drawn .
in these scenarios users usually receive permission request dialogs after they click a button that performs sensitiveoperations or switch to a new activity that requires dangerouspermissions.notethattheseresultswereobtainedfollowingthe under estimation setting discussed in .
.
.
we also did the same analysisfollowingtheover estimationsettingandobservedsimilar context distributions.
due to page limit we omit the details.
discussions.
asynchronouspermissionmanagementcanavoid redundant checks andrequest s. however it brings challenges to developers as they should examine both the dangerous api call sitesandallrelatedappcomponentstoseewhethertherequired permissions are already requested and granted.
moreover they shouldcarefullyhandlethecasewhentheusersrevokeaparticular permission required by the dangerous api since asynchronous permission requests may be unavailable in this scenario.
asynchronous permission management practices also complicate arp bug detection.
a conservative detector that considersan app buggy whenever a synchronous checkorrequest is missing at a dangerous api call site e.g.
revdroid may produce many false alarms if asynchronous permission management figure overview of aper canalreadyprotectthedangerousapicall.furthermore asusers mayrevokepermissionsbetweentwoasynchronousevents howto determinewhethera checkcanprotectasubsequentdangerous api call is also a technical challenge for static bug detectors.
as we willsee in .
asynchronouspermission managementscanlead tobothsafepermissionusagesandappcrashes whichcannotbe distinguished by existing tools.
aper .
overview our empirical study reveals that a large number of real world apps perform asynchronous permission managements which complicates permission checking and may lead to subtle arp bugs.
moreover compatibilityissuesmayariseduetotheactivechangesofthe mappingsbetweendangerousapisandtheirrequireddangerous permissions api dp mappings .
to ease subsequent discussion we first define two common types of arp bugs type missingpermissioncheck adangerousapiiscalled without a permission check on the target android version.
type incompatible permission usage adangerousapi can be called on incompatible platforms or the evolution of permission specification is not fully handled.
accordingto thesetwotypesofbugscorrespondtothenonlibrary interfered arp issues except those caused by device manufacturers customization whichaccount for60.
oftheir studied realarpissues.existingtoolscannoteffectivelydetectthesetwo types of common arp bugs in android apps.
this motivates us to design a new approach to detect these bugs.
figure6showstheoverviewofourtool aper.ittakesanandroid application package apk file and the api dp mappings as input andoutputsthecallingcontextsofdangerousapisthathave potential type or type bugs.
its analysis procedure consists of three components thecontext extractor traverses the cg of an app and performs backward analysis from the call sites of dangerous apis andcheckapistoextractallpossiblecallingcontextsofthese apis.
similar to our approach in the empirical study a dangerous context will be matched with checkcontexts figure according to the api dp mappings.
the only difference here is that the mappings for all android versions will be used in ordertodetecttype 2bugs.theprocessedcallingcontextswill be analyzed by the misuse detector to locate arp bugs.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
aper evolution aware runtime permission misuse detection for android apps icse may pittsburgh pa usa if build.version.sdk int checkselfpermission access fine location !
granted requestpermissions new string access fine location return p2pmanager.creategroup ... evolving dangerous api figure an example of handling api evolution in order to know which permissions are checked at each call site of the checkapi the dataflow analyzer conducts a reaching definition analysis on the inter procedural controlflow graph icfg of the app to infer the possible string values passedtothe checkapi .
.
.thishelpscontextextractor to match a dangerous context with the checkcontexts that possiblyprotectthedangerousapicalls.todetecttype 2bugs thedataflowanalyzeralsoanalyzestheruntimeversion rv checks that guard dangerous api calls to infer reachable rvs on which the dangerous apis can be invoked.
themisuse detector leverages the api calling contexts and dataflowfactsgeneratedbytheothercomponentstolocatebugs.
theideais adangerousapicontextwithoutproperpermission checksmaycontaintype 1bugs anevolvingdangerousapi context without proper rv checks may contain type bugs.
it is worth noting that aper does not analyze the usages of therequest apis as the request process is asynchronous and cannot guard the calls to dangerous apis.
nonetheless the misuse detectorwillconsiderthedangerousapicallswithinthe handle callback .
which handles the request results.
most of theanalysesperformedbyaperhavebeendetailedinourempirical study .
.
.
in the following we explain how aper analyzes rv checks and detects type type bugs.
.
analyzing reachable runtime versions figure7showshowthedevelopersofapopularapp vpnhotspot handledtheevolutionofadangerousapi.startingfromapilevel29 the api wifip2pmanager.creategroup requires the dangerouspermission access fine location whileitdoesnotrequire permissionsinthepreviousapilevels.astheexampleshows to invoke the dangerous api on compatible android versions theapp first checks the value of the field build.version.sdk int which is widely used to handle incompatible api usages .
todetectincompatiblepermissionusages aperneedstoinfer thepossiblervsonwhichadangerousapicanbeinvoked.forthis purpose aper performs dominator analysis .
in a flow graph a nodeddominates another node nifdexists on every path starting fromtheentrynodeto n i.e.
toreach n itsdominator dmustbe gone through .
in an android app if a dangerous api call site is dominatedbysomervchecks thesechecksthenconstrainthervs on which the api can be invoked.
we call such rvs reachable rvs.
algorithm1explainshowaperanalyzesreachablervs.givena dangerous context aper analyzes all methods invoked prior to thedangerousapi lines2 tolookfordominatingrvchecks line6 .
a statement is an rv check if it is a conditional statement and the conditionreferstotheconstantfield build.version.sdk int2.
whenanrvcheckisfound aperwillsolvetheconstraintinvolved 2this approach may miss some runtime version checks.
however such cases are rare in practice .algorithm analyzing reachable rvs input dangerous api calling context p1 shortrightarrowp2 shortrightarrow shortrightarrowpn piare call sites and pncalls a dangerous api output set of reachable rvs ... lav 1reachablerv shortleftarrow ... lav 2fori shortleftarrow1...n 1do 3m shortleftarrowgetbodyofcalledmethod pi 4dominators shortleftarrowm.finddominatorsof pi 5forstmt dominators do 6ifisrvcheck stmt then rvs shortleftarrowsolveallsatisfiable stmt reachablerv shortleftarrowreachablerv rvs 9returnreachablerv lav stands for the latest android version.
in the condition to find all reachable rvs line .
if there exist multipledominatingrvchecks aperwillcomputetheconjunction of the reachable rvs constrained by each check line .
it should be pointed out that rv checks may not necessarily dominate a dangerous api call site in order to protect it.
consider twoseparatervchecksintwoparallelprogrambranchesandboth branchescanleadtothesamedangerousapicall.insuchacase neither check dominates the dangerous api call although it is guaranteedtobecalledsafely.toreducealgorithmiccomplexity aper does not take such unusual cases into account.
.
detecting arp bugs themisusedetectordetectsarpbugsbyanalyzingeachdangerous contextandtwootherpiecesofinformation asetofmatching checkcontexts provided by the context extractor and all reachablervsprovidedbythedataflowanalyzer.inthefollowing we describe how aper detects type and type bugs in detail.
.
.
detecting type bugs.
a type bug occurs when a dangerous api is called without permission checks on the target android version.inthemosttrivialcase atype 1bugcanbereportedwhen thesetofmatching checkcontextsisempty.ifthesetisnotempty we need to analyze whether the checkcontexts could safely protect the dangerous context.
there are three cases to consider if thecheckapi and the dangerous api are synchronously called aperwillexaminewhethertheformer scallsitedominatesthelatter sontheicfgandwhetherthedangerousapi is reachable from the checkapi s positive branch.
if thecheckand dangerous apis are called in different callbacks of an app component aper will examine whether thecheckcontext s entry method precedes the dangerous context s e.g.
oncreate mustprecede onstart onresume mustprecede onclick .ifadangerousapiiscalledincallbackawhilea checkiscalledincallbackbthatmustprecede a such a permission check is safe.
to analyze the execution order of callbacks we used the temporal constraints defined by liuetal.
todistinguisherroneousasynchronouspermission checks from safe cases.
if thecheckapi is called in a component c while the dangerousapiiscalledinanothercomponent c prime aperwillexamine authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa sinan wang yibo wang xian zhan ying wang yepang liu xiapu luo and shing chi cheung whetherthe checkapi scallsite morespecifically itspositive branch in cdominates the call site of the icc method that launches c prime.
ineachcase ifadangerouscontexthasnodominating checks aperwillreportatype 1bug.toavoidfalsealarms aperwillnot reportbugsin twocases the dangerousapicalliswrapped in atry catch blockthathandlesthe securityexception .some developersmayusesuchaworkaroundtoavoidappcrashes instead ofexplicitlyperformingpermissionchecksbeforecallingdangerous apis.
insidethe handle callback thedangerousapiiscalled after checking the permission request results.
since the permission requestresultsarepassedasaparametertothiscallback developers canchecktheparametervaluetolearnthepermissionstatusand invoke dangerous apis when the permission is granted.
.
.
detecting type bugs.
a type bug can occur when a dangerousapiiscalledonincompatibleandroidversions callingnew apis on old platforms or removed apis on new platforms or the permissions required on different versions are not fully handled.
aper detects type bugs by examining whether a dangerous api can be safely called on all reachable rvs except the app s targetsdk version which is already analyzed when detecting type bugs.givenadangerouscontext withacorrespondingreachable rvv if the dangerous api does not exist in the api dp mappings of the android version v then a type bug can be reported.
this can happen if the api has been deleted or not yet introduced.
ifthe api exists in the mappings then aper will analyze whether theapiisinvokedwithadominatingcheckofthecorresponding permission required on the android version v which is essentially thesame asdetecting type 1bugs.
aperwillreport atype bug when there are no dominating permission checks.
evaluation our evaluation aims to answer two research questions rq4 effectivenessof aper howeffectiveisaperindetecting arp bugs compared with the existing tools?
rq5 usefulness of aper can aper detect unknown arp bugs in real world apps and help developers diagnose them?
inthefollowing wepresentourexperimentsandanalyzetheresults in detail.
we also discuss some real arp bugs detected by aper.
.
rq4 effectiveness of aper .
.
constructing benchmark.
to study rq4 our evaluation subjects should contain both type and type bugs.
more importantly to understand how the tools report false alarms we need subjectsthatusedangerousapiscorrectly.forthispurpose weconstructedabenchmark arpfix leveragingrealarpbugsinopensource apps and their patches.
specifically we collected projectsfrom github that have both issues related to checkapis and dangerous apis to identify arp bugs and commits or pull requests that fix the issues to locate the bug fixes .
we found suchprojectswithatotalof71arpissues whichcorrespondto71 arp bugs.
for each bug we then applied the following procedure on both the buggy version and the patched version locating the related dangerous api finding the api s corresponding permission management code via manual inspection removingtable comparison results with the existing tools type type lintarpdroid revdroid aper lint aper tp tn fp fn failed precision .
.
.
.
.
.
recall .
.
.
.
.
.
f1 score .
.
.
.
.
.
revdroid fails on both versions of the three subjects.
irrelevantappclasses methods attributes andtpls untilaminimal compilable apk remains.
for the ease of experiments each apk has only one dangerous api and thus a buggy apk contains only one arp bug.
if we could not build an apk we simply dis carded that bug.
finally buggy apks were successfully built among which contain type bugs and contain type bugs.
correspondingly each buggy apk has its patched version.
.
.
baselines and metrics.
tothebestofourknowledge there are three available static analysis tools that can find arp bugs lint is a built in checker in android studio which is the officialidefordevelopingandroidapps.itcanreportmissing permission checks and rv checks and we treat these two types of warnings as type and type bugs respectively.
arpdroid isanacademictoolforautomaticruntimepermission management.
if it inserts permission management statements on any calling context of a dangerous api we consider that it detects a type bug.
revdroid is also an academic tool which can detect unhandled permission revocation on a dangerous api call and we treat its warnings as type bugs.
for fair comparisons we did not consider testing based tools e.g.
patdroid orsetdroid becausetheirperformancesheavily rely on the underlying tests coverages.
to answer rq4 we applied aper and the three tools on arpfix and compared their performance using the following metrics true positives tp buggy versions that have warnings true negatives tn patched versions that have no warnings false positives fp patched versions that have warnings false negatives fn buggy versions that have no warnings basedonthem wecanfurthercalculate precision tp tp fp recall tp tp fn andf1 score p r p r to measure their effectiveness.
.
.
results and analyses.
table shows the comparison results.
we can see that aper outperforms the baselines on all metrics.
for type bugs aper achieves an f1 score of .
with an improvement of .
.
.
.
over revdroid which performedthebestamongthebaselines.asfortype 2bugs the improvement of aper over lint which is the only baseline tool that supports detecting type bugs on f1 score is .
.
on average aper outperforms existing tools by .
.
.
on f1 score indicating its effectiveness on arp bug detection.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
aper evolution aware runtime permission misuse detection for android apps icse may pittsburgh pa usa for type 1bugs the baselinetools suffer from lowprecisions.
we manually investigated these tools and figured out the main reasons.first lintperformsflow insensitiveanalysisandonlydetects the presence of checkwithout considering the api dp mappings orthereturnvalueof check.forarpdroid wefoundthatitonly insertschecks andrequest s without properly dealing with the existingcallstotheseapis.thebestbaseline revdroid leverages flowdroidtogenerateanalysisentrypointsandcannothandleicc well .aswewillseein .
onlyperformingintra component analysismayproducemanyfalsealarms.incomparison aperexplicitly models both synchronous and asynchronous permission checks which greatly improves the precision.
thebaselinetoolshavelowrecallsonbothtypesofbugs.the primary reason is the incompleteness of the api dp mappings which is also a major reason for aper s low recall on type bugs.
forexample theapi camera.open doesnotspecifyanypermissioninthedocumentation andthusisnotcoveredinourmappings.however in practice apps would request the user to grant camera permission before invoking it .
another reason is that some issuesinourbenchmarkarerelatedtocontentproviders.currently neither the baselines nor aper can analyze the behavior of content providers.
we will address the limitations of aper in the future.
.
rq5 usefulness of aper .
.
collecting real world apps.
toanswerrq5 wecollected214 appsfromf droid awidelyusedopen sourceappcatalogue to seewhetherapercandetectarpbugsfromreal worldapps.theseappswereselectedfollowingthreecriteria invokingatleastone dangerousapi containingidentifiable checksorrequest s and having commit records in the recent three years in their coderepository.weonlyperformedexperimentsonopen source apps because we need the source code to verify the detected bugs manuallyreproduceappcrashes andcommunicatewiththeapp developerstoinvestigatewhetheraperisuseful.itshouldbenoted that aper can also help detect bugs in closed source apps.
.
.
study method.
we ran aper on the apps and manually verifieditsreportedarpbugs.wefirstinvestigatedthereported contexts to see if aper was functionally correct.
then we tried toreproduceabnormalbehaviorsbasedonthegivencontext.for example if aper reports a type bug on backupactivity w e would launchthe app goto its backup page then revoke theconcerned permission s in the system settings and go back to theapp.
typically the app would crash or behave abnormally after were enteringit.however ifwecouldnotfindthedesiredpage e.g.
the backupactivity afterthoroughlyexploringtheapp we treatedthiscaseasunverified.asfortype 2bugs wewouldverify them under a similar procedure with type bugs but on multiple android devices.
our main focus was whether their runtime behaviorswereconsistentacrossdifferentandroidversions.weused android devices most of which run the stock android systems with api levels ranging from to .
onceweverifiedanarpbug wereportedittothedevelopers via the issue tracking system links provided on f droid.
to help developersdiagnosethebugs werecordedvideosandappended themtothebugreports ifwecouldreproducethem.forsomebugs we also sent our suggested patches to the developers to fix them.table summary of detected arp bugs detected verified reported confirmed fixed videos type type ethical considerations .toavoidspammingtheopen source community and the developers we reported an issue only when it couldbereproducedonatleastthreedifferentandroiddevices and submitted pull requests only after we had thoroughly tested the patched code.all issuereports andpull requestsweresubmitted in compliance with the projects contributing guidelines and licenses.
.
.
results.
table4summarizesthearpbugsdetectedbyaper.
among the detected arp bugs we identified true type bugs and11 truetype bugs.wereported 30of the34 truebugs.
we did not report the other four bugs because the issue tracking systemsofthecorrespondingappswereclosedatthetimewhen we conducted the experiments.
nonetheless we still put the bug reproductionvideosonourprojectsite.atthetimeofour paper acceptance 17ofourreportedbugshavebeenconfirmedandseven bugs have been fixed.
specifically three bugs were fixed by our suggested patches.
interestingly two of the fixed bugs are in tpls acra andkahelpers .
both of them are popular on github with .7k and stars respectively .
during our manual bug verification we found that aper reported arp bugs in them when analyzing the host apps.
after analyzing the root causes of the bugs wedecidedtoreportthemtothelibrarydevelopers rather than the app developers.
such a case will be discussed in .
.
.in total videos were successfully recorded.
among them videos recorded test cases that trigger app crashes two were about program stuck and the remaining two were inconsistent behaviors on different android devices.
each test case was constructed by us intypicallylessthantenminutes afterexaminingaper soutput andtheapp ssourcecode.theseresultsshowthatapercandetect real arp bugs and produce useful debugging information.
21detectedbugsarefalsealarms.amajorityofthemarecaused by specific api usages.
for example bugs are related to the dangerous api getexternalstoragedirectory which returns a directorypathintheexternalstorage.arecommendedwaytoexam inethispath sreadabilityistocheckthe read external storage permission .however developersmayalsouseotherapisforthe samepurpose suchas file.canread injdk.inthissituation aperwillreportatype 1bugforlackof checkapis althoughthe fileaccessissafe.wefailedtoverifytheremainingbugsbecause triggeringthemrequirescomplicatedsetupsorinteractions e.g.
triggeringa bugin kore requires aconnected kodiplayer .it is worth noting that these unverified bugs are not necessarily false alarms.
.
case studies inthissubsection wediscussseveraltypicalcasesobservedduring our study to facilitate the design of future tools.
.
.
a type arp bug.
figure8 showsatype 1bugcaused by inter component permission usage.
it was found in ml manager anopen sourceappmanagerwith100k installsongoogle authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa sinan wang yibo wang xian zhan ying wang yepang liu xiapu luo and shing chi cheung request storage permission click allow click delete files success revoke storage permission success alt click delete files crash mainactivity settingsactivity system settings figure an inter component type bug in ml manager void oncreate bundle bundle ... if issdcardpermissionnotgranted requestsdcardpermissions else intent new intent directorypickeractivity startactivity intent figure9 asafeinter componentarpusageintrickytripper in class savetosdcardactivity simplified play.
normally the user grants the storage permission in the app s mainactivity and then the app can delete cached files when the user operates in the settingsactivity .
however because the lattercomponentdoesnotinvolve checksorrequest s oncethe userrevokesthestoragepermissionafterenteringit theappcan nolongeraccessthedevice sexternalstorage.insuchascenario deleting files will result in a crash.
this bug was fixed in the app s .
.
version.
developers added checkin the button click listener to avoid unprotected storage access.
we found that three out of the four tools could detect this bug except lint since the app has checkstatements in other unrelated components.
.
.
a safe inter component arp usage.
static analyzers may reportfalsealarmsonsafeinter componentarpusages.figure9 shows such an example from the app tricky tripper .
the directorypickeractivity displays the file directory and thus needsstoragepermission.thisactivitycanonlybelaunchedwhenthe permission is granted so the usage is safe.
however both arp droidandrevdroidwouldreportthelackofpermissionmanage mentin directorypickeractivity .incontrast apercanavoid thisfpby resolving the icc between the two components.
.
.
a type bug in tpls.
aswediscussed somebugscanoccur in tpls.
instead of blaming the host apps we reported these issues tothelibrarydevelopers.figure10showsourpullrequestinthe libraryacra written in kotlin language which fixes the issue caused by the evolution of the dangerous api getdeviceid .override fun collect ... ... target.put reportfield.device id telephonymanager.deviceid val deviceid if sdk int telephonymanager.deviceid else null target.put reportfield.device id deviceid figure pull request in acra library simplified after compilation the expression telephonymanager.deviceid istransformedintothisdangerousapi.theapi getdeviceid is commonly used in real world apps as shown in table .
since api level many apps may throw a securityexception when invokingthisapibecauseitstartstorequireasignaturepermission which is not available to general apps.
to avoid app crashes we enforce the api to be called under api level and the api will return a nullvalue on newer android versions.
this patch has beenapprovedbytheprojectmaintainer andwillbemergedtothe next release of the library.
.
.
an intended permission misuse.
in fact not all detected bugs areconsideredharmfulfromthedevelopers perspectives.forexample the api getconfigurednetworks starts to require finelocationpermissionsinceapilevel29.in netguard aninternet firewall app with over five million installs aper reported that this apicalllackspermissionchecksonapilevel29andabove.theapp developerconfirmedthisistrue .however forprivacyconcerns theydonotwanttheirapptorequestthelocationpermission.they would rather disable the related features.
threats to validity the validity of our study results is subject to the following threats incomplete api permission mappings.
we built the mappings between apis and permissions via analyzing the annotationsand javadocs in the source code of the android framework.
we didnotdirectlyusemappingsfrompreviousworkduetothefollowing reasons as the android platform constantly evolves existing mappings can quickly become outdated.
for example arcade only released the mappings up to api level while the mostrecent work dynamo only released mappings for two api levels 23and29.
themappingextractiontoolsareunavailable or difficult to use.
the existing mappings are either imprecise orincomplete aspointedoutby .anexampleispscout which was claimed to contain at most incorrect mappings.
in contrast although our approach may extract incomplete mappings theyarepreciseand moreimportantly up to datewiththelatest android version.
false positives in the extracted contexts.
extractingalldangerousapi callingcontextstounderstand thearppracticesmay leadtofalsepositives.tomitigatethethreat weproposedtheunderestimation setting which only considers entry methods within the app s package.
we also performed manual validation by sampling appsfromf droidandinspectingtheirextractedcontextstoensure the precision of our analysis.
benchmark may not be comprehensive.
it is hard to thoroughly understand the buggy code and the patches in our selected open sourceapps.thus ourbenchmarkmaynotfullyreflectthedevelopers usagesofdangerousapisortheirpracticesofpermission management.
to address the threat two authors worked together to understand the bugs patches and built arpfix.
we also made it authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
aper evolution aware runtime permission misuse detection for android apps icse may pittsburgh pa usa publiclyavailable.wehopethatfutureresearcherscanhelpfurther improve arpfix which may benefit the whole community.
related work we discuss three categories of related work in this section.
mining permission specification.
building reliable android permission specification has been extensively studied for many years .
most existing studies employed either dynamic analyses e.g.
stowaway or static analyses e.g.
pscout to find api permission mappings.
among them stowaway copes pscout and axplorer were proposed before the adoption of the runtime permission model.
arcade is a static approach proposed in for extracting permission specification.itaddressed theissueof imprecisemappingbyhandlingpath sensitivityintheapis.itsmappingconsidersnotjust thepermissionprotection butothersecurityattributes e.g.
api caller s uid pid .
dynamo is a dynamic approach that extracts permission mappings through api fuzzing.
in their paper theauthorsstatedthatonly76.
ofthecommonapisreportedbydynamoandarcadehavematchingsecuritychecks.sincedynamo buildspermissionmappingsthroughdynamictesting itsresultis supposedtobemoreprecise.however theseexistingmappingsare either outdated or incomplete arcade released the mappings upto api level dynamo only released the mappings in two api levels and .
ourmappingextractionwasinspiredbydpspec whichalso extracts mappings from the annotations and javadocs of the android framework apis.
however their mappings were unavailable and that was the reason we extracted the mappings by ourselves.
runtime permission migration.
since the emergence of android6.
manyattemptshavebeenmadetomigratelegacyapps to the new runtime permission model.
most of them applied static analysis on an app s icfg or other variants to decide proper programlocationstoinsertcallstopermissionmanagementapis.
arpdroid insertscallstothe check request and handle apis into its identified incompatible permission responsible callers.
however itdoesnotproperlydealwiththeexisting checkand request api call sites and thus suffers from low precision and recall.
gasparis et al.
pointed out that most developers consideredmigratingtotheruntimepermissionmodeltobelaborious.to easemigration theyproposeddroidm tomigratelegacyapps with comprehensive runtime permission managements.
previous methods were proposed under the assumption that the apps under processing target legacy platforms thus they chose to actively insert calls to permission management apis whenever a dangerous api call site lacks permission management.
in comparison aperonlyreportsthosedangerouscontextsthatarenot dominated by permission or rv checks.
it helps developers findpotential arp bugs in their apps and avoid unexpected runtime behaviors such as crashes.
arpbugdetection.
runtimepermissionmigrationhasbecome less important in recent years as most apps have targeted new android versions .
however various arp bugs are still lurking inappsanddifferenttechniqueshavebeenproposedtodetectthem.
revdroid appliesreachabilityanalysisonthecgofanapp to detect unexpected consequences after permission revocations.huangetal.proposedastaticmethodtodetectstubbornpermission request which repeatedly spawns a request dialog until the usergrantsthatpermission.theyalsoappliedreachabilityanalysisonthecgtodetectsuchbehaviors.unlikeaper thesestaticmethodsdonotfullyconsiderasynchronouspermissionmanagement which is a common practice for app developers as revealed by our empiricalstudy.rtpdroid candetectthelackofpermission checksbeforesensitiveoperations.however thework smainfocus is onmodelingand detectingimplicitly maliciousbehaviors thus falls into the security perspective.
we did not compare aper with rtpdroid because the tool is not publicly available.
patdroid applies hybrid analysis on an app to find crashtriggering test cases and permission combinations.
terminator alsodetectspermissionmisusesviahybridanalysis butitfocuses onsecurity issues.
setdroid candetect system settingrelatedbugsbyinjectingsetting alteringactionsinthetestevent sequences.
it is capable of finding bugs caused by permission revocation.
however the performances of these test driven approaches heavily rely on the underlying tests coverage.
aper as a static detector models the permission usages and managements as four types of api invocation relations and comprehensively analyzes the existences of two types of arp bugs.
tothebestofourknowledge aperisthefirsttoolthatisable to detect arp bugs caused by evolving permission specification.
moreover its modeling of the dangerous api calls and permission managementshelpsreducefalsealarmsandprovideeffectivedebugging information as we have shown in the experiments.
conclusion and future work in this paper we studied the evolution of android permission specification and real world developers permission management practices via analyzing the android framework source code and top ranked android apps.
we found that both evolving dangerous apis and asynchronous permission managements are widely used byreal worldapps whichpotentiallybringarpbugsbutcannot be detected by existing tools.
to detect the two types of arp bugs we proposed aper a new static analysis based permission misuse analyzer.
we evaluated aper with control experiments on a bench mark prepared by us and an in the wild study on open source android apps.
the results show that aper can significantly outperform existing tools and find real bugs in popular android projects withusefuldebugginginformation.inthefuture weplantoextend apertosupportmoretypesofruntimepermissionbugs suchas library induced or device specific bugs.