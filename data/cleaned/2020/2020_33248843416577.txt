inferring and applying def use like configuration couplings in deployment descriptors chengyuan wen wechyu88 vt.edu virginia tech blacksburg virginiayaxuan zhang yaxuan93 vt.edu virginia tech blacksburg virginia xiao he hexiao ustb.edu.cn university of science and technology beijing chinana meng nm8247 vt.edu virginia tech blacksburg virginia abstract when building enterprise applications on java frameworks e.g.
spring developers often specify components and configure operations with a special kind of xml files named deployment descriptors dd .
maintaining such xml files is challenging and time consuming because the correct configuration semantics is domain specificbutusuallyvaguelydocumented and existing compilers and program analysis tools rarely examine xml files.
to help developers ensure the quality of dd this paper presents a novelapproach xeditor thatextractsconfigurationcouplings i.e.
frequentlyco occurringconfigurations fromdd andadopts the coupling rules to validate new or updated files.
xeditor has two phases coupling extraction and bug detection.toidentifycouplings xeditorfirstminesddinopen source projects andextractsxmlentitypairsthat i frequentlycoexist in the same files and ii hold the same data at least once.
xeditor thenappliescustomizedassociationruleminingtotheextractedpairs.
for bug detection given a new xml file xeditor checks whetherthefileviolatesanycoupling ifso xeditorreportsthe violation s .
for evaluation we first created two data sets with the 248ddminedfrom1 137githubprojects.accordingtotheexperimentswiththesedata sets xeditorextractedcouplingswith highprecision itdetectedbugswith92 precision recall and accuracy.
additionally we applied xeditor to the version history of another github projects.
xeditor identified very suspiciousxmlupdates 15ofwhichwerelaterfixedbydevelopers.
keywords configuration coupling deployment descriptor rule mining permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
reference format chengyuan wen yaxuan zhang xiao he and na meng.
.
inferring and applying def use like configuration couplings in deployment descriptors.in 35thieee acminternationalconferenceonautomatedsoftware engineering ase september virtual event australia.
acm new york ny usa pages.
introduction when building enterprise applications on top of software frameworks e.g.
javaeeplatforms developersusuallycreatedeployment descriptors e.g.
web.xml a special kind of xml files to configuredeploymentoptions .erroneousddcantriggerabnormalruntimebehaviors orconfusingerrors .debugging suchxmlfilescanbechallengingandtime consumingforthree reasons.
first frameworks have domain specific rules to define orspecify deploymentoptionsasxmlentities i.e.
elements andattributes and developers have application specific ways to configureddfordistinctneeds.unfortunately thedomain specific rulesandapplication specificconfigurationsareusuallyvaguely documented .
second it is tedious and error prone for developerstomemorizealldd related rules.third existingcompilers andtoolsexaminesourcecodeinsteadofxmlfiles.eventhough xmlfilevalidatorscanbebuilttovalidatesyntaxbasedonxml schemas or dtds the validators do not examine dd semantics.
existing research provides quite limited support for checking or transforming xml files .
for instance xquery is a domain specific language for finding elements and attributes in xml documents .
to find particular xml errors developers havetolearnxquery andthenusexquerytomanuallydescribethepatternmatchingmechanism.thelearningcurveofxquerymaybelongtosomedevelopers whilethepatterndefinitionprocedurecan be also tedious and error prone.
we believe that with an automatic approachto inferrulesfromcorrectxmlconfigurationfilesand applythoserulesinordertolocateerroneousxmlfiles wecanprovidequalityassuranceforxmlfileswithoutrequiringmuchhumaneffort.
thispaperpresentsxeditor ournovelapproachtoinferand apply xml rules based on open source projects.
because different frameworksdefinediverseformatsofxmlfilesandtheddsemantics vary a lot it is almost infeasible to infer arbitrarily complex xmlrulesinadomain agnosticway.toensurethegeneralizability of our approach we designed xeditor to mainly focus on one type of rules that commonly exist in distinct frameworks def use 35th ieee acm international conference on automated software engineering ase beans xmlns xmlns xsi ... bean id outputhelper class com.mkyong.output.outputhelper property name outputgenerator ref local csvoutputgenerator property bean bean id csvoutputgenerator class com.mkyong.output.impl.csvoutputgenerator ... beans figure an exemplar deployment descriptor bean id validator class org.springframework...factorybean property name validationmessagesource ref messagesource bean !
bean id messagesource class ... ... bean figure2 theincorrectlymaintained dispatcher servlet.xml file in project addressbook sample jpa that violates ref id like couplings a b between xml entities .
here a b means ifentity areferstoanidentifierorastringliteral thenthere must be another entity bthat defines meaning for that identifier.
forinstance inspring abeanisanobjectthatisinstantiated assembled and managed by a spring container.
in dd a reference to a bean identifier is always coupled with the identifier definition oranybeanreferenceisvalidonlywhenthereisadefinitionforthe bean.
figure presents an example to demonstrate this constraint.
inthisfigure entity refisareferenceto csvoutputgenerator which is coupled with the bean iddeclaration of csvoutputgenerator i.e.
ref id.ourresearchintendstorevealddsemanticrulessimilar to such def use couplings.
notice that although ref idis easy to understand based on our experience many def use like rules are not so obvious see listing .
more importantly developerssometimes violated such rules when maintaining dd.
figure showsan incorrectlyupdated deploymentdescriptorin theopensourceproject address sample jpa wheredeveloperscommented the bean iddeclaration of messagesource but kept a refto that bean.
we believe that if two entities frequently coexist in the same file and often hold the same data they are correlated .
with this insight wedesignedxeditortohavetwophases asillustratedbyfigure3.
givenddoranxmlcorpusfromopen sourceprojects phaseiex tractscandidatepairsofxmlentitiesthat i frequentlyco occurin xmlfiles and ii holdthesamedataorstringliteralsatleastonce.
for each candidate pair xeditor identifies the longest common xmlpath csharedby bothentities onthexml parsingtree and thencontextualizes therepresentationof bothentitiesbased on c. for every candidate a b xeditor tentatively extracts couplings by applying our customized association rule mining technique.
in particular xeditor identifies all occurrences of each entity in the xml corpus together with thecorresponding stringliterals.
if theoccurrenceofoneentity e.g.
a isusuallycoupledwiththatof the other entity e.g.
b and both entities usually hold identical string literals then xeditor infers a rule e.g.
a b .
phase ii takes in an xml file fthat developers newly created or updated from an existing file xeditor tentatively matches f !
!
!
!
!
figure xeditor consists of two phases phase i extractsconfiguration couplings from open source projects andphase ii uses the couplings to check for bugs in dd against all extracted couplings.
if there is a coupling rule for which the file contains awithoutb xeditor recommends developers to insert bordelete aand ensurebothentitiesholdthesame string literal.
in the continuous integration ci practices we envision xeditor to be used for correctness checking before a submittedcommitisintegratedintothesoftwareproduct.inthis way xeditor helps developers correctly edit dd and complement existing code oriented program analysis techniques.
forevaluation wefirstappliedxeditortothe4 248ddfrom projects and manually inspected the extracted couplings.
withthedefaultparametersetting xeditoridentified30couplings among which couplings are true positives.
it means that our approach can extract rules with high precision .
furthermore based on our manual inspection results we built a ground truthdata set of coupling occurrences in the dd.
we randomly split the xml corpus into portions and conducted fold cross validation to evaluate xeditor s effectiveness of bug detection.
in each fold we used nine portions of data for coupling extraction weconstructedtestcasesbyremovingsomexmlentitiesfromthe remainingoneportionofdata andappliedxeditortothosetest cases.
our evaluation shows that on average xeditor detected bugs with precision recall and accuracy.
additionally we applied xeditor to the program commits in another open source projects.
xeditor revealed incorrectly updateddd 15ofwhichwerelaterfixedbydevelopers.thisimplies that xeditor can help developers avoid introducing bugs whenthey modify dd.
finally we compared xeditor with a baselineapproach that extracts couplings from co changed entities andapplies both approaches to the same data sets.
our comparison showsthatxeditordetectedmoreruleviolationsthanthebaseline xeditorobtainedlowerprecision vs. muchhigherrecall vs. and higher accuracy vs. .
in summary this paper makes the following contributions wedevelopedanovelapproach xeditor toautomatically extract configuration couplings in dd and detect relatedbugs.
different from most prior work xeditor does not needuserstomanuallyprescribeanyruleormatchinglogic.
we built xeditor to extract couplings from the coexistence ofxmlentities.comparedwithabaselinetechniquethatextracts couplings from co changed entities xeditor worked better by detecting rule violations with higher accuracy.
weconductedacomprehensiveevaluationonxeditor.our evaluation shows that xeditor could identify important couplingsbecausedevelopersdidmakemistakesbyignoring 673such delicate constraints and xeditor suggested useful corrective changes for buggy xml files.
at weopen sourced our program and data.
background this section first introduces dd section .
and xml syntax section2.
.itthenexplainswhyitischallengingtoconfiguredd appropriately section .
.
.
deployment descriptors dd adeploymentdescriptorisaconfigurationfilethatspecifieshow anartifactshouldbedeployed.forinstance inawebapplication appwritteninjava thedeploymentdescriptor e.g.
web.xml describes component classes resources and configurations of app italsospecifieshowaserverusesthesecomponentstoserveweb requests .
similarly in a java ee application the deployment descriptor e.g.
application.xml clarifiestheconfigurations container options andsecuritysettings .xmlisusedforthesyntaxof dd.
depending on the types of applications and modules dd may be located in various file folders and named differently.
listing a simplified version of a web.xmlfile ?xml version .
e ncoding utf ?
w e b app version .
xmlns xmlns xsi http org xmlschema instance xsi schemalocation http java.sun.com xml ns ... ... security constraint ... auth constraint role name comm role name auth constraint security constraint ... security role role name comm role name security role web app .
xml syntax xmlsyntaxdefineshowanxmlfilecanbewritten .accordingtothesyntaxrules eachxmlfileincludesoneormore xml elements whichareorganizedinatreestructure.namely thereis only one root element in any xml file and the root element has one or more child elements .
for the exemplar xml file shown in listing1 the web app elementisroot oneofitschildelementis security constraint .
generally speaking an xml document consists of markups anddata.markupsareprovidedintheformof tagsandattributes .
dataisthetextthatgoesinbetweentagsorisprovidedasvalues forattributes.xmlelementsarerepresentedbytags.anelement usually consists of an opening tag e.g.
role name a closing tag e.g.
role name and data between the tags e.g.
comm attributes can be added to xml elements they are represented asname value pairs e.g.
version .
.thispaperuses xml entitiesto refer to both xml elements and attributes.
.
problem statement in dd there are various rules that developers have to follow in order to realize their deployment requirements.
for instance as shown in listing a security constraint security constraint i su s e dt odefinetheaccessprivilegestoacollectionofresources anauthorization constraint auth constraint authorizes certain role s with the defined access privileges and has one or more role name elementstolisttheauthorizedroles .meanwhile asecurityrole security role defines an abstract name that can be assigned to usersandgroups .arelevantruleisthat eachrolenamelisted inauth constraint e.g.
comm must correspond to the role name definedinoneofthe security role elements e.g.
comm .
however inthebig andlengthyjavaeetutorial with980pages thereis only one small paragraph together with a single code example vaguely implying the above mentioned rule thefollowingsnippetofadeploymentdescriptordeclarestheroles that will be used in an application using the security role element and specifies which of these roles is authorized to access protected resources using the auth constraint element ... it is very tedious and error prone for developers to identify remember andfollowalldomain specificruleswhentheymaintain dd.
according to a recent study on stackoverflow many developers asked various questions on how to correctly configure ddandexpressedfrustrationswithxmldebugging.unfortunately there is limited tool support for bug detection or fix in dd.
two reasons may explain such technique insufficiency domain specific rules are usually vaguely described or even poorly documented so it can be time consuming for toolbuilders to extract rules from software library framework documentation and then code those rules into their tools.
differentsoftwaredefinesdivergentddrules soitcanbe challengingfortoolbuilderstofrequentlyintegratetherules related to newly released software into their tools.
tobuildatoolthatcanhelpdevelopersdebugdd weneedtosolve the two technical challenges mentioned above.
approach inthissection weexplainourautomaticapproach xeditor that detectsbugsinxmlfilesandprovidescorrectivesuggestions.to overcome the two technical challenges mentioned in section .
we designed xeditor to infer def use like configuration couplings from open source dd and to adopt the inferred couplings for bug detection.
as shown in figure xeditor has two phases.
this sectionfirstsummarizesthestepsineachphaseandthendescribes each step in detail section .
section .
.
phase i rule inference givenasetofopen sourceprojects xeditorlocatesasetof dd f f1 f2 ... fm from which files xeditor extracts candidatexmlentitypairs c c1 c2 ... cn whereci ei1 ei2 withei1andei2being coexisting entities.
for each candidate ci xeditor searches among all files fto findtheoccurrenceofeitherentity i.e.
ei1andei2 itfurther applies our customized association rule mining to infer any def uselikecouplingsbetweenentities.eachminedrulehas the format a b and is saved into a database d. phase ii rule application givenanewxmlfile f foreachrule r d xeditorchecks whetheraandbcoexistinthefile.xeditorreportsabugif aexistsbut bdoesnot or areferstoastringliteral which is not held by any b.
674byinferringdef uselikerulesfromopen sourceddinadomainagnostic way we avoid the manual effort of extracting such rules from software documentation and hardcoding the rules in xeditor.byimplementingthefirstphasetostorerulesto dand thesecondphasetoloadrulesfrom d weensurethatxeditorcan beeasilyextendedtocovernewrulesintroducedbynewlyreleased software frameworks or libraries.
.
candidate identification given a set of open source projects we need to first locate dd.
although the dd of different java projects are all xml files not all xmlfilesaredd.toefficientlylocateddamongtheavailablexml files we adopted a heuristic to focus on files whose paths have any of the following keywords web inf spring security and web .wedefinedthisheuristicbecausebasedonourexperience dd usually exist in specific folders or have specialized names.
foreachlocatedxmlfile weappliedantlr togeneratea parsingtree wherenodesrepresentxmlentitiesordataandedges represent the parent child containment relationship.
to identify candidate pairs in the tree representation a na ve approach can identify all xml entities e e1 e2 ... en and create a pair for any two coexisting entities i.e.
ei ej wherei j andi nequalj .
however sincemanyirrelevantentitiesmaycoexistinthesame file for distinct requirements their coexistence is meaningless.
therefore manyofthecandidatepairsconstructedbytheabovementioned na ve approach are actually useless for rule inference.
to overcome the challenge of noisy entity pairs and to identify promising candidates we used a heuristic that if two xmlentities hold the same string value at least once they are likely tobe correlated .
as shown in listing the role name element under security constraint holds the data comm line while the role name elementunder security role containsthesamestring literal line14 .therefore xeditorgeneratesacandidatepairbased on the two elements.
before generalizing rules from the concrete candidate pairs we needtosolveanotherchallenge howcanwerepresentcandidates inanunambiguousway?
inlisting1 thetwoelementsreferring to comm have the same tag role name .
if we simply use these tags todefineacandidatepair role name role name thesemantics isveryconfusingandwecannottelltheelementsapart.tosolve this problem we decided to include the context i.e.
the parent and even ancestors of both entities into our representation fordisambiguation.supposethatanentity ahasitsparententityas p whilepis contained by the root element r. then our contextawarerepresentation for ais r p a which corresponds to the xml path from root to a. for the candidate pair mentioned above our context aware representation is web app security constraint auth constraint role name web app security role role name .
when a rule to infer rhas multiple occurrences it can correspond to multiple candidates with distinct xml paths such as cp beans bean id beans bean property ref andcq beans beans bean id beans beans bean property ref shown in figure .
if we do not appropriatelyprocessthepathdivergencesbetweencandidates we may fail to infer true rules or always infer duplicated rules.
essentially we need an abstractcontext awarerepresentation of figure xml trees to visualize the spatial relationship be tween entities in c pandcq candidatesthatis sensitivetothepathdivergencesbetweenenti tiesinsideeachcandidate but insensitivetothepathdivergences among candidates showing the same rule.
to create the abstract representation for each candidate ci ei1 ei2 xeditor identifies the lowest common xml ancestor and converts the paths of both entities based on that ancestor.
for instance the entities in cpof figure have the lowest common ancestor as beans so the abstract representation is beans bean id beans bean property ref .
here wildcard represents the common xml path prefix of beansshared by both entities.
similarly cq is converted to beans bean id beans bean property ref .
therefore the above mentioned candidate pair from listing can be abstracted as web app security security constraint auth constraint role name web app security security role role name .
byrepresentingcandidatepairsinanabstractandcontext aware way we can differentiate between same tag entities cluster candidates showing the same rule and simplify rule extraction and application section .
section .
.
.
rule extraction afterextractingasetofcandidatepairs i.e.
c c1 c2 ... cm fromcorpus f xeditorinfersruleswithourcustomizedassociation rule mining technique.
this technique first adopts traditional association rule mining to infer the occurrence coupling betweenxmlentities itthenappliestwofilterstoremovecooccurring entity pairs that are less likely to have def use relations.
associationrulemining arm isaclassicalwaytofind patterns in data and detect couplings between data entities.
an assocationrule betweentwoentities e1ande2canhavetheformat e1 e2 o r e2 e1 .
in the notation e1 e2 e1is called the antecedent and e2iscalledthe consequent.thenotationmeansthat the occurrence of e1implies that of e2.
with such rules we can predicttheoccurrenceof e2whene1occurs.armminesassociation rules in a probabilistic way.
intuitively arm infers the rule e1 e2 if the two entities cooccur for a sufficient number of times and whenever e1occurs e2usuallyoccurs.formally supposethatthe numbers of occurrences of e1ande2are separately freq e1 and freq e2 .
we represent the number of cooccurrences between the entities as freq e1 e2 .
the rule e1 e2 is derived if freq e1 e2 supp wheresuppis the threshold for the number of cooccurrences and pr e2 e1 freq e1 e2 freq e1 conf whereconfisthethreshold for the probability.
in our research for each candidate ci ei1 ei2 xeditor identifies the occurrences of ei1andei2in all files it then computes 675freq ei1 ei2 pr ei2 ei1 andpr ei1 ei2 accordingly to reveal existence couplings between entities.
two filters.
in certain projects some irrelevant entities accidentally coexist a lot.
to avoid inferring noisy def use like rules from such accidental coexistence we decided to build two filters that refine the above mentioned existence couplings.
f1 pfreq e1 e2 pth wherepthis the minimum number of projects that support the cooccurrences between e1ande2.
we designedthis filter because certainaccidental coexistence was introduced by the coding habitsof some programmers.
however it isveryunlikelythatsuchaccidentalcoexistencepopularlyexistsin many projects.
this filter removes any rule that is only supported by a small number of projects.
f2 pr same strin freq strin ei1 strin ei2 freq ei1 ei2 vth wherevthistheminimumrateofsame stringcooccurrences.
we designed this filter because in some dd developers unnecessarily set irrelevant xml entities to hold identical values such that theydonothavetocarefullyexaminethecorrespondencebetweenentities.however moredevelopersstillusedistinctandmeaningful stringvaluestotellapartirrelevantentities.therefore thisfilter removesanyrulewherethetwoentitiesdonotfrequentlyholdthe same string literal.
by default xeditor extracts a def use like rule ei1 ei2 i f supp conf .
vth .
andpth .
we used these thresholdvaluesbecauseourevaluationshowsthatxeditorworks most effectively with this setting section .
.
at the end of this step xeditor obtains a set of def use configuration couplings and saves them into its database d. for the exampleshowninlisting1 fromthisexemplarfiletogetherwith several other files containing relevant entity pairs xeditor can infer the following rule web app security constraint auth constraint role name web app security role role name .
rule .
rule based checking given a new xml file f xeditor enumerates the inferred rules to detect bugs in the file and suggests changes when possible.
specifically xeditor adopts antlr to create a parsing tree for fand extracts all entities from the tree.
for each rule r a bin the database xeditor searches entity matches for aandbseparately.forsimplicity werepresentthetwosetsoffoundmatches withea ea1 ea2 ... eah andeb eb1 eb2 ... ebl .
next xeditorpairsup entitiesbetween eaandebbased on abstract context awarerepresentationsofentitiesand thecommonstring literalstheyshare.if eai i cannotbepairedupwithany entity ineb xeditor reports a bug and suggests possible fixes.
for instance by applying the above mentioned inferred rule rule1 tothexmlfileinlisting2 xeditorcanfindtwomatches fortheantecedent role name elementunder security constraint but find no match for the consequent role name element.
in this scenario xeditorreportstwobugsandsuggeststhecorresponding fixes as below insert a role name entity with value prof under web app security role or delete the role name entity with value prof under security constraint auth constraint .
insert a role name entity with value stu under web app security role ordeletethe role name entitywithvalue stu under security constraint auth constraint .
listing a simplified version of another web.xmlfile ?xml version .
e ncoding utf ?
w e b app version .
xmlns xmlns xsi http org xmlschema instance xsi schemalocation http java.sun.com xml ns ... ... security constraint ... auth constraint role name prof role name auth constraint security constraint ... security constraint ... auth constraint role name stu role name auth constraint security constraint web app evaluation this section first introduces our data sets section .
and evaluation metrics section .
.
next it presents our evaluation on xeditor s effectiveness of rule inference section .
and rule application section .
.
finally it expounds on the comparison between xeditor and a baseline technique section .
.
.
data sets we constructed two major data sets for evaluation.
specifically we minedjavaopen sourceprojectsongithub usingtheheuristics describedinsection3.
.wecrawledthewebsiteforanyprojectthat containsatleastonexmlfile whosefilepathhasanyofthefollowingkeywords web inf spring security and web .afterremovingredundantprojects werandomlyputthecrawledprojects intotwodatasets.thefirstset d1 contains70 ofprojects i.e.
while the second set d2 contains of projects i.e.
.
ford1 xeditoridentified4 248ddinthelatestversionof1 projects.
we used these dd to explore three research questions rq1 how effectively does xeditor infer rules?
rq2 how effectively does xeditor apply rules to locate bugs?
rq3 how well does xeditor compare with a baseline approach which detects xml bugs based on co changed instead of coexisting entities?
afterinferringrulesfromd1 weusedxeditortoapplyrulesto individual program versions in d2.
we investigated two questions rq4 diddevelopersintroduceanyofthexmlbugsthatxeditor can detect during xml file maintenance?
rq5 how well do xeditor s change suggestions match developers actual fixes for those detected xml bugs?
ourexperimentswithd1intendtoassesstheusabilityof xeditor whileourexperimentswithd2intendtomimictherealapplication scenariosof xeditorandassessthetool susefulnesstodevelopers.noticethatxeditorisactuallyapplicabletoarbitraryddto examine for any rule violation no matter whether the files have beennewlycreated recentlyupdated orunchangedforalongtime.
676inourexperimentswithd2 weintentionallyappliedxeditorto revisions of programs to demonstrate one typical usage of the tool.
.
metrics weusedthefollowingmetricstoevaluatetheeffectivenessof xeditor and the baseline technique.
precision p measuresamongallreportsgeneratedbyatechnique how many of them are true positives p of correct reports total of generated reports .
precisioncanbeusedtoevaluatetheeffectivenessofruleinference and rule application.
for rule inference pmeasures how many reported rules are correct rules.
for rule application pmeasures among all reported xml bugs how many of them are real bugs.
recall r measuresamongallknowntruepositives howmany of them are reported by a technique r of correct reports total of true positives .
sincewe donothaveany priorknowledgeonthe truerulesexisting in xml files we did not evaluate the recall of rule inference.
however basedontheinferredrulesandourmanualinspection wemanagedto constructa ground truthdata setand evaluated the recall of rule application.
f score f combines pandrto measure the accuracy f p r p r .
the f score measures the trade off between precision and recall thus we leveraged it to measure the accuracy of rule application.
.
effectiveness of rule inference there are four parameters in xeditor that can influence its capability of rule inference supp conf vthandpth.
to investigate howsensitivexeditoristotheseparameters weappliedxeditor tothefirstdatasetd1withdistinctparametersettings andthen manually inspected the inferred rules to calculate precision.
before our manual inspection we did not have any prior knowledge of the correct rules.
therefore it is infeasible for us to evaluate the recall of xeditor s rule inference.
to evaluate the precision given a rule reported by xeditor our manual inspection involves onlinesearchfor therelatedlibraryspecificationsorframework tutorials and or relevantdiscussionsontechnicalforums e.g.
stackoverflow .weconsideraninferredruletobetrueifonline documentation or discussion recommends it or no online xml example violates the rule.
.
.
sensitivity to supp.we increased suppfrom to and explored settings for the parameter.
due to the space limit in table we present the results for only five settings.
intuitively suppcounts the number of supporting instances for any candidate rule.
the more supporting instances there are the more likely that a candidate rule is a real one.
as shown in the table when supp increases from to the number of inferred rules by xeditordecreases from to while the number of correctly inferred rules decreases from to .
the observations are understandablebecausewiththeotherparametersunchanged themoresupportingtable rule inference with different settings of supp supp conf vth pth of inferred rules of correct rulesprecision .
.
.
.
.
.
.
.
.
.
table rule inference with different settings of conf supp conf vth pth of inferred rules of correct rulesprecision .
.
.
.
.
.
.
.
.
.
table rule inference with different settings of vth supp conf vth pth of inferred rules of correct rulesprecision .
.
.
.
.
.
.
.
.
.
table rule inference with different settings of pth supp conf vth pth of inferred rules of correct rulesprecision .
.
.
.
.
.
.
.
.
.
instancesarerequired thefewerruleshavesufficientoccurrence rates to meet the criterion.
among all investigated settings weidentifiedaprecisionpeakat supp whichis64 .therefore we setsupp by default.
.
.
sensitivityto conf.weincreased conffrom0.00to0.95with .
increment and explored settings for the parameter.
due to the space limit table only presents our results for five parametersettings.theoretically foreachcandidaterule a b confreflects the likelihood of b s occurrence given a s occurrence.
thus the higherconfis themorelikelythatacandidateruleisatruepositive.
according to the table as confincreases from .
to .
the number of inferred rules decreases from to while thenumber of correctly inferred rules remains to be initially and thendecreases to25.
themajor reasonforthese observed trends is that as the threshold increases there are fewer rules satisfying the filteringcondition.becausetheprecisionof xeditor sinference increases first and then decreases we set conf .
by default.
.
.
sensitivityto vth.weincreased vthfrom0.00to0.95with .
increment and explored settings for the parameter.
table showsourresultsforfiveofthoseinvestigatedsettings.basically givenacandidaterule a b vthreflectstheratioofsame value cooccurrencesbetween aandbamongallof theircooccurrences.
therefore the higher vthis the more convincing a candidate rule is.
in table as vthincreases xeditor inferred fewer rules and 677table the fold cross validation for xeditor s effectiveness of bug detection idrule inference rule application of rules inferred of correctly inferred rules of bugs reported of known bugs of correctly reported bugsprecision recall accuracy acquired fewer correct rules the inference precision goes up from to .
thus by default we set vth .
.
.
.
sensitivity to pth.we increased pthfrom to and explored20 settingsfor theparameter.
table4 showsour resultsfor five of the explored settings.
essentially pthcounts the number of projects holding at least one supporting instance for any candidate rule.themoreprojectstherearetosupportacandidaterule the more possible that the rule is true.
in table as pthincreases the numberofrulesinferredbyxeditordecreasesfrom32to15and the number of correct rules decreases from to .
the precision rate first increases then decreases and next increases again.
to achieve a good trade off between the number of correctly inferred rules and inference precision we set pth by default.
finding forruleinference xeditor seffectivenessisconsiderablyinfluencedbythesettingsofallfourparameters.aseach parameterhasitsvalueincreased xeditorusuallyinfersfewer rulesandobtainsfewercorrectrules whiletheprecisionratemay increase decrease or remain the same.
.
.
xeditor precision for rule inference.
after manually checking all inferred rules by xeditor with different parameter settings we confirmed correctly inferred rules.
among these rules rules can be retrieved by xeditor with its default configuration supp conf .
vth .
andpth .essentially different parameter settings indicate different trade offs between two factors thenumberofinferredrulesand theprecisionrate.
whenwedecideduponthedefaultsetting wecaredmoreabout precisionthantheotherfactor.thisisbecausetomakexeditor usableto people wewanttoensure thatmostofthe rulesreported by xeditor are correct and valuable.
our experiment implies significant space for future improvement in rule inference from dd.
specifically with our carefully chosen parameter configuration xeditor inferred rules with precision novel approaches are still needed to considerably boost theprecisionrate.additionally amongthe57validatedrulessofar atmost38rulescanberetrievedwithoneoftheexploredparametercombinations.moreadvancedtechniquesarestillinneedto identify more true rules with reasonably good precision rates.
finding2 responsetorq1 withthedefaultsetting supp conf .
vth .
andpth xeditor effectively inferred rules with high precision .
.
effectiveness of bug detection and fix to evaluate xeditor s effectiveness of rule application we conducted two experiments.
the first experiment splits d1 into portionsevenly andconducts10 foldcrossvalidationtoevaluate how bugs detected by xeditor match the known bugs in our data sets.inthesecondexperiment with57rulesextractedfromd1 we applied xeditor to different versions of deployment descriptors in d2 and validated the reported bugs and fixes based on later versions in software history or developers feedback.
.
.
experiment based on d1.
we splitthe dd into portionsp p1 p2 ... p10 andconducted10 foldcrossvalidation toevaluatexeditor seffectivenessofbugdetectionandfix.ineach fold we fed xeditor with nine portions of data for rule inference e.g.
including p1 p2 ... p9 weusedtheremainingoneportion ofdata e.g.
p10 tocreateatestset andthenreliedonthetestdata toassessxeditor seffectivenessofruleapplication.amongthe10 foldsofvalidation werotateddataandensuredthateachportion was used exactly once for test data creation.
specifically to build a test set with a data portion pi i wefirstappliedantlrtoconverteachdeploymentdescriptor f pi to a parsing tree t and then extracted entities from t. if there is any entity pair c e1 e2 demonstrating a rule r a bwhich belongs to the confirmed rules in section .
we removed b s match e.g.
e2 fromthetreetogetadifferenttree t prime.inthisway if xeditorworkssuccessfully itshouldbeableto inferrule r fromtheothernineportionsofdata and usethatruletoreportabug e.g.
missingb smatch e2 whenscanning t prime.withthecreated test sets we compared all bugs reported by xeditor against the known bugs in modified parsing trees and evaluated the precision recall and accuracy accordingly.
table presents our experiment results for the fold cross validation.inthetable ofrulesinferred showshowmanyrules xeditor inferred from the nine data portions for each round.
of correctlyinferredrules reportshowmanyoftheinferredrules are actually correct according to our manual analysis.
of bugs reported presentsthenumberofbugsxeditordetectedinthetest set.
of known bugs showsthenumberofbugsweintroduced by modifying parsing trees and removing certain entities.
o f correctly reported bugs counts the reported bugs that match our ground truth.
precision recall andaccuracy reflect the effectivenessof xeditor sbugdetectioncapability.forinstance in round xeditor inferred rules from the given data portions while20oftheserulesaretruepositives.basedonallinferred25 678table the real xml bugs fixed by developers bug indexviolated rule a b root cause category fixing strategy vdiff fix bug beans bean property ref beans bean id delete b only import an xml file web app security constraint auth constraint role name web app security role role nameupdate the data of a while b s data is unchangedupdate the data of b web app security constraint auth constraint role name web app security role role nameupdate the data of a while b s data is unchangedupdate the data of b web app security constraint auth constraint role name web app security role role nameinsert a only insert b web app security constraint auth constraint role name web app security role role nameinsert a only insert b beans bean property ref beans bean id insert a only delete a beans beans beans bean beans property ref beans beans beans bean idinsert a only delete a beans beans beans bean beans property ref beans beans beans bean iddelete b only delete a web app servlet mapping servlet name web app servlet servlet nameinsert a and b with different string literals usedupdate the data of a web app servlet mapping servlet name web app servlet servlet namedelete b only insert b web app servlet mapping servlet name web app servlet servlet nameinsert a only insert b web app servlet servlet name web app servlet mapping servlet nameinsert a only delete a web app servlet mapping servlet name web app servlet servlet nameinsert a only delete a web app servlet mapping servlet name web app servlet servlet nameinsert a only delete a web app servlet servlet name web app servlet mapping servlet nameinsert a and b with different string literalsupdate the data of b rules xeditor detected bugs in the test set although there are 283knownbugsintheset.theintersectionbetweenbugreports and our ground truth is bugs.
thus xeditor achieved precision recall and accuracy for round .
in each round given portions of data xeditor inferred def uselikerules and17 21oftheserulesaretruerules.basedonall inferredrules xeditorreported258 322bugs and240 292ofthemaretruebugs.amongthe10rounds onaverage xeditorachieved precision recall and accuracy for bug detection.
two reasonscanexplainwhyxeditorcouldnotachieve100 accuracy.first when xeditor obtained false positives for rule inference theincorrectlyinferredrulesmisledxeditortoproducefalsepositives forruleapplicationandthusreportfalsebugs.second sometrue ruleshaveinsufficientsupportinginstancesintheselectedninedataportions.
consequently these rules cannot be inferred by xeditor neithercanxeditordetecttheknownbugsinthetestsetforthese rules.
in other words the false negatives in rule inference cause false negatives in rule application.
finding response to rq2 xeditor detected bugs in xml files with precision recall and accuracy.
.
.
experiment based on d2.
with the true rules revealed in section .
we applied xeditor to the second data set d2 to evaluatewhetherxeditorcan detectanyrealbuginupdatedxml files and suggest fixes that correspond to developers actualfixes in reality.
specifically for each project if a commit cin the versionhistorymodifiesadeploymentdescriptor f xeditorscans the after changeversion of f. if there is any bugdetected we manually examine versions after cin the repository to decide whetherthereportedbugwasultimatelyfixedbydevelopers.ifso thereportedbugisarealbug andwecanfurthercomparexeditor sfix suggestion against the actual fix applied by developers.
by manually checking the bug reports generated by xeditor we identified really problematic xml updates.
interestingly of these bugs were later fixed by developers according to the version history.
this observation means that developers did introducethe xmlbugsthat xeditorcandetect andxeditoris capable of revealing developers mistakes when they edited dd.
finding4 responsetorq4 xeditorrevealed15xmlbugs inopen sourcesoftwarerepositories.ourobservationindicatestheimportanceofxeditor becausedevelopersdidintroducethexml bugs that xeditor could detect during xml file maintenance.
table presents the bugs that developers later fixed.
specifically column bugindex showstheindexweassignedtoeachbug.
violated rule shows the rule xeditor used to identify the bug.
root cause category explains how developers introduced the bug.fixingstrategy describeshowdevelopersresolvedthebugin a later version.
vdiff fix bug describes the version difference between the bug fixing commit and bug introducing one.
let us take thefirstbugasanexample.theviolatedruleis beans bean property ref beans bean id .
in one commit ci developers deleted the consequententity b whilekeepingtheantecedent a .inalater commitci developers fixed the bug by importing an xml file wherebdefinestheliteralusedbya.therefore vdiff fix bug i i .
679table the fold cross validation for baseline s effectiveness of bug detection idrule inference rule application of rules inferred of correctly inferred rules of bugs reported of known bugs of correctly reported bugsprecision recall accuracy according to table four bugs i.e.
4th 5th 0th and 11th werefixedviatheinsertionofb.developersfixedanothersixbugs i.e.
6th 7th 8th 2th 3th and 14th by deleting a. four bugs i.e.
2nd 3rd 9th and 15th were fixed via data updates to a or b. one bug i.e.
1st was fixed when developers imported another xmlfileforthedatavalueusedbya.amongalltheseappliedfixes fixes are covered by the strategies suggested by xeditor insert bordeletea .itmeansthatxeditorusuallysuggestshelpfulfixes.
additionally for6outofthe15bugs developersappliedfixes in the immediate next commit they fixed the remaining bugs afteratleasttwocommits.mostinterestingly developersfixedone bug i.e.
11th after commits.
these observations imply that if developers had used xeditor to examine their updated xml files before committing program changes they should have avoided checkingintheerroneousprogramchanges orevenhavefixedthe introduced bugs earlier.
finding response torq5 xeditor s change suggestions matchdevelopers actualfixesfor10ofthe15detectedxmlbugs.
.
comparison with baseline prior change suggestion tools mine software version history for co change patterns and use those patterns to identify any missing change .
for instance rose leverages associationrulemining arm toidentifytheco change rulesbetween program entities e.g.
if method ais changed method b shouldalsobechanged suchthatwheneveranentity e.g.
a is changed and its related entity e.g.
b is not rose suggests the missing change .
these tools are similar to xeditor due to theiradoptionofarm butdifferentbyrelyingonthe co changes instead of coexistence of program entities.
we were curious how xeditorcompareswithpriorwork butnopriorworkextractsany project agnostic co change rules for deployment descriptors.
the baseline approach baseline .
to facilitate the comparison between two methodologies i.e.
coexistence based vs. cochange based we built a rose like baseline approach named baseline for short .
baseline mines frequently co changed xml entities in software version history and uses our customized as sociation rule mining to infer rules of the format chan e a chan e b .
baseline then exploits these rules to check individual program commits i.e.
the program changes for any erroneous xml update.
similar to xeditor baseline extracts two entities as a candidate pair if i they are frequently co changed within the same files and ii they usually refer to the same string literal.experimentsetting.
aswithxeditor baselinealsohasfour parameters supp conf vth andpth.forfaircomparison wetuned parameters in the manner described in section .
and found areasonably good default setting for baseline supp conf .
vth .
andpth .
afterwards we evaluated baseline using fold cross validation based on the data set d1.
results.
table presents baseline s effectiveness of bug detection in the fold cross validation experiment.
according to thetable ineachround baselineinfers17 23rules while12 oftheseinferredrulesarecorrect.whendetectingbugsbasedon all inferred rules baseline obtained precision recall and accuracy.
on average baseline detected bugs with98 precision recall and87 accuracy.comparedwith xeditor s effectiveness shown in table on average baseline achieved higher precision vs. lower recall vs. and lower accuracy vs. .
these results indicate that xeditor and baseline achieved different trade offs betweenprecision and recall.
when software practitioners choose an approach to use for xml debugging they can either choose baseline for higher precisionandlowerfalsepositiverates orselectxeditorforhigher recall and lower false negative rates.
tworeasonscanexplaintheabove mentionedcomparisonresults.
first baseline analyzes the evolution history of dd whilexeditorexaminesonlyoneversionofthesefiles.actually the frequent co changes indicate stronger relevance between entities than recurring coexistence.
namely if two entities are often changed together in the same file they definitely coexist neverthe less iftwoentitiesoftencoexistinthesamefile theydonothaveto be changed or get frequently changed together.
consequently the rules inferred from co changed entities are generally more precise.
second when two closely related entities are barely changed in version history baseline cannot infer any correlation between them neither can it predict any co changes for those entities.
consequently baseline obtained lower recalls.
finding6 responsetorq3 comparedwithbaseline xeditor detected bugs with lower precision vs. higher recall vs. andhigheraccuracy vs. .thesetwo approaches made distinct trade offs between precision and recall.
threats to validity threats to external validity.
all inferred rules and detected bugs mentionedinthispaperarelimitedtoourexperimentdatasets.theobservationsmaynotgeneralizewelltoclose sourceprojects.inthe 680future we would like to include more projects into our evaluation orevenincludeclose sourceprojectsifpossible sothatourfindings are more representative.
threatstoconstructvalidity.
inour10 foldcrossvalidationfor xeditor s effectiveness of bug detection and suggestion for each fold we automatically generated bugs by removing some xml entitiesfromdd.thesebugsmaynotrepresenttherealbugsintroducedbydevelopersduringsoftwaremaintenance soourempirical measurementscanbebiased.inthe future wewillconstructdata setswithrealbugsinddtobetterevaluatexeditor scapability of bug detection and suggestion.
threatstointernalvalidity.
ourmanualanalysisfortheoutput by xeditor is subject to human bias and limited to our domain knowledge.
to mitigate the problem we had two authors to examine the rules reported by xeditor for agreement.
the two authors agreed with each other in most scenarios.
when they disagreed uponcertainrulesmainlybecauseoftheirlimiteddomainknowledge theysharedrelevantdocumentationorexampleswitheach other for discussionuntil coming to an agreement.
among the really buggy xml updates detected by xeditor there are bugs not fixed by developers.
we sent emails to the owner developers to check whether any of these bugs is true.
so far we have only received one response email which pointed out that the violation showninlisting3isafalsepositive.aswegathermorecomments from developers we will further improve the quality of inferred rules and change suggestions.
lessons learned weconductedcustomizedassociationruleminingtoextractdef use likexmlrulesinadomain agnosticway.ourapproachisbasedontheinsightthat iftwoentitiesfrequentlycoexistinthesamefileandoftenholdthesamedata theyarecorrelated .ourevaluationshows that xeditor reveals some interesting rules that can effectively capture the xml bugs caused by human errors.
more importantly by manually analyzing the false positives produced by xeditor we also learnt four research challenges in this area.
first relatedentitiesdonotalwayscoexistinthesamedeployment descriptor.
we observed that some correlated entities are defined in two separate xml files their relationship is established when onexmlfileimportstheotherfileor ajavaannotationin source code specifies both files.
for instance for the rule beans bean property ref beans bean id wefound1 196occurrencesof refind2 and49ofthemcorrespond totheiddefinedinanotherxmlfile.toresolvesuchissues wewill conductcross fileassociationruleminingbytreatingmultiplexml files and java files as a whole and analyzing them simultaneously.
listing3 afilethatviolatesoneofourinferredrulesbutis considered to be valid by its owner developer ... beans xmlns http mongo db factory dbname mongo.
database.name mongo ref mongo bean id mon gotemplate class ... constructor arg name mongodbfactory r e f mongodbfactory bean beans second some related entities may never refer to the same value.
listing presents a file that violates an inferred rule but is considered to be correct by the owner developer.
based on the rule beans bean constructor arg ref beans bean id listing has a rule violation and should include another beandefined with the id mongodbfactory .
however from our email conversation with the developer and relevant documentation we learnt that by default the db factory element enables spring to createaninstanceof mongodbfactory andtoregistertheinstanceas a bean named mongodbfactory .
in other words with theexistence of mongo db factory weshouldnotdefineabeanwiththeid mongodbfactory .
suchdelicateconstraintsarecurrentlynotinferablebyxeditor becausethespecificationdoesnotalignwellwithourinsight.toex tractsuchconstraints moreheuristicsanddomain specificinsights are needed for better approach design.
third some related entities may not cooccur frequently enough.
currently xeditor adopts multiple parameters i.e.
suppandpth to refine inferred rules based on the cooccurrence frequency be tween entities.
according to our experience there are def use rules that xeditor could not identify simply because the cooccurrence rates are low.
this limitation is commonly shared among all probability basedruleinferenceapproaches.morenoveltechniques are still needed to reveal rules based on rare entity occurrences.
fourth the fixing strategies for rule violations can vary a lot.
currently whenarule a bisviolated xeditorsuggestsdevelopers to either remove aor insertb.
however in reality developers fixingstrategiescanbemorediverse suchasmodifyinganexisting entity to satisfy the constraint or importing an xml file with b defined.researchesmayneedbettertechniquestoproposemore fixing strategies automatically and to fully automate xml repair.
related work the related work of this research includes metadata validation program change prediction traceability management and configuration debugging.
.
validation of metadata several approaches were proposed to help check and or fix the usageofmetadata i.e.
xmlandannotations .forinstance xqueryisawidelyusedqueryandfunctional programminglanguage thatqueriesand transformscollectionsof structured or unstructured data in xml documents .
similarly cduce andxduce areindependently developeddomainspecific languages dsls for xml processing.
to validate and transform xmlfiles usershave tolearn one ofthese dslsand use the dsl to prescribe matching logic and change operations which procedure can be tedious and error prone.
to validate java annotation usage eichberg et al.
provided a dsl for users to define constraints .
to check user specified constraints the researchers automatically converted java bytecode to xml documents and converted constraints to xquery path expressions.similarly darwin andnogueraetal.
separately defined dsls for users to specify and then validate the constraints onannotationusage.however generaldev elopersmaynothave sufficient domain knowledge to properly utilize these languages.
681songandtilevichbuiltanapproachto automaticallyinferand check invariants between metadata and program constructs without requiring users to manually prescribe anything .
however this approach focuses on the relations between metadata and code it does not handle any editing constraint within xml files.
.
program change prediction researchers built tools to mine version histories for co change patterns andusedthosepatternstopredictanymissingchange .specifically galletal.minedreleasedatafortheco change relationshipbetweensubsystems andclasses .zimmerman etal.andyingetal.furtherextractedtheco changerelationship between finer grained program entities e.g.
classes methods and fields .however theseapproachespredictchanges purely based on entities co change frequencies without considering any syntacticorsemanticrelationshipbetweenentities.whenlotsof irrelevant entities are accidentally co changed multiple times such tools may incorrectly infer rules and produce incorrect predictions.
somehybridapproachescombinehistory basedassociationrule mining with information retrieval ir .
given a software entity e these approaches leverage ir based techniques to extract terms from eand any other entity and rank those entities based on their term overlapping with e. meanwhile these approachesalsominehistoryforco changesandrankentitiesaccordingly.
given a new commit these approaches combine the two ranked lists in distinct ways to reveal any missing change.
however theeffectivenessoftheseapproachesarealsolimitedbythe frequency of co changed entities.
severalresearchersusedthesyntacticrelationshipbetweenentitiesorfilestopredictchanges .forinstance shirabadet al.
trained a machine learning model to characterize any commonalitybetweenco changedfiles suchasnumbersofcommonlyused types functions variables .
given a changed file the model predicts what other files to change together.
wang et al.
characterized the common field accesses and or common method invocations betweenco changedmethods .basedonthecharacterization wangetal.builtcmsuggester atooltopredictmethodsforchange given an added field or method and one or more changed methods .
however these approaches only analyze source code they are not applicable to non code artifacts like xml files.
.
traceability management softwareartifacttraceabilitymeans theabilitytofollowthelifeofarequirementinaforwardandbackwarddirection .maintaining traceabilityacrosssoftwareartifactshelpsensurethecoevolution of artifacts .
for instance when a high level requirement document is changed traceability helps locate the pieces of design or codewhichshouldalsobechanged.variousinformationretrieval approaches were proposed to reveal traceability links mainly betweenrequirementdocumentationandothertypesofartifacts e.g.
designdocumentsandsourcecode .additionally kagdiand maleticbuiltatooltoanalyzecommitsinasoftwareversionhistoriesandtomineforhighlyfrequentlyco occurringchangesto different artifacts .
lozano et al.
built matraca a tool that supports users to specify traceability links across domains via logicpredicates.
with users specifications matraca checks the linksbetween entity definitions in one domain e.g.
java and entityusageinanother e.g.
xml .however noneofthesetools examine the coevolution patterns within the same xml file.
.
configuration debugging severaltoolswerebuilttodiagnoseorfixsoftwareconfiguration errors .
these approaches execute buggy software gather execution profiles compare the profiles and conduct dynamic analysis to locate errors.
for instance confdiagnoserrecords program predicates that may be affected by each configurationoption andcollectstheexecutionprofilesofaprogram s correctandundesiredruns .bycomparingthebehavioraldifferencesbetweentwotypesofrunsintermsofrecordedpredicates confdiagnoseridentifiesthecandidateoptionswithmisconfigured values.weissetal.builtanapproachtogeneralizesystemconfigurationrepairsforcertaintypesofmachinesfromtheshellcommands developers entered to update one machine .
the configuration files examined by these approaches are irrelevanttoxmldocuments.noneofthesetoolscheckforanycoupling between configuration options.
conclusion deploymentdescriptorsarehardtocreateandmaintain because there are domain specific constraints on the xml formats defined by different software libraries.
in this paper we built xeditor anapproachtoautomaticallyinferthedef uselikeconfiguration couplingsindd.byapplyingtheinferredrulestoagivenxmlfile xeditor can identify any rule violation to report bugs and provide suggestions.similarto priorruleminingapproaches xeditor also leverages association rule mining to infer rules based on statistics.
however different from prior work xeditor infers rules from dd instead of source code relies on the common data sharedbetween xml entities to locate candidate pairs mines rulesbased on the coexistence instead of co changes between entities and adopts more filters to refine the mined rules.
ourevaluationrevealsinterestingphenomena.first theeffectiveness of xeditor is sensitive to its parameter settings.
withappropriate configuration xeditor was able to infer rules withhigh precision .
second xeditor could detect bugs in dd with high precision high recall and high accuracy .third xeditorcouldidentifyrealbugs indd whichwere actuallylaterfixedbydevelopers.thisdemonstratestheusefulnessof xeditorandthenecessityofsimilarstaticanalysistoolsfordd.
thereisstillsignificantspaceforfutureimprovementsinddrelatedruleinferenceandapplication.ourresearchcurrentlyfocuses on def use like configuration couplings because we observed such rules in various software frameworks.
however it is still unknownwhatmajortypesofddbugsexistinrealsoftwaresystems and how def use bugs compare with other bug categories in terms of the occurrence rates and severity.
as the future work we will conduct an empirical study on dd bugs in open source projects.
acknowledgment wethank reviewersfor their insightfulcomments.
thiswork was supported by nsf grants ccf and cns and beijing natural science foundation no.
.
682references bagh.
cae2a77fbdefedc823291a5fa98a3f51bb0c4816 diff411d1a9625fc3f5d5be34d116942f6ca.
demo web.
webapp web inf web.xml.
github.
poc spring data mongodb.
spring bean definition.
definition.htm.
stackoverflow.
thedeploymentdescriptor web.xml.
standard java config webxml.
viewing deployment descriptors.
app deploymtdesc.html.
workingwithsecurityroles.
bncav index.html.
xml syntax.
introductiontowebapplicationdeploymentdescriptors.
com cd e19226 bncbj index.html .
manual wiring functional.
.
securingresturlswithspring.
.
howtocorrectlymanagefeatureconfigurationdeploymentinjbossfuse6.
.
?
.
antlr.
.
gumtreediff gumtree.
.
securingwebapplications.
.
m. attariyan and j. flinn.
using causality to diagnose configuration bugs.
in usenix annual technical conference atc pages berkeley ca usa .
usenix association.
m.attariyanandj.flinn.
automatingconfigurationtroubleshootingwithdynamic information flow analysis.
in proceedings of the 9th usenix conference on operatingsystemsdesignandimplementation osdi pages237 berkeley ca usa .
usenix association.
v.benzaken g.castagna anda.frisch.
cduce anxml centricgeneral purposelanguage.
in proceedings of the eighth acm sigplan international conference on functional programming icfp pages new york ny usa .
acm.
m. borg p. runeson and a. ard .
recovering from a decade a systematic mapping of information retrieval approaches to software traceability.
empirical software engineering .
m. brundage.
xquery the xml query language.
pearson higher education .
i. darwin.
annabot a static verifier for java annotation usage.
advances in software engineering .
p.duvall s.m.matyas anda.glover.
continuousintegration improvingsoftware qualityandreducingrisk theaddison wesleysignatureseries .
addison wesley professional .
m.eichberg t.sch fer andm.mezini.
usingannotationstocheckstructural propertiesofclasses.
in proceedingsofthe8thinternationalconference heldas partofthejointeuropeanconferenceontheoryandpracticeofsoftwareconference on fundamental approaches to software engineering fase pages berlin heidelberg .
springer verlag.
h.gall k.hajek andm.jazayeri.
detectionoflogicalcouplingbasedonproduct release history.
in proc.
icsm pages .
h. gall m. jazayeri and j. krajewski.
cvs release history data for detecting logical couplings.
in proc.
iwpse pages .
m. gethers b. dit h. kagdi and d. poshyvanyk.
integrated impact analysis for managingsoftwarechanges.
in 201234thinternationalconferenceonsoftware engineering icse pages june .
o.c.
z.gotelandc.
w.finkelstein.
ananalysisof therequirementstraceability problem.
in proceedings of ieee international conference on requirements engineering pages .
h. hosoya and b. c. pierce.
regular expression pattern matching for xml.
j. funct.
program.
nov. .
h. hosoya and b. c. pierce.
xduce a statically typed xml processing language.
acm trans.
internet technol.
may .
m. a. islam m. m. islam m. mondal b. roy c. k. roy and k. a. schneider.
detecting evolutionary coupling using transitive association rules.
in2018ieee18thinternationalworkingconferenceonsourcecodeanalysis and manipulation scam pages sep. .
z.jiang y.wang h.zhong andn.meng.
automaticmethodchangesuggestion tocomplementmulti entityedits.
journalofsystemsandsoftware .
h. kagdi and j. maletic.
software repositories a source for traceability links.
tefse gct .
h. h. kagdi m. gethers and d. poshyvanyk.
integrating conceptual and logical couplingsforchangeimpactanalysisinsoftware.
empiricalsoftwareengineering .
n. meng s. nagy d. yao w. zhuang and g. a. argoty.
secure coding practices in java challenges and vulnerabilities.
in icse .
c. noguera and l. duchien.
annotation framework validation using domain models pages .
springer berlin heidelberg berlin heidelberg .
r.oliveto g.antoniol a.marcus andj.hayes.softwareartefacttraceability thenever endingchallenge.in ieeeinternationalconferenceonsoftwaremaintenance icsm pages .
a. rabkin and r. katz.
precomputing possible configuration error diagnoses.
in proceedings of the 26th ieee acm international conference on automated software engineering ase pages washington dc usa .
ieee computer society.
t. rolfsnes s. d. alesio r. behjati l. moonen and d. w. binkley.
generalizing the analysis of evolutionary coupling for software change impact analysis.
in2016 ieee 23rd international conference on software analysis evolution and reengineering saner volume pages march .
j.sharmaanda.sarin.
gettingstartedwithspringframework coversspring5.
createspace independent publishing platform usa 4th edition .
j. s. shirabad t. c. lethbridge and s. matwin.
mining the maintenance history of a legacy software system.
in proc.
icsm pages .
m. song and e. tilevich.
metadata invariants checking and inferring metadata codingconventions.
in 201234thinternationalconferenceonsoftwareengineering icse pages june .
springsecurityjdkbasedproxyissuewhileusing securedannotationoncontrollermethod.
j. w. w. wan and g. dobbie.
extracting association rules from xml documents using xquery.
in proceedings of the 5th acm international workshop on web information and data management widm pages new york ny usa .
association for computing machinery.
y.wang n.meng andh.zhong.
cmsuggester methodchangesuggestionto complement multi entity edits.
in sate .
y. wang n. meng and h. zhong.
an empirical study of multi entity changes in realbugfixes.
2018ieeeinternationalconferenceonsoftwaremaintenanceand evolution icsme pages .
a.weiss a.guha andy.brun.
tortoise interactivesystemconfigurationrepair.
inproceedings of the 32nd ieee acm international conference on automated software engineering ase pages piscataway nj usa .
ieee press.
a.t.t.ying g.c.murphy r.ng andm.c.chu carroll.
predictingsourcecode changesbyminingchangehistory.
ieeetransactionsonsoftwareengineering sept .
m. b. zanjani g. swartzendruber and h. kagdi.
impact analysis of change requestsonsourcecodebasedoninteractionandcommithistories.
in proceedings of the 11th working conference on mining software repositories msr pages new york ny usa .
acm.
c.zhangands.zhang.
associationrulemining modelsandalgorithms.
springerverlag berlin heidelberg .
s. zhang and m. d. ernst.
automated diagnosis of software configuration errors.
inproceedings of the international conference on software engineering icse pages piscataway nj usa .
ieee press.
t. zimmermann p. weisgerber s. diehl and a. zeller.
mining version histories to guide software changes.
in proc.
icse pages .