parallel shadow execution to accelerate the debugging of numericalerrors sangeeta chowdhary departmentof computerscience rutgers university usa sangeeta.chowdhary rutgers.edusantosh nagarakatte departmentof computerscience rutgers university usa santosh.nagarakatte cs.rutgers.edu abstract thispaperproposesanewapproachfordebuggingerrorsinfloating pointcomputationbyperformingshadowexecutionwithhigher precisioninparallel.theprogrammerspecifiespartsoftheprogram that needto be debuggedfor errors.
our compilercreates shadow execution tasks which execute on different cores and perform the computation with higher precision.
we propose a novel method to execute a shadow execution task from an arbitrary memory state whichisnecessarybecausewearecreatingaparallelshadow executionfromasequentialprogram.ourapproachalsoensures thattheshadowexecutionfollowsthesamecontrolflowpathasthe originalprogram.ourruntimeautomaticallydistributestheshadow execution tasks to balance the load on the cores.
our prototype for parallel shadow execution pfpsanitizer provides comprehensive detectionoferrorswhilehavinglowerperformanceoverheadsthan prior approaches.
ccs concepts software and its engineering software testing and debugging computingmethodologies parallelcomputing methodologies .
keywords floatingpoint dynamicanalysis fpsanitizer roundingerrors acmreference format sangeeta chowdhary and santosh nagarakatte.
.
parallel shadow executiontoacceleratethe debuggingofnumericalerrors.
in proceedingsof the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august 23 28 athens greece.
acm new york ny usa 12pages.
introduction the floating point fp representation approximates a real number usingafinitenumberofbits.hence someroundingerrorwitheach operationisinevitable.suchroundingerrorscanbeamplifiedby certainoperations e.g.
subtraction suchthattheentireresultis permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse august 23 28 athens greece associationfor computing machinery.
acm isbn ... .
by rounding errors.
even the control flow of the programcandiffercomparedtoanoracleexecutionduetorounding errors whichcanresultinslowconvergenceorwrongresults.in extremecases mathlibrariescanproducewrongresults whichcan beamplifiedbyotheroperations.further theprogramcanproduce exceptionalvaluessuchasnot a number nans whichgetpropagatedthroughouttheprogramtoproduceincorrectresults.such errorshave causedwell documentedmishaps .
giventhehistoryoferrorswithfpprograms therehavebeen numerous proposalsto detect debug and repairerrors .therearenumeroustoolstodetectspecificerrors .acomprehensiveapproachtodetecterrorsin fpprogramsistoperforminlinedshadowexecutionwithrealnumbers .intheshadowexecution everyfpvariableinmemory and registers is represented with a type that has a large amount of precision e.g.
using mpfr library .
when the fp value and the shadow value differ significantly the error is reported to the user.suchshadowexecutiontoolscancomprehensivelydetecta wide range of errors cancellation errors branch divergences and thepresenceofspecialvalues e.g.
nans .toassistindebugging the error herbgrind and fpsanitizer provide a directed acyclic graph dag of instructions.
herbgrind when coupled with herbie hasbeenusefulinrewritingfpexpressions.thedebugging features in our prior work fpsanitizer have been useful inour effortto develop correctlyroundedmath libraries .
inlined shadow execution is useful in detecting errors with unit tests.
however it has more than performance overhead.
software emulation of a real number using the mpfr library and additionalinformation i.e.
metadata maintainedwitheachmemory location during inlined shadow execution are the primary sources ofthisperformanceoverhead.theseoverheadspreventtheusage ofsuch debuggingtoolsinmanyapplications.
our objective is to enable the use of shadow execution tools for debuggingnumericalerrorswithlongrunningapplications.this paperproposesanewapproachfordebuggingnumericalerrorsthat performs shadowexecution in parallel on the multicore machines.
inourapproach theuserspecifiespartsofthecodethatneedsto bedebugged i.e.
withdirectives pragma pfpsan infigure a similar to task parallel programs.
our compiler creates shadow executiontasksthatmimictheoriginalprogrambutexecutethefp computation with higher precision inparallel.
the shadow executiontasksofasequentialprogram bydefault arealsosequential becausetheyneedthememorystatefrompriortasks.toexecute the shadow execution tasks in parallel we need to provide these shadow execution tasks with appropriate memory state and input arguments.
we also need to ensure that the parallel task follows esec fse august 23 28 athens greece sangeeta chowdhary andsantoshnagarakatte the same control flow path as the original program to be useful for debugging.
our key insight for parallel shadow execution from a sequential programistousethefpvalueproducedbytheoriginalprogramas theoraclewheneverwedonothavethehigh precisioninformation available.
our approach is partly inspired from prior efforts on speculative parallelization .
in our model the shadow task can startexecutionevenifpriorshadowtasks accordingtotheorderin the sequential program have not completed as long as the original program has executed the corresponding fp computation.
the original program pushes the live fp values memory addresses and the fp values loaded from those addresses to a queue that is used by the shadow execution task see figure .
the original program and the shadow execution task execute in a decoupled fashion and communicate only through the queues.
the shadow executiontaskreadsthelivefpvaluesfromthequeueandexecutes the high precision version of the program created by our compiler.
itmaintainsahigh precisionvalue i.e.
ampfrvalue witheach fpvariable inboth memory andintemporaries.
whentheshadowexecutiontaskloadsavaluefromamemory location itneedstoidentifywhetherthememorylocationwaspreviously written by that task.
the high precision value is available in memory when the task haspreviously written to that address.
otherwise it needs to initialize the shadow execution using the fpvaluefromtheoriginalprogram.todetectsuchscenarios the shadowexecutiontaskstoresboththehigh precisionvalueandthe fpvalueproducedbytheprograminitsmemorywhenitperforms a store.
subsequently when the shadow execution task performs a load it checks whether the loaded fp value from memory and the valueproducedbytheprogramareidentical.thefpvaluesfrom theprogramandtheonesinthememoryoftheshadowtaskwill mismatch whenthe shadow taskis accessingthe memory address forthefirsttimeorwhenthememoryaddressdependsonvalues frompriorshadowtasks.insuchcases theshadowtaskusesthefp value from the program as the oracle and re initializes its memory seefigure .thistechniquetousetheoriginalprogram sfpvalue asanoracleallowsustoexecuteshadowexecutiontasksfroman arbitrary state.toenableeffectivedebuggingofnumericalerrors the shadow execution task also maintains information about the operationthatproducedthevalueinmemory whichcanbeused to provideadag ofinstructionsresponsible for the error.
our prototype pfpsanitizer is open source and publicly available .itenhancesthellvmcompilertoinstrumenttheprogram and generate shadow execution tasks.
pfpsanitizer s runtime creates a team of threads for shadow execution allocates bounded queues to communicate values for shadow execution tasks and dynamicallyassignsshadowexecutiontaskstothecorestobalance the load.
the speedup with pfpsanitizer over inlined shadow executiondependsonthenumberofshadowtasks.iftheuserdoes notcreateanytask thentheentireexecutionisasingletaskand pfpsanitizer can attain a maximum speedup of .
when the user creates sufficient number of shadow tasks pfpsanitizer is approximately fasteronaverageonamachinewith64 cores whencomparedto fpsanitizer whichisthestate of the artfor debuggingfpprograms.sign bit bit exponent bits fraction bits figure a bit fp representation of .
in decimal.
first thenumber5.5isconvertedtoabinaryfraction .
andtheactualbitpatternsfortheexponentandthefraction aredetermined.as bias 127fora32 bitfloatand e bias e 129whichis inbinary.theleastsignificantbits ofthefraction are populated with zeros.
real .5f computed .5freal .00134f computed .00134f real .
computed .
real .00134f computed .00134freal .
computed .4999real .5f computed .5freal computed .98023e real .0f computed .0freal computed .
a bbac computation of a a b b ccancellation figure2 erroramplificationwithasequenceofoperations represented as a dag.
we show the real value and the fp resultforeachoperation.
background weprovideaprimeronthefprepresentation thecauseoferrors andtheiraccumulationwithfpcomputation anoverviewofinlined shadowexecution andacomparison of existing approaches.
the floating point representation.
the floating point fp representationisthemostwidelyusedrepresentationtoapproximaterealnumbers.itwasstandardizedbytheieee 754standard.
thefprepresentationisspecifiedbythetotalnumberofbits n and thenumberofbitsfortheexponent e .therepresentationhas threecomponents asignbit e exponentbits and n e bitsto representthefraction.figure 1showstherepresentationfora32 bit float whichhasasignbit bitsfortheexponent and23 bitsfor thefraction.a64 bitdoublehasasignbit bitsfortheexponent and bits for the fraction.
the goal of the fp representation is to encode both large andvery small values.
thesignbitindicateswhetherthenumberispositiveornegative.
there are three classes of values depending on the bit pattern in the exponent.
if the exponent bits are all s the bit pattern representsspecialvalues.itrepresentsinfinityifthefractionbits areall0 sandnans not a number otherwise.thesespecialvalues propagatewitheachoperation.iftheexponentbitpatternisall0 s itrepresentsdenormalvalues i.e.
valuesveryclosetozero .the value of the number represented is s .f bias where bias e 1andfisthevalueofthebinaryfraction i.e.
from thefractionbits .iftheexponentbitpatternisneitherall0 snor 616parallel shadowexecutionto acceleratethe debuggingof numerical errors esec fse august 23 28 athens greece table comparison of various dynamic analysis tools.
we indicate whether they support parallel execution type of instrumentation performance overhead kind of errors detected and the oracle used for the analysis.
here il indicates that the tool provides debugging information at an instruction level which is useful for debugging.
fl represents information being presented at thegranularity ofafunction.
tool nameparallel shadow analysisinstrumentation overheadrounding errorsbranch flipsconversion errorsroot cause analysisoracle bz compiler gimple ir .
canceled bits fpspy binary valgrind condition codes verrou binary valgrind fl randomized rounding fpdebug binary valgrind il mpfr herbgrind binary valgrind il mpfr fpsanitizer compiler llvmir il mpfr pfpsanitizer compiler llvmir .
il mpfr all1 s thenitrepresentsnormalvalues.thevaluerepresentedis s .f 2e bias.
rounding error.
when a real number is not exactly representable then it must be rounded to the nearest fp number accordingtotheroundingmode.theieee 754hasmultiplerounding modes.
round to nearest with ties to even is the default rounding mode .
hence each primitive arithmetic operation has some error which is bounded by .
ulp units in the last place .
accumulation oferrors.
althougheachprimitivearithmetic operation has a small amount of rounding error .5ulp the error can get amplified with a sequence of operations and produce wrong results exceptions and branch divergences.
figure 2shows the accumulation of error while computing the expression a a b b c.an executionwithrealsproduces zerobutthe fpexecutionproducesanon zerovalue.whenthisvalueisused as a branch condition then the outcome of the branch will diverge fromtheidealexecution.onereasonforthiserroristhatwhentwo numbers that are close to each to other are subtracted the most significant precision bits can get canceled.
if the remaining bits are influencedbyrounding then the roundingerrorgetsamplified.
inlinedshadowexecutionwithreals.
onewaytodetectsuch numericalerrorsisbycomparingtheresultsofthefpprogramand the program that is rewritten with real numbers i.e.
differential analysis .suchanapproach candetecterrorsbutdoesnot helpin debuggingbecauseitisinfeasibletostoreallintermediateresults and compare them.
a lock step inlined shadow execution wheretheanalysisperformsrealcomputationaftereachinstruction maintainstherealvaluewitheachvariableinregistersandmemory and checks error after each instruction is useful.
the real numbers are simulated with a widely used gnu mpfr library which is a c libraryformultiple precisionfloatingpointcomputationswithcorrectrounding.bymaintainingappropriateinformationwitheach memorylocation suchlock stepshadowexecutioncanprovidea directed acyclic graph dag of instructions i.e.
a backward slice ofinstructions to debug an error .
comparison of prior approaches with pfpsanitizer .table1comparesvariousdynamicanalysistoolstodetectfperrors.
manyofthepriorapproachesdonotusetherealexecutionasan oracle because it is expensive .
hence they detect likelyerrorsrather than actual errors.
amongthe shadow executionapproaches that use real numbers as an oracle herbgrind and fpdebug perform binary instrumentation and have significant overheads.ourpriorwork fpsanitizer reducestheoverhead by keeping the memory usage bounded.
in contrast to prior approaches pfpsanitizer performsparallelshadowexecutionthat reduces overheads by an order of magnitude while providing comprehensive detection anddebuggingsupport.
parallel shadowexecution our objective is to facilitate detection and debugging of numerical errors by performing a fine grained comparison of a program s executionwithaparallelshadowexecutioncarriedoutwithhigherprecision.incontrasttoapproachesthatdetectspecificerrors a shadow execution with higher precision can enable comprehensive detection and debugging of errors such as cancellation exceptions precision loss and control flow divergences.
typically fpdatatypessuchas floatanddoublearesupportedinhardware andthehigher precisionexecutionisperformedusingasoftware library e.g.
mpfr .hence inlinedshadowexecutionwillbesignificantlyslowerthantheprogram sexecution.toaddressthese overheads we propose to perform parallelshadowexecution.
performingshadowexecutioninparallelischallengingforthe following four reasons.
first we have to create a higher precision versionoftheprogramautomatically whichchecksitsexecution with the original program in a fine grained manner.
second significant communication between the original program and the shadowexecutionwillreduceperformance.third executingthe entire shadow execution on another core i.e.
a single core will notprovidesignificantspeedupcomparedtoinlinedshadowexecution because the shadow execution is significantly slower than the original program.
hence we need a mechanism to identify and executefragmentsofshadowexecutioninparallel i.e.
parallelizethe shadow execution .
finally we need to initialize the memory state appropriately for each such parallel fragment of shadow execution.
.
high level overviewof pfpsanitizer we propose a new approach for debugging numerical errors where theuserspecifiespartsoftheprogramthatneedstobedebugged.
our compiler automatically creates a high precision version of 617esec fse august 23 28 athens greece sangeeta chowdhary andsantoshnagarakatte float foo float a float b pragma pfpsan float aval a float bval b float x1 aval bval float x2 x1 aval float x3 x2 bval float z .
if x3 z x2 x3 else z x2 x3 return z a original program with a directive float foo float a float b task create task float aval a 3a task.enqueue a aval float bval b 4a task.enqueue b bval float x1 aval bval float x2 x1 aval float x3 x2 bval float z .
task.
enqueue x3 9a if x3 z x2 x3 else z x2 x3 task.enqueue z 15a end task task return z void foo shadow task t 3a a addr a t.dequeue 3b a s pfpsan load a a addr b addr b t.dequeue 4a b s pfpsan load b b addr x1 s pfpsan add a s b s x2 s pfpsan sub x1 s a s x3 s pfpsan sub x2 s b s z s pfpsan const .
cond t.dequeue 9a cond s pfpsan cmp x3 s 9b pfpsan check branch cond cond s 9c if cond z s pfpsan mul x2 s x3 s else z s pfpsan add x2 s x3 s z t.dequeue 15a pfpsan check return z z s .
b compiler generated producer program with fp computation c compiler generated shadow execution task with high precision computationpfsan compiler figure3 transformationsdonebythe pfpsanitizer scompiler.
a programwith pfpsandirective.
b theproducer original program withadditionalinstrumentationtowritefpvaluesandaddressestothequeue.theproducerpassestheaddressofthe memory read and the actual fp value because it enables the shadow execution task to map the address to a shadow memory address.
the fp value enables it to check if the shadow task is starting from an arbitrary memory state.
c the consumer shadow execution task that performs high precision computation.
by default pfpsanitizer checks error on every branch conditionandreturn value i.e.
pfpsan check branch andpfpsan check return the original program corresponding to it which we call as the shadowexecutiontask.therearetworequirementsfortheshadow execution it has to follow the same control flow path as the original program and we should be able to check the shadow execution s value with the original program s value at various pointsofinterest.ourgoalistoexecutemultipleshadowexecution tasksinparallel.however theseshadowexecutiontasksarederived fromasequentialprogramandtheyaredependentoneachother.to executetheminparallel weneedtobreakdependenciesbetween theseshadowexecutiontasks.
tobreakdependenciesbetweentwoshadowexecutiontasks we needtoprovideappropriatestateformemorylocationsthatdepend on values produced by prior shadow tasks.
our key insight is to use the fp values from the original programas the oracle to break dependencies.inourmodel wetreatashadowexecutiontaskto be independent of other shadow tasks and use the values produced bythecorrespondingregionsoftheoriginalprogramtoinitialize the memory state.
hence our compiler introduces additional instrumentation to the original program to provide live fp values addressesofmemoryaccesses fpvaluesreadfromeachmemory access andoutcomesofbranchestothequeue.figure b presents the instrumented version of the original program.
the shadow executiontasks created by our compiler readfp values and addresses from the queue.itexecutesthe fpcomputationwithhigher precision.
to ensure that the shadow execution taskfollows the same control flowpathastheoriginalprogram pfpsanitizer scompilerchangeseverybranchintheshadowtasktousetheoutcomeofthe original program.
figure c illustrates the shadow execution task createdbyour compilerfor the program infigure a .
the shadow task maps every memory location with an fp value in the original program to a shadow memory location that has a high precisionvalue.whentheshadowtaskexecutesamemory access itneedstodeterminewhetherthatlocationhasbeenpreviously accessed by it.
if it has previously accessed the memory location thenthehigh precisionvalueisavailableinshadowmemory.
otherwise itneeds toinitializetheshadowmemory with the fpvaluefromtheprogram.hence everyshadowmemorylocation maintainsthehigh precisionvalueandthefpvalueproducedby theoriginalprogram.whentheshadowexecutiontaskperforms aload we checkif the fpvalue loadedfrom shadow memory and thefpvalueproducedbytheoriginalprogramareidentical.ifthey match we use the high precision value for shadow execution.
otherwise weusethefpvalueproducedbytheprogramtoreinitialize shadow memory for that location.
this technique to use the fp valuefromtheoriginalprogramastheoracleenablesustoperform parallel shadow execution from a sequential program.
it limits the detection of errors to instructions in the region provided by the programmer whichwefoundtobesufficienttodebugvariousfperrors.toassistdebugging eachshadowmemorylocationmaintains information about the operations that produced the value.
this informationenables pfpsanitizer todetecterrorsandprovidea dag ofinstructionsfor thoseerrors.
618parallel shadowexecutionto acceleratethe debuggingof numerical errors esec fse august 23 28 athens greece for .. int res foo .... core .. .. bk ak .. the original program producer task task foo shadow .. .. b0 a0 .. .. .. b1 a1 ..task task kshadow memory core task foo shadow shadow memory core task k foo shadow shadow memory core k shadow execution tasks consumers active tasks along with bounded queues for live fp values figure parallel execution of shadow execution tasks during dynamic execution on a multicore machine.
the producer original program and the consumer communicate live fp values addresses of memory accesses and branch outcomes usingqueues.
pfpsanitizer sruntimemapsashadowexecutiontasktooneof thecoresinthesystemdynamicallybalancingtheload.theoriginal program and the shadow execution task operate in a decoupled fashionandcommunicateonlythroughthequeues seefigure .
this decoupled execution with dynamic load balancing provides significant speedups withthe increaseinthe number ofcores.
.
ourmodel fordebuggingfp errors as our goal is to enable programmers to debug numerical errors in longrunningprograms performinganexpensiveshadowexecution for the entire program may not be feasible.
in our approach the programmermarkspartsoftheprogramthatneedstobedebugged withthepfpsandirective i.e.
pragma pfpsan infigure a .each pfpsandirective represents a scoped block where the programmer suspectsthepresenceofnumericalerrorsandwantstodebugthem withshadowexecution.ourcompilergeneratesashadowexecution taskforeachsuchdirective.eachsuchdirectivecorrespondstoa single shadow task which can be executed on another core.
we do not support nested directives.
if the dynamic execution encounters nested directives the nested directives are ignored and the shadow executiontaskcorrespondsto the outermost directive.
two non nested directives in the dynamic execution result in two shadow execution tasks that can execute in parallel.
if the programmer places the directive at the beginning of the main method theentireprogramwillbeasingleshadowexecutiontask.itcanat most get a speedup of over inlined shadow execution.
as the programmerintroducesmoredirectives moreshadowexecution tasks can be executed in parallel.
with the introduction of additional non nested directives the window of instructions tracked to debug an error decreases.
numerical errors have a relatively small windowofdynamicinstructionsthatareusefultodebugandfixthe error .hence whentheprogrammerusesasufficientnumber of directives the programmer can obtain sufficient speedup and relatively rich dag of instructions to debug the error using our approach.
.
compiler generatedshadowtasks given a program with directives pfpsanitizer s compiler automaticallycreatesashadowhigher precisionversionoftheprogramthatcanoperateinparallelwiththeoriginalprogramonaseparate core.wewanttheoriginalprogramandtheshadowtasktoexecute independently with minimum communication.
in our design they communicatethroughboundedqueues.theoriginalprogramisthe producerandtheshadowexecutiontaskistheconsumer.toenable effectivedebugging weneedtoensurethattheshadowtaskfollows thesamecontrol flowpathastheoriginalprogram.
pfpsanitizer s compileridentifiesthe pfpsandirectiveandcreatesthemodified original program and the shadow execution task corresponding to the directive.
figure b shows the modified original program and the shadowexecutiontaskcorresponding to the directive.
modified original program.
pfpsanitizer s compiler modifies the original program to account for the creation of the shadow task.itaddsacalltotheruntimetoobtainanuniquetaskidentifier and a queue associated with it.
subsequently pfpsanitizer captures the fp values that are live to the directive and introduces enqueue operations.
our shadow tasks do not have information aboutintegeroperations.hence pfpsanitizer enqueuestheaddressandthe fpvalueloaded storedfor everymemoryoperation.
toprovideinformationaboutthebranchconditions thecompiler alsoenqueuesthe branchcondition.attheend ofthescopedblock corresponding to the directive the compiler adds a runtime call to indicatethe end ofthe shadowtask.
shadow execution task.
pfpsanitizer creates ashadow executiontaskthatperformsthehigher precisionexecutiontofacilitatedetectionanddebuggingoffperrors.toimproveperformance pfpsanitizer doesnotcreateahigh precisionreplicaoftheentire scopedblockindicatedbythedirective.further rewritinganentire program especially global data structures with indirect