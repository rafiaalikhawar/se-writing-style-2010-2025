metamorphic testing of datalog engines muhammad numair mansur mpi sws germany numair mpi sws.orgmaria christakis mpi sws germany maria mpi sws.orgvalentin w stholz consensys germany valentin.wustholz consensys.net abstract datalog is a popular query language with applications in several domains.
like any complex piece of software datalog engines may contain bugs.
the most critical ones manifest as incorrect results when evaluating queries we refer to these as query bugs.
given the wide applicability of the language query bugs may have detrimental consequences for instance by compromising the soundness of a program analysis that is implemented and formalized in datalog.
in this paper we present the first metamorphic testing approach for detecting query bugs in datalog engines.
we ran our tool on three mature engines and found previously unknown query bugs some of which are deep and revealed critical semantic issues.
ccs concepts software and its engineering software testing and debugging.
keywords metamorphic testing fuzzing datalog acm reference format muhammad numair mansur maria christakis and valentin w stholz.
.
metamorphic testing of datalog engines.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
.
introduction datalog is a declarative logic based query language that is syntactically a subset of prolog.
datalog is expressive yet concise and as a result it is used as a domain specific language in several application domains such as natural language processing bioinformatics big data analytics networking program analysis robotics generic graph databases and security .
query evaluation is performed by datalog engines prominent examples of which include souffl bddbddb ddlog z and logicblox .
however as any complex piece of software datalog engines may contain bugs resulting in incorrect query results.
an incorrect result may manifest by including wrong entries or by missing entries that should have been included.
we refer to such bugs as query bugs.
esec fse august athens greece copyright held by the owner author s .
acm isbn .
on the application domain query bugs may have detrimental consequences.
in particular when a buggy datalog engine is used in program analysis it could compromise soundness of the verification process in other words it could cause an analyzer to verify incorrect software.
as an example imagine a static analyzer that uses datalog to implement a may alias or must alias analysis.
a query bug that results in computing fewer or more aliases could lead to missing critical bugs in the analyzed software.
in this paper we present the firstautomatic test case generation approach for detecting query bugs in datalog engines.
a major challenge in finding such bugs is the lack of an oracle specifying expected query results.
this problem may be overcome with a technique known as differential testing .
differential testing would involve running multiple datalog engines on a common set of programs and comparing their results for discrepancies.
in our context this would be extremely difficult as there exists no unified standard for datalog syntax as a result many different dialects have emerged.
our approach circumvents the lack of an oracle using an alternative technique namely metamorphic testing .
it works by transforming a datalog program such that the new result has an a priori known relationship to the result of the original program.
examples of such a relationship are that the new result should be equivalent to the original contained in the original or containing the original.
to ensure that these oracles are known in advance we design metamorphic transformations based on database theory and in particular formal properties of conjunctive queries.
despite their simplicity conjunctive queries constitute an important class of database queries due to their theoretical properties.
specifically while many fundamental problems in query optimization and minimization are computationally hard or even undecidable for general forms of queries they are feasible for conjunctive queries.
an example of such a problem is query containment which we discuss in sect.
.
the key insight behind our approach is to leverage properties of conjunctive queries to develop metamorphic transformations for full blown datalog programs.
we implement our approach in a tool called queryfuzz which we use to test three mature datalog engines.
not only did we find previously unknown query bugs in all engines but we also detected of all reported query bugs since may .
moreover as we describe in sect.
some of these bugs were hidden deep in the engine stack and revealed critical semantic issues.
contributions.
our paper makes the following contributions we present the first metamorphic testing approach for detecting query bugs in datalog engines.
we implement our approach in an open source tool1 queryfuzz.
we are already working closely with the developers 639this work is licensed under a creative commons attribution international .
license.
esec fse august athens greece muhammad numair mansur maria christakis and valentin w stholz declarations 2edge x number y number .
3reachable x number y number .
.output reachable facts 7edge .
8edge .
9edge .
10edge .
rules 13reachable x y edge x y .
14reachable x z edge x y reachable y z .
figure a simple datalog program.
of the mature datalog engine souffl in order to integrate queryfuzz in their development cycle.
we evaluate the effectiveness of queryfuzz by testing three popular datalog engines.
our tool detected previously unknown query bugs in all three engines as well as many other bugs as a by product.
outline.
the next section gives an overview of our approach.
sect.
provides background on properties of conjunctive queries sect.
explains the technical details of our approach for these queries and sect.
generalizes the approach to full blown datalog programs.
in sect.
we describe the implementation of queryfuzz .
we present our experimental evaluation in sect.
discuss related work in sect.
and conclude in sect.
.
overview datalog is a logic programming language where programs comprise a finite set of rules over relations .input relations are given in the form offacts they are also commonly referred to as extensional database edb relations .intensional database idb relations are defined by logic rules and one of them is specified as output .
fig.
shows an example of a simple datalog program.
the rules on lines and define idb relation reachable which is specified as output on line and computes the transitive closure of input relation edge .
pictorially edge represents the graph in fig.
2a.
there is an edge from node xto nodeyifedge x y is a fact.
execution of this program is essentially a sequence of derivations where each step adds an edge tuple to the output relation until a fixed point is reached.
fig.
2b shows the final tuples in reachable .
approach.
using the above example as seed we now give an overview of our metamorphic testing approach for datalog engines.
fig.
illustrates its main stages.
the first stage program generation generates a diverse set of programs to be transformed.
it takes as input a possibly empty seed program such as that of fig.
and outputs a new program.
in case the seed is empty the new program is randomly generated based on a datalog grammar.
if the seed is not empty this stage automatically extends it with randomly generated idb relations using both existing and newly generated facts and rules again based on a grammar .
this is essentially a generalization of the above case where the seed is empty.
one of the program relations is then specified as output.
a pictorial view b transitive closure figure pictorial view and transitive closure of edge .
the second stage program transformation applies metamorphic transformations to the newly generated program or directly to the seed if the first stage is skipped .
these transformations change rules of the program such that when computing its output using a datalog engine the new result has an a priori known relationship to the old result.
in particular the new result may contain the old one as computed by program exp .dl in fig.
it may be equivalent to the old one as computed by equ .dl or it may be contained in the old result as computed by con .dl .
for example a transformation in which the new result should be equivalent to the old one is changing line of fig.
to the following reachable x y edge x y edge w y .
as we will see in the next section this change appears to be introducing a join which however has no effect on the result.
another transformation could be applied to line as follows reachable x z edge x x reachable x z .
in this case the new result should be contained in the old one in fact the new result should be empty as there are no edges from a node to itself.
finally the third stage bug detection uses these relationships between new and old results shown in blue and yellow respectively in fig.
as oracles in order to detect query bugs in the underlying datalog engine.
for instance imagine that after transforming line of fig.
as described above the datalog engine returns all but one of the tuples shown in fig.
2b.
since this transformation ensures that the new result is equivalent to the old one a query bug has been detected.
note that a query bug is also detected if the old result is incorrect as long as the expected relationship to the new result does not hold.
query bugs.
in the rest of this section we present two query bugs detected by queryfuzz in existing datalog engines.
we provide a complete list of detected bugs and more details in sect.
.
fig.
shows a program snippet that was generated by queryfuzz in order to test z the datalog engine of the z3 smt solver supporting the bddbddb dialect.
relation r line is defined to compute all tuples in in2 whose second element is in in1.
tuple is the only one that satisfies this definition.
output relation out line obtains the first element of each tuple in r that is it computes .
this is also the result that is returned by z. now consider the following transformation applied by queryfuzz to line out f r f c r f a r f b .
the result of the new program should still be but z returns values .
we reported this bug on z3 s github issue tracker2 and it was immediately confirmed and fixed.
in fact a z3 developer 640metamorphic testing of datalog engines esec fse august athens greece program generationgen.dlgenexp.dlequ.dlexp equ gengen bug reportseed.dl con.dlcongen bug detectionprogram transformation123 figure overview of our approach.
1in1 .
in1 .
2in2 .
in2 .
in2 .
4r v m in2 v m in1 m .
5out f r f c .
figure generated program snippet for testing z.
1hqv a mzv a b mzv c d .
2gqk jw mzv jw jw .
3qoq as gf mzv gf gf gqk m hqv as mzv as m .
4rwl qr qoq u qr gqk u gqk u .
5out jb ym gqk h rwl ym mzv h jb .
figure generated program snippet for testing souffl .
commented these are good latent bugs.
they exercise some edge cases that slipped through the cracks until now.
the code snippet in fig.
was also generated by queryfuzz this time when testing the souffl datalog engine .
relation out is the output relation of the program.
when line is changed to hqv a mzv a b .
the program result should remain the same.
however we found that the result of the original program contained entries whereas that of the transformed program contained .
we reported this query bug3 which was immediately fixed.
these types of bugs detected by queryfuzz are extremely difficult for unsuspecting users to notice and might compromise upstream applications that rely on a datalog engine.
background in this section we review key concepts from database theory and in particular query optimization that form the basis of our metamorphic transformations.
adatabase schemaris a set of relations r. the arity of a relation is the number of attributes in the relation.
for example edge and reachable in fig.
are relations of arity .
an attribute in a relation can take values from a domain d. letrbe a relation of aritym.
afactoverris an expression of the form r a1 ... a m whereai difor everyi ... m e.g.
edge in fig.
.
aninstance of relationris a finite set of facts over r. adatabase a database schema ris a collection of relational instances over the relations r r. aconjunctive query cq is a single non recursive functionfree horn rule e.g.
every rule in figs.
and is a cq.
this is the simplest type of query that can be expressed over a database schema.
syntactically a conjunctive query qis an expression of the form p u r1 u1 ... r n un where uand ui i n are vectors of variables and constants.
any variable appearing in umust also appear in some ui.
the expression to the left of is the head of the query and the expression to the right is the body .
eachri ui in the body of the query is a subgoal andri r is arelation .
note that subgoals can refer to the same relation.
the set of answers for query qw.r.t a database instanceiis denoted by q i .
given two syntactically different cqs we now define query equivalence andcontainment .
definition query eqivalence .
two conjunctive queries q1andq2are equivalent denoted by q1 q2 iff for every database instancei we haveq1 i q2 i .
definition query containment .
conjunctive query q1is contained in conjunctive query q2 denoted by q1 q2 iff for every database instance i we haveq1 i q2 i .
it is straightforward to see that if q1 q2andq2 q1 thenq1 q2.
a decidable procedure for checking query containment involves determining whether there exists a so called containment mapping between two queries.
definition substitution .
a substitution is a mapping from a set of variables vto a set of variables v .
definition containment mapping .
a substitution is a containment mapping from conjunctive query q2to conjunctive query q1 ifq2can be transformed by means of to becomeq1.
formally given two cqs p u r1 u1 ... r n un q1 p v s1 v1 ... s m vm q2 is a containment mapping from q2toq1if p v p u and i ... m j ... n si vi rj uj .
641esec fse august athens greece muhammad numair mansur maria christakis and valentin w stholz w x y zx yx yw z a containment mapping from q1toq2.
q1 p x a x y a y w a z w .
q2 p x a x y a y x .
q1 p x a x y a y w a z w .
b mapping of head and subgoals induced by .
figure containment mapping fromq1toq2induces a mapping of subgoals.
no mapping exists from q2toq1.
in words a containment mapping maps variables of q2to variables ofq1such that the head of q2becomes the head of q1 and each subgoal of q2becomes some subgoal ofq1.
theorem .
letq1andq2be conjunctive queries.
q2is contained inq1 q2 q1 iff there exists a containment mapping from q1to q2.
as an example consider the two cqs below in datalog syntax p x a x y a y w a z w .
q1 p x a x y a y x .
q2 q2is contained in q1 q2 q1 because there exists a containment mapping fromq1toq2 shown using solid arrows in fig.
6a dotted arrows should be ignored for now .
this is indeed a containment mapping because the head of q1is the head of q2and each subgoal ofq1becomes a subgoal of q2 shown using solid arrows in fig.
6b .
on the other hand q1is not contained in q2 q1 q2 because there does not exist a containment mapping from q2to q1 shown with dotted arrows in the figure.
if xandyare mapped to themselves see fig.
6a then the head and first subgoal of q2 become the head and first subgoal of q1 but the second subgoal of q2cannot become any subgoal of q1 see fig.
6b red dotted arrows denote invalid subgoal mappings .
metamorphic transformations using the equivalence and containment properties of cqs we now present their metamorphic transformations.
note that in this section we keep the presentation simple by describing a single transformation to a single conjunctive query.
in practice however our approach can perform sequences of transformations to multiple more general queries see sects.
.
and for more details .
since any conjunctive query may be expressed as a datalog rule we refer to cqs as rules in the following.
our metamorphic rule transformations are categorized into three types x yx y zx y a containment mapping from qtoq and mapping from q toq.
q p x a x y a y x .
q p x a x y a y x a z x .
q p x a x y a y x .
b mapping of head and subgoals induced by and .
figure example of addeq transformation.
addition add ruleqis transformed into add q q by adding a subgoal.
modification mod ruleqis transformed into mod q q by modifying a variable.
removal rem ruleqis transformed into rem q q by removing a subgoal.
each of these transformation types may result in any of the following three outcomes expansion exp original rule qis contained in transformed ruleq i.e.
q q .
equivalence eq original rule qis equivalent to transformed rule q i.e.
q q .
contraction con transformed rule q is contained in original ruleq i.e.
q q. we refer to these outcomes as oracles .
based on the above a rule transformation combines a transformation type with an oracle.
for instance addcon refers to adding a subgoal to a rule qsuch that the resulting rule q is contained in q. next we describe these transformations in detail.
.
add transformations theadd transformations add a subgoal r v1 ... v n to a ruleq wherev1 ... v nare variables we ignore constants for simplicity.
addexp .the addexp transformation ensures that qis contained in the resulting rule q i.e.
q q .
however note that it is not possible to obtain a q such thatq q by adding a subgoal.
the reason is that when adding a subgoal to q there is always a containment mapping from qtoq i.e.
q q. this is because the head of qis the head of q and each subgoal of qis inq .
consequently even if there existed a containment mapping in the desirable direction i.e.
q q then the two queries would be equivalent a case that is already covered by addeq .
addeq .given that a containment mapping from qtoq always exists the addeq transformation guarantees that q q by ensuring there also exists a containment mapping from q toq.
intuitively addeq adds a new subgoal to qwhile avoiding introducing new joins among the existing subgoals thus preserving the original result.
to ensure the existence of a containment mapping 642metamorphic testing of datalog engines esec fse august athens greece algorithm add transformations 1procedure addeq q head body q g randsubgoal body n arity g m randintrange n 6for i i m i do j randintrange n g.args freshvar q 9return head body g. 10procedure addcon q relations g.rel randrelation relations n arity g vars extractallvars q for i i n i do g.args randvar vars head body q ifg body then return none return head body g. fromq toqwhen adding a subgoal r v1 ... v n toq relationr must already exist in the body of q. example.
fig.
shows an example of an addeq transformation.
the new subgoal a z x shown in green maps to a y x when respecting the containment mapping fromq toq.
although it might appear that the new subgoal introduces a join this join does not restrict the original result as computed by the original subgoals any further.
algorithm.
the algorithm performing this transformation is shown in procedure addeq of alg.
.
first we extract the head and body of rule q line .
then a random subgoal gand its arity n are retrieved from body lines .
on lines we replace each of mvariables ingwith a fresh variable where mis a random number from 1ton.
each call to function freshvar returns a new variable that is not already present in q. this guarantees that no new joins are introduced.
subgoal gis finally appended to body and new rule q is returned line .
in the example of fig.
we replace variable yin subgoal a y x ofqwith fresh variable zand append this new subgoal to qin order to generate q .
addcon .the addcon transformation ensures that rule q is contained in original rule q i.e.
q q. intuitively addcon adds a new subgoal to qintroducing new joins thus potentially contracting the original result.
to differentiate this transformation from addeq we ensure that a containment mapping does not exist fromq toq i.e.
q q .
note however that the absence of such a mapping does not mean that q produces a strictly contracted result.
in other words q qdoes not always hold for example for an empty database instance the result of q is still equivalent to that ofq.
to ensure the absence of a containment mapping from q toqwhen adding a subgoal r v1 ... v n toq relationrmust either not already exist in the body of q or if it does its variables should prevent it from being mapped to any subgoal in q. example.
fig.
shows an example of an addcon transformation.
the new subgoal a y y shown in green corresponds to relation a which already appears in the body of q. despite this the newq p x a x y a y x .
q p x a x y a y x a y y .
q p x a x y a y x .
figure example of addcon transformation.
x yx yw zx y a containment mapping from q toq.
q p x a x y a y x .
q p x a x y a y w .
q p x a x y a y x .
b mapping of head and subgoals induced by .
figure example of modexp transformation.
subgoal does not map to any subgoal in qsince variable ymay not be mapped to both xandy.
algorithm.
the algorithm is shown in procedure addcon of alg.
.
as a first step we create a subgoal gby randomly selecting a relation from the set of all relations in the program line .
on line we retrieve its arity n. then all variables of query qare extracted in vars line and we initialize each argument of g with a random variable from vars lines .
using variables in qfor this initialization guarantees that new joins are introduced unlessgalready appears in body .
if so we discard it lines otherwise we append gtobody and return new rule q line .
note that when none is returned our implementation tries again.
in the example of fig.
we select relation a initialize its arguments with variable y and append this new subgoal to q. .
mod transformations themod transformations modify a rule qby renaming a variable appearing in its subgoals.
modexp .intuitively this transformation expands the result of qby renaming a variable in a way that removes existing joins.
this is achieved by creating a surjective containment mapping from q toq i.e.
q q .
note that the mapping may not be bijective as this would make modexp equivalent to modeq .
example.
fig.
shows an example of a modexp transformation where variable xof subgoal a y x is renamed to w. algorithm.
the algorithm for this transformation is shown in procedure modexp of alg.
.
we first extract variables vars that appear more than once in body of ruleq line .
a random variable vfrom vars is selected line and we replace a random occurrence 643esec fse august athens greece muhammad numair mansur maria christakis and valentin w stholz algorithm mod transformations 1procedure modexp q head body q vars extractreusedvars body v randvar vars body replacerandoccurrence body v freshvar q 6return head body 7procedure modcon q vars extractallvars q 9if vars 2then return none v randvar vars w randvar vars v q replacevar q v w return q x yxx y a containment mapping from qtoq .
q p x a x y a y x .
q p x a x x a x x .
q p x a x y a y x .
b mapping of head and subgoals induced by .
figure example of modcon transformation.
ofvinbody with a fresh variable to get body line .
replacing an occurrence of a reused variable with a fresh one guarantees that existing joins are removed.
finally we return head body as transformed rule q line .
in the example of fig.
we choose variable x which appears twice in the body of q and replace its second occurrence with fresh variable w. modeq .themodeq transformation ensures that the result ofqis equivalent to that of q by creating a bijective containment mapping between the two rules.
a way to guarantee the existence of such a mapping is by replacing alloccurrences of a variable in qwith those of a fresh variable.
note that this is a very simple transformation which we include here mainly for completeness.
modcon .analogously to the modexp transformation modcon renames a variable in qsuch that there exists a surjective and not bijective containment mapping from qtoq .
example.
fig.
shows an example of a modcon transformation where all occurrences of variable yare renamed to x. algorithm.
the algorithm is shown in procedure modcon of alg.
.
as a first step we extract all variables vars inq line .
if there are fewer than two we return none lines .
otherwise two different variables vandware randomly selected from vars lines and we replace all occurrences of vinqwithwto getq line .
this ensures that new joins are introduced.x y zx y z a no containment mapping from qtoq .
q p z t z r x y r y x .
q p z t z r y x .
b dropped subgoal may not be mapped to any subgoal in q .
figure example of remexp transformation.
.
rem transformations the rem transformations remove a subgoal r v1 ... v n from a ruleq.
analogously to the add transformations when removing the subgoal there is always a containment mapping fromq to q i.e.
q q .
this is because the head of q is the head of q and each subgoal of q is inq.
remexp .this transformation checks the existence of a containment mapping from qtoq .
if such a mapping does notexist then q qandq q due to that is the result of qis expanded.
note that in general the problem of checking query containment is np complete.
however we can design a containment checker with linear time complexity because q is derived from qby removing one subgoal.
therefore it is only necessary to check whether this subgoal ofqmay be mapped to any subgoal of q .
example.
consider the example in fig.
.
removing the second subgoal ofq shown in green prevents the existence of a mapping fromqtoq since it would require each of the variables xandy ofqto be mapped to more than one variable of q .
consequently this is a successful remexp transformation.
algorithm.
the algorithm for this transformation is shown in procedure remexp of alg.
.
first we randomly select a subgoal g from the body of q line and remove it to get q line .
we then check the existence of a containment mapping from qtoq line .
this is done by simply checking if the removed subgoal gmay be mapped to any subgoal in q .
if no such mapping exists then we return transformed rule q otherwise none .
the algorithm for checking the existence of a containment mapping fromqtoq whereq is derived from qby removing a subgoalgis shown in procedure existscontainment of alg.
.
as a first step we extract all variables vars inqand vars inq lines .
we then compute the set of removed variables rmvars line .
function replacewithwildcard line creates a pattern expressionpfromgsuch that the first occurrence of each variable ingis replaced with a wildcard if the variable is also in rmvars .
any subsequent occurrences of the same variable are replaced with a back reference to the first match this ensures that equality constraints between variables are captured.
in the example of fig.
rmvars is empty so pisg that is r x y .
if anyg in the body of q matches this pattern then gmay be mapped to a subgoal in q and a mapping exists lines .
otherwise a mapping does not exist line as in fig.
.
644metamorphic testing of datalog engines esec fse august athens greece algorithm rem transformations 1procedure existscontainment q q g vars extractallvars q vars extractallvars q rmvars vars vars p replacewithwildcard g rmvars head body q 7for each g body do ifg matches pthen return true return false 11procedure remexp q head body q g randsubgoal body q .head head q .body body g if existscontainment q q g then return q return none w x y zx y z a containment mapping from qtoq .
q p z t z r w x r y x .
q p z t z r y x .
b mapping of head and subgoals induced by .
figure example of remeq transformation.
remeq .if after removing a subgoal of q a containment mapping fromqtoq does exist then we have a remeq transformation because both q qandq q hold.
the former holds due to and the latter due to .
example.
fig.
shows an example of a remeq transformation.
algorithm.
this algorithm is analogous to the one for remexp see alg.
.
for this transformation however we return q when a containment mapping from qtoq does exist i.e.
existscontainment on line is not negated.
in the example of fig.
rmvars is a singleton containing variable w thus pattern pon line of alg.
isr x where is a wildcard.
subgoal r y x inq matches this pattern and as a result a mapping exists.
remcon .analogously to addexp this transformation can only be the same as remeq .
.
transformation sequences until now we have focused on applying a single transformation to a single rule which is a conjunctive query.
however our approach is also able to apply sequences of transformations to such a rule.
more specifically a rule macro transformation tmay be composed of a sequence of micro transformations as theones that we described so far.
however every micro transformation ti tmust preserve the intended oracle for the rule i.e.
exp eq con .
in particular for an expanding macro transformation texp in whichq q the sequence of micro transformations may have oracles eq orexp but not con.
analogously for a contracting macro transformation tcon in whichq q the micro transformations may have oracles eq orcon but not exp.
for an equivalent macro transformation teq in whichq q all micro transformations must also have eq oracles.
in the following section we generalize our approach from a single conjunctive query to a datalog program containing rules that are not necessarily cqs.
beyond conjunctive queries let us first show how the oracle of a rule macro transformation generalizes to any positive datalog program i.e.
any program without negation.
to do this we need to explain monotonicity of conjunctive queries.
intuitively when adding more entries to a database instance a monotonic query never produces a smaller result.
definition monotonicity .
a conjunctive query qover a database schemaris monotonic iff for every two instances iandj ofr it holds that q i q j wheni j. in a program p the output relation is called a datalog query qp.
suppose our approach transforms a rule qinpto get new rule q and therefore new program p and datalog query q p. now the same oracle that should hold between qandq should also hold betweenqpandq p. this is because in positive datalog all rules are monotonic.
therefore due to the fixed point computation any change in the result of qpropagates monotonically to all rules that directly or transitively depend on q. ultimately this includes the final datalog query and thus the program result.
consequently we may lift our oracles from individual conjunctive queries to full blown positive datalog programs.
naturally this also allows us to transform more than one rule in a positive datalog program as long as all transformations have the same intended oracle.
let us now explain how our approach handles anydatalog program not only positive ones .
of course the eq oracle trivially extends to any program.
however queryfuzz is able to accept any datalog program for alloracles it enforces that all rules depending on a transformed rule q are monotonic e.g.
they do not contain any negated subgoals .
intuitively should the result of a rule q flow into a non monotonic rule the effect on the program result could be flipped for instance it could be contracted instead of expanded.
this is undesirable as it could lead to false positives.
to handle negation existing datalog engines impose a computation order on relations.
more specifically relations are assigned tostrata via a process known as stratification .
lower strata are computed before higher ones during the fixed point computation.
therefore queryfuzz works on any datalog program by only transforming rules that are in a higher stratum than any rules containing negation.
as a consequence no results of transformed rules can flow into non monotonic rules.
note that many datalog dialects support rules with more expressive language features such as comparison operators aggregate functions disjunctions and recursion.
while our transformations target the restricted subset of pure conjunctive queries see sect.
645esec fse august athens greece muhammad numair mansur maria christakis and valentin w stholz they may also be applied to more expressive dialects as long as the monotonicity constraints described above are maintained.
in fact our implementation does handle such dialects.
based on the above in the rest of this section we present another transformation in queryfuzz which is specific to datalog programs unlike the transformations in sect.
which target cqs in general .
.
neg transformation aneg transformation changes a program pinto an equivalent but further stratified program p by introducing a double negation in a ruleq.
in particular introducing a negation causes the datalog engine to split a stratum in two.
when this negation is double we guarantee the eq oracle i.e.
the transformation is negeq .
we introduce so called safenegations i.e.
every variable in a negated subgoal must also appear in a positive subgoal.
unsafe rules are traditionally not allowed in datalog as they do not restrict all variables to finite domains.
as an example consider p x y a x y b y z c z .
q negeq selects a subgoal ginq say c z and replaces it with a new negated subgoal say !
neg z .
relation neg is defined to have the same body as qbut with a negated g thus introducing a double negation neg z a x y b y z !c z .
p x y a x y b y z !
neg z .
q one can easily see that queries qandq are equivalent when thinking about the transformation logically a b neg a b a b c a b c. such a transformation partitions the original stratum of relation pinto two where the stratum of pis strictly greater than that of c. note that datalog traditionally disallows neg transformations when g in this case c has a cyclic dependency on the head of q in this case p which would require them to be defined in the same stratum.
implementation we implemented queryfuzz in a total of lines of python.
it currently supports three datalog dialects namely souffl bddbddb used by z and ddlog .
in the rest of this section we discuss how we implement the bug detection stage of our approach.
bug detection.
during bug detection queryfuzz compares the result of a program gen in fig.
with that of its transformation exp equ orcon in the figure .
however a program result could potentially contain millions of entries.
this is especially true for randomly generated programs.
to efficiently check an oracle queryfuzz uses datalog rules that decide result containment.
for instance the rules that check eq oracles are the following equ1 z gen z !
equ z .
equ2 z equ z !
gen z .
the first rule checks whether gen equ and the second whether equ gen. a bug is detected if the result of either equ1 orequ2 is non empty.table query bugs detected by queryfuzz .
bug datalog metamorphic bug id engine transformations status souffl add fixed souffl rem rem rem mod fixed souffl mod add add confirmed souffl neg fixed souffl mod add add confirmed souffl mod add mod rem confirmed souffl rem mod add confirmed souffl add add mod confirmed 9 z add mod add fixed 10 z add add add mod fixed 11 z add mod fixed 12 z mod add confirmed ddlog add add add confirmed experimental evaluation in this section we address the following research questions rq1 how effective is queryfuzz in detecting previously unknown query bugs in datalog engines?
rq2 is the number of detected bugs significant?
rq3 how deep are the detected bugs?
rq4 what are characteristics of the detected bugs?
rq5 how efficient is queryfuzz ?
.
experimental setup we tested souffl z and ddlog three popular and mature datalog engines that are publicly available on github.
we completed the development of the first version of queryfuzz with a subset of the metamorphic transformations and limited support for different language features in may and initially focused on testing souffl .
we only added support for the dialects of z and ddlog in late dec to evaluate the generality of our transformations.
to avoid burdening developers and reporting duplicate issues we only filed reports for bugs that were clearly different than the ones we had already reported until these were fixed.
of course this hinders bug reporting but it was greatly appreciated by the developers.
in fact we are now closely working with the souffl team on integrating queryfuzz in their development cycle.
.
experimental results we now discuss our experimental results for each of the above research questions.
rq1 query bugs.
tab.
shows the list of unique query bugs detected by queryfuzz in the datalog engines we tested.
note that we confirmed bug uniqueness with the engine developers themselves.
the first column of the table assigns an identifier to each bug all identifiers link to the corresponding bug reports on the github issue tracker of each engine.
the second column of the table shows the engine in which the bug was found the third the sequence of metamorphic transformations that revealed the bug and the last column shows the current status of the bug i.e.
open confirmed or fixed .
646metamorphic testing of datalog engines esec fse august athens greece table by product bugs detected by queryfuzz .
bug datalogbug typebug id engine status souffl floating point exception confirmed souffl aborted evaluation fixed souffl segmentation fault fixed souffl segmentation fault fixed souffl segmentation fault fixed souffl segmentation fault fixed souffl segmentation fault confirmed souffl assertion failure fixed souffl assertion failure fixed souffl assertion failure confirmed souffl assertion failure confirmed souffl assertion failure open souffl compiler error fixed 27 z performance bug fixed overall queryfuzz detected previously unknown query bugs in all three engines.
all bugs have been confirmed by the developers and have already been fixed.
bugs and are labeled as questions on the issue tracker even though developers have confirmed them.
the reason is that they reveal a deep semantic issue in logic programming that cannot be easily addressed see rq4 .
as shown in the third column of the table each of our metamorphic transformations i.e.
add mod rem and neg contributed to detecting at least one query bug.
moreover the fact that each tested engine implements its own datalog dialect speaks to the generality of these transformations.
note however that our public bug reports do not all show the applied transformations as we tried to localize issues as much as possible and aid developers in debugging our tool repository4contains instructions on how to reproduce all bug revealing transformations.
in addition to query bugs queryfuzz also detected several crash bugs as a by product they are shown in tab.
.
even though such bugs are less critical they expose robustness issues and developers were still interested in them.
in fact a developer of souffl said bug reports like this are definitely welcome especially because they might also point to other potential issues in our setup.
have already been super useful.
in general we found many more bugs in souffl in comparison to the other engines.
however this does not necessarily mean that souffl is more buggy.
a reason is that we tested it for a longer period of time see sect.
.
.
another reason is that the z3 developers currently have very limited bandwidth to devote to z as they are working on a new core smt engine we therefore decided against filing more bugs for the time being.
in addition ddlog is quite slow as it compiles every input program into a rust project this also slows down the testing process see rq5 .
rq2 significance of bug numbers.
to evaluate the significance of our bug finding results we compare the number of query bugs detected by queryfuzz to the total number of such bugs reported from may to feb .
for this research question we consider all three engines and we collect the total number of 50crash bugsquery bugs number of reported bugsqueryfuzz others figure all bugs reported in the three datalog engines from may to feb .
table categorization of souffl bugs into the components in which they were found.
souffl bug idscomponent astgen a e astopt b c d astram ramopt intsyn infra reported bugs from their github issue trackers.
we inspect issues since may because this is when we started testing souffl .
the results are shown in fig.
.
in the considered time period a total of query bugs were reported in the three datalog engines we tested and queryfuzz detected of them .
this ratio though very high is not surprising since query bugs are very hard to detect without an oracle.
in the same time period crash bugs were reported and queryfuzz detected of them as a by product.
rq3 bug depth.
to understand the depth of the detected bugs we analyzed all souffl bugs together with the engine developers.
in general they revealed issues across the stack.
the souffl engine essentially consists of the following components from front to back end astgen for parsing and abstractsyntax tree ast generation astopt for ast analysis and optimization astram for translation from ast to relationalalgebra machine ram ramopt for ram optimization and intsyn for interpretation or synthesis.
the interpreter evaluates its ram input whereas the synthesizer translates ram into c code which is then compiled and executed.
tab.
categorizes all souffl bugs into the engine component in which they were found ignore bugs a b c d and e for now.
note that no bugs were found in astgen and that we include a row infra referring to infrastructure bugs e.g.
in utilities that could affect the entire stack.
as shown in the table queryfuzz detected bugs in all components except astgen which is the most shallow.
we compare the depth of these bugs with that of bugs detected using of the shelf fuzzers and reported from may to feb .
there were such bugs of which were detected with radamsa and the other with afl .
one of the radamsa bugs5was not confirmed by the developers who labeled it as wontfix .
the other bugs are shown in tab.
as a b c d and e. they revealed issues in the astgen andastopt components of souffl which are at the top of the stack for instance bugs a and e crash the engine during or even before parsing.
the reason why 647esec fse august athens greece muhammad numair mansur maria christakis and valentin w stholz 1pqri v z v z nbj .
2pley o pqri x z o z x .
3nfuv q z fym pley q .
4out t nfuv ssz pley arv pley t .
figure generated program snippet for testing ddlog.
queryfuzz bugs are much deeper is that it generates valid datalog programs and its oracle driven transformations are more likely to reveal semantic issues.
note that we do not further compare our approach with other off the shelf fuzzers as they are not able to detect query bugs due to lack of oracles.
rq4 bug characteristics.
to demonstrate the nature of the detected bugs we now provide a few interesting bug samples.
bug was found in souffl s astopt component and specifically in the minimization pass that simplifies the program by removing equivalent rules and subgoals.
this pass missed a corner case for singleton relations i.e.
with arity .
the program and transformation that revealed this bug are discussed in sect.
see fig.
.
bug was detected in the same component but in its magic set transformation which aims to derive only those facts that are relevant for the program s datalog query.
our approach revealed this bug using a neg transformation.
the rule in which the negation was introduced depended on another rule containing a comparison operator which in turn caused a mislabeling of relations as positive.
naturally correct positive labeling is essential to the stratification process.
bug revealed another issue in the magic set transformation.
in general developers mentioned that implementing optimization passes on the ast is quite complex for a feature rich datalog dialect.
they also expressed the need for verifying the correctness of such passes as done by b gay et al.
.
according to developers bugs and reveal an important semantic issue in logic programming.
there is no clear execution order of instructions which may result in numerical stability issues in the presence of floating point numbers.
for these bugs to be fixed the developers would have to build symbolic machinery that dictates the order of optimizations and instructions such that numerical stability is maximized.
however this is an open research problem which is why these bugs were labeled as questions.
bug was detected in souffl s intsyn component at the very bottom of the stack.
according to the developers the problem lies in a data structure representation for relations namely brie which does not properly implement element insertion and count.
this bug existed at least since an old release of souffl of .
years ago .
a developer commented about this bug i don t know how it could have been missed until now but that s the first time i ve seen anyone point this out.
bug revealed a different issue with the same data structure in this case the computation of lower and upper bound values of its elements was incorrect.
bug was found in the astram component of souffl .
our transformation caused a silent internal failure in this component which manifested itself with an incorrect result.
a developer commented well spotted!
great work!
bug was detected in ddlog after randomly generating the program in fig.
and then adding two subgoals to rule pley pley o pqri x z o z x pqri z pqri x .the original program repeatedly computes cartesian products of the different relations and generates a non empty result.
however after the above transformation which should preserve the original result the new program generates an empty result.
this is because ddlog stores all intermediate relations as multi sets where the multiplicity of each element is the number of times it was derived.
currently multiplicities are stored as bit integers to reduce the memory footprint of the program and the above transformation caused an integer overflow manifesting itself as an empty result.
this bug was confirmed by the developers who are considering several solutions to the problem such as using bit integers to store multiplicities internally converting multi sets to sets using the distinct operator in rust or statically analyzing the program to estimate the number of derivations.
rq5 performance.
regarding the performance of queryfuzz it expectedly varies significantly depending on the tested datalog engine.
on average souffl requires .
seconds to run a test .
tests per second in interpreter mode and seconds in synthesizer mode ddlog needs .
minutes per test and z .
seconds tests per second .
on average the first stage of queryfuzz generates .
programs per second and the second stage performs transformations per second.
as shown from these numbers the performance bottleneck are the engines themselves.
.
threats to validity we identified two threats to the validity of our experiments.
selection of seeds.
our approach may use seeds as input and its effectiveness in bug finding could depend on their selection.
however we used non empty seeds only when testing souffl and we selected all of its semantically valid regression tests6.
our seed selection is therefore sufficiently broad to mitigate this threat.
moreover queryfuzz does not require non empty seeds as in their absence it generates random datalog programs see sect.
.
in fact of the detected bugs were found using non empty seeds.
selection of datalog engines.
the detected bugs also depend on our selection of datalog engines.
however we chose three mature engines which even support different dialects to mitigate this threat and demonstrate the generality of our approach.
related work in this paper we present the first testing approach for detecting query bugs in datalog engines.
it uses metamorphic testing to solve the common problem of finding a suitable oracle taking inspiration from query optimization in database theory.
of course query optimization has been studied in other domains as well such as in datalog or prolog e.g.
.
however optimization targets a goal different than ours that of finding an equivalent query that performs faster.
in contrast queryfuzz tests datalog engines by exploring a state space of queries that are not necessarily equivalent let alone more optimal.
in the following we focus on testing work from related areas such as database systems compilers and program analyzers.
metamorphic testing.
metamorphic testing is an effective technique to test software systems without user provided oracles.
6we selected all tests in the evaluation example and semantic folders under 648metamorphic testing of datalog engines esec fse august athens greece it works by mutating test cases via metamorphic relations that allow inferring the expected output of the mutated test cases.
over the years it has been used to test a variety of systems from web services over compilers to machine learning applications .
segura et al.
conducted a comprehensive survey on metamorphic testing in different domains.
testing database systems.
database management systems lie at the heart of most large scale software applications today.
ensuring their correctness and robustness is of critical importance and has been a focus of many researchers and practitioners for decades.
in slutz proposed a technique based on differential testing to detect bugs in database systems.
another approach also based on differential testing was used by jinho et al.
to detect performance bugs .
jepsen developed by kingsbury is a practical tool for detecting safety bugs in distributed database systems these can occur due to asynchronous interactions between components data loss due to networking issues node failures etc.
recently rigger and su proposed a series of testing techniques which they implemented in a tool called sqlancer.
their tool detected hundreds of bugs in various relational database systems.
fuzzing is also applied to detect crashes and other robustness issues in database systems.
for instance sqlsmith is a popular sql query generator that has detected hundreds of crashes in widely used database systems.
other query generation approaches include ones relying on constraint solvers symbolic execution and reverse query processing .
testing compilers.
compiler testing is another important and active research area .
le et al.
proposed a metamorphictesting technique known as equivalence modulo inputs emi which mutates a seed program to generate equivalent programs.
the technique and its extensions have detected hundreds of bugs in gcc and clang.
a related approach was also used to test graphics shader compilers .
livinskii et al.
recently developed a technique for generating expressive programs without undefined behavior to test c and c compilers .
the programs are then compiled using different compilers and their outputs are compared to detect bugs.
testing program analyzers.
work on detecting bugs in particular soundness bugs in implementations of program analysis techniques has received significant attention in recent years.
various different approaches have been proposed to test a wide range of analysis techniques such as model checking abstract interpretation symbolic execution or dataflow analysis as well as their underlying components such as abstract domains or constraint solvers .
conclusion we have presented the first approach for metamorphic testing of datalog engines.
our tool queryfuzz detected previously unknown query bugs in three different engines.
query bugs are critical since unlike crashes they typically remain undetected.
given that datalog is frequently used to formalize and implement security analyses or verification tools such bugs can be catastrophic.
as a result we received overwhelmingly positive reactions from engine developers about the bugs we reported several of which revealed deep sometimes even fundamental issues.