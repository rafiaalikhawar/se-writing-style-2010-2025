generating efficient solvers from constraint models shu lin peking university china fzlinshu pku.edu.cnna meng virginia tech usa nm8247 cs.vt.eduwenxin li peking university china lwx pku.edu.cn abstract combinatorial problems cps arise in many areas and people use constraint solvers to automatically solve these problems.
however the state of the art constraint solvers e.g.
gecode and chuffed have overly complicated software architectures they compute solutions inefficiently.
this paper presents a novel and model driven approach sogen to synthesize efficient problem specific solvers from constraint models.
namely when users model a cp with our domain specific language pdl short for problem description language sogen automatically analyzes various properties of the problem e.g.
search space value boundaries function monotonicity and overlapping subproblems synthesizes an efficient solver algorithm based on those properties and generates a c program as the problem solver.
sogen is unique because it can create solvers that resolve constraints via dynamic programming dp search.
for evaluation we compared the solvers generated by sogen with two state of the art constraint solvers gecode and chuffed.
sogen s solvers resolved constraints more efficiently they achieved up to 058x speedup over gecode and up to 300x speedup over chuffed.
additionally we experimented with both sogen and the state of the art solver generator dominion.
we found sogen to generate solvers faster and the produced solvers are more efficient.
ccs concepts theory of computation theory and algorithms for application domains software and its engineering domain specific languages automatic programming .
keywords combinatorial problems cp constraint solvers static analysis of problem properties automated dp optimization acm reference format shu lin na meng and wenxin li.
.
generating efficient solvers from constraint models.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
introduction combinatorial problems cps popularly exist in a variety of domains.
typical cps include register allocation how can we assign a large number of variables to a few registers?
winner determination in combinatorial auction given a set of bids in an auction what is the allocation of items to bidders that maximizes the auctioneer s revenue?
each cp involves finding a grouping ordering or assignment of a discrete and finite set of objects that satisfies given conditions.
constraint solving provides a means of solving cps automatically.
when using an existing constraint solver e.g.
gecode chuffed or minion to solve a problem users go through two stages.
first users adopt a domain specific language e.g.
minizinc tomodel the problem as a set of decision variables and a set of constraints on those variables.
here a decision variable represents a choice that must be made to solve the problem.
second a constraint solver is used to search for a solution to the model i.e.
value assignment to variables such that all constraints are satisfied.
a major limitation of existing generic solvers is the scalability issue.
namely current solvers cannot quickly solve certain cps even if the problem size is moderate i.e.
the problem has a decent number of variables and each variable has a reasonable value range .
for instance based on our experience although gecode can find the shortest path between two nodes in a given graph it cannot solve this problem within a reasonable amount of time e.g.
hours when the graph has or more nodes.
one reason to explain such deficiency is the inefficient backtracking search algorithm popularly used by solvers.
as problem size increases the search space can grow exponentially and the na ve search can become very slow and ineffective.
some researchers recently explored to use sat smt solvers to solve cp constraints .
however sat smt solvers only handle sat smt problems a subset of cps.
they cannot solve cps when objective functions are complex e.g.
composed of nonlinear functions .
additionally existing constraint solvers are usually provided as toolkits or software libraries .
to mitigate the scalability issue mentioned above users are supported to configure and tune the optimization options offered by solvers via programming or machine learning .
however constraint toolkits have become overly complex in an effort to support more functionalities such complexity negatively impacts the efficiency and scalability of solvers in two ways configuring or tuning existing solvers for large and realistic problems requires users of a great deal of expertise and demands lots of fine tuning effort by humans or machines.
esec fse august athens greece shu lin na meng and wenxin li the complex software architecture of these toolkits can introduce high overheads into the constraint solving procedure compromising any performance gain due to optimizations.
in this paper we introduce a novel approach sogen short for solvergenerator that generates efficient solvers from cp models to better address the scalability issue.
there are two components insogen a constraint modeling language pdl and a generation engine.
to solve a cp with sogen users need to first use pdl short for problem description language to model the problem from two or three aspects input parameters and their domains i.e.
value ranges decision variables and their relations with inputs and optionally an objective function for optimization.
when the pdl model mis sent to the generation engine the engine analyzesmto identify i the minimum value range of each variable ii any value dependency between variables and iii the independent variables with minimum search space.
such model analysis facilitates the engine to characterize four problem properties prop1 the search space that can be used to decide the search strategy of any synthesized algorithm prop2 value ranges of subfunction s to decide how to optimize synthesized algorithms via feasibility based branch pruning prop3 the monotonicity of objective function to determine how to prune branches based on the objective function in cp and prop4 overlapping subproblems that help decide whether a search algorithm can be optimized via dynamic programming dp .
by analyzing and using the above mentioned properties the engine generates an efficient problem solver implemented in c. we did two experiments to evaluate sogen .
the first experiment compared nine solvers generated by sogen with two state of theart solvers gecode and chuffed.
by applying alternative solvers to constraint solving tasks and setting time limit to minutes we observed sogen s solvers to find solutions for tasks while gecode and chuffed separately handled and tasks.
more importantly based on the property characteristics of individual problems sogen optimized six solver algorithms three algorithms automatically optimized via branch pruning and another three optimized by dp.
sogen s solvers achieved up to 058x speedup over gecode and up to 300x speedup over chuffed.
the second experiment compares sogen with another solver generator dominion .
in all experimented cases sogen s solvers worked more efficiently than the solvers created by dominion.
one ofsogen s solvers achieved up to 593x speedup.
in summary this paper makes the following contributions we developed sogen an approach that statically analyzes cps and synthesizes solvers accordingly.
different from prior work sogen does not require users to configure any parameter it can create problem specific dp search algorithms.
our novel analysis on cps statically extracts and characterizes four problem properties.
based on these properties of any given cp sogen shrinks the search space generates a solver algorithm and opportunistically optimizes the algorithm with branch pruning and dynamic programming.
we evaluated sogen by comparing it with another solver generator dominion and by comparing the problem specific solvers it generated with gecode and chuffed.
no prior work conducted such a comprehensive evaluation as we did.intmain best result nonoptimal value for v1 in range for v2 in range for ... if violateconstraint ... continue if findbettersolution ... update best result v1 v2 ... listing an algorithm skeleton for iteration based search intmain best result nonoptimal value rec voidrec inti if i of controlling variables if violateconstraint ... continue if findbettersolution ... update best result v1 v2 ... return for vi in range i rec i listing an algorithm skeleton for recursion based search in the following sections we will introduce the background knowledge of our research section present a running example section and describe the two components of sogen pdl section and the engine section .
our pdl manual program and data are available at background and terminology this section introduces cps section .
and two typical search strategies section .
involved in constraint solving.
.
combinatorial problems cp a typical cp searches for one solution in a finite data space.
formally a problem is cp if given a set of parameter variables a 1 m and their domains i.e.
value ranges a set of decision variables v 1 n and their domains and a set of constraints on those variables in aandv r r1 a v rl a v we are supposed to find a value assignment for 1 n such that all constraints rare satisfied.
combinatorial optimization problems cops are a subset of cps because in addition to the a v andrmentioned above each cop also defines an objective function f a v .
to solve a cop we need to find the optimal value assignment for vsuch that all constraints are satisfied and the value of the objective function is optimal.
.
two typical search strategies generally speaking a cp can be solved when a search algorithm enumerates all data points in a space either iteratively or recursively.
thus there are two alternative ways to implement a constraint solver iteration based search andrecursion based search .
as shown in listing iteration based search adopts one or more variables and their domains to control the number of loop iterations.
in each iteration the algorithm checks whether the current value assignment of variables satisfies all constraints and optionally leads to a better value of the objective function if so the algorithm updates its record to track a better solution.
the algorithm returns 957generating efficient solvers from constraint models esec fse august athens greece h l w v l w h figure a cuboid with the volume v input v of int in required l of int in w of int in h of int in v l w h objective minimize l w l h w h listing the pdl model for the cuboid problem one optimal solution after all iterations.
similarly recursion based search uses at least one variable and related domain s to control the number of recursive function calls see listing .
in each recursive function call the algorithm checks whether all variables have values assigned.
if so the algorithm checks if the value assignment satisfies all constraints and optionally gets a better objective function value.
we use controlling variables to refer to the variables that control loop iterations or recursive function calls.
the domains of these controlling variables define the search space.
when developing sogen to synthesize efficient cp solvers we tried to tackle two challenges c1.given a cp how can our approach decide which search strategy to adopt?
c2.once a search strategy is selected how does our approach decide which of the following two optimizations to apply pruning and dp?
sogen overcame both challenges by automatically characterizing properties for any given cp and making decisions accordingly.
a running example this section overviews our approach with an exemplar cop.
.
problem statement given an integer v find a cuboid with the smallest surface area such that the volume is vand the lengths of all edges e.g.
l w andhin figure are integers.
.
constraint modeling with pdl suppose that a user alex wants to build an automatic solver for the problem.
by analyzing the problem alex can identify one input parameter v three positive integer variables whose values will be computed l w andh and an objective function to minimize the surface area.
with pdl alex can create a constraint model for the problem.
as shown in listing the model includes three segments input required and objective .
the input segment defines the input parameter vand its domain .
the required segment declares decision variables i.e.
l w andh their domain i.e.
any positive integer and their value constraint with the input v l w h .
the objective segment defines the objective function.
.
algorithm synthesis given the constraint model in pdl the sogen engine automatically synthesizes a solver algorithm by taking four steps bound tightening independent variable set selection algorithm generation and algorithm optimization.
bound tightening.
to characterize the problem property prop1 sogen iteratively tightens variable domains with an off the shelf technique fbbt .
intuitively in the first iteration by converting the given formula to l v w h fbbt refines the domain of l asd l dl .
in the second iteration fbbt similarly refines the domain ofwby usingl s updated domain.
this process continues until the domain of each variable is fixed as .
independent variable set selection.
given a set of variables not every variable should be used as a controlling variable in the synthesized search algorithm.
this is because when variables have mathematical relations with each other the values of some variables can uniquely determine the values of other variables.
to further refine prop1 and to focus search on only feasible or promising value assignments we defined three terms definition .
value dependencies given formulas or equations e.g.
rj a v if the value of certain variable viis uniquely determined by the value assignment of other variables we say that vi has value dependencies on others.
definition .
independent variable set this is a subset ofv.
the values of variables in this subset can uniquely determine the values of other variables in v. definition .
dependent variable set this is the complementary set of an independent variable set in v. all variables in this subset have value dependencies on the independent variables.
in this example l w andhare interdependent.
namely given the value assignment of any two variables the third variable is computable.
therefore l w can be considered as an independent variable set.
this step chooses the independent variable set with algorithm the optimized iteration based solver algorithm created by sogen for the cuboid problem input v input parameter v output best result l w h the values of objective function and variables .1best result max value .
enumerate values of controlling variables .2foreachl do .
ifvmodl 0then .
continue .
foreachw do .
check constraints on variable values .
ifv lmodwthen .
continue .
calculate values of dependent variables .
h v l w .
calculate the value of objective function .
result l w l h w h .
update record if a better solution is found .
ifresult best result then .
continue .
best result result .
record l w h 958esec fse august athens greece shu lin na meng and wenxin li minimum domains as the controlling variables in an algorithm todesign.
in this way sogen refines its characterization for prop1.
algorithm generation.
this step relies on prop1 characteristics to synthesize a basic search algorithm.
if there are only a few controlling variables and no variable is of any composite data type e.g.
set this step creates an iteration based search algorithm otherwise it synthesizes a recursion based algorithm in order to make the generated code more compact and readable.
for this example since there are only two primitive typed variables i.e.
landw an iteration based algorithm with the two level nested loop structure can solve the problem.
in particular inside the inner loop the constraint related if condition is v l w h .
algorithm optimization.
this step characterizes and uses properties prop2 prop4 to opportunistically optimize the basic algorithm.
specifically sogen tentatively decomposes each constraint objective function into smaller subfunctions.
among all valid solutions e.g.
the value assignments that can satisfy all constraints if the potential values of any constraint subfunction are bounded by the tightened variable domains prop2 is characterized accordingly.
if the objective function monotonically increases or decreases prop3 is consider satisfied.
if prop2 is characterized prop3 is satisfied and the search space of a potential dp algorithm estimated by prop2 is much smaller than that of the basic algorithm prop4 is considered satisfied.
sogen applies branch pruning if prop2 tightens the value ranges of subfunctions or prop3 holds.
sogen applies dp if prop4 holds.
in our example the constraint formula v l w h can be decomposed to two subfunctions v landv l w .
among all valid solutions the potential values of these subfunctions are actually bounded by variable domains e.g.
because v l w h values of v l should be positive integers .
thus sogen characterizes prop2 and applies branch pruning to avoid enumerating invalid solutions.
the synthesized algorithm by sogen is illustrated in algorithm .
.
code generation based on the synthesized algorithm sogen produces a constraint solver implemented in c. the solver program implements not only the algorithm but also two utility functions input to read values of input parameters from console and output to write the optimal value of objective function and variable values to console.
with a solver generated for the cuboid problem alex can enter any vvalue to instantiate the cop.
then the solver responds with the minimum surface area and related values of l w andh.
pdl pdl is a constraint modeling language for users to describe cps.
as illustrated in listing a pdl model consists of three segments input required and objective .
input segment input declares all input parameters and their domains.
these inputs will be declared as formal arguments by a generated program.
this segment can have zero or more input parameter declaration.
a parameter can be declared with any primitive type e.g.
int or composite type e.g.
list .
required segment required declares decision variables their domains and their relations with inputs i.e.
data constraints .
a required segment has zero or more statement.
a statement can be a variable declaration expression statement or forall enumeration.table built in operators and functions in pdl category symbols relational operators !
logical operators and or not xor arithmetic operators mod exponent operators aggregation functions min max summation product each expression statement has an expression to describe data constraints as mathematical formulas.
the forall enumeration is a higher order function which applies a given function to all elements in a composite data structure.
pdl supports common data types including primary types i.e.
int real char and bool and composite types i.e.
array set and struct .
pdl supports various expression formats such as a parenthesized expression an atomic expression e.g.
a variable a a unary expression e.g.
not a a binary expression e.g.
a b an aggregate result of forall enumeration e.g.
summation forall i in a quantifier function to check whether there exist certain value s to meet certain conditions e.g.
exists a a in and a conditional expression e.g.
if a b else b .
pdl also defines built in operators and functions see table .
objective segment objective declares zero or one objective function.
if no objective function is defined the resulting program stops search after finding asolution otherwise it searches for an optimum that acquires the best objective value among all solutions.
pdl has a similar type system to c and shares type inference rules.
however pdl supports fewer data types including int real char bool array set and struct.
to learn more about pdl please refer to our pdl manual on github.
the sogen engine as shown in figure there are five major steps in sogen s generation engine.
steps automate algorithm synthesis and step automates algorithm implementation.
sections .
.
explain each step in detail.
.
bound tightening given a pdl model sogen tokenizes the model and conducts both syntax and semantic analysis to build an identifier table i.e.
a table to record parameters variables and their domains constraint formulas and any objective function.
specifically we built a pdl compiler frontend with javacc and java tree builder jtb .
javacc is a scanner and parser generator for ll k grammars.
it takes in the token patterns defined with regular expressions to generate a lexical analyzer i.e.
scanner it also generates a parser from the given syntax grammar defined in ebnf.
we used the generated scanner and parser to create a parsing tree for any given pdl model.
additionally we used jtb to implement a tree visitor for semantic analysis.
with the visitor sogen traverses each parsing tree to extract all constraints and any objective formula and to create an identifier table.
959generating efficient solvers from constraint models esec fse august athens greece pdl model .
independent variable selection .
bound tightening problem solver .
algorithm optimization .
code generation algorithm synthesis algorithm implementation .
algorithm generation figure the sogen engine takes five steps to generate a solver from the given pdl model table identifier table for the cuboid problem identifier parameter variable type range v parameter int in l variable int in w variable int in h variable int in required a of int in b of int in c of int in d of int in c a b d b c listing an exemplar required segment similar to the symbol table produced by a traditional compiler our identifier table records both the names and types of parameters and variables.
however different from symbol tables identifier tables also record whether an identifier is a parameter or variable and the value range of an identifier see an exemplar identifier table in table .
these value ranges are computed with an offthe shelf range reduction technique fbbt .
intuitively given a b c a b c fbbt first converts the formula to b a c and then refines the domain for bas d b db .
by reducing the specified value ranges of variables using fbbt sogen intends to shrink the search space and characterize prop1.
.
independent variable selection this step identifies controlling variables variables used to control the number of iterations or recursions in search algorithms.
specifically according to the identifier table and related constraint formulas sogen reveals dependencies between variables and recognizes all alternative sets of independent variables.
it selects the minimum set with minimum value ranges as controlling variables for two purposes.
first controlling variables define the search space of the algorithm to design.
the fewer controlling variables there are and the smaller value ranges they have the smaller search space needs to be explored.
second sogen relies on these variables to choose the search strategy i.e.
either iteration based or recursion based .
value dependency identification.
we explain this process with a concrete example.
listing shows an exemplar required section which declares four variables i.e.
a b c andd and defines two constraints.
according to the first constraint chas value dependencies onaandb becauseccan be computed based on the values of those variables.
formally we represent this dependency as c a b similarly we can identify another dependency relationship by converting the formula to a c b2 a b c however bis not dependent on aorc.
this is because given values ofaandc we cannot determine a single value for bbased on theconverted formula b c a. according to the second constraint we can similarly identify the following value dependency d b c variable subset enumeration.
with all dependencies identified sogen sorts all variables in an ascending order of their value ranges.
it then enumerates all possible variable subsets in a depthfirst manner to find the minimum independent variable set with the minimum search space.
for the example in listing the sorted list is .
thus the enumeration procedure first includes ainto a candidate set i1.
asaalone cannot uniquely determine the value of any other variable the procedure continues to include binto the set obtaining i1 a b .
based on relations and the procedure concludes that all remaining variables are dependent oni1 soi1is an independent variable set.
the search space defined byi1is the cartesian production of all included variables value ranges whose size is s1 range a range b .
in the next round of subset exploration the procedure tentatively includes binto a new candidate set i2.
since no variable solely depends on b we can further add cintoi2to build another independent variable set.
correspondingly the search space size is s2 range b range c .
sinces2 s1 we consideri1to be better thani2.
our search continues until every subset is enumerated.
we use the variables in the optimal independent variable set as controlling variables which characterize prop1.
.
automatic algorithm generation this step relies on prop1 to decide whether an iterative or recursive algorithm should be created.
generation of iteration based algorithms.
if prop1 corresponds to a few controlling variables e.g.
and all variables have primitive types e.g.
bool sogen creates an iterative algorithm based on the skeleton shown in listing .
this is because compared with recursion based algorithms iteration based algorithms have higher efficiency.
please refer to algorithm for an exemplar iterative algorithm produced by sogen .
generation of recursion based algorithms.
if prop1 corresponds to a large number of controlling variables e.g.
or any of the variable has a composite data type e.g.
list sogen chooses to create a recursive algorithm based on the skeleton in listing .
sogen s decision making is based on four rationales.
first any composite data type can be treated as a set of independent controlling variables.
second when there are many controlling variables recursion based algorithms are more compact and readable.
compactness ensures software reusability and maintainability.
readability facilitates experts to further optimize generated solvers as needed.
third recursion based algorithms can effectively solve cps that have more controlling variables.
iteration is limited by the maximum depth of nested loops e.g.
for c while the recursion depth can be much larger e.g.
some thousands .
fourth the extra runtime overhead of recursive function calls over loop iterations is negligible compared with the overall solving time.
960esec fse august athens greece shu lin na meng and wenxin li natural language pdl model there arenitems.
there is a knapsack of capacity c. theithitem i n has valueviand weightwi.
put a set of items s nin the knapsack such that the sum of weights is at mostc.
the sum of values should be maximal.
input n of int in c of int in w of int in v of int in required sel of int in summation forall i i in sel c objective maximize summation forall i i in sel figure the description of the knapsack problem in natural language vs. in pdl algorithm the main function in the recursionbased algorithm for the knapsack problem input n c w v input parameters output best result sel the values of objective function and variable .1best result .2wsum vsum two local variables used to accumulate the weights and values of selected items .3rec wsum vsum n c w v algorithm the rec ... function invoked by the main function mentioned in algorithm input step wsum vsum n c w v stepimplies which controlling variable has values enumerated output .
check whether all controlling variables have values assigned already .1ifstep nthen .
check constraints .
ifwsum cthen .
continue .
update record if a better solution is found .
ifvsum best result then .
continue .6best result vsum .
record sel .
return .
explore all possible values for the controlling variable sel .9foreach sel do .
evaluate the objective function based on the variable values assigned so far .
rec step wsum w sel vsum v sel n c w v figure shows the natural language description and pdl model of another exemplar cp the knapsack problem.
in the constraint model the only decision variable selis a set that holds the indexes of items put into a knapsack.
to generate a solver algorithm for this problem sogen first converts selto an n length boolean array sel where sel indicates whether the number iis in the set.
next sogen creates a recursion based algorithm based on inputs sel the constraint and the objective see algorithms and .
.
automatic algorithm optimization sogen characterizes prop2 prop4 and optimizes any synthesized algorithms based on those properties.
this section first clarifies notations section .
.
and describes the property characterization process section .
.
next it introduces sogen s decision making to optimize algorithms based on properties section .
.
.
.
.
notations.
to simplify explanation suppose that the pdl model hasmconstraints.
a solver algorithm has ncontrolling variables.
at step i i.e.
theithloop structure or ithrecursion there areivariables with value assignment and n i variables without value assignment we denote these two sets of variables separately as ai v1 v2 ... vi andui vi vi ... vn .
for any cop in the search procedure we denote the suboptimal value of objective function obtained so far i.e.
intermediate optimal value asbest result .
.
.
property characterization.
to characterize prop2 value range of subfunctions sogen tentatively converts each constraint to subfunctionspandqmatching the following formats p ai cmpq ui wherepandqderive from the original constraint and cmp represents any comparison operator e.g.
and used in the constraint.
suppose that the value ranges of aianduiseparately define value ranges for pandqfunctions as r1andr2.
givencmp andr2 sogen checks whether there is any value in r1that can never satisfy the converted mathematic relationship if so sogen discards those values and characterizes prop2 to refine p s value range.
sogen later uses such refined ranges to prune search branches see section .
.
.
for our running example when v l w h sogen can generate two converted formulas v l w h v l w h because the potential value range of w hin formula is positive integers sogen infers thatv lshould be an integer.
similarly as the domain of hin formula is positive integers sogen infers v l wto be an integer.
prop2 captures all such derived value constraints for pfunctions e.g.
v modl v lmodw .
to characterize prop3 the monotonicity property of objective function sogen decides whether the objective function monotonically increases or decreases with all nvariables by checking the coefficients of each variable.
if the coefficients are all positive or negative values prop3 holds and sogen later prunes search branches accordingly see section .
.
.
for the knapsack problem in figure the objective function is obj n j 1v sel wherev .
as the coefficients of sel i.e.
v are all positive prop3 holds.
sogen checks prop4 overlapping subproblems only if prop2 bounds every constraint subfunction involving any controlling variable and prop3 holds if prop4 holds sogen later converts the synthesized algorithm to a dynamic programming dp algorithm for optimization see section .
.
.
specifically sogen relies on prop2 to estimate the search space s1of a potential dp algorithm it also uses the value range of controlling variables to estimate the search space s2of a brute force search algorithm.
if the size of s2is 961generating efficient solvers from constraint models esec fse august athens greece algorithm the rec ... function produced by sogen when it applies branch pruning input step wsum vsum n c w v stepimplies which controlling variable has values enumerated output check whether all controlling variables have values assigned already .1ifstep nthen update related record if a better solution is found .
ifvsum best result then .
continue .4best result vsum .
record sel .
return explore all possible values for the controlling variable sel .7foreach sel do evaluate the objective function based on the variable values assigned so far .8wsum wsum w sel .9vsum vsum v sel fbp check constraint violation based on wsum .
ifwsum cthen .
continue obp assess the potential upper bound value of objective function based on the value sum so far .
ifvsum n step best result then .
continue .
rec step wsum vsum n c w v much larger than that of s1 i.e.
s2 s1 sogen concludes that there are overlaps between subproblems of the objective function and prop4 holds.
for the knapsack problem prop3 is true prop i j 1w sel c s1 n c s2 2n.
means there exist positive constants c1andc2 c1 c2 such that c1 n c s1 c2 n c. as s2 s1 prop4 holds.
.
.
optimization application.
sogen is capable of applying two types of algorithm optimizations branch pruning and dp.
branch pruning adds restructures or moves if branches to reduce the number of explicitly enumerated values.
there are two types of pruning sogen automates feasibility based pruning fbp based on the value assignment of some instead of all controlling variables this optimization makes early decisions on constraint violation.
if any constraint is definitely violated even if some involved variables have values unassigned the search tree is pruned.
objective based pruning obp this optimization is applied to cops.
given the value assignment of some instead of all controlling variables obp predicts the potential values of objective function when all variables have values assigned.
if the predicted values are unpromising e.g.
worse than the intermediate best result the search tree is pruned.
dynamic programming dp breaks a given cop into simpler subproblems.
it first solves subproblems and caches optimal solutions in a table for reuse.
then it solves the overall problem based on optimal solutions to subproblems.
decision making for feasibility based pruning fbp .
when prop2 is not empty sogen replaces all if condition checks on original constraints with those on derived subfunctions in prop2.
whenany subfunction only involves a subset of controlling variables sogen further moves the related if condition from the innermost loop or recursion to some outer loop or recursion such that unpromising search subtrees are pruned as early as possible.
please refer to algorithm for an exemplar fbp applied by sogen .
decision making for objective based pruning obp .
when prop3 holds sogen inserts an if condition check that compares the partial evaluation result of objective function based on ai the intermediate optimum best result andui.
if no matter how variables inuiget values assigned the existing partial evaluation result is unpromising to lead to a better objective value than best result then sogen uses the inserted check to prune branches.
algorithm shows an exemplar obp sogen applied.
decision making for dp.
when prop4 holds sogen restructures the synthesized recursion based algorithm to have two parts table creation and table access.
for table creation sogen initializes a table of m dimensions.
among these dimensions the first one has values within and corresponds to the nsteps of function recursion.
the other mdimensions correspond to the derived subfunctions in prop2.
each table cell caches an optimal subproblem solution.
for table accesses sogen defines two ifstructures in the algorithm.
one structure checks whether a given subproblem is already solved and looks up the table if so.
the other structure puts the result of a newly solved subproblem to table if the result is better than the value on record.
please refer to algorithm for the dp algorithm sogen generated for knapsack problem.
algorithm the rec ... function optimized by sogen when it applies dp and branch pruning input step wsum vsum n c w v step implies which controlling variable has values enumerated output reuse the result if the subproblem has been solved before .1ifdp sel null then .2vsum vsum dp sel .3step n .
copy sel from the recorded subproblem solution .5ifstep nthen .6result vsum .
ifwsum cthen .
return .
ifresult best result then .
best result result .
record sel .
returnvsum .
foreach sel do .14wsum wsum w sel .15vsum vsum v sel .
ifwsum cthen .
continue .
ifvsum n step best result then .
continue .20tmp rec step wsum vsum n c w v vsum if the result is better than the recorded subproblem solution use it to update the record .
iftmp dp sel then .
dp sel tmp return the optimal value of objective function .
returnvsum dp sel the rationale of sogen s decision making for dp is as below.
dp can optimize search when a problem has two properties optimal 962esec fse august athens greece shu lin na meng and wenxin li substructures andoverlapping subproblems .
optimal substructures mean that an optimal solution can be constructed with the optimal solutions to its subproblems this property corresponds to prop3.
overlapping subproblems indicate that a na ve search algorithm repetitively solves some subproblems this property is actually prop4.
as sogen checks prop4 only if prop2 is not empty and prop3 is true it applies dp based on the fact that both prop3 and prop4 are satisfied.
in this way sogen ensures that its generated dp algorithms can improve solver efficiency.
.
code generation to generate code for each synthesized algorithm sogen has six predefined code templates input ... reads parameters from the console.
output ... prints the optimal value of objective function and related variable values.
update ... compares a new solution result with best result and updates recorded values if result is better.
find ... implements the recursive function for recursionbased search algorithms.
solve ... enumerates values of controlling variables checks constraint formulas evaluates the objective function and updates records.
it calls find ... optional and update ... .
main integrates all functions into a program.
we designed sogen to implement algorithms in c because the language is simple and efficient.
however our methodology is not limited to c and can be implemented to generate code in other languages as well.
evaluation to assess the usefulness of sogen we conducted two experiments and explored two research questions rqs rq1 how do the solvers generated by sogen compare with state of the art cp solvers?
rq2 how does sogen compare with the state of the art solver generator?
.
empirical comparison with cp solvers this section first introduces our dataset and experiment settings and then discusses our results.
.
.
dataset.
we created a dataset based on nine classical and representative cps from undergraduate programming courses and csplib a program library for constraints.
the problems are different in terms of constraints objective functions variables sizes of the search spaces and possible solver optimization techniques.
therefore the included problems are diverse they represent a much larger set of cps.
as shown in table depending on the problem the complexity of a na ve backtracking algorithm can be o nc o cn oro n!
.
herenis a parameter mentioned in the original problem description.
complexity reflects the space size of each backtracking search.
as the search space grows with n we defined five constraint solving tasks instances for each problem by setting nto distinct values if the complexity is polynomial i.e.
o nc we setnto and 107because current solvers usually solve the problems efficiently.
model model processing search enginespropagators branchers variable modulesgecode kernelsolutionvariables constraintsgecode architecture instancefigure the architecture of gecode if the complexity is exponential i.e.
o cn we setnto smaller numbers and .
this is because when nis too large existing solvers do not respond in a timely manner.
if the complexity is factorial i.e.
o n!
we setnto even smaller numbers and .
this is because current solvers can only solve these problems when nis small.
p7 is an outlier.
although the theoretical complexity is o n!
p7 is a constraint satisfaction problem that only requires for one feasible solution.
therefore p7 can be effectively solved by current solvers in practice and we setnto and .
with the above mentioned method we created tasks.
.
.
experiment settings.
we compared the solvers generated bysogen with generic solvers gecode and chuffed by applying them to our dataset.
we did not experiment with any smt solver because smt solvers only handle smt problems a subset of cps which are decision problems for logical formulas with respect to combinations of background theories expressed in first order logic with equality.
the state of the art smt solver z3 cannot solve cps when objective functions are non linear.
gecode and chuffed are two state of the art generic constraint solvers widely used by people to solve cps.
both gecode and chuffed have complex architectures.
chuffed adapts techniques from sat solving such as conflict clause learning to speed up constraint solving .
as shown in figure gecode has multiple components.
in particular the search engines component supports alternative search strategies while propagators andbranchers offer a variety of configurable optimizations .
to solve cps with these solvers we used minizinc a high level and solver independent constraint modeling language to describe each cp task by specifying input parameters a set of decision variables constraint formulas and optionally the objective function.
then we used a standard third party tool mzn2fzn to convert minizinc models to flatzinc models as flatzinc is a low level and solver dependent modeling language acceptable by gecode and chuffed.
solvers by sogen were generated from pdl models.
we used pdl to describe the nine problems in table and used sogen to generate nine solvers accordingly.
among these solvers sogen optimized three solvers via branch pruning i.e.
solvers for p4 p7 and p8 it optimized another three solvers via both pruning and dp i.e.
solvers for p5 p6 and p9 .
in our experiment we applied each solver to the five constraint solving tasks mentioned in table .
procedure.
we conducted the experiment on a computer that has an intel core i5 7300hq .5ghz cpu and 8g ram.
we applied three solvers to each task one solver generated by sogen gecode and chuffed.
for fair comparison we used the default settings of all experimented tools and modeled the problems with pdl minizinc in semantically equivalent ways.
to ensure the representativeness of our results we applied each solver to every task three times.
we recorded solvers runtime and memory costs and averaged the 963generating efficient solvers from constraint models esec fse august athens greece table the nine problems and related constraint solving tasks used in the first experiment id problem summarycomplexityconstraint solving tasks p1 greatest common divisor find the greatest common divisor of given npositive integers.
o n n p2cake baking there are two types of cakes.
given both the ingredients and profit of each cake and the total amounts of ingredients available suppose that at most ncakes of each type can be made.
how many cakes of each type should a baker make to maximize the profit?o n2 n p3cuboid problem givenvandn find a cuboid with the smallest surface area such that the volume is vand the lengths of all edges are integers and not exceeding n.o n2 n p4 map coloring color thennodes of a graph with four colors so that no two adjacent nodes have the same color.
o 4n n p5 knapsack problem see figure o 2n n p6teamwork given the cooperation value and working value of each candidate select a subset among ncandidates such that the total cooperation value is positive and the total working value is maximum.o 2n n p7 n queens putnqueens on an n nchess board so that no queen can attack others.
o n!
n p8 traveling salesman problem find the shortest hamiltonian cycle in a graph of nnodes.
o n!
n p9 shortest path find the shortest path from node to node nin a given graph.
o n!
n table the time and memory costs of each solver on constraint solving tasks time cost second memory cost mb id sogen gecode chuffed sogen gecode chuffed p1 p2 p3 n a p4 n a n a n a p5 n a n a p6 p7 p8 n a n a p9 n a n a means that the memory cost cannot be calculated because some constraint solving processes were interrupted due to timeout.
values among all three runs.
due to the time limit if a solver did not respond within minutes we terminated the execution.
.
.
results.
table presents our results.
due to the space limit each row shows results for five tasks related to the same problem.
among the five tasks since the time costs of solvers change more significantly than memory costs for each solver this table shows all measured values of time costs and value ranges of memory costs.
according to the table all solvers have relatively low memory costs but their time costs vary a lot.
it implies that cpu instead of memory is the performance bottleneck.
this is expected because constraint solving is computationally intensive all solvers focus their efforts on the enumeration of variable values and the evaluation of constraint formulas as well as objective functions.
compared with gecode and chuffed sogen s solvers successfully handled more tasks and often used less time and memory.
specifically the solvers by sogen fulfilled tasks and triggered timeouts for only p4.
meanwhile gecode handled tasks and obtained timeouts when solving p4 p5 and p8 chuffed handled only tasks and acquired timeouts when dealing with p3 p4 p5 p8 and p9.
among the tasks commonly solved by distinct solvers on average sogen s solvers achieved 401x speedup over gecode and 167x speedup over chuffed their average memory costs are of gecode s and of chuffed s. in particular compared with gecode sogen s p5 solver achieved the highest speedup 058x whenn .
in comparison with chuffed sogen s p9 solver obtained the highest speedup 300x when n .
two reasons can explain the better performance of sogen s solvers.
first sogen s solvers are small c code they have no software infrastructure to consume additional resources.
second sogen s property characterization enables it to minimize the search space select the best search strategy and apply optimizations as needed.
by minimizingsearch space sogen could select the the most efficient search strategy and avoid fruitless value enumeration thus it outperformed gecode and chuffed when solving p1 p3 tasks even though no optimization was applied.
when solving p5 p9 sogen s solvers worked better because they optimized search based on properties.
when solving p4 the efficiency comparison is chuffed gecode sogen .
as mentioned earlier each cp corresponds to multiple solving tasks i.e.
problem instances .
for p4 a solving task is determined by an n value i.e.
and a map while the map concretizes constraints between specific controlling variables i.e.
adjacent nodes have distinct colors .
such constraints are specific to individual tasks they are not statically inferable from the pdl model of p4.
they are not leveraged by sogen for optimization either assogen applies problem specific optimizations based on static analysis of problem properties.
meanwhile gecode and chuffed apply task specific optimizations e.g.
variable reordering based on dynamic analysis of the solving procedure for individual tasks.
finding sogen s solvers worked better than gecode and chuffed by handling more tasks given limited time.
sogen s solvers accelerated the solving process by up to orders of magnitude.
.
empirical comparison with dominion dominion is the state of the art solver generator it is based on the generic solver minion .
given a problem described in dominion input language dil dominion takes four steps it selects potentially relevant components e.g.
optimizers and search strategies from minion s component library it randomly creates a solver to include some selected components it mutates the solver by adding removing one component at a time tests each mutant with constraint solving tasks and adjusts mutation 964esec fse august athens greece shu lin na meng and wenxin li table the solver generation time by sogen and dominion second id solver generation by sogensolver generation by dominion sum q1 .
.
.
.
.
.
.
.
.
.
.
.
q2 .
.
.
.
.
.
.
.
.
.
.
.
q3 .
.
.
.
.
.
.
.
.
.
.
.
table the constraint solving time for each task t1 t15 by sogen s solvers and dominion s fastest solvers second t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 solvers by sogen .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
the best solvers by dominion .
.
.
.
.
.
.
.
.
.
.
.
accordingly until finding a best solver it repeats and for times and creates solvers.
.
.
dataset.
to understand how sogen compares with dominion we did a comparative experiment by applying both tools to the same dataset.
due to the difficulty of dil usage we were unable to use dil to describe all nine problems mentioned in the dataset shown in section .
.
.
therefore we created a second dataset by referring to the problems mentioned in the dominion paper .
among the six problems discussed in that paper we managed to express three problems in dil.
as a result our new dataset includes constraint solving tasks related to cps q1.n queens see p7 in table .
q2.golomb a golomb ruler is defined as a set of n integers a1 a2 ... ansuch that the n n 2differences i.e.
aj ai i j n are distinct.
find a ruler with the minimum length.
q3.non monochromatic rectangles colorn ngrids with a fixed number of colors i.e.
c such that there is no rectangle with all four corners to have the same color.
the complexities of q2 and q3 are separately o n2n and o cn2 higher than those mentioned in table .
thus we set n to very small numbers when defining tasks and .
.
.
experiment settings.
we compared sogen with dominion in two aspects the speed of solver generation and the efficiency of generated solvers.
procedure.
we modeled each cp with both pdl and dil in semantically equivalent ways and fed those models separately tosogen and dominion using the default settings.
for each cp sogen generated a single solver while dominion created solvers.
by applying each solver to every task three times we recorded the solvers costs and averaged the values among three runs.
.
.
results.
as shown in table sogen generated solvers more efficiently than dominion.
specifically sogen produced a single solver for each cp and the generation time is negligible i.e.
.
second .
meanwhile dominion generated solvers for each cp.
the generation time varies from .
to .
seconds with the average as .
seconds per solver.
the overall solver generation time by dominion for each cp is .
.
seconds as the solvers created for each cp were optimized differently some solvers resolved constraints faster than the others.
to compare the quality of generated solvers we applied sogen s solvers and dominion s fastest solvers to the tasks in our dataset.
namely each task was resolved by two separate solvers and we recorded the incurred time memory costs.
as shown in table sogen s solvers fulfilled all tasks while dominion s solvers onlyresolved tasks.
among these tasks sogen s solvers worked more efficiently and obtained 4x 593x speedup over dominion s solvers.
we also compared the memory costs.
among the tasks successfully resolved by both types of solvers sogen s solvers used only of the memory space used by dominion s. three reasons can explain sogen s higher effectiveness and efficiency.
first sogen synthesized solver programs from scratch instead of tailoring existing solver architectures so its solvers incurred no runtime overhead for complex software infrastructures or poorly configured optimizations.
second sogen generates efficient solvers based on rigorous static reasoning of problem properties while dominion explores and validates each solver based on random search and dynamic solver execution.
third sogen can synthesize dp search algorithms and dominion cannot do that.
therefore our approach is more rigorous and efficient.
finding sogen outperformed dominion by generating solvers with lower runtime overheads its solvers also resolved more constraints by using less time and memory.
discussion pdl vs. existing domain specific languages.
pdl is similar to existing constraint modeling languages e.g.
minizinc and dil as it also supports users to describe inputs decision variables constraints and optionally the optimization objective.
however we chose to define pdl instead of reusing existing languages because we need users to also specify the domains of all inputs and decision variables.
such domain information is mandatory by sogen since sogen relies on the info to reason about problem properties and to use those properties for algorithm synthesis and optimization.
meanwhile the domain information is optional in other languages it is used by existing constraint solvers only for input validation.
none of existing solvers characterizes prop1 prop4 or synthesizes dp search algorithms as sogen does.
the novelty of sogen .as a solver generator sogen takes in cp models and outputs problem specific optimized constraint solvers.
on the other hand existing constraint solvers e.g.
gecode and chuffed take in cp models and output solutions to the described constraint solving tasks.
sogen is unique in three aspects it statically reasons about four problem properties the search space value ranges of subfunctions the monotonicity of objective functions and overlapping subproblems.
based on problem properties sogen automates the decisionmaking process to adopt two optimization strategies branch pruning and dynamic programming.
965generating efficient solvers from constraint models esec fse august athens greece it automatically designs and implements dynamic programming algorithms.
sogen s good performance is due to the novel approach design of unique property reasoning and problem specific c solver generation.
we did not propose any new optimization technique.
instead sogen characterizes cps from different angles and automatically applies existing optimization techniques as needed to achieve high problem solving efficiency.
due to the space and time limit we did not measure the impact of different optimization strategies.
we will analyze that in the future.
the correctness of cp models.
we carefully did constraint modeling for all experimented cps using minizinc for gecode and chuffed pdl for sogen and dil for dominion in order to define correct models.
as gecode and chuffed take in flatzinc instead of minizinc directly we used a standard third party tool mzn2fzn to translate models from minizinc to flatzinc and to ensure the translation correctness.
as all experimented tools support declarative programming we modeled every problem with different languages in semantically equivalent ways and opensourced all models at github.
we observed correct results by all solvers which indicate the correctness of problem specifications.
threats to validity threats to external validity.
all the findings and observations mentioned in this paper are based on our evaluation datasets.
we believe our results to generalize well to unexplored cps for two reasons.
first the experimented cps are from undergraduate programming courses and csplib so they are popularly used and representative.
second the two optimization techniques automated are pruning and dp which have been widely applied for search optimization.
thus sogen is likely to considerably accelerate the solving process for unexplored cps.
in the future we plan to experiment with more cps so as to explore the generalizability of our observations.
threats to construct validity although we had no difficulty writing models with minizinc and pdl dil seems quite different from other modeling languages and its documentation is not quite helpful.
consequently we created a dataset by reading the dominion paper and modeling three cps mentioned there with our best effort.
because neither source code nor data of the dominion paper is publicly available and dominion works nondeterministically we do not guarantee that the solvers used in our evaluation are the best solvers that dominion can generate.
related work the related work of this research includes optimizers of constraint solving and solver generators.
optimizers of constraint solving.
to overcome the scalability issue of constraint solving researchers proposed a variety of methods to optimize the solving process .
for instance caching memoizes search states to prevent the same state from being recomputed.
subproblem dominance reasons about the dominance relationship between states to reduce unnecessary state exploration.
lazy clause generation lcg analyzes failures at backtracking points and derives new constraints i.e.
nogoods to reduce the search space.
given a minizinc model dpsolver analyzes the model and checks whether the described problem hastwo properties optimal substructures and overlapping subproblems.
if so dpsolver refactors the minizinc model such that gecode solves the problem in a dp manner.
sogen is similar to existing optimizers by automating both property characterization for cps and decision making for optimizations.
however sogen focuses on a unique set of properties and conducts novel property reasoning.
instead of adding optimizers to existing solvers sogen creates solvers from cp models to eliminate the high overheads incurred by complex software architectures and to synthesize efficient solvers that perform dp search.
solver generators.
generic constraint solvers are usually provided as configurable toolbox systems.
by manually configuring the system provided search strategies and optimizers users can tailor a generic solver for any cp.
because manual configuration is challenging and time consuming for users prior work proposed solver generators to automate configuration tuning.
for example given a problem specification and several training instances i.e.
constraint solving tasks multi tac adopts the backtracking schema to search for an optimized configuration among candidates and evaluates each configuration based on those instances.
some approaches exploit machine learning to tune the parameters or select the solvers in an algorithm portfolio i.e.
alternative algorithms usable to solve the same problem .
although existing techniques customize generic solvers for given problems to accelerate constraint solving they cannot fully bypass the extra runtime or memory overheads introduced by the complex infrastructure of toolbox systems.
meanwhile the time consuming tuning procedure can be ineffective and inaccurate making the generated solvers inefficient.
in comparison sogen synthesizes solver algorithms from scratch produces efficient and correct solvers in c and thus incurs no infrastructure related costs.
conclusion existing constraint solvers cannot efficiently solve cps.
this paper presents sogen a novel approach of generating efficient solvers to alleviate the scalability issue of existing solvers.
different from the state of the art solver generator sogen analyzes constraint models written in pdl to identify controlling variables and minimize their value ranges compute value boundaries for any subfunction of constraint formulas check whether a given objective function is monotonic and decide whether an objective function has overlapping subproblems.
with its novel and static property characterization sogen synthesizes optimized solvers that significantly outperformed existing ones in most scenarios.
we recently also applied sogen to the context of cs education we provided our pdl and tool as a scaffolding technique that intends to help students program for cops and observed very impressive results .
in the future we will evaluate sogen with more cps and improve it to characterize more properties.