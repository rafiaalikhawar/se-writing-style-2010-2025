typestate guided fuzzer for discovering use after free vulnerabilities haijun wang ant financial services group china csse shenzhen university chinaxiaofei xie nanyang technological university singaporeyi li nanyang technological university singapore cheng wen csse shenzhen university shenzhen chinayuekang li nanyang technological university singaporeyang liu nanyang technological university singapore zhejiang sci tech university china shengchao qin scedt teesside university uk csse shenzhen university chinahongxu chen nanyang technological university singaporeyulei sui university of technology sydney australia abstract existing coverage based fuzzers usually use the individual control flow graph cfg edge coverage to guide the fuzzing process which has shown great potential in finding vulnerabilities.
however cfg edge coverage is not effective in discovering vulnerabilities such as use after free uaf .
this is because to trigger uaf vulnerabilities one needs not only to cover individual edges but also to traverse some long sequence of edges in a particular order which is challenging for existing fuzzers.
to this end we propose to model uaf vulnerabilities as typestate properties and develop a typestateguided fuzzer named uafl for discovering vulnerabilities violating typestate properties.
given a typestate property we first perform a static typestate analysis to find operation sequences potentially violating the property.
our fuzzing process is then guided by the operation sequences in order to progressively generate test cases triggering property violations.
in addition we also employ an information flow analysis to improve the efficiency of the fuzzing process.
we have performed a thorough evaluation of uafl on widely used real world programs.
the experiment results show thatuafl substantially outperforms the state of the art fuzzers including afl aflfast fairfuzz mopt angora and qsym in terms of the time taken to discover vulnerabilities.
we have discovered previously unknown vulnerabilities and received new cves.
ccs concepts security and privacy software security engineering.
corresponding authors shengchao qin and xiaofei xie permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
.
.
.
fuzzing typestate guided fuzzing use after free vulnerabilities acm reference format haijun wang xiaofei xie yi li cheng wen yuekang li yang liu shengchao qin hongxu chen and yulei sui.
.
typestate guided fuzzer for discovering use after free vulnerabilities.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
introduction software defects are pervasive and may be exploited by malicious parties .
these software vulnerabilities have become fundamental threats against the software security.
with the development of mitigation techniques many security vulnerabilities such as buffer overflow have become harder to exploit.
an exception is the use after free uaf vulnerability.
there are still very few mitigation techniques deployed in production environments to defend against uaf vulnerabilities .
this has made uaf a significantly more vulnerable target for exploitation .
the uaf vulnerability happens when the memory is accessed after it has been freed previously which may cause data corruption information leaks denial of service and arbitrary code execution attacks .
according to recent reports about of the uaf vulnerabilities in the nvd database were rated critical or high in severity.
in contrast only about of the heap buffer overflow vulnerabilities were considered as high severity.
compared with other vulnerabilities e.g.
the stack heap buffer overflow vulnerability uaf vulnerabilities are generally considered more difficult to detect .
the main reason is that to successfully trigger a uaf a sequence of operations need to be executed in the specific order first allocating the memory then terminating the lifetime of the memory and finally dereferencing the memory.
these operations may not share locality in the code base which makes the detection much more challenging.
nevertheless there exist some automated techniques for detecting and defending against uaf vulnerabilities.
static analysis based techniques suffer from false positives especially when dealing with real world software systems.
this is due to the fact that how to perform scalable and precise inter procedural alias analysis ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea haijun wang et al.
remains an open problem.
imprecise results from the alias analysis could also affect the effectiveness of some run time detection mechanisms such as freesentry and dangnull .
these techniques monitor the pointers to each memory location and replace them with invalid pointers once the memory is freed.
if such an invalidated pointer is accessed the program will subsequently crash preventing an attacker from exploiting the vulnerability.
on the other hand dynamic techniques e.g.
greybox fuzzing which less likely produce false positives have been shown effective in detecting memory related vulnerabilities.
specially afl libfuzzer and the fuzzing infrastructure clusterfuzz have discovered more than vulnerabilities in over open source projects .
however existing techniques are not effective in detecting uafs as shown in our experiments c.f.
section .
.
existing coverage based fuzzers e.g.
afl usually use the individual control flow graph cfg edge coverage to guide the fuzzing process.
unfortunately cfg edge coverage is not so effective in discovering uafs.
this is because to trigger uaf vulnerabilities one needs not only to cover individual cfg edges but also to traverse some long sequence of edges in a particular order which is very difficult for existing coverage based fuzzers.
for example the state of the art grey box fuzzers mopt and profuzzer discover very few uaf vulnerabilities according to their experimental results.
to address this challenge we propose a typestate guided fuzzer named uafl for discovering vulnerabilities violating certain typestate properties.
our insight is that many common vulnerabilities can be seen as the violation of certain typesate properties.
for example the operation sequence malloc free use is a witness of the typestate property violation shown in fig.
therefore it may trigger the uaf vulnerability.
similarly nullify dereference is a witness for the null pointer dereferencing.
although our approach is generally applicable to all vulnerabilities which can be modelled by typestate property violations we focus on one representative exemplar uaf in this paper.
we first perform typestate analysis to identify operation sequences potentially violating the typestate properties.
we then instrument the operation sequence coverage into the target program.
based on the information collected from the instrumentation we propose two strategies to improve the effectiveness of the fuzzer we use the operation sequence coverage as the feedback to guide the test generation to progressively cover the operation sequences c.f.
section .
and we deploy an information flow analysis to infer how test inputs affect the program states c.f.
section .
and use such information to design an efficient mutation strategy by avoiding unnecessary mutations.
we have implemented uafl and evaluated it on widely used programs with diverse functionalities.
uafl significantly outperforms afl aflfast fairfuzz mopt angora qsym .
in particular uafl achieves respectively a speedup of .
.
.
.
.
and .
to detect the vulnerabilities compared to existing fuzzers afl aflfast fairfuzz mopt angora and qsym.
moreover we have discovered previously unknown uaf vulnerabilities in real world programs for them we have received cves.
all the new vulnerabilities have been confirmed.
the contribution of this work is summarized as follows.
1void main 2char buf 3read buf 4char ptr1 malloc 5char ptr2 malloc 6if buf e 7ptr2 ptr1 8if buf s 9if buf u free ptr1 11if buf e 12if buf r if buf f ptr2 m ... figure an example simplified from uaf cve .
we propose a typestate guided fuzzer for discovering vulnerabilities violating certain typestate properties.
it specifically addresses the challenge in detecting vulnerabilities triggered by specific sequences of operations e.g.
the uaf vulnerabilities where we use operation sequence as guidance to progressively generate test cases violating the typestate properties.
we design an effective mutation strategy customized for typestateguided fuzzer and apply quantitative information flow analysis to help improve the overall performance of fuzzing process.
we have implemented the proposed techniques as uafl and evaluated its effectiveness on a set of popular real world programs.
uafl significantly outperforms the state of the art fuzzers.
we have discovered previously unknown uaf vulnerabilities of which have been published as cves.
motivating example in this section we give an overview of uafl with a motivating example as shown in fig.
.
this example is simplified from the realworld program readelf which contains a uaf vulnerability i.e.
cve2018 .
fig.
a shows its control flow graph cfg where the nodes represent the statements marked with their line numbers.
the uaf vulnerability can be triggered when the statements lines 10and14 are executed temporally.
specifically the pointer ptr1points to the memory allocated at line and then ptr1and ptr2become aliases at line .
the memory pointed by ptr1 and ptr2 is freed at line but accessed again at line 14byptr2.
.
existing coverage based fuzzers existing coverage based fuzzers usually utilize the cfg edge coverage to guide the fuzzing process such as afl .
in this section we take afl for example to illustrate how the cfg edge coverage is calculated in existing fuzzers.
given a program afl needs to identify the cfg edge i.e.
an edge from one basic block to another one .
to this end afl first generates a random idfor each basic block of the program.
then a cfg edge idis calculated based on theids of two basic blocks.
for example regarding edge a b itsidis calculated ida b ida idb where the shift operation is to preserve the directionality of the edge such that theidof edge a bis distinguishable from the idof edge b a. a shared memory shared mem is used to count the hits of an edge.
for example shared mem represents that hits of edge a bare increased by .
actually the hits of each edge is divided into buckets hit 1time 2times 3times 7times 1000typestate guided fuzzer for discovering use after free vulnerabilities icse may seoul republic of korea ... ... ... ... ... ......... discarded2 ... ... ...bug!malloc alias free useptr1 malloc ptr2 ptr1 free ptr1 ptr2 m aaaaaaa aaaseen aurseaa faraeaa aaaseen auaseen furseen a control flow graph b fuzzing process in afl c fuzzing process in uaflphase1 typestate analysis phase2 typestate guided fuzzing figure fuzzing process of afl and uafl in the example of fig.
.
times times times and times.
given a test case afl generates new test cases by performing mutations on it.
basically the new test case is considered as interesting and added into the test pool for further mutation if it covers the edges not found by previous test cases or it touches the new buckets of edges.
otherwise this test case is discarded.
.
limitations of coverage based fuzzers existing coverage based fuzzers usually consider the cfg edge s coverage individually and they are limited to track the coverage of a sequence of edges.
for example regarding a path a b c afl individually counts the hits of a bandb c but cannot track the hits of this path.
hence existing coverage based fuzzers are challenging to detect some vulnerabilities e.g.
uaf and double free which violate the temporal memory safety malloc free use.
this can be also specified as a typestate property as shown in fig.
.
we take the program in fig.
as an example the uaf vulnerability can be triggered if lines 14are executed temporally i.e.
the grey nodes in fig.
a .
assume the initial seed is aaaaaaa and afl generates three mutants aaaseen aurseaa and faraeaa as shown in fig.
b .
these four program paths cover all the cfg edges but none of them can trigger the uaf vulnerability.
besides since all cfg edges have been covered in these four test cases their following mutants will be discarded as they cannot cover new cfg edges.
considering the edge s coverage individually e.g.
afl it is highly difficult to generate a test case that can cover .
we actually ran afl on this example and cannot find the uaf vulnerability within hours.
.
our approach motivated by the aforementioned challenge we propose a typestateguided fuzzer named uafl which aims to detect the vulnerabilities violating the typestate property.
uafl works in two phases typestate analysis and typestate guided fuzzing.phase1 typestate analysis.
based on the typestate property e.g.
uaf and double free in fig.
uafl firstly performs the static typestate analysis to capture the operation sequences in the program following the temporal relation violating the typestate property.
for example to discover the uaf vulnerability uafl identifies all operation sequences following the pattern malloc free use.
as shown in typestate analysis step of fig.
c we present the identified operation sequence i.e.
which satisfies the uaf pattern.
this operation sequence first performs the memory allocation then goes through the memory free and finally reaches the memory use.
it is worth noting that uafl also performs the pointer alias analysis e.g.
pointers ptr1 andptr2may be aliases during the execution.
phase2 typestate guided fuzzing.
guided by the operation sequences uafl generates test cases to progressively execute towards the operation sequences.
uafl first performs the instrumentation based on the identified operation sequences.
the objective of instrumentation is to provide the feedback which can guide uafl to generate test cases that can execute towards the operation sequences.
fig.
c shows the fuzzing process of uafl.
assume that uafl has also generated the test cases of fig.
b and covered all cfg edges.
with the operation sequence i.e.
as guidance uafl is able to generate new test cases that gradually cover the entire operation sequence.
for example based on test case aaaseen uafl may generate a test case auaseen .
this test case is discarded by afl since it does not cover new cfg edges compared to previous test cases aaaseen and aurseaa .
however as it covers edge 10of operation sequence i.e.
malloc free uafl adds it into the test pool for further mutation by mutating test case auaseen uafl may further generate new test case f urseen which covers the operation sequence i.e.
malloc free use .
thereby the uaf vulnerability is discovered.
we ran uafl on this example and discovered the uaf vulnerability within about minutes.
1001icse may seoul republic of korea haijun wang et al.
typestate analysis in this section we elaborate on the typestate property and how to identify operation sequences potentially violating the uaf property with static typestate analysis.
.
typestate properties to facilitate the illustration we adopt a simplified programming language model defined as follows.
definition program .a program is a stmt defined by the following context free grammar stmt var var var malloc var.op stmt stmt if stmt elsestmt label stmt gotolabel where denotes a non deterministic branch varare variables which reference to objects of type t opare operations supported by type t. we adopt the intuitive notion of a path pthrough a program p orp path a valid sequence of statements starting at p s entry.
a program path may contain operations on multiple objects and we can extract multiple operation sequences from it each per object.
the operation sequence for objects is formally defined as follows.
definition operation seqences oss for objects .
given a p path p u p denotes the set of object instances created during this execution and for any object o u p p denotes the sequence of operations performed on oduring execution of p. for example assume that a p path is p a.malloc a.insert b.malloc b.free a.free then we haveu p a b andp a.malloc a.insert a.free .
an operation sequence for a particular object can be checked against a typestate property which is formally defined as follows.
definition typestate property .atypestate property pis a finite state automaton p q init q err where is the alphabet of observable operations qis the set of states is the transition function mapping a state and an operation to a successor state init q is a distinguished initial state err q is a distinguished error state such that for every err err and all states inq err are accepting states.
we say that q is the successor of a state qon operation opwhen q op q .
given a sequence of operations op0 .
.
.
opn we write p when is accepted byp and we write p when is not accepted byp.
typestate analysis.
regarding typestate properties a set of observable operations accepted by the automaton are valid traces.
on the other hand a set of operation sequences not accepted by the automaton represent invalid traces which potentially violate typestate properties.
intuitively vulnerabilities triggered by a sequence of operations can be captured by typestate properties.
given a typestate propertyp the typestate analysis problem forpis to determine whether there exists a path psuch that o u p p p. .
use after free detection problem in this paper we focus on detecting the uaf vulnerability and fig.
illustrates its typestate property.
the alphabet for this problem consists of three operations malloc free use .
when thealgorithm typestate analysis for use after free input a program p output a set of operation sequences s 1s sm m find malloc p 3foreach sm m sm m do a cal alia s m sf find free a p su find use a p s s sm sf su sf sf su su is reachable sm sf is reachable sf su 8return s live dead errormalloc freeuse use free figure typestate for use after free and double free.
memory is allocated it is in the livestate and can be accessed afterwards.
once the memory is freed it becomes dead.
any subsequent use free operation on this memory results in an error state.
notice that the double free vulnerability is a special case of uaf.
the uaf detection is to discover test cases that perform the operation sequences violating typestate property in fig.
.
refer to the example in fig.
a p path contains the operation sequence for the memory associated with ptr1 which violates the given typestate property.
.
use after free typestate analysis given the typestate property of uaf vulnerability uafl performs the static typestate analysis to identify the operation sequences violating this property.
algorithm shows the basic idea which takes as the input a program pand outputs a set of operation sequences sviolating the property.
for the program p uafl first finds all memory allocation statements sm line where mis a set of memory objects allocated atsm.
for each memory object mallocated at sm line uafl calculates all the aliased pointers athat all point to the memory object m with the pointer alias analysis line .
then uafl identifies all memory freestatements that free the memory object mby an aliased pointer in a line .
following the same way uafl finds all memory usestatements line .
finally the operation sequence sm sf su is added into output s line where smallocates the memory sffrees the memory which is reachable from sm and suuses the memory which is reachable from sf.
notice that uafl adopts the path insensitive reachability analysis to perform typestate analysis and may produce false positives.
thus some operation sequences identified in smay not violate the typestate property.
furthermore we employ the fuzzing technique that will confirm whether they actually violate the property.
example .
in fig.
two memory objects pointed by pointers ptr1 andptr2are allocated at lines 4and5.
regarding ptr1 we identify the aliased pointer ptr2at line .
then the memory is freed at line 10by ptr1.
lastly line 14accesses the memory again by the aliased pointer ptr2.
since line 10is reachable from line 4and line 14is reachable 1002typestate guided fuzzer for discovering use after free vulnerabilities icse may seoul republic of korea test poolstatic analysisoperation sequencesoperation sequence instrumentation information flow instrumentationinstrumented program executionoperation sequence coverageseed preservation information flow analysisadaptive mutationnew seeds input to state relationseedseed selection fuzzing loopinstrumentation typestate analysissource code initial seedstypestate property power scheduleenegy figure workflow of typestate guided fuzzing.
from line we identify an operation sequence .
to be more precise if the memory free and use statements use the aliased pointers we incorporate the alias statement into the sequence.
as a result we obtain the sequence c.f.
fig.
a which violates the property of uaf.
typestate guided fuzzing given the operation sequences oss identified by the static typestate analysis we perform os guided instrumentation to steer the fuzzing process which can generate test cases to progressively cover the type state statement sequences at runtime.
uafl mainly proposes two strategies to improve the effectiveness of the fuzzer.
we propose the os guided mechanism which can guide uafl to generate test cases progressively covering the oss.
for example to cover the sequence 14in fig.
uafl gradually generates the test cases to cover and4 14in turn.
with the guidance developed we still require an equipped mutation strategy to coordinate it.
uafl utilizes an information flow analysis to build the relationship between the input and variables in the program.
based on the relationship uafl adaptively mutates the input to change the states of variables.
take the program in fig.
for example the second and fourth bytes of input bufare relevant to lines 8and9 and uafl mutates them to generate a test case that can execute line .
.
fuzzing workflow fig.
presents the fuzzing workflow.
after identifying the oss by typestate analysis we instrument os guided information into the program.
to achieve the two proposed strategies we perform two kinds of instrumentation operation sequence instrumentation and information flow instrumentation c.f.
section .
.
during the fuzzing loop uafl first selects a test case i.e.
the seed from the test pool c.f.
section .
.
uafl then measures the quality of this seed and assigns an energy to it with the power scheduling strategy c.f.
section .
.
next we adopt the adaptive mutation strategy to mutate this seed and generate new seeds.
the information flow analysis is used to produce an adaptive mutation strategy c.f.
section .
.
after the new seeds are generated uafl checks whether there is new os coverage by running them.
if so the new seeds are considered interesting and added into the test pool for further mutation.algorithm uafl instrumentation input a program p and a set of operation sequences s output an instrumented program p 1letop mem ope mem andifa mem be shared memory 2foreach s0 .
.
.
sn sdo b0 .
.
.
bm bb op s0 .
.
.
sn foreach bi b0 .
.
.
bm do insert op mem 1intobi foreach bi b1 .
.
.
bm do letcibe a set of conditional statements between bi 1and bi and biis control dependent on ci foreach cj cido letbcjbe parent basic block of cj tid for0 k ido ifop mem 1then tid tid idbk insert ope mem intobcj letcjbe comparison instruction cmpa b insert ifa mem a bintobcj .
instrumentation algorithm presents the details of our instrumentation.
the inputs of the algorithm are a program pand a set of identified oss s. the output is the instrumented program p .
from a high level the instrumentation mainly includes three steps use the shared memory op mem to record whether the operation statements in the oss are executed use the shared memory ope mem to record whether the os edges are covered and use the shared memory ifa mem to record the values of variables in the comparison instructions for the future information flow analysis line .
it is worth noting all elements of the three shared memory arrays are initialized as zero before each execution.
the instrumentation is conducted on the basic block for each os s0 .
.
.
sn we first get its basic block sequence b0 .
.
.
bm line .
note that the length of the basic block sequence may be less than the original os as some statements may belong to the same basic block.
regarding each biin the sequence we instrument it with op mem line representing whether biis executed or not.
the idbiis the idof basic block bi c.f.
section .
.
in the second step we perform the instrumentation to record the coverage of oss.
notice that the os is different from the p path c.f.
section .
.
specifically an os edge may need to execute a sequence of cfg edges in p path.
for example in fig.
c to cover the os edge it needs to execute the cfg edges 9and .
therefore it is highly difficult to cover the os edge directly.
instead we should first cover edge and then .
to provide the fine grained guidance for covering the os edge we consider its dominated basic blocks.
for example regarding 10in fig.
c the parent basic blocks at lines and in fig.
are its dominated basic blocks.
in particular for each biin the sequence uafl analyzes the conditional statements cibetween bi 1andbi biis control dependent on ci line .
for each statement cj ci uafl gets its parent basic block bcj line and instruments bcj 1003icse may seoul republic of korea haijun wang et al.
algorithm mutation probability calculation input an program input x and variables bv atn instructions output mutation probability prob 1foreach i .
.
.
m do x y foreach j .
.
.
k do x mutate x b v evaluate x bv x x x y y b v e x maxj .
.
.
n ifstrength x bv x y 9mine min e x .
.
.
e x 10maxe max e x .
.
.
e x 11foreach i .
.
.
m do prob e x mine maxe mine with ope mem line .
specifically the variable tidis used to represent the execution information of b0 .
.
.
bi lines .
if bkis executed i.e.
op mem at line itsidis embedded into tid line .
as a result tidcan be used to guide the execution process toward bcj.tidwould have a different value when a new basic block bk b0 .
.
.
bi is executed.
thus the instrumentation can guide the fuzzing process to gradually cover the operation sequences named operation sequence feedback.
in the third step we preform the information flow instrumentation to conduct information flow analysis.
we assume that the conditional statement is a comparison instruction e.g.
cmp a b .uafl records the values of a bby instrumenting ifa mem a b in the basic block bcj line .
example .
given the os edge 10in fig.
c we assume the basic block sequence is b7 b10and their ids are idb7and idb10.
when b7is executed we instrument b10with ope mem id b7 idb10 .
otherwise the instrumentation ope mem is inserted into b10.
thereby our instrumentation can differentiate whether b7is executed or not once we reach b10at runtime.
.
information flow analysis based mutation with the oss and their dominated basic blocks identified the next challenge is to find a way to perform the mutations so that the oss can be covered quickly.
for an instruction cmpa b the basic idea is that we first identify which part of the input can change the values ofa b then we can focus the resource on mutating this part of the input until its condition is satisfied.
we adopt an information flow analysis to identify the relationship between the input and the program variables in the comparison instructions.
information flow strength.
we follow the information flow definition in and compute the information flow strength from variable xto variable yas follows ifstrength x y vx vy h x vx h x y vx vy where vxandvyare the value domains of variables xandy respectively.
h x vx denotes the information entropy measuring the uncertainty of variable x. h x vx xi vxp x xi lo 2p x xi h x y vx vy denotes the conditional information entropy of variablexgiven the distribution of variable y h x y vx vy yj vyp y yj algorithm mainly includes two steps.
first we compute the information flow strength between each byte of the input and variables i.e.
a b in the target comparison instructions lines .
the higher the information flow strength the stronger this byte influences the values of the variables.
then we assign higher mutation possibility for these bytes of the input as they are more likely to change the values of target instructions lines .
the inputs of the algorithm consist of the array x that is a m bytes program input and the array bv that includes variables inncomparison instructions i.e.
a bincmpa b .
its output is an array prob that contains the mutation probability for each byte of input x. for each byte of the input x line we compute its information flow strength to each variable in bv.
we use xandyto store the sampling values for each byte of xand each variable of bv line .
we mutate each byte of x i.e.
x with ktimes line and get kvalues for each variable of bv.
specifically after each mutation we get a new mutant x line .
by running x line we can evaluate the values of variables bv c.f.
ifa mem at line in algorithm .
after generating ksamples we compute the information flow strength between x and each variable of bv line .
notice that for each x we compute ninformation flow strength values and the maximum value is considered as the information flow strength of x line .
based on the information flow strength we calculate the mutation probability for each byte of input i.e.
x by the normalization line .
intuitively if there is strong information flow between x and the program variables it has a larger mutation probability.
example .
in fig.
given an input buf aaaaaaa assume the target instruction is buf s at line we consider the information flow strength between the bytes of input i.e.
bu f andbu f and the variable bu f s at line .
assume each byte is mutated with times i.e.
k 10in algorithm then we figure out the information flow strength .3forbuf and0forbuf .
it suggests that there is a strong information flow between bu f and the condition at line .
to cover this branch i e bu f s we will assign more mutations on buf .
.
seed selection the seed selection step is to select the next test case from the test pool such that it is more likely to cover the target oss with some mutations on the selected test case.
motivated by the technique uafl provides a three tiered queue which classifies the generated seeds into different categories based on their scores.
the seeds in the top tiered queue have the highest priority followed by the second tiered and finally the lowest tiered.
these three tiers are designed based on the os edge e.g and10 14in fig.
and cfg edge coverage e.g.
9and .
specifically given a newly generated seed if it covers a new os edge we add it into the top tiered queue if it covers a new cfg edge we add it into the second tiered queue otherwise the seed is added into the lowest tiered queue.
intuitively uafl 1004typestate guided fuzzer for discovering use after free vulnerabilities icse may seoul republic of korea favors the seeds that cover new os edges since it has more chances to cover the target os.
if the seed does not cover any new os edge but covers a new cfg edge which are control dependent on the statements of the os refer to line in algorithm it still makes a small step towards covering the whole os.
example .
in fig a newly generated test case which covers the new os edge is prioritized in the top tiered queue since it is closer to cover the target oss.
however if it does not cover but cfg edge it is also added into the second tiered queue as it executes towards to .
.
power scheduling the power scheduling concerns about how many mutation chances are assigned to the given test case.
a test case that has more chances to cover oss with mutations should be assigned with more energy.
existing coverage based fuzzers e.g.
afl usually calculate the energy for the selected test case as follows ener y i allocate ener y qi where iis the seed and qiis the quality of the seed depending on the execution time branch edge coverage creation time and so on.
uafl considers the os edge coverage and updates the existing power scheduling as follows ener y i ener y i c ose t ose where t ose represents the total number of os edges and c ose denotes the number of os edges that are covered by seed i. intuitively the number of covered os edges implies how close the seeds are to oss.
thus uafl assigns higher energy to seeds closer to oss for them to have more chances to cover more os edges with mutations.
evaluation we have implemented the static typestate analysis on top of an interprocedural static value flow analysis tool called svf which is able to perform scalable and precise interprocedural dependence analysis for c and c programs.
this part takes about lines of c c code.
in the instrumentation component we have designed three bulks of shared memory that tracks the execution information.
the instrumentation consists of about lines of c c code.
the fuzzing engine is implemented based on the afl version .51b where we have implemented the information flow analysis based mutation.
we added about lines of c c codes into this part.
.
evaluation setup in the experiments we aim to answer the following questions rq1 what is the effectiveness of the static typestate analysis for uaf vulnerabilities?
rq2 how effective is uafl in discovering uaf vulnerabilities?
rq3 how effective are the two strategies in uafl i.e.
operation sequence feedback and information flow based mutation?
rq4 how is the code coverage relevant to uaf vulnerabilities?
following klees s suggestions in we conduct a large scale experiment and compare uafl with state of the art fuzzers.
.
.
baseline fuzzers.
to evaluate the effectiveness of uafl we select representative state of the art fuzzers which incorporate diverse advanced techniques to improve the effectiveness of fuzzing.
afl is the most popular baseline fuzzer which is studied in most coverage based fuzzers.
aflfast is an advanced variant of afl with a better power scheduling that was incorporated into the later versions of afl.
fairfuzz monitors the program executions and computes the key patterns inside a seed to reach rare cfg edges.
mopt adopts a customized particle swarm optimization pso algorithm to schedule the mutation operations which enables more efficient discovery of vulnerabilities.
angora utilizes taint analysis to track information flow and then uses gradient descent to break through the hard branches.
qsym is an effective symbolic execution assisted fuzzer.
.
.
benchmark programs.
we consider the benchmark programs with the following factors frequency of being tested in related work popularity of being used by end users and their functionality diversities.
finally we select widely used programs as our benchmark including the well known development tools e.g.
readelf .
readelf .
code processing tools e.g.
mjs mini xml gnu cflow nasm graphics processing libraries e.g.
imagemagick jpegoptim compression tools e.g.
lrzip and openh264 data processing libraries e.g.
libpff andliblouis an encryption key management tool e.g.
boringssl and a satisfiability modulo theories solver e.g.
boolector .
for each program we select the version that includes the uaf vulnerabilities c.f.
column version in table .
.
.
configuration parameters.
the effectiveness of fuzzers heavily replies on the random mutations thus there may be performance deviation in the evaluation.
following klees s suggestions in we take three actions to mitigate performance deviation.
first we test each program for a longer time until the fuzzer reaches a relatively stable state.
in the paper we run each fuzzer for hours.
second we perform each experiment for times and evaluate their statistical performance.
third for the initial seeds if the programs provide the sample seed inputs we use them as the initial seeds.
otherwise we randomly download some input files from the internet according to the required input file formats.
all the initial seeds can be found in our website .
all our experiments have been performed on machines with an intel r xeon r cpu e5 v4 .60ghz and 16gb of ram under bit ubuntu lts .
.
.
static typestate analysis statistics rq1 in table we present the static typestate analysis results for benchmark programs.
the first three columns denote the basic information of programs including program names their versions and lines of code.
we can see that the chosen programs have high diversities in terms of program size from 2k to 781k lines of code.
column t bb lists the number of total basic blocks in the program.
column bbuafpresents the number of basic blocks in oss which may violate the uaf typestate property.
specifically uafl instruments .
of the basic blocks on average to provide operation sequence feedback.
column bbifdenotes the number of basic blocks in which we perform the information flow instrumentation.
to calculate the information flow strength uafl performs 1005icse may seoul republic of korea haijun wang et al.
table static typestate analysis results program version loc t bb bbu af bbif bbfre e os t s readelf .
781k .
.
readelf .
758k .
.
jpegoptim .
2k .
.
liblouis .
.
53k .
.
lrzip .
19k .
.
mini xml .
15k .
.
boringssl 162k .
.
gnu cflow .
50k .
.
boole ctor .
.
141k .
.
openh264 .
.
143k .
.
libpff 125k .
.
mjs .
.
40k .
.
imagemagick .
.
485k .
.
nasm .
101k .
.
avg.
348k .
.
table time to expose uaf vulnerabilities in state of the art fuzzers program vulnerabilitiestime usage to expose the vulnerabilities hours uafl uafl n oi f afl aflfast fairfuzz mopt angora qsym readelf .
cve .
.
.
.
.
.
t o .
readelf .
cve .
.
.
.
t o .
.
.
jpegoptim cve .
.
.
.
.
.
t o .
liblouis cve .
.
.
t o .
.
t o .
lrzip cve .
.
.
.
.
.
.
.
mini xml cve .
.
.
.
.
.
t o .
boringssl google test suit .
.
t o t o .
.
t o gnu cflow uaf issue .
.
.
t o .
t o t o t o boolector uaf issue .
.
.
.
.
.
.
openh264 uaf issue .
.
.
.
.
.
t o .
libpff uaf issue .
.
.
.
.
.
t o .
mjs uaf issue .
.
.
.
.
.
t o .
imagemagick uaf issue .
.
t o t o t o t o t o t o nasmcve .
.
.
.
.
.
.
.
cve .
t o t o t o t o t o t o t o missed vulnerabilities avg.
time usage .
.
.
.
.
.
.
.
.
.
uafl s speedup .
.
.
.
.
.
.
uafl n oi f s speedup .
.
.
.
.
.
t o means the fuzzer cannot discover vulnerabilities within hours across runs.
when we calculate the average time usage we replace t o with hours.
angora does not work on the programs boringssl andboolector denoted by because it throws the exceptions during the instrumentation.
the instrumentation on an average of .
of basic blocks.
the experiment results show that with less instrumentation total .
in both operation sequence and information flow instrumentation uafl can concentrate more power and energy on the oss which may violate the typestate property of uaf.
column bbfreeshows the number of static memory free instructions.
column ospresents the number of operation sequences identified by static typestate analysis.
it reports on average oss in each program.
since uafl adopts the path insensitive reachability analysis it produces too many false positives.
thus we employ the fuzzing to confirm whether these oss really trigger uaf vulnerabilities.
in the last column t s we list the time overhead for static typestate analysis.
in all programs uafl requires less than one hour i.e.
avg.
148s .
hour to conduct the static typestateanalysis.
compared to the long time fuzzing process e.g.
hours the time overhead for static typestate analysis is acceptable.
rq1 the results show that the time overhead incurred in the static typestate analysis of uafl is acceptable with an average of 148s .
hour .
on average .
and .
of basic blocks are instrumented respectively for operation sequence feedback and information flow analysis.
.
v ulnerability detection results rq2 as suggested by klees the vulnerabilities found are ideal to measure the effectiveness of fuzzers.
we evaluate the fuzzers with the time used for discovering uaf vulnerabilities.
1006typestate guided fuzzer for discovering use after free vulnerabilities icse may seoul republic of korea table shows the time usage to discover the unique uaf vulnerability.
the first two columns list the program names and the vulnerability id.
the following columns presents the results for each fuzzer.
compared to state of the arts fuzzers e.g.
afl aflfast fairfuzz mopt angora and qsym uafl takes much less time i.e.
avg.
.79hours while others need about hours.
even if the time overhead i.e.
avg.
.32hours in static typestate analysis is added uafl is still more effective than others.
row uafl s speedup shows the average speedup achieved by uafl a speedup of .
.
.
.
.
and .
respectively compared with the other fuzzers.
for shallow vulnerabilities e.g.
readelf .
lrzip all fuzzers work well but for deep hard vulnerabilities e.g.
liblouis gnu cflow andimagemagick uafl performs much better than the others.
for example uafl takes about .80hours to discover uaf in gnu cflow while other fuzzers almost spend about 20hours.
in addition of the vulnerabilities uafl performs the best in .
vulnerabilities.
in the program readelf .
angora performs the best and fairfuzz achieves the best performance inboolector.
a close investigation reveals the reason behind is that these fuzzers objectives coincidentally fit with the uaf.
for example fairfuzz aims to cover rare cfg edges and the memoryfree statement in boolector is under such rare cfg edges.
thus fairfuzz has high chance to detect the uaf after covering the free statement.
different with other tools uafl is designed based on the typestate properties.
hence uafl performs more stably and achieves better performance for most programs.
row missed vulnerabilities shows the number of uaf vulnerabilities which cannot be discovered by each fuzzer.
afl aflfast fairfuzz mopt angora and qsym missed and vulnerabilities within hours respectively.
statistical test.
to mitigate the randomness we conducted the statistical test for the experiment results.
the vargha delaney statistic a12 is a non parametric measure of effect size and usually used to measure the randomized algorithms .
given the time usage inuafl and other fuzzers the a12statistic measures the probability that uafl performs better than others.
moreover we also use mann whitney u to measure the statistical significance of performance gain.
when it is significant we mark the a12values in bold.
in the column a12 uafl of table we can see that uafl significantly performs better than other fuzzers in most cases.
rq2 from tables and uafl performs significantly better than other fuzzers in most cases.
uafl achieves a speedup of .
.
.
.
.
and .
compared to afl aflfast fairfuzz mopt angora and qsym respectively.
.
evaluation of the strategies rq3 uafl mainly adopts the operation sequence feedback and information flow analysis based mutation strategies to enhance the capability of uaf detection.
to evaluate the effectiveness of each strategy we configure a new fuzzer uafl n oi f which only incorporates operation sequence feedback strategy but not the information flow analysis.
the experiment results of uafl n oi f is shown under the column uafl n oi f in table and a12 uafl n oi f in table .
time hour os edge mjs uafl noif uafl qsym moptfairfuzz angora aflfast afl time hour os edge cflow uafl noif uafl qsym moptfairfuzz angora aflfast afl time hour os edge nasm uafl noif uafl qsym moptfairfuzz angora aflfast afl time hour os edge boringssl uafl noif uafl qsym moptfairfuzz aflfast afl time hour os edge liblouis uafl noif uafl qsym moptfairfuzz angora aflfast afl time hour os edge readelf .
uafl noif uafl qsym moptfairfuzz angora aflfast aflfigure code coverage relevant to operation sequences.
by comparing the results it shows that uafl n oi f is still better than other fuzzers in most cases.
for example uafl n oi f averagely takes .12hours to discover each vulnerability achieving the speedups of .
.
.
.
.
and .
over other fuzzers respectively.
similarly the statistical test also shows that uafl n oi f is more effective in most cases.
the results demonstrate the effectiveness of the operation sequence feedback.
by comparing the results of uafl anduafl n oi f we find that uafl performs better than uafl n oi f in each program.
specifically uafl achieves .
improvement over uafl n oi f .
it is worth noting uafl n oi f cannot find the uaf i.e.
cve in the program nasm within hours.
however with the information flow based mutation incorporated uafl can discover the vulnerability with .
hours.
the results demonstrate the effectiveness of the information flow based mutation.
rq3 the two strategies used in uafl are both effective.
the comparative results between uafl n oi f and other tools show the effectiveness of operation sequence feedback.
the comparative results between uafl anduafl n oi f show the contribution of the information flow analysis based mutation.
.
co de coverage rq4 although there is no fundamental connection between maximizing code coverage and finding more vulnerabilities the general efficacy of grey box fuzzers over black box ones means the certain correlation.
it is believed that the code coverage makes sense as a secondary measure for the effectiveness of fuzzers.
in this section 1007icse may seoul republic of korea haijun wang et al.
table statistical test for time to exposure uaf vulnerabilities program vulnerability a12 uafl a12 u afl n oi f afl aflfast fairfuzz mopt angora qsym afl aflfast fairfuzz mopt angora qsym readelf cve .
.
.
.
.
.
.
.
.
.
.
.
r eadelf cve .
.
.
.
.
.
.
.
.
.
.
.
jpegoptim cve .
.
.
.
.
.
.
.
.
.
.
.
liblouis cve .
.
.
.
.
.
.
.
.
.
.
.
lrzip cve .
.
.
.
.
.
.
.
.
.
.
.
mini xml cve .
.
.
.
.
.
.
.
.
.
.
.
boringssl google test suit .
.
.
.
.
.
.
.
.
.
.
.
gnu cflow uaf issue .
.
.
.
.
.
.
.
.
.
.
.
boolector uaf issue .
.
.
.
.
.
.
.
.
.
.
.
openh264 uaf issue .
.
.
.
.
.
.
.
.
.
.
.
libpff uaf issue .
.
.
.
.
.
.
.
.
.
.
.
mjs uaf issue .
.
.
.
.
.
.
.
.
.
.
.
imagemagick uaf issue .
.
.
.
.
.
.
.
.
.
.
.
nasmcve .
.
.
.
.
.
.
.
.
.
.
.
cve .
.
.
.
.
.
.
.
.
.
.
.
significant b etter a12 .
bold we highlight the a12in the bold if its corresponding mann whitney u test is significant.
we only calculate the code coverage identified by the typestate analysis because only they can help find the uaf vulnerabilities and the coverage can measure how close the generated test cases are to uaf vulnerabilities thus can signify the quality of generated test cases.
we evaluate the code coverage in uafl uafl n oi f afl aflfast fairfuzz mopt angora and qsym.
we only show here the results for programs in which the uaf vulnerabilities are hard to detect the rest can be found from our website .
fig.
presents the code coverage achieved by state of the art fuzzers.
in the early stage all fuzzers show the similar code coverage growth.
as the time goes on the code coverage in uafl and uafl n oi f grows faster than the other fuzzers.
at the end of hours uafl anduafl n oi f almost achieve the best code coverage among all eight fuzzers.
the code coverage also reflects why uafl anduafl n oi f perform better in discovering vulnerabilities than others as shown in table .
for other fuzzers the results in afl aflfast mopt angora and qsym are close to each other.
fairfuzz averagely performs better than the other fuzzers.
after investigating the fuzzing process in fairfuzz we find that some edges in oss of uaf are rarely covered which is in accordance with the target of fairfuzz.
although fairfuzz can cover some rare edges individually it is still challenging to cover the whole operation sequences.
hence it is less effective to discover uaf than uafl.
another example is program readelf .
where angora achieves the best code coverage.
however angora does not discover the uaf vulnerability as shown in table .
this is because angora covers only individual edges but not the sequences.
rq4 compared to other fuzzers uafl and uafl n oi f achieve better code coverage relevant to uaf vulnerability which also explains why uafl anduafl n oi f are more effective in discovering uaf vulnerabilities.
.
discussion and threat to validity this paper evaluates our proposed typestate guided fuzzer for detecting uaf vulnerabilities.
due to the high expressiveness of typestate property our approach can be extended to detect other types of vulnerabilities.
for example we can extend uafl to detect apimisuse e.g.
file read write operations by customizing the typestate property.
on the other hand uafl adopts the typestate analysisto identify operation sequences violating the typestate property and then focuses its resource on these sequences imposing less power for exercising other parts of the program.
thus uafl is complementary to existing coverage based fuzzers to find the vulnerabilities that violate the typestate property.
one threat to validity is that it may cause a certain sample bias when selecting programs to evaluate the capabilities of uafl in discovering uafs.
to address this issue we have selected a wide range of real world programs which have different functionalities and are frequently used in others work.
in addition each experiment is conducted times to mitigate the randomness factor.
due to the unique characteristics of uaf i.e.
malloc free use we believe that the real world uaf vulnerabilities found by uafl are representative.
related work we discuss some closely related work in the following topic areas.
typestate analysis.
typestate analysis is a widely used technique in formal verification .
however as proved by field et al.
the typestate verification problem becomes np hard for programs with maximum aliasing width of three and aliasing depth of two .
this limits the practical usefulness of typestate verification on large programs.
to tackle this problem hua et al.
introduced machinelearning guided typestate analysis for static uaf detection .
they leverage machine learning techniques to reduce the overhead of typestate analysis making it scalable to large size programs.
chen et al.
proposed a regular property guided symbolic execution to verify whether there is a path in the program satisfying the given property.
these techniques are different from uafl in two ways they employ symbolic execution while we enhance the fuzzing technique and they identify only a program path satisfying the property while we find all possible program paths violating the property.
these works bring insights for uafl and we provide another approach to applying typestate analysis by incorporating it into fuzzing.
use after free run time protection.
since uaf vulnerabilities are highly exploitable many works are proposed to protect the program via early detection of uaf .
most of these works eliminate uaf vulnerabilities by capturing the existence of dangling pointers and disposing.
this is because dangling pointers are the hotbed for uaf vulnerabilities.
for example in a pointer 1008typestate guided fuzzer for discovering use after free vulnerabilities icse may seoul republic of korea is nullified once the corresponding memory is freed.
this effectively turns the uaf bug into a null pointer dereference which is much less harmful.
these works are orthogonal to uafl as they focus on capturing and monitoring the uaf behaviors while uafl focuses on discovering and triggering uaf vulnerabilities.
use after free static detection.
besides the dynamic approach proposed in this paper researchers also proposed several static approaches for uaf discovery .
these approaches rely heavily on pointer analysis which bears a dilemma in nature.
the dilemma is that we need to sacrifice a lot of scalability in exchange of a small amount of increment in precision and the result can still suffer from high false positives.
comparing with these static approaches uafl strikes a balance by having no false positive every uaf found is associated with a proof of crash input as well as good scalability only light weight static analysis is needed and the rest is handled by the dynamic part .
greybox fuzzing.
recently lots of greybox fuzzing techniques have been proposed to detect various types of bugs .
these techniques either enhance the different components of the greybox fuzzer or combine greybox fuzzing with other techniques such as static analysis symbolic execution or taint analysis .
these techniques are general purpose techniques which are not designed to detect a specific type of bugs with more effectiveness.
with the experiments in section it is demonstrated that uafl can substantially outperform these general purpose fuzzers in uaf detection.
besides the general purpose greybox fuzzers there are also directed greybox fuzzers to quickly reach target locations .
comparing with the directed fuzzers uafl does not require prior knowledge about the locations of uaf bugs for reaching and detection.
other than the general purpose and directed greybox fuzzers researchers also proposed fuzzing techniques for finding specific types of bugs such as slowfuzz perffuzz memlock .
however none of them is designed for uaf bugs and to the best of our knowledge uafl is the first greybox fuzzer specialized in detecting uaf vulnerabilities.
conclusion in this paper we propose a typestate guided fuzzer uafl for discovering vulnerabilities violating typestate properties e.g.
uaf vulnerabilities.
we first employ a typestate analysis to extract operation sequences violating a given typestate property which are then used to guide the fuzzing process to generate test cases progressively towards these operation sequences.
we also adopt information flow analysis to guide the mutation process to improve the efficiency of the fuzzing process.
our experimental results have shown that uafl substantially outperforms the state of the art fuzzers including afl aflfast fairfuzz mopt angora and qsym in discovering uaf vulnerabilities.