explaining pair programming session dynamics from knowledge gaps franz zieris zieris inf.fu berlin.de freie universtit t berlin berlin germanylutz prechelt prechelt inf.fu berlin.de freie universtit t berlin berlin germany abstract background despite a lot of research on the effectiveness of pair programming pp the question when it is useful or less useful remains unsettled.
method we analyze recordings of many industrial pp sessions with grounded theory methodology and build on prior work that identified various phenomena related to within session knowledge build up and transfer.
we validate our findings with practitioners.
result we identify two fundamentally different types of required knowledge and explain how different constellations of knowledge gaps in these two respects lead to different session dynamics.
gaps in project specific systems knowledge are more hampering than gaps in general programming knowledge and are dealt with first and foremost in a pp session.
conclusion partner constellations with complementary knowledge make pp a particularly effective practice.
in pp sessions differences in system understanding are more important than differences in general software development knowledge.
acm reference format franz zieris and lutz prechelt.
.
explaining pair programming session dynamics from knowledge gaps.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
introduction software development is knowledge intense.
in their daily work software developers need to be knowledgeable about languages technology stacks approaches to design coding testing and debugging functional and non functional requirements and the system s current architecture and status.
rarely all of the relevant knowledge is readily available and so software development is a knowledgeacquiring activity .
pair programming pp is a practice of two developers working together closely on the same problem.
surveys show that knowledge transfer is an important expected benefit of pair programming and some pp sessions main purpose is to transfer knowledge .
in practitioners expectations knowledge transfer can mean to combine the partners possess different knowledge to begin permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
and these combine favorably for solving the session s task faster or better.
understand two developers together acquire the lacking knowledge faster and more reliably and thus catch defects in the making and produce better solutions.
learn beyond the current task the two developers learn together and from another improving their abilities to work on future tasks.
research goals generally we want to understand how pp actually works and want to provide actionable advice to practitioners for effective pp behavioral patterns and anti patterns .
specifically for this article we want to understand the role of knowledge transfer for how a pp session develops.
we do notquantify effects and do not compare to solo programming.
research approach we perform deep qualitative analyses of a broad variety of industrial pair programming sessions.
research contributions first we go beyond a simple dichotomy of expert and novice developers based on years of work experience and instead characterize two types of knowledge relevant for software development system specific sand generic gknowledge.
we use these types to characterize a the extent of the developer s knowledge needs for working on the current task and b how the developers exchange and acquire knowledge to meet these needs.
second we describe how six different pair constellations in terms of the pair s initial knowledge needs shape the dynamics of the whole pp session and how a single global structure emerges from these six that is common to all analyzed pp sessions.
third we formulate and validate ideas on how practitioners may use these insights to make more informed decisions about whom to work with on which task and how to organize the resulting pair programming session.
in the following sections we first summarize related work section .
we then describe our data collection and analysis method section and discuss the classification of knowledge needs that is central for the present work section .
we explain the idea of pair constellations and our finding how they in general lead to the overall session dynamics section .
we describe five prototypes of such session dynamics with examples section .
we discuss the validity our results and describe our first attempts at putting them to practical use with industrial practitioners section before we conclude section .
related work .
pair programming effectiveness pair programming studies in education focus on learning outcomes more than economic aspects of improved code quality and effort.
a meta analysis has shown a positive effect of pair programming on assignment and exam scores .
in industry the focus is on ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea franz zieris and lutz prechelt effort spent and quality produced.
here a meta analysis found mere tendencies and a lot of between study variance.
arisholm et al.
s large quasi experiment could not determine consistent moderating effects of task complexity and individual developer expertise on pair performance.
however experimental studies are strongly unrealistic in industrial contexts it takes years to learn the specifics of a project and become fully productive .
pp appears to require some of that learning to have happened before but can then help with the rest .
the pair members traits e.g.
personality type as such appear to have little impact on the effectiveness of pp performance and even individual performance does not predict pp performance well so it appears to be important how pp partners actually work together.
.
peeking into the pair process a few qualitative and qualitative quantitative studies have looked at the pp process itself.
pp consists of a lot of discussions in which both partners verbally contribute to almost all topics with an equal share on all levels of abstraction .
chong hurlbutt observed that a more experienced pair member dominates the session while a newly hired partner would ask many questions time pressure permitting.
plonka et al.
identified experts teaching tactics nudging making suggestions instead of telling preparing the environment e.g.
opening a useful file pointing out problems instead of telling the solution gradually adding information or giving clear instructions.
jones fleming and our own prior work however has shown that knowledge transfer in pair programming is not limited to such expert novice constellations.
there are episodes of explicit knowledge transfer essentially throughout all pp sessions even expert expert constellations.
jones fleming identified four types of knowledge that pair members transfer in bug fixing sessions programming language details development tools code structure and how to reproduce a bug.
we identified four modes of individual knowledge transfer episodes pushing is explaining without prior request akin to plonka s teaching tactics pulling is knowledge transfer driven by many questions of the knowledge recipient.
co producing means both developers acquire and consolidate new knowledge together by e.g.
code reading and discussion.
pioneering production means one pair member does this alone e.g.
if the partner already knows or does not care .
pp only works well as long as the partners frequently resynchronize their ever changing session specific knowledge .
we are not aware of a characterization of pp sessions as a whole that explains what makes pair programming work or not and where the high variance seen in experiments likely comes from.
research method .
type and origin of data we analyze sessions of professional software developers working in pairs on their every day development tasks.
part of our data we draw from the pp ind repository of industrial pair programming session recordings collected by plonka prechelt salinger schenk schmeisky and zieris between and .
this repositoryid length pair session content company a content management system java objective c sql aa1 a1 a2 fix five similar bugs touching both frontend backend company b social media php javascript sql html css ba1 b1 b2 read foreign code implement cache discuss specification bb1 b1 b2 new feature from scratch template discuss requirements bb2 b1 b2 impl.
model controller template discuss requirements bb3 b1 b2 implement template controller discuss requirements company c graphical geo information system java ca1 c1 c2 implement new form in gui c1 already started ca2 c2 c5 architecture discussion c5 already started refactoring ca3 c6 c7 implement context menu entry incl.
test case refactoring ca4 c4 c7 implement selection feature w special key binding ca5 c3 c4 implement feature to split graphical elements company d estate customer relationship management java xml da2 d3 d4 planned feature impl.
turned to widespread refactoring company e logistics and routing c xml ea1 e1 e2 step by step debugging of error in route display company j data management for public radio broadcast java ja1 j1 j2 walkthrough of j2 s code discuss possible refactorings ja2 j1 j2 review of j2 s new api define requirements company k real estate platform java sql coffeescript ka1 k1 k2 dev.
env.
setup discuss inter system api design 1st impl.
kb1 k2 k3 add new class to model write and debug database migration kc1 k2 k3 test env.
setup discuss test approaches for gui feature kc2 k2 k3 tr ying diff.
test approaches struggling w debugger company o online project planning coffeescript oa1 o3 o4 understand foreign component try to read state for testing oa2 o3 o4 tr y to set up parts of component for testing oa5 o1 o3 bug fix amend test cases refactor prod.
code fix the bug oa8 o3 o4 failing test investigate prod.
and test code correct mocks company p online car part resale php sql pa1 p1 p2 walkthrough of db migration written by p1 discuss req.
pa2 p1 p2 test of migration debugging refactor test cases pa3 p1 p3 implement new api endpoint w tests p3 already started pa4 p1 p3 implement db access with or mapper sessions aa1 to kc2 were selected from the pp ind repository oa1 to pa4 were recorded for this study see section .
.
some sessions continue an earlier one .
sessions oa1 to oa8 are in english all others are in german.
developers c4 c6 and o3are female.
table context characterization of analyzed pp sessions contains recordings of pairs from different companies featuring developers working on many different types of tasks.
these sessions have a typical length of minutes to .
hours averaging .5h.
developers were not restricted in their choice of task and partner participation was voluntary and based on informed consent.
each session has a unique identifier such as ca2 which denotes the third company first project second session.
developers are identified by their company and an index such as c4.
each recording comprises a desktop screen capture a webcam video showing the upper bodies of the two developers and an audio track with the developers conversation.
most recordings are complemented with questionnaires with self reported developer backgrounds and developers characterization of the session s task.
for this study we recorded additional sessions in two companies o and p in similar manner featuring developers in pair and mob constellations groups of three or four .
we do not discuss mob sessions here.
see table for an overview of the sessions analyzed for this study.
additionally we conducted on and group interviews with developers scrum masters and technical managers from companies o and p in order to gather more background information and to validate our findings see section .
.
422explaining pair programming session dynamics from knowledge gaps icse may seoul republic of korea all companies a to p develop their own software product inhouse so that the application domain is stable for the developers.
this is different for consulting companies whose developers more often encounter a new application domain.
for validation we also conducted individual and group interviews with developers and technical managers in two consulting companies q and r but did not record pp sessions .
.
analysis process we base our research method on the grounded theory methodology gtm in its straussian form .
in particular we make use of the practices of open coding axial coding and selective coding chapters we applied theoretical sampling to focus more on the interesting phenomena once we identified them and to reach theoretical saturation .
we selected sessions in the manner of theoretical sampling ch.
with different pair constellations who work on different types of tasks e.g.
implement new feature from scratch amend existing feature bug fixing module integration refactoring and other maintenance testing see table for information on the analyzed sessions.
we did not transcribe the sessions but performed our analysis directly on the video material.
.
.
open coding.
during open coding data is broken down and conceptualized as what it is .
existing grounded concepts strengthened our theoretical sensitivity .
to help with reconstructing what the pair programmers are we employed the base layer for pp research .
it conceptualizes certain speech acts a set of concepts structures the pp process with utterance level granularity into so called base activities such as making and evaluating proposals or asking questions and offering explanations .
we used the base concepts to identify session segments relevant for our general interest in knowledge transfer phenomena we reuse our notions of knowledge transfer episodes andmodes push pull etc.
see section .
and as vocabulary to talk about pp processes throughout this paper.
we illustrate this with a concrete example in section .
.
.
an early result of our open coding was our operationalization ofknowledge and different knowledge types see section .
we came back to open coding and constant comparison whenever new insights from axial and selective coding required amending or adding concepts.
in this article we typeset our new concepts in blue sans serif font as such some concept for brevity we do not report on intermediate concepts.
.
.
analysis process example.
what follows is an annotated transcript from the beginning of session ea1 where developer e2explains to his colleague e1what he already knows about a display error of route segments on a map.
the software is running in debug mode execution is halted at a breakpoint.
e2 switches between source code and gui to explain the observable failure and related code segments.
the transcript is translated from the original german dialog and slightly shortened with marked developer actions and source code identifiers .
we annotate base concepts flushed right per utterance and knowledge transfer episodes with their modes semi graphically in the right margin .e2 i ll show you what i did the error is this you see the last segment has an extra point.
explain knowledge e1 yep.
agree knowledge e2 the last point should have been this one but it takes that one.
hovers two points in gui explain knowledge e1 yes.
agree knowledge e2explains ande1agrees for five minutes in this fashion.
e2 looking at source code result is the point count which gets increased here.
explain knowledge opens inspector and now it s .
explain finding before it was i guess that s the start point.
propose hypothesis e1 m hm.
agree hypothesis e2 and then were added.
explain finding and now they are in this ppoints there opens inspector they are.
explain knowledge e1 the polygon points of the route they are still in there?
ask knowledge e2 yes exactly.
this traceferry has an output parameter where the points get copied to.
explain knowledge e1 m hm.
agree knowledge e2 it s called multiple times.
it s a big array first for the stub and later it says copy starting here .
explain knowledge e1 m hm.
agree knowledge e2 and in traceferry they get copied.
explain knowledge e1 ok. agree knowledge e2 exactly.
and erm now in this ppoints array there are the points.
explain knowledge the last point should be correct now.
or it s not.
we ll see about that.
propose hypothesis inspects values yes it is the one it s doubled.
so the error is somewhere in traceferry .
explain finding e1 so you say it s actually we interrupt the route i mean takes mouse it goes here goes here goes back again and takes that as the endpoint or what?
ask knowledge e2 exactly it got all these points first then this one then that one instead of this.
explain knowledge e1 yes and goes back again.
ok. agree knowledge e2 i first thought it goes wrong here but it s not.
instead it s traceferry where it comes out wrong.
explain knowledgee2pushe1pull e1pull with a long push and two shorter pull episodes it took the pair almost minutes to get the point where e2already was.
after they reached the limits of e2 s existing understanding the pair then continues in co produce mode debugging the source code together.
our research interest in knowledge transfer led us to two questions what is the effect of this behavior?
what role does it play in the session overall?
we come back to these questions and the above excerpt in sections .
.
and .
.
to illustrate how we arrived at our concepts.
.
.
axial coding.
inaxial coding one considers the conceptualized behavior what phenomena it is directed at its context and its consequences .
in our case the behavior is pair programmers transferring knowledge in episodes and the phenomena are perceived knowledge gaps pertaining to different knowledge types.
as the relevant context for all their in session behavior we identified the developers knowledge needs resulting from their individual pre existing knowledge and the specific demands of their task see section .
we did not consider higher levels of the conditional matrix such as team or company.
423icse may seoul republic of korea franz zieris and lutz prechelt .
.
selective coding.
selective coding is the integration of concepts to a theory around a central narrative under systematic consideration of context properties .
we identified systemspecific knowledge s as the most important knowledge type and generic software development knowledge g as another see section .
.
our pairs also talked about other types of knowledge such as their application domain or aspects of the company culture but these were rare and had little relevance in their sessions.
we considered pair constellations based on the developers knowledge needs regarding the two dimensions sandgwhich led to six recurring initial constellations see section .
across all these we identified three common prototypes of session dynamics see section .
.
.
validation and theoretical saturation.
we validated our findings with our subjects in companies o and p and as another round of theoretical sampling with developers and technical managers from consulting companies q and r for whom knowledge of the application domain presumably works differently section .
theoretical saturation is reached when collecting fresh data no longer sparks insights with regard to new properties of the central concepts .
our discussions with companies o p q and r brought no new facets regarding our concepts to light so we reached theoretical saturation in this sense.
knowledge needs we do not a characterize developers as experts or novices but consider their concrete situation in a pp session.
they work on some task with specific knowledge demands and bring some body of existing knowledge to the table.
their task is not necessarily welldefined and can be modified explicitly or implicitly as the session proceeds.
depending on the pair s design decisions for instance different areas of knowledge become more or less relevant.
these decisions in turn may depend on what the developers know and do not know.
considering all that happens in a pp session each developer has an overall knowledge need her gap in knowledge with regard to the current task which we operationalize as follows direct operationalization individual knowledge transfer episodes have a topic .
when developer a explains something to developer b about some topic x and b acknowledges this explanation as seen several times in section .
.
this indicates that b had a knowledge need regarding x and a had not .
occasionally pair programmers also express uncertainty or talk about their respective knowledge levels explicitly thus marking aknowledge need.
indirect operationalization developers may not yet be aware of the extent of their knowledge need and thus do not formulate questions to trigger an explanation.
but signs like correcting an obvious mistake or being puzzled by new discoveries allow the researcher to see it.
conversely being able to formulate and evaluate proposals indicate a lower knowledge need.
for the sake of simplicity we also speak of a developer s knowledge level to refer to all the things she demonstrates to know in a pp session.
after a successful knowledge transfer episode her overall knowledge need gets lower and her level gets higher.considering not only one developer but the whole pair we call a knowledge gap either one sided ortwo sided depending on whether only one partner or both have an according knowledge need.
.
types of knowledge nearly all knowledge transferred in our pp sessions relates to solving the session s task.
at first we characterized pair members as either having a high or a low knowledge need regarding this task knowledge and later distinguished three degrees details follow .
in our data there were knowledge transfer episodes pertaining to many different types of knowledge such as the company culture and structure or the application domain.
but the vast majority of the topics across all sessions can be classified into two major types s specific knowledge is about understanding the software system at hand its requirements its overall architecture and gazillions of small facts regarding its detailed design structure test build infrastructure and procedures configuration state defects idiosyncrasies implementation gaps and so on.
g generic knowledge is about general software development methods and technology programming language details design patterns development tools and technology stacks etc.
s knowledge is mostly narrow and factual.
large numbers of sitems are typically transferred in any pp session.
in contrast g knowledge is more widely applicable but much fewer gitems are typically transferred in a pp session.
the following subsections provide first for s then for g a characterization for different degrees of knowledge needs.
.
s need need for system specific knowledge considering all in session activity from a researcher perspective a pair member has an overall need for s knowledge the s need.
we characterize three degrees of s need lows need the developer provides explanations about the current state to her partner she alludes to things not yet seen in the session and she evaluates findings explanations and hypotheses proposed by her partner.
she does not ask questions about s knowledge and is rarely puzzled by new discoveries.
mids need the developer has some knowledge about the system in general but not enough about the particular area relevant for the task.
for instance she may be not up to date with recent changes in that area.
the developer may acknowledge her lack of knowledge and proposes to look into things or formulates hypotheses.
alternatively if she is not aware of her lack of s knowledge or does not act on it she might make proposals that are misled and which her partner rejects thus pointing out the s need.
high s need the developer knows barely anything about the system s relevant parts.
she acknowledges her lack of knowledge and asks her partner about the system.
she does not refer to system parts or properties until the pair has looked at them.
proposals and hypotheses coming from the partner are not evaluated.
the degree of s need depends on prior involvement with the relevant parts of the system e.g.
authorship on forgetting details and many specifics of the current task.
424explaining pair programming session dynamics from knowledge gaps icse may seoul republic of korea .
.
analysis process example c d but how did we find the s need concept?
as explained in section .
.
we use the pair programming literature to increase our theoretical sensitivity.
salinger et al.
for example identified the role of a task expert who provides her partner with task relevant knowledge.
in the example from section .
.
developer e2would be the task expert who explains all he knows about the bug.
however our first question what is the effect of this?
cannot be answered from this perspective.
it occurred to us that what matters here is the partner e1 who gains system understanding the beginning of the session ea1 is about addressing hiss need.
.
g need need for generic software development knowledge again we distinguish three degrees of g need based on the developer s behavior lowg need the developer is able to explain the meaning of programming language idioms or how to use certain libraries or tools if need be.
she does not ask questions in this regard.
midg need the developer asks informed questions about the used technology or the development approach and occasionally reads in the documentation.
high g need the developer asks fundamental questions concerning programming language standard libraries or basic tools and or uses documentation extensively.
she might also express uncertainty and verbalize a lack of ideas on how to proceed.
by these terms experts and novices would be developers with low and high g needs respectively for the majority of tasks in their job.
the same developer will often have different degrees of s need and can have different degrees of g need for different tasks.
in practice a developer s gands needs are not independent.
for an individual developer and a given task the combination of perfect system understanding low s need and no applicable general development knowledge high g need is unlikely since understanding a system without having a grasp of the used technology is difficult.
having a low g need and high s need on the other hand is plausible and may lead to quick acquisition of s knowledge.
pair constellations and session dynamics .
session context and goal initial and target constellation with respect to a specific development task each developer has a degree of sandg need possibly changing over time.
a pp situation can thus be characterized by each developer s momentary sandg needs.
for systematically solving a task the pair needs to address its s need and attain complete understanding of the system s taskrelevant aspects.
depending on the goal of the particular session the pair has one or more options to break this down to the individual level meeting the s need is often desirable for both developers e.g.
if they are expected to be able to work on similar tasks alone or with a different partner in the future.
in other cases the pairsare content with only one developer meeting her s need leaving a one sided sgap between the partners.
in contrast to s not all g needs have to be addressed in a session.
more complete g knowledge facilitates important steps such as addressing an s need designing a good solution implementing and debugging that solution smoothly.
filling a ggap may be part of the session goal e.g.
for training purposes.
from a researcher s perspective pair programmers begin a session with an initial constellation of each partner possessing some sandg knowledge plus a more or less clear idea of the session task i.e.
what they want to achieve with their session.
the task might be for example fixing a problem for which s needs have to be met or educating the partner addressing an sand or g need in some respect .
the intended outcome of a session in terms of sand g needs to be met denote the session s target constellation.
.
constellation changes overall knowledge gaps tend to shrink during a session.
it is important for a pair to become aware of knowledge gaps but in our terminology their gands need are not affected by such insights alone.
in principle pairs can take two approaches to deal with knowledge gaps they are aware of limiting the scope of the current task thereby making some of their sand or g needs obsolete or transferring existing or acquiring new knowledge to address their respective sorg needs.
as for in our data a pair s initial session scope discussion is often not recorded.
but our developers also sometimes decide during the session that some subtask is not mandatory and stop pursuing it e.g.
in the beginning of session bb1 section .
.
or they may shift their focus mid session thus effectively changing what knowledge is relevant e.g.
in da2 which should have been a feature implementation but pivoted to a large refactoring .
as for the remainder of this paper is concerned with this approach only that is with knowledge transfer.
.
overall session dynamics in all analyzed sessions the pairs first deal with a one sided s gap if one exists then with any two sided sgap both limited by their awareness of these gaps.
we therefore call these the primary gap and the secondary gap .
the target constellation acts as a moderator for both steps in case not both developers need to reach high s knowledge parts or all of the primary andsecondary gap may remain unfilled.
once the s needs are met to the intended degree and only then the pair transfers or does not g knowledge if one partner has a g need the g opportunity.
different orders appear to be the exception if neither partner possesses required g knowledge two sided ggap the pair will have to acquire it together and this can happen when a secondary gapis still open.
if two sided sandggaps are large enough the pair may become overwhelmed by difficulty.
the session then breaks down and no or nearly no progress happens.
.
.
analysis process example c d how did we find the concepts of primary andsecondary gap?
remember section .
.
where we discussed e2 s bug related explanations to e1and our second question what role does it play in the session overall?
425icse may seoul republic of korea franz zieris and lutz prechelt considering the session ea1 as a whole the long running push episode in the beginning enabled the pair to work as peers to then solve the actual task together.
in our data this is common behavior in the beginning of a session especially when one developer already worked on the task before.
it occurred to us that these pairs start with an asymmetric situation regarding their s needs and they turn it into a symmetric one which allows them to make further progress closely together co produce episodes in the case of ea1 .
so achieving s need symmetry comes first closing the primary gap acquiring the remaining s knowledge together follows closing the secondary gap .
.
session visualizations below we will provide schematic representations of pairs knowledge constellations and their trajectory throughout several example sessions .
each developer is represented by a point on a two dimensional coordinate system with the degree of g need decreasing from left to right and the degree of s need from bottom to top.
in a qualitative sense the vertical distance between a pair s two points hence represents the primary gap the distance from the top represents the secondary gap and the partner s horizontal distance represents the g opportunity.
the pair s points are drawn at their initial constellation.
the reduction of knowledge gaps is indicated by arrows originating at the developer whose understanding improves upward for increasings knowledge to the right for improved g knowledge.
multiple arrows starting at the same height indicate multiple attempts made to address a knowledge need.
the trajectories do not depict technical progress at all.
arrow length does not represent time at all but only the qualitative!
reduction of a knowledge gap.
arrow color indicates the mode in which the knowledge gap is narrowed see section .
and for details .
the numbers in the trajectories correspond to numbers in the article text.
for readability a single arrow e.g.
might represent multiple knowledge transfer episodes pertaining to similar topics.
session dynamics prototypes we will now describe how pairs actually deal with their knowledge needs we have identified six different initial constellations in our data each having a different combination of primary andsecondary gaps andg opportunity each leading to a characteristic session dynamic.
these form a set of session dynamics prototypes that is very useful to understand how pp works and when and for which goals it is most useful.
see fig.
for the initial constellations of all analyzed sessions.
other initial constellations are conceivable but we have not seen them.
.
no knowledge gaps no opportunity in many pair programming sessions there is a point at which both partners have all necessary system understanding as well as all needed general programming knowledge to work productively on the task.
this is the no relevant gaps constellation see fig.
.
the only pair we have seen that had this as its initial constellation forms our first and simplest example.
.
.
example greenfield development.
developers b1andb2 work on a new feature from scratch over the course of one afternoons need g need highhigh midmid lo wlo wno relevant gaps one sided g gap complementary gaps one sided s gap t wo sided s gap t oo big two fold gapbb1bb2bb3 k c2 p a3p a4 ca1 d a2kb1 ja1ja2 ea1ca2ca4 p a1k c1 aa1 ba1 ca5ca3 o a5 p a2ka1o a8 o a1o a2 sandg need denote a developer s gap in task relevant knowledge with regard to the specific software system and generic software development respectively see section .
.
each pair of points represents one pp session see table sessions are grouped in six recurring pair constellations.
figure initial pair constellations of the analyzed sessions in three sessions bb1 to bb3 with short pauses in between.
both are proficient in the involved technologies and need to interact with existing code only through few and well understood interfaces neither snorg need .
the newly developed code stays small enough to be fully understood by both developers at all times.
apart from a short orientation phase in the beginning when they decide on where to visually place the feature in the gui they are in construction only mode throughout the session i.e.
defining requirements and discussing design proposals with zero debugging.
b1andb2develop no s need through all three sessions while the body of s knowledge increases along the way.
.
.
discussion.
this nice and easy initial constellation is likely only in development from scratch situations which are not frequent.
it is fragile and can be destroyed by any lengthy debugging episode or by between session pauses long enough to let developers forget relevant details of what they built.
.
dealing with a one sided sgap in some pair programming sessions one developer has an sadvantage e.g.
because she already started work on the task.
two constellations have this property one sided s gap andcomplementary gaps each of which happened to be the initial constellation of five our analyzed sessions see fig.
.
whenever a one sided sgap the primary gap exists the pair addresses it first.
in most cases the developer with the larger s need is aware of the gap and the pair can address it proactively as illustrated in section .
.
.
if however she is not aware of her s need she 426explaining pair programming session dynamics from knowledge gaps icse may seoul republic of korea s g example ea1 e1e2 s g example ca2 c2c5 s g example aa1 a1a2 s g example pa3 pa4 p3 p1 s g example ja1 j1j2 s g example ca1 c1 c2 s g example kc2 k2 k3 s g example oa1 o3 o4 sandgdenote a developer s task relevant knowledge with regard to the specific software system andgeneric software development respectively.
arrows indicate mode of knowledge transfer solid line blue pull developer asks about topic of interest.
dashed line red push developer receives not explicitly requested explanations.
dotted line green pioneering developer acquires new knowledge through reading source code inspecting artifacts.
double line black co production both developers acquire new knowledge in a tightly coupled fashion corresponding arrows are connected with a thin line .
numbers refer to descriptions in main text.
figure trajectories of discussed examples example bb1 to bb3 has no relevant gaps might make poor or non applicable proposals which need to be identified as such.
this can take some time and be frustrating for the developers see section .
.
.
.
.
example bringing partner into ongoing work.
in session ea1 developers e1ande2want to fix a bug which e2has already worked on before more s knowledge than e1 .
so e2steps through the code with a debugger demonstrates the failure in the running application and comments on the state of individual variables pushes .
his partner e1asks for details pulls .
they quickly close their primary gap phase and continue debugging together .
we already discussed phase in the analysis process example in section .
.
see also fig.
for the numbers.
.
.
example closing the primary gap painfully.
in session ca2 c2andc5want to implement a new feature for just one edition of their software.
c5has already started the implementation and is familiar with the system modularization low s need .
c2 does not know c5 s recent changes additionally some aspects of the system s architecture have slipped his mind mid s need .
it takes the pair frustrating minutes and multiple attempts to close their primary gap refer to numbers in fig.
c5tries to explain his recent changes and alludes to the underlying architecture that motivated them.
c2does not engage in these push episodes he does not listen to c5at all and keeps hushing him.
instead c2starts reading the source code pioneering which leaves him puzzled several times because he is not aware of the underlying rationale.
c5tries to follow c2 s mostly silent reading process and intersperses architectural explanations spushes .c2 however appears to misinterpret these as a discussion of general design principles which would be gpushes and ignores them.
this continues until c2eventually recognizes the underlying system structure and finally understands c5 s changes from before the session.
with their primary gap closed the pair continues in a two sided s gap constellation and works on their secondary gap .
.
.
discussion.
the most common way how pairs address their primary gap appears to be that the partner with more s knowledge starts a push into which the partner hooks in pulling for details.
in many sessions e.g.
ca4 ea1 ja1 and pa1 this is enough to close the primary gap.
if the pair member with more s knowledge does not provide good explanations in push mode her partner with the s need may take the lead with a more interview style pull driven mode e.g.
in sessions ca1 and da2.
if this is not enough to close the primary gap either the partner with the s need may switch to reading up the necessary information herself pioneering .
in session da2 such a switch was necessary when a partner could not explain well because of his lack of relevant g knowledge.
developer c2above however appears to generally 427icse may seoul republic of korea franz zieris and lutz prechelt prefer to pioneer for closing a primary gap even though his partner is willing and able to provide suitable information.
closing aprimary gap was the only setting where we observed issues due to presumed personal preferences.
.
dealing with a two sided sgap pairs that have no member with all relevant s knowledge need to find ways to acquire it to close their joint sgap.
such a secondary gapappears to be common eight of our analyzed sessions had a two sided s gap as their initial constellation see fig.
many others reached this constellation after closing their primary gap.
.
.
example pairing up throughout.
in session aa1 developersa1anda2want to fix five similar bugs and need to work with two different sub systems neither of which is fully understood by either partner.
since they both want to meet their s need they keep their understanding in sync along the way.
their session illustrates a number of ways how pairs can deal with their secondary gap see fig.
for the numbers co produce most of the time a1anda2address their secondary gap collectively in co produce episodes where they formulate hypotheses about the system read source code try out the application and integrate their insights.
pioneer plus push the developers disagree on the relevance of some stopics.
a2occasionally pursues a pioneering episode and afterwards explains what he learned push .a1 hardly opposes a2 s initiatives as some of them lead to taskrelevant insights which the pair probably would have missed otherwise.
co produce plus push during later co produce episodes sometimes one developer is faster at understanding something than the other a1 is more proficient in one sub system a2in the other .1in such cases the faster developer would push explanations for his partner to catch up.
.
.
discussion.
for closing a secondary gap co producing is common behavior in many sessions e.g.
ca1 ca2 and ja1 .
if one pair member understands faster e.g.
due to a gadvantage as in session ca1 discussed below or a local sadvantage in some area as in session aa1 a co produce plus push makes sure no partner falls behind.
if the developers have different goals or preferences not all topics need to be understood fully by both and the more invested pair member may pioneer plus push.
occasionally this also happened in other sessions such as ja1 discussed below .
.
opportunity reducing a one sided ggap a difference in g knowledge between the partners can be an opportunity to transfer valuable general software development knowledge.
in our sessions pairs never seized their g opportunity before any known primary gap andsecondary gap were closed.
some pairs started from a one sided g gap e.g.
in sessions pa3 and pa4 others from a complementary gaps e.g.
ja1 or da2 or two sided s gap e.g.
oa5 .
1one could split the sdimension for characterizing pair constellations that are complementary with regard to different parts of s potentially leading to as many sdimensions as there are topics.
to keep the discussion tractable we do not do this.
.
.
example initially misunderstood teaching.
in sessions pa3 and pa4 see also fig.
frontend developer p3and backend developer p1work in the backend of their system.
both know the relevant parts of the system well no secondary gap but p3already started implementing a new api endpoint small primary gap .
since they are on p1 s technological home turf no g need he understands p3 s explanations quickly and the primary gap is soon closed .
from thereon p1explains the newest php language features and how to employ test driven design whenever he sees an opportunity gpushes .
in session pa3 p3misinterprets these explanations as a lead in for unnecessary spushes and gets confused but after talking to p1about p1 s intentions in a break he then acknowledges them as valuable lessons in session pa4.
.
.
example embracing a difference.
session ja1 is about improving the maintainability of a module that j2wrote a year earlier andj1never saw before.
the module is basically a state automaton implemented with deeply nested if statements.
in addition to a seized g opportunity this session also illustrates how one developer j1 does neither need nor want to fully met his s need as he will only ever work on that module together with j2.
again refer to fig.
for the numbers the pair deals with its primary gap via a long running push with hooked in pulls j2explains and j1asks for details.
to address their secondary gap j2repeatedly reads through the complex low level control structure and then explains the high level states and transitions of the automaton pioneer plus push .
both partners take care to keep the pushes from going into too much detail.
after j1got the big picture only a mid s need left the pair starts reading source code together reducing the secondary gapfurther through co production .
in so j2looks for code smells to explain possible refactorings gpushes thus using the g opportunity.
.
.
example missing the opportunities.
in session ca1 the pair wants to implement a new gui feature similar to an existing feature.
c1already worked on it for an hour when c2joins him.
this gives c1a modest sadvantage which needs to be addressed.
c2is more proficient with the object oriented paradigm a gadvantage .
they deal with their primary andsecondary gap but do not use their g opportunity see corresponding numbers in fig.
to close c2 s sgap c1first tries to explain what he did push .
this is not effective and c2starts to ask specific questions about existing classes pull which c1begins to answer.
but c2quickly gives up on this in favor of trying out the new gui elements and reading in the new code himself pioneering which eventually achieves the desired understanding.
later in the session the pair is able to close newly detected two sided sgaps in co production episodes.
in these cases c2is always the first to understand presumably due to his better g knowledge and often explains his findings to c1 push .
during the session there are multiple occasions at which c2could have explained some g knowledge toc1 i.e.
e.g.
how he got to his insights so swiftly or how some of c1 s proposals violate 428explaining pair programming session dynamics from knowledge gaps icse may seoul republic of korea good design.
but he does not and merely alludes to the underlying knowledge.
.
.
discussion.
while session pa3 see section .
.
was at times frustrating for p3who only received explanations but had no opportunity to provide some complementary gaps constellations such as in ja1 see section .
.
or da2 and kb1 see fig.
were mutually satisfying sessions one developer needs to understand the system s need and her colleague may help with this.
yet the developer with the s need can use her advantage to teach g knowledge.
session ca1 shows however that not all pairs in such a constellation seize the g opportunity see section .
.
.
a constructive pattern for the partner with the higher g need might be to pullforg knowledge whenever the partner does something magic without pushing.
.
two sided ggaps?
there are sometimes pp sessions where both pair members lack g knowledge needed for their task a non routine situation.
we have seen one instance of a pair attempting to acquire it session kc2 section .
.
.
if both pair members have a high s need anda high g need the pair lacks the technical background to build up the required s knowledge and faces a too big two fold gap.
we have seen this constellation twice with the same pair sessions oa1 and oa2 section .
.
.
.
.
example it s not easy!
in session kc2 see fig.
developers k2andk3want to write a test case for an auto completion feature k2implemented earlier.
they already addressed their primary gap in session kc1 before lunch and now want to programmatically simulate keystrokes.
both have a mid g need they know their tools and where to look for help but cannot implement a test case right away.
they attempt to read documentation together gco production which helps k2somewhat but not k3.
forty minutes later !
they notice this one sided ggap and close it gpush .
but they never complete their g knowledge acquisition and after two hours they give up.
the next day k3said he found a simple solution alone.
.
.
example disaster.
in session oa1 the developers were tasked to write test cases for some new functionality they did not implement and which is built with a technology they are not familiar with.
o3ando4have both a high s need and a high g need.
o3 has a slight sadvantage as she already opened and skimmed the relevant source code.
o4has a slight gadvantage since he knows a bit more about the programming language.
see numbers in fig.
.
to close the small primary gap o4has to pioneer since o3 does neither push nor react to o4 s pullattempt.
for most of the session they address their secondary gap and try to acquire s knowledge by individually reading in the source code pioneering .
at some point and for lack of better ideas high g need they together resort to printf debugging co production but do not gain much s knowledge in this way either.
the developers express confusion on fundamental issues e.g.
o3 type?
function?
i don t even know what this is.
but never attempt to address their g need.
the same pattern continues in session oa2on the same day after lunch.
the pair eventually decided to not continue with this task.
.
.
discussion.
a two sided ggap is too rare in our data to make much of it but it appears to be difficult to resolve.
in session kc2 the pair had no sgap to deal with and presumably were simply too tired to put their newly gained g knowledge to proper use.
our interpretation of session oa1 and oa2 is that the situation was so difficult overall that the pair failed to manage the combined complexity of task solving plus coordinating the pp process.
we do not expect too big two fold gap to be common as developers likely anticipate and avoid such a situation.
in the oa1 oa2 case for example the pair only tackled this task because they were the only team members available and the task had high priority.
validation and application in practice our analysis yielded two results a characterization of two types of task relevant knowledge generic software development knowledge g and system specific knowledge s and descriptions of six different pp session types based on the degrees of the developers gands needs for which we claim based on our observations of the overall session dynamic see section .
that some types make pp particularly favorable and that this fact can be useful in practice.
we will now discuss some limitations inherent in our analysis approach section .
support the g sconcepts by relating them to similar concepts in existing literature section .
and validate the session dynamics results and our usefulness claim by describing practitioner reactions to them and experience with practical industrial application of the ideas section .
.
.
limitations we only get to see knowledge that can be verbalized as opposed to tacit knowledge and so mostly deal with declarative knowledge as opposed to procedural knowledge .
in software engineering the procedural knowledge relies on a thick foundation of declarative knowledge so this is hardly a problem at all.
we only get to see knowledge in transfer that is actually verbalized but not the larger body of knowledge in use.
the difference is smaller than it sounds because in practice there is almost always some difference in understanding between pair members that leads to a verbal exchange in the context of the session.
one sided knowledge gaps are easier to see than two sided ones but we usually detect the latter as well because they become visible as uncertainty on how to proceed.
overall we found no indication that either of is problematic but they make it impossible to be sure that developers always address primary andsecondary gaps when they exist.
but if they address them they do it in that order.
furthermore all our developers and work context were western.
we have not seen all kinds of software engineering settings e.g.
no consulting contexts .
however our data comes from nine different application domains.
429icse may seoul republic of korea franz zieris and lutz prechelt .
gandsin existing literature the likelihood that the concepts gandsare contrived is lower if other people report on similar concepts so we integrate them back into existing literature .
jones fleming also investigate knowledge transfer in pp.
they identified general development knowledge pertaining to tools and programming language and project specific knowledge about code structure and bug reproduction as different knowledge types which get transferred.
in our terminology which we developed independently these would be parts of gands knowledge respectively.
furthermore jones fleming are only concerned with explicit teaching i.e.
only pushing but no pulling co producing orpioneering of such knowledge.
many studies postulate the importance of s knowledge.
for example the whole subfield of program comprehension revolves around acquiring s knowledge .
sillito et al.
analyze the types of questions developers ask about their code base and characterize how well current tools support extracting information from it.
in contrast fritz et al.
acknowledge the value of another developer as an information source and provide a tool that identifies s knowledgeable colleagues in a task specific manner.
salinger et al.
identify the task expert role in some pp sessions who may provide the s knowledge to close the primary gap.
.
validation with practitioners glaser strauss argue and strauss corbin agree that a grounded theory meant for practical application needs to be understandable to people working in the respective area and should allow the user some control over daily situations.
we first validated our concepts by presenting them to practitioners from four companies two of which are consulting firms q and r we approached because our analysis was based on companies with in house development only.
then we also validate three ideas of how to put our findings to use in everyday development practice.
we mark each validation result as positive negative or half positive .
.
.
validation of concepts.
we discussed the two dimensions of developers task specific gands knowledge five initial pair constellations 2and particular session trajectories in interviews with groups of various sizes two scrum masters sm and product owner po in company o after recording the oa sessions six developers d sm and po in company p before recording the pa sessions ten d sm and two technical managers tm in company r and a on interview with a tm in company q. the two dimensions were understood in all discussions.
the o sms immediately started to characterize their developers as to their typical gandslevels o po used the dimensions to characterize recent difficulties across all teams as a collective g gap .
to q tm the classic expert vs. novice is too simplistic too naive offensive even whereas sandg resonate better they get better to the heart of the matter he found thinking about resolving an s gap or a g gap?
more compelling than am i a novice?
.
the five constellations were quickly understood.
o sm and o po independently identified complementary gaps as interesting 2we had not yet seen one sided g gap.as the most real and valuable pairing o po a p d and q tm recognized it from recent experience of working together with different roles such as system administrator or as a common consulting theme.
o po found it useful to have names for the constellations.
q tm had recent experience with four constellations but not with too big two fold gap.
nevertheless after just seeing the too big two fold gap picture he immediately comprehended the issue tricky isn t it?
the developers do not get very far.
in consulting companies q and r we wanted to assess the importance of application domain knowledge a possible third type d so we asked for types of relevant knowledge before presenting theg sdimensions.
we learned that d knowledge is seen to have little impact on pp session dynamics several r ds explained that there are only small d knowledge differences within their team but sometimes gaps which only the non technical client can fill.
the far more serious issue is their overall lack of s knowledge as due to the legacy system a developer with a mid s need is already considered a rare expert .
they pair program to carefully build up and maintain s knowledge.
q tm ranked the problems imposed by g knowledge lowest because g knowledge can be hired if needed or be built along the way through pair rotation.
while the dimensions g swere understood the task specificity of a developer s knowledge need was not.
instead both developers and managers tended to think of programmers as having a relatively fixed experience based level with little changes over the course of a session.
unfortunately without the task specific understanding of sandg needs the pair constellations can no longer be recognized as a valuable tool for forming effective pairs.
.
.
validation of practical ideas.
with these four companies we also discussed three practical ideas for putting our findings to use in everyday software development all of which would involve a g s chart consider task specific knowledge when forming pairs p. set goals and orient during a pp session and reflect on a pp session after the fact.
forming pairs we firmly expect our findings to be useful for forming effective pairs but due to point although many respondents tended to like the idea none of them reacted enthusiastically in this respect.
some were mostly positive but raised practical concerns p po said their teams are too small to regularly offer more than one pairing to chose from.
o po believed all their pairings would have the same constellation.
setting session goals before starting session pa4 we asked developers p1andp3to discuss and draw onto a blank g s chart their initial and their target constellation.
they quickly agreed on a one sided g gap with no primary andsecondary gap and the goal to address p3 s g need regarding an or mapper.
after the session both explained that filling out the chart did not affect their session butcould have had there been discrepancies in their respective knowledge need assessments to be resolved.
reflecting on a session we individually asked the developers after sessions pa1 pa2 same pair same day and pa3 different pair to trace out their trajectory and to discuss the results without us intervening.
in both cases the pairs had actually seized their g opportunity during the session but only remembered the primary andsecondary gaps.
the gtransfer resurfaced during the reflection p3 right i totally forgot about that.
that was really cool.
430explaining pair programming session dynamics from knowledge gaps icse may seoul republic of korea concept description s knowledge g knowledge system specific knowledge requirements overall architecture detailed design structure test build infrastructure defects idiosyncrasies implementation gaps etc.
and generic software development knowledge programming language details design patterns development tools and technology stacks etc.
see section .
.
knowledge need degree of individual developer s knowledge gap resulting from her existing knowledge and the specific demands of the task.
may pertain to either knowledge type s andg need see sections .
and .
.
one sided two sided gap characterization of a pair either only one pair member or both partners have a knowledge need in some regard.
initial target constellation constellation of the developers each with her individual sandg needs which they assume at the beginning of their session and which they want to achieve with their session respectively.
we identified six recurring constellations see section .
and fig.
no relevant gaps neither partner has an sorg need rarely the initial constellation the target constellation in most cases section .
.
one sided s gap one has an unmet s need e.g.
when joining a partner who already started sometimes also target constellation sec.
.
.
two sided s gap both lack system understanding initial constellation e.g.
for debugging tasks not a target constellation section .
.
one sided g gap one partner has an unmet g need opportunity to transfer g knowledge in absence of s need section .
.
complementary gaps one partner has an sadvantage the other for g satisfactory session possible due to mutual learning section .
.
too large two fold gaps both have high sandg needs difficult and undesirable constellation section .
.
overall session dynamics three prototypes of session dynamics describing pairs trajectories from all initial constellation changes section .
.
.
closing the primary gap narrow a one sided sgap between the developers either through pro active explanations an interview mode or through solitary reading of the less knowledgeable partner section .
.
.
.
closing the secondary gap narrow a two sided sgap of both developers by building understanding together and staying in sync section .
.
.
.
seizing the g opportunity narrow a one sided ggap between the developers after any s need has been addressed sufficiently section .
.
.
table overview of our grounded concepts conclusions and further work our qualitative analysis of real world industrial pair programming sessions from nine companies led to the following results the expert novice discrimination used in much existing pp research is not useful.
one must consider task specific knowledge and discriminate sandg knowledge section .
.
the overall knowledge transfer dynamics of all pp sessions follows a single pattern synchronize s knowledge acquire needed s knowledge together possibly transfer g knowledge section .
.
by far most knowledge transfer activity in a pp session concerns s knowledge.
one sided sgaps can require multiple attempts to resolve section .
.
in contrast resolving onesided ggaps is usually optional section .
.
resolving two sided sgaps are a bread and butter activity in pp and pairs do it routinely section .
whereas two sided ggaps appear to pose difficulties section .
.
in summary there is plenty of evidence that differences in s knowledge differences are more important those in g knowledge s needs are addressed first more knowledge transfer is concerned with s knowledge resolving s need is more often mandatory and s knowledge transfer is the type that pairs are more skilled with.
general programming experience differences are overrated.
our initial attempts at putting these results to practical use have shown that further work will need to create a better didactic concept to communicate the task specificity of sandg needs.
only once this is solved we will be able to demonstrate the insights usefulness by selling pp to teams not currently using it at all.
presumably those teams do not recognize which are the pair constellations or tasks when pp is going to be most useful.