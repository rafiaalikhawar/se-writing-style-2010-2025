accelerating javascript static analysis via dynamic shortcuts extended version joonyoung park korea advanced institute of science and technology daejeon south korea gmb55 kaist.ac.krjihyeok park korea advanced institute of science and technology daejeon south korea jhpark0223 kaist.ac.kr dongjun youn korea advanced institute of science and technology daejeon south korea f52985 kaist.ac.krsukyoung ryu korea advanced institute of science and technology daejeon south korea sryu.cs kaist.ac.kr abstract javascript has become one of the most widely used programming languages for web development server side programming and even micro controllers for iot.
however its extremely functional and dynamic features degrade the performance and precision of static analysis.
moreover the variety of built in functions and host environments requires excessive manual modeling of their behaviors.
to alleviate these problems researchers have proposed various ways to leverage dynamic analysis during javascript static analysis.
however they do not fully utilize the high performance of dynamic analysis and often sacrifice the soundness of static analysis.
in this paper we present dynamic shortcuts a new technique to flexibly switch between abstract and concrete execution during javascript static analysis in a sound way.
it can significantly improve the analysis performance and precision by using highlyoptimized commercial javascript engines and lessen the modeling efforts for opaque code.
we actualize the technique via safe ds an extended combination of safe and jalangi a static analyzer and a dynamic analyzer respectively.
we evaluated safe dsusing official tests of lodash library.
our experiment shows that safe ds is .
xfaster than the baseline static analyzer and it improves the precision to reduce failed assertions by .
on average for opaque functions.
ccs concepts software and its engineering software testing and debugging .
keywords javascript static analysis dynamic analysis dynamic shortcut sealed execution both authors contributed equally to the paper.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
reference format joonyoung park jihyeok park dongjun youn and sukyoung ryu.
.
accelerating javascript static analysis via dynamic shortcuts extended version .
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
introduction over the past decades the rise of javascript as the de facto language for web development has expanded its reach to diverse fields.
node.js supports server side programming react native and electron produce cross platform applications and moddable and espruino provide javascript environments in micro controllers for iot.
such wide prevalent uses place javascript at programming language in the tiobe programming community index1.
thus researchers have developed static analyzers such as jsai tajs wala and safe to understand behaviors of javascript programs and to detect their bugs in a sound manner.
however static analysis of real world javascript programs suffers from immensely functional and dynamic features of javascript such as callback functions first class property names and dynamic code generation.
while they provide flexibility in software development it is challenging to statically analyze such features.
to overcome these problems researchers have proposed several analysis techniques advanced string domains loop sensitivity analysis based on property relations and on demand backward analysis .
at the same time javascript host environments require excessive manual modeling of their behaviors for static analysis.
because built in functions and host dependent functions are implemented in native languages like c and c instead of javascript their code isopaque during static analysis.
thus static analyzers often model their behaviors manually which is error prone tedious and laborintensive.
while researchers have proposed automatic modeling techniques since they utilize only type information they generate imprecise models compared with the manual approach.
to alleviate these problems researchers have leveraged dynamic analysis during static analysis.
unlike static analyzers that run on their own interpreters dynamic analyzers such as jalangi and jun 2021esec fse august athens greece park and park et al.
figure performance of a dynamic analyzer and a static analyzer for a subset of the sunspider benchmark dlint run on highly optimized commercial javascript engines which makes them much faster than static analyzers.
figure shows that the dynamic analyzer jalangi is .8x faster than the static analyzer safe for a subset of the sunspider benchmark that is input independent and deterministic.
using high performance dynamic analysis researchers have reduced the scope of static analysis and constructed initial abstract states and automatic modeling of opaque code .
unfortunately existing techniques using dynamic analysis for static analysis have two limitations they do not fully utilize the high performance of dynamic analysis and they sacrifice the soundness of static analysis.
most of them are staged analyses which first extract specific information via dynamic analysis and utilize it in static analysis.
sch fer et al .
identify determinate expressions that always have the same values at given program points wei and ryder extract dynamic values to change expressions to certain literals and park et al.
dump the initial states of a certain host environment or the entry of an event handler.
however because they do not utilize dynamic analysis as soon as static analysis begins they do not get performance benefits since then.
moreover they sacrifice the soundness of static analysis by performing dynamic analysis.
for example the sra model uses dynamic analysis for opaque code with abstract arguments during static analysis.
when the abstract arguments represent an infinite number of values it randomly samples finite concrete values for the abstract arguments which makes the analysis result unsound due to missing concrete values.
in this paper we present dynamic shortcuts a new technique to flexibly switch between abstract and concrete execution during javascript static analysis in a sound way.
during static analysis one can take a dynamic shortcut which consists of three parts converting the current abstract state to its corresponding sealed state performing sealed execution on the sealed state and converting the result of the sealed execution to its corresponding abstract state.
our key observation is that we can use the fast concrete execution for specific program parts while preserving the soundness if they do not use abstract values.
for example consider static analysis of the following javascript code var v ... an abstract value var obj p1 v y p x obj because ystores a string p the expression y evaluates to a string p1 and x obj assigns the abstract value of vstoredinobj.p1 to the variable x. note that even though objcontains an abstract value v because the third line does not use the value of vbut only passes it to the variable x we can concretely execute the code.
based on this observation we introduce sealed execution which is concrete execution using sealed values .
a sealed value is a symbol that represents an abstract value in sealed execution it signals the end of the current dynamic shortcut when the sealed execution tries to access its value.
to evaluate our technique we implemented safe dsusing safe and jalangi and analyzed official tests of lodash library.
the contributions of this paper include the following we present a novel technique for javascript static analysis to leverage the high performance of dynamic analysis using dynamic shortcuts.
we formally define the technique and prove its soundness and termination.
we actualize the proposed technique in safe ds an extended combination of safe and jalangi.
for empirical evaluation we analyzed official tests of lodash library.
the experiment shows that safe dsoutperforms safe .
xon average.
moreover by using dynamic shortcuts instead of manual modeling for opaque functions safe dsimproves the analysis precision to reduce failed assertions by .
on average.
in the remainder of this paper section explains the motivation of this work with a simple example.
section formalizes the language agnostic part of the technique in the abstract interpretation framework.
then we extend the formalization with javascript specific features in section .
section describes important details of the safe dsimplementation.
we explain the evaluation results ofsafe dswith real world benchmarks in section .
section discusses related work and section concludes.
motivation this section explains the motivation of dynamic shortcuts using real world examples in figure .
we describe their behaviors and explain how we can utilize dynamic shortcuts during static analysis.
figure a shows the concat function defined in lodash library v4.
.
it is the most popular npm package2and npm packages have a dependency on it.
the concat function creates a new array concatenating given arrays or values.
it first checks the length of arguments on lines .
then it stores the first argument toarray on line and copies the remaining arguments to argson lines .
on line it checks whether array is an array object using the built in function isarray .
if so it creates a new array by copying the given array via copyarray otherwise it creates a singleton array .
finally it flattens argsvia baseflatten and pushes the result to the new array on line .
figure b and figure c show use cases of the concat function in thezoom.us site.
it is the homepage of zoom a videotelephony software by zoom video communications and it is ranked as the 15th popular web site according to alexa3in february .
dynamic shortcuts with concrete values.
when a function is called with concrete values we can perform dynamic analysis instead of javascript static analysis via dynamic shortcuts extended version esec fse august athens greece function concat var length arguments .
length if !
length return var array arguments args array length index length while index args arguments return arraypush isarray array ?
copyarray array baseflatten args a lodash s concat function function changecountry g ... if g. selectedval us state deterministic arguments of concat state .
items .
concat webinarbase .
questions .
state .
items state .
selectedval .
head .
head c. items b call of concat with concrete values function getdata e var option ... option for server connection post option .
then function e if e. total records e. total records non deterministic arguments of concat this .
pastevents .
concat this .
pastevents e. events this .
total e. total records else this .
nopastdata !
c call of concat with abstract values figure lodash library function and its uses in zoom.us static analysis.
for example changecountry in figure b is invoked when a user selects a country from a drop down list in the registration page.
it calls the concat function to update the drop down list of states or provinces on lines .
however when the user selects united states of america which is us two arguments are pre defined with deterministic values the first one is an array literal and the second one is an array of pairs of abbreviations and names of the states defined as follows webinarbase .
questions .
state .
items ... moreover thisalso has a concrete value the lodash top level object .
thus we can perform dynamic analysis by invoking concat with as its thisvalue and the above concrete values as arguments.
by skipping the analysis of the function call on lines and utilizing the result of dynamic analysis it improved the analysis performance.
dynamic shortcuts with abstract values.
even when a function is called with abstract values we can still perform dynamic analysis using sealed execution.
for example getdata in figure c is invoked when a user clicks the load more button to load more zoom events in the webinars events page.
it sends a post request to a serverproperty value evt length int a this.pasteventsproperty value 0 evt 7 evt length b e.events figure concrete objects with sealed values and receives additional events eon line .
then eight events in e.events are appended to this .pastevents using concat on lines .
however the arguments of concat are not deterministic because the event list stored in this .pastevents is continuously grown for each load and the events stored in e.events are dependent on the data given from the server.
to perform dynamic analysis with abstract values we seal abstract values with sealed values as in figure .
two sealed values evtand intrepresent an event object and an integer respectively.
then we can perform dynamic analysis successfully until line .
on line length is2 on line array points to this .pastevents on lines argsstores an array with a single object stored in e.events and on line isarray array istrue.
however dynamic analysis fails for copyarray array on line because the value of the length property ofarray is the sealed value int.
then we stop the sealed execution convert the current sealed state to its corresponding abstract state and resume the static analysis from line .
because sealed execution leverages fast dynamic analysis as long as possible the overall analysis becomes more scalable.
dynamic shortcuts for opaque functions.
as the previous two examples additionally show using dynamic shortcuts lessens the burden of modeling opaque functions from static analysis and it can even improve the analysis precision.
on line since the isarray function is a javascript built in library function it is implemented in a native language of the host environment which often requires manual modeling of its behaviors for javascript static analysis.
assuming that a static analyzer models isarray to return the boolean top value bthat encompasses both trueand false static analysis of the ternary conditional expression on lines analyzes both branches copyarray array and even though is never reachable in the example code.
on the contrary using dynamic shortcuts static analysis does not need to model isarray .
it can perform sealed execution for isarray which returns a more precise result truethan b. dynamic shortcuts in this section we formally define static analysis using dynamic shortcuts by introducing sealed execution in the abstract interpretation framework.
we extend the formalization of abstract interpretation of cousot and cousot and views based analysis sensitivity of kim et al .
.
for dynamic shortcuts we define sealed execution with a sealed domain and abstract instantiation maps.
to combine sensitive abstract interpretation and sealed execution we define a combined domain of sensitive abstract domain and sealed domain and explain it with a simple example.
finally we proveesec fse august athens greece park and park et al.
l0if x l1x x else l2x x l3x x l4 figure negation of the absolute value of x the soundness and termination property of abstract interpretation using the combined domain.
.
concrete semantics we define a program pas a state transition system s s .
a program starts with an initial state in s and the transition relation s sdescribes how states are transformed to other states.
a collecting semantics jpk s s consists of reachable states from initial states of the program p. we can compute it using a transfer function f d das follows jpk limn fn d f d d step d where the concrete domain d p s is a complete lattice with and as its join meet and partial order operators.
the set of states d denotes the initial states s .
the one step execution step d dtransforms states using the transition relation step d d .
for example the code in figure is a simple program that calculates the negation of the absolute value of the variable x. states are pairs of labels and integers stored in x s l n. assume that the initial states are s l0 which denotes that the program starts at l0with the variable xof value .
then it executes with the following trace l0 l2 l3 l4 .
abstract interpretation abstract interpretation over approximates the transfer functionfas an abstract transfer function f d d to get an abstract semantics jpk in finite iterations as follows jpk limn f n d we define a state abstraction d d as a galois connection between the concrete domain dand an abstract domain d with a concretization function and an abstraction function .
the initial abstract state d d represents an abstraction of the initial state set d d .
the abstract transfer function f d d is defined as f d d step d with an abstract one step execution step d d .
for a sound state abstraction the join operator and the abstract one step execution should satisfy the following conditions d d d .
d d d d d d .step d step d a simple example abstract domain is d p with set operators as domain operators denotes negative integers positive integers and 0zero.
assume that we analyze the code in figure with the abstract domain and the initial abstract state d .
then the analysis result is because xcan havea positive value by executing x xbut there is no way for xto have 0in this program.
.
analysis sensitivity abstract interpretation is often defined with analysis sensitivity to increase the precision of static analysis.
a sensitive abstract domain d d is defined with a view abstraction dthat provides multiple points of views for reachable states during static analysis.
it maps a finite number of views to sets of states d. each view represents a set of states and each state is included in a unique view s. .
.
asensitive state abstraction d d is a galois connection between the concrete domain dand the sensitive abstract domain d with the following concretization function d d with analysis sensitivities the abstract one step execution step d d is defined as follows step d .
j k d where j k d d is an abstract semantics of a view transition from a view to another view .
it should satisfy the following condition for the soundness of the analysis d d .step d j k d one of the most widely used analysis sensitivity is flow sensitivity defined with a flow sensitive view abstraction fs l d where l l. fs l l if we apply the flow sensitivity for the above example with the initial abstract state the analysis result is as follows l l0 l1 l2 l3 l4 d .
sealed execution we define sealed execution by extending the transition relation as a sealed transition relation on sealed states.
first we extend concrete states sto sealed states s by extending values v with sealed values .
we also define the sealed transition relation s s .
we use the notation k forkrepetition of and write when does not have any sealed transitions to other sealed states.
we define the validity of sealed execution as follows definition .
validity .
the sealed transition relation is valid when the following condition is satisfied for any sealed states and m m. m m where m vrepresent instantiation maps from sealed values to concrete values and mdenotes a state produced by replacing each sealed value in with its corresponding value m using the instantiation map m m.accelerating javascript static analysis via dynamic shortcuts extended version esec fse august athens greece sealed execution is different from traditional symbolic execution in that it supports only sealed values instead of symbolic expressions and path constraints.
for example the following trace represents traditional symbolic execution of the running example in figure l1 l3 l4 l0 l2 l3 l4 it first assigns a symbolic value to the variable xat l0.
for the conditional branch it creates two symbolic states with different path conditions 0and 0for true and false branches respectively.
after executing statements x xandx x the variable xstores symbolic expressions and at l3 respectively.
similarly xstores and at l4.
however sealed execution stops at l0as follows l0 because the branch requires the actual value of the sealed value .
to define an abstract domain that contains sealed states we define abstract instantiation maps m v from sealed values to abstract values.
its concretization function m m p m is defined with the concretization function v v p v for values as follows m m m .m m the instantiation of a given sealed state s with an abstract instantiation map m m is defined as follows m m m m m now we define a sealed domain as follows definition .
sealed domain .
asealed domain d p m s is defined with the concretization function d dand the sealed one step execution step d d such that d m m d step d m m d .
combined domain we now define a combined domain of a given sensitive abstract domain with the sealed domain and its one step execution.
definition .
combined domain .
acombined domain ised d d and its concretization function e ed dand join operator are defined as follows e d d d d d d d d d d d d before defining the one step execution for the combined domain we introduce analysis elements to easily configure different types of abstract states in the sensitive abstract domain and the sealed domain.
definition .
analysis elements .
ananalysis element e d m s is either a pair of a view and an abstract state in a sensitive abstract domain d or a pair of an abstractinstantiation map and a sealed state in a sealed domain d .
its concretization function e dis defined as follows d if d m if m moreover to freely convert between different kinds of analysis elements we define two converters d m s d m s while the converter is total the other one ispartial .
thus it is possible to convert an analysis element d in a sensitive abstract domain to another analysis element in a sealed domain only if the convert is defined d dom .
in addition they should convert given analysis elements without loss of information for all e now we define the combined one step execution gstep ed ed with two converters and .
it consists of two steps the reform step converts analysis elements if a new sealed execution starts or an existing one stops and the execution step performs execution of each analysis element using the abstract one step execution step in the sensitive abstract domain and the sealed one step execution step in the sealed domain.
definition .
combined one step execution .
acombined onestep execution gstep ed edis define as follows gstep ed step d step d where d d reform ed .
from a given combined state ed the reform function makes analysis elements and converts them if a new sealed execution begins or an existing sealed execution terminates.
specifically for an analysis element d in the sensitive abstract domain if the converter is defined for it reform introduces a new sealed execution by converting the analysis element to its corresponding one m d in the sealed domain.
on the other hand for an analysis element m in the sealed domain if it does not have any sealed states to transit to the sealed execution for m terminates.
it converts the analysis element to its corresponding one d m in the sensitive abstract domain and merges the current abstract state stored in withd .
to formally define the reform function we first define a reform function for analysis elements using two converters.
definition .
reform .the function reform e efor analysis elements is defined as follows reform if d dom if m otherwise definition .
reform .the reform function reform ed edfor combined states is defined as follows reform d d .
d d e e m s esec fse august athens greece park and park et al.
a notations b x c x d x n figure abstract interpretation using a combined domain for the running example with different initial values for x. where e reform d d and the dot notation fdenotes the element wise extended function of a function f. .
examples now we show examples of abstract interpretation with a combined domain.
figure depicts the flow of analysis for the running example in figure with three different initial sets of values for the variable x. in this example we use the abstract domain for integers stored in xas introduced in section .
and the flow sensitivity that utilizes the labels of states as their views as introduced in section .
.
for brevity we use concatenation of abstract values so that 0denotes the set .
figure a presents notations used in each graph.
a solid box denotes an analysis element that is a pair of a label land an abstract stated .
a pair enclosed by angle brackets denotes an analysis element that is a pair of an abstract instantiation map m and a sealed state .
in fact the sealed state part right of each pair in graphs contains only the value of the variable of xwithout its label.
for brevity we represent its label by locating it next to a node with its label.
a solid line is a view transition jl l k from a label l to another one l .
a dotted line is a sealed transition .
three solid lines with circled labels denote two converters and the join operator .
figure b shows the analysis with the combined domain when the initial value of xis0.
first in the reform step the converter converts the analysis element l0 to another analysis element with the label l0.
it does not introduce any sealed values because the value represents only a single value.
until the end of the program the sealed execution from successfully continues.
because there is no more possible sealed transition for the sealed state with l4 it is converted to l4 via the converter .
instead of a single value assume that the initial value of xis one of any positive integers.
figure c describes the analysis flow for the case.
the initial abstract value at the label l0is and it is impossible to convert it to any sealed values because the next program statement requires the actual value stored in the variable xfor the branch condition x .
thus it performs view transition jl0 l1k from the label l0to another one l1for the abstract value and the result is also .
now the analysis element l1 can be converted to with the label l1.
this sealed execution stepterminates in the label l3because the next statement is x xand the negation operator requires the actual value of x. it is converted to l3 via performs the view transition and results in l4 .
for the last case we assume that all integers are possible for the initial value of the variable xas described in figure d .
while it reaches the false branch in the label l2unlike previous cases it cannot perform dynamic shortcuts because the statement in the false branch is x x which requires the actual value of x. at the label l3 there are two analysis elements l3 introduced by the view transition from the label l2with and with l3 introduced by sealed execution started at l1.
since it is not possible to perform sealed execution for both elements the second one is converted to l3 and merged with at l3via the join operator .
finally the view transition jl3 l4k from l3to l4is performed to the merged abstract state and the result is .
.
soundness and termination the converter and the sealed transition are keys to configure the introduction and termination of sealed execution.
to ensure thesoundness andtermination of an abstract interpretation defined with a combined domain of a sensitive abstract domain and a sealed domain the following conditions should hold.
theorem .
soundness and termination .
an abstract interpretation with dynamic shortcuts is sound andterminates in a finite time if the abstract transfer function f is sound the sensitive abstract domain d has a finite height the sealed transition is valid and there existsn such that e. m k k n for soundness proof we should prove two conditions presented in section .
for the join operator and for the combined one step execution.
the core idea of the proof is to use lemma .
and lemma .
for the sealed one step execution step and the reform function respectively.
on the other hand the core idea of the termination proof is to use the property that the second and the fourth conditions provide upper bounds of the number of sensitive abstract states and the number of sealed states respectively.
we formally define and prove the property using time to live ttl functions of sealed states ttlifor each iteration i and prove the termination using them.
now we assume that its all conditionsaccelerating javascript static analysis via dynamic shortcuts extended version esec fse august athens greece in theorem .
are hold and rephrase the soundness as theorem .
andtermination as theorem .
.
.
.
soundness.
theorem .
soundness .
the abstract interpretation using the combined domain edissound if ed0 ed1 ed.e ed0 e ed1 e ed0 ed1 ed ed.step e ed e gstep ed proof.
first we prove that the abstract transfer function ef ed eddefined as ef ed ed gstep ed is sound f e ed e ed step e ed e ed e gstep ed condition e ed gstep ed condition e ef ed then the abstract semanticsgjpk limn ef n ed is also sound because it is defined with a sound abstract transfer function efusing the combined one step execution gstep.
now we should show that two conditions about the soundness of the join operator and the soundness of the combined one step execution in theorem .
hold.
first we prove the soundness of the join operator in lemma .
.
lemma .
soundness of .
ed0 ed1 ed.e ed0 e ed1 e ed0 ed1 proof.
e d d e d d d d d d d d d d d d d d d is sound d d d d e d d d d e d d d d for the condition we first prove two properties of the reform function in lemma .
.
using the properties we prove the soundness of the sealed one step execution in lemma .
.
finally we prove the soundness of the combined one step execution in lemma .
.
lemma .
properties of reform .for a given combined state ed ed the reform function satisfies the following two properties e ed e reform ed m d .
s .s.t.
where d d reform ed proof.
e ed e reform ed e d d d d d m d m !
d m d m !
d d reform d d trivially e. reform e see the definition of ein definition .
d e d !
m e m !
d e d !
m e m !
d e d !
m e m !
d e d !
!
m e m !
d ed !
!
m e m !
.
d ed !
e m s e .
d ed e m s !
e reform d d m d .
s .s.t.
for a given m d there exists an analysis element esuch that reform m .
according to the definition of reform in definition .
there are two possible cases m s .s.t or d dom .
we separately consider those two cases m s .s.t by definition s .s.t d dom by the condition in the theorem .
k .
k .
thus s .s.t lemma .
soundness of step .the sealed one step execution step is sound step d step d proof.
step d step m m d m d m m d m m m m m d m m m m second property in lemma reflemma reform esec fse august athens greece park and park et al.
m m d m m m validity of m m d m m d step d lemma .
soundness of gstep .the combined one step executiongstep is sound ed ed.step e ed e gstep ed proof.
step e ed step e d d first property in lemma .
where d d reform ed .
step d d step d step d step d step d step is sound.
step d step d and lemma .
e step d step d e gstep ed .
termination before proving the termination of the abstract interpretation using the combined domain ed we define several notations.
the initial abstract state ed d is pair of the initial abstract state of the sensitive abstract domain d and an empty set.
for each iteration i we define the i th result of abstract interpretation efi ed edi d i d i and the difference set i d i d i. for simplicity we define ias fori .
moreover we define a lifted version of sealed relation m s m s as follows m m using the lifted relation we define the time to live ttl function of sealed states ttli i nfor each iteration i 0as follows definition .
ttl function .
ttli n ifd min ttli d otherwise whered i based on the notations we formally prove the termination property as follows theorem .
termination .
the abstract interpretation using the combined domain edterminates in a finite time if n. m n.d m d n i .
i. ttli n i .d i d i sup ttli i sup ttli i proof.
by the condition there exists n nsuch thatd m d nfor allm n. by the condition the ttl of each sealed state in nis bounded by n sup ttln n n .
then the upper bound of ttl for sealed states in each difference set after the n th iteration is decreased by the condition i .sup ttln i n i sup ttln i n i .
which implies that sup ttln i n i sup ttln n i n i therefore for j n sup ttln j n j n j notice that again by the condition inf ttln j n j meaning that inf ttln j n j sup ttln j n j which implies n j andd n j d n j. therefore for all m n n d m d n n d m d n n and edm edn n which means the abstract interpretation using the combined domain edterminates in n niterations.
now we should show that three conditions about the termination of the sensitive abstract interpretation the bound of ttl for sealed states in difference sets and the decrease of their upper bounds in theorem .
hold.
first we prove the termination of the sensitive abstract interpretation in lemma .
.
lemma .
termination of sensitive abstract interpretation .
n. m n.d m d n proof.
note that for all d d d that satisfies ef d d ef d d gstep d d d d which implies d d .
since ef d i d i d i d i holds for all i .
then d 0 d 1 d 2 is an ascending chain.
since the height of the sensitive abstract domain d is finite the ascending chain condition is also hold.
therefore there exists n such that for all m n d m d n. then we prove two remaining conditions and .
we first prove two properties of difference sets in lemma .
and corollary .
and a property of ttl in lemma .
.
using them we prove the bound of ttl for sealed states in difference sets in corollary .
and the decrease of their upper bounds in lemma .
.accelerating javascript static analysis via dynamic shortcuts extended version esec fse august athens greece lemma .
.
i .
i. .
d i i .
proof.
leti nand i d i d igiven.
by definition d i d i step d i where d i reform d i d i note that step d i and by definition of step there exists some d i that satisfies .
now by definition ofreform d i reform d i d i m s this means there exists d i d ithat satisfies reform .
we have two possible cases for .
d i in this case reform and the left condition for conclusion is satisfied.
d i in this case reform .
now let s assume that d i .
in that case would be preserved after reform step that is d i .
then by definition of step step d i d iwhich contradicts to the fact that i. therefore d i that is d i d i i and the right condition for conclusion is satisfied.
corollary .
.
i .d i d i i. i .
proof.
the proof goes same as the previous lemma until the point where we divide the case for .
let s assume that the first case holds that is d i sinced i d i d i in that case would be transformed after reform step that is d i .
then by definition of step step d i d iwhich contradicts to the fact that i. therefore only second case holds and the right conclusion in previous lemma is satisfied.
lemma .
property of ttl .
i .
i.ttli k k n d .
d n k proof.
we prove by induction on i. let i. ifi ttl n nand since only left conclusion of lemma .
can hold there exists view s.t.
d 0 .
ifi we have two cases for d i .
ifd the argument is similar as i 0case.
otherwise let argmin x dttli x .
by induction hypothesis we have k ttli n and there exists d such that d n k .
by definition of ttli ttli ttli andk k .
then k k n n and n k with implies that n k .
corollary .
.
i .
i. ttli n proof.
we already proved k ttli n. now let s assume thatk .
by previous lemma there exists d such that d n k sincen k n this implies that there exists such that d n however this contradicts to the condition of that says if d is in domain of the number of possible from state of d is at mostn .
therefore k .
lemma .
.
i .d i d i sup ttli i sup ttli i proof.
let i. by corollary .
the set d i is non empty and for some i ttli ttli sup ttli i since it holds for every i sup ttli i sup ttli i dynamic shortcuts for javascript in this section we introduce the core language of javascript that supports first class functions open objects and first class property names and define sealed execution of the core language for dynamic shortcuts.esec fse august athens greece park and park et al.
p l r e rr l ee v l m c a next l m c a p l r rr l a a fresh object address l m c a next l m c a p l r ef ea rr l eef x. lb eea vaa a fresh environment address l m c a lb m c a p l rete ee v c a a l l l m c a l m c a p l ifel ee true l m c a l m c a p l ifel ee false l m c a next l m c a rr l l m c a rx a x ee0 a0 ee1 v1v1 vstr l m c a re0 a0 v1 ee v l m c a evp vp l m c a e x. l x. l rr l l dom m l m c a er m l ee1 v1 een vn l m c a eop e1 en op v1 vn figure the transition relation for the core language of javascript .
core language of javascript programs p l i labels l l instructions i r e r r e e rete ifel