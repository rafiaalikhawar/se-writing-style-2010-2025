promal precise window transition graphs for android via synergy of program analysis and machine learning changlin liu1hanlin wang1tianming liu2diandian gu3yun ma3 haoyu wang4xusheng xiao1 1case western reserve university 2monash university 3peking university 4beijing university of posts and telecommunications cxl1029 hxw458 xusheng.xiao case.edu 2tianming.liu monash.edu gudiandian1998 mayun pku.edu.cn 4haoyuwang bupt.edu.cn abstract mobileappshavebeenanintegralpartinourdailylife.asthese appsbecomemorecomplex itiscriticaltoprovideautomatedanalysistechniquestoensurethecorrectness security andperformance of these apps.
a key component for these automated analysis techniquesistocreateagraphicaluserinterface gui modelofanapp i.e.
awindowtransitiongraph wtg thatmodelswindowsand transitions among the windows.
while existing work has provided both static and dynamic analysis to build the wtg for an app the constructed wtg misses many transitions or contains many infeasibletransitionsduetothecoverageissuesofdynamicanalysisand over approximationofthestaticanalysis.weproposepromal a tribrid analysisthat synergisticallycombines static analysis dynamic analysis and machine learning to construct a precise wtg.
specifically promal first applies static analysis to build a static wtg andthenappliesdynamicanalysistoverifythetransitions inthe staticwtg.forthe unverifiedtransitions promalfurther provides machine learning techniques that leverage runtime in formation i.e.
screenshots ui layouts and text information to predictwhethertheyarefeasibletransitions.ourevaluationson40real worldappsdemonstratethesuperiorityof promalinbuilding wtgsoverstaticanalysis dynamicanalysis andmachinelearning techniques when they are applied separately.
ccs concepts theoryofcomputation programanalysis softwareand itsengineering softwaretestinganddebugging computing methodologies machine learning.
keywords mobileapps windowtransitiongraph staticanalysis deeplearning acm reference format changlinliu hanlinwang tianmingliu diandiangu yunma haoyu wang xushengxiao.
.promal precisewindowtransitiongraphs permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
android via synergy of program analysis and machine learning.
in proceedings of the 44th ieee acm international conference on software engineering icse may22 pittsburgh usa.
acm newyork ny usa pages.
introduction mobile applications i.e.
apps have become an integral part of our daily life from entertainment travel education and even tobusiness .
thus it is critical to improve the quality and reliability of these apps by developing automated analysis techniquestoensurethecorrectness security andperformanceofthese apps .
as a key component for these automated analysis techniques we focus on creating a graphical userinterface gui modelofanapp i.e.
awindowtransitiongraph wtg .
in wtg nodes represent windows and edges represent transitionsbetweenwindows triggeredbycallbacksexecutedin theguithread.forexample clickingabuttonintheguiwillresultintheexecutionofacallbackthatchangesthescreentodisplayan otherwindow.wtgcanbedirectlyusedforunderstanding testing and exploring apps behaviors .
it can also assist static analyses such as detecting security sensitive behaviors and other non functional properties like energy efficiency .
whileconsiderableresearcheffortshavebeenspenttoconstruct wtgs via either static analysis techniques or dynamic analysis techniques it is still challenging to obtain anaccurate wtg.
on one hand dynamic analysis such as dynamic exploration ispreciseinidentifyingtransitionsbetween windows but this type of techniques suffer from the notorious coverage problem as other dynamic analysis techniques .ontheotherhand whilestaticanalysisthatmodelsthegui objects events and callbacks showspromising results in constructing a more comprehensive wtg the imprecision in referenceanalysisandover approximationincomputingdataflowsoftenresultininfeasibletransitions.forexample iftheimprecision ofthereferenceanalysiscausesseveralbuttonstobealiaseswith eachother thenatransitiontriggeredbyonebuttonwillalsoresultinthemodeltoincludeincorrecttransitionsfromtheotherbuttons.suchincorrecttransitionswillfurthercausetheimprecisionforthedownstreamanalysissuchascontrolanddataflowanalysis .
to address these challenges we propose a novel tribrid analysis approach promal that synergistically combines static dynamicprogramanalysisandmachinelearningtechniques toconstructawtgforanapp .inparticular promalaimsto benefit from the precise analysis from dynamic analysis and at the ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sametimemitigatethelowcoverageofdynamicanalysisandthe imprecisioncausedbythestaticanalysis.
xspecifically promal firstcombines static analysis and dynamic analysis promal applies static analysis to construct a wtg and then runs dynamic analysistoverifythedetectedtransitions.duetothecoverageissuesofdynamic analysis and over approximation of the static analysis it is expected that a substantial amount of transitions cannot be verifiedbythedynamicanalysis.
yinsteadofincludingallthese unverified transitions in the wtg which potentially will gener ate many infeasible transitions promal further uses a machine learningtechnique windowtransitionprediction thatleveragesthe features for the unverified transitions e.g.
screenshots and text to predictwhichtransitiontoinclude.
ournoveltechniques xfor verifyingstaticwtgsusingdynamicwtgsand yforpredictingunverifiedtransitions allowingpromaltoconstruct amoreprecisewtgthatcanbenefitdownstreamanalysis techniques.
existing static analysis techniques are effective in detecting transitions among windows but are limited in detecting transitions among dialogs.
promal improves the existing static analysisbymodelingthedialogbuilderapisanddetectstransitionsburiedinthecallbacksofdialogstoidentifythetransitionsfromdi alogstootherwindowsanddialogs.asdynamicanalysis typically models the window transitions differently from the static analysis promalinstrumentstheappunderanalysis whichwill recordtheinformationthatcanbeusedtoalign thedynamicwtg withthestaticwtg.thisincludestheidentifiersofguiwidgets i.e.
xpath and interaction events.
moreover the instrumentation willcollecttheruntimeinformation includingscreenshotsofthe windows theviewtree1 andthetext showninthewindows.
theruntimeinformationislaterusedbythemachinelearningtechniques to predict unverified transitions.
for the windows found by static analysis but dynamic analysis cannot reach due to coverage issues promal uses static ui rendering based on adt android developer tools to render the ui layouts for obtaining the screenshots and the view tree and applies static analysis on the ui layout file to obtain the text.
to predict whether unverified transitions should be included in thewtg weconstructamodelofwindowtransitionpredictionbased on machine learning techniques.
given a gui widget in a windowandanotherwindow themodelfirstextractsfeaturesof them to learn their low dimensional representations which are then fed into a link predictor to estimate the likelihood of whether theseexistsatransitionbetweenthewidgetandwindow.however duetothelargeamountofparametersinthepredictionmodel itis difficult to directly train the model since obtaining a large amount of manually labelled wtgs is infeasible.
to address this issue we adoptatwo phasetrainingmodels pre trainingonthedynamic wtgscollectedbydynamicprogramanalysisfromalargeamount of apps and fine tuning on the manually labelled wtgs from a small set of apps.
the essence of the design lies in getting a model general enough to accurately predict window transitions.
weimplementpromalupongator andpaladin andevaluatepromalonadiversifiedsetofrealapps 40appswith 1a tree structure shows that hierarchy of the gui widgets and the layout containers e.g.
linearlayout andrelativelayout .
.
million loc .
these apps have non trivial wtgs of differentsizes ofedgesrangingfrom5to538 .weapplypaladinto constructwtgsfortheseapps andcomparethewtgswiththe groundtruth wtgs.
we pre train our prediction model on 625appsexploredbypaladin andfine tunethemodelusing90 of theappsinourevaluationdataset.weperform10 foldvalidationtopredict the transitions for each app.
the results show that promal effectively identifies the feasible transitions among the windows in constructingwtgs achievinga precision of .
arecall of .
and a f1 score of .
on average.
moreover the wtgs builtbypromalachievesasignificantlybetter f1 scorethanthe wtgsbuiltbygator .
andthecombinedwtgsbuiltby gatorandpaladin .
.theseresultsrevealthelimitations of static analysis in modeling windows callbacks for diversified real apps and demonstrate the effectiveness of promal in using a synergy approach of program analysis and machine learning.
this paper makes the following main contributions anovelapproach promal thatsynergisticallycombinesstatic dynamicanalysisandmachinelearningtoconstructwtgsfor android apps.
anovelstaticanalysistechniquethatbuildsstaticwtgswith transitions among windows and dialogs.
anoveldynamicanalysistechniquethatinstrumentsappsunderanalysisandleveragesappexplorationtechniquestobuild dynamic wtgs and collect runtime information for window transition prediction.
a machine learning model to predict window transitions which can be pre trained on apps explored by dynamic analysis and fine tuned using labelled wtgs to improve the performance.
anevaluationonadiversifiedsetofandroidappstodemonstratetheeffectivenessof promal.thetoolandtheresultsareavailable at the project website .
background in an android app an activity provides a window to draw thegui .
a gui consists of gui widgets e.g.
buttons and text boxes and layout models e.g.
linear layout that describe how to arrangeuiwidgets.eachguiwidgetcanrespondtoseveralevents whereeacheventtriggersasequenceofcallbacks.forexample the click event in a button corresponds to clicking the button and ittriggers the event handler callback that is registered to the clickevent such as onclick.
a callback can open a new window.
for example thiscan bedone viacalling the api startactivity .
when a new window is opened it causes a window transition.
besides widget event callbacks hardware events e.g.
pressing back or homebutton canalsotriggercallbackstocausewindowtransitions.
in particular android maintains a back stack that stores the order of the opened window so that it can be used to decide which window to return to when the back button is pressed.
window transition graph wtg is a type of gui model that representswindowtransitions.existingwork defines awtgasadirectedgraph wherenodesrepresentwindowsand edges represent transitions.
the edges in wtg are annotated with three types of labels i.e.
where represents the event to trigger the transition represents a sequence of window stack authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
fwlylw 5rrw fwlylw 0hqx figure1 exampleuisof subscriberassistantapplication and a window transition operationsthatpushorpopthewindowtothewindowstack2 and representsthesequenceofcallbacksforthetransition.besides widget events such as click events the model further supports fivedefault events that correspondsto pressingthe back home power menu buttons and rotating the phone.
a series of static analysis techniques are then developed to identify gui widgets associatetheircallbacks andbuildastaticwtg.whiledynamic analysis such as app exploration usually does not explicitlybuildawtg theyprovidetheirownmodelstorepresent uistates whichcanbeconsideredasanothertypeofwtgswith different representations for windows and their transitions.
applications of wtgs.
wtgs can be used to improve various types of software analysis such as testing security vetting and performance profiling .
wu et al.
generates gui tests based on the paths in the wtgs and analyzesthe ui callbacks and activity life cycle methods to examine sen sors that are not properly released.
yang et al.
uses a wtg to determine which activities can reach more other activities toprioritize test exploration.
another gui testing tool uses a staticallycomputedwtgtoguidewhichwidgettotriggerwhen theotherexplorationrulesfail.besidestesting wtgsarealsousedforperformanceprofilingandsecurityvetting.wangetal.
profilepotentialresourcedemandingtasksintheuithreadbyusing wtgs to identify callbacks that trigger janky operations and the windowtransitionsequencesthattriggersuchcallbacks.tanget al.
build a ui oriented program dependence graph which is essentially a wtg to discover link hijacking vulnerabilities.
all theseapplicationsrelyonwtgsbuiltexplicitlyorimplicitly and thus it is crucial to improve the precision of the built wtgs for improving the effectiveness of these applications.
motivation example figure shows the ui after translation of an example windowtransition of the app subscriber assistant application which allows users to subscribe various services in russia.
when the highlightedbuttonisclicked theuitransitsfromtheactivity rootto theactivity menu resultinginawindowtransition.wecanconstruct 2window stack is a generalization of android back stack that includes more types of windows dialogs and menus and models the changes of the stack.
3package name of the app is com.olsoft.sa.ntvplus .d dyrulwhv d 6hqg rppdqgd 0hqx d 5rrwh olvw folfn h edfnd 1hzv h ewq folfn h jdoohu folfnh edfn h edfnn h ewq folfn h olvw folfnh phqx folfn h edfn h edfnh olvw folfnd 6hqg rppdqg h edfnh olvw folfn h edfn e n figure partial wtg of subscriber assistant application 9lhz 7uhh ri d 5rrw dqgurlg zlgjhw udph d rxw 3dwk udph d rxw lqhdu d rxw udph d rxw lqhdu d rxw lvw9 lhz lqhdu d rxw rxqgv dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw udph d rxw dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw lqhdu d rxw dqgurlg zlgjhw lvw9lhz dqgurlg zlgjhw lqhdu d rxw fwlylw 5rrw dqgurlg zlgjhw figure example view tree of root window awtgfor thisapptomodelthesetransitions where8nodesare used to represent the activities and edges are used to represent the transitions among them.
due to space limit figure showsthe partial wtg of the app.
there are nodes and edges in thewtg.thenodesshowthenameoftheactivity e.g.
a0 root and a1 favorite .thelabelsontheedgesrepresenttheeventsto trigger the transition e.g.
e3 btn click means that after clicking the button the active windowof appwill transit fromthe activity rootto the activity favorite .
to obtain this wtg promal first applies both static and dynamic wtg analysis to obtain the static wtg and the dynamic wtg respectively.then promalalignsthestaticwtgandthedynamic wtg to form a single wtg.
as shown in figure the solid edgesrepresentmatchingedgesbetweenthestaticwtgandthe dynamicwtg i.e.
verifiededges.duetotheover approximationofstaticwtganalysisandthecoverageissueofthedynamicwtg analysis therealwayswillbesomeedgesinthestaticwtgthat cannotbeverifiedbythedynamicwtg.theonedashededgein figure represents such kind of unverified edge.
to address this problem promalfurtheruseswindowtransitionpredictiontopre dictwhethertheunverifiededgesarelikelytobetransitionsornot.
todoso promalcollectsthescreenshotsandthetextinformation authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
!
!
figure workflow of promal oftheactivities asshowninfigure1 andalsothestructuralinformationoftheuilayout i.e.
theviewtree.figure3showsthepartial viewtreeoftheactivity root.aswecansee theviewtreeshowsthe hierarchyoftheuiwidgets e.g.
listview andthelayoutcontainer e.g.
linearlayout and also the boundary of each ui widget i.e.
represented using screen coordinates .
since android uses xmllayout files to build view trees at runtime xpath can be used to locate theui widget and thelayout container.
for example the xpathshownatthebottomoffigure3pointstoa linearlayout that canbeclicked andthe bounds showsitsboundaryintheuiusing screen coordinates.
with the screenshots and the text information oftheactivitiesandtheviewtreeasinput thewindowtransition predictioncorrectlypredictsthetransitionfromtheactivity rootto theactivity menu infigure1 enhancingthewtgconstructedby the static and dynamic wtg analysis.
overview figure4showstheworkflowof promal.promalconsistsofthree majorcomponents staticwtganalysis dynamicwtganalysis and window transition prediction.
promal accepts an androidapp apk file as input and applies both static and dynamic wtg analysis to obtain the static and dynamic wtgs respectively.
the static wtg analysis performs static analysis on the gui layoutfiles and the code of the apk file and outputs a static wtg.
the dynamic wtg analysis consists of two steps it firsts performs app instrumentation which adds the code component into the apk filetocollectruntimeinformation andthenappliesdynamicapp exploration to explore apps behaviors for building the dynamic wtg.
promal then aligns the static and dynamic wtgs to obtain theedges i.e.
windowtransitions thatareverifiedbythedynamic wtg analysis i.e.
verified edges .
for the unverified edges promal uses the window transition prediction to predict whether the unverifiededgesarelikelytobefeasibletransitions.thewindow transition prediction trains its model on a set of training apk files andusestheruntimeinformation i.e.
screenshots textinformation anduilayouts topredictwindowtransitions.asunverified edges are not explored by the dynamic analysis promal statically renderstheguisinvolvedintheunverifiededgesforobtainingthe information required for the prediction.
the output wtg contains onlytheverifiededgesandtheedgespredictedtobefeasibleedges.
design of promal in this section we first provide the formal definition of window transition graph wtg and then describe the three major components of promal static wtg analysis dynamic wtg analysis and window transition prediction.
.
definition of wtg we represent a wtg as a directed graph g win e where winrepresentsasetofnodeswhereeachnoderepresentsa window of an app e win win is the set of edges that represent transitionsamongwindows and e evtrepresentstheedge labels that describe the events evtthat cause the transitions.
window.weconsider3categoriesofwindowsthatuserscaninteractwithasanodeinawtg activities menus and dialogs.an activity is often presented to the users as a full screen window serving as the build block of an app s gui.
menus include optionsmenuwhichisassociatedwithactivitiesand contextmenu whichis associated with gui widgets.
dialogs are short lived windows that often need user actions to proceed to the next window.
edge transition .anedge e wins win t representsatransition from a source window winsto a target window wint and the labels on the edges describe the events that cause the transition such as a button click.
without loss of generality we treat backedges as the other edges but with a special back label whichmakes it easier to match the back edges identified in the static wtgwiththedynamicallyobservedones.moreover weexclude loops in e. a loop is an edge el wins win t that points to itself i.e.
wins wint.forexample whentheuserclicksabutton representing numbers in a calculator app which does not result in awindowtransitionbutstaysatthesamewindow resultingina loop.asguiwidgetsthatdonotcauseinter windowtransitions willresultinloops theseedgesareofalargeamount.thus adding loops to eonly complicates a wtg without providing more useful information.
event.a ne v e n t evt w t is a label associated with an edge e wins win t where wrepresentsaguiwidgetin wsandtisthe typeofthisevent e.g.
wisabuttonand tis long click .wemodel twotypesofevents widgetevents anddefaultevents.widgetevents correspondtotheinteractionswithaguiwidget e.g.
clickinga button which are categorized into two groups click events including touch select click item click and item selected and long click events including long click anditem long click.w e exclude several widget events because they mainly cause loops such asscroll drag focus changed and enter text.
in fact in our evaluation dataset all edges corresponding to these eventsare loops.
default events correspond to the interactions with the physical buttons or rotating the device.
we focus on the eventscaused by pressing the back button and the menu button and excludeeventscausedbyrotatingthephoneandpressingthehome buttonandthe powerbuttonssincethese excludeddefaultevents onlycauseloopsandappswitches.inourdataset 116outof1 430edgesrelatedtotheseeventsareloops andtheremaining314edges representappswitches.forexample whenanappshowsamenu oradialogandtheuserpressesthehomebutton thephoneexits theappandshowsthehomescreen whentheusergoesbacktothe app the app shows the parent activity of the menu or the dialog.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
while it seems like a transition from the menu or the dialog back to the activity it is in fact an app switch which is generally not interesting in app explorations or testing .
ourmodelcurrentlydoesnotinclude systemevents sincethey usually do not trigger window transitions but rather changing the statesofawindow.systemeventscorrespondtochangesofsystem states such as receiving new messages and volume adjustment .
these events are of a huge amount and can significantly damper the performance of the testing tool and thus they are randomly injected during testing .
.
dynamic wtg analysis dynamic wtg analysis instruments apps and leverages app exploration techniques to automatically explore apps behaviors and collecttheruntimeinformationforbuildingdynamicwtgsand predicting window transitions.
we next describe the app instrumentation and runtime information collection.
app instrumentation.
promal instruments an app to record widget interactions and window transitions.
specifically based on our wtg definition promal monitors two major types of interaction events widgetevents promalrecordstheclickevents theclickcoordinates and the gui widgets.
defaultevents promalrecordsthedefaulteventsforpressing the back and the menu buttons.
to correctly identify window transitions the instrumentation records theforeground activitybefore eachinteraction andleveragesthechangesoftheforegroundactivitytoidentifythesource window and the target window when a transition happens.
during the exploration we collect the attributes of the visited windows e.g.
titlesandtexts thecallstacksoftheirparentmethods and the screenshots of dialogs and menus.
sincesomeguiwidgetsmaynotpossesswidgetids promal furtherusescoordinatesandxpathtoidentifyguiwidgetsinawindow asillustratedinfigure3.promalhooksthe dispatchtouchevent apitoobtainthescreencoordinatesforeachinteraction e.g.
clickingabutton andleveragesuiautomator toobtain theinformationoftheguistateaftertheinteraction whichincludesaview treeandascreenshot.asandroid sguiisrenderedbasedonan xml layout file the rendered gui state can be represented as a view tree where the root element is a layout container such as linearlayout .
based on this view tree we can use xpath to describe thepathfromtherootelementtothexmlelementoftheclicked guiwidget.besides aviewtreeprovidestheboundariesofeach guiwidget whichenablespromaltolocatetheguiwidgetsinthe viewtreeusingthescreencoordinatesofaninteraction andthen generate the xpath of the clicked widget accordingly.
to ensurethe interaction event is fully executed when we capture the gui state thedynamicexplorationaddsawaitingperiodoftwoseconds between two interaction commands.
buildingdynamicwtg.tobuildadynamicwtg promalfirst identifies windows from the data collected during app exploration.
promal leverages two types of information to uniquely identify a window windowtype i.e.
activity dialog menu and resource name.
for an activity the resource name is the resourceid of the activity.
for a menu the resource name is the resourceid of the activity that owns the menu.
for a dialog the resourcename is the resource id of the activity that owns the dialog i.e.
host activity plus the method calls that create the dialog whichcan distinguish different dialogs opened from the same activity.
then promal leverages the source window the target window theclassoftheguiwidget thewidgetid andthecoordinatesof the interaction as the attributes to uniquely identify edges among the windows.
these identified edges and windows are then used to build the dynamic wtgs.
.
static wtg analysis static wtg analysis applies static analysis to identify windows gui widgets and the transitions among the windows.
based onour definition three types of windows are considered activities dialogs andmenus.notethatweconsiderboththeclasses contextmenu and optionsmenu as menus.
promal first applies the existing static analysis technique i.e.
gator to identify edgesamongwindowsaswedefinedin5.
.itperformsaconstraintgraphbasedreferenceanalysistomodelandroidguirelatedobjects e.g.
activities views and callback listeners and their association relationship.
it then builds a wtg based on the analysis of thegui event callbacks and the window lifecycle callbacks.
besides modelingguirelatedobjects promalextractsguiwidgetinformation i.e.
titleandtext fromtheviewtree whichislaterusedfor matchingthedynamicwtgs.foreventsthattriggertransitions our static analysis focuses on widget events i.e.
click and long click events and default events i.e.
pressing the back and the menu buttons .
dialogtransitions.existingstaticanalysis mainlyidentifiestransitionsfromactivitywindowtodialogs butfailstoidentifytransitions from the dialogs to other windows.
the major reason is thatthese transitionsare oftenburiedin thecallbacksof dialogs which are defined using specific apis in dialog builders e.g.
the setitemsapi of alertdialog.builder .
to identify these transitions we extend the static analysis techniques to identify these apis andassociatethecallbacksbuiltthroughtheseapistothedialog constructed by the dialog builders.
specifically our extended static analysis techniques identify the following dialog transitions to other dialogs the analysis examines whether a known dialog allocation api call is found in the associated callbacks.
to host activities executing apis such as dismissorcanceland registering a nullornophandler will trigger a transition to the hostactivityofthedialog.todetectsuchtransitions ouranalysis first leverages the dynamic runtime information collected in section5.2toidentifythehostactivitiesforallthedialogs ifa dialogisnotcoveredduringdynamicexploration ouranalysis usesthecallbackregistrationsitesidentifiedbythestaticanalysis techniques to infer the activity.
to other activities the analysis examines the activity transition calls e.g.
startactivity and startactivityforresult andthevalues of their intentarguments to identify the other activities.
to previous activities calling apis like activity.finish will cause transitionstothepreviousactivity.thesetransitionsareinferred based on the collected dynamic exploration traces.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
.
alignment of static and dynamic wtg afterobtainingthestaticwtgandthedynamicwtgofanapp promalalignsthembymatching each edgeinthestaticwtgto an edge in the dynamic wtg.
we next describe the detailed steps.
matchingwindows.
promalmatcheswindowsusingdifferent attributes based on their types for activities promal checks theiractivitynames formenus promalchecksthenamesofthe activities that create the menus for dialogues promal checks the call stack of the functions that creates the dialogs.
matchingeventsandguiwidgets.tomatchtheeventonan edge we first check if the event types are identical.
for widget eventsthatassociatewithacertainguiwidget promaltriesto obtainthewidgetidinboththestaticwtgandthedynamicwtg to match the widgets.
however the edges in the static wtgs do not always possess a widget id.
sometimes they can only provide aclassnameoftheguiwidgetsorevenprovidenothingtoinfer the associated widgets.
this imprecision of static analysis makes it impossible for users to pinpoint the widgets and hence they are regarded as unmatched.
the edges in the static wtgs that cannot be matched will be subject to further machine learning prediction.
.
window transition prediction thewindowtransitionmodelisusedtopredicttheunverifiededges in the static wtgs.
as shown in the example of figure the windowtransitionmodelconsistsoftheembeddingmodels thewidget embedding model and the window embedding model and the link predictor.
given a pair of a gui widget and a window promal firstextractsthefeaturesfromthem suchasscreensnapshotand text andthenfeedsthesefeaturesintotheembeddingmodelsto obtaintheembeddingvectorsoftheguiwidgetandthewindow.
thelinkpredictorthenusesthetwoembeddingvectorstotellhow likely there is a link between the widget and the window.
we next describe the embedding models and the link predictor in detail.
windowembeddingmodel.
thewindowembeddingmodeluses the features of a window i.e.
screen snapshot text information andguitree togeneratealow dimensionalembeddingvector.we next describe the features of a window screenshot the screenshot of a window displays all visible fragments of an app activity in one image.
following the recent successinusingcnnformodelingimages weadopt a block of densenet to retrieve useful information from the screenshots.
text userscaneasilyunderstandthewindow spurposeandfunctionalityfromthetextsinguis.toutilizethesetexts promal segments the textsand uses a pre trained word2vec model to generate the representations of each word.
then promal computes the average word embedding as the feature vector for the window.
figure shows how the window embedding model computes the embedding of all the text in the target window.
guitree aguitreecontainsalltheguiwidgetsinawindow.
aguiwidgetcanbeaninstanceofasystemwidgetclass e.g.
buttons and checkboxes or a customized widget class extending theclass android.view.view .thus thenameofaguiwidgetclass s superclass which weregard as thegui widget s tag contains the information about the basic functionality of this widget andone hot embedding is used to represent the tag.
besides the tags thepositionsandsizesoftheguiwidgetsmayalsobeusedto infer the functionality of widgets.
to encode all the gui widgets in a window promal traverses the gui tree via in order tree traversaltogeneratea widgetsequence andadaptslstm to learn the representation of the widget sequence.
figure shows how the tags and other information in a gui tree are unrolled to a sequence.
the representations of these three features are then concatenated and fed to a fully connected layer fc to generate the window embedding vector.
widget embedding model.
to generate an embedding vector for a gui widget besides the features of the source window the widgetembeddingmodelalsoextractsthefeaturesofaguiwidget includingthewidgetscreenshot thetext andtheguiproperties.
the feature extraction for the source window adopts the same approachasthewindowembeddingmodel.wenextdescribethe other three features widget screenshot the widget embedding model uses a block ofdensenet formodeling thescreenshotof thesource window andanotherblockofdensenetformodelingthescreenshotof the gui widget as shown in the red frame in figure .
text thewidgetembeddingmodelsegmentsboththetextsin the source window and the gui widget and feed both sequences of words to the word2vec model to generate two vectors.
as showninfigure5 thewidgetembeddingmodelcomputesthe word representation of the text does not repeat in the gui widget as well as the average embedding of every word in the source window.
guiproperty thewidgetembeddingmodelencodestheguitree usingasimilarapproachasthewindowembeddingmodel.apart from the widget sequence of the source window it also extracts the tag the size and the position of thegui widget and feeds these featuresto a fullyconnected layer togenerate a vector as shown in figure .
thefeature vectorsof thesource windowand theguiwidget are concatenatedandfedintoafullyconnectedlayertogeneratethe widget embedding vector.
linkpredictor.
thewidgetembeddingandwindowembedding generatedbytheembeddingmodelswillbefedtothelinkpredictor toinferwhetherthereisalinkbetweenthewidget windowpair.
the link predictor is designed by leveraging the neural tensor network ntn which relates the two inputs i.e.
the widget embedding and window embedding vectors multiplicatively instead ofonlyimplicitlythroughthenon linearityaswiththestandard neural networks where the entity vectors are simply concatenated.
thus it provides a more powerful way to infer the relationship between entities than a standard neural network layer.
letwrepresent a gui widget and arepresent a window of an app activity.
wis the widget embedding model and ais the window embedding model.
the link predictor computes a score of howlikelythereisalinkbetweenthem whichisrepresentedby w w a a .
the score is computed by using the following authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
!
!
!
!
!
!
!
!
.
.
.
.
.
.
.
.
.
.
.
.
figure illustration of how the window transition model predicts whether interacting with a gui widget in a source window causes a transition to a target window.
the figure shows part of the extracted features for the gui widget the source window andthetargetwindow andillustrateshowtheyareprocessedintheembeddingmodelstoproducetheembeddingvectors which are used by the link predictor to make the prediction.
function w w a a ut rf w w tw r a a vr bracketleftbigg w w a a bracketrightbigg br wheref tanhisastandard non linearity applied element wise andw r rd d kis a tensor.
w w tw r a a is a bilinear tensor product and resultsin a vector d rk where each entryis computedbyoneslice m ... kofthetensor w w tw r a a .
theotherparametersforrelation rarethestandardformofaneural network vr rk 2dandu rk br rk .
two phase training.
due to the large amount of parameters in the model we have to use a correspondingly large amount of widget windowpairsasthetrainingdata whichareinfeasibleto be manually labeled.
to address this challenge we adopt a twophase training process.
we first apply dynamic app exploration techniques to automaticallyexplore alargenumber of appsdynamicallyandpre trainthemodelbasedonthedynamically observed transitions.
the variety of apps makes the embedding models general enough.
as these transitions bias towards the transitions that can be easily found by dynamic analysis we further finetunethepre trainedmodelbasedonthemanuallyidentified window transitions from a smaller set of apps.
in the fine tuningprocess theparametersoftheembeddingmodelsarefrozen i.e.
weights and biases meaning that these parameters do not change whiletheparametersofthelinkpredictoraresettrainabletoadapt the patterns related to window transitions.
evaluation in this section we seek to evaluate the effectiveness of promal to constructwindowtransitiongraphsforreal worldandroidapps.
weimplementpromalinjava.promalusesgator astate of the artstaticandroidguianalysistool tobuildstatic wtgs and uses paladin a state of the art app exploration tool tobuilddynamicwtgs.promalalsousesxposed toinstrumentappsforcollectingwindowtransitionsandotherruntime information.
the window transition prediction is implemented usingkeras .specifically weaimtoanswerthefollowingresearch questions rq1 how effectively can promal build the wtgs?
rq2 how effectively can promal improve over gator and paladin?
rq3 how effectively can the ntn model and the two phase training improve promal s window transition prediction?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table apps used in our evaluations.
the real apps are sorted by their densities and divided evenly in groups.
f droid is the last group.
group density loc nodes edges group .
.
group .
.
group .
.
group .
.
group .
.
group .
.
group .
.
f droid .
.
total .
subjects and evaluation setup weuseadiversifiedsetofappsfromgoogleplay asourevaluationsubjects.theseappsarefrom14categories suchasgame entertainment and education.
we also include popular open sourced apps from f droid in our evaluation subjects.
once we downloadedanapp weappliedgatortobuildstaticwtgsandexcluded theappswithlessthan3windows sincetheirwtgsarefairlysimpleandwillnotbepropersubjectsforassessingtheeffectiveness of promal.
in total we examined apps and got apps with at least windows.
as shown in figure a node window may have multiple edges transitions to another node in wtgs making the wtgs more complex than the wtgs that have one or two transitions among windows.
thus we use densityto represent the complexity of wtgs where the density is computed using the numberofedgesdividedbythenumberofnodesinstaticwtgs.
note that the edges in static wtgs may be infeasible but theycan still form a reasonable estimation of the actual wtg.
based on the density we divided the apps into groups equally and randomly sample a subset from each group to evaluate promal on thewtgsofdifferentcomplexities.asthereisnopubliclyavailable groundtruth wtg for these apps we need to construct the groundtruth wtgs by manually exploring the apps and inspecting theirsourcecode.becausethenumberofedgesgrowsdrastically as the complexity of the app grows collecting the groundtruth requiresa non trivialeffort.within ouraffordableefforts werandomly chose apps from each group as our evaluation subjects.
together with the apps chosen from f droid we have apps in density groups.
these apps also belong to different popular categories e.g.
sports game tools .
the total loc of these apps is .
million.
the summary of the apps is shown in table and more details can be found on our website .
we then applied paladin and promal on these apps to build dynamicwtgsandperformedwindowtransitionpredictionsto buildtheoptimizedwtgs.paladinisadynamicappexploration toolthat modelsview treesas uistates toavoid visitingthe same uistatesduringtheexploration.ittriggersactionablewidgetsin a depth first search manner to exercise as many behaviors as possible.amongalltheappsanalyzedbypaladin theminimum running time is .
minutes and the maximum time is around minutes.
the average running time for all the apps is about .
minutes per app.obtaininggroundtruthwtgs.weinstalledtheseappsonan android phone and manually explored the apps by interacting with each gui widget to construct the groundtruth wtgs.
we then matched the manually explored edges to the static wtgs and then manually verify the unmatched edges in the static wtgs.
asdescribed inthe studies due tothe deficienciesin window widget modeling and event handler analysis gator willincorrectlyincludeinfeasibleedgesandalsomisssomefeasible edges in the built wtgs.
thus we further manually inspected the decompiled source code using jadx in the real apps and the source code in open source apps.
we analyzed all the method calls ofstartactivity and all the callbacks of gui widgets to identify the windowsandtransitionsthatwecannotobserveinthestaticwtgs.
the statistics of the groundtruth wtgs are shown in table .
training prediction model.
to train the prediction model we collect the most popular apps indicated by the downloading times fromeachcategoryoftwoappmarketplaces i.e.
googleplay and wandoujia a leading android app marketplace in china .
then we use paladin to perform dynamic analysis on each of the collected apps and finally get dynamic wtgs from apps.
in thepre trainingprocess themodellearnstheparametersforthe embeddingmodelusingthesedynamicwtgs.inthefine tuning process themodellearnstoexploretherelationshipbetweenan appwidgetandanappwindow.themodelisevaluatedusing10fold cross validation which is repeated times.
for the model parameters we set the max word sequence length to the word embeddingsizeto100 thelstmstatesizeto72 thefullyconnectedlayer fc unitsofboththeembeddingmodelsto64 andtheoutput size of ntn layer to .
we take a batch size of in both thepre training and fine tuning processes.
since there are far morenegative samples i.e.
widget window pairs without edges than the positive samples i.e.
widget window pairs with edges in the dataset weapplythemethodofnegativesampling bywhichwe sample negative samples randomly for training.
the final number of the negative samples is four times of the number of positivesamples so the class weights for the negative samples and the positive samples are set to and respectively.
metrics.
to measure the effectiveness of promal we measurethe nodes and edges of the wtgs built by promal gator and paladin andcomparethesewtgswiththegroundtruthwtgsto computetheprecision recall and f1 scoreforthedetectededges.
an edge i.e.
a window transition in a wtg is considered as a true positive tp only if the nodes i.e.
windows of the edge and the edge both match the corresponding nodes and edge in the groundtruth wtg otherwise it is considered as a false positive fp .ifawtgmissesanedgeinthegroundtruthwtg weconsider the missing edge as a false negative fn otherwise it is a true negative tn .
based on these values we compute the precision as prec tp tp fp recall as rec tp tp fn andf1 prec rec prec rec.
.
rq1 overall effectiveness table2showsthedetailsofthewtgsbuiltbypromalforeach app.
column nodes shows the number of nodes in the wtg.
column edges showsthenumberofedgesinthewtg.column prec.
edges and column recall edges shows the precision and the recall of the detected edges.
as we can see on average authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table details of the wtgs built by promal app group nodes edges prec.
edges recall edges group .
.
group .
.
group .
.
group .
.
group .
.
group .
.
group .
.
f droid .
.
total .
.
prec.
and recall are average values.
promal achieves a precision of .
a recall of .
and a f1 scoreof82 .
.inparticular promalachieves97 precision in groups and and recall for groups and .
it also achieves precision and recall for the f droid group.
these resultsshowthat promalishighlyeffectiveinidentifyingfeasible edges in building wtgs.
combination of gator and paladin.
we comparethe wtgs built by promal and the combination of gator and paladin.
the resultsshowthatthewtgsbuiltbycombiningthewtgsof gator andpaladinachieveaprecisionof53 .
arecallof88 .
and af1 score of .
on average.
since all the edges produced by paladinarefeasibleedges thelowprecisioniscausedbyahuge numberofinfeasibleedgesintroducedby gator.forthe40apps in our dataset gator yields edges in total while only .
can be found in the wtgs built by paladin.
thus the majority ofedgesingatorarefurtheranalyzedbythewindowtransition prediction.forthe2 841unverifiededges .
containsincompleteinformation e.g.
missinguilayoutinformationorunable to locate the widget based on gator s widget information .
our modelhenceregardstheseedgesasinfeasibleedgesandpredicts the remaining edges.
it is also noteworthy that of the remaining edges from gator are not specified with a widget id.
instead thewidgetsoftheseedgesareoftenassignedtoawhole window or an anonymous menuitem or a certain type of class name.
toaddresssuchimprecisionof gator promalconsidersallthe clickablewidgetsthatfitthewidgetinformationprovidedbygator inthesourcewindowoftheseedgesastheedges sourcewidgets and predicts whether the edges are feasible.
for edges with backevents weconsiderthemasfeasibleifanon backedgefromthe target window to the source window can be found in the predicted wtg.
only the edges that are predicted to be feasible edges are kept in the final wtgs.
with the window transition prediction the precision of the built wtgs is significantly improved from53 .
to .
which results in a significant improvement of f1 score from61 .
to82 .
.theseresultsclearlydemonstrate the effectiveness of promal in using a synergy approach of program analysis and machine learning.
fps and fns.
due to the fps and the fns promal achieves a relatively low precision in groups and a relatively low recallingroup6 i.e.
morethan5 lower .figure6illustrateshowpromalproducesan fpandanfn.thewindowontheleftisfrom the activity mainpage.
promal correctly identifies a transition from mainpageto the activity preference resulted from clicking the info button highlightedingreen .however promalalsoincorrectly identifiesanothertransitiontotheactivity preference resultedfrom fp tp fn figure example fpandfnproduced by promal table details of the static wtgs built by gator app group nodes edges prec.
edges recall edges group .
.
group .
.
group .
.
group .
.
group .
.
group .
.
group .
.
f droid .
.
total .
.
prec.
and recall are average values.
clickingthe high button highlightedinred .this fpiscausedby the patterns learned by the machine learningmodel.
figure also includesa fnproducedbypromal.inthe preference activity ifthe moreapp buttonisclicked theappwilltransittothe moreactivity which serves as a built in browser and displays a website to users.
due to the drastic changes of the ui states the window transition predictionmodelcannotinferanycloserelationshipbetweenthe sourcewindowandthetargetwindowfromtheiruilayoutsand screen snapshots and thus produces a fn.
furthermore the limitations of gator s model hinders the performance of promal.
first gator have trouble distinguishing widgets without widget ids and will associate them with all pos sible handlers declared in the same method.
this type of over approximation makes promal generate extra edges.
second a large number of false negatives are caused by gator failing to identify dialog instances.
thus promal cannot detect transitions from these dialogs.
.3rq2 comparison with paladin and gator comparison with gator table shows the details of the wtgs built by gator for each app.
as indicated by the results many oftheedgesfoundbygatorareinfeasibleedges i.e.
fps.these resultsshowthatthewtgbuiltbygatorforeachappisrather inaccurate achieving a precision of .
a recall of .
and af1 score of .
.
uponfurtherinvestigations wefindthatgatorperformspoorly on both precision and recall for two main reasons.
the first reason is due to the imprecision of gator.
we empirically find out that gatoroftenyieldsmultipletransitionswithdifferenttargetwindows from the same ui widget while most of them turn out to be infeasible.figure7showsanexampletransitionfromthegameapp com.twobitinc.cornholescore .theleftwindowisfromtheactivity optionsactivity whichshows5buttonsforuserstocustomizecertaingameparameterssuchasthecoloroftheteamandthescoring authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
click figure example fpproduced by gator click figure example fnproduced by gator mode.whenthe setcolor buttonisclicked theuitransitstothe activity rgbpickactivity .
however due to the imprecision in associatingwidgetidsandeventhandlermethods gatorinfersthat clicking any of the button will transit to different activities.
in this way gator infers infeasible edges for each of the buttons and results in fpedges for a single activity which significantly reduces gator s precision.
second gator often fails to identify transitions between activities due to the limitationin modeling certain transitions.
figure shows an example transition for the app com.jacobsmedia.sparts .
upon clicking the hockey button the app transits from the activity mainto another activity xmlpage.
butgator fails to infer this edge.actually thebuiltwtgforthisappindicatesthattheactivity xmlpage along with two other activities have only transitions to themselves.
however there are in fact edges among the three activities in the groundtruth wtgs which cause fns for gator.
comparedtogator promalsignificantlyimprovesboththe precisionandtherecallinbuildingwtgs withthehelpofdynamic analysis and window transition prediction.
the predictions on the unverifiededgesintotalruleout2 351outof2 399fpedges hence significantly improving the precision of promal by .
from .
to90 .
.byaddingthe708edgesdetectedbypaladinand the63edgesfromgator swtgs therecallofthewtgbuiltby promal is improved from .
to .
.
comparison with paladin.
table shows the details of the wtgs built by paladin.
as paladin adopts dynamic analysis thetable details of the dynamic wtgs built by paladin app group nodes edges prec.
edges recall edges group .
.
group .
.
group .
.
group .
.
group .
.
group .
.
group .
.
f droid .
.
total .
.
prec.
and recall are average values.
precision in finding feasible edges is always .
on average the wtgs built by paladin achieve an average recall of .
in findingfeasibleedges.wecanobservethatpromalimprovesthe built wtgs with the help of static analysis and window transition prediction.
on average promal improves the recall of paladin by .
and in turn improves the f1 score by .
.
in particular promal improves the recall significantly for group from .
to92.
andgroup7 from68 .
to80 .
.theincreasedrecall willenabletestingtocovermorebehaviorswithtolerableextraefforts on the reported infeasible transitions with the precision still being .
.
rq3 window transition prediction we first compare the performance of the alternative models for the link predictor and then measure the improvement brought by the two phase training.
comparisonoflink predictormodels.wecompareourntn modelwiththebilinearmodel whichisalsoaneffective way to model the relationships between entities.
we train both models using the window transitions collected from the dataset of1 625apps whichareautomaticallyexploredbypaladin.the results show that ntn achieves a precision of .
a recall of .
and a f1 score of .
while the bilinear model only achieves a precision of .
a recall of .
and a f1 score of .
.
thus ntn is a better choice for the link predictor.
effectivenessoftwo phasetraining.byperformingourtwophasetraining thepredictionmodelachievesaprecisionof50 .
a recall .
and a f1 score of .
.
however if we directly use90 ofthegroundtruthwtgstotrainthemodel theprediction modelachievesaprecisionof33 .
arecallof67 .
anda f1scoreof45 .
.thisclearlydemonstratestheimprovementbrought bythetwo phasetraining.moreover eventhoughthetwo phase training improves the performance of the prediction the overall performanceofpredictionisstillnotsatisfactory.thereasonisthat fortheseunverifiededges promalusesstaticguirendering to render thelayout files toobtain the view treesand screenshots which are not as accurate as dynamic analysis.
even so when it is applied on only the unverified edges promal can achieve further improvement by combining the prediction results of the unverified edges with the verified edges improving the f1 score to .
.
if we use the model without pre training in promal the precision dropsto61 .
therecallbecomes78 .
andthe f1 scoreisonly .
indicating the importance of two phase training.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
discussion staticanalysis.promalbuildsthestaticanalysisupongator and extends the static analysis to detect dialog transitions buried in the callbacks of dialogs.
while gator provides a comprehensivemodelofandroidenvironment e.g.
backstacks events and callbacks it adopts an over approximation algorithm that appliesonlyweakupdateswhenassociatingthewidgetidsandevent handler callbacks.
such problems can be mitigated by applying moreexpensivebutpreciseanalysissuchaspath sensitiveanalysis like flowdroid and symbolic execution .
dynamicanalysis.dynamicappexploration hasbeenusedtogenerateguitests discoverappbehaviors anddetectviolationsadfraud.promalleveragesdynamicappexploration to build the dynamic wtg for an app.
while these approaches can automaticallytrigger both uiwidgetevents andhardwareevents e.g.
pressing back button they still suffer from coverage issues duetovariousenvironmentdependencies.thisissuecanbemit igated by using developer provided test cases as seeds t o improve app exploration.
window transition prediction.
due to the functionality and designdifferencesbetweendifferentapps manytransitionfeaturesarequiteunique.therefore thepredictionmodelhasarathergoodperformance in apps similar to its training set and performs poorlyinotherapps.infuturework weplantoextractmorefeaturessuchas whether the widget is clickable or not to improve the prediction.
threats to validity our evaluation subjects may not be representativeoftheentiremarket.tomitigatetheissue wechooseapps that have wtgs of different complexities and the subjects usedfor pre training apps also alleviate the issue.
we plan to addressthislimitationbyincludingmorediversifiedmarketapps to further reduce the threats.
also we discard apps that cannot be analyzed by either paladin or gator which are mainly caused by thecompatibilityproblemofthelibrariesandsdkversions.this can be mitigated by upgrading the libraries and adding support for later sdk versions.
inaccuracies in the manual code inspection are inevitableduetothelackofthegroundtruthwtgs.inaddition there may be human errors in collecting statistics and studying the evaluation results.
these threats are mitigated by double checking all manual work and ensuring that the results were agreed upon by at least two authors.
related work androiduimodelling.rountevetal.
sgator isamong the first to provide a static analysis framework for modeling an droidapps uis.gatormodelsgui relatedandroidobjects their flowthroughtheapplication andtheirinteractionswitheachother via the abstractions defined by the android platform and provides a context sensitive static analysis of callback methods to link callbackmethodstoguiobjects .builtuponthisstaticanalysis gatorfurthergeneralizestheanalysiswithexplicitmodelingofthe window stack to generate a static wtg .
besides static analysis dynamicanalysisbuildsauimodelthatrepresentsdifferent states for windows which can be considered as a finer grained wtg .theseuistatesareusedtoguidethedynamic exploration to either discover more behaviors or identify certain violations e.g.
adfrauds .promal swtganalysisisbuiltuponthesestaticanddynamicanalysistechniques wherethedynamic analysis is used to verify the results of the static analysis.
hybrid program analysis.
hybrid program analysis has been used toimprove theprecision of variousstatic analysis.check n crash takes the error conditions inferred using theorem provingtechniquesbyastaticcheckerandproducestestcasesto determine whether an error truly exists.
this technique has shown advantages over both static checking and automatic testing individually.
blended analysis combines dynamic and static analysisbyfirstapplyingdynamicanalysistocaptureruntimeinformation and then performing static analysis on each dynamic trace toidentifysolutions whichhasbeenshowntoachievepromisingre sultsinperformanceunderstandingandtaintanalysis.anotherim portantlineofhybridanalysisisconcolictesting where dynamic analysis is used to collect constraints along the executedprogrampathsandstaticsymbolicanalysisandconstraint solver are used to derive new inputs to explore more program paths.
promal s tribrid analysis is inspired by the idea of hybrid program analysis where machine learning techniques are used to address the limitations of both static and dynamic analysis.
machine learning based link prediction.
link prediction is a fundamental problem in link mining that attempts to predict the existence of a link between two nodes based on observed links and theattributesofnodes .linkpredictionandrecommendation problemwasfirstproposedbyliben nowellet.al .traditionally there are two ways of making link predictions one way tomake this prediction is based on structural properties of the network another way is to make use of attribute information for linkprediction .recently alotofmethodsbasedonmachine learningtechniquesareproposed .thefirsttostudythe link prediction problem as a supervised learning problem is hasan et.
al.
where the existing and non existing social links are treatedasthepositiveandnegativeinstancesrespectively.promal is related to link prediction but focuses on predicting transitions among windows using app specific ui information.
conclusion wehaveproposedpromal asynergisticanalysisthatcombines staticanalysis dynamicanalysis andmachinelearningtoconstruct a precise wtg.
promal applies static analysis and dynamic analysis to build the static wtg and the dynamic wtg for an app and identifies the verified edges by matching the edges in these two wtgs.promalthenleveragesmachinelearningtechniquestopredicttheunverifiededgesinthewtgtodeterminewhethertheyare feasible transitions.
our evaluations on real world apps demonstrate the superiority of promal in building wtgs over static analysis and dynamic analysis when they are applied separately.