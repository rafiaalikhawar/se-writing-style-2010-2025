supporting quality assurance with automated process centric quality constraints checking christoph mayr dorn johannes kepler university linz austria christoph.mayr dorn jku.atmichael vierhauser johannes kepler university linz austria michael.vierhauser jku.atstefan bichler johannes kepler university linz austriafelix keplinger johannes kepler university linz austria jane cleland huang university of notre dame notre dame usa janehuang nd.edualexander egyed johannes kepler university linz austria alexander.egyed jku.atthomas mehofer frequentis ag vienna austria thomas.mehofer frequentis.com abstract regulations standards and guidelines for safetycritical systems stipulate stringent traceability but do not prescribe the corresponding detailed software engineering process.
given the industrial practice of using only semi formal notations to describe engineering processes processes are rarely executable and developers have to spend significant manual effort in ensuring that they follow the steps mandated by quality assurance.
the size and complexity of systems and regulations makes manual timely feedback from quality assurance qa engineers infeasible.
in this paper we propose a novel framework for tracking processes in the background automatically checking qa constraints depending on process progress and informing the developer of unfulfilled qa constraints.
we evaluate our approach by applying it to two different case studies one open source community system and a safety critical system in the airtraffic control domain.
results from the analysis show that trace links are often corrected or completed after the fact and thus timely and automated constraint checking support has significant potential on reducing rework.
index terms software engineering process traceability developer support i. i ntroduction software quality assurance qa focuses on ensuring and attesting that the engineering processes result in appropriate quality of the software.
to this end various regulations standards and guidelines stipulate stringent traceability paths but don t prescribe the corresponding detailed software engineering process.
examples in safetycritical systems include the fda principles in the medical domain do 178c ed 12c for airborne systems ed 109a for air traffic management systems and automotive spice in the automotive industry.
here qa engineers need to inspect fine grained constraints over properties of engineering artifacts i.e.
requirements models code test cases etc.
as well as trace links at specific points in time i.e.
in different process steps such as requirement elicitation specification refinement coding or test case specification .
the current practice in industry however is to use semi formal descriptions to specify processes .
as a result software engineering processes are rarely executable meaning that there is little to no automatedsupport for checking whether these processes are followed and to what extent deviations occur during development.
in this paper we specifically address the problem of developers andquality assurance engineers being overwhelmed by the complexity and extent of adhering to and evaluating qa constraints.
typically developers work on multiple projects sometimes simultaneously with each project having different quality standards or guidelines.
in an informal study with our industry partners developers reported being stressed about potentially missing important steps mandated by quality assurance.
qa engineers on the other hand need to conduct countless tedious often mind numbing checks that involve manually navigating across diverse artifacts and tools to ensure that the required constraints are fulfilled at the right process step.
these checks are error prone and rarely conducted in time to provide immediate feedback to developers.
remediating problems later on however interrupts developers who may have already moved on to other steps or projects causing even further delay.
in this paper we present a novel approach that aids developers and quality assurance engineers to reduce the effort required in ensuring that development activities adhere to the intended process ultimately leading to less rework.
our approach relies on passive process execution achieved by tracking process steps via monitoring engineering artifacts such as requirements design documents issues change requests and tests.
this is complemented by constant evaluation of quality constraints.
the key novelty is treating quality constraints neither as an implicit part of the engineering process model nor as completely disjunct from it.
instead we propose treating quality constraint evaluations as first class citizens i.e.
as explicit development artifacts that determine process progress.
this contrasts with existing work on traceability where links required by regulations and standards are typically verified by an auditor at the end of a process stage or prior to shipping the final product .
similarly work on constraint checking primarily focuses on consistency among diverse artifacts without addressing consistency issues ieee acm 43rd international conference on software engineering icse .
ieee between these artifacts and the underlying process.
the key contributions of this paper are as follows a process model that decouples process control and data flow from qa constraints.
a passive process engine which explicitly tolerates inconsistencies and allows engineers to temporarily deviate from the process while providing them with timely feedback on qa constraint evaluation results.
a prototype that helps developers clearly understand when they have completed a step or what they still need to provide e.g.
specific content or trace links .
an evaluation against an open source system for unmanned aerial vehicles ua vs and an industrial air traffic control system atc that measures the extent to which the prescribed process was followed.
the remainder of this paper is structured as follows.
section ii motivates our work by describing constraint checks for the development of safety critical systems.
sections iii and iv provide an overview of our approach and introduce details on modeling the process and constraints.
we then evaluate our approach using two distinct case studies in section v and conclude with a discussion of results section vi threats to validity section vii and related work section viii .
ii.
m otivating example our industry partner frequentis is a world leading voice communication provider for air traffic control and commandcontrol centers.
in this domain the do ed standard specifies traceability requirements according to different design assurance levels ranging from catastrophic to minor or no effect .
however while do ed defines which trace links need to be available it does not specify when these trace links need to be established or who should must perform this task.
figure left depicts a partial traceability information model tim and excerpts from a simplified development process representation right for one frequentis product.
the process example indicates that once high level requirements hlreq and high level design specifications hlspec are reviewed hlreq may be refined into low level requirements llreq and cause updates to the low level design specification llspec .
thus developers should not start refining llreq without the outcome of the review even though hlreqs and teams are already assigned to work packages during the development iteration planning phase.
additionally before the implementation of llreq can start trace links from hlreq to llreq and trace links from llreq to llspec need to be reviewed.
constraints that are set up for the development process are not only used to check for the existence of an artifact or the existence of a trace link between the right type of artifacts.
constraints build on the properties of an artifact at a specific process progress.
at the end of step s3 cf.
figure the respective llreqs need to be in state complete each having a trace link to a hlreq.
upon completion of step s7 when a llreq s verification method is demonstration then there must exist at least one tracelink to a respective test case which is not of type software test case but for example a simulation demonstration or acceptance test .
these constraints are complementary to human in the loop qa measures such as the trace reviews in s5 and s6.
the automated checks reduce the effort for these reviews by ensuring the traces under review are syntactically correct and thus the review can be done more efficiently.
engineers who are updating the llspec in s4 for example thus need to be aware when they may start with their step to avoid rework if additional refinements of an llreq occur.
similarly engineers in s7 need timely feedback when they can claim to have finished implementation and thus trigger the review in s8.
knowing the state of the process helps assess the risk of deviation.
starting early on hlreq refinement s3 may be too risky if none of the requirements have gone through review in s1 and s2 but perhaps necessary and ok due to time pressure when s2 has only a few requirements left to review.
the following sections use this tim process and constraints as a running example to better explain process and constraint modeling as well as execution.
fig.
frequentis simplified traceability information model tim excerpt left and process model excerpt right .
iii.
a pproach theproconframework in this section we provide a comprehensive overview of procon our passive process execution and quality constraint support framework.
two key aspects that characterize our framework are first the integrated handling of explicitly distinct processes and constraints and second the tracking of engineering progress achieved through explicitly linking process descriptions to software engineering artifacts.
in procon a passively executable process specification describes the sequence and alternatives of carrying out engineering activities i.e.
the control flow and the software engineering artifacts that serve as inputs and outputs of those activities i.e.
the data flow .
explicitly modeling a software engineering process for controlling the software engineering life cycle is not new with a plethora of research dating back until the 90s .
procon is different insofar as that i the process is tracked in the background based on the 1299fig.
the procon framework.
software engineers activities performed in the tools they are using in their daily work rather than requiring engineers to interact with a process engine ii engineers are free to deviate from the process iii engineers may receive guidance even in the presence of deviation and iv procon supports controland dataflow conditions as well as constraints across diverse artifact types and tools.
we refer to these abilities as passive execution as our framework goes beyond simple process monitoring by determining available future steps detecting premature steps and making this information immediately available to engineers.
with procon deviations from the process are tracked via process and quality constraints.
these constraints and their respective evaluation results are treated as first class citizens in the software engineering process model hence are explicit software engineering artifacts of their own.
this in turn allows for explicitly evaluating constraints as soon as actions are performed and constraint evaluation results can provide valuable insights about the status of the process beyond whether a step has been completed or not.
additionally treating constraints and their evaluation results as first class citizens makes reuse and maintenance less cumbersome.
constraints may be modified over time to accommodate changes in the organization s process or may apply in diverse process contexts making them amenable to product line engineering approaches.
imagine applying the concepts of software product line engineering for better managing the variations in process and qa concerns found in a larger organization .
a. procon high level architecture procon consists of four major elements depicted in figure that together allow defining checking and maintaining the process and development artifacts of an organization existing semi informal process definitions standards guidelines and regulations serve as the initial input for procon.
typically these already exist within an organization anddescribe and motivate the prescribed processes and quality assurance measures.
process definitions may be spem documents pdfs with flowcharts or simple text documents outlining the steps and responsibilities of the different roles.
the process definitions are complemented by and used in conjunction with a variety of diverse tools within an organization to create update and maintain the artifacts that represent the input and output of the different process steps.
artifacts such as issues often serve as a partial informal representation of process instances.
tool connectors b for the respective tools provide machine readable e.g.
as json data via a rest api access to artifacts.
these connectors take on sophisticated tasks such as obtaining artifact updates via polling or subscriptions managing which artifacts are relevant for a process and thus need to be monitored caching the artifacts for quick repeated access and keeping this cache up to date cf.
section v a .
passively executable process specifications and constraints c are manually derived cf.
section iv a and iv b respectively based on the above two main inputs.
process specifications formalize the semi informal process definitions and guidelines and allow a fine grained mapping to the respective artifacts properties and their changes observable via the tool connectors.
thepassive process engine d manages instances of passively executable process specifications or process instances for sake of brevity .
the passive process engine obtains artifact state and events from tool connectors e feeds these changes into a rule engine in which the process progress conditions and qa constraints are evaluated.
the rule engine eventually fires events that the process engine utilizes to update the process progress and quality constraint evaluation results cf.
sections iv c and iv d respectively .
a web based process dashboard makes process progress and qa constraint evaluation results f continuously available to software engineers.
it allows controlling the passive process instance triggering new instances observing their progress and eventually archiving them cf.
section v a .
b. procon usage procon users are primarily qa engineers and developers but also include stakeholders such as product managers and team leads.
the former can use the framework with a focus on quality assurance the focus of this paper while the latter can use the framework with a focus on process progress.
based on this procon supports two distinct use cases.
in the process and constraint modeling use case various stakeholders map the informal process definitions standards etc.
a to passively executable process specifications c .
this phase involves analyzing how engineers currently produce evidence of process execution in the various tools b .
the tool connectors describe what artifact properties are available and thus what change events may serve as process progress triggers during process execution for example what custom properties are used for various jira issues what trace links are available to navigate from a jira issue to a requirement 1300managed in jama .
the outcome of the modeling use case is a passively executable process specification and its quality constraints.
note that our approach does not require modeling the complete process if tools don t allow access to certain information.
one would typically start with those parts that are most important or most error prone etc and focus on these.
ambiguity may arise for example if rules expect one trace to navigate to an artifact but find multiple ones then a random one will be selected.
mitigation includes correcting and or extending qa constraints to identify the ambiguous situation.
in line with lee osterweil s key observation that software processes are software too we advocate the use of contemporary software engineering practices such as developing in iterations testing versioning and issue tracking.
a key element here is replaying of the artifacts history to test the constraints ability to detect deviations .
the second use case focuses on the passive process execution.
upon process instantiation the passive process engine obtains artifacts and their changes as they occur in tools d .
the engine then tracks the progress of each step and attached constraints.
it determines completed and in progress steps figure center with solid border which steps an engineer is free to start next and which ones should not yet start dashed border .
artifact and process updates trigger reevaluation of constraints document symbols with icons .
procon users then access the process progress and constraint evaluation results e .
an engineer may notice an unfulfilled constraint conducts the necessary artifact changes via the tools triggers reevaluation and confirms quality constraint fulfillment.
note that users exclusively affect process progress and constraint evaluation results via tool interactions f and never via direct interaction with the passive process engine itself except for explicit triggering of quality constraint evaluation .
in the next section we describe the process and constraint modeling in more detail as well as process execution.
iv.
p rocess constraint modeling and execution the following section describes how process specifications are structured and executed and discusses the elements and transitions of the procon process specification metamodel.
a. process specification model the challenge when passively executing processes is determining the steps that are currently available for engineers to work on steps that represent work in progress but perhaps shouldn t be worked on yet and finally steps that have been successfully completed.
the prevalent differences to existing approaches hereby are not the basic building blocks i.e.
the process steps but rather in how transitions between these steps are defined and subsequently triggered.
figure left provides a simplified uml class diagram of the process model s main elements.
the two main elements of the process model are steps anddecision nodes attached to them.
astep describes what an engineer should do in contrast to must do as prescribed by a a more restrictive traditionalprocess .
for example refine a requirement implement a feature define a test case.
a step has zero or more input artifacts attached that represent required data to make a decision or artifacts that need to be modified.
it further has zero or more output artifacts that describe the effect of having executed the step e.g.
having modified an input artifact or created a new artifact .
input and output artifacts can represent any kind of information such as requirements tests issues or trace links.
in addition to the textual description of an engineer s activity a step consists of a set of event condition action rules that define which event s from the engineering environment e.g.
an artifact update given additional constraints i.e.
the condition trigger the inclusion of an artifact to a step s output artifact set i.e.
the action part of the rule .
for example in s5 when an engineer posts a review url as a jira issue comment then add that link as the step s output artifact .
adecision node describes how the completion of one or more steps and additional conditions leads to the execution of subsequent steps.
the set of decision nodes thus defines the process control flow.
a decision node s datatransfer declaration describes how the output of one step becomes the input of a subsequent step thereby defining the process data flow.
for example the llreq output artifacts of s3 and llspec output artifacts of step s4 become the input artifacts to step s6 .
note that a step may only have one preceding and one subsequent decision node to avoid conflicting control or data flow.
only a decision node may link to multiple steps.
ultimately a process consists of a set of steps and decision nodes that create a single connected directed graph.
note that currently loops are not yet supported as the use cases at our industry partner did not require this feature for two reasons first artifacts can be updated over and over again until qaconstraints are fulfilled.
second longer explicit loops such as sprints are typically represented as separate sub processes and thus are spawned separately.
the specific activation conditions are placed on the inflows from preceding steps to decision node on the node itself and on the outflows from decision node to subsequent steps .
figure right outlines how these conditions reflect in a decision node s state.
available upon instantiation a decision node is in theavailable state.
depending on a decision node s inflowtype and or xor it will check upon each update of preceding steps whether all at least one or exactly one inflow are fulfilled to transition the node intopassedinconditions.
passed inconditions in this state conditions independent on any preceding step such as process or date time centric conditions need to be fulfilled before transitioning into passed context conditions.
passed context conditions in this state the decision node evaluates outflows.
outflow conditions serve as a filter to dynamically select the relevant subsequent steps to enable.
depending on a decision node s outflowtype and or xor it will check whether all or at least one outflow is fulfilled then transitioning 1301fig.
process specification meta model uml class diagram and state charts.
intopassed out conditions.
in case of xor we still need to enable all steps of fulfilled outflows as this indicates a situation where the engineer decides which one is the relevant one.
passed out conditions this is a temporary state to separate between having fulfilled all outflow conditions and having also instantiated the subsequent steps including data transfer.
progressed all subsequent steps identified by outflow conditions are instantiated and have the required input artifacts available according to the specified data transfer.
as long as a decision node hasn t reach progressed any change to the inflow context and outflow conditions will transition the state back to an earlier state.
note that the conditions on inflow context and outflow are optional.
for example the decision node between step s1 and step s2 not shown in figure does not have any of these three conditions.
upon completion of s1 it will immediately transition through all these states into state progressed thus serving as a simple trigger to activate step s2.
in addition to the decision node state tracking each step s state is vital to provide developers with feedback on which steps are ready for starting which ones have started too early and which ones should not be done.
figure middle depicts a step s life cycle modeled as a finite state machine.
available when a step is instantiated it resides in theavailable state indicating that it s input is not sufficient yet i.e.
it has not yet obtained the necessary data from the preceding decision node .
enabled once all specified input conditions are met for example required input artifacts are available a decision node causes the step to transition to enabled indicating that an engineer is free to start working on it.
active when artifact to step mappings signal that artifacts attached to the state are updated or modified the step becomes active indicating that an engineer is actively working on it.
nowork expected when multiple mutual exclusive steps are enabled it can initially not be determined which of these an engineer has chosen.
once one of the alternative steps transitions into active the remaining steps transition into nowork expected.
revoked when a step s input conditions are no longer fulfilled it transitions into revoked to indicate that an engineer should not no longer work on this step or if starting respectively continuing may need rework later on.
once the input conditions are re established the step transitions back into enabled oractive depending on its previous state .
the key difference between a revoked step and nowork expected step is that the former should eventually be carried out while the latter should not be carried out at all.
completed when all output conditions are met e.g.
all required output artifacts are available the step transitions into completed and triggers the evaluation of the step s subsequent decision node.
b. quality constraint integration for each step quality constraints can be defined describing conditions the created or updated output artifacts must adhere to.
a constraint can refer to a step s input and output artifacts its metadata or process metadata.
each constraint has an identifier that allows triggering constraints not only upon artifact changes but also manually on demand.
this is important to provide control to the user and to allow for example an engineer to trigger a constraint check to reassure him her that a step is indeed complete and nothing has been overlooked.
the language in which constraints are implemented is flexible and can vary depending on the domain or application scenario.
the only requirement is that it has to provide respective evaluation results we provide further examples on constraints and the constraint language as part of the use cases in section v .
every time a quality constraint is evaluated a corresponding new instance of quality constraint evaluation result is created reporting the result i.e.
fulfilled or unfulfilled and lists the artifacts subject to that constraint.
for example a constraint for step s6 checks whether each low level requirement llreq output artifact has a trace link to a high level requirement hlreq which must be in state released .
therefore the respective constraint evaluation result will contain the list of llreqs that fulfill this constraint and a list of llreqs 1302that violate this constraint.
for every constraint we further store timestamps indicating when the constraint evaluation result was last evaluated and when the evaluation result last changed from violated to fulfilled and vice versa.
this for example allows to infer how recent results are when shown on the process dashboard.
the evaluation results of all quality constraints associated with the same step are collected and bundled in a quality check document which is added to the output artifacts of that step.
the process model itself remains largely independent from constraints and their evaluation results.
while a process step s completion constraint must check whether a quality check document output artifact exists which contains only positive quality constraint evaluation result s it doesn t need to understand the particular constraints that resulted in the evaluation success.
this loose coupling allows to execute the same process with different levels of quality assurance by switching in and out different quality constraints.
c. passive process execution every process model comes with an activation condition typically an explicitly added artifact such as a change request issue or work package issue that already serves as some form of process representation.
the process engine instantiates the process and checks which steps and decision nodes can be instantiated based on the provided activation artifact.
instantiation occurs incrementally i.e.
only when a step reaches the state enabled will the process engine instantiate the step s subsequent decision node.
similar only when a decision node is in state passedoutflow conditions will the engine instantiate the steps identified by the outflow links.
with step instantiation the engine also instantiates the quality check constraints.
thus as long as a step doesn t exist none of its constraints will be checked.
in the passive process engine incremental step and decision node instantiation is insufficient as engineers may decide to work on steps not yet ready.
when artifact changes trigger artifact to step mappings the process engine will instantiate the corresponding premature step and attempts to find an existing preceding decision node that this step can be linked to.
if none exists yet the step remains dangling in the process until the process progress catches up i.e.
upon instantiating a decision node the engine checks if a dangling step exists that should be linked via one of the decision node s out flow links.
from the engine s point of view there is no difference between missing a step and starting the next or starting too early on the next step.
it will continue either way.
in such as case however then the engine will not be able to fully execute a datatransfer that requires the output of the skipped incomplete step.
the consequence is then highlighted via the step s status as having insufficient input artifacts.
note that assessing the impact of prematurely starting a step and how to mitigate any potential change propagation is outside the scope of this paper.
premature steps stand out from regular steps by having transitioned directly from a v ailable to active.d.
constraint checking we made the deliberate decision to execute constraint checks upon explicit request and not automatically triggered by every single artifact change.
often a single change is not indicative of step completion.
the reasons behind this are manifold.
first as quality constraints often span across multiple artifacts a single change to an artifact is insufficient multiple changes need to occur.
for example in s6 not just one low level requirement llreq needs to be set to released but all linked ones.
second an artifact may be involved in multiple constraints thus a change would trigger execution of multiple constraints.
third reevaluation on every change puts unnecessary burden on the process engine respectively its constraint evaluation subsystem.
forth when quality constraints involve diverse artifact types managed in different tools change events from these tools may not be readily available as the engineer carries out the change in these tools but need to be fetched periodically.
jama for example doesn t offer automatic event notifications but requires polling with subsequent explicit fetching of changed artifacts.
this would result in executing checks on stale data.
v. e valuation we evaluated procon against two distinct use cases for which we created process specifications and constraints and implemented connectors for different issue tracking and requirements management tools.
the first use case dronology an open source project represents an more agile lightweight process whereas the second one a safety critical system in the air traffic management domain describes a rigid standardized process with stringent quality assurance criteria.
we report on the application of procon to the two use cases and our findings and lessons learnt.
supplemental online material provides artifact data and trace links process definitions including constraints and the experiment results.
the prototype source code is publicly available .
a. prototype implementation we implemented a prototype to evaluate the two use cases and to obtain feedback from our industry partner frequentis.
tool connectors to cover a reasonably large set of artifacts from our industry partner frequentis and from dronology we implemented connectors for jira a web based tool for planning issue tracking and reporting and jama a tool for requirements management traceability and test management.
the jira connector uses the atlassian java rest api to retrieve artifacts and their attributes and is used to periodically poll for changes in these artifacts.
similarly the jama connector uses the jama rest api.
to reduce load on network and tools the tool connectors cache jira and jama artefacts in a couchdb a schemaless json database .
process engine the process engine is implemented in java containing an implementation of the process specification metamodel and a rule engine for checking constraints.
we opted for the drools rule engine a business rules management system that can be easily integrated into a java 1303fig.
procon process dashboard.
application and allows easy access to java objects representations of jira and jama artifacts within rules written in a java dialect.
additionally we persist the processes and quality check documents including quality constraint evaluation results attached to the different process steps in a neo4j graph database.
the graph structure simplifies fetching all related process steps decision nodes input and output artifact