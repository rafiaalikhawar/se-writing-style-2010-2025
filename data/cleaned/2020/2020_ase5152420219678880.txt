context debloating for object sensitive pointer analysis dongjie he jingbo lu and jingling xue unsw sydney abstract we introduce a new approach c onch for debloating contexts for all the object sensitive pointer analysis algorithms developed for object oriented languages where thecalling contexts of a method are distinguished by its receiverobjects.
our key insight is to approximate a recently proposed setof two necessary conditions for an object to be context sensitive i.e.
context dependent whose precise verification is undecidable with a set of three linearly verifiable conditions in terms ofthe number of statements in the program that are almostalways necessary for real world object oriented applications based on three key observations regarding context dependabilityfor their objects used.
to create a practical implementation we introduce a new ifds based algorithm for reasoning aboutobject reachability in a program.
by debloating contexts for tworepresentative object sensitive pointer analyses applied to a set of12 representative java programs c onch can speed up the two baselines together substantially .1x on average with a maximumof .9x and analyze more programs scalably but at only anegligible loss of precision less than .
.
index t erms pointer analysis object sensitivity debloating i. i ntroduction many software engineering tasks such as call graph construction program slicing program understanding and bug detection often require precisepoints to alias information.
the quality of a pointer analysisdirectly determines the effectiveness and usefulness of thetools developed for accomplishing these tasks.
for object oriented languages object sensitive pointer analysis which distinguishes the calling contexts of a methodby its receiver objects is regarded as providing highlyuseful precision and thus widely adopted inseveral pointer analysis frameworks for java such as s oot d oop and w ala .
under k objectsensitivity denoted kobj a context used for analyzing a method mis represented by a sequence of kcontext elements under klimiting where o1is the receiver object of man the receiver object of a method in which oi 1is allocated .
so oiis an allocator ofoi .
currently kobj does not scale well for reasonably large programs when k greaterorequalslant3and is often time consuming when it is scalable .
as kincreases the number of contexts analyzed for a method often blows up exponentially withoutimproving precision much.
to alleviate this issue severalrecent research efforts focus on selectivecontext sensitivity which first conducts a pre analysis to theprogram and then instructs k obj to apply context sensitivity only to some of its methods selected.
a number of attemptshave been made including client specific machine learningtechniques guided by improving the precision of a givenclient e.g.
may fail casting and general purpose techniques such as user supplied hints pattern matching and cfl context free language reachability .
despite some performance improvements obtained atno or a noticeable loss of precision these existing selectivecontext sensitive pointer analysis algorithms still suffer froman unreasonable explosion of contexts.
we introduce a new approach c onch for debloating contexts for all object sensitive pointer analysis algorithms including k obj and its various incarnations for performing selective context sensitivity by boosting their performance sig nificantly with negligible loss in precision.
in object orientedprograms we observe that a large number of objects that areallocated in a method are used independently of its callingcontexts.
distinguishing these objects context sensitively asoften done in the past will serve to increase only the numberof calling contexts analyzed for the methods invoked on theseobjects as receivers without any precision improvement.
our key insight is to approximate a recently proposed set of two necessary conditions for an object to be context sensitive i.e.
context dependent whose precise verification is undecidable with a set of three linearly verifiable nec essary conditions in terms of the number of statements in theprogram based on three key observations regarding context dependability for the objects used practically in real worldobject oriented programs.
to create a practical implementationfor c onch we have developed a new lightweight ifds based algorithm for verifying these conditions governing objectreachability .
by allowing only context dependent objects tobe handled context sensitively c onch can significantly limit the explosive growth of the number of contexts and achievesubstantially improved efficiency and scalability.
we have implemented c onch on top of the s oot framework and evaluated it with popular java benchmarksand applications.
compared with k obj and z ipper a representative of selective context sensitive pointer analyses c onch can speed up the two baselines together substantially .1x on average with a maximum of15.9x and analyze more programs scalably but at no lossof precision for programs and only a negligible loss ofprecision less than .
for the remaining two.
in summary this paper makes the following contributions we present context debloating a new approach for accel erating all object sensitive pointer analysis algorithms.
we give a set of three mostly necesssary conditionsfor determining an object s context dependability andpropose a new lightweight ifds based algorithm for ver ifying them on the p ag representation of a program.
we have implemented c onch in the s oot framework and will release it soon as an open source tool.
36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee 1void main 2b b new b b1 b1.foo 4b b new b b2 b2.bar 7class a object f void setf object o this.f o object getf return this.f 12class b a g b this.g new a a void f o o object o1 new object o1 a a1 this.g a1.setf o1 object v1 a1.getf void b a r object o2 new object o2 a a2 this.g a2.setf o2 object v2 a2.getf fig.
an example for illustrating object sensitivity.
o1 o a.f v1 o2 v2 o1 o a.f v1 o2 v2 a andersen o1 o a.f v1 o2 a.f v2 o1 o a.f v1 o2 a.f v2 b 2obj o fig.
computing the points to information for v1 andv2 in figure by applying andersen s analysis and 2obj .
we have extensively evaluated the effectiveness of conch using several popular metrics and demonstrated its practical significance for real world programs.
the rest of this paper is organized as follows.
section ii motivates our approach.
section iii gives a version of kobj that supports context debloating.
section iv presents our conch approach.
in section v we evaluate the effectiveness of c onch in terms of context debloating.
section vi discusses the related work.
finally section vii concludes the paper.
ii.
m otiv a tion we first review object sensitivity as a context abstraction section ii a .
we then examine the limitations of existing object sensitive pointer analysis algorithms section ii b .
fi nally we motivate context debloating by describing the basicidea behind this new approach examining the main challengesfaced in realizing it efficiently and effectively and discussingour solution for addressing these challenges section ii c .
a. object sensitivity we briefly review object sensitive pointer analysis with an example given in figure .
in lines we define class a which has a field fand its corresponding setter and getter methods.
in lines we define class b which has a field g a constructor and two regular methods foo and bar .
in foo bar of class b an instance of java.lang.object o1 o2 is created.
later o1 o2 is firstly stored into a.f and then loaded into v1 v2 via thesetf andgetf methods respectively.
in main two instances of b b1 andb2 are created and used as the receivers for invoking foo and bar respectively.
in a context insensitive andersen s analysis every method is analyzed only once under an empty context .
let pts v denote the points to set of a variable vthus computed.as illustrated in figure a o1 ando2 are merged at o line and will later flow spuriously to v2 andv1 respectively.
hence we have pts v1 pts v2 o1 o2 .
in ak object sensitive pointer analysis k obj denoted a the calling contexts of a method are distinguished byits receiver objects with each being abstracted by its kmost recent allocation sites .
we write pts a v c to represent the points to set of a variable vthus computed under a context c. in the case of 2obj i.e.
kobj withk setf getf will be analyzed differently for its two invocations in lines and lines and under twodifferent contexts and .
as a result o1 created under context and o2 created under context will flow along two separate paths to v1 andv2 respectively figure b .
hence pts 2obj v1 o1 and pts2obj v2 o2 without the spurious pointsto information generated by andersen s analysis.
in general when a method mis analyzed under a context o1is a receiver object of m an a receiver object of a method where oi 1is allocated and thus known as theallocator object ofoi where i lessorequalslantk.
thus any objecto0that is allocated in mis identified as o0 where is known as the heap context ofo0.
b. limitations of existing algorithms we now use an example in figure which reuses class bfrom figure to reveal the limitations of kobj and existing approaches for selective context sensitivity in analyzing real world programs.
in lines we define class c with a total of n methods.
in lines where lessorequalslantj 2i 2i lessorequalslantj 2i a method foo i j bar i j is defined in which an object ci j is created and used as the receiver to invoke fooi j bari j .
in lines we define foo bar where an instance of b defined in figure b3 b4 is created and used to invoke foo bar .
in main lines 2ninstances of c denoted as c n j where lessorequalslantj 2n are created and used as the receivers to call foon j whenj 2n 1and barn j whenj 2n .
figure depicts the oag object allocation graph where an edge o o primesignifies that o is an allocator ofo prime.f o rk obj the contexts of a method can be directly read off from this graph by starting fromits receiver object and then retrieving the next k 1objects backwards.
for example the contexts of foo and bar are b3 c j 2k ck j ck j lessorequalslantj 2k and b4 c1 j 2k ck j ck j 2k lessorequalslant j 2k respectively.
let cj x a x c1 j 2k ck j ck j .
both setf andgetf share the contexts in cj b3 lessorequalslantj 2k cj b4 2k lessorequalslantj 2k .
in practice the number of contexts for analyzing a method can be exponential.
for example there are a total of 2k 2contexts for foo bar setf andgetf .a s kincreases such a method becomes exponentially expensive to analyze consuming more and more memory and analysis time.
8029class c void fooi j j 2i c c i j new c c i j c i j .
fooi j d bar i j d d 2i j c c i j new c c i j c i j .
bari j d return d void foo0 b b3 new b b3 b .f o o d bar d d b b4 new b b44 b .b a r return d 52class d 53void main d d new d d c c new c c n c .
foo n .
.
.
c c new c c n n c .
foon n c c new c cn n c .
barn n d .
.
.
c c new c c n n c .
barn n d fig.
an example for motivating c onch lessorequalslanti lessorequalslantnand lessorequalslantj 2i reusing class bdefined in lines in figure .
cn ................ cn 2n ...... ci ...... ...ci j ...... c i 2i ... c1 c1 b3 b4 o1ad o2 fig.
the object allocation graph oag for figure where only the two edges in red will remain after context debloating.
existing approaches for selective context sensitivity can improve the efficiency and scalability of kobj .
for example z ipper which does not preserve the precision ofkobj will select main b foo bar and foo i j where j ri to be analyzed context insensitively.
however the context explosion problem still remains forbar i j setf andgetf .e agle which preserves the precision of kobj is worse as it will also analyze b foo andbar partially context sensitively.
c. conch our context debloating approach basic idea we offer a new approach to mitigating the context explosion problem.
our approach named c onch context dependability checking aims to debloat contextsduring the pointer analysis and thus complements the priorwork on selective context sensitivity.
c onch can be plugged into all object sensitive analysis algorithms including kobj and its various incarnations for supporting selective context sensitivity to boost their performance signif icantly with negligible loss in precision.
for our motivatingexample only ais context dependent.
handling any of the other objects context sensitively will cost an exponential in crease in analysis time without any precision benefit.
to illustrate context debloating using the oag in figure we will remove all the allocators of a context independentobject so that the exponential growth of contexts for the objectis avoided completely.
under c onch only the two edges in red will remain as ais the only context dependent object in the example.
this implies that only setf and getf will be analyzed context sensitively under and .
all the other methods will be analyzed context insensitively.
for this example debloating contexts can helpk obj and its variants reduce their analysis times and memory consumption significantly without losing any precision.
letabe any existing object sensitive analysis for java.
in practice ais usually used for analyzing a program according to client s needs under different settings depending on forexample how complex java features such as exceptions reflection and native code are handled and whether or notcertain objects are pre configured to be context insensitiveempirically .
apparently a will exhibit different analysis times under different settings a problem that we do not addressin this paper.
however for a fixed setting given c onch can accelerate aat no or little loss of precision by debloating its contexts.
let a1anda2be two different object sensitive analyses used for analyzing a program under two differentsettingss 1ands2.
it is possible that a1is faster than a2 unders1but the opposite is true under s2 which is again a problem that we do not investigate here.
however for a fixedsetting given c onch can accelerate both analyses at no or little loss of precision by debloating their contexts.
challenges to debloat contexts we must find contextdependent objects.
recently the following two necessaryconditions are given for determining the context dependabilityof an object oallocated in a method mbased on cfl reachability requiring us to check the existence of a write into anda read from an access path o.f .
.fncontext sensitively where the two accesses often happen outside m a c o.f .
.fn there exists an object athat flows intomfrom outside and ends up being stored later into o.f .
.fnunder a calling context cofm and o.f .
.fn c v there exists a load of o.f .
.fn flowing into a variable voutsidemunder also c. where context matching is formulated by solving the standardbalanced parentheses problem .
if these two conditionshold omust be context dependent.
otherwise different objectsa flowing into o.f .
.fnunder different calling contexts of mwill be conflated causing them to flow into different variables vspuriously.
in object sensitive pointer analysis the parameters and return variable of a method arealso conceptually regarded as special fields of its receiverobjects .
thus in the access path above a field f i can be either a real java field or one of such special fields.
unfortunately verifying these two conditions precisely is undecidable as it requires us to solve kobj fully contextsensitively with k .
in addition weakening these two conditions will over approximate unduly the numberof context dependent objects found but approximating themheuristically may cut it down significantly but atthe expense of some significant precision loss.
our solution to identify context dependent objects efficiently and effectively our key insight is to approximatethe two aforementioned necessary conditions with the threeconditions that are linearly verifiable in terms of the number 81of statements and mostly necessary for real code based on three key observations governing how objects are used.
like the prior work on selective context sensitivity c onch also relies on the points to information pts pre computed by andersen s analysis.
observation .
a context dependent object ooften has at least one instance field o.f that is both written into x.f and read from x.f whereo pts x .
1void main 2a a new a a object o new object o object v a .
wrapid o 6class b object id object q return q 10class a object wrapid object p b b new b b return b.i d p fig.
a context dependent object bviolating obs .
there can be rare cases as illustrated in figure where obs may not be valid for some context dependent objects such as b. under object sensitivity opointed to by pis first written into b.q and then returned and stored into v. as discussed in section ii c2 qis considered as a special field of b. such cases are rare in real world object oriented programs as c onch loses little precision section v .
observation .
a context dependent object o pointed to by a variable or a field of some object according to pts usually flows out of its containing method for allocating o .
v ector int size this .
elems n e w object a case from vector1 iterator iterator return new keyiterator b case from hashmap 1void sunjce ea ... bufferedreader br new bufferedreader this .f new streamtokenizer br c case from sunjce e fig.
three common cases abstracted from jdk for obs .
figure gives three representative cases abstracted from the jdk where obs holds.
in figure a the array objectcreated flows out of the constructor via a store.
in figure b thekeyiterator object created flows out of iterator directly via a return.
in figure c we have a slightlymore complicated case.
the bufferedreader object created flows out of its containing method as it is stored intotheinput field of the streamtokenizer object which flows out of the containing method via a store.
the objectsthat cannot flow out of their containing methods are usuallycontext independent as they are often created and used locally.
observation .
a context dependent object otends to have a store statement x.f yin a method m prime whereo pts x .
letmbe the method where ois allocated if m primeis a constructor i.e.
the constructor for creating o andm prime otherwise.
then y a is data dependent on a parameter of mor b points to a context dependent object.
arraylist this .
elems new object 4void set int idx e e this .
elems e a case from arraylist1void addentry int idx k k v v this .
table new entry k v entry k k v v this .
key k this .
value v b case from hashmap.
hashset this .m a p new hashmap hashmap ... this .
table new entry c case from hashset andhashmap.
fig.
three common cases abstracted from jdk for obs .
figure gives three representative cases abstracted from the jdk where obs holds.
in figure a ois the object object allocated in line and x.f yisthis.elems e which is modeled as this.elems.arr e where arr is a special field introduced to represent all the elements of an array section iii .
in this case m m prime set .
here esatisfies obs a trivially.
in figure b o is the entry object allocated in line x.f yis this.key k this.value v m prime entry and m addentry .
here k v in line also satisfies obs a trivially.
in figure c ois the hashmap object allocated in line x.f yisthis.table new entry m prime hashmap and m hashset .
asnew entry is context dependent by obs as well as obs and obs if the entire code is considered thehashmap object in line is also context dependent by obs b .
in obs b the circular dependences on context dependability are solved optimistically in algorithm .
motivating example for this example given in figure with class bfrom figure c onch will identify aas the only context dependent object.
let us examine figure whereais created in line .
ais context dependent as it satisfies all the three observations ahas an instance field f which has a write and a read in lines and respectively obs a can flow out of b via the store statement in line obs and ois stored into a.f in line where ohappens to be a parameter of setf obs .
let us now consider b3 and b4 created in figure .
both are context independent as both satisfy obs with an instance field gofb3 b4 stored in b and loaded in foo bar in figure and obs due to the existence of this.g new a a in line where ais context dependent but not obs as b3 b4 does not flow out of its containing method foo bar .
finally all the other objects are context independent as theydo not contain instance fields and are used only locally failingto satisfy any of the three observations stated.
discussion c onch relies on obs obs to generate three corresponding linearly verifiable conditions for determin ing the context dependability of an object.
in section iv weintroduce a lightweight ifds based algorithm for verifyingthese conditions efficiently.
in section v we demonstrate c onch is highly effective for real world programs.
iii.kobj with context debloa ting we formalize context debloating here.
we first review the classic algorithm for kobj section iii a and then adapt it 82to support context debloating section iii b .
c onch can be used similarly for debloating contexts for any variant of kobj .
a.kobj we describe kobj by considering a simplified subset of java with five types of labeled statements in table i. note that x newt ... is modeled as x new t x .
angbracketleftinit angbracketright ... where angbracketleftinit angbracketright ... is the corresponding constructor invoked.
the control flow statements are irrelevantsincek obj is context sensitive but flow insensitive.
loads and stores to the elements of an array are modeled by collapsingall the elements into a special field arr of the array.
every method is assumed to have one return statement return ret whereret is known as its return variable.
section v discusses how to handle static method calls and other complex languagefeatures such as exceptions reflection and native code.
kind statement kind statement new l x new t assign l x y store l x.f y load l x y.f call l x a0.f a1 ... a r t able i five types of statements analyzed by kobj .
kobj makes use of the following domains v h m f andl which represent sets of program variables heap objects identified by their labels methods field names andstatements identified also by their labels respectively.
we usec h as the universe of contexts.
given a context ctx cand a context element e h we write e ctx for and ctx kfor .
the following auxiliary functions are also used methodof l m methodctx m c dispatch m h m pts v h f c h c where methodof gives the containing method of a statement methodctx maintains the contexts used for analyzing a method dispatch resolves a virtual call to a target method and pts records the points to information found contextsensitively for a variable or an object s field.
figure gives the five rules used by kobj for analyzing the five kinds of statements in table i. in ol his an abstract heap object created from the allocation site at l identified by its heap context hctx.
rules and are handled in the standard manner.
in a call to an instance method x a0.f a1 ... a r is analyzed.
in this paper we write thism prime pm prime i andretm primefor the this variable i th parameter and return variable of m prime respectively wherem primeis a target method resolved.
frequently we also writepm prime forthism prime.
in the conclusion of this rule ctx prime methodctx m prime reveals how the contexts of a method are maintained.
initially methodctx main .
b. context debloating to debloat contexts we assume that drepresents the set of context independent objects found by c onch .
thus thel x newtm methodof l ctx methodctx m hctx ctx k ol hctx pts x ctx l x ym methodof l ctx methodctx m pts y ctx pts x ctx l x.f ym methodof l ctx methodctx m o hctx pts x ctx pts y ctx pts o.f hctx l x y.f m methodof l ctx methodctx m o hctx pts y ctx pts o.f hctx pts x ctx l x a0.f a1 ... a r m methodof l ctx methodctx m o hctx pts a0 ctx m prime dispatch f o ctx prime o hctx ctx prime methodctx m prime o hctx pts thism prime ctx prime i pts ai ctx pts pm prime i ctx prime pts retm prime ctx prime pts x ctx fig.
rules for kobj .
l x newtm methodof l ctx methodctx m hctx braceleftbigg ifol d ctx k ifol h d ol hctx pts x ctx fig.
adapting to support context debloating.
objects in h d are context dependent.
to modify kobj to support context debloating we simply replace by given in figure .
for a context dependent object we proceed identically as before.
for a context independentobject we no longer distinguish it under its different alloca tors by setting its heap context as hctx eliminating the context explosion problem that would otherwise have occurredwhen it is used as a receiver object of an invoked method.
c onch is conceptually simple algorithmically easy to plug into any existing object sensitive pointer analysis and practi cally effective as validated during our extensive evaluation.
iv .
c onch o ur context debloa ting approach we introduce an ifds based algorithm for verifying efficiently the three mostly necessary conditions stated inobs obs to find the context dependent objects ina program.
as these conditions are not sufficient we maymis classify context independent objects as being context dependent but err on the side of preserving precision .
asthese conditions are mostly but not strictly necessary fig ure we may occasionally mis classify context dependentobjects as being context independent at a small loss ofprecision .
we use the points to information pts pre computed by andersen s analysis which is the context insensitiveversion of figure .
we first give a high level overview ofalgorithm and then discuss how to verify these conditions.
c onch takes a program pas input and returns das the set of context independent objects in pfor context debloating.
some additional notations are in order.
for a given object o fieldsof o denotes the set of the fields of o. in addition hasload o f hasstore o f holds if pcontains a load x.f storex.f such that o pts x .c ia n d cd which are initialized to be line represent the sets 83algorithm conch context debloating.
input p input program output d. set of context indep objects 1ci cd 2forol hdo if f fieldsof o l s.thasload o l f hasstore o l f then ci ci ol obs else if ol leakobjects then ci ci ol obs else r ol l prime x.f yinp ol pts x forl prime x.f y r ol do ifmethodof l prime is a constructor of olthen m methodof l else m methodof l prime ifdeponparam y m then cd cd ol obs a break 17uk h ci cd changed true 18while changed do changed false forol uk do if l prime x.f y r ol s.t.
pts o l.f cd negationslash then cd cd ol obs b changed true 24d ci uk cd 25returnd of context independent and context dependent objects found so far respectively.
there are two stages with the first stage lines for verifying obs obs and obs a and thesecond stage lines for verifying obs b .
a. v erifying observation in lines an object o lis classified as being contextindependent and inserted into ci if it does not satisfy obs .
otherwise we will proceed to verify obs and obs .
b. v erifying observation in lines an object olis classified as being contextindependent and inserted into ci if it does not satisfy obs i.e.
ol leakobjects where leakobjects contains the set of objects that can flow out of their containing methods byobs .
otherwise we will proceed to verify obs .
we introduce an ifds based algorithm given in figure for computing leakobjects inpcontext sensitively based on the dfa deterministic finite automaton given in figure .computing leakobjects entails reasoning about object reachability in p. let us describe it incrementally.
initially we start with a parameterless method containing no calls.
its p ag pointer assignment graph can be builtby the rules in figure .
our analysis is field insensitive asreflected by p l oad and .
figure a gives a dfa for tracing approximately how an object oallocated in a method flows over the p ag.
there are four states h starting at a heap object f moving forwards in the p ag b moving backwards in the p ag and e exiting from the allocating method .
due to the absence of parameters and returns nol x newt olnew xxnew ol x y yassign xxassign y x y.f yload xxload y x.f y ystore x fig.
p ag edges for a parameterless method with no calls.
pis a parameter pparam p ret is a return variable retreturn ret fig.
p ag edges for parameters and return variables.
h startf benewassign store assign loadnew a no calls parameters returnsh startf benewassign storereturn assign loadparamnew b no calls fig.
two intermediate dfas for the dfa in figure .
h startf benewassign storeinterassign return interstore assign loadparam interloadnew fig.
the dfa for verifying obs .
object can flow out of a method once it is allocated inside as indicated by the lack of transitions into the final state e. let us explain the object reachability analysis supported by this dfa figure a .
if the dfa starts with an objectounder state h and transits to a node xunder state f by following a sequence of p ag edges then either oflows directly to x via a new edge and possibly some assign edges orofirst flows into an access path o prime.f1.
.fn o where o prime which is a locally allocated object flows to x. if the dfa starts with an object ounder state hand transits to a node y under state b then either ois stored directly into an access path ofy i.e.
y.f1.
.fn o o ro is firstly stored into an access path of some locally allocated object o primeand then o prime is stored into an access path of y i.e.
y.f1.
.fn o prime.i n this dfa the load edges in the p ag are ignored as we track whereorather than its pointed to objects flow to but are used by the dfa in figure for computing deponparam .
in addition the dfa also ignores the store edges in the p ag as we assume that a method rarely contains a storeand a load operating on the same field of an object which 84is often accessed via its getter andsetter .
in the rare cases where this fails to hold c onch may classify a contextdependent object as being context independent causing the underlying pointer analysis to lose some precision.
to support parameters and return variables we add their self loop edges using the rules in figure and transform thedfa in figure a into the one in figure b .
once anobject allocated in a method flows to a parameter suggestedby param or the return variable suggested by return under statee it has leaked.
the final dfa is presented in figure where the three dotted transitions are added for handling call statements.
whileeach method has its own p ag some summary edges are addedto its p ag for its call sites to capture the inter proceduralvalue flows across these call sites context sensitively alongthe three dotted transitions.
the call graph is built using pts.
given a call statement l x a0.f a1 ... a r contained in methodm letm primebe a resolved target method with pm prime ibeing itsi th parameter and retm primebeing its return variable .
let n1 andn2be two p ag nodes.
we write angbracketleftn1 s1 angbracketright angbracketleftn2 s2 angbracketright known as a path edge in to indicate that node n1at states1can reach node n2at states2.
let us write gmas the p ag of m. there are four cases considered when m primeis analyzed angbracketleftpm prime i f angbracketright angbracketleftpm prime j e angbracketright pm prime i is saved into some access path ofpm prime j i.e.
pm prime j.f1.
.fn pm prime i. thus we add a summary edge aiinterstore aj i.e.
aj.f ai togm to propagate this reachability fact inter procedurally.
angbracketleftpm prime i f angbracketright angbracketleftretm prime e angbracketright pm prime i is saved into some access path of a locally allocated object oinm prime i.e.
o.f .
.fn pm prime i and then oflows out of m primevia its return.
thus we add a summary edge aiinterassign x togmto reflect this reachability fact inter procedurally.
angbracketleftretm prime b angbracketright angbracketleftpm prime i e angbracketright retm primeis loaded from some access path of pm prime i i.e.
retm prime pm prime i.f1.
.fn.
thus we add a summary edge xinterload ai i.e.
x ai.f to gmto propagate this reachability fact inter procedurally.
angbracketlefto h angbracketright angbracketleftretm prime e angbracketright o which is allocated in m prime fl o w s out ofm primevia its return.
we introduce a symbolic object sym lto abstract all the possible objects returned from the call site land continue our analysis in m. figure gives our ifds based algorithm for computing leakobjects operating on a p ag instead of a cfg representation of a program.
the rules in inject three kinds of path edges where the first one is for tracingleak objects while the other two are for finding summaryedges which are not injected on demand in order to improveparallelism in a parallel implementation of our algorithm .the rules in p ropagate perform the reachability analysis according to the dfa in figure .
note that the three dottedtransitions in the dfa are implicitly handled by the summaryedges generated in s ummary .
finally we collect the objects that can reach the final state e by using .c.
v erifying observation in lines we verify if an object olsatisfies obs a .
in the case of a positive answer olis considered immediately as being context dependent and thus inserted into cd sinceo lhas already satisfied both obs and obs at this point.
otherwise we proceed to verify obs b in lines .
the key to verifying obs a lies in deponparam y m which returns true if yis data dependent on any parameter of methodm.
we have also designed and implemented an ifdsbased algorithm for computing deponparam in a similar manner as how we have computed leakobjects in figure by making use of a simpler dfa given in figure .
this dfa has only two states fande recognizing only four types of p ag edges where interassign is a summary edge introduced for supporting call statements.
given a callstatement l x a .f a1 ar in method m. letm prime be a target method invoked.
when angbracketleftpm prime i f angbracketright angbracketleftretm prime e angbracketright happens retm primeis recognized to be data dependent on pm prime i i.e.
retm prime pm prime i.f1.
.fn .
thus we add a summary edge aiinterassign x t ot h ep a go fm to propagate this reachability fact inter procedurally from the callee m primeto the caller m. our algorithm for computing deponparam which proceeds forwards from method parameters is a simplified ver sion of the one in figure .
for s eeds only the parameters need to be injected.
the rules for are similar.
for we use the summary edges added as discussed above.
finally let dps v m v pmv i angbracketleftpmv i f angbracketright angbracketlefty f angbracketright wherevis a variable defined in its containing method mvandpmv i is some i th parameter of mv.
then deponparam y m can be defined recursively as by taking care of chained constructors in practice deponparam y m dps y m y negationslash ifm my logicalortext pmy i dps y m y deponparam a i m otherwise whereaiis the corresponding argument of pmy i. finally obs b can be verified straightforwardly.
at this point ci and cd contain the sets of context independent and context dependent objects found so far.
let obe an object inh ci cd .ois regarded as being context dependent if it can point to any context dependent object found so far transitively and context independent otherwise.
d. soundness and time complexity c onch is sound as it may mis classify some contextdependent objects as being context independent and thus cause the underlying pointer analysis to produce over approximatedpoints to information resulting in some loss of precision.
the worst case time complexity of c onch in analyzing a program pis linear to the number of its statements for three reasons.
first leakobjects can be computed according to figure in o ed3 where eis the number of p ag edges in p which are constructed linearly to the number of statements in paccording to figures and and d is the number of states of the dfa in figure .
second the first stage of algorithm lines runs in o l angbracketleftol h angbracketright angbracketleftol h angbracketright angbracketleftpm i f angbracketright angbracketleftpmi f angbracketright angbracketleftretm b angbracketright angbracketleftretm b angbracketright angbracketleftn1 s1 angbracketright angbracketleftol h angbracketrightl n2 newt angbracketleftn1 s1 angbracketright angbracketleftn2 f angbracketright angbracketleftn1 s1 angbracketright angbracketleftn2 f angbracketrightl n3 n2 angbracketleftn1 s1 angbracketright angbracketleftn3 f angbracketright angbracketleftn1 s1 angbracketright angbracketleftn2 f angbracketrightl n3.f n2 angbracketleftn1 s1 angbracketright angbracketleftn3 b angbracketright angbracketleftn1 s1 angbracketright angbracketleftn2 b angbracketrightl n2 n3 n3.f angbracketleftn1 s1 angbracketright angbracketleftn3 b angbracketright angbracketleftn1 s1 angbracketright angbracketleftn2 b angbracketrightl n2 newts negationslash b angbracketleftn1 s1 angbracketright angbracketleftol h angbracketright angbracketleftn1 s1 angbracketright angbracketleftn2 s2 angbracketright angbracketleftn2 s2 angbracketright angbracketleftn3 s3 angbracketright sum angbracketleftn1 s1 angbracketright angbracketleftn3 s3 angbracketright angbracketleftn1 s1 angbracketright angbracketleftretm f angbracketright angbracketleftn1 s1 angbracketright angbracketleftretm e angbracketright angbracketleftn1 s1 angbracketright angbracketleftpmi b angbracketright angbracketleftn1 s1 angbracketright angbracketleftpmi e angbracketright angbracketleftpmi f angbracketright angbracketleftpmj e angbracketrightpmi negationslash pmjl x a0.f a1 ar o pts a0 m dispatch f o angbracketleftai f angbracketright angbracketleftaj b angbracketright sum angbracketleftpmi f angbracketright angbracketleftretm e angbracketrightl x a0.f a1 ar o pts a0 m dispatch f o angbracketleftai f angbracketright angbracketleftx f angbracketright sum angbracketleftretm b angbracketright angbracketleftpmi e angbracketrightl x a0.f a1 ar o pts a0 m dispatch f o angbracketleftx b angbracketright angbracketleftai b angbracketright sum angbracketlefto h angbracketright angbracketleftretm f angbracketrightl x a0.f a1 ar o pts a0 m dispatch f o angbracketleftx b angbracketright angbracketleftsym l h angbracketright sum angbracketleftsym l h angbracketright angbracketleftx f angbracketright sum angbracketleftol h angbracketright angbracketleftpmi e angbracketright ol leakobjects angbracketleftol h angbracketright angbracketleftretm e angbracketright ol leakobjects fig.
rules for computing leakobjects i.e.
the set of objects that can flow out of their containing methods for verifying obs .si h f b where i andsym lis a symbolic object abstracting all objects returned from call site l. f start eassign load interassignreturn fig.
the dfa used for computing deponparam.
wherelis the set of statements in p. finally the second stage of algorithm lines can be efficiently performed in o h wherehis the set of heap objects in p. v. e v alua tion we demonstrate the effectiveness of our c onch approach by addressing the following two research questions rq1.
is c onch precise and efficient?
rq2.
can c onch speed up existing object sensitive analysis algorithms significantly?
implementation.
we have implemented c onch in s oot a program analysis and optimization framework for java on top of its context insensitive andersen s pointer analysis s p ark for computing pts .
c onch is implemented in about lines of java code which will soon be releasedas an open source tool at corg conch along with a reproducible artifact in the form of a docker image.
as described in section ii c onch aims to boost the performance of all object sensitive pointer analysisalgorithms.
we report and analyze our results by applying c onch to debloat two representative baselines kobj anobject sensitive version of s p ark and z ipper the latest version b83b038 which can deliver the arguably best speedupsfork obj among the recent algorithms for supporting selective context sensitivity in our experimentalsetting .
due to space limitations we will only summarizethe significant performance benefits also achieved by c onch in debloating contexts for e agle .
experimental setting.
kobj is a standard in house implementation of s p ark in s oot .
as for z ipper originally released in d oop but used here to accelerate kobj in soot we have used an analysis setting that is as close as possible to the one used by z ipper in several major aspects.
first we perform an exception analysis on the flywithk obj as in d oop by handling exceptions along the socalled exception catch links .
second we use the declaredtype of an array element instead of java.lang.object to filter type incompatible points to objects.
third we handlenative code by using the summaries provided in s oot .
fourth we analyze a static method m by using the contexts of m s closest callers that are instance methods on the callstack and resolve java reflection by using the reflection loggenerated by t amiflex as is often done in the pointer analysis literature .
finally objects that areinstantiated from stringbuilder andstringbuffer as well as throwable including its subtypes are distinguished per dynamic type and then analyzed context insensitively asis done in d oop and wala .
we have conducted our experiments on an intel r xeon r cpu e5 .2ghz machine with 256gb of ram.
we 86have selected a set of popular java programs including benchmarks from dacapo and java applications checkstyle jpc andfindbugs .
the java library used isjre1.
.0 45. these are the standard java programs that are frequently used for evaluating pointer analysis algo rithms .
the time budget used for runningeach pointer analysis on a program is set as hours.
theanalysis time of a program is an average of three runs.
a. rq1 is c onch precise and efficient?
given base a baseline pointer analysis and base d base with its contexts debloated by c onch we measure the precision of c onch in terms of precision loss incurred with respect to a given metric metric when both base and base d are applied to analyze the same program metric base d metric base metric base where metric base and metric base d are the metric numbers obtained by base and base d respectively.
we use four common metrics for measuring the precision of a contextsensitive pointer analysis fail cast the number of type casts that may fail call edges the number of call graph edges discovered poly calls the number of polymorphic calls discovered and reach mtds the number of reachable methods.
table ii gives our main results.
for kobj zkobj denotes the version of kobj with selective context sensitivity provided by z ipper .
all the baselines where k and their debloated versions are compared over the java programs.
conch is very precise in terms of supporting context debloating while losing negligible precision.
our approachpreserves the precision of all the baselines for programsconsisting of the dacapo benchmarks and findbugs.
forcheckstyle andjpc our approach suffers from an average precision loss of only less than .
across the fourmetrics .
this happens since a propertychangeevent object created in method firepropertychange ... of class java.beans.propertychangesupport and a linereader object created in method load inputstream ofjava.util.properties have been misclassified as being context independent by c onch as they do not satisfy obs .
conch is also highly efficient as a pre analysis .
table iii gives the times spent by s p ark z ipper and c onch .
note that both z ipper and c onch are designed to be multithreaded with threads used in our experiments .
c onch is slightly faster than z ipper and s p ark across all the programs.
on average we have .
seconds c onch .
seconds z ipper and .
seconds s p ark .
thus c onch is efficient enough for supporting context debloating.
b. rq2 can conch speed up baseline analyses?
table ii also gives the analysis times of all the analyses.
conch deliver significant speedups geometric means over all the baselines.
for kobj the speedups of 2obj d overt able ii main results.
in all metrics except for speedups smaller is better.
given an analysis base base d is its debloated version by c onch .
oom stands for out of memory .
classic kobj selective kobj prog metrics 2obj 2obj d 3obj 3obj d z2obj z2obj d z3obj z3obj d time s .
.
.3x .
.
.7x .
.
.7x .
.
.5x fail cast call edges poly calls 1636antlr reach mtds time s .
.
.1x 12h .
.
.
.9x oom .
fail cast call edges poly calls 1716bloat reach mtds time s .
.
.0x oom .
.
.
.7x .
.
.2x fail cast call edges poly calls 2040chart reach mtds time s 12h .
oom oom .
.
.2x oom oom fail cast call edges poly calls eclipse reach mtds time s .
.
.8x .
.
.2x .
.
.8x .
.
.0x fail cast call edges poly calls 826fop reach mtds time s .
.
.2x .
.
.9x .
.
.9x .
.
.2x fail cast call edges poly calls 937luindex reach mtds time s .
.
.6x .
.
.8x .
.
.5x .
.
.9x fail cast call edges poly calls 1136lusearch reach mtds time s .
.
.7x .
.
.8x .
.
.6x .
.
.6x fail cast call edges poly calls 2376pmd reach mtds time s .
.
.9x oom .
.
.
.0x .
.
.2x fail cast call edges poly calls 1629xalan reach mtds time s .
.
.9x 12h oom .
.
.7x oom .
fail cast call edges poly calls 2211checkstyle reach mtds time s .
.
.9x .
.
.0x .
.
.3x .
.
.0x fail cast call edges poly calls 4188jpc reach mtds time s .
.
.0x oom .
.
.
.6x .
.
.1x fail cast call edges poly calls 3643findbugs reach mtds t able iii times spent by pre analyses in seconds.
antlr bloat chart eclipse fop luindex lusearch pmd xalan checkstyle jpc findbugs sp ark .
.
.
.
.
.
.
.
.
.
.
.
zipper .
.
.
.
.
.
.
.
.
.
.
.
conch .
.
.
.
.
.
.
.
.
.
.
.
2obj range from .7x for pmd to .0x for findbugs with an average of .6x.
when k the speedups of 3obj d over 3obj are more impressive ranging from .9x forluindex to .0x for jpc with an average of .2x.
for zipper the speedups of z 2obj d over z 2obj range from .0x for xalan to .7x for antlr with an average of .8x.
when k the speedups of z 3obj d over z 3obj are also more impressive ranging from .2x for xalan t o .9x for lusearch with an average of .6x.
87these results suggest that the speedups delivered by c onch increase as kincreases implying that c onch can help all the baselines improve their scalability.
in particular 2obj d scales one more benchmark i.e.
eclipse than 2obj 3obj d can scale more benchmarks bloat chart xalan and findbugs than 3obj and z 3obj d can scale more benchmarks bloat andcheckstyle than z3o bj.
in general an analysis may be unscalable due to running either out of memory oom or the time budget 12h .
due to space limitations let us summarize briefly the significant performance benefits achieved by c onch in debloating contexts for e agle .
unlike z ipper which makeskobj run faster while losing precision e agle aims to accelerate kobj while preserving its precision.
for kobj let ekobj be the version of kobj with selective contextsensitivity enabled by e agle .
for the four precision metrics considered in table ii fail cast call edges poly calls and reach mtds e kobj yields the same results as kobj and ekobj d yields the same results as kobj d in theory.
as for the performance speedups achieved c onch is nearly as effective for e agle as for z ipper .
the speedups of e 2obj d over e 2obj range from .3x for eclipse to .7x for findbugs with an average of .1x and the speedups of e3obj d over e 3obj range from .8x for luindex t o .2x for lusearch with an average of .8x.
in addition conch scale more benchmarks bloat chart xalan andfindbugs under e 3obj d than under e 3obj .
therefore c onch can accelerate existing object sensitive pointer analyses significantly with negligible loss in precision.these include not only k obj the standard algorithm but also its variants enabled by e.g.
z ipper and e agle the two recent attempts on applying selective context sensitivity to improve the performance of k obj .
below we analyze in detail why context debloating can enable baseline analyses kobj and zkobj to improve their efficiency and scalability as reported in table ii .
fig.
percentage distribution of the two types of objects.
figure depicts the percentage distribution of contextdependent objects and context independent objects classifiedby c onch .c onch has successfully identified a large percentage of context independent objects in all the programs ranging from .
in eclipse to .
in fop with an average of .
.
thus a large amount of precision irrelevantcontexts has been eliminated via context debloating.
table iv compares the baseline analyses i.e.
k obj and zkobj and their debloated counterparts i.e.
kobj d and zkobj d in terms of the average number of contexts analyzed for a method where k .
the debloated analysest able iv average number of contexts analyzed for a methodbyk obj kobj d zkobj and zkobj d where k .
antlr bloat chart eclipse fop luindex lusearch pmd xalan checkstyle jpc findbugs 2obj .
.
.
.
.
.
.
.
.
.
.
2obj d .
.
.
.
.
.
.
.
.
.
.
.
z2obj .
.
.
.
.
.
.
.
.
.
.
.
z2obj d .
.
.
.
.
.
.
.
.
.
.
.
3obj .
.
.
.
.
.
3obj d .
.
.
.
.
.
.
.
.
.
z3obj .
.
.
.
.
.
.
.
.
z3obj d .
.
.
.
.
.
.
.
.
.
.
have achieved a substantial reduction in terms of this importantmetric across all the programs providing the reasons behindthe improved efficiency and scalability via context debloating.
finally we can also understand the effectiveness of c onch from a substantial reduction it has achieved in the numberof context sensitive facts inferred.
in table v cs gpts cs pts and cs fpts represent the numbers of context sensitiveobjects pointed by global variables i.e.
static fields localvariables and instance fields respectively and cs calls rep resents the number of context sensitive call edges.
in general the speedups of a pointer analysis over a baseline comefrom a significant reduction in the number of context sensitivefacts computed by the baseline.
for example obj d is significantly faster than 2obj forfindbugs as its number of context sensitive facts is significantly less than 2obj .
similarly z 3obj d is also much faster than z 3obj for lusearch.
however the analysis time of a pointer analysisis not linearly proportional to the number of context sensitivefacts computed .
consider xalan.z obj d has achieved a reduction of .
over z 2obj in terms of the number of facts inferred but their analysis times are comparable.
vi.
r ela ted work in this section we mainly review the prior work that is the most closely related to improving the performance of whole program pointer analysis for object oriented programs.
there are several recent efforts on exploiting selective context sensitivity to accelerate the performance of object sensitive pointer analysis i.e.
k obj .
e agle improves the efficiency of kobj while preserving its precision by conservatively reasoning about value flowsvia cfl reachability.
z ipper as a representative of nonprecision preserving approaches trades preci sion for efficiency by exploiting several value flow patterns.these techniques mitigate the context explosion problem ofk obj by analyzing only a subset of methods in the program context insensitively.
in contrast c onch represents a novel mitigation approach as it can debloat contexts for all theobjects in the program enabling existing algorithms to runsignificantly faster at a only negligible loss of precision.
when applying c onch to debloat contexts for z kobj and e kobj we have observed that their relative performance advantages depend on the experimental settingsused for good reasons .
in e k obj outperforms z kobj when both are evaluated in s oot by using the exception analysis provided by s p ark and disallowing manual 88t able v context sensitive facts.
classic kobj selective kobj prog metrics 2obj 2obj d 3obj 3obj d z2obj z2obj d z3obj z3obj d cs gpts .9k .1k .1k .5k .7k .3k .6k .7k cs pts .8m .6m .8m .1m .6m .3m .1m .4m cs fpts .6m .1m .6m .3m .6m .1m .7m .3m cs calls .4m .3m .5m .7m .9m .5m .7m .1mantlr total .8m .1m .8m .1m .1m .9m .6m .8m cs gpts .1k .9k .3k .9k .0k .4k cs pts .8m .0m .0m .9m .6m .0m cs fpts .7m .6m .8m .9m .6m .0m cs calls .1m .9m .0m .2m .4m .0mbloat total .7m .5m .8m .0m .5m .9m cs gpts .5k .9k .3k .1k .5k .6k .9k cs pts .9m .8m .2m .2m .9m .8m .1m cs fpts .1m .4m .6m .7m .3m .7m .0m cs calls .0m .5m .8m .5m .4m .7m .1mchart total .0m .7m .6m .5m .6m .3m .1m cs gpts .8k .9k .0k cs pts .7m .8m .5m cs fpts .8m .7m .5m cs calls .2m .2m .3m eclipse total .7m .7m .4m cs gpts .9k .8k .3k .0k .4k .9k .1k .2k cs pts .1m .2m .8m .5m .7m .1m .0m .9m cs fpts .2m .4k .0m .8m .2m .4k .2m .2m cs calls .3m .5m .0m .0m .5m .2m .1m .7mfop total .6m .8m .7m .2m .4m .4m .4m .8m cs gpts .8k .6k .5k .0k .7k .8k .6k .2k cs pts .4m .4m .6m .4m .1m .2m .0m .5m cs fpts .2m .0k .0m .6m .2m .3k .0m .6m cs calls .4m .6m .1m .9m .6m .3m .6m .8mluindex total .0m .0m .6m .9m .9m .6m .7m .9m cs gpts .9k .6k .2k .8k .7k .8k .3k .1k cs pts .8m .6m .6m .8m .4m .4m .5m .1m cs fpts .2m .4k .0m .9m .2m .7k .3m .9m cs calls .1m .7m .3m .8m .1m .3m .8m .0mlusearch total .1m .4m .9m .6m .7m .8m .6m .0m cs gpts .4k .9k .1k .1k .3k .1k .3k .4k cs pts .7m .1m .9m .0m .9m .8m .1m .8m cs fpts .6m .3m .1m .4m .1m .4m .0m .0m cs calls .9m .0m .8m .1m .2m .0m .4m .9mpmd total .2m .3m .8m .6m .2m .2m .5m .7m cs gpts .9k .9k .2k .2k .8k .0k .2k cs pts .4m .0m .0m .1m .5m .5m .6m cs fpts .3m .3m .7m .4m .5m .1m .0m cs calls .6m .6m .4m .6m .7m .0m .8mxalan total .3m .9m .2m .2m .7m .6m .3m cs gpts .7k .5k .8k .3k .2k cs pts .2m .7m .8m .3m .9m cs fpts .5m .4m .8m .6m .6m cs calls .5m .2m .1m .0m .8mcheckstyle total .2m .3m .6m .9m .3m cs gpts .3k .1k .3k .7k .0k .8k .4k .3k cs pts .8m .9m .3m .0m .2m .0m .3m .2m cs fpts .9m .3m .3m .2m .8m .3m .2m .7m cs calls .8m .5m .8m .8m .8m .0m .2m .0mjpc total .5m .7m .5m .1m .8m .4m .7m .8m cs gpts .1k .5k .0k .0k .5k .8k .9k cs pts .2m .2m .9m .6m .5m .2m .6m cs fpts .0m .0m .1m .0m .0m .1m .9m cs calls .2m .3m .9m .2m .8m .5m .9mfindbugs total .5m .5m .8m .8m .2m .9m .4m context sensitivity selections to be pre configured .
in this paper however e kobj underperforms z kobj when both are evaluated also in s oot but by using a more precise on thefly exception analysis and turning on the manual heuristicdescribed in section v to allow certain objects to be identi fied per dynamic type and then pre configured to be alwaysanalyzed context insensitively .
as described in section ii c whichever is faster in whichever setting is irrelevant to thiswork c onch can boost their performance regardless as evaluated in section v .
in the absence of this manual heuristic conch is observed to be even substantially more effective in boosting the performance of an object sensitive analysis a since it can help aidentify more context independent objects that would otherwise be analyzed context sensitively by a. in our evaluation turning this manual heuristic on aims tochallenge c onch to demonstrate its performance benefits overa faster baseline by debloating the contexts for the fasterbaseline that has already been debloated manually before .
recently t urner exploits object containment to predict context independent objects.
in contrast c onch is a more principled approach and could find more context independentobjects than t urner .
mahjong mitigates context explosion by merging equivalent heap abstractions at the expense of precision inalias relations.
c onch is orthogonal to m ahjong and may boost its performance by debloating its contexts used.
in context transformations are introduced as an alternative context abstraction to context strings as used in kobj but the practical benefits are shown to be small.
data driven approaches apply machine learning to obtain various heuristics for supporting selectivecontext sensitivity.
s caler trades precision for scalability by selecting a suitable context sensitivity variant for eachmethod so that the amount of points to information is bounded.
elsewhere efforts have been made to improve the precision of object sensitive pointer analysis.
thisthread of research is orthogonal to ours considered here.
finally unlike whole program analyses considered in this paper demand driven pointeranalyses typically only compute the points to in formation for program points that may affect a particular siteof interest for specific clients.
vii.
c onclusion and future work scalability is a major challenge in designing and developing precise object sensitive pointer analysis techniques due to thecombinatorial explosion of contexts in large object orientedprograms.
in this paper we address this challenge by applyingcontext debloating so that we can boost the performance ofall object sensitive pointer analysis algorithms with negligibleloss in precision.
our key insight is to replace a set of twoexisting necessary conditions whose verification is undecid able by a set of three necessary conditions that can be linearlyverifiable in terms of the number of statements in the programfor determining the context dependability of any object.
ourevaluation shows that our new approach c onch can improve significantly the efficiency and scalability of not only kobj but also existing approaches to selective context sensitivity thatcan already accelerate the performance of k obj .
we believe that the performance benefits of context debloating are not just limited to object sensitive pointer analysis asdemonstrated here.
in our future work we plan to explore howto apply context debloating to other flavors of pointer analysissuch as call site sensitive pointer analysis and context transformation based pointer analysis .
in addition wewill also investigate how to apply context debloating to othercontext sensitive program analyses such as taint analysis and data dependence analysis for improving their effi ciency and scalability particularly for large codebases.
viii.
a cknowledgement thanks to all the reviewers for their constructive comments.
this research is supported by an arc grant dp180104069.
89references o. lhot ak and l. hendren scaling java points to analysis using spark in international conference on compiler construction.
berlin heidelberg springer berlin heidelberg pp.
.
k. ali and o. lhot ak application only call graph construction in ecoop object oriented programming.
berlin heidelberg springer berlin heidelberg pp.
.
m. weiser program slicing ieee transactions on software engineering no.
pp.
.
m. sridharan s. j. fink and r. bodik thin slicing in proceedings of the 28th acm sigplan conference on programming language designand implementation.
new y ork ny usa association for computingmachinery pp.
.
y .
li t. tan y .
zhang and j. xue program tailoring slicing by sequential criteria in 30th european conference on object oriented programming.
dagstuhl germany schloss dagstuhl leibniz zentrumfuer informatik pp.
.
m. naik a. aiken and j. whaley effective static race detection for java in proceedings of the 27th acm sigplan conference on programming language design and implementation.
new y ork ny usa association for computing machinery pp.
.
y .
liu and a. milanova static analysis for inference of explicit information flow in proceedings of the 8th acm sigplan sigsoft workshop on program analysis for software tools and engineering ser.
p aste .
new y ork ny usa association for computingmachinery p. .
s. arzt s. rasthofer c. fritz e. bodden a. bartel j. klein y .
le traon d. octeau and p .
mcdaniel flowdroid precise context flow field object sensitive and lifecycle aware taint analysis for androidapps in proceedings of the 35th acm sigplan conference on programming language design and implementation.
new y ork ny usa association for computing machinery p. .
d. he l. li l. wang h. zheng g. li and j. xue understanding and detecting evolution induced compatibility issues in android apps in2018 33rd ieee acm international conference on automated softwareengineering ase .
new y ork ny usa association for computingmachinery pp.
.
d. he h. li l. wang h. meng h. zheng j. liu s. hu l. li and j. xue performance boosting sparsification of the ifds algorithm withapplications to taint analysis in 34th ieee acm international conference on automated software engineering ase .
san diego ca usa ieee pp.
.
y .
smaragdakis m. bravenboer and o. lhot ak pick your contexts well understanding object sensitivity in proceedings of the 38th annual acm sigplan sigact symposium on principles of programminglanguages.
new y ork ny usa association for computing machin ery pp.
.
t. tan y .
li and j. xue efficient and precise points to analysis modeling the heap by merging equivalent automata in proceedings of the 38th acm sigplan conference on programming language designand implementation.
new y ork ny usa association for computingmachinery pp.
.
r. thiessen and o. lhot ak context transformations for pointer analysis in proceedings of the 38th acm sigplan conference on programming language design and implementation.
new y ork ny usa association for computing machinery p. .
m. jeon s. jeong and h. oh precise and scalable points to analysis via data driven context tunneling proceedings of the acm on programming languages vol.
no.
oopsla pp.
.
j. lu and j. xue precision preserving yet fast object sensitive pointer analysis with partial context sensitivity proceedings of the acm on programming languages vol.
no.
oopsla pp.
.
r. v all ee rai p .
co e. gagnon l. hendren p .
lam and v .
sundaresan soot a java bytecode optimization framework in cascon first decade high impact papers.
usa ibm corp. pp.
.
y .
smaragdakis doop framework for java pointer and taint analysis using p taint .
.
available ibm w ala t.j. watson libraries for analysis .
.
available a. milanova a. rountev and b. g. ryder parameterized object sensitivity for points to and side effect analyses for java in proceedings of the acm sigsoft international symposium on software testingand analysis.
new y ork ny usa association for computingmachinery pp.
.
parameterized object sensitivity for points to analysis for java acm transactions on software engineering and methodology vol.
no.
pp.
.
s. jeong m. jeon s. cha and h. oh data driven context sensitivity for points to analysis proceedings of the acm on programming languages vol.
no.
oopsla p. .
y .
li t. tan a. m ller and y .
smaragdakis precision guided context sensitivity for pointer analysis proceedings of the acm on programming languages vol.
no.
oopsla pp.
.
b. hassanshahi r. k. ramesh p .
krishnan b. scholz and y .
lu an efficient tunable selective points to analysis for large codebases inproceedings of the 6th acm sigplan international workshop on stateof the art in program analysis.
new y ork ny usa association forcomputing machinery p. .
y .
smaragdakis g. kastrinis and g. balatsouras introspective analysis context sensitivity across the board in proceedings of the 35th acm sigplan conference on programming language design andimplementation.
new y ork ny usa association for computingmachinery pp.
.
j. lu d. he and j. xue eagle cfl reachability based precisionpreserving acceleration of object sensitive pointer analysis with partialcontext sensitivity acm transactions on software engineering and methodology .
d. he j. lu y .
gao and j. xue accelerating object sensitive pointer analysis by exploiting object containment and reachability in 35th european conference on object oriented programming ecoop ser.
leibniz international proceedings in informatics lipics vol.
.dagstuhl germany schloss dagstuhl leibniz zentrum f ur informatik pp.
.
t. reps undecidability of context sensitive data dependence analysis acm transactions on programming languages and systems vol.
no.
pp.
.
t. reps s. horwitz and m. sagiv precise interprocedural dataflow analysis via graph reachability in proceedings of the 22nd acm sigplan sigact symposium on principles of programming lan guages ser.
popl .
new y ork ny usa association for computing machinery p. .
l. o. andersen program analysis and specialization for the c programming language ph.d. dissertation university of cophenhagen .
t. tan y .
li and j. xue making k object sensitive pointer analysis more precise with still k limiting in international static analysis symposium.
berlin heidelberg springer berlin heidelberg pp.
.
t. reps program analysis via graph reachability information and software technology vol.
no.
pp.
.
y .
smaragdakis and g. balatsouras pointer analysis f ound.
trends program.
lang.
vol.
no.
p. .
m. i. gordon d. kim j. h. perkins l. gilham n. nguyen and m. c. rinard information flow analysis of android applications indroidsafe in ndss vol.
.
the internet society p. .
m. bravenboer and y .
smaragdakis exception analysis and pointsto analysis better together in proceedings of the 18th international symposium on software testing and analysis.
new y ork ny usa association for computing machinery p. .
e. bodden a. sewe j. sinschek h. oueslati and m. mezini taming reflection aiding static analysis in the presence of reflection and customclass loaders in proceedings of the 33rd international conference on software engineering.
honolulu hi usa ieee pp.
.
m. bravenboer and y .
smaragdakis strictly declarative specification of sophisticated points to analyses in proceedings of the 24th acm sigplan conference on object oriented programming systems languagesand applications.
new y ork ny usa association for computingmachinery pp.
.
s. m. blackburn r. garner c. hoffmann a. m. khang k. s. mckinley r. bentzur a. diwan d. feinberg d. frampton s. z. guyer m. hirzel a. hosking m. jump h. lee j. e. b. moss a. phansalkar d. stefanovi c t. v andrunen d. von dincklage and b. wiedermann the dacapo benchmarks java benchmarking development and anal ysis in proceedings of the 21st annual acm sigplan conference on object oriented programming systems languages and applications.new y ork ny usa association for computing machinery pp.
.
y .
li t. tan a. m ller and y .
smaragdakis a principled approach to selective context sensitivity for pointer analysis acm transactions on programming languages and systems vol.
no.
toplas pp.
.
m. jeon m. lee and h. oh learning graph based heuristics for pointer analysis without handcrafting application specific features proceedings of the acm on programming languages vol.
no.
oopsla pp.
.
y .
li t. tan a. m ller and y .
smaragdakis scalability first pointer analysis with self tuning context sensitivity in proceedings of the 26th acm joint meeting on european software engineering conferenceand symposium on the f oundations of software engineering .n e w y ork ny usa association for computing machinery pp.
.
a. milanova light context sensitive points to analysis for java in proceedings of the 7th acm sigplan sigsoft workshop on programanalysis for software tools and engineering.
new y ork ny usa association for computing machinery p. .
g. kastrinis and y .
smaragdakis hybrid context sensitivity for pointsto analysis in proceedings of the 34th acm sigplan conference on programming language design and implementation.
new y ork ny usa association for computing machinery p. .
j. whaley and m. s. lam cloning based context sensitive pointer alias analysis using binary decision diagrams in proceedings of the acm sigplan conference on programming language design andimplementation.
new y ork ny usa association for computingmachinery pp.
.
l. li c. cifuentes and n. keynes boosting the performance of flowsensitive points to analysis using value flow in proceedings of the 19th acm sigsoft symposium and the 13th european conference onf oundations of software engineering.
new y ork ny usa associationfor computing machinery pp.
.
m. sridharan d. gopan l. shan and r. bod k demand driven pointsto analysis for java in proceedings of the 20th annual acm sigplanconference on object oriented programming systems languages andapplications.
new y ork ny usa association for computingmachinery p. .
m. sridharan and r. bod k refinement based context sensitive pointsto analysis for java in proceedings of the 27th acm sigplan conference on programming language design and implementation.new y ork ny usa association for computing machinery p. .
d. y an g. xu and a. rountev demand driven context sensitive alias analysis for java in proceedings of the international symposium on software testing and analysis.
new y ork ny usa associationfor computing machinery pp.
.
l. shang x. xie and j. xue on demand dynamic summary based points to analysis in proceedings of the tenth international symposium on code generation and optimization.
new y ork ny usa association for computing machinery pp.
.
y .
sui and j. xue on demand strong update analysis via valueflow refinement in proceedings of the 24th acm sigsoft international symposium on foundations of software engineering.n e wy ork ny usa association for computing machinery pp.
.
j. sp ath l. nguyen quang do k. ali and e. bodden boomerang demand driven flow and context sensitive pointer analysis for java in30th european conference on object oriented programming.
dagstuhl germany schloss dagstuhl leibniz zentrum fuer informatik pp.
.
m. sharir and a. pnueli two approaches to interprocedural data flow analysis.
new y ork university.
courant institute of mathematicalsciences .
q. zhang and z. su context sensitive data dependence analysis via linear conjunctive language reachability in proceedings of the 44th acm sigplan symposium on principles of programming languages.new y ork ny usa association for computing machinery pp.
.