graphfuzz library api fuzzing with lifetime aware dataflow graphs harrison green hgarrereyn forallsecure.com forallsecure u.s.a.thanassis avgerinos thanassis forallsecure.com forallsecure u.s.a. abstract we present the design and implementation of graphfuzz a new structure coverage and object lifetime aware fuzzer capable of automatically testing low level library apis.
unlike other fuzzers graphfuzzmodelssequencesofexecutedfunctionsasadataflow graph thusenablingittoperform graph basedmutations bothat thedataand at the execution trace level.
graphfuzz comes with an automated specification generator to minimize the developer integration effort.
weusegraphfuzztoanalyzeskia therigorouslytestedgoogle chrome graphics library and benchmark graphfuzz generated fuzzingharnessesagainsthand optimized painstakinglywritten libfuzzerharnesses.wefindthatgraphfuzzgeneratestestcases that achieve 3x more code coverage on average with minimal development effort and also uncovered previous unknown defects intheprocess.wedemonstrategraphfuzz sapplicabilityonlowlevelapisbyanalyzingfouradditionalopen sourcelibrariesand findingdozensofpreviouslyunknowndefects.allsecurityrelevant findings have already been reported and fixed by the developers.
last we open source graphfuzz under a permissive license and provide code to reproduce all results in this paper.
acm reference format harrison green and thanassis avgerinos.
.
graphfuzz library api fuzzing with lifetime aware dataflow graphs.
in 44th international conferenceonsoftwareengineering icse may21 pittsburgh pa usa.
acm newyork ny usa 12pages.
introduction fuzzinghasbecomethede factostandardforidentifyingnewsecurityvulnerabilitiesandensuringsoftwarereliability.fromcommon opensourcelibrariestobrowsercomponenttesting andfrom safetycriticalsystemstoautomotiveandaerospacestandards the entire industry is adopting fuzzing and finding thousands of critical issues before they occur in production.
the constantly increasing need for better automated testing has led to the development of a taxonomy of fuzzer types.
coverageguided grey box fuzzers such as libfuzzer have gained significantadoptionandvisibilitywithin theindustry.thesefuzzers permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
feedback information from the target edge coverage valuecoverage orsimilar toguidetestcaseselectionandmutation.
coverage guided fuzzing is an optimization problem the goal is to discoveracorpusoftestcasesthatmaximizescoverageforatarget.
intuitively maximizing coverage leads to edge cases erroneous behavior and or security vulnerabilities.
at the same time the art of model based or structure aware fuzzingisgrowingrapidlyasitofferstwosignificantbenefits.first it enables fuzzing targets which expect complex structured inputs.
at the simplest level a model based fuzzer may simply unpack or post process the input byte string.
for example the llvm project provides fuzzeddataprovider.h fdp autilityheaderfilethat splits a single fuzzer input into multiple smaller inputs.
more complexmodel basedfuzzers suchaslibprotobuf mutator lpm use custom generators and mutators to fuzz structured objects like protocol buffers.
second model based fuzzers realize efficiency improvements overanalogousunstructuredfuzzersbyavoidingbadinputs.targetsthatvalidatetheirinputbeforeproceeding i.e.throughtheuse of checksums are effectively un fuzzable without manual countermeasuressuchasdisablingvalidationatfuzz time.unstructured fuzzers simply get stuck trying to brute force input after input.
model based fuzzers bypass this problem entirely by programmatically synthesizing valid test cases.
for example a checksum aware fuzzer needs only to computeandsetthe correct checksum for a given input.
despitetherecentsurgeinfuzzingresearch thereisanoticeable lack of systems capable of fuzz testing c c libraries.
existing grey boxfuzzerssuchaslibfuzzer areparticularlywellsuited forfuzzingoneortwoendpointsatatimebutrequiremanualeffort using fdp for example to scale to multiple endpoints at once.
csmith can synthesize realistic c code but recompiling at each iteration is expensive when the target is a c libraryand not the c compiler.
fudge is a promising meta fuzzing technique that automatically generates harnesses by analyzingand slicinga seed corpusofclient sidecode however itreliesongoogle sinternal infrastructure and is not open source.
toaddressthisgap weintroducetheconceptofdataflowgraphbased fuzzing in which a library api interaction is represented as a dataflow graph.
we describe algorithms for dataflow graph mutation generationandexecutioninthecontextofc c libraries.we open source our implementation of dataflow graph based fuzzing calledgraphfuzzunderapermissivelicenseandwedemonstrate its effectiveness by finding bugs in real world targets and quan titatively benchmarking its performance against state of the art ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa harrison green and thanassis avgerinos harnessesintheskiagraphicslibrary.additionally webrieflysurvey the field of model based api fuzzersto compare recent works and understand the benefits and drawbacks of various systems.
overall graphfuzz makes the following contributions model based api fuzzer survey.
we present a taxonomy for model based fuzzers developed until today and show where graphfuzz fits within the design space.
dataflowgraph basedfuzzing.
weformallydefinedataflow graph basedfuzzingandintroducealgorithmsforperforminggraph mutation and generation in the context of coverage aware fuzzing.
graphfuzz for c c .
we introduce our open source implementation of dataflow graph based fuzzing called graphfuzzthat is capable of semi automatically fuzz testing c and c libraries.
we validate this technique by finding real world bugs and quantitatively benchmarking its performance against current stateof the art harnesses.
section provides a taxonomy for model based api fuzzers and describeshowgraphfuzzfitsintothedesignspace.weformally definetheconceptofdataflowgraph basedfuzzinginsection3and insection4 wedescribeouropen sourceimplementationcalled graphfuzz.
section 5evaluates graphfuzzon real world targets.
we discuss limitations in section and the paper concludes in section .
model based fuzzing model basedfuzzers sometimescalledstructure awareorgrammarbased use a modelto inform test case generation and mutation.
the model constrains generated test cases and the search space of the fuzzer.
when used correctly models enable fuzzers to generate interesting inputs more efficiently than an unstructured fuzzer.
.
model domain model based fuzzers specify often implicitly a model domain d thatdescribesthespaceofpossiblefuzzertestcases.thisdomain describestheinternal structure ofeachtestcaseandthereforerestricts the typesof mutations possible and theways in which test cases can be invoked in a target.
as a baseline example unstructured fuzzers use a bytesdomain i.e.
each test case is a byte sequence and fuzzers can apply bytelevelmutations such as swapping bytes inserting substrings or mutating bytes.
libprotobuf mutator lpm an example of a differentmodel basedfuzzer representstestcasesinternallyasa tree a protocol buffer object and therefore uses a treedomain.
using custom mutators lpm performs tree level mutations such as adding or removing leaves and rearranging subtrees.
we identify four broad classes of model domains as follows bytes domainsthatconsistofrawbytesequences.
i.e.all unstructured fuzzers use this domain tree domains that are tree like.
these inputs typically representanabstractsyntaxtreeandaregeneratedwithagrammar such as a context free grammar.
sequence domainsthatconsistofalistofitems.eachitem in the list can contain additional metadata.
graph domainsthatconsistofverticesandedges.wedescribethefirstimplementationofgraph baseddomainsin this work.
.
anatomy of a model based fuzzer model based fuzzers consist of the following four functions which operate on their respective model domains generation seed d mutation d seed d crossover d d seed d invocation d feedback theseedenablespseudo random yetdeterministicbehavior.the feedbackmetric always consists of at least a binary bugsignal did the target crash or not?
and typically contains more fine grained data such as specific addresssanitizer issues or code coverage.
generation based fuzzers use only the generation function to synthesize new test cases.
these fuzzers are most applicable in black boxenvironmentswherenocoverageinformationisavailable orwhenitistoocomplicatedtodefinea mutation operation.for example jsfunfuzz and csmith use hand crafted rules to generate realistic javascript and c code respectively.
in grey box environments mutation is necessary to reap the benefits of coverage feedback.
mutation based fuzzers define the mutation and orcrossover operatorstosynthesizenewtestcases by mutating and mixing existing cases from a corpus.
mutationbasedfuzzerssuchaslibfuzzer havedemonstratedsubstantial efficiencyimprovementsoverpurelygeneration basedfuzzers.cov eragefeedbackhasalsobeenemployedwithsuccessinmodel based fuzzers such as nautilus a script language fuzzer and pythia a rest api fuzzer.
.
api fuzzing methods most real world targets contain more than one endpoint a web application provides http endpoints a kernel provides system calls a c library provides public functions fuzzingindividual endpointsatatimeisnotsufficienttodiscover every bug in a target.
some erroneous behavior only arises from the interaction of multipleendpoints.
api fuzzers attempt to solve this problem of fuzzing many endpoints at once.
while modern techniques are varied we identify four broad methodsofapifuzzingandusethemtocategorize apifuzzersat a high level method harness.
a standard grey box harness can be configured toactasanapifuzzerthroughmanualeffort.forexample adevel opercanfuzz testac librarybyprocedurallyinvokingfunctions inside a for loop and or switch statement.
typically a raw bytesequence from an unstructured fuzzer is used to initialize thesepseudo random values.
for example in the fuzzeddataprovider fdp approach thefuzzerbytesequenceisinterpretedasa byte streamand values are pulled from this stream to initialize variables insidetheharness.similarly onecanuse libprotobuf mutator lpm in conjunction with a coverage guided fuzzer such as libfuzzer tobuildatree basedapifuzzer.forexample inchromium s appcache fuzzer the protocol buffer instance represents a sequence of ipc calls.
method code gen. some api fuzzers synthesize and execute programsourcecode.thisapproachismostfeasibleforscript based authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
graphfuzz library api fuzzing with lifetime aware dataflow graphs icse may pittsburgh pa usa languages such as javascript and ruby which do not require an expensive compilation step before execution however this approach has also been used to fuzz test c compilers .
whilethesefuzzerscangeneraterealisticsyntaxpatternsthrough the use of context free grammars or similar models they often fail to produce high level semantically meaningful code.
for example hanet.al notedthat99 ofthetestcasesfromjsfunfuzz apopularjavascriptfuzzer raisearuntimeerrorafteronly3 statements.
method harness gen. rather than building harnesses by hand it isalso possibleto createsystems thatgenerate harnessesautomatically or with little manual effort.
for example imf traces syscalllogstoidentifydependenciesandsynthesizescharnesses thatcanfuzz testthesesyscalls.similarly fudge andfuzzgen analyzealargecode baseofclient sidec c codeandextract slicesofcodetocreatefuzzerharnesses.whilethesesystemscan generatevariedharnesses theapiinvocationstructurewithina single harness is staticat fuzz time and only the values change.
method dynamic.
in thedynamicapproach to api fuzzing each test case represents a full api interaction sequence.
the fuzzer enginedynamicallyprocesseseachtestcase invokingendpoints one by one.forexample inrestlerandpythia eachtestcaseis essentially a listof http requests.
the key distinction between dynamic andharness gen approaches is that in a dynamic fuzzer thestructureofapiinteractionsisspecifiedatfuzz time aspart of the test case which allows the fuzzer to control both the values andstructure ofapicalls.while code genfuzzerscanalsochange the structure of api calls at fuzz time through recompilation e.g.
csmith dynamicfuzzerssuchassyzkaller andgraphfuzz this work bypass this expensive recompilation step.
.
recent model based api fuzzers manes et al have extensively surveyed the current field of fuzzing.
in this work we focus specifically on model based api fuzzersandnarrowdownourcriteriaandcategorizationtoprovide a detailed comparison.
in table we survey a collection of recent model based api fuzzers and compare various features explained below .
the table is primarily organized by the methodof api fuzzing as described in section .
.
.
.
fuzzer features.
foreachfuzzerwelisttheprimarytarget type themodeldomain d asdescribedinsection2.
andthetype of model used to generate and mutate inputs.
.
.
mutation engine.
in the first column group we compare the method of generating and exploring inputs.
for each fuzzer we list whether it supports generation mutation crossover and collecting coverage information.
generation based fuzzers such as jsfunfuzz andcsmith implementonlythe generation function while mutation basedfuzzers alsoimplement the mutation and or crossover functions.
in addition some fuzzers such as nautilus andgraphfuzz thiswork supportgrey box coverage guided fuzzing using feedback from the target program to guide test case selection and mutation.
.
.
api conformity.
for the purposes of api fuzzing it is useful tocomparesyntacticandsemanticfeaturestounderstandhowwellthe fuzzer conforms to a target api specification.
in the second column group we compare the fuzzers based on three constraint attributes syntax the fuzzer produces inputs that conform to language syntax rules.
endpoint dependencies the fuzzer produces inputs that ensure endpoints with dependencies are invoked after their dependents.
object lifetimes the fuzzer manages object lifetimes and invokes explicit constructors and destructors.
fuzzers that conform to syntax rules alone will primarily target theparsingorcompilationstageofthetarget.thesefuzzersmay becapableofgeneratingsemanticallymeaningfulinputsbutitis notguaranteed andalargepercentageoffuzz timewillbespent on inputs that are rejected.
this level of fuzzing is most applicable forscript basedlanguagesthattargetinterpreterssuchasjsfunfuzz langfuzz ifuzzer and nautilus .
fuzzersthatunderstandendpointdependencyrequirementscan synthesizeinputswhereallendpointargumentsaresatisfied.for example codealchemist maintains a set of javascript code brickswith explicit inputs and outputs and stitches together inputs that obey dependency rules.
similarly restler understands restapidependenciesandinvokesendpointsthat consumespecificparametersonly afterarequesthas beenmadethat generates that parameter for example a post foo before aget foo .
fuzzers that are lifetime aware explicitly manage the lifetime of objects.
this ability enables fuzzers to operate in environments without automatic memory management and enforce semantic lifetime constrains such as the use of managed pointers.
additionally these fuzzers can identify issues such as memory leaks and use after free bugs without false positives.
.
.
applicability.
inthethirdcolumngroup weidentifywhether each fuzzer requires an input corpus of seed data i.e.
language grammarexamples client sidecode apitraces etc andwhether each fuzzer is open source.
dataflow graph based fuzzing we propose a new technique of dataflow graph based fuzzing in which alibrary api interaction is represented as a dataflow graph.
we develop algorithms to generate and mutate dataflow graphs according to a schemaand describe how to execute such graphs in thecontextofc c libraries.theconceptofdataflowgraph basedfuzzingisnotrestrictedtoc c andwebelievethatfutureworks will apply this technique to new environments.
tointroducetheconceptofadataflowgraph wefirstprovide an example of a bug found by graphfuzz in the skia graphics library.figure1containsasnippetofc codethattriggersaheapuse after free in skia.
in this example the shrinktofit method frees memory that is being used by the skcontourmeasureiter object.infigure2weshowthe samebug representedasadataflow graph in short functions are vertices and objects are edges.
thekey concept in graphfuzz is that these two representations areequivalent.
we can invoke this test case by either compiling and running the c code in figure orby dynamically executing the dataflow graph in figure .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa harrison green and thanassis avgerinos method fuzzer target domain model generationmutationcrossovercoveragesyntaxendpoint depsobject lifetimesworks w o seedsopen source harness libfuzzer fdp library api bytes procedural harness libfuzzer lpm library api tree protobuf code gen jsfunfuzz javascript bytes procedural code gen csmith c compilers bytes cfg code gen langfuzz script languages tree cfg code gen dharma data tree cfg code gen ifuzzer script languages tree cfg code gen nautilus script languages tree cfg code gen codealchemist javascript sequence api spec harness gen imf kernels harness gen fudge library api harness gen fuzzgen libary api harness gen rulf rust api dynamic syzkaller syscalls sequence api spec dynamic restler rest api sequence api spec dynamic pythia rest api sequence rg dynamic graphfuzz library api graph api spec table a survey of recent model based api fuzzers organized by method.1requires manual implementation 1skpath path newskpath 2path moveto 3skcontourmeasureiter iter new skcontourmeasureiter 4iter reset path false 5path shrinktofit 6delete path 7iter next 8delete iter figure the textual representation of crbug.com aheap use after freeintheskiagraphicslibraryfoundbygraphfuzz.
figure the dataflow graph representation of cr bug.com figure .in this section we formally define the concept and terminology of a dataflow graph and we introduce our graph mutation and completion algorithms.
in the following section we introduce graphfuzz an open source framework for fuzzing c c libraries with dataflow graphs.
.
library api specification library apis provide two specifications for developers object declarations and endpoint specifications that consume and produce the declared objects.
definition .
object .an object is the abstract specification of adatatype.weuse oxtodenoteanobjectdomainand otosignify the domain of all valid objects.definition .
endpoint .an endpoint takes in a list of input objectsandreturnsalistofoutputobjects.forexample anendpoint ewith x inputs and y outputs has a type signature of e o1 o2 o x o prime o prime o prime y we use the notation e i to refer to the i th input object and e i prime to refer to the i th output object.
definition .
endpoint driver .each endpoint is associated withanendpointdriverthatspecifiesexactlyhowtoconvertobject inputsintoobjectoutputs.forc c targets theendpointdriver is a small function that is compiled into the harness.definition .
library api .a library api defines a list of x objectsand yendpoints api o1 o2 o x e1 e2 e y forac c api objectsconsistofstructs classes enumsand primitivetypeswhileendpointsar egenerallymethods.
however endpoints can be arbitrarily complex snippets of c c code as described in section .
.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
graphfuzz library api fuzzing with lifetime aware dataflow graphs icse may pittsburgh pa usa .
dataflow graph definition3.
dataflowgraph .thedataflowgraphisastronglytypeddirectedacyclicgraph dag thatrepresentsaspecific deterministic interaction pattern between endpoints.
g v e from a fuzzing perspective each dataflow graph is equivalent to a traditionalfuzzertestcase.verticesinthegraphrepresent instances of endpoints and edges represent object dependencies objects that areproducedbyoneendpointandconsumedbyanother.forexample theedge ei va vb j k indicatesthatoutput jofvabecomes inputkofvb.
dataflow graphs are strongly typed so this edge is only valid if the object type is consistent i.e.
e j prime a e k b. a dataflow graph is validif and only if every vertex has a single incoming edge for each object input and a single outbound edge foreachobjectoutput.additionally therecanbenodirectedcycles in the graph.
.
invoking a dataflow graph each dataflow graph represents a deterministic fully formed interactionbetweenendpoints.toinvokeadataflowgraph wegenerate an ordering of the vertices such that endpoints with object dependencies are invoked afterthe endpoints that produce those objects.
then we iterate and invoke each endpoint driver in order passing objects from one endpoint to the next as necessary.
for example to execute the dataflow graph in figure we first invoke the constructor skpath producing a new skpathobject.
thisobjectispassedtothenextendpoint skpath moveto which performsamethodcallontheobject.wecan tyetinvoke skcontourmeasure reset becausewearemissingadependency sowe first invoke skcontourmeasureiter to produce a new skcontourmeasureiter object.onlythencanweinvoke skcontourmeasure reset passingboththenewlycreated skcontourmeasureiterobjectandthe skpathobject.executioncontinuesinthismanner until every vertex has been visited.
each vertex in the graph maintains a fuzzable indexattribute to break ties in cases where the ordering is ambiguous.
.
endpoint context forsometargets itisunwieldytotrackalloftheprimitivevaluesasdiscretenodesinthegraph.anendpointthatconsumesanarrayofintegersofsize100wouldnaivelyrequire100inboundconnections bloating the dataflow graph.
we simplify dataflow graphs by embedding certain objects directlyintothegraphvertexmetadata.forc c targets weconsider primitive types such as integers floats and enums to be shortlived.theseobjectsarenottrackedasedgesinthegraphbutrather their values are embedded directly into a graph vertex.
specifically wecoalesceallfixed size short livedobjectsfora given endpoint into a single context byte string that is stored as metadatainsideagraphvertex.atfuzz time theseprimitiveobjectsareinitializedbydeserializingthecontextbytestringandprovided to the corresponding endpoint driver.definition .
contextbytestring .acontextbytestringconsists of the concatenation of zfixed size short lived types c o bardblo bardbl... bardblo z where bardbldenotesconcatenationoftherawbyterepresentationsof an object s value.
thecontext size is the number of bytes required to store all objects which is simply the sum of each object s size c z summationdisplay.
k o k for example o k is implemented as the sizeofoperator for c c targets.
definition3.
optimizedendpoint .anoptimizedendpointconsists ofxlong lived inputs youtputs and zshort lived inputs and has the following type signature e o1 o2 o x c o prime o prime o prime y eachvertexinthedataflowgraphmaintainsaninstanceofan endpoint scontextbytestringinadditiontotheendpointreference v e b c b ... for example in figure the short lived types indicated in blue two float inputs and one bool input are initialized from a context stringratherthanaseparateendpoint.theendpoint skpath moveto float float has an byte context string which is deserialized into two byte floats.
the endpoint skcontourmeasureiter reset skpath bool has a byte context string which is deserialized to initialize the boolvalue in this case only the leastsignificant bit of this string is used .
.
fuzzing dataflow graphs the fuzzing process requires the ability to generateandmutate dataflow graphs.
at the surface level changing the structure of a dataflow graph i.e.
the vertices and edges is straightforward.
however ensuringthateachgraphasawholeisstill validrequires meeting specific constraints.
if a generated graph is invalid missing edges or mismatched edgetypes graphexecutionwillproducefalsepositiveerrorssuch as null pointer dereferences or memory leaks.
for simplicity we split the graph fuzzing problem into two parts graph mutation and graph completion mutation section3.
generateormutateadataflowgraph to form an incomplete graph g primewith potential missing edges.
completion section .
add vertices and edges as necessary to form a complete valid graph g. .
graph mutations in this section we list the graph mutations used by graphfuzz.
thesespecificmutationsarenotrequiredfordataflowgraph based fuzzing howeverinpractice wefindthemeffectiveforthetypes of schemas used in c c libraries.
each mutation acts on a graph gto produce an intermediate potentially incomplete graph g prime.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa harrison green and thanassis avgerinos figure graphfuzz mutations following every mutation the graph completion algorithm section .
acts on g primeto produce a valid fully formed graph g .a graphical representation of these mutations is shown in figure .
.
.
graph mutations.
splicein spliceanewendpointbetweentwoexistingendpoints.givenanexistingedge va vb i j addanewvertex vkandreplacetheoldedgewithtwonewedges va vk i and vk vb j .
spliceout the opposite of the splicein mutation.
given a pair of edges va vk i and vk vb j wheree i prime e j remove the pair of edges and vkand add a direct edge fromvatovb va vb i j .
crosslink sampletwovertices vaandvbatrandomsuch thate j prime e k forsome j k.removetheexistingedges va j and vb k andaddanewinternaledgebetweenvaandvb va vb j k .
if this mutation splits the graphintomultipledisconnectedparts keeponlythesubgraph containing vaandvb.
context sample a vertex vkwith a non zero sized context byte string ck and invoke libfuzzer s builtin mutator llvmfuzzermutate o n ck.
priority sample two vertices vaandvbat the same layer and swap their vertex indexes reversing vertex priority during graph execution.
swap sample a random vertex vaand replace it with adifferentendpointofthesamesignature.bydefinition thetwo endpoints are compatiblewith the existing graph structure so no further structural modification needs to be done.
truncatedestructor sample a vertex vksuch that ek o prime j ... .
remove the edge vk j and ifthis splits the graph into two disconnected parts keep only the subgraph with vk.
extenddestructor sample a vertex vksuch that ek o .replacethisvertexwithanewvertex v prime ksuchthat ek o j ... andreplacetheedge vk with a new edge v prime k j .
truncateconstructor sample a vertex vksuch that ek o j ... .
remove the edge vk j and if this splits the graph into two disconnected parts keep only the subgraph with vk.
extendconstructor sample a vertex vksuch that ek o prime .
replace this vertex with a new vertex v prime ksuch thatek o prime j ... and replace the edge vk with a new edge v prime k j .
.
.
graph crossover.
giventwographs gaandgb invokethe crosslink mutation on two vertices va g aandvb g b. .
.
graph generation.
initialize a new graph gwith a single random endpoint eand invoke the graph completion algorithm.
.
graph completion wenowintroducethe graphcompletion algorithmthatisusedin graph generation and mutation to complete a partial graph g prime.w e reducethegraphcompletionproblemintoseveralsmallerproblems of satisfying missing edges in a graph.
to this end we propose the sub problem of edge completion definition3.
edgecompletion .givenanobjectoutputoftype o the goal is to generate a subgraph g that is valid except for a single missing input edge of type o .
note that the problem is symmetricaltothecasewheregivenanobject inputoftypeo we want to generate a subgraph missing the corresponding output.
an incomplete graph g primecan be completed by invoking the edge completion algorithmforeverymissinginputandoutputandlinking the generated subgraphs.
a naive probabilistic approach to edge completion such as randomlysamplingviableendpointstendstogenerateextremelylarge graphsorfailstoreturnasolutionatall insteadthegraphgrows endlessly .itispossibletoenforcecertain cutoffrules suchassamplingendpointswithfewerconnectionswithahigherprobability but such heuristics are graph schema dependent and we empiricallyfound thattheydo notalwayswork.additionally theedge completion algorithm runs several times per mutation which may itself run or times per fuzzer iteration a fast implementation is critical for fuzzer performance.
ourgraphfuzzimplementationofedgecompletionpre computes everypossiblesubgraphforagiventargetobject o byperforming abreadth firstsearchofdepth koverthegraphschema.thesubgraphsarestoredinanprobability encodedtreestructure referred to as atypetree .
at fuzz time the edge completion algorithm can sample subgraphsfor any object type inconstant time.
these pre computed trees are cached o n disk which speeds u p parallel fuzzing.forexample inlibfuzzer forkmode anewlyspawned thread can instantly retrieve the subgraph solutions.
in graphfuzz this pre computation step also performs schema validation.warningsaredisplayedifthereareanyendpointsinthe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
graphfuzz library api fuzzing with lifetime aware dataflow graphs icse may pittsburgh pa usa schema which are unreachable orunsatisfiable i.e.
cannot exist in a valid graph .
.
graph minimization crashing test cases often contain unnecessary cruft that can be removedtoobtainaminimalreproducer.althoughsimplistic we findthatbyrandomlyinvokingmutationsandretainingonlythose graphs which exhibit the same crash and are smaller we obtain dataflow graphs close to the size of hand minimized examples.
graphfuzz for c c in this section we describe graphfuzz an implementation of dataflow graph based fuzzing designed to fuzz test c and c libraries.
wehavereleasedthisframeworkalongwithdocumentationand example code under .
overview graphfuzz consists of two parts libgraphfuzz acoreframeworkwritteninc whichperforms dataflow graph mutations andis linked into the fuzz harness.
gfuzz a python command line tool used to generate harnessesfilesandperformmiscellaneoustaskssuchasgraph minimization and automatic schema extraction.
.
graphfuzz schema the core of a graphfuzz harness is the schema.
a schema is defined in a human readable yaml file and contains a list of the api endpoints and object types available in a library api.
using the schema graphfuzz automatically generates the execandwrite fuzzer harnesses.
an example partial schema for the skia skpath api is shown in figure .
this harness found a uaf in skcontourmeasureiter graphfuzz understands c and c function signatures and often times this is the only information needed to define an endpoint.
.
harnessing harnessing a target with graphfuzz requires the following steps visualized in figure instrumentation compile the target library with fuzzer coverage.
with clangfor example this just requires adding the fsanitize fuzzer flag.
schemainference optional using gfuzz runtheschema extractor tooltoautomaticallyextractclasses structs enums typedefsandmethodsfromlibrarysourcecodeintoaschema.
the generated schema is a starting point for further modification.
manual revision applying an understanding of the library api requirements manually fix up the schema by adding removing classes adding functions or redefining the input and output types of a function.
harness generation rungfuzzon the schema to automatically generate two versions of the harness fuzzexec executesthedataflowgraphswhile fuzzwrite convertsthe1typedef skscalar 2type typedef 3name skscalar 4value float 6struct skpath ... 8methods skpath voidmoveto skscalar x skscalar y ... voidshrinktofit voidclose 15struct skcontourmeasureiter ... 17methods skcontourmeasureiter skcontourmeasureiter constskpath path boolforceclosed skscalar resscale sk sp skcontourmeasure next ... figure a partial graphfuzz harness for the skia skpath api.thisharnessincludesfunctionsignaturesformethods onthe skpathand skcontourmeasureiter structsinaddition toskvector skpointand skcontourmeasure not shown .
figure5 anoverviewofthegraphfuzzharnessingprocess.
dataflow graphs to plain c c source code which can be recompiled externally.
compilation linking link both harness variants to the target library to produce native libfuzzer executables.
.
endpoint driver specification in graphfuzz an endpoint specification is represented with the following four components inputs a list of endpoint input types outputs a list of endpoint output types args a list of context based endpoint input types exec an endpoint driver template c c code theseattributescaneitherbedefinedmanuallyoradeveloper cansimplyprovideac c functionsignatureandgraphfuzzwill attempttogeneratetheendpointspecificationautomatically.inreal worldtargets weobservethatfull manualendpointdefinitionsare authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa harrison green and thanassis avgerinos 1inputs 2outputs 3args 4exec i0 moveto a0 a1 o0 i0 figure a full endpoint driver specification for skpath moveto skscalar skscalar .
1struct skpath ... intgetpoints skpoint points intmax inputs outputs args exec skpoint points unsigned int max a0 i0 getpoints points max o0 i0 figure a custom endpoint definition for skpath getpoints skpoint int .
onlyrequiredroughly10 ofthetime.fortheremainingcases the function signature itself is sufficient.
theendpointdrivertemplate exec isasnippetofc c code that is exposed to several additional graphfuzz specific macros.
inside the endpoint driver template in on and anrefer to the n th input output and argument respectively.
inputs and outputs havepointertypeswhileargumentscan bereferenceddirectlyas raw types.
for example the void moveto skscalar skscalar signature defined on the skpathstruct in figure is converted into thefullendpointspecificationinfigure6.graphfuzzrecognizes thatthisisamethodcallandautomaticallygeneratesthecorrect input output dependencies and execution driver template.
.
custom endpoint drivers certain endpoints have implicit requirements about usage that are notinferablefromthefunctionsignaturealone.inthesecases adevelopercanextendthe exectemplatetocustomizethespecification of an endpoint.
forexample themethod skpath getpoints skpoint points int max is used to retrieve points from the underlying path object.
the pointsarray must have space for maxentries and will be filled in during execution.
while graphfuzz cannot infer theseconstraintsfromthefunctionsignature theycanbemanually defined in the graphfuzz schema.
we incorporate this semantic knowledge into the schema by defining a custom endpoint as in figure .
in this endpoint we manuallyallocatea skpatharrayonthestackwithsize1024.then weinvoke skpath getpoints withthisarrayanda maxparameter which is bounded to the range .
.
fuzzing process graphfuzz is implemented as a custom mutation engine on top oflibfuzzer .hence theresultingbinariesarenativelibfuzzer executablesandarecompatiblewithexistingfuzzinginfrastructure such as oss fuzz.
the fuzzing process figure consists of the following steps selection libfuzzer selects inputs to mutate.
mutation graphfuzzinterpretseachcorpusinputasaserialized dataflow graph section .
and applies graph level mutations section .
.
execution graphfuzzexecutesthedataflowgraph section .
by performing a dynamic traversal of the vertices ex ecuting corresponding endpoint drivers as necessary.
the fuzzexec harness executes actual target code while the fuzzwriteharnessconvertsnodestocorrespondingsourcecode output.
coveragefeedback feedbackfromthetarget intheform of edge coverage value coverage etc.
is collected by libfuzzer and used to guide corpus growth and selection.
evaluation weusedgraphfuzztofuzz test5real worldcandc libraries.
in this section we discuss challenges and results from our fuzzing campaigns.
we also include severalexamples of the types ofbugs found with graphfuzz.
duringourresearch wesoughttoestablishaquantitative headto head benchmark.
this endeavor proved difficult simply because there are not many existing harnesses that can test a large set of apiendpointsatonce mostexistingharnessesonlytestoneor two endpoints at a time and therefore graphfuzz could easily get more coverage by invoking more endpoints.
however we were able to find harnesses in the skia project which fuzzed between 6to350endpointsatatime.weusedtheseharnessestoestablisha quantitativebenchmarkthatwediscussinmoredetailinsection .
.
.
wefoundhardbugs i.e.segfaults use after free buffer overflows in of the libraries we fuzzed and we found soft bugs internalassertionerrors ineverylibrary.sincemostofthesebugs require api control to trigger they are naturally less likely to manifest as security vulnerabilities.
however we did find potential security vulnerabilities in both skia and rdkit.
.
implementation all ofthe fuzzingexperiments described inthe followingsections were performed on a core amd epyc cluster with gb of ram.
fuzzer harnesses were compiled in an ubuntu .
or ubuntu .
docker container using clang .
for exploratory fuzzerruns weusedbetween1and32coresinlibfuzzerforkmode.
the skia benchmark was performed with cores per harness.
weprovidealloftheharnessesandsupportingcodetoreproduce these experiments in the graphfuzz repository.
.
skia graphics library skia isaamature c graphicslibrary maintainedbygoogle andused inhigh profileprojects suchaschromium andandroid.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
graphfuzz library api fuzzing with lifetime aware dataflow graphs icse may pittsburgh pa usa figure8 graphfuzzfuzzingprocess.
.corpusinputsareselectedbylibfuzzer2.graphfuzzappliessemanticgraphmutations .
inputs are invoked through a dynamic traversal of the dataflow graph .
coverage feedback is collected and used to guidecorpus growth and selection.
theskiacodebasehasbeenrigorouslytestedbygooglesecurityengineers independentbugbountyhuntersandtheoss fuzzproject.
cumulativelybillionsofcpuhourshavebeenspentfuzz testing skia.
asagraphicslibrary thecoreskiaapicontainsdozensofobjectsrepresentinggraphicsprimitivesandthousandsoffunctions that operate with these objects.
due to skia s use in high profileprojects such as chromium and android many of these internal apis are potentially attacker controlled.
a malicious webpage can usespeciallycraftedsvgorthejavascriptcanvasapito induce specific api calls in the renderer process.
during our research we found hundreds of unique assertion errors.wealsofoundandreported3securityvulnerabilitiesinskia.
one we show in figure .
.
.
existing harnesses.
duetoitssecurityimportance considerabletimehasbeenspenttodevelopfuzzingharnessesforskia.
currently there are separate libfuzzer targets in the skia repository most of which are fuzz tested at scale as part of oss fuzz.
the majority of these harnesses isolate one specific endpoint such as adeserialize function or a compile shader function.
several of these harnesses use the fuzzeddataprovider approach to test a wide array of api endpoints at once.
for example the fuzz draw functions harness simulates drawing random shapes and paths to a canvas.
.
.
head to head benchmark.
we selected existing structureaware oss harnesses from the skia project as a baseline.
for each existing harness we created an equivalent graphfuzz harness designed to fuzz exactlythe same api surface.
while in practice it isnotnecessarytoconstraingraphfuzzinthisway limitingthe fuzzable api surface allows us to construct a fair head to head benchmarkandensureanydifferencesingeneratedcoverageare due to the flexibility andefficiency by which both variants can fuzz testapiinteractionsandnotsimplythe numberoffuzzable endpoints.
on average for each graphfuzz harness we were able to accurately specify the usage semantics of of target endpointsusingonlythe function signatures.
the remaining of cases requiredminimalrevision forexampletospecifytheusageofan array argument or constrain the domain of an input argument.
see the auto column in table for a breakdown by harness.
we performed independent hour fuzz sessions for each harnessusing4 coresinlibfuzzer sforkmode.eachharnesswas linkedagainsttheexactsameskiabuild.afterthedesignatedperiod we computed line coverage over the whole corpus using a gcovinstrumentedversionofeachharness.forcomparisonpurposeswecompiledasecond instrumentedversionofeachharnesscalledthedry harness which is identical to the original harness except it does not invoke the target api.
this dry harness allows us to account for differences in coverage due to the way both harnesses read andpreparetestcases.forexample boththeossandgraphfuzz harnesses use a small percentage of the skia api to prepare data streamsandsetupthefuzzenvironment.wecanusethedifference in coverage between the normal harness and the dry harness to isolate only the code coverage that is due to actual target api fuzzing.
specifically given cossandcgf setofcoveredlinesforossand graphfuzz respectively and the dry harness coverage c primeossand c prime gf setof coveredlinesin thedry harnessvariants we compute the shared fuzzer core coverage r c primeoss c prime gf i.e.
theuninterestingcode coverage due to harness specific mechanics .
then we compute the normalized line coverage as noss coss r and ngf cgf r .
to obtain temporal coverage information we parsed the libfuzzer log output which contains both the elapsed time and alibfuzzer internal covmetric for many data points over the 48hour period.
this cov metric is not directly comparable between harnessessinceitincludesharness specificcoverageinformation.however withthe assumptionthatthis metricscalesroughly linearly with the true normalized line coverage nossandngf we graph a linearly scaled version of the libfuzzer covmetric such that the final datapoint matches nossorngfexactly.
this chart providesavisualcuefortheevolutionofthefuzzercorporaover time.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa harrison green and thanassis avgerinos .
.
benchmark results.
fuzzercoverageisgraphedinfigure9 and we provide statistical information in table .
in the best cases the graphfuzz harness generated nearly 9x as muchlinecoveragecomparedtothebaselineandintheworsecases the graphfuzz harness was roughly equivalent to the baseline.
in general we see the largest coverage improvements with graphfuzz on the larger harnesses.
intuitively more endpoints means there are more opportunities for novel interactions.
man ually defined harnesses miss these interactions unless they are specifically programmed to test them.
for small harnesses such as api regionop api pathop and api path measure the graphfuzz harnessesare roughly equivalenttotheexistingskiaharnesses.bothharnessvariantsquickly explore the majority of the state space and plateau.
inlargerharnessessuchas api svg canvas andapi draw functions graphfuzzcontinuestofindnewcoverageuntiltheend of the hour period while the baseline harness plateaus early on.
.
other oss targets .
.
rdkit.
rdkit is a cheminformatics library written in c with python bindings for most of the api.
typical usage involves constructing and manipulating many different objects such asrdmol rdatom andrdbond representingmolecules atoms and bonds respectively .
rdkithasbeencontinuouslyfuzzedaspartofoss fuzzsince may .
despite this we found bugs with graphfuzz including heap use after free and segmentation faults after fuzzinga small portion of the rdkit api surface.
most of these bugs were alsoreachablefromthepythonapibindings.wedisclosedthree security relevant bugs to the rdkit developers.
.
.
sqlite.
sqlite is a small sql database library written in c. it is used in chrome android and hundreds of other projects.
we spent a few days harnessing most of the sqlite3 c api with graphfuzz.weidentifiedtwocrashingtestcasesrequiring5and15 endpoints respectively.
in the first case graphfuzz discovered that settingthe sqlite limit length to0wouldcrashasubsequent sqlite3 prepare v2 statement.inthesecond graphfuzzfound awaytocrashsqlitebyinvokingthreeonlinebackupsatonceinaspecificorder.duetothewaysqliteisusedinthewild thesebugs are unlikely to manifest as security vulnerabilities.
however for a heavily fuzzed library like sqlite it is impressive that graphfuzz could discover these bugs.
.
.
eigen.
eigen3 isac templatelibraryforlinearalgebra.
itisusedinprojectssuchastensorflowandchromium.wefound this target particularly interesting to harness due to the extensive use of templates.
althoughgraphfuzz does not currently support c template syntax natively it is possible to define schemas that usefixed argumenttemplatefunctions.weusedgraphfuzztofuzztest a subset of the matrix and vector api.
although we did not find any crashing bugs we discovered test cases that reach dozens of unique assertions in the eigen core library.
.
.
iowow.
iowow isakey valuestoragelibrarywritten inc.theprovidedapiallowsausertocreateanddestroydatabase objects and store retrieve key value pairs consisting of arbitrarybyte string data.
we spent less than a day configuring a schemaforiowowandfuzzingitandidentifiedtwocrashingbugswithin minutes ofstarting the fuzzer.
inthe first graphfuzzdiscovered thataddingmetadatatoadatabaseobjectwith iwkv db set meta and then destroying the database iwkv db destroy would cause ause after freeuponclosingthecontaining iwkvinstance.inthe second graphfuzzidentifiedthatinitializingadatabasewiththe iwdb vnum64 keys flagandtheninvoking iwkv cursor open on thedatabaseusingalookupkeyofsize0 wouldtriggerasegmentation fault.
we reported both of these bugs to the maintainers and they were quickly patched in the latest version.
limitations .
automation while graphfuzz can automatically synthesize a schema from a listoffunctionsignatures wefindthatfunctionsignaturesalone are not always sufficient to describe the usage requirements of an endpoint.
for example in the c function void foo bar b argument bcould be an input an output or both.
similarly in the functionvoid sum int arr int n there may be a hidden correlationbetween arrandnwherethesizeof arrisexpectedto be at least n. during our experiments we observe that roughly of endpoints seetable2 canbeaccuratelymodeledwithonlythefunction signature while the remaining require human curated custom endpoint definitions.
the development of systems which can au tomatically infer or search these implicit constraints in library apis is an interesting area for future research.
.
false positives givenanincorrect schema graphfuzzcangenerate falsepositive crashes do to invalid api usage.
in other words generated graphs areonlyasaccurateastheprovidedschema.usersofgraphfuzz need to take care to ensure that the graphfuzz schema aligns with the target library api.
we call this problem schema alignment.
inpractice weobservetwodistincttypesofschemaalignment issues .
.
type single endpoint semantics.
givenaschemawithan incorrectly specified endpoint such as the examples in section .
graphfuzz will quickly and frequently generate false positive crashes.
these issues are both easy to diagnose and easy to correct by manually redefining the endpoint.
.
.
type multi endpoint semantics.
somelibraryapishave hard to model usage requirements that span multiple endpoints.for example one api pattern we observe in skia is the use of a sharedpointer sk sp foo alongwitha foo reffoo method.
thereturned foopointerisvalidaslongastheoriginal sk sp foo object has not been destroyed.
in this case modeling the usage requirementsismoredifficultthansimplymodelingeachendpoint.
auserneedstocreateaschemasuchthat sk sp foo cannotbe destroyed while a foopointer is still used elsewhere.
for example it is possible to define a synthetic type in the graphfuzz schema which bundles the returned foopointer along with the original sk sp foo object such that the sk sp foo object cannot be destroyed until the foopointer is released.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
graphfuzz library api fuzzing with lifetime aware dataflow graphs icse may pittsburgh pa usa 0h12h24h36h48h05101520api draw functions 0h12h24h36h48h0510api raster n32 canvas 0h12h24h36h48h02468api null canvas 0h12h24h36h48h0510api pathop 0h12h24h36h48h0.
.
.
.5api polyutils 0h12h24h36h48h0510api svg canvas 0h12h24h36h48h0510api mock gpu canvas 0h12h24h36h48h0.
.
.
.6api regionop 0h12h24h36h48h0.
.
.0api path measure 0h12h24h36h48h024region set path graphfuzz baseline average coverage figure graphfuzz vs. oss fuzz harnesses on skia benchmarks.
each line shows a complete hour fuzz session on cores.
the x axis shows elapsed time in hours and the y axis shows normalized line coverage in thousands .
the bold lines indicated by the marker show the average coverage from graphfuzz and oss respectively across the runs.
harness endpoints auto baseline nlc graphfuzz nlc coverage api draw functions .45x api raster n32 canvas .84x api null canvas .86x api pathop .99x api polyutils .54x api svg canvas .39x api mock gpu canvas .03x api regionop .99x api path measure .02x region set path .01x table skia benchmark results.
nlc normalized line coverage reported as mean std for fuzzer runs.
coverage average increase in coverage gained by graphfuzz over the baseline 1x means no change .
auto percentage of endpointsspecified using only the function signature.
this solution is effective at preventing false positives but is a stop gapforamorecomplexproblemandlimitstheflexibilityof generatedgraphs.furtherresearchisneededtodesignsolutions that enable more accurate modeling of multi endpoint semantics.
conclusion inthispaper weintroducedthetechniqueofdataflowgraph based fuzzingwhichisdesignedtofuzz testlibraryapi s.wedescribe this approach in the context of fuzzing c and c libraries and we release our implementation of dataflow graph based fuzzing called graphfuzzasanopen sourceframework.wevalidateourapproachonfivereal worldtargetsanddemonstratethatgraphfuzzcanfind realbugsandoutperformhand craftedharnessesinquantitativebenchmarks at a fraction of the development cost.
often times the only information required to fuzz with graphfuzz is a list of function signatures in a target.