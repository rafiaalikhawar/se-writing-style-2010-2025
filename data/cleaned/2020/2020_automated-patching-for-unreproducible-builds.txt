automated patching for unreproducible builds zhilei ren key laboratory for ubiquitous network and service software of liaoning province school of software dalian university of technology dalian china zren dlut.edu.cnshiwei sun school of software dalian university of technology dalian china mail.dlut.edu.cnjifeng xuan school of computer science wuhan university wuhan china jxuan whu.edu.cn xiaochen li university of luxembourg luxembourg school of software dalian university of technology dalian china xiaochen.li uni.luzhide zhou school of software dalian university of technology dalian china cszide gmail.comhe jiang school of software dalian university of technology dalian china jianghe dlut.edu.cn abstract software reproducibility plays an essential role in establishing trust between source code and the built artifacts by comparing compilation outputs acquired from independent users.
although the testing for unreproducible builds could be automated fixing unreproducible build issues poses a set of challenges within the reproducible builds practice among which we consider the localization granularity and the historical knowledge utilization as the most significant ones.
to tackle these challenges we propose a novel approach repfix that combines tracing based fine grained localization with history based patch generation mechanisms.
on the one hand to tackle the localization granularity challenge we adopt system level dynamic tracing to capture both the system call traces and user space function call information.
by integrating the kernel probes and user space probes we could determine the location of each executed build command more accurately.
on the other hand to tackle the historical knowledge utilization challenge we design a similarity based relevant patch retrieving mechanism and generate patches by applying the edit operations of the existing patches.
with the abundant patches accumulated by the reproducible builds practice we could generate patches to fix the unreproducible builds automatically.
to evaluate the usefulness of repfix extensive experiments are conducted over a dataset with real world packages.
based on repfix we successfully fix the unreproducible build issues for packages.
moreover we apply repfix to the arch linux packages corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
successfully fix four packages.
two patches have been accepted by the repository and there is one package for which the patch is pushed and accepted by its upstream repository so that the fixing could be helpful for other downstream repositories.
ccs concepts software and its engineering maintaining software software testing and debugging.
keywords reproducible builds dynamic tracing automated patch generation acm reference format zhilei ren shiwei sun jifeng xuan xiaochen li zhide zhou and he jiang.
.
automated patching for unreproducible builds.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
.
introduction as a set of emerging software engineering practices reproducible builds have attracted rapidly growing interests from both academia and industry.
the motivation behind reproducible builds is to allow any user to verify that no vulnerabilities or backdoors have been introduced during the compilation process.
through validation localization and repairing tasks the reproducible builds aim at building bit for bit identical compiled packages to bridge the gap between source to binary code with an independently verifiable path .
for example the well known malware xcodeghost which affected more than packages could be detected by independent recompiling applications from multiple build environments .
by guaranteeing identical built artifacts are always generated from a given source package diverse third party users could come to a consensus on the build result so that inconsistent built artifacts immediately trigger alarms for further investigation.
within the reproducible builds practice fixing unreproducible build issues is an important meanwhile challenging task.
currently ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa zhilei ren et al.
various software repositories are conducting the testing the localization and the fixing for the package reproducibility issues.
for example industry leading companies such as microsoft google and huawei have been focusing on the reproducibility property of their software product lines .
in the open source community gnu linux distributions such as debian arch linux and guix are routinely validating the reproducibility of the packages hosted by their repositories1.
as of february .
of debian s packages bookwarm amd64 and .
of arch linux s packages are reported to be reproducible2.
also studies focusing on the localization task i.e.
searching for the root causes and problematic files for unreproducible builds have been reported in the literature .
while the automation of validation and localization has been developed as emerging techniques the fixing for the unreproducible builds is mostly manually conducted and relies heavily on the developers knowledge and experience.
there exist various obstacles within the automated fixing process for the unreproducible builds and we list two major technical challenges as follows.
localization granularity challenge.
despite the promising results achieved the localization for unreproducible builds could only be realized at the file level i.e.
developers have to manually read the source file reported by the localization tools in search of the specific line for patching.
given that the makefiles and scripts could be of tens to hundreds of lines such fine grained localization task could be time consuming and error prone.
historical knowledge utilization challenge.
currently the patches for fixing unreproducible build issues are mostly manually written by the developers.
meanwhile for software distributions like debian during the reproducible builds practices various patches for fixing the unreproducible build issues have been accumulated.
however how to leverage the historical knowledge to fix new unreproducible packages remains a great challenge.
to tackle the aforementioned challenges we propose a novel reproducible build fixing repfix approach which features the combination of two mechanisms i.e.
the tracing based fine grained localization and the history based patch generation.
on the one hand to face the localization granularity challenge we incorporate not only kernel level system call traces but also user space application traces to establish the linkage between each build command and its specific invocation location.
with the help of these runtime traces problematic build commands with their accurate location could be located.
on the other hand to tackle the historical knowledge utilization challenge we propose a patch generation approach guided by the existing patches.
for unreproducible packages we retrieve their most relevant patches extract the edit operations from the retrieved patches and apply the operations over the problematic build command obtained from the fine grained localization.
with the patched source files we are able to validate the correctness of the overall approach.
to evaluate repfix we take the real world packages from debian as a case study to examine whether repfix is able to generate valid patches that fix unreproducible build issues.
over the packages repfix is able to successfully fix all the unreproducible build issues over packages and partially fix the issues over another packages.
moreover to examine the generalization ofrepfix we apply repfix over the arch linux packages and successfully fix the unreproducible build issues for four packages of which two patches have been accepted.
in particular there is one package for which the patch is pushed and accepted by its upstream repository.
we make the details of the patches available at the contributions of this study could be summarized as follows to the best of our knowledge we are the first to generate patches for unreproducible builds in an automated paradigm.
we propose a tracing based approach that unifies traces from kernel and user space to realize fine grained localization and design a history based patch generation.
we conduct extensive experiments over the dataset collected from a set of real world unreproducible packages to demonstrate the effectiveness of repfix.
we also submit four patches constructed by repfix to the arch linux bug tracking system among which two have been accepted by the maintainers.
the remainder of this paper is organized as follows.
in section we introduce the background information with a motivating example.
in section we discuss the details of the repfix approach.
in section extensive experiments are conducted to evaluate repfix from various perspectives.
sections present the discussion as well as the related work of this study.
finally section concludes this study and points out the future research directions.
motivating example in this section we introduce the background information with a motivating example.
take the mylvmbackup package a mysql backup utility with version .
from the debian repository as an example we first describe the reproducibility validation workflow.
the validation process is carried out by building the source files under controlled varied build configurations.
the altered configurations include build date timezone information locale file system traversing order etc3.
if the built artifacts under the two build configurations are bitfor bit identical the package is reported as reproducible.
otherwise if there exists any inconsistent artifact between the two builds the package is indicated as unreproducible and we shall continue to analyze the root cause for the unreproducible build issue conduct the localization task and fix the problematic build commands.
with the reproducibility validation tool chain reprotest4 mylvmbackup is reported as unreproducible.
in fig.
we present the diff log for the package which is generated by the in depth comparison utility diffoscope5.
it is shown that there exists an inconsistent artifact usr bin mylvmbackup in which a timestamp is embedded in the generated file.
consequently when the package is built at different time inconsistent packages will be compiled.
to fix unreproducible build issues localization has to be first conducted.
currently there exist automatic approaches such as reploc authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automated patching for unreproducible builds icse may pittsburgh pa usa source1 .
usr bin mylvmbackup source2 .
usr bin mylvmbackup unified diff use fcntl use diagnostics use strict version is set from the makefile my version .
my build date my build date ... figure diff log for mylvmbackup define some variables name mylvmbackup version .
42builddate shell date y m d man1 man name .
hooks wildcard hooks .pm distfiles changelog copying credits ... figure snippet of the makefile file for mylvmbackup and reptrace which aim at retrieving the problematic files that cause the unreproducible build issues.
for the two tools reploc follows the information retrieval based fault localization studies and realizes the localization functionality based on text similarity between inconsistent artifacts and build logs to search for the most relevant build scripts to the inconsistent artifacts.
meanwhile besides file level localization reptrace is able to represent the root cause as the problematic build command and its process id pid .
for both the approaches the makefile could be located.
however the file has to be further manually traversed to identify the 42th line that should be patched see fig.
.
after that the line of the problematic build command should be patched by modifying the command in the hope of fixing the issue.
ideally if we could obtain the mapping between each executed command and its location where the command is invoked it will be helpful for fixing the issue.
however obtaining such mapping relationship is not straightforward.
a possible way is to instrument the bash interpreter adding logging statements in the source code.
however such intrusive approach is hard to generalize to other applications.
alternatively another possible way is to leverage the power of dynamic tracing frameworks such as systemtap6and bpftrace7.
these frameworks allow developers to deeply investigate the behavior of the kernel and user space applications in order to debugging errors performance issues or understand system working mechanisms .
the main focus of these tools is to make it easy to capture and manipulate the required data without modifying the kernel application source code which is often required for instrumentation based studies .
both systemtap bpftrace are command line applications that utilize scripts as input and generates plain text output.
the expressiveness of the domain specific tracing languages makes it possible to generalize to other applications.
based on the connection between the traces from user space and kernel space we could extend the causality analysis to achieve fine grained localization.
besides since our goal is to generate feasible patches we intend to design an extensible approach to automate such process.
currently the patches are manually constructed based on the developers experience.
meanwhile during the reproducible builds practice software repositories like debian have accumulated thousands of patches for fixing unreproducible build issues.
hence an automated approach based on the historically fixed patches would be ideal.
however the cumulated knowledge may not be directly transferable to new unreproducible packages.
for example to guide the patch generation we have to take the grammar of the build scripts into consideration.
proposed approach in this section we discuss the design and implementation of the repfix framework.
in fig.
we first illustrate the components of the proposed framework.
in repfix there are two major components i.e.
tracing based fine grained localization and history based patch generation which aim to tackle the localization granularity challenge and the historical knowledge utilization challenge respectively.
figure the repfix framework more specifically in the fine grained localization component we first invoke the build process under the supervision of the tracing monitor step .
the tracing script defines a set of probes which could be attached to both the kernel kprobes and user space applications uprobes .
with these probes runtime traces such as the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa zhilei ren et al.
parameters return value and global local variables of system calls and user space functions could be collected during the build process.
after the build completes the localization process is launched with the traces the source files and the built artifacts as the input step .
after the localization history based patch generation is conducted.
we extract the command to patch from the localization result step and get the most relevant patches from debian s bug tracking system step .
under the guidance of the retrieved patch the command is modified step and further used to generate the candidate patch step .
with the generated patch reproducibility validation should be applied over the patched source files to evaluate the patch step .
finally if the validation succeeds the patch is returned for deeper investigation.
in the subsequent subsections we shall discuss the two components in more details.
.
tracing based fine grained localization in the tracing based localization component we build the source files twice to obtain the built artifacts.
in particular to gain deep observability of the build process a trace monitor is employed to capture both the system call information and the user space process runtime information.
in this study we adopt systemtap to realize the tracing functionality due to its expressiveness and efficiency.
an advantage of using systemtap in our approach lies in its ability to capture both kernel space and user space traces.
hence after the build process we could not only capture what build commands have been executed as in the existing studies but also where these commands are invoked.
on the one hand for the system call traces kprobes are defined in the script which are translated and compiled into kernel modules.
on the other hand with the help of dwarf debugging with attributed record formats 8debug information uprobes could also be defined.
in this study we consider the user space runtime traces of two types of build scripts i.e.
bash and make from the gnu project.
the reasons we consider these two types of scripts are as follows.
first both bash and make are among the most popular build tools which are widely used in the open source community .
second both the tools are highly dynamic.
for instance according to the maintainer of gnu make there is no official grammar for make since makefiles could be highly contextdependant .
hence it is difficult to implement static analysis for these build tools especially for those scenarios where multiple build tools are involved.
as a result it is reasonable to take bash and make as the case study to investigate the feasibility of realizing localization at line level.
for bash the runtime traces could be obtained by probing the make child user space function.
each time a command in a bash script is invoked the make child function will be called and the return value of the function indicates the pid of the executed command.
moreover the source file and line number of the command could be extracted from global variables shell script filename andcurrently executing command .
by attaching probes to the make child function of the bash executable we are able to bridge tracing based fine grained localization input source files src build configuration conf output localization result res 1begin fori do ktrace i utrace i build src conf i end pid list reptrace ktrace lmap location map utrace res list forpid pid listdo res append res lmap end return res 12end the gap between the pid of each command and its corresponding location.
similarly for make the runtime traces could be extracted from two user space functions i.e.
start waiting job andjob next command .
for both functions the parameter refers to an instance of struct child which encapsulates the fields such as filenm andlineno .
besides we also attach probes to the function lookup variable to capture the locations of variable definitions in makefiles.
with such information we are able to complete the localization task by establish linkages between the pid obtained from reptrace and the line level location for patch.
it is interesting that being a byproduct in reptrace the pid plays an essential role in connecting the high level localization based on system call tracing and the low level fine grained localization based on user space function call tracing.
in algo.
we present the pseudo code of the tracing based finegrained localization.
the localization is based on the system call based localization as in reptrace.
first we build the source files twice with varied configurations lines .
meanwhile we apply systemtap to capture the traces from kernel and the build tools bash and make which are indicated as the ktrace and the utrace .
on the one hand with ktrace we are able to apply reptrace to locate the problematic build command with their corresponding pid line .
on the other hand based on utrace we could construct a key value structure lmap line with which we are able to query the location with the pid of the build command.
hence we could transfer the results of reptrace into the location for patching lines .
running example consider the mylvmbackup package introduced in section fig.
illustrates the overall workflow of the localization procedure.
first the kprobes and uprobes are attached to the kernel and the build tools i.e.
bash and make respectively step .
then when the build process starts utrace andktrace traces are collected step .
from utrace we could construct the location mapping step .
meanwhile based on ktrace we could conduct the system call tracing based localization as in reptrace.
to make the discussion self contained we briefly explain how the localization works as in reptrace.
reptrace relies on the dependency graph which is constructed by applying differential analysis over the system call traces between the two rounds of build step .
for example the dependency is authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automated patching for unreproducible builds icse may pittsburgh pa usa figure illustration for the tracing based fine grained localization component established in that the process with pid the date command writes different content see the last line of ktrace between builds and the content is written through a pipe pipe to the process with pid the make build command .
the other dependencies could be detected in a similar way.
after traversing all the related traces we could obtain the dependency graph.
from the dependency graph we could observe that the root cause for the unreproducible build is the date command which is propagated to the inconsistent artifact via the sed sh and install commands.
furthermore with the location mapping we could decide the problematic date command is invoked at line of the makefile step .
.
history based patch generation after the fine grained localization we proceed to generate the patch to solve the unreproducible build issues.
the essential idea of the patch generation process is to utilize the existing patches accumulated by the software repositories.
for example after yearsalgorithm patchgen input source files src localization result res build configuration conf number of evaluations k output patch patch 1begin patches load patches templates foreach p patches do t initialize template p templates templates t end forlocation resdo cmd extract command location src tmax arg max t templates similarity t cmd operations edit distance tmax patched cmd apply operation cmd operations patch diff cmd patched cmd src status evaluate patch src conf ifstatus reproducible then return patch end k k ifk 0then return empty patch end end 23end datetime shell date y m d datetime shell date u d source date epoch y m d figure snippet of template for mylvmbackup of the reproducible builds practices lead by debian there exists thousands of patches for solving the unreproducible build issues .
given an unreproducible package we intend to retrieve the most relevant patches and examine the possibility of transplanting the patch to solve the unreproducible build issue.
more specifically the patch generation process is described in algo.
.
the algorithm takes the source files the localization result the build configuration and the maximum number of evaluations as inputs and generate patches that are potentially able to solve the unreproducible build issues of the package.
first we load the patches which are obtained from debian s bug tracking system lines .
for each patch we extract the commands and instantiate a template lines .
each template consists of a command pair i.e.
the source and destination commands that describe the modification to the source command.
after that we initiate the patch generation process lines .
for each location reported by the localization component we extract the command to be patched from the source files.
then we could retrieve the most relevant template tmax with respect to the text similarity between the command to patch and the templates text.
in this study we consider the n gram based cosine similarity authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa zhilei ren et al.
figure illustration for command patching mylvmbackup .
.orig makefile mylvmbackup .
makefile name mylvmbackup version .
builddate shell date y m d builddate shell date u d source date epoch y m d man1 man name .
hooks wildcard hooks .pm distfiles figure patch for mylvmbackup between command texts9.
with the retrieved template we tokenize the extracted commands calculate the edit operations between the source and the destination commands of tmax and apply the operations to generate the patch10 lines .
in this study we tokenize the extracted commands with respect to the grammar of make and bash based on the following two considerations.
on the one hand we do not directly treat the patches as plain text in that text based edit operations may not be precise enough.
on the other hand due to the inherent complexity of the grammars for bash and make it is very challenging to parse the patches properly .
to validate the generated patch we evaluate the patch by building the patched source files twice with the configurations and calculating the checksums of the built artifacts lines .
if the build is reproducible the generated patch is returned.
otherwise the iteration continues with other locations for patching until the maximum number of evaluations is reached.
in this study repfix adopts two criteria to determine if the reproducibility of the patched source files no artifacts are missing e.g.
caused by incorrect build command and bit for bit identical artifacts are generated between the two rounds of build during validation.
besides we should note that during the experiments manual check for the patches are required in that plausible patches might be generated e.g.
patches with malformed build commands that fail to compile but with bit for bit identical artifacts obtained.
running example consider the mylvmbackup package we introduce in section again we first illustrate the relevant patch for the package as shown in fig.
.
then we tokenize the patch to obtain the edit operations between the source and the destination command in the patch i.e.
from the date command to source date epoch .
according to the reproducibility validation tool chain when building packages the build time is assigned in our preliminary experiments we observe that repfix is not sensitive to the choice of similarity.
shell date y m d builddate shell date u y m d figure snippet of a plausible patch for mylvmbackup to an environment variable source date epoch which could be exported when validating the subsequent builds.
hence replacing thedate command to source date epoch could keep the output identical once the environment variable is set with the same value.
besides u indicates coordinated universal time which suppresses the influence of timezone.
by applying the patch shown in fig.
the mylvmbackup package could be reproducibly built.
as a comparison fig.
presents an example of a plausible patch in which the patched command date u y m d is malformed.
under such circumstance date u y m d generates empty output and identical artifact usr bin mylvmbackup is obtained with unexpected content due to the incorrect patch.
experiments to evaluate the proposed repfix framework from various perspectives extensive experiments are conducted.
more specifically we consider the following four research questions rqs rq1 is repfix effective in fixing unreproducible builds for real world packages?
rq2 how effectively can the tracing based fine grained localization and the history based patch generation mechanisms improve the overall solution quality?
rq3 how efficient is each component of repfix?
rq4 is repfix able to be applied to other unreproducible build packages that have not been previously fixed?
among these rqs rq1 evaluates repfix s ability to accurately generate valid patches to resolve the unreproducible build issues.
rq2 concentrates on the contribution of each component of repfix.
by comparing each component with its variant we could gain more insights into the reason why repfix works.
rq3 investigates the overhead caused by each component of repfix.
finally rq4 focuses on the generalization of repfix.
repfix is implemented in python .
.
in particular the localization component is realized following reptrace in java .
in which the tracing tool is switched from strace to systemtap.
for the patch generation component the build command processing is based on bashlex11 and the parameter kis set with .
all the experiments are conducted on an intel nuc i7 8809g .10ghz cpu 32gb ram running debian bullseye amd64 .
for the real world unreproducible packages we consider the dataset as in reptrace .
there are initially packages in the dataset.
however due to the upgrade of the build tool chain packages could be reproducibly built and packages could not be built due to broken dependencies.
as a result the dataset in our experiments contains packages that cannot be reproducibly built.
besides the patches are obtained from debian s bug tracking authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automated patching for unreproducible builds icse may pittsburgh pa usa system12.
after filtering out the patches not recognized by bashlex we obtain templates13.
.
investigation of rq1 a number of files b number of lines figure statistics of the packages in this study in fig.
a we illustrate the statistics of the packages.
from the figure we could observe that the number of files for the packages we fix ranges from less than to over with an average number of .
.
the large number of files poses great challenges for the localization task.
furthermore we have to identify the line of build command after the file has been successfully located.
in fig.
b we present the boxplot depicting the distribution of the number of lines for the files to be patched.
we could observe that for the majority of the packages the number of lines ranges within .
moreover in fig.
we present the proportions of the reasons for the unreproducible build issues.
from the figure we could observe that the majority of the unreproducible packages are caused by timestamp related issues e.g.
the timestamp in compressed files and the embedded output of the date command.
this phenomenon conforms with the observation as in the existing literature .
over the packages repfix is able to construct valid patches for the packages i.e.
repfix is able to fix at least one unreproducible issue over these packages.
note that there might be multiple inconsistent artifacts in a single unreproducible package.
hence we indicate those packages for which part of but not all issues are fixed as partial fixes.
in this study there are packages that are fully reproducible after applying repfix.
among these fixable or partially fixable packages of the fixed packages belong to the timestamps category for compressed file and for embedded date .
there are also two packages for which the unreproducible build issues are caused by file ordering.
the reason is that in the history based patch generation we could not generate valid patches if there are not similar patches with the same root causes.
besides there are no packages from the randomness category in that the root causes for these packages mostly lie in python or perl scripts e.g.
non deterministic hash table traversal which could not be handled by repfix.
for the successful fixes we are further interested in the impact of number of templates used by repfix.
as discussed in section 13note that since both the dataset and the patches are from debian during the patch generation for each package we avoid using its corresponding template.
figure reasons of unreproducible builds in the dataset figure impact of the maximum evaluation number during the patch generation procedure for each localization result we consider the most relevant existing patches as the templates.
in fig.
we present the trend of successful patches as the maximum number of evaluations for each package increases.
from the figure we could observe that repfix is not very sensitive to the maximum number of evaluations.
even if when only single template is considered for each package repfix is able to fix at least one unreproducible build issue over packages.
answer to rq1 in this rq we investigate the effectiveness of repfix over a set of real world packages.
for of the packages repfix is able to at least fix one issue that is responsible for the unreproducible builds.
in particular repfix successfully makes packages reproducible.
.
investigation of rq2 to gain more insights into why repfix works in this rq we investigate each component of repfix with its variant.
more specifically two comparative approaches are considered.
first to examine the effectiveness of the tracing based finegrained localization we consider the text similarity based localization as the baseline indicated as loc text .
the comparative line level localization is intuitively realized as follows.
after obtaining the problematic build command and the located file to patch with reptrace we extract all the lines from each problematic file and calculate its cosine similarity same metric as in section .
with the problematic build command.
then the most similar line is returned as the localization result.
to evaluate the effectiveness of repfix s localization component we measure the accuracy rate precision recall and mean authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa zhilei ren et al.
figure comparison for the trend of accuracy rate reciprocal rank mrr in identifying the location for patching for unreproducible builds.
the metrics are computed by examining the ranked line level location for patching returned by the baseline.
the top nlocations in the ranked result list are called the retrieved list and are compared with the relevance list to compute the accuracy rate the precision and the recall respectively indicated as a n p n and r n respectively .
in particular a n measures the percentage of packages for which the top nlist provides at least one correct location for patching .
finally mrr is also considered as an aggregate metric to evaluate the retrieved result list which is calculated as mrr p p i rank i where p indicates the number of packages in the dataset and rank irefers to the rank position of the first correct location for patching for the ith package.
in tab.
we present the comparison between the localization component of repfix and the baseline approach.
in the table we consider the precision the recall the accuracy rate for the top top and top results as well as the mrr metric.
from the table it is obvious that the tracing based localization outperforms the baseline approach loc text significantly.
over out of the packages the location reported by repfix is correct considering only the top results.
when we further consider the top results repfix successfully locates at least one correct location for patching over packages.
to depict the comparison more intuitively in figs.
we illustrate the trends of accuracy rate precision and recall for the comparative localization which is based on text similarity.
from the figures we could observe that the results of the baseline localization approach loc text is not satisfying.
the recall remains the same for retrieved lists with length larger than .
even if we consider the top result the recall value remains below .
implying that we could not hit the real location to patch over all the packages with the baseline approach.
these phenomena confirm the necessity of applying the tracing based localization.
second to examine the history based patch generation component we are interested in whether the token based command patching is more effective than the baseline in which text based patching.
to achieve this the baseline adopts the tracing based figure comparison for the trend of precision figure comparison for the trend of recall fine grained localization and replace the patch generation component with text based modification indicated as repfix text .
more specifically during patch generation the patches are treated as text without taking the grammar of bash and makefile into consideration.
given a new unreproducible package we first sort all the patches according to the tree edit distance between the source command and the command to patch.
for the top ranked patch we generate a sequence of edit operations with the popular levenshtein edit distance and try applying the operations to the command to patch.
thereafter we apply the modifications generate the patch and validate the patched source files as in repfix.
if the validation succeeds the patch is returned.
over the dataset repfix text generates valid patches for packages which to some extent demonstrates the importance of the token based patch generation.
similar with rq1 we also present the impact of the maximum number of evaluations for repfix text in fig.
.
from the figure we could observe that repfix text is not as effective as repfix especially if the maximum number of evaluates is limited.
answer to rq2 in this rq we focus on why repfix works.
by comparing the localization of repfix with loc text we confirm the effectiveness of the fine grained localization.
also repfix is able to fix unreproducible issues over more packages than repfix text which demonstrates the usefulness of the token based patch generation.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automated patching for unreproducible builds icse may pittsburgh pa usa table results of repfix andloc text for the line level localization task approach a a a p p p r r r mrr repfix .
.
.
.
.
.
.
.
.
.
loc text .
.
.
.
.
.
.
.
.
.
figure impact of the maximum evaluation number for repfix text .
investigation of rq3 in this rq we investigate the efficiency of repfix.
as mentioned in section repfix leverages systemtap to realize the runtime trace collection which introduces non negligible time cost during the build process.
hence we shall empirically investigate the impact of the tracing on the build performance.
also we are interested in the time elapsed for each main steps of repfix.
fig.
illustrates the distribution of each component s time elapsed over the dataset.
in the figure each boxplot corresponds to one or more step in fig.
i.e.
the boxplots indicate the traced build step the localization step the patching steps in that these steps are closely related and the validation step .
besides we also present the distribution of the build time without tracing to analyze the impact of system call tracing.
from the figure we observe that the validation is the most time consuming step with an average value of .
seconds.
this observation is as expected since in the iterative fixing paradigm validation has to be conducted for each generated patch.
meanwhile the other steps tend not to be very time consuming.
interestingly when we compare the build time with without tracing we observe that the average time under the two circumstances is .
and .
seconds respectively.
such phenomenon implies that the tracing time cost is not negligible but is acceptable in most cases.
answer to rq3 by comparing the time distribution of each main step of repfix we identify that the patch validation is the most time consuming step.
also we confirm that the overhead of the tracing for both the kernel and the user space applications is nonnegligible.
however with the promising fine grained localization ability we think the time cost is in general acceptable.
.
investigation of rq4 finally in rq4 we are interested in applying repfix over new unreproducible packages.
as a case study we test repfix over real world arch linux packages.
the reason for the choice of the repository is that the arch linux community is actively conducting figure time consumed by components of repfix the reproducible builds validation and fixing practice.
also arch linux is a rapidly evolving gnu linux distribution where we could receive efficient feedback from the developers and maintainers.
the package fixing procedure is carried out as follows.
first the package status is obtained from the status page of arch linux s continuous integration testing system14.
then we download the source packages for the packages that are unreproducible with arch linux s build source management tool asp15.
after that we filter out the packages that use build systems other than bash and make since currently repfix does not handle build systems like cargo and bazel.
in total there are four packages for which repfix is able to resolve the unreproducible issues.
we submitted the patches in the form of bug reports to arch linux s bug tracking system .
all the bug reports have been assigned and two of the patches have been accepted.
when .
.
.orig makefile when .
.
makefile install when.
install m temp destdir bindir when ... u rwx go rx rm temp gzip when.
when.
.gz gzip 9n when.
when.
.gz test d destdir mandir mkdir p destdir mandir install m when.
.gz destdir mandir rm f when.
.gz figure patch for when in particular within the packages for which repfix successfully generated patches the package when16was an interesting case.
the package with version .
.
was unreproducible due to the misuse of gzip argument i.e.
gzip by default keeps its timestamp in authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa zhilei ren et al.
the compressed file unless the nargument is used .
after validating the patch shown in fig.
locally we submitted the patch with a bug report .
however the patch was not immediately accepted.
instead the maintainer suggested reporting the patch upstream.
the reason as stated by the documentation17 was that fixing the issue upstream might help other downstream repositories as well.
following the suggestion we opened an issue at the package s repository at github18.
also we explained to the author why the patch should be applied.
finally the patch was accepted which was then pushed to arch linux s repository later and the bug report was closed.
answer to rq4 repfix is able to effectively solve unreproducible build issues for real world packages.
four patches are submitted to the arch linux repository and two patches have been accepted.
discussion .
extensibility of repfix repfix could be potentially extended from two aspects.
first in this study we demonstrate the flexibility of repfix with two types of build scripts i.e.
bash and make.
to support more types of build systems the user space tracing is necessary.
in most build systems it is common that build tools are responsible for maintaining the relationship between build command location information as well as build processes when invoked.
hence it would be feasible to design systemtap probes to capture such data structures to construct the location mapping for repfix.
once such connection is established the corresponding build system could be supported.
furthermore for other operating systems such as bsd distributions and windows there also exist system level monitoring facilities such as dtrace and event tracing for windows etw with which fine grained localization could be realized.
second in this study we rely on the existing patches to construct new patches for new unreproducible build issues.
a more effective way might be summarizing a set of template based formal rules to guide the generation of patches.
in such paradigm we might be able to improve the generalization of repfix over new repositories since with summarized rules we are able to take more domain specific knowledge into consideration.
.
threats to validity in our evaluation there are two major threats to the validity.
first during the patch generation component after a candidate patch is generated the validation step is conducted to evaluate whether the patch is valid.
it is possible that the patched source files could be reproducibly built yet the functionality is not the same as in the original version .
for example if the patched command fails to be compiled and generates nothing the built package might be reproducible but the patch is not acceptable.
to mitigate this threat we introduce a constraint in patch validation checking the existence of all the built artifacts.
moreover we manually check the patches that pass the validation.
second another threat arises within the dynamic tracing framework.
in this study we employ systemtap to collect traces from kernel and user space applications.
at heavy workload systemtap may skip certain probes so that the traces might be incomplete.
to avoid such circumference we make sure that no multiple builds are executed simultaneously.
also sufficient buffer is assigned to systemtap.
in our experiment no missing probes are discovered.
a possible approach to preventing this issue is to implement the dynamic tracing tool from scratch based on the ptrace system call as in strace and dettrace .
related work there are two topics that are closely related to this study i.e.
the work related to reproducible builds and the work related to build script analysis and repair.
.
reproducible builds software reproducibility is an emerging research topic that has attracted great interests.
lamb and zacchiroli from the debian community make a systemic review of the current state of the reproducible builds.
as of the fixing of unreproducible builds currently the existing studies focus on the localization task.
in ren et al.
propose the initial work reploc that focuses on the automated localization for unreproducible builds.
in their study the localization for unreproducible builds is modeled as an information retrieval task and a hybrid framework that combines heuristic filtering and query expansion is developed in search of the problematic files that cause the build to be unreproducible.
in a system call tracing based approach reptrace is proposed which features the ability of root cause analysis for unreproducible builds.
with the dependency graph constructed based on the system call traces deeper insights could be gained into why builds are unreproducible.
besides there also exist studies that intend to guarantee the software build process to be reproducible.
navarro leija et al.
propose the framework dettrace a reproducible container abstraction for linux implemented in user space.
with dettrace the reproducibility of software build could be ensured by intercepting all the system calls that may introduce non determinism.
similarly he et al.
develop constbin which tries to fix unreproducible issues during the build process by capturing and replacing arguments of the execve system calls for suspicious build commands.
for these studies related to reproducible builds reploc and reptrace concentrate on the localization task but are not able to realize the fixing functionality.
meanwhile dettrace andconstbin intend to fix unreproducible issues on the fly during the build process.
despite the promising achievements the software reproducibility property could not be realized without the tools i.e.
the build process has to be conducted under the supervision of dettrace orconstbin.
unlike these approaches repfix is able to generate patches for the packages.
once fixed no more containers or tools are required for future builds.
also the generated patches in upstream repositories could benefit their downstream repositories.
.
build script analysis and repair due to the inherent complexity of build systems many software packages suffer from build failures and great effort has to be made to fix build scripts.
in recent years there have been a series of authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
automated patching for unreproducible builds icse may pittsburgh pa usa studies on the analysis and the repairing of the build scripts.
on the one hand to effectively analyze build scripts various techniques have been applied.
for example symake apply static analysis such as symbolic evaluation to help developers better understand build scripts.
gazzillo proposes kmax to find all configurations of linux kernel s kbuild makefiles.
besides there are also dynamic analysis approaches such as mkcheck and buildfs .
compared with these studies on build script analysis a unique feature of this study lies in its ability to utilize the runtime trace capturing from both the kernel and the user space applications i.e.
make and bash.
with the modern tracing framework more accurate runtime behavior could be captured with which we are able to realize fine grained localization.
on the other hand to fix build script faults there have been growing research interests on the automated repairing of build scripts.
foyzul and wang propose the hirebuild framework which is an automatic approach to history driven repair of build scripts.
lou et al.
develop hobuff which considers the historical projects as well as the present project under test and external resources.
in lou et al.
systematically investigate more than build issues from stack overflow to summarize fix patterns for different types of failure with respect to three well known build systems i.e.
maven ant and gradle.
these studies focus on the fixing of build failures i.e.
hirebuild andhobuff are applied when projects failed to build from source.
in contrast repfix is more targeted to the scenario of unreproducible builds.
conclusions in this paper we propose the initial work repfix to generate patches for unreproducible builds in an automated paradigm.
the framework features the combination of the tracing based fine grained localization and the history based patch generation.
on the one hand with the unified tracing tool systemtap the system call trace induced dependency graph could be associated with the userspace trace guided line level localization and tackle the localization granularity challenge.
on the other hand by utilizing the existing patches we are able to generate valid patches for real world unreproducible packages.
furthermore repfix successfully fix the unreproducible build issues of four arch linux packages that have not been previously fixed.
the patches are submitted to arch linux s bug tracking system and two patches have been accepted.
for future work we are interested in the possibility of automatically generating fixing rules from the existing patches that solve unreproducible builds.
also an empirical study to gain deeper insights into the fixed patches is also an interesting direction.
besides we would like to extend the fixing technique to more software repositories which have not considered reproducible builds practice.