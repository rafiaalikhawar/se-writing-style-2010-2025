practical inference ofnullabilitytypes nimakarimipour nima.karimipour email.ucr.edu university ofcalifornia riverside riverside california usajustinpham jpham079 ucr.edu university ofcalifornia riverside riverside california usa lazaroclapp lazaro uber.com ubertechnologies sanfrancisco california usamanu sridharan manu cs.ucr.edu university ofcalifornia riverside riverside california usa abstract nullpointerexception s npes caused by dereferencing null frequentlycausecrashesinjavaprograms.pluggabletypecheckingis highlyeffectiveinpreventingjavanpes.however thisapproach is difficult to adopt for large existing code bases as it requires manually inserting a significant number of type qualifiers into the code.
hence a tool to automatically infer these qualifiers could make adoption oftype basednpe prevention significantly easier.
wepresentanovelandpracticalapproachtoautomaticinference of nullability type qualifiers for java.
our technique searches for asetofqualifiersthatmaximizestheamountofcodethatcanbe successfullytypechecked.thesearchusesthetypecheckerasa blackboxoracle easingcompatibilitywithexistingtools.however this approachcan be costly as evaluating the impact of a qualifier requires re running the checker.
we present a technique for safely evaluating many qualifiers in a single checker run dramatically reducingrunningtimes.wealsodescribeextensionstomakethe approach practical in areal world deployment.
we implemented our approach in an open source tool n u.sc l.sc l.sc hyphen.sc a w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc designedtoworkwiththenullawaytypechecker.
we evaluated n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc s effectiveness on both opensource projects and commercial code.
n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc reducesthenumberofreportednullawayerrorsby69.
onaverage.
further our optimizationsenable n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc to scale to large java programs.
n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc has been highly effective in practice in a production deployment it has already beenusedtoaddnullawaycheckingto160productionmodules totalingover1.3million lines ofjavacode.
ccsconcepts softwareanditsengineering softwareverificationand validation .
keywords pluggable type systems nullsafety staticanalysis inference thisworkwas partiallycompleted during an internshipat uber technologies inc. esec fse december san francisco ca usa copyright heldby theowner author s .
acm isbn .
reference format nimakarimipour justinpham lazaroclapp andmanusridharan.
.
practical inference of nullability types.
in proceedings of the 31st acm jointeuropeansoftwareengineeringconferenceandsymposiumonthefoundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa 12pages.
.
introduction nullpointerexception s npes caused by a dereference of null areawell knownandcommoncauseofcrashesinjavaprograms.
hence therehasbeenagreatdealofpastresearchonpreventing nulldereferences e.g.
.type basedapproachesto nullnesscheckingaregrowinginpopularity.inthisapproach types includeinformationonwhethereachexpressionmayevaluateto null andonlyexpressionsthatcannotbe nullcanbedereferenced.
recentlanguageslikekotlin andswift buildnullsafety intotheirtypesystems.further pluggabletypecheckerslikethe checker framework eradicate nullsafe and nullaway leveragetypequalifiers toaddtype basednullness checkingtojava.
type based nullness checking can be difficult to adopt for existingjavacodebases duetotheneedtomanuallyaddtypequalifiers intothecode.toenableincrementalandmodularchecking typebased nullness checkers require explicit nullability annotations on field parameter and return types.
hence manual effort is required to annotate any existing program for a type basedchecker.
while default assumptions for unannotated types reduces the annotation burdenconsiderably asignificantnumberofexplicitannotationsmuststillbewritten.1ourgoalistodevelopatoolforautomatically inferring nullabilityqualifiersforexistingcode thereby dramatically easingadoption of type basednullness checking.
wedesireapracticalinferencetoolthatcanbeusedwithrealworld code bases and type checkers and as such have three key requirements.first werequireatoolthatprovidesa besteffort partialsolutionincaseswhereaprogramcannotbeverifiedwithout code changes.
existing code may have real bugs or may be correct butwritteninastylethatisnotamenabletotype basedverification.
insuchcases aninferencetoolcanstillprovidesignificantvalueby addingannotationsthatenabletypecheckingof mostoftheoriginal program.thisway mostnewly addedormodifiedcode veryoften 1banerjee et al .
report an average of roughly explicit annotations per kloc on their open sourcebenchmarks ranging up to annotationsper kloc.
thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 san francisco ca usa nima karimipour justinpham lazaro clapp andmanu sridharan thesourceofdefects willbetypechecked whiledevelopers can gradually adopt andenable checking for the remaining code.
second werequiretheinferencetooltoworkalongsideanexisting type checker implementation.
inference approaches often require a type checkerthatsupports bothcheckingand inference directly e.g.
using constraintgeneration and solving.ourtoolinfersannotationsfortheexistingproduction qualitynullawaytype checker which does not use constraints.
while the constraintbased approach is elegant and efficient re implementation of a complexcheckerlikenullawaytouseconstraintswouldrequire a huge effort.
for example nullaway employs ad hochandling ofvariouscodingpatternsandlibraries e.g.
streamlibrariesand grpc to reduce false positives and this customized handlinglogicwouldhavetobeencodedpreciselyusingconstraints.to avoid re implementation we desire an inference approach that primarily treats the type checking tool as ablack box oracle relying only onits reportederrorsto perform inference.
third werequire theinferencetooltobeperformant.
forour use cases the tool must be able to run in an overnight job roughly 8hoursmaximum .withalongerrunningtime deploymentofthe tool becomes less practical due to the compute resources required and the fact that the target code could be changing frequently.
we are unaware of any existing approach that meets these three requirements.
in this paper we present a novel approach to nullability type inference suited to these requirements.
given an unannotated program ourapproachsearchesforasetoftypequalifiersthatminimizestheremainingnumberofnullawayerrors therebymaximizingthe amountofcodenullawayis ableto type check.findinga goodsetofqualifiersisnon trivial wefoundthateagerlyinserting all possible qualifiers could increasethe final number of errors.
our strategy evaluates candidate qualifiers using a bounded depth search iteratedto afixedpoint.
a na ve implementation of our search strategy is too slow for large code bases.
when treating the type checker as a black box oracle evaluatingtheimpactofacandidatequalifierontheerror countrequiresre runningthetypechecker.thoughnullawayis highly optimized each run still requires a re compilation of the code and can take tens of seconds or longer.
for larger programs a straightforwardversion of our searchrequiredrunning over1 builds makingthe tooltooslow.
ourkeyinsightisthatmanyqualifiersimpacttheerrorcount independently of each other.
since nullaway performs modular checking the code regions where new errors may appear due to qualifierinsertionarelocalizedandcanbecomputedaheadoftime.
giventhisinformation weconstructagraphrepresentingwhich candidate qualifiers may conflict by causing new errors in an overlapping region.
then we use graph coloring to find sets of non conflictingqualifiers whichcanallbetestedsimultaneously withinasinglenullawaybuild.withthisapproach manyfewer runsofnullawayarerequired dramaticallyreducingrunningtime andmakingthe toolpractical.
wealsodescribeextensionstoourtechniqueforhandlingrealworld code patterns and deployment.
we show how our algorithm can incorporate usage information from client code when annotatingalibrary significantlyeasingdeploymentinalarge modular1classtest nullable object f1 null suppresswarnings nullaway object f2 null nullable object f3 null nullable object f4 null nullable object f5 f4 7string m1 8returnf1 !
null?
f1.tostring f2.tostring 10intm2 returnf3 !
null?
f3.hashcode f2.hashcode nullable object m3 returnf4 figure1 motivating examplefor inference.
greentext indicates where annotationsareinserted by our technique.
our tool chooses to suppress the error on line to maximize the amount ofcodechecked by nullaway.
codebase.and wedescribeaspecializedhandlingoffieldinitializationto betterhandle certaincommon patterns.
we implemented our approach in an open source tool n u.sc l.sc l.sc hyphen.sc a w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc whichgeneratesannotationssuitablefordirectly enablingnullawaychecking.weperformedanextensiveempirical evaluation onbothopen sourceprojectsandasetofcommercial code modules at uber technologies inc. uber .
the evaluation showed that n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc decreased the final number of errors reported by nullaway by an average of .
.
.
.
further ouroptimizationswerecriticalforacceptableperformance reducing running time by an average of .1x .0x .8x and eliminating two timeouts.
n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc is deployed at uber for direct use by developers and it has beenhighly effective ithasbeenusedtoenablenullawaycheckingfor160production modules totaling over .
million linesof code.
this paper makesthe following key contributions we present a technique to infer type qualifiers that make as much of an existing program as possible verifiable by nullaway whiletreating nullawayas ablackbox oracle.
wedescribeanoptimizedsearchthatleveragesconflictdetection via graph coloring to simultaneously evaluate many candidate qualifiers reducing running time.
we present an open source implementation of the approach n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc and show its effectiveness in an extensive experimental evaluation.
overview in this section we give an overview of our nullability inference technique and present relevant background.
we illustrate our technique using the example code infigure .
1396practical inference of nullability types esec fse december3 san francisco ca usa .
type basednullness checking webrieflyintroducekeyideasoftype basednullnesschecking see theliteraturefordetails .type basednullnesscheckersfor java use type qualifiers to capture whether a type includes or excludes null.thesequalifiersarewritteninsourcecodeusingjava annotations prefixedwith .suchcheckerstypicallyuse nullable toqualifyatypethatcontains null and nonnull foratypethatdoes not.anunqualifiedtypeistreatedas nonnull bydefault except for local variables whose qualifiers are inferred automatically .
giventhesequalifiers typecheckingguaranteesthata nullable expression is never assigned to a nonnull location and that a nullable expression is never dereferenced.
assuming object fields are properlyinitialized and thatallexecutingcode hasbeentype checked thesepropertiestogetherguaranteetheprogramwillbe free of npes.
for clarity we defer discussing the impacts of field initialization checking to section and for now assume that all nonnull fields are appropriately initializedinaconstructor.
consider the code example in figure ignoring the green inserted annotations.
running nullaway on this code will yield four errors oneforeachoflines 2to5 sinceeachlineassigns nullto a nonnull field nonnull bydefaultsincetheyareunannotated .
these errors can be removed by changing the type qualifier of each field to be nullable e.g.
writing nullable object f2 on line3.
however adding these qualifiers can lead to new nullaway errors e.g.
making f2 nullable causesanewerroronline since f2.tostring thendereferencesa nullable expression.currently adding type based nullness checking to an existing code base requires repeatedly adding annotations and changing code manually until noerrorsremain atedious time consumingprocess.
to ensure null safety type based nullness checkers must also enforcestandardsubtypingrulesformethodoverriding i.e.
covariantreturntypesandcontravariantparametertypes.so ifamethod super.m1 p has a nonnull return type and a nullable parameter type anoverridingmethod sub.m1 p wheresub extends super mustnothave a nullable return type or a nonnull parameter type see further discussioninthe literature .
.
inference approach thegoalofourworkistoautomateasignificantportionofthework required to adopt type based nullness checking for pre existing real worldcodebases.wefocusontheproblemofinferringasetof nullable type qualifiers thatminimizesthenumber ofremaining errors reported by nullaway.
as noted in section we require inference to use nullaway as a black box oracle.
hence checking theimpactofasetofqualifiersonnullaway serrorcountrequires re runningnullawayonamodifiedversionoftheprogramwith the qualifiers inserted.
we only attempt to address errors fixable viaqualifierinsertion i.e.
errorsstemmingfromeitherassigning a nullable expression into a nonnull location or an incorrect method override notdereferences of nullable expressions .
from such errors we create a set of candidate fixesbased on qualifier insertion andthenusenullawaytotestifthosefixesreducethe overallerrorcount.
determining the impact of a candidate fix may require multiple iterations as fixes can cause new errors which themselves are amenable to fixing.
for figure adding a nullable qualifier to fixtheerroratline 3leadstotwonewerrorsatline 8andline11 both duetodereferenceofa nullable expression.sinceourapproach cannotfixthesenewerrors theline 3fixincreasestheoverallerror count and is not retained.
it makes sense to leave this error for the developer to handle as the lack of null checks for f2on lines8 and11contradicttheinitializationof f2tonull anditisunclear howto automaticallyresolve this contradiction.
addinga nullable qualifierfortheerroronline 5alsocauses twonewerrors online 6andline14.however thesenewerrors canbeaddressedviatwomore nullable qualifiers online 6and the return type on line and these qualifiers cause no further errors yieldingan overalldecrease.
our search discoversthe final solutionshowninfigure whichincludesthesethreequalifiers.
we detailour iterative search strategy insection .
to create a code change that can be adopted immediately our toolsuppressesanyremainingnullawayerrorsafteritssearchis complete forfigure weinsertthe suppresswarnings annotation on line3.
adding suppressions is not ideal since they may mask realnpebugsremaininginthecode.however akeybenefitofthis approach is that afterremainingerrorsare suppressed nullaway can be enabled for all future builds of the code.
developers then benefitfromnullawaycheckingforanysubsequentcode change outsideofasuppressedregionoranynewly writtencode andrecentcode changesare oftenthesource ofdefects .
remaining suppressions can be removed gradually as part of periodic code cleanup efforts.
alsonote that with this approach the initial code change enabling nullaway introduces no semantic changes easing code review and can be generated with no manual effort .
minimizing the number of remaining nullaway errors during inference maximizes the amount of code subject to nullaway checking after the inferredqualifiers are adopted.
.
optimizing performance ana veimplementationofoursearchrunstooslowlyinpractice due to the cost of repeatedly running nullaway to evaluate candidatesolutions.
reducing running time therefore requiresreducing thenumberofnullawayrunsrequiredforinference.thisreduction could be achieved if multiple independent qualifiers could be evaluatedsimultaneously inasinglerunof nullaway.twoqualifiersare independent if any nullaway errors removed or caused by each qualifierareguaranteedtobeinnon overlappingregionsofcode.
achievingaspeeduprequiresefficientlycomputinglargegroups ofindependent qualifiers.
our first key insight was that due to modular type checking the potential code regions where a nullable qualifier may add or removeerrorscanbecomputedpreciselyandcheaply.forexample a nullable qualifieronafieldcanonlyimpacterrorcountswithin methodsthatreadorwritethefield newerrors cannotappearother unrelatedmethods.so fortheinitialerrorsinfigure ourapproach determines that the potentially impacted regions for nullable qualifiers are m1forf1 m1andm2forf2 m2forf3 andm3forf4.
intuitively many qualifiers in a large program may be independent e.g.
whentheyapplytoprivatestateofdistinctclasses buta questionremainsastohowtoquicklyfindlargesetsofindependent 2each field initializer e.g.
the right hand side of object f5 f4 is also a region whichweignoreherefor simplicity seesection .1for details.
1397esec fse december3 san francisco ca usa nima karimipour justinpham lazaro clapp andmanu sridharan algorithm1 pseudocode for unoptimizedsearch.
procedure f i.sc n.sc d.scn u.sc l.sc l.sc a.sc b.sc l.sc e.sc q u.sc a.sc l.sc i.sc f.sc i.sc e.sc r.sc s.sc u1d443 u1d451 u1d438 n u.sc l.sc l.sca w.sc a.sc y.sce r.sc r.sc o.sc r.sc s.sc u1d443 u1d439all f i.sc x.scl o.sc c.sc a.sc t.sc i.sc o.sc n.sc s.sc u1d438 u1d439new u1d439all while u1d439new do u1d439good e v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sc u1d443 u1d439new u1d439all u1d451 u1d438 u1d443 a p.sc p.sc l.sc y.scf i.sc x.sc e.sc s.sc u1d443 u1d439good u1d438 n u.sc l.sc l.sca w.sc a.sc y.sce r.sc r.sc o.sc r.sc s.sc u1d443 u1d439 f i.sc x.scl o.sc c.sc a.sc t.sc i.sc o.sc n.sc s.sc u1d438 u1d439new u1d439 u1d439all u1d439all u1d439all u1d439new end while return u1d443 end procedure procedure e v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sc u1d443 u1d439 u1d439all u1d451 u1d438 if u1d451 0return u1d439 u1d439good for u1d453 u1d439do curfixes u1d453 for u1d456 do u1d443 a p.sc p.sc l.sc y.scf i.sc x.sc e.sc s.sc u1d443 curfixes u1d438 n u.sc l.sc l.sca w.sc a.sc y.sce r.sc r.sc o.sc r.sc s.sc u1d443 u1d439 f i.sc x.scl o.sc c.sc a.sc t.sc i.sc o.sc n.sc s.sc u1d438 if u1d438 u1d438 0then u1d439good u1d439good curfixes break end if newfixes u1d439 u1d439all ifnewfixes then break else curfixes curfixes newfixes end if end for end for return u1d439good end procedure qualifiers.
our second key insight was that groupsof independent fixes could be computed efficiently via graph coloring .
in compilers graph coloring is often used for register allocation .
in ourscenario twofixesareindependentiftheirimpactedregions donotoverlap.weconstructagraphrepresentationwherenodes represents sets of fixes and an edge between two nodes reflects overlapping regions for their fixes.
this graph can be colored to find groups of fixes that can be evaluated in a single nullaway run.
for our example the f1 f3 andf4fixes for figure 1can all be evaluated in a singlerun of nullaway see figure 2in section .
overall the optimized approach reduces the number of nullaway runsrequiredbytwoforfigure andasshowninsection the reductions for real world code are muchmore dramatic.
search based qualifier inference inthissection wepresentanunoptimizedversionofourinference algorithmfor nullable qualifiers tomakeclearhowourtechnique explores and evaluates the space of possible qualifiers.
in section we present our graph coloring basedoptimizedsearch.
pseudocode for the unoptimized technique appears in algorithm1.givenanunannotatedprogram u1d443andadepthlimit u1d451for evaluating fixes f i.sc n.sc d.scn u.sc l.sc l.sc a.sc b.sc l.sc e.sc q u.sc a.sc l.sc i.sc f.sc i.sc e.sc r.sc s.sc u1d443 u1d451 returns a modified program with nullable qualifiers that reduce the number of reported nullaway errors.
it uses a procedure e v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sc that givenaprogram u1d443 asetofcandidatefixes u1d439 allpreviouslyconsidered fixes u1d439all thedepth limit u1d451 andthe nullaway errors u1d438 for u1d443 returns a set u1d439goodof fixes that reduce the nullaway error count for u1d443.
bothproceduresmakeuseofthreekeysubroutines whoseimplementationsarenotshown .
n u.sc l.sc l.sca w.sc a.sc y.sce r.sc r.sc o.sc r.sc s.sc runsnullaway to compute the errors it reports for a program u1d443.
given a set of errors u1d438 f i.sc x.scl o.sc c.sc a.sc t.sc i.sc o.sc n.sc s.sc u1d438 first determines the subset of errorsin u1d438that can be fixed via nullable insertion see section .
.
for thatsubset itreturnsasetcontaining fixesforeacherror i.e.
the code locationswhere nullable should be inserted to fix the error multiplelocationsmayberequiredforasingleinitializererror see section6 .finally givenaprogramandasetoffixes a p.sc p.sc l.sc y.scf i.sc x.sc e.sc s.sc returns anewprogram withthe fixes inserted.
thealgorithmproceedsasfollows.
f i.sc n.sc d.scn u.sc l.sc l.sc a.sc b.sc l.sc e.sc q u.sc a.sc l.sc i.sc f.sc i.sc e.sc r.sc s.sc runs a fixed point loop lines inserting fixes determined bye v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sc to reduce the error count until no new fixes canbefound.in e v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sc ifthedepthlimit u1d451 allfixes areassumedtobegood line leadingtotheireagerinsertion.
otherwise for each fix u1d453 u1d439 the algorithm iteratively applies u1d453 andanynewfixesdiscoveredafterapplying u1d453uptosomemaximum depth u1d451 lines18 .
in the first iteration only u1d453itself is tested line19 withnewlydiscoveredfixesaddedtothe curfixessetfor eachsubsequent iteration lines .
a fix u1d453is determined to be good if the curfixesset of fixes for u1d453 doesnotincrease thenullaway errorcount lines .we keep fixeseveniftheyyieldthesameerrorcounttoimprovehandlingof fix chains at lower depth limits.
a fix chain occurs when inserting fix u1d4531causes a single new error with fix u1d4532 u1d4532leads to u1d4533 and so on where the final fix causes no new error.
if good fixes needed to strictly reduce the error count then discovering the goodness of u1d4531 would require setting u1d451to at least the length of the chain reducing performance.withourapproach thefixchainisappliedevenwith depthlimit dueto the outer fixed pointloop.
algorithm 1isguaranteedtoterminate.inanexecutionof f i.sc n.sc d.sc hyphen.sc n u.sc l.sc l.sc a.sc b.sc l.sc e.sc q u.sc a.sc l.sc i.sc f.sc i.sc e.sc r.sc s.sc the u1d439allsetoffixesgrowsmonotonically and numberofpossiblefixesforaprogramisfinite.so eventually u1d439new mustbecome emptyafter line causing the loopto terminate.
example.
considerapplyingalgorithm 1tothefigure 1example with a depth limit u1d451 .
in the first iteration u1d439new representing the fix locations for the initial errors reported by nullaway.in e v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sc thefixes 2and4willbelabeledas good at depth since theyimmediately reducethe error count by .
fix3is not labeled as good as it introduces errors that cannot be fixed with nullable annotations but fix 5is labeled good after exploringtodepth2andapplyingsubsequentfixesatlines 6and13 1398practical inference of nullability types esec fse december3 san francisco ca usa see section .2discussion .
so u1d439good in the first fixed pointloopiteration.nonewfixesareobservedafterapplying u1d439good sothealgorithmconverges yieldingthefinalsetof nullable qualifiers shown in figure .
for this example the unoptimized algorithmrequires7callsto n u.sc l.sc l.sca w.sc a.sc y.sce r.sc r.sc o.sc r.sc s.sc tocomputethefinal solution section 4willshowhowwe can reduce this number.
optimized search thesearchalgorithmofsection 3runstooslowlyforlargercode bases due to running a large number of nullaway builds.
here we present optimizations to significantly reduce this cost based on evaluatingmultipleindependent qualifierssimultaneouslyina build.
we first define the potentially impacted regions of a qualifier section4.
usedtodeterminewhenqualifierscanbeevaluated simultaneously.
then we give details of our graph coloring based searchalgorithm section .
.
.
potentially impactedregions our optimizations exploit the fact that for a type based nullness checker introducinga nullable qualifieronanentity field method parameter or method return can only impact the final error count in regions of the code where the entity is directly used or overridden .
thisfactstemsfromthemodularnatureofthetypechecking since nointer proceduralanalysisisperformedbythecheckertodetermine nullability the impact of changed nullability for an entity cannotpropagatebeyondthe procedures using the entity.
aregionisamethod aninitializerexpression e.g.
thereadof f4 atline6infigure oraninitializerblock.givenanentity u1d452 the potentially impacted regions for u1d452are the set of regions whose containederror count may change as the resultof adding a nullable qualifierto u1d452.wedefine potentially impactedregions for u1d452asfollows if u1d452is a field u1d453 any region containing a read or write of u1d453is potentially impacted.
if u1d452isaparameterorreturnofmethod u1d436.
u1d45a then u1d436.
u1d45aitselfis potentiallyimpacted asisanyregionthatcalls u1d436.
u1d45a.further any method that overrides or is overridden by u1d436.
u1d45ais also potentiallyimpacted.
regionsthatread u1d452maycontainnewerrors sinceonce u1d452is nullable it cannot be dereferenced or assigned to a nonnull location.
similarly errorsmayberemovedfromregionsthatwrite u1d452 sincewrites of nullable values into u1d452become legal.
overriding or overridden methods may be impacted due to nullaway s subtyping checks see section .
.
potentially impacted regions can be computed using standard type checking information like a type hierarchy andsymboltables.
.
optimizedalgorithm algorithm 2gives pseudocode for the key e v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sco p.sc t.sc procedureofouroptimizedsearch.theoverallalgorithmretainsthe f i.sc n.sc d.scn u.sc l.sc l.sc a.sc b.sc l.sc e.sc q u.sc a.sc l.sc i.sc f.sc i.sc e.sc r.sc s.sc procedurefromalgorithm withthe calltoe v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sc atline6replacedwithacallto e v.sc a.sc l.sc u.sc a.sc t.sc e.sc hyphen.sc f i.sc x.sc e.sc s.sco p.sc t.sc .
e v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sco p.sc t.sc computesgroupsofindependentfixesusing aconflictgraph .eachnodeinthegraphrepresentsapairofarootfix u1d453and related fixes curfixesbeing tested the same state tracked for each fix by the main loop of e v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sc in algorithm .
givenalgorithm2 optimizedsearch basedongraph coloring.
procedure e v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sco p.sc t.sc u1d443 u1d439 u1d439all u1d451 u1d438 if u1d451 0return u1d439 u1d439good initnodes root u1d453 curfixes u1d453 u1d453 u1d439 u1d43a c o.sc n.sc f.sc l.sc i.sc c.sc t.scg r.sc a.sc p.sc h.sc initnodes for u1d456 do groups c o.sc l.sc o.sc r.sc u1d43a toremove for u1d446 u1d454 u1d45f u1d45c u1d462 u1d45d u1d460do fixes uniontext.
u1d45b u1d446 u1d45b.curfixes u1d443 a p.sc p.sc l.sc y.scf i.sc x.sc e.sc s.sc u1d443 fixes u1d438 n u.sc l.sc l.sca w.sc a.sc y.sce r.sc r.sc o.sc r.sc s.sc u1d443 for u1d45b u1d446do u1d438 u1d45b uniontext.
u1d45f r e.sc g.sc i.sc o.sc n.sc s.sc u1d45b e r.sc r.sc o.sc r.sc s.sci n.scr e.sc g.sc i.sc o.sc n.sc u1d438 u1d45f u1d438 u1d45b uniontext.
u1d45f r e.sc g.sc i.sc o.sc n.sc s.sc u1d45b e r.sc r.sc o.sc r.sc s.sci n.scr e.sc g.sc i.sc o.sc n.sc u1d438 u1d45f u1d439 u1d45b f i.sc x.scl o.sc c.sc a.sc t.sc i.sc o.sc n.sc s.sc u1d438 u1d45b if u1d438 u1d45b u1d438 u1d45b 0then u1d439good u1d439good u1d45b.curfixes toremove toremove u1d45b end if newfixes u1d439 u1d45b u1d439all ifnewfixes then toremove toremove u1d45b else u1d45b.curfixes u1d45b.curfixes newfixes end if end for end for u1d43a c o.sc n.sc f.sc l.sc i.sc c.sc t.scg r.sc a.sc p.sc h.sc u1d43a.nodes toremove end for return u1d439good end procedure procedure c o.sc n.sc f.sc l.sc i.sc c.sc t.scg r.sc a.sc p.sc h.sc u1d441 conflictedges u1d45b1 u1d45b2 u1d45b1 u1d45b2 u1d441 r e.sc g.sc i.sc o.sc n.sc s.sc u1d45b1 r e.sc g.sc i.sc o.sc n.sc s.sc u1d45b2 return nodes u1d441 edges conflictedges end procedure procedure r e.sc g.sc i.sc o.sc n.sc s.sc u1d45b return uniontext.
u1d453 u1d45b.curfixespotentially impactedregionsfor u1d453 end procedure a set of nodes the c o.sc n.sc f.sc l.sc i.sc c.sc t.scg r.sc a.sc p.sc h.sc procedure constructs a conflict graph which contains an undirected edge between nodes u1d45b1and u1d45b2iffthepotentially impactedregionsforthefixesin u1d45b1.curfixes and u1d45b2.curfixesoverlap.
with this representation the fixes for any twonon adjacent nodes are independent and the impacts of all theirfixes maybe evaluatedsimultaneously.
after constructing an initial conflict graph line e v.sc a.sc l.sc u.sc a.sc t.sc e.sc hyphen.sc f i.sc x.sc e.sc s.sco p.sc t.sc proceeds by iterating up to the depth limit starting at line6 similartotheline 20loopine v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sc inalgorithm .
in each iteration the algorithm computes sets of independent fixes bycoloringthecurrentconflictgraph line .thec o.sc l.sc o.sc r.scroutine returnsasetofsetsofnodes groups whereforeachset u1d446 u1d454 u1d45f u1d45c u1d462 u1d45d u1d460 nopairofnodesin u1d446isadjacentin u1d43a.hence fixescorrespondingto 1399esec fse december3 san francisco ca usa nima karimipour justinpham lazaro clapp andmanu sridharan allnodesin u1d446canbeevaluatedsimultaneouslyinasinglenullaway run.
our implementation uses a greedy coloring algorithm whichproduces sufficiently goodresults for our needs.
for each group u1d446 line9 we apply allcurrent fixes for all nodes in that group simultaneously and run nullaway to compute an updatedsetoferrors lines 10to12 .thisyieldsasinglenewsetof errors u1d438 fromwhichwemustextracttheerrorsspecifictoeach node u1d45b to determine if u1d45b s fixes reduce the error count.
we can do so by finding original and new errors only in the impacted regions for u1d45b lines14and15 which are guaranteed not to overlap with anyothernodein u1d446.thelogicinlines 26isanalogoustothatin lines23 33inalgorithm exceptthatinsteadofbreakingoutofthe loop when a fix is fully handled the corresponding node is marked forremovalfromtheconflictgraph.afterprocessingallgroups we recomputetheconflictgraph line afterremovingmarkednodes andcontinuetothenextdepthlevel.recomputingtheconflictgraph is needed even if nonodes are removed as the listof current fixes for each node may have changed impacting the required edges between nodes.
in the end e v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sco p.sc t.sc returns the same result ase v.sc a.sc l.sc u.sc a.sc t.sc e.scf i.sc x.sc e.sc s.sc from algorithm 1for the same inputs but withasmallernumber ofcalls to n u.sc l.sc l.sca w.sc a.sc y.sce r.sc r.sc o.sc r.sc s.sc .
figure conflict graph infirstiterationofalgorithm2run on figure .example.
consider applying algorithm2to the figure 1example again with u1d451 .
figure2shows theinitialconflictgraphfortheexample capturing which fixes have overlappingimpactedregions.the coloringoffigure 2showsthatfixes and5can all be evaluated with a single call to n u.sc l.sc l.sca w.sc a.sc y.sce r.sc r.sc o.sc r.sc s.sc .
overall thesamefinalresultiscomputed butwith5callsto n u.sc l.sc l.sca w.sc a.sc y.sc hyphen.sc e r.sc r.sc o.sc r.sc s.scas compared to for algorithm1 real world improvements are more dramatic see section .
clientcode real worldcodebasesareoftencomposedofmanyinter dependent modules to enable more scalable development with large teams.
for scalability and ease of review it would be very useful to be able to apply nullability inference one module at a time for such projects.asdescribedthusfar ourinferencealgorithmaccountsfor nullaway errorswithin the code being annotated which we term thetargetcode.
in a multi module scenario the target code would be the single module being annotated.
however our presented technique does not yet account for potential nullaway errors in othermodulesdependentonthemodulebeingannotated whichwe refer to as clientcode.
ignoring client code can lead to undesirable inference results.
for example if a public method mhas no calls from within target code inference will assume that making m s return type nullable will not introduce any new errors even if client code assumes mdoes not return null.
here we describe an inference extension to account for assumptions made by clients of the target code crucial for usabilityinpractice.
a na ve approach to handling client code could simply compile all client code alongside the target in each build and observe theimpact of fixes in clients.
we assume annotations cannot be added toclientcode soerrorsshouldonlybetreatedasfixableifthefix locationisinthetarget.unfortunately thisapproachdoesnotscale to a large amount of client code even with the optimizations of section4 as each individual build becomes much more expensive when allclientcode isincluded.
instead wehandleclientcodeviaup front cachingoftheimpacts offixesonclients.forsimplicity hereweassumethatclientcode only interacts with the target via calls to public methods field accesses and method overriding can be handled similarly.
under this assumption fixes in the target may impact the client in two ways making a public return type nullable may cause new client nullaway errors and making a public parameter type nullable mayremoveclienterrors.beforeourcoresearch werun up frontbuildsofclientcodetofindandcachetheclientimpacts foreachsuchfix wethenusethecachedinformationduringthe searchandonlybuildthetargetcode.empirically thenumberof up frontbuildsrequiredwasfarfewerthanthenumberofbuilds run during the search see section so overall this caching yields alarge speedup.
our caching phase runs the following builds.
first we build the clientcodewithunmodifiedtargetcode andcacheallnullaway errors in client code caused by passing a nullable expression to a nonnull targetmethodparameter case above .then werun builds to cache the client errors introduced by making eachpublic target method return nullable case above noting when such errors have a fix location in the target.
we dramatically reduce the number of such builds needed for this phase by re using the graph coloring optimization of section .
.
with fully cached information about relevant client errors and their fix locations we augment algorithms 1and2to use this information during the search requiring nofurther clientcode builds.
resultequivalence.
thecachingschemedescribedabove canbe generalizedtocachetheerrorscausedby anypotentialfix whether in target or client code.
this more extensive caching could yield further search speedups when applying a set of fixes u1d439 if the impacts of all fixes in u1d439are already cached the cached information couldbeusedtocomputetheoverallimpactof u1d439 avoidingarunof nullaway.
unfortunately in certain cases the combined impacts of individualfixesin u1d439arenotequivalenttotheimpactofapplyingall fixesin u1d439together.thisoccursbecauseitispossibleforanewerror to appear only when a pairof fixes is introduced but not when eitherfixisaddedindividually.considerthis excerpt classc object f1 newobject object f2 newobject voidm f1 f2 f1.tostring say that due to nullaway errors in other code not shown the search considers making f1andf2 nullable .
nullaway reports a dereference of nullable error at the f1.tostring call only if 1400practical inference of nullability types esec fse december3 san francisco ca usa bothf1andf2are nullable .
if just f1is nullable no error is reported since f2is nonnull andassignedto f1before thecall.if justf2is nullable an error is reported at the f1 f2assignment but not at the call.
due to such cases cached information may under estimate the number of nullaway errors reported when multiple fixes are applied simultaneously.
in our evaluation we neverobservedunexpectednullawayerrorsinclientcodedueto this issue.
weighting.
aquestionremainsofhowtoweightclientvs.target nullawayerrorsduringtheinferencesearch.e.g.
forasmalltarget withalargeamountofclientcode onemaywanttoweighterrorsin thetargetmorehighlythanerrorsinclients.bydefault n u.sc l.sc l.sca w.sc a.sc y.sc hyphen.sc a n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc weightsallerrorsequally butdifferentweightingscan easily be supported.
at uber n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc is being used to annotate individual modules in a monorepo containing hundreds of modules.
some modules are already checked with nullaway and a key requirementfor n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc isthatnonewnullaway errorsshouldbeintroducedinothermoduleswhenannotatingatarget.thisfeatureeasescodereview sincethechangesintroducedby n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc aretherebylimitedtosemantics preserving changes to exactly one module requiring limited review.
before imposingthisrequirement weobservedcaseswhere n u.sc l.sc l.sca w.sc a.sc y.sc hyphen.sc a n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc changescausednewerrorsindozensofothermodules the fixes for these errors required reviews from many teams and dramatically slowedadoption.
for this scenario n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc includes a strict mode in which it only adds annotations to the target if they do not cause new errors in other modules.
in essence strict mode applies an infinite weight to client errors.
strict mode may increase the final number of remaining nullaway errors in the target.
however it makes adoption of changes from n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc much easier andasnotedinsection .
gettingthesechangesmerged quickly provides an immediate benefit as new code and most code modificationsinthe target then benefitfrom nullawaychecking.
initialization beyond the checks discussed so far nullaway also checks for correct object initialization.
consider the example of figure .
the t1 t2 andt3fieldsaretreatedas nonnull bydefault.however the testinit constructor fails to initialize the fields so they could still benullat later reads e.g.
if usefields were called immediately after the constructor .
hence nullaway reports an initialization error for the constructor.
our inference technique can handle such acasebyinsertinga nullable annotationonallthreefields which removes the error.
however this leads to three new dereferenceof nullable errors in the usefields method and hence does not decreasethe errorcount.
nullaway also supports initializer methods to capture cases where fields are initialized after object construction but before anyuse .forthefigure 3example assumetheintendedlifecycleoftestinit isthatafterconstruction the initmethodshould beinvokedbeforeanyothermethodintheclass.then thedereferences in usefields are safe as they will only occur after init has run.
such protocols arise regularly in practice e.g.
for android activities .
nullaway treats any method annotated with1classtestinit 2object t1 t2 t3 3testinit initializer 5voidinit object o1 object o2 object o3 6t1 o1 7t2 o2 8t3 o3 10intusefields no null checks needed here returnt1.hashcode t2.hashcode t3.hashcode figure example forillustrating initializationchecks.
initializer as a method that runs before all other methods in the class and reasons about field initialization in such methods appropriately.
nullaway does notcheck that client classes actually invoke initializer methods before other methods and hence its handling ofthis feature isunsound .
ourapproachincludeslimitedsupportforinferring initializer annotations.sincenullaway ssupportfor initializer isunsound we devised our approach toinfer initializer under narrow conditions aimingtoavoidintroducingincorrectannotations.weonly add initializer to amethod u1d45aif the following holds u1d45amust write a nonnull value to at least two otherwiseuninitializedfields andthosefieldscannotbeoverwritten witha nullable valuebefore u1d45areturns.
there can be at most one inferred initializer method per class.
if more than one method in u1d45a s class meets condition u1d45amustbe the methodthat initializes the mostfields.
inferenceof initializer occursinaseparatepass beforerunning algorithm sothatthecoresearchdoesnotinsert nullable annotations on fields that are never null once initializer methods are considered.
for the figure 3example our approach would add an initializer annotation to init thereby removing all errors reported for the class.
in our evaluation we inspected all introduced initializer annotations to check that they reflected actual lifecyclebehavior see section .
implementation we have implemented our approach in a tool n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc hyphen.sc t.sc a.sc t.sc o.sc r.sc which is open source.3to compute potentially impacted regions for fixes section .
we implemented a code structure scanner as an error prone plugin checker which runs as part of the java compilation process like nullaway .
this scanner serializestherelevantinformationaboutusesoffields usesofmethods and the type hierarchy as computed by the java compiler.
the scannerisimplementedin1 non blank non comment lines ofjava code.
1401esec fse december3 san francisco ca usa nima karimipour justinpham lazaro clapp andmanu sridharan a separate component handles insertion of annotations into source code.
it leverages javaparser to discover annotation insertion locations and then inserts annotations using string manipulationtoensurewhitespaceispreserved.whitespacepreservation is critical for making the tool usable in practice as any unnecessary formatting modifications make changes harder to review.
the injector isimplementedin1 linesofjava code.
finally the core optimized search of n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc section4.
is implemented in roughly lines of java code.
to runn u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc a developer must integrate nullaway and the code structure scanner as part of their compilation scripts.
n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc isbuild systemindependent asavariety ofbuildsystemsareincommonuseinthejavaecosystem.forease ofimplementation wemademinormodificationstonullawayto serializeitsoutputinamachine readableformat.thisoutputcould have beenparseddirectlyfrom nullaway serror messages butat greater engineeringcost.
evaluation in this section we present an experimental evaluation of n u.sc l.sc l.sc hyphen.sc a w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc showing the effectiveness of its inferred annotationsandofour performance optimizations.
.
experimentalsetupandresearch questions weevaluated n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc ontwoseparatedatasetsof java code bases.
first we used a collection of open source java projects from github.
from the most popular java projects on github asdeterminedbynumberofstars wechose13projects thatusethegradlebuildsystem toeaseintegrationofnullawayand n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc sconfiguration.toensuregreater diversity in the benchmarks we limited the number of android projectstofive.finally weincludedwala util amodulefromthe walastaticanalysislibrary maintainedbyoneoftheauthors toevaluateadoptingnullawayvia n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc onan open source project see section .
.
we did not create a larger suite of open source benchmarks due to the manual effort required tointegratenullawayand n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc intothebuild scripts ofeachbenchmark.
second we used a set of modules from uber s repository of javaservercode.thesetargets t1tot8 wereselectedonthebasis ofaone weeksamplingofproductioncrashlogs.theyrepresented thetop 8targetsbynpecountinthisdataset excludingonetarget onwhich n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc crashedandanytargetsthatwere alreadyenrolledinnullaway whichmaystillcontainnpesdueto third party libraries .
at the time of our evaluation targets t1 tot8were notalreadyenrolledontonullawayusing n u.sc l.sc l.sca w.sc a.sc y.sc hyphen.sc a n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc we avoided previously enrolled targets so that all experimentscouldberunwithasingletoolversion.seesection .
forfurtherdiscussionregardingreal worldusageof n u.sc l.sc l.sca w.sc a.sc y.sca n.sc hyphen.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc to enroll targets.
table1gives the size and type of each benchmark.
while the open source dataset represents standalone programs and libraries theuberdatasetconsistsofbuildtargets programmodulesbuilt and unit tested independently but which serve as part of one or more production services.table benchmark types and sizes and the error reduction fromnullawayannotator at depths and .
benchmark name klocnumber of errors initial depth0 depth1 depth5open source projectsframework conductor .2k .
.
.
mockito .6k .
.
.
springboot .1k .
.
.
gameengine litiengine .1k .
.
.
libgdx .1k15492314 .
.
.
libraries mpandroid .1k .
.
.
glide .6k .
.
.
eventbus .9k .
.
.
gson .0k .
.
.
eureka .0k .
.
.
retrofit .6k .
.
.
compilertools jadx .8k .
.
.
wala util .5k .
.
.
networklibrary zuul .2k .
.
.
ubert1 .7k .
.
.
t2 .7k1072 .
.
.
t3 .9k .
.
.
t4 .1k .
.
.
t5 .8k .
.
.
t6 .4k .
.
.
t7 .9k .
.
.
t8 .8k .
.
.
usingthesetwodatasets weseektoanswerthefollowingkey researchquestions isn u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc effective inreducing the number ofreportednullawayerrorsfor thesebenchmarks?
how does our technique compare with the strategy of applyingallpossible fixes interms of errorreduction?
what is the impact of the depth limit see section on tool effectiveness in terms of number of errors removed and running time?
how much do our optimizations section reduce running time over unoptimized?
istheoutputof n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc anadequatebasisto enable nullaway checking on previously unannotated code inaproduction setting?
section8.2addresses questions section8.3addresses question andsection .4addresses question .
experiments for open source benchmarks were performed on a desktop with an 11th gen intel r core tm i7 .50ghz corecpuand32gbramrunningubuntu20.
.5lts.experiments atuberwereperformedinsidealinuxcontaineronasharedamd epyc .45ghz machine with cores per socket and sockets reporting gb of ram.
we did not have dedicated access to this machine during our measurements but it usually stayed at low utilization duringexperiments.
1402practical inference of nullability types esec fse december3 san francisco ca usa .
error countreductionanddepthbound we first evaluated the effectiveness of n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc at reducing the number of errors reported by nullaway.
data on this error reduction after running n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc with various depth limits is shown in table with percentage changes inparentheses.theinitialcolumngivesthenumberofnullaway errors before running inference.
we show error reduction with depthlimits and5.recallfromsection 3thatadepthlimitof 0correspondstoeagerlyinsertingallpossiblefixes ignoringthe impact onerrorcount.
eager insertion of all possible fixes depth limit always yields moreremainingerrorsthandepth1 andsometimesyieldsahigher number of errors than were reported on the original code!
e.g.
for libgdx the number of reported nullaway errors increases from 1549to2314 moreerrors atdepth0 andfor mpandroid the number of errors increases by .
these results show that our searchstrategyproducesafinalresultwithmanyfewererrorsthan performingeager nullable insertion.
todeterminetheimpactofthedepthlimit weran n u.sc l.sc l.sca w.sc a.sc y.sc hyphen.sc a n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc withlimitsof1 10acrossallofourbenchmarks.we observedthatthefinalnumberoferrorswasneverreducedfurther going beyond depth .
also the running time at depth was an averageof2.24xthedepth1runningtime areasonablecost.so on ourbenchmarksweconcludedthatdepth5yieldedthebesttradeoff between performance and error reduction and we used that depth limit for allsubsequent experiments.
at depth we saw an average reduction of .
in the number of nullaway errors reported when compared to the initial code ranging from .
for the t4uber target to .
for springboot .
the significant reduction of errors from running n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc has multiple benefits it enables more code to be checked immediately by nullaway via warning suppressions see section .
and it reduces the effort required to eventually enroll allthe code innullawaychecking.
.
impactofoptimizations next we evaluatedtheperformance impactofour graph coloring optimizations section andourresultsappearintable .allconfigurationswererunwithadepthlimitof5andatimeoutof8hours.
we show both the overall running time in minutes and also the numberofnullawaybuildsrunineachconfiguration nearlyallexecution time of n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc is spent running nullaway builds onaverageover97 ofrunningtimeforouropen source benchmarks .
for our benchmarks we observe enormous reductionsinrunningtimeswiththegraphcoloringoptimizationover unoptimized thespeedupsrangefrom2.0x .8x withanaverage of .1x.further for t1and t2 we could not measure the speedup as the unoptimized run could not complete within an hour limit.
weobserveasimilarly largereductioninnumberofbuildsrequired with optimizations enabled showing that a significant numberofthequalifiersevaluatedbyoursearchareinfactindependent.
regardingthenumberofup frontbuildsrequiredforclientcode section5 weobservedanaverageof2.4buildsandamaximumof across our benchmarks small compared to the number of buildstable2 runningtimeandnumberofbuildsforunoptimized andoptimized configurations.
benchmark nametime minutes number of builds unoptimized optimized unoptimized optimizedopen source projectsconductor .
.
.6x .1x mockito .
.
.4x .4x springboot .
.
.8x .6x litiengine .
.
.5x .4x libgdx .
.
.2x .9x mpandroid .
.
.4x .4x glide .
.
.7x .4x eventbus .
.
.0x .0x gson .
.
.1x .7x eureka .
.
.7x .8x retrofit .
.
.0x .8x jadx .
.
.5x .9x wala util .
.
.2x .2x zuul .
.
.0x .6x ubert1 x .
t2 x .
t3 .
.
.1x .4x t4 .
.
.4x .9x t5 .
.
.8x .1x t6 .
.
.5x .1x t7 .
.
.5x .3x t8 .
.
.2x .5x table3 numberofannotationsinjectedby nullawayannotator .
benchmark namedepth5 suppress only nullable suppression unchecked uncheckedopen source projectsconductor .
.
mockito .
.
springboot .
.
litiengine .
.
libgdx .
.
mpandroid .
.
glide .
.
eventbus .
.
gson .
.
eureka .
.
retrofit .
.
jadx .
.
wala util .
.
zuul .
.
ubert1 .
.
t2 .
.
t3 .
.
t4 .
.
t5 .
.
t6 .
.
t7 .
.
t8 .
.
requiredduringsearch.
we concludethat the graph coloringoptimization provides an enormous benefit and is essentialfor making n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc practical for larger programs.
1403esec fse december3 san francisco ca usa nima karimipour justinpham lazaro clapp andmanu sridharan .
tooloutput andreal worldusage here wecharacterizetheinferredannotationsdiscoveredby n u.sc l.sc l.sc hyphen.sc a w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc anddescribeitsreal worldusagethusfar.table givesdataonthefinalsolutionsfoundby n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc forourbenchmarks.fordepth5 weshowthenumberof nullable annotations inferred the number of annotations inserted to suppressremainingwarnings andthepercentageofcodethatremains uncheckedby nullaway dueto thesesuppressions.wealso show thepercentageof uncheckedcodefor abaseline configuration in which all the errors initially reported by nullaway are suppressed without running inference .
due to a tool bug for one benchmark t5 we addedone suppressionannotation manually.
thenumberof nullable annotationsinsertedby n u.sc l.sc l.sca w.sc a.sc y.sca n.sc hyphen.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc is significant up to reflecting the large amount of manualworkotherwiserequiredtoadoptnullaway.aftersuppressionswereinsertedatdepth5 thepercentageofuncheckedcode ranged from .
to .
with an average of .
.
in comparisontothebaselineofsuppressingwithnoinference thepercentage ofuncheckedcode decreasedbyanaveragefactor of2.54x .89x to .05x .
for the one target where the amount of unchecked code increased with inference the uber t8 module the baseline suppresses many uninitialized field warnings at the field declarations whileinferencemakesthefields nullable andaddssuppressions on certain methods using the fields.
even though inference adds many fewer suppressions vs. 362forthe baseline dueto the placement of these suppressions on methods rather than fields the amount of unchecked code becomes higher.
table 1shows that inferencestilldramaticallyreducesthenumberofnullawayerrors for this benchmark.
overall the data show that our inference allows for a much greater amount of existing code to be immediately checked by nullaway yielding greater safety for future code modifications withnomanual effort.
initializers wemanuallyinspectedallinjected initializer annotations and all were correct exceptfor two in libgdx.
for the bad cases the method was in fact a setter not involved in initialization thoughitassignedvaluestomultiplefields.inthefuture webelieve wecanmake initializer inferencemoreaccuratebyleveraging methodnaming patterns e.g.
includingmethods withnames like initwhileexcluding methodswhose names startwith set .
deployment n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc hasbeendeployedatuberfor self serveusebydevelopers.thusfar ithasbeenusedtoenroll160 modulesinnullawaychecking consistingofroughly1.365million lines of java code.
running n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc on production modules led to many bug fixes and improvements in the tool itself e.g.
handling of code generation by annotation processors.
themainlessonfromourexperiencethusfaristhat n u.sc l.sc l.sca w.sc a.sc y.sc hyphen.sc a n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc changes should as much as possible be scoped to a single module and be semantics preserving to avoid long code review cycles see section .
a key issue with extended code review is that the target and client code keeps evolving and keeping the inferred changes consistent with the evolving code requires significant manual effort.
we also used n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc to enable nullaway checkingforthewala utilopen sourcemodule maintainedbyoneof the paper authors.
here we again found n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc ssupport for analyzing client code to be useful as wala util is used by many other modules in the project and we wanted the annotations to capture that usage behavior.
in studying the final output wefoundseveralplaceswhere n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc inferred a nullable annotation for a field or method parameter but the author would have preferred to refactor the code to make that location nonnull.
automatically performing such code refactorings and repairs is out of scope for n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc but is a fruitful avenue for further research.
the nullable annotations discussed above could be considered false positives since they do not match the annotations a developer would have written by hand we expect that similar cases may have occurred in our other benchmarks.
we have found thatinsuchcases introducingthedesireddeveloperannotations usually also requires modifying executable program code.
any change that modifies executable code require much deeper review than thechanges generated by n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc whichare semantics preserving.foreffectivedeployment webelievefuture repair approaches would be best deployed in combination with n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc schangeswould enable immediate nullaway checking with no review required andsubsequentautomatedrepairpatchescouldbereviewedand incorporatedgradually.
.
threatsto validityandlimitations the main threat to the external validity of our evaluation is our choice of benchmarks.
we strove tochoose a diverse set of benchmarksinaprincipledmanner seesection .
.still itispossible thatonlesspopularopen sourcebenchmarks oronbenchmarks using build systems besides gradle n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc will belesseffective.and itispossiblethat n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc is particularly effective for code written in the style used at uber but thatitwillbelesseffectiveforotherproprietarycode.regarding internalvalidity ourresultsmaybeimpactedbyimplementation bugsinn u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc .tocombatthisissue n u.sc l.sc l.sca w.sc a.sc y.sc hyphen.sc a n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc has an extensive suite of unit and integration tests.
further for all benchmarks we verified that the final result of n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc was exactly the same with and without optimizations enabled.
we have also manually vetted the output of n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc onseveral uber targets.
alimitationof n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc isthatitdoesnotsupport inferenceofallannotationssupportedbynullaway.we donotyet support inference of contract requiresnonnull and ensuresnonnullannotations used to express pre and post conditions e.g.
thatsomefieldofaparametermustbe nonnull atmethodentry .
we focused on inference of nullable annotations initially since it providesalargebenefitonitsown butweplantosupportinference ofpre andpost conditionannotationsinthefuture.othernullness checkers support writing type qualifiers on generic type arguments e.g.
list nullable string butnullawaydoesnot.
n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc does not currently support inference of such qualifiers but we are working to extend it with such support.
related work there is a wide and rich literature on classical type inference or typereconstruction whichfocusesondiscovering 1404practical inference of nullability types esec fse december3 san francisco ca usa whetherthereexistsa complete typingforanunannotatedprograminagiventypesystem.ourproblemdiffersfromtheclassical case as we nearly always target programs where no such typing exists andourgoalistofindamaximalsetofusefultypequalifiers for such programs.
as such we focusour related work discussion ontechniquesmorecloselyrelatedtoourtargetscenario anddo not discuss type inference work more broadly.
checkerframeworkinference usesconstraint basedanalysis toinfertypes andtheapproachhasbeenappliedsuccessfullyto atypesystemsformeasurementunits .thisapproachsolves the constraints using maxsat which could be adapted to output a partialtypingfortheprogramwhentheconstraintsareunsatisfiable.previousapproachestoimprovederrorexplanationfortype inference andmigrationofdynamically typedprograms tousegradualtypes arealsobasedonconstraints and couldbesimilarlyadapted.however asnotedinsection werequire reuse of an existing checker implementation for ourscenario andcannotre implement the checker using constraints.
the checker framework includes whole program inference wpi functionality that works with unmodified pluggable typesystemimplementations.thetechniqueworksbyinserting the most specific type qualifier compatible with all expressions written into an entity a field parameter or return value running toafixedpoint.wpiisintegratedintothecheckerframework and hencecaninfermanyannotationsfromasinglerun.ourtechnique treatsthecheckerasablackbox necessitatingtheoptimizations of section 4for better performance.
our less coupled approach makes it potentially easier to combine our technique with other checkerimplementations andweplantoexploreintegrationswith thecheckerframework.wpiis notguidedbyminimizingthefinal number of errors reported its strategy resembles that of our eagerinsertionofqualifiers whichsection 8showed can increase the final number of errors.
also our technique aims to generate annotations a developerwould accept into their source code.
wpi may generate many annotations unrelated to any reported error which developers are unlikely to incorporate to minimize clutter .
thedaikondynamicinvariantdetector caninfer nullable annotations from dynamic behaviors .
this approach infers a nullable qualifieronlyforlocationsobservedtobe nullatruntime aguaranteethatanystaticapproachcannotprovide.aswithany dynamic approach it requires that the target code to be executable bythetoolandthatsomesetofsuitableinputsisavailable.static approacheslikeoursarecomplementary astheyneednotbeableto executetheprogramandcanaccountforallpossiblecodebehaviors.
cascade isaninteractivetypequalifierinferencetoolthat involvesprogrammersintheinferenceprocess.cascadealsotargets programswherecodechangesarelikelytoberequiredtomakethe code type check.
n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc aims to automate more of thequalifier inferenceprocess than cascade.
the twoapproaches arecomplementary afteradoptingtheinitialannotationsproposed byn u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc a developer could use a cascade like toolto aid ingradually fixing the remaining errors.
recent workhas appliedmodernmachinelearningtechniques totypeinference andtoprogramrepairwhosefixesmay include type qualifier insertion .we have not yetpursued such techniques due to the amount of training data required we are notawareofapublicly availabledatasetshowinghow nullablequalifiers are inserted to address type errors.
in the future we plan to investigate generation of training data to further enable a learning basedapproach.notethattypewriter alsousesblackbox executions of an extant type checker to evaluate candidate types we believe our graph coloring optimization could be used to reducethenumberoftypecheckerrunsrequiredbytheirtechnique.
conclusions wehavepresentedanovelapproachtoinferenceofnullabilityqualifiers for java programs to enable applying nullness type checkers to extant code bases.
in contrast to many other techniques our approach treats the type checker as a black box oracle and does not require re implementation of its logic.
we defined an effective search strategy for discovering a good set of qualifiers to insert andpresentedoptimizationstodramaticallyspeedupthesearch.
we implemented our approach in an open source tool n u.sc l.sc l.sca w.sc a.sc y.sc hyphen.sc a n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc and evaluated it on both open source and commercial code bases.
our evaluation showed that n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc scaled well and that the inferred annotations significantly reduced the number of errors reported enabling nullaway checking for more existing code.
n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc has already been used to enable nullaway checking for production modules at uber.
in future work we planto generalize our approach to other static type andtype qualifier systems.
data availability n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc is open source and available at https github.com ucr riple nullawayannotator .further wehavemade an artifact available at containingthecodefor n u.sc l.sc l.sca w.sc a.sc y.sca n.sc n.sc o.sc t.sc a.sc t.sc o.sc r.sc andscriptstorunitonour open sourcebenchmarks.