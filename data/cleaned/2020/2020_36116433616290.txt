engineering a formallyverified automatedbugfinder arthur correnson dominicsteinh fel arthur.correnson cispa.de dominic.steinhoefel cispa.de cispa helmholtz center forinformationsecurity saarbr cken germany abstract symbolic execution is a program analysis technique executing programs with symbolic instead of concrete inputs.
this principle allows for exploring many program paths at once.
despite its wide adoption inparticularforprogram testing littleeffortwasdedicated to studying the semantic foundations of symbolic execution.
without these foundations critical questions regarding the correctness of symbolic executors cannot be satisfyingly answered canareportedbugbereproduced orisita falsepositive soundness ?
can we be sure to find all bugsif we let the testing tool run long enough completeness ?
this paper presents a systematic approachforengineeringprovablysoundandcompletesymbolic execution based bug finders by relating a programming language s operational semantics with a symbolic semantics.
in contrast to priorworkonsymbolicexecutionsemantics weaddressthecorrectness of critical implementation details of symbolic bug finders includingthesearchstrategyandtheroleofconstraintsolversto prune the search space.
we showcase our approach by implementing wise a prototype of a verified bug finder for an imperative language in the coq proof assistant and proving it sound and complete.wedemonstratethatthedesignprinciplesofwisesurvive outsidetheecosystemofinteractiveproofassistantsby automaticallyextractinganocamlimplementationand transforming wisetopywise afunctionally equivalentpython version.
ccsconcepts theory of computation program verification operational semantics higherorderlogic automatedreasoning softwareand its engineering semantics software testing and debugging formalsoftwareverification softwareverification automated staticanalysis .
keywords symbolic execution testing program verification symbolic semantics proofassistants acm reference format arthurcorrensonanddominicsteinh fel.
.engineeringaformally verifiedautomatedbugfinder.in proceedingsofthe31stacmjointeuropean esec fse december san francisco ca usa copyright heldby theowner author s .
acm isbn .
engineering conference and symposium on the foundations of softwareengineering esec fse december3 sanfrancisco ca usa.
acm newyork ny usa 12pages.
introduction itisnowtwodecades sinceitwas pointed out thatprogram testing may convincingly demonstratethe presenceofbugs butcan neverdemonstratetheirabsence.
afterquoting this well publicized remark devoutly the software engineer returns to the order ofthe day andcontinues torefinehistesting strategies justlikethe alchemistofyore whocontinued to refinehischrysocosmic purifications.
e.w.dijkstra a bridge that works fine for a year but collapses during a windy day is considered a failure.
a program that works fine for a year but crashes for a certain input is considered buggy.
this ridiculous analogy reflects the reality of software engineering while civil engineers carefully identify loads and associated stresses on the structures they build and create their designs accordingly preventing tragic crashes upfront bugs in software are most frequently reportedby usersonlyafterdeployment .however software engineers are in a fortunate position they can stress test the final productbefore it is shipped to users.
this becomes an opportunityonlyifprogrammerspossessadequateverificationtools.the predominant verification discipline today is testing which aims tofindbugsthatare actionable inthesensethatrunningtheprogramundertestwithan inputprovidedbythetestingtoolresults inanerrorstate.forexample evolutionarygrayboxfuzzers such asafl mutate inputsfrom an initialpopulationand add mutants covering new parts in the program.
while modern fuzzers workexceptionallywellinmanycases theeffectivenessofevolutionary fuzzersstronglydepends onthe quality of theinitialseed inputs .
furthermore they struggle tocovercode guardedwith complex constraints.
considerthe python program ifx hash y z fail findingatripleofvaluessatisfyingthe ifconditionrandomlyor bymutatingpreviousinputsisextremelydifficult.indeed bundt et al.
demonstrated that graybox fuzzers are mostly useless for certain bugs.
however they state that integrating symbolic execution with graybox fuzzers to so called hybrid fuzzers ishighly effective aresult alsoconfirmedbyotherstudies e.g.
.
symbolic execution se builds on the principle of declaring some or all inputs to a program to be symbolic.
while concrete execution maintains states mapping variables to values seuses symbolicstates consistingofa pathcondition andasymbolicstore.
this work is licensed under a creative commons attributionnoncommercial sharealike .
internationallicense.
esec fse december3 san francisco ca usa arthur corrensonanddominic steinh fel atbranchingpoints such as the ifstatement fromabove segeneratesmultiplesuccessorstatesdistinguishedbydifferentconstraints added to their path condition.
as usual assignments update the symbolic store which can map to symbolic values.
sewas conceived almost simultaneously as a bug finding and program proving technique and is still actively used in both areas.
it is more popular in testing though due to its precise nature under idealassumptions seyieldsnofalsepositivesandcanbeusedin automated testing campaigns on the other hand program proving withserequires expensive auxiliary specifications .
so whatarethese idealassumptions?
first seisawhitebox technique itrequires accessto the sourcecode ofthe testedprogram interpreting its structure to drive the search for bugs.
while thispermitsbetterresults implementingasymbolicexecutorrequires a precise understanding of the semantics of the targeted language.forexample asymbolicexecutorforpythonprograms mustrespectpython sinteger floordivision semantics thedivision expression x ycorresponds to floor x y where is division on reals.
other interpretations can result in false positives spuriousbugs or false negative missedbugs .
in the program ifx y fail a wrong interpretation of integer division might lead a symbolic bug finder to believe that u1d465 u1d466.alt 2triggersfail .
however in python the result of is while in other languages such as java itevaluates to .
second sediscardsunreachableerroneousstatesbychecking whether their path conditions are satisfiable.
in our examples from above it must decide if x hash y z or x y are consistent with the previously collected constraints.
to that end theseengines use constraint solvers to determine whether a set of constraints is satisfiable sat or unsatisfiable unsat .
however insteadofreturning satorunsat solversfrequently timeoutprovidingnoanswers inthatcase blindlyreportingabug could result ina false positive.
consequently an seengineismoredifficulttoimplementcorrectlythanafuzzer.whilethesemanticsandcorrectnessof sehave beenstudiedindifferentcontexts thecorrectness of symbolic bug finders remains an open research topic.
in particular toourknowledge thereexistsnorigorousdefinitionofwhat constitutes atrustworthysymbolic bugfinder.
themaincorrectnesscriterionfortestingtoolsisthe soundness ofbugs ifthetoolanswers isthereabuginmyprogram?
with yes there must exist a bug witness an actionable input .
we call thispropertysoundnessfortesting t soundness .fuzztesters short fuzzers generateinputsthattheyfeedtotheprogramundertest and report a bug if the program crashes.
such tools are t sound by construction.however t soundnessaloneisaninsufficientquality measureforbugfinders.indeed atesterneverreporting anybugis triviallyt sound.thus the converseofsoundnessisanadditionally desirableproperty ifabugwitnessexists atestershouldeventually answerthequestion isthereabuginmyprogram?
withyes.this property whichwenamecompletenessfortesting t completeness is generally out of reach for fuzzers.
the best option is to estimate theresidual risk that an ongoing fuzzing campaign would discover an errorif itonly ranfor abit longer .contrary building a t sound and t complete symbolic executor ispossible.inthispaper weproposeageneralapproachtobuilding provably sound and complete bug finders based on symbolic execution.weimplementedaprototypicalbugfinderbasedonthis approachinthecoqproofassistanttogetherwithanend to end proofofitscorrectness.tothebestofourknowledge oursisthe first endeavor to explicitly specify the meaning of correctness in the contextofsymbolicbugfinders inaproofassistantandtouse formal verificationtechniques to prove the correctness of abugfinder.
research questions.
precisely we answer the following main questions whatconstitutesareliabletestingtool?
and how can we engineer such a tool?
these questions cannot be answered experimentally.
followingtheterminologyofshaw theybelongtothecategories methodforevaluation question and method means of development question of software engineering research questions.
our answer to question is the precise definition of t soundness and t completeness.
addressing question we explain the characteristics of a t sound and tcomplete bug finder and expound a methodology to implement suchatool.followingthismethodology weimplementedse based testingtoolsincoqandpython.forthecoqprototype wederived aformal mechanizedcorrectness proof.
relatedwork.
kapusandcadar combinecompilertesting techniques and different oracles to test three symbolic bug finders.
they reported distinct bugs exposing a variety of important errors e.g.
relatedtodivision.thisistheonlyworkonthecorrectnessof symbolic bugfinders question weareawareof.
otherworkmainlystudieshow secanbeappliedforautomated testing.
the strongest oracle used by kapus and cadar the output oracle comparestheresultsofaconcreteexecutionandasymbolic onefollowingthesamepath.thisoracleonlyworksiftheinitial path condition uniquely describes the inputs used for concrete execution but is at the same time obfuscated to prevent the executorfromdroppingto concretemode.
whentesting seengines with less constrained inputs such that multiple paths are explored kapusandcadarusecoarseroracles.incontrast wedevelopeda verifiedsymbolic bug finder based on carefully designed semantic foundationsinresponsetoquestion .likely kapusandcadar wouldhavefoundmorebugswheninvestingevenmoreworkon testcasesandoracles ourbugfinderisguaranteedtobebug free.
informalprogramverification itismuchmorecommontoaddress the soundness of verification tools and their underlying theoreticalunderpinnings.thegoalofformalverificationisnottoshow the presence but prove the absence of bugs.
consequently the main correctness criterion is the soundness of proofs p soundness if a verifier answers is my program safe to execute?
withyes then there existsaproofoftheprogram scorrectness.aswitht completeness p completenessistheconverseofp soundness.sincecheckinga complexprogramproofisarguablymorecomplexthenchecking whether an input causes a bug the formal verification community put significant effort into justifying their tools and foundations.
for example abstract interpretation ai is a mathematical framework for designing and implementing correct static analysis.
following the aiframework jourdan et al.
proved the soundness of an abstract interpreter for c programs in the coq proof assistant.
this project is strongly related to the development 1166engineeringaformallyverifiedautomatedbugfinder esec fse december3 san francisco ca usa of compcert a c compiler also proven correct in coq.
coq itselfisbasedonanestablishedmetalogic itskernelwasproven correct .
closingthecircletosymbolicexecution therehavebeenvarious effortstoshow p soundness ofse basedverifiers .furthermore the semantics of sewas addressed in the past in a more general context.
the symbolic semantics used in this paperisinspiredbythesemanticsproposedbydeboerandbonsangue .buildingonthesefoundations wedefinesoundness andcompletenessinthecontextofsymbolicbugfindingandprovideaformally verifiedimplementation.
contributions.
followingthecompcertapproach tobuild verifiedprogramanalyzersinaproofassistant wedevelopaprototypeofaformallyverifiedsymbolicbugfinderincoq.weformalize the concrete operational semantics of a small imperative programminglanguageandderiveasymbolicoperationalsemanticsinspired bydeboerandbonsangue sect.
.then weextensivelyexplore the relations between concrete and symbolic semantics by proving that seis a sound and complete method for reachability analysisandvariousbug findingtasks sect.
.buildingonthese theoreticalresults wederiveat soundandt completesymbolic bugfinder sect.
.inthecourseofthis weformallyaddressseveral practical questions such as path selection andsearch space pruningusingconstraintsolversandtheirinfluenceon exhaustiveness i.e.
t completeness and precision i.e.
t soundness of se.
all implementations definitions theorems and proofs in this paper are realized in coq.
thus if our specifications convince you you canblindlytrusttheproofs.
wecallourprototypicalsymbolicbug finderwise whatissymbolicexecution .todemonstratethe practicability of our seengine s design principles we extract an executable ocaml implementation fully automatically from the coq code and manually transform wise to pywise a wise implementation written in python sect.
.
both extracted bug finders can be invoked on the command line.
to provide hands on evidencethatwiseworks additionallytoourformalproofs we apply itto find bugsinsertedintonumeric algorithms.
concreteand symbolic semantics we study symbolic execution along the example of imp a small imperative programming language with loops and integer arithmetic.
in this section we introduce the imp language sect.
.
and describe its operational semantics sect.
.
.
afterward we equipimpwithasymbolicoperationalsemanticsfollowingdeboer and bonsangue sect.
.
.
the symbolic semantics will be the formalbasisto justify the correctness ofour seengine.
notation.
weusethefollowingnotationalconventionstoclarify the domainsofidentifiers inour formalizations.
u1d45d u1d45e ... forprograms u1d449forconcreteenvironments u1d446forsymbolicstores u1d711forpath conditions orltlformulas u1d70eforconcretestates u1d449 u1d45d u1d70eforsymbolicstates u1d711 u1d446 u1d45d u1d6fcforstreams e.g.
ofsymbolic states statements stmt colonequalskip fail var aexpr stmt stmt whilebexprdostmtod ifbexprthenstmtelsestmtfi expressions bexpr colonequaltrue false bexpr and or bexpr notbexpr aexpr aexpr aexpr colonequalint var aexpr aexpr figure syntax ofimp .1a small imperative programming language imp is an imperative programming language with assignments whileloops andconditionals.figure 1containsagrammarofimp s concrete syntax vardenotes a variable identifier and intan integer.
we integrate a failstatement signaling an error.
using fail one can instrument source code to e.g.
mark supposedly unreachablesectionsormodelrun timeassertions.impdoesnotnatively support multiplication and division these operators can be implementedinterms ofadditionandsubtraction.
u1d449 u1d465 u1d452 u1d449 skip u1d44f u1d449 true u1d449 if u1d44fthen u1d4601else u1d4602fi u1d449 u1d4601 u1d44f u1d449 false u1d449 if u1d44fthen u1d4601else u1d4602fi u1d449 u1d4602 u1d4491 u1d4601 u1d4492 u1d4602 u1d4491 u1d4601 u1d4603 u1d4492 u1d4602 u1d4603 u1d449 skip u1d460 u1d449 u1d460 u1d44f u1d449 true u1d449 while u1d44fdo u1d460od u1d449 u1d460 while u1d44fdo u1d460od u1d44f u1d449 false u1d449 while u1d44fdo u1d460od u1d449 skip u1d465 u1d449 u1d449 u1d465 u1d465 vars true u1d449 true false u1d449 false u1d4521 u1d4522 u1d449 u1d4521 u1d449 u1d4522 u1d449 u1d44f1and u1d44f2 u1d449 u1d44f1 u1d449 u1d44f2 u1d449 ... figure operational semantics ofimp 1167esec fse december3 san francisco ca usa arthur corrensonanddominic steinh fel u1d711 u1d446 u1d465 u1d452 sym u1d711 u1d446 skip u1d711 u1d446 if u1d44fthen u1d4601else u1d4602fi sym u1d711and u1d44f u1d446 u1d446 u1d4601 u1d711 u1d446 if u1d44fthen u1d4601else u1d4602fi sym u1d711and not u1d44f u1d446 u1d446 u1d4602 u1d7111 u1d4461 u1d4601 u1d7112 u1d4462 u1d4602 u1d7111 u1d4461 u1d4601 u1d4603 sym u1d7112 u1d4462 u1d4602 u1d4603 u1d711 u1d446 skip u1d460 sym u1d711 u1d446 u1d460 u1d711 u1d446 while u1d44fdo u1d460od sym u1d711and u1d44f u1d446 u1d446 u1d460 while u1d44fdo u1d460od u1d711 u1d446 while u1d44fdo u1d460od sym u1d711and not u1d44f u1d446 u1d446 skip figure symbolicsemantics ofimp .
concrete operational semantics imp programs are executed in an environment u1d449 vars zrepresenting the values assigned to each program variable.
execution states are pairs u1d449 u1d45d of an environment and a program that remainstobeexecuted.thesmall stepoperationalsemanticsforimp is a relation between execution states.
we use the notation u1d449 u1d45d u1d449 u1d45d to state that executing program u1d45din environment u1d449foronestepproducesanewenvironment u1d449 togetherwith a program u1d45d that remains to be executed.
the relation is thereflexive transitiveclosureof .
weusethenotation u1d452 u1d449 to denote the value of the expression u1d452in environment u1d449.
the operationalsemantics ispresentedinfig.
.
.
symbolic operational semantics informally a program is symbolically executedby using symbolic placeholdersinsteadofconcretevaluesasinputs.whenastatement with different possible outcomes is reached in imp this can be anifstatement or a loop bothpossibilities are independently exploredin differentexecution branches.
symbolic execution thus producesina treerepresentingallpossibleexecutionpaths.each treenodeislabeledwithaformula calledthe pathcondition which characterizes the condition on the program inputs that needs to be metfor the program to reachthe associatedstate.
more formally we regard seas a type of program execution respecting a symbolic operational semantics sym .
inse symbolic stores u1d446 vars exprtake the role of environments.
contrarytothelatter symbolicstoresmapvariablestosymbolic expressionsandnotnumericvalues.thedualtoconcreteexecution statesare symbolicstates triples u1d711 u1d446 u1d45d ofaformula u1d711 thepath condition asymbolicstore u1d446 and aprogram tobeexecuted u1d45d the program counter .
we extend the concrete evaluation of an expression u1d452inastore u1d449toasymbolicevaluation u1d452 u1d446.theresultof u1d452 u1d446 is again a symbolic expression obtained by replacing variables in u1d452 withtheirassociatedexpressionsin u1d446 if any.
thesymbolicexecutionofaprogram u1d45dusuallystartsintheinitial state true u1d456 u1d451 u1d45d where u1d456 u1d451 u1d465 u1d465is an empty symbolic store assigningtoeachprogramvariableasymbolofthesamename.the initial path condition trueindicates that we make no assumptionsabouttheprograminputs.wewrite true u1d456 u1d451 u1d45d sym u1d711 u1d446 u1d45d to denotethatthesymbolicstate u1d711 u1d446 u1d45d canbereachedbysymbolic execution of u1d45d.
figure4shows a symbolic execution tree for the executionofaconditional statementinthe defaultinitialstate.
true u1d465 u1d465 ifx 0thenfailelse x x 1fi x u1d465 u1d465 fail x u1d465 u1d465 x x x u1d465 u1d465 skip sym sym sym figure example symbolicexecution tree finding bugssymbolically asymbolicexecutor simulates manyconcrete executionsofa program simultaneously.
from this we can obtain a bug finder by reportinganerrorwheneveronesimulatedexecutionreachesanerrorstate.everyreportedbugmustcomewithan witness.infuzzing this is a bug triggering input in the case of se it is frequently a more abstract witness in theform of a boolean formula describing allinputs triggering the bug.
additionally we would like to ensure that any bug in the program will eventually be detected during se.
inthissection formallyconnectbugfindingandsymbolicexecution.in particular weliftthesymbolicsemanticsfromsect.
.3to asound andcomplete methodto find bugs.
.
sound complete reachability our first step toward a symbolic bug finder is to connect symbolic and concrete executions.
the glue we use to establish this connection isreachability.
a correct symbolic executor should onlyreach symbolic states representing reachable concrete states.
conversely we would like it toreach anyreachable concretestate intheform ofasymbolic state representing it.
we write reach u1d45d u1d70e andreachsym u1d45d u1d70e to express that concrete state u1d70ecan be reached by concrete and symbolic execution oftheprogram u1d45d.then weexpresssoundnessandcompleteness concerning reachabilityas asimpleequivalence theorem .
soundness and completeness for reachability .
reachsym u1d45d u1d70e reach u1d45d u1d70e reach u1d45d u1d70e canbeexpressedusingtheconcreteoperationalsemantics.
a state u1d70eis reachable for a program u1d45dif executing u1d45din someinitialstore u1d4490eventually leads to u1d70e.
definition .
concrete reachability .
reach u1d45d u1d70e u1d4490 u1d4490 u1d45d u1d70e symbolic states reached during serepresent manyconcrete states.
to make reachsym u1d45d u1d70e precise we relate them to their concretizations.
theconcretizationoperation turns asymbolic store u1d446intoaconcretestore u1d449 u1d449 u1d446byreplacingallfreevariables in u1d446bytheirassociatedvaluesin u1d449.forexample if u1d446 u1d465 u1d466.alt u1d466.alt u1d466.alt and u1d449 u1d465 u1d466.alt we obtain u1d449 u1d465 u1d466.alt .
definition .
.
u1d449 u1d446 u1d465 u1d446 u1d465 u1d449 1168engineeringaformallyverifiedautomatedbugfinder esec fse december3 san francisco ca usa we lift the storeconcretization to the concretization of symbolicstates.toexpressthatasymbolicstate u1d70erepresentsaconcrete state u1d70evia an initial store u1d4490 we write u1d70e u1d4490 u1d70e.
any concretization u1d70eof u1d70emust have the same program counter as u1d70e.
furthermore theinitialstore u1d4490mustsatisfythe path condition of u1d70e.finally u1d70e s environment mustbe aconcretizationof u1d70e sstore via u1d4490.
definition .
.
u1d449 u1d45d u1d4490 u1d711 u1d446 u1d45d u1d45d u1d45d u1d449 u1d4490 u1d446 u1d711 u1d4490 true now allconcretizations of reachable symbolic states are symbolically reachable.formally definition .
.
reachsym u1d45d u1d70e u1d4490 u1d70e true u1d456 u1d451 u1d45d sym u1d70e u1d70e u1d4490 u1d70e intheremainderofthissection we describetheproofsofboth directionsoftheorem2.1fortheinterestedreader.followingthe proofs sect.
.2addresses the detection of bugs which involves makingprecise what constitutes an errorstate.
proofofsoundness subsequently we derive the proof of sound reachability i.e.
that all states reachable by seare also reachable by concretely executingaprogram.thisproofrequiressomeintermediatelemmas.
lemma2.1is a compositionality result on the interplay of concretizationandsymbolic store updates.
lemma2.
.
u1d449 u1d446 u1d449 u1d446 proof.by structuralinduction on u1d452.
duringse pathconditionsgetonlyever morespecific byaccumulatingadditionconstraints.thisisassertedinlemma .
.we note u1d711 u1d711 u1d449 u1d711 u1d449 true u1d711 u1d449 true.
lemma2.
.
u1d711 u1d446 u1d45d sym u1d711 u1d446 u1d45d u1d711 u1d711 proof.by induction on the length of the symderivation and by induction onthe last symstep.
whenever the path condition after a symbolic step is satisfiable we can make acorresponding concrete step.
lemma2.
.
u1d711 u1d446 u1d45d sym u1d711 u1d446 u1d45d u1d449 u1d711 u1d449 u1d446 u1d45d u1d449 u1d446 u1d45d proof.by inductionover thesymbolicderivation andbycomposition .
inthe caseofvariable assignments u1d465 u1d452.
weextendlemma .3tothetransitivereflexiveclosurebyapplyingmonotonicity lemma .
.
lemma2.
.
u1d711 u1d446 u1d45d sym u1d711 u1d446 u1d45d u1d449 u1d711 u1d449 u1d446 u1d45d u1d449 u1d446 u1d45d proof.by iterating lemma .3andbylemma .
.
soundreachabilityfollowsfrom the more general lemma .
.
theorem .
soundreachability .
reachsym u1d45d u1d70e reach u1d45d u1d70e proof.byimmediateapplicationoflemma .4andthefactthat u1d4490 u1d45d u1d4490 true u1d456 u1d451 u1d45d .
proofofcompleteness weaddresstheconversedirection allconcretelyreachablestates are symbolically reachable.
the idea is to show that for any executionstepthatcanbetakenaccordingtotheconcretesemantics there existsasymbolic step to simulate it.
lemma2.
.
u1d70e u1d4490 u1d70e u1d70e u1d70e u1d70e u1d70e sym u1d70e u1d70e u1d4490 u1d70e proof.by induction on the derivation u1d70e u1d70e and selecting the appropriate symbolic rulefor eachcase.
we extend lemma .5to the reflexive transitive closure.
lemma2.
.
u1d70e u1d4490 u1d70e u1d70e u1d70e u1d70e u1d70e sym u1d70e u1d70e u1d4490 u1d70e proof.by iterating lemma .
.
the completeness of reachsymfollows directly from lemma .
.
theorem .
complete reachability .
reach u1d45d u1d70e reachsym u1d45d u1d70e proof.it is easy to see that u1d4490 u1d45d u1d4490 true u1d456 u1d451 u1d45d .
the result immediately followsfrom this observationandlemma .
.
.
sound complete bug finding in the previous section we proved that the states reachable by se are the same as those reachable by concrete execution.
building on that weestablishthat secanalsobeusedasasoundandcomplete bug finding method.
first however we must address the question what does it mean to find bugs?
we present different views on this questionandprove that seanswers eachcase.
detectingbuggyprograms.
anaturalviewonbugfindingisto ask and answer the question does my program contain a bug?
weintroducearelation hasbug u1d45d characterizingbuggyprograms.
this predicate is central to our definition of t soundness and tcompleteness sect.
.
.
astate u1d70e u1d449 u1d45d has a bug if u1d45dis stuck i.e.
has no semantic successor state.
however in the case of imp this would also hold if u1d45dwasskip although we were morethinkingof fail.weexplicitlyexcludethe skipcaseinthe followingdefinitionsof notstuck i.e.
canprogress and stuck.
definition .
progress .
progress u1d449 u1d45d u1d45d skip u1d70e u1d449 u1d45d u1d70e definition .
stuckstates .
stuck u1d70e progress u1d70e a buggy program has areachable stuckstate.
definition .
havinga bug .
hasbug u1d45d u1d70e reach u1d45d u1d70e stuck u1d70e as the question does my program contain a bug?
can be reduced to reachability we can answer itsymbolically.
1169esec fse december3 san francisco ca usa arthur corrensonanddominic steinh fel definition .
.
hasbugsym u1d45d u1d70e reachsym u1d45d u1d70e stuck u1d70e theequivalenceof hasbugsymandhasbugfollowsimmediately from the equivalence of reachsymandreach.
theorem .
soundandcomplete bugdetection .
hasbugsym u1d45d hasbug u1d45d proof.by soundness of reachsymin the direction and by completenessof reachsyminthe direction.
finding erroneous execution states.
hasbug u1d45d asserts that some bugexists.alternatively wecanspecificallyaskwhethera given stateiserroneousandwhether secanfindit.thepredicate isbug u1d45d u1d70e asserts that u1d70eis an error state of u1d45d.
in sect.
.
we derive a refined relative versionoft soundnessandt completenessfornonterminating symbolic executors using isbug u1d45d u1d70e .
definition .
.
isbug u1d45d u1d70e reach u1d45d u1d70e stuck u1d70e similarlytoabove wederivea symbolicpredicate isbugsym u1d45d u1d70e .
theorem .
soundandcomplete bugdetection .
isbugsym u1d45d u1d70e isbug u1d45d u1d70e findingerroneousinputs.
ourfinalviewistoaskfor bad i.e.
bug triggering inputs.
the predicate badinput u1d45d u1d4490 characterizes those where the environment u1d4490represents an input definition .
.
badinput u1d45d u1d4490 u1d70e u1d4490 u1d45d u1d70e stuck u1d70e the symbolic equivalent is more subtle since symranges over symbolic states.
we must concretize the reached symbolic state before checking whether itdenotesabug.
definition .
.
badinputsym u1d45d u1d4490 u1d70e u1d70e true u1d446 u1d45d sym u1d70e u1d70e u1d4490 u1d70e stuck u1d70e the equivalence of badinputsymandbadinput follows fromthe definition of reachsymand the proof of theorem .2and theorem2.
.
theorem .
soundandcomplete bugdetection .
badinputssym u1d45d u1d4490 badinputs u1d45d u1d4490 this view bridges the gap between seand fuzzing what is neededtoreporta bug triggeringinput is abug oracle asymbolic equivalent of stuck u1d70e and a constraint solver extracting a solution u1d4490from a path constraint.
subsequently we describe how tobuildatestingtoolbasedonourinsightson se includingabrief discussion of crash oracles.
constraint solving is not in our scope.
a trustworthysymbolic bug finder section2demonstratedthefeasibilityoffindingbugswith sebased onthesymbolicoperationalsemantics.now weturntheseinsights into an executable correct symbolic bug finder.
first we discuss howtodetecterrors resolvethenondeterminismofthesymbolic semantics anddealwithdivergingexecutions sect.
.
.second we provide relevant implementation details of our wise prototype sect.
.
.
third we introduce relative notions of soundness and completenessandrelatethemtothesymbolicexecutor sect.
.
and bug finder sect.
.
.
finally we bridge the already tiny gap towardat soundandt complete bugfinder sect.
.
.
.
from thesymbolic semantics to an executable symbolic executor oursymbolicoperationalsemanticsisasolidbasisforsymbolicbug finding.yet itsdesignleavessomecrucialquestionsopenthatneed tobeaddressedwhendevelopinganexecutable se basedtesting tool.
these are the symbolic semantics is nondeterministic .
wheneveran iforwhilestatementisreached secanchoosewhich branchtoexecutenext.
weneedaneffectivewaytodetecterror states.
the previously regarded predicates hasbugsym isbugsym andbadinputsymare adequate formalizations for bug detection but are not executable because they live on the semantic level.
finally the symbolic semantics does not terminate for programs with loops whichwecannotsolveingeneral butmustfacenonetheless.
hasbugsym u1d45d u1d70e reachsym u1d45d u1d70e stuck u1d70e u1d70e u1d4490 u1d70e true u1d456 u1d451 u1d45d sym u1d70e u1d70e u1d4490 u1d70e stuck u1d70e u1d4490 u1d711 u1d446 u1d45e true u1d456 u1d451 u1d45d sym u1d711 u1d446 u1d45e u1d711 u1d4490 true stuck u1d4490 u1d446 u1d45e u1d711 u1d446 u1d45e true u1d456 u1d451 u1d45d sym u1d711 u1d446 u1d45e u1d4490 u1d711 u1d4490 true stuck u1d4490 u1d446 u1d45e figure5 decompositionofsymbolicbugfindingintochecks for reachability satisfiability and stuckness.
resolving nondeterminism.
while in theory we could spawn independent processes whenever seperforms a case distinction whenfacingan iforwhilestatement thiscannotcontinueforever.
thenumberofbranchesinasymbolicexecutiontreeisexponential inthenumberofsuchbranchingpoints eventually wewill have todecide which branches to follow first.
this process is known aspathselection inse .usually pathselectionisregardedasa heuristics merelyanartifactofefficiencyconsiderations.however theexplorationorderhassolidconsequencesonthe t completeness of the resulting bug finder.
early dynamic symbolic executors such as dart explored programs using a depth first search dfs .
thisapproachis incomplete ingeneral suchexecutorslikelyget lostineverdeeperiterationsofloopsatthebeginningofaprogram neglecting any states that follow.
instead we choose a breadthfirstsearch bfs approach.insect.
.
weprovethecompleteness of bfs based path selection which requires estimating where a successor state isaddedinthe stream of states to explore.
1170engineeringaformallyverifiedautomatedbugfinder esec fse december3 san francisco ca usa detecting errors.
any bug finder depends on a bug oracle to determine when a program state constitutes a bug.
predicates such ashasbugsymarenon executable semanticnotions.moreover they aredefinedusingsymbolicreachability whichrequireschecking if a path condition is satisfiable see fig.
.
fuzzers commonly classifyprogram runs as erroneous if theyend witha crashofthe program.
we use a similar approach we classify a program as buggy or crashing if it is stuck.in our case it can be shown that a state is stuck if and only the next statement to be executed is fail.thissimplesolutionisalreadyquitepowerful.forexample toextendimpwithfailing expressions onecanuse failtomodel theexceptionalcases.considerintegerdivision foranyexpression x y weaddaprecedingstatement ify 0then fail else d div x y replacing x ywith the fresh variable d. the functiondivwouldimplementdivisionusingrepeatedsubtraction assuming thatyisnonzero.
addressingtermination.
asamethodsimulatingconcreteexecutions sedoesnotterminateformostloopingorrecursiveprograms.
derivationsinoursymbolicsemantics areinfinitefor any program with a loop.
in sect.
.
we integrate pruning of unsatisfiable states which solves that issue for loops with concrete or unsatisfiableguards.evenso loopswithunderconstrainedsymbolic guardsinducean infinite amount ofreachable successor states.
there are two main options for dealing with nontermination in se.
the first option is to impose an upper bound on the number of timesaloopisunwound.thisapproachhastheadvantagethatitis easytoimplement.however itpreventsusfromreasoningabout thet completeness of a symbolic executor since the chosen bound mightbetoosmalltodetectsufficientlydeepbugs.theapproachwe choseinsteadis toimplementthesymbolic executoras agenerator of aninfinite stream of states.
a user of a stream based executor can only ever inspect finitely many states from the stream which correspondstoboundedexecution yet we canobtainacompleteness result.ourocamlandpythonimplementations sect.
retrieve elements from the stream upto auser specifiedbound.
thus we view automated bug finders as producers of lazily evaluated infinite sequences of status messages reporting on the progress of the bug finding process.
there are various ways of implementing infinite streams depending on the capabilities of the programming languagea symbolicexecutor is implemented in.
in proofsystemsbasedonpurelyfunctionallanguagessuchascoq infinitesequencescanbemodeledby co induction .inlanguageswithlazyevaluationsuchashaskell suchinfinitesequences canbeimplementedusingstandard lists.inthecaseofeagerlyevaluated functional languages such as ocaml the implementation can resort to explicit suspensions .
otherwise we can model streams withgenerators la python.
in sect.
.
we show that the stream based approach permits elegant specifications ofcorrectness basedontemporal logic.
.
functionalimplementation after many dry discussions we provide some implementation details of our proven correct symbolic executor.
as discussed in sect.
.
theexecutorusesabreadth firstgoalselectionandproducesa lazy infinitestreamofstatusmessages.weuseanocamlflavoredsyntaxinallcodesnippets wefounditeasytotranslateletrun u1d459 match u1d459with yield none run u1d711 u1d446 u1d45d u1d459 yield u1d711 u1d446 u1d45d run u1d459 expand u1d711 u1d446 u1d45d figure main entry pointofthe symbolicexecutor letexpand u1d711 u1d446 u1d45d match u1d45dwith skip fail skip c x e skip u1d4501 u1d4502 u1d711 u1d446 u1d4501 u1d4502 for u1d711 u1d446 u1d4501 inexpand u1d4501 whileconddocod u1d711andcond u1d446 u1d450 u1d45d u1d711and andcond u1d446 skip if u1d450 u1d45c u1d45b u1d451then u1d4501else u1d4502fi u1d711and u1d450 u1d45c u1d45b u1d451 u1d446 u1d450 u1d711and not u1d450 u1d45c u1d45b u1d451 u1d446 u1d4502 figure computingsuccessorsofsymbolicstates this syntax to e.g.
python.
everythingdiscussedinthis section is implementedincoq provencorrect andautomatically extracted to an executableocaml executableversion.
symbolic evaluator and symbolic stores.
implementing a symbolic executor requires an efficient implementation of symbolic storesandafunctiontoevaluatesymbolicexpressions.oneway to implement symbolic stores is using hash tables with variable namesaskeysandexpressionsasvalues.updatingastore u1d446with anassignment u1d465 u1d452 written u1d446 returnsanupdatedcopy ofthehashtable.thesymbolicevaluation u1d452 u1d446ofanexpression u1d452in a store u1d446can be performed by a simple recursive function.
weabstractfromtheseimplementationdetailsandusethemathematicalnotations u1d446 and u1d452 u1d446incodesnippetstodenote assignments andsymbolic evaluations.
alazysymbolicexecutor.
themaincomponentofthesymbolic executorisafunction expand computingthesuccessorsofa symbolic state implementing the symbolic semantics in fig.
.
the executor sentrypointisafunction run takingafifoqueue ofsymbolicstatesandreturningastreamof optional reachable symbolic states.
at every iteration it yields the first state from the queue.then thedirectsuccessorsofthecurrentstatearecomputed usingexpandand enqueued in the task queue with the lowest priority realizing a breadth first search .
finally runcalls itself recursively on the updated queue.
if the queue is empty a none token isyieldedindicating that nostates are left for expansion.
1171esec fse december3 san francisco ca usa arthur corrensonanddominic steinh fel letdisplay state ifstate is none then finished else if is stuck state then bugfound state else pending letbug finder u1d45d map display run figure8 statusmessageconversion bugfinderentrypoint letis stuck u1d711 u1d446 u1d45d match u1d45dwith fail true u1d45d is stuck u1d45d false figure classifying errorstates reporting bugs.
the function runimplements a symbolic executor.
we obtain a bug finder by turning symbolic states from the stream intoadequate statusmessages bugfound u1d711 u1d449 u1d45d informs the user that a bug has been detectedandreturns the associatedsymbolic state.
pendinginformsthe userthat the seisinprogress.
finished informstheuserthatthe seterminated.nofurther symbolic state willbe discovered.
the conversion from symbolic states to status messages is accomplishedbythefunction display .thefinalbugfinder bug finder infig.
startssewithasingletontaskqueueconsisting of an initial symbolic state andapplies display on the results.
detecting bugs.
the function display usesis stuck to filtererrorstates.asdiscussedinsect.
.
is stuck considersa symbolic state u1d711 u1d446 u1d45d an errorstate if u1d45dstartswith fail.
.
relativesoundness andcompletenessof thesymbolic executor t soundnessandt completenessareexpressedassuminga yes no oracle.forexample at soundbugfinderonlyrespondswith yes tois there a bug in my program?
if thereisa bug that manifests for a concrete input.
however fuzzers and symbolic bug finders generally do not terminate unless interrupted as in the case of our symbolic bug finder from the previous section.
thus we adapt thesenotionstotestersproducinga streamofresults.wecallthe resulting concepts relativesoundness completeness.
they address the questionofwhether aninputin astream exposes abug.
more precisely a bug finder is relatively sound if any bug report in the generated stream corresponds to bug exposing input s .
it is relativelycomplete ifitwilleventuallyreportabugforanygiven bug triggering input.
in other words both terms are relative to thetimeprovidedtothebugfinder.moreover relativecompleteness isparametric in a concrete bug triggering input.
thoughformally weaker than t completeness due to the additional precondition it provides the strong guarantee a specificbug will be found not justanybug.inthecontextof se relative soundness additionally permitsconveyingfalsepositiveswith unsatisfiablepathconstraints excludingtheserequiresacompleteconstraintsolverthatcorrectly classifiesallunsatisfiablepathconditions.providedsuchasolver it isaneasyexercisetoconstructat soundandt completebugfinder from arelativelysound complete one as describedinsect.
.
.
in this section we investigate se specific notions of relative soundness and completeness asserting that a symbolic executor exploresonlyreachable symbolic states soundness and allreachable states completeness .
the subsequent sect.
.4formalizes the more general notions of relative soundness and completeness and applies the results from this section to prove that the bug finder from sect.
.2satisfiestheseproperties.
to conveniently express predicates over streams of symbolic statesorstatusmessages weuse lineartemporallogic ltl chapter notation.
ltlformulas describe infinite streams of elementsofsomecarrierset u1d434.atomicltlformulasarepredicates over u1d434 elements or equivalently subsets of u1d434.
for example the ltlformula u1d443 u1d45b u1d45a u1d45a u1d45b is satisfied by the stream ...sinceitsfirstelementiseven.theformula u1d443 globally describes streams in which allelements are even u1d443 eventually matches streams with someeven number.
the property u1d443holds for streams with infinitely many even numbers every position in thestream musteventually besucceededbyaneven number .in additionto and weuselogicalimplication .
forexample means that any stream whose first element is mustcontain either0or1at alaterposition.
we write u1d6fc u1d711if the stream u1d6fc u1d6fc0 u1d6fc1 ...satisfies the ltl formula u1d711 u1d6fc u1d711means that u1d6fcdoesnotsatisfy u1d711.
formally the semantics ofltlformulas isinductivelydefinedas follows u1d6fc u1d443 u1d443 u1d6fc0 u1d6fc u1d711 u1d456 u1d6fc u1d456 u1d6fc u1d456 ... u1d711 u1d6fc u1d711 u1d456 u1d6fc u1d456 u1d6fc u1d456 ... u1d711 u1d6fc u1d7111 u1d7112 u1d6fc u1d7111or u1d6fc u1d7112 oursymbolicexecutorproducesastreamofoptional possibly none symbolicstatesfromalist u1d459ofinputstates.tobesound every symbolic state in the stream must be reachable from some state in u1d459.
theltlformulareachablefrom u1d459 asserts that the first element inastream is noneorasymbolic state reachable from astate in u1d459.
definition .
reachable from .
reachablefrom u1d459 u1d70e u1d70e u1d459 u1d70e sym u1d70e none ourbugfinder ssoundnessdependsonthesingle stepexecution functionexpandcorrectlyimplementingthe relation sym theorem .
correct expansion .
u1d70e sym u1d70e u1d70e expand u1d70e proof.by induction on the sym derivation direction and the structure of u1d70e sprogram counter .
now we can state the relative soundness theorem whose proof followsdirectlyfrom theorem .
1172engineeringaformallyverifiedautomatedbugfinder esec fse december3 san francisco ca usa theorem .
relative soundnessof symbolic execution .
run u1d459 reachablefrom u1d459 by outputting a nonevalue in the stream runsignals that all reachable states have been exhaustively explored.
consequently the stream should only consist of noneafter the first issued one guaranteeing that we can safelyterminate seafter the first none.
theorem .
soundterminationof symbolic execution .
run u1d459 none none weconsiderthesymbolicexecutor relativelycomplete if forany initial symbolic state u1d70e it generates at leastall sym successors of u1d70ewhen started on the list .
we first state a more general theorem lemma .
from which we then conclude the relative soundness.lemma .1assertsthatforanystate u1d70ediscoveredduring se its directorindirect successorswilleventuallybefound.its proofrequiresustopredict whenexactly thedirectsuccessorsof anystate u1d70ewillbe discovered byour breadth firstsearchstrategy.
lemma3.
reachability of successors .
u1d70e sym u1d70e u1d459 run u1d459 u1d70e u1d70e proof.by induction on the length of the derivation u1d70e sym u1d70e .
if u1d70e u1d70e thenthetheoremisobvious.otherwise wehave u1d460 sym u1d70e and u1d70e sym u1d70e forsomeintermediatestate u1d70e .nowsuppose that u1d70eoccursatagivenposition u1d456 u1d70einthestream run l thedirect successor of u1d70e necessarily occurs at index u1d456 u1d70e u1d456 u1d70e u1d459 1or u1d456 u1d70e u1d456 u1d70e u1d459 2becauserunextendsthe tasklist byaddingallthe successors see theorem .
ofthecurrent state attheend ofthe tasklistandthereareatmosttwosuccessorsforanystate.since u1d70e occursatposition u1d456 u1d70e weknowbyinductionhypothesisthat u1d70e occurs at someindex u1d456 u1d70e u1d45bfor u1d45b .
from lemma .
we conclude the completenessresult.
theorem .
relative completeness of symbolic execution .
u1d70e sym u1d70e run u1d70e proof.itsufficestoseethatthefirstelementofthestream run is u1d70eandthen to apply lemma .1at position .
.
relativesoundness andcompletenessof thesymbolic bug finder in theprevious section we established therelative soundnessand completenessofthesymbolicexecutorregardingthesymbolicsemantics.now wedefine relativelysound bugdiscovery aproperty relevant to bug finders in general including fuzzers.
we assume the interface of the function find bugs from sect.
.
.
that is a bug finder outputs a stream of status messages that are either pending finished orbugfound .
for a status message to be valid abugfound messagemustreportasymbolicstatecorresponding to a concrete set of bug triggering states.
the following definition ofvalidstatus uses a function concrete u1d70e mapping from a symbolicstatetothesetofconcretestatesitrepresents.formally concrete u1d70e u1d70e u1d4490 u1d70e u1d4490 u1d70e .
definition .
valid status .
validstatus u1d45d bugfound u1d70e u1d70e u1d70e concrete u1d70e isbug u1d45d u1d70e pending finishedaccording to this definition a bug report is always valid for symbolic states with unsatisfiable path conditions since these have anempty concrete u1d70e .howtogetfromtheretorealt soundness isthefocusofsect.
.
.thedefinitionofrelativesoundnessiseasy a relativelysound bugfinder only outputs valid status messages.
theorem .
relatively soundbug discovery .
find bugs u1d45d validstatus u1d45d proof.directapplicationoflemma .
andthefactthat display filtersonly stuckstates.
completeness.
relative completeness means that any given bug will eventually be reported in the stream of status messages.
as mentioned before this property is both weaker due to the precondition of providing a concrete bug triggering input and stronger since it guarantees that a pre chosen bug will be found than tcompleteness.thesubsequentcompletenesstheoremusesafunctionsymbolic u1d70e mapping from a concrete state to the set of symbolic states representing it the inverse of concrete .
more formally symbolic u1d70e u1d70e u1d4490 u1d70e u1d4490 u1d70e .
theorem .
relatively complete bug discovery .
isbug u1d45d u1d70e find bugs u1d45d symbolic u1d70e proof.supposeisbug u1d45d u1d70e .
by completeness of bug finding we haveisbugsym u1d45d u1d70e .theresultfollowsbythecompletenessof run andthe fact that displaykeepsallstuckstates inthe stream.
termination.
implementing a complete and yet always terminatingbug finder is impossible as it would solve the halting problem.
yet thereareprogramsforwhich secanbeexhaustive e.g.
programswithoutloopsnorrecursion .wedefine soundtermination as the property that whenever a bug finder emits a finished message itwillnotreportanythingelsefromthatpointon.ifasoundly terminating relativelycompletebugfinderdoesnotreportabug andsays finished we can be sure that the tested programis safe.
theorem .
soundterminationof thebug finder .
find bugs u1d45d finished finished proof.directconsequenceof theorem .
.
.
a t sound andt complete bug finder a t sound and t complete bug finder is a binary oracle answering yesif andonlyif thetestedprogramisfaulty.sofar weconsidered bugfindersproducinginfinitestreamsofstatusmessages towhich t soundnessandt completenessdonotdirectlyapply.yet relative soundness and completeness theorem .
theorem .
are sufficiently strong to derive such an oracle.
relative soundness ensures forevery bugfound u1d70e messagethatall u1d70e concrete u1d70e areerror states.
the only obstacle in the way toward t soundness is that concrete u1d70e could be empty i.e.
u1d70e s path condition unsatisfiable.
otherwise a bugfound messagefromthe streamcorrespondstoa soundbug.seengines typically use off the shelf constraint solvers suchasz3orcvc5todetermineifapathconditionisunsatisfiable.
relativecompleteness ontheotherhand ensuresthatforany error state u1d70e the stream contains a message bugfound u1d70e with u1d70e symbolic u1d70e .
the latter condition implies that u1d70e s path condition is satisfiable.
inconveniently a terminating bug finder can 1173esec fse december3 san francisco ca usa arthur corrensonanddominic steinh fel exception bug exception termination letreport msg matchmsgwith bugfound path ifis sat path then raise bug finished raisetermination typeanswer yes no lethas bug p tryiter report find bugs p with bug yes termination no figure at soundandt complete bug finder neverbecompleteingeneral thebugcouldalwaysbehiddeninthe nextstate.oursolutiontothisproblemistoimplementa nonterminating butcomplete symbolic tester.
our implementation shown in figure10 buildson find bugs andusesaconstraintsolver is sat andafunction iterforiteratingoverallelementsofastream.it only outputs sound bugs terminates for finite symbolic executions and continues seas long as no bug is found or the process is interrupted.
since only terminating functions can be implemented in coq we have to resort to a pen and paper proof of has bug s t soundness andt completeness.
theorem .
t soundnessandt completeness .
has bug u1d45d u1d44c u1d438 u1d446 hasbug u1d45d proof.the answer is yesiff there is a bugfound u1d711 u1d446 u1d45d message in the stream find bugs u1d45d such that u1d711is satisfiable.
the result followsfrom relative soundness completeness.
implementationsand case studies inthissection weconnecttoquestion fromtheintroduction how can we engineer a reliable symbolic testing tool?
we aim to proposeadesignforsymbolicexecutorsindependentlyoftheimplementation language for the solution to be of general interest it should be able to live outside an interactive theorem prover.
thus we derived two executable implementations from the coq implementation of wise.
first we automatically extracted ocaml code wrapped in a command line interface with a parser for imp s concretesyntax.second wedevelopedafunctionallyequivalent python implementation pywise again with a usable commandline frontend.
we used python generators to implement streams wherethecoqversionusesco inductionandre implementedthe coqcode withonly small purelysyntactical changes.
since the transformations from coq to executable programs are not formally proven correct we evaluated them with three numeric algorithms.
we chose the computation of a number s factorialandintegersquarerootandthegreatestcommondivisoroftwo numbers.
we annotated each program with assertions of their correctness e.g.
foranintegersquareroot u1d45fofanumber u1d45b u1d45bmust bein theclosedinterval .next wederived a buggy mutation of each program e.g.
turning while s x while s x the square root example.
finally we asserted that our symbolic executors find the inserted bug but report no bugfor theoriginalprograms.
inaddition weverified that seterminateswitha finished messageforthecorrectprogramswhen we restrict the domain of the input number s to a finite range.
to demonstratethatabreadth firstpathselectionissuperiortodepthfirst asintheoriginaldartsymbolicexecutor infinding any buginaprogram weaddeda depth first optiontopywiseto transition to depth first search.
as a result the bug in the factorial implementationisnotuncoveredsince segets trapped ininfinite iterations ofan early loop.
engineeringtasks.
themainnoveltyofthispaperisthepresentationofamechanized specificationofthecorrectnessoftestingtools and the implementation of a mechanically verified symbolic testing toolinaproofassistant.weabstractedtheaddressedproblemin twonoteworthywaysto facilitate this project.
our target programming language imp is a simple while language.
extending our framework to a richer language requiresthespecificationofarichersemantics.forexample thesemanticsofes5javascriptinthejscertproject is implementedinabout3 000linesofcoqcode.thecorrectnessproofofjsref anexecutablereferenceinterpreterfor jscert spans linesof code.
we disregard the question of efficiency which is orthogonal to our questions and .
yet efficiency is crucial for the competitivenessof se basedtestingtoolscomparedtorandomtesting .anefficientsymbolicexecutormightreplace the breadth first path selection with e.g.
a coverage guided generationalsearch .aconsiderablebodyofliterature on efficient symbolic execution exists cf.
the survey by baldoni et al.
for an overview .
the role of our contribution is to show how the correctness of an sesystem can be retained in the face of efficiency optimizations.
exchanging path selection for example requires provingthat allreachable symbolic states are eventually considered by the new selection mechanism lemma .
.
extending our foundational work to efficient systems for richer languagesispossible.ofcourse thatsteprequiressignificant proof engineeringwork.
this paper showsthe way.
conclusion and futurework consideringthattestingisthepredominantprogramverification technique it may seem surprising that the correctness of bug findershasnotreceivedmoreattention.probably thisisbecause fuzzers the most popular automated testing tools are naturally bug sound theyonlyreportinputsthat havealready madethe program under test crash.
however fuzzers only find shallow bugs forprogramswithcomplexdemandsontheirinputsorwithcode guardedbycomplexconstraints.
symbolicexecution se isawhitebox technique simulating multiple program executions at once.
as such this technique can handle complex input constraints fully 1174engineeringaformallyverifiedautomatedbugfinder esec fse december3 san francisco ca usa automatically.comparedtoafuzzer correctlyimplementingasymbolicexecutorconstitutesamuchmoresignificantchallenge.we defined when a tester is bug sound and bug complete i.e.
a program is buggy if and only if a bug is reported resulting in the notions of t soundness and t completeness.
we chose a semantics forseanddemonstratedthatitcanbeusedasafoundationforsymbolicbugfinding.finally weimplementedasymbolicbugfinder wise in coq proved it t sound and t complete and extracted executableimplementations inocaml andpython.
the resulting symbolic executors interpret programs in the simpleprogramminglanguageimp.connectingtoourfoundational work weplantosupportadditionalimpfeatures suchasfunctions and pointers in our symbolic executor.
thus we could discover common pitfalls in implementing their symbolic evaluation.
more generally wiseconstitutesasolidbasisforstudyingmoreadvanced sefeatures such as different path selection algorithms constraint representations orconstraint solving approaches.
is it realistic to expect a fully verified symbolic executor for anindustrialprogramminglanguage?wethinkitis considering the existence of fully verified c compilers .
in any case blackbox testing will never find all the errors in existing symbolic executors butinsightsfromimplementingdifferentprogramminglanguage features inaframework willpositivelyinfluencetheirdesign.
data availability ourwiseandpywiseprototypesandthedocumentationofthe coqsourcescan be accessedat pywiseisalsoavailable onpypiandcan be installedvia pip install wise se an artifact with a docker container comprising wise pywise andourexampleprogramsinaworkingenvironmentispublicly available .