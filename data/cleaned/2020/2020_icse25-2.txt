tiver identifying adaptive versions of c c third party open source components using a code clustering technique youngjae choi korea university republic of korea youngjaechoi korea.ac.krseunghoon woo korea university republic of korea seunghoonwoo korea.ac.kr abstract reusing open source software oss provides significant benefits but also poses risks from propagated vulnerabilities.
while tracking oss component versions helps mitigate threats existing approaches typically map a single version to the reused codebase.
this coarse grained approach overlooks the coexistence of multiple versions leading to ineffective oss management.
moreover identifying component versions is further complicated by noise codes such as shared algorithmic code across different oss and duplicate components caused by redundant oss reuse.
in this paper we introduce the concept of the adaptive version a one stop solution to represent the version diversity of reused oss.
to identify adaptive versions we present t iver which employs two key techniques fine grained functionlevel versioning and oss code clustering to identify duplicate components and remove noise.
this enables precise identification of oss reuse locations and adaptive versions effectively mitigating risks associated with oss reuse.
evaluation of popular c c software revealed that of oss components contained multiple versions averaging over three versions per component.
nonetheless t iver effectively identified adaptive versions with .
precision and .
recall in duplicate component distinction and precision and .
recall in eliminating noise while existing approaches barely achieved recall in distinguishing duplicates and did not address noise.
further experiments showed that t iver could enhance vulnerability management and be applied to software bills of materials sbom to improve supply chain security.
index terms open source software third party library management version identification supply chain security i. i ntroduction software reuse has become a cornerstone of modern software development with open source software oss accelerates development and reduces costs .
however improper oss reuse can compromise the entire system e.g.
vulnerability propagation .
a key strategy to mitigate this is identifying and tracking reused oss versions and updating vulnerable components e.g.
.
in a real world software ecosystem especially in c c software where code level reuse is more dominant than package level reuse oss is rarely reused without modifications .
developers often use only parts of oss apply backported patches or unintentionally include redundant corresponding authorcopies due to nested dependencies .
this adaptive reuse results in a complex landscape where multiple oss versions coexist within a program complicating version identification and security management.
therefore identifying the adaptive version of oss components a comprehensive representation that encompasses the various versions present in reused code is crucial for software security.
however this task is challenging by noise and duplicate components which can result in inaccurate version identification and flawed vulnerability assessments.
noise.
code snippets that are commonly present in various oss due to their brevity or the implementation of widely used algorithms.
duplicate components.
cases where the same oss is reused in multiple parts of the target software often with different versions to satisfy specific requirements .
removing noise ensures accurate version identification by preventing unrelated code from being misclassified as oss reducing false alarms in vulnerability reports.
detecting duplicate components allows precise mapping of oss usage each with unique vulnerabilities.
failure to distinguish duplicates can lead to overlooked version specific issues and compromised vulnerability assessments.
limitations of existing approaches.
to the best of our knowledge no existing approaches have considered the version diversity of c c components while attempting to distinguish duplicate components and eliminate noise see section vi .
for example c entris and v1 scan map only the most prevalent version within a component without considering duplicates and noise.
c neps made some progress by partially identifying duplicate components however it did not perform version identification and gave little consideration to noise.
while ossfp attempted to eliminate noise from the perspective of component identification it failed to apply this to version prediction and did not consider version diversity and duplicate components.
this gap in current research underscores the need for a more comprehensive solution to identify c c oss component versions effectively.
ieee acm 47th international conference on software engineering icse .
ieee approach.
we present t iver adapt iveversion analyzer a novel approach for the comprehensive identification of adaptive versions in c c oss components.
the key concepts of t iver which are markedly distinct from existing approaches are fine grained versioning at the function level and an oss code clustering technique.
given a target software t iver identifies the oss components and specifies the oss version for each reused function see section iii b .
it adapts c entris to identify components and then compares the codebase of the target software with that of each oss version.
this process enables tiver to determine the specific versions associated with reused functions.
t iver then utilizes oss code clustering to isolate the reused oss code regions see section iii d .
it groups code segments expected to belong to the same oss based on the file names and directory structures in which the reused functions are located thereby creating clusters.
subsequently clusters with duplicate source files are identified as duplicate components whereas clusters with a small proportion of reused functions are considered noise and pruned.
finally t iver aggregates the versions of the reused functions within each cluster and identifies the adaptive version that encompasses oss version diversity section iii e .
evaluation.
when we applied t iver to c c software projects on github we observed that oss components with a single version accounted for only of the total.
instead each component had more than three distinct versions and of the identified components were reused redundantly.
despite various oss reuse patterns in which different versions coexist and redundant reuse occurs t iver can effectively identify adaptive versions encompassing multiple coexisting oss versions.
in particular t iver showed .
precision and .
recall in duplicate component distinction and precision and .
recall in noise elimination whereas existing approaches barely achieved recall in duplicate component distinction and failed to address noise see section iv a .
we further demonstrate that by integrating the adaptive versions identified by t iver with the software bill of materials sbom t iver can be used to improve supply chain security especially in detecting propagated vulnerabilities see section iv d .
contributions.
we summarize our contributions below.
we present t iver the first approach to effectively identify adaptive versions of reused oss components using fine grained versioning and oss code clustering to distinguish duplicate components and eliminate noise.
tiver revealed that oss components with a single version made up only of our dataset emphasizing the need to address multiple versions and proposing a detailed process for identifying adaptive versions.
experiments on popular software show that t iver effectively identifies adaptive versions distinguishes duplicate components and eliminates noise.
we demonstrated that tiver can enhance supply chain security and vulnerability management when used with the sbom.ii.
m otivation a. terminology we define several terms upfront.
oss reuse.
this refers to utilizing a portion of oss functions or the entire oss source code .
oss component.
an oss component is a set of oss functions reused in a target program .
oss version.
we define an oss version to adhere to the default three component semantic versioning notation of major.minor.patch .
oss update.
we consider any change in the aforementioned three component i.e.
major.minor.patch of an oss version to constitute an update of the oss.
b. problem and goal statements problem.
in this paper we aim to address the problems that occur when mapping a single version to a c c oss component.
in c c languages it is typical to reuse oss with code modifications which involve updating specific portions of the code to newer versions e.g.
through backporting patches .
consequently multiple versions of code may exist within a single oss component.
however oss management becomes inefficient when determining the version of oss components as a single entity.
one of the critical issues is the difficulty in precisely identifying vulnerabilities.
as identified by v1 scan mapping a single version to the entire component without considering version diversity results in a false positive rate for vulnerability detection.
moreover this can overlook certain vulnerabilities and potentially leave unidentified threats.
goal.
therefore we aim to identify the issues arising when mapping a single version to oss components and propose a solution to identify adaptive versions of c c oss components for efficient third party library management.
additionally we intend to compile the issues that arise during the identification of c c oss component versions and propose policies that encompass diverse versions of reused oss codes.
c. motivating example to demonstrate the importance of identifying an adaptive version we attempted to manage the oss components of reactos1 a free windows compatible operating system.
as of march the master version of reactos reused source files from libxml22.
when the version of each reused source file was identified by referring to the commit history six versions emerged.
the distribution of the reused versions is listed in table i. limitations of existing approaches.
existing approaches designed to identify the versions of reused oss components at the source code level have primarily focused on the version to which the majority of functions belong.
however this method results in inefficient vulnerability discovery.
2459table i version distribution of reused libxml2 source files inreactos as of march .
version reused files ratio v2.
.
v2.
.
v2.
.
v2.
.
v2.
.
v2.
.
total for example when c entris was used the reused version of libxml2 was v2.
.
.
applying this result to vulnerability detection it can be concluded that reactos contains two propagated vulnerabilities cve and cve2022 which were reported to be present in libxml2 versions prior to v2.
.
.
however the reused files containing these vulnerabilities were updated by the reactos team to v2.
.
by backporting the security patches.
hence these results are false positives fps because the vulnerabilities are remediated.
similarly if vulnerabilities are contained within source files belonging to versions v2.
.
or v2.
.
existing approaches overlook these vulnerabilities.
tiver .tiver can distinguish multiple versions mixed in reused oss codes and identify adaptive versions of oss components thereby enabling effective vulnerability responses.
tiver uses code clustering to precisely identify reused oss code areas and eliminate noise that hinders version identification.
for example t iver detects that the source files under the reactos dll 3rdparty libxslt path contain libxml2 code because both libraries share a commonly used algorithmic code.
t iver identifies these as noise and excludes them from the libxml2 version identification.
furthermore if libxml2 is redundantly reused in reactos tiver determines the adaptive version for each reused code area see section iii d .
finally t iver identifies the adaptive version of libxml2 i.e.
2. .
see section iii e and tracks which version the reused functions belong to.
this ensures accurate component version tracking even when specific functions are updated or experience delayed updates thus aiding effective library management.
for instance t iver can identify that the reused functions containing the two aforementioned cves are from a version where vulnerabilities have been patched thereby preventing fps.
moreover it can detect vulnerabilities present in versions prior to v2.
.
an in depth analysis of these issues is presented in section iv d .
iii.
d esign of tiver we describe the design of t iver an effective approach for identifying adaptive versions of c c oss components.
considerations.
before introducing t iver in detail we present two important considerations that need to be considered for the effective management of oss by identifying adaptive versions.
first we address noise which refers to common source code found in various oss projects.
since code that implements common algorithms e.g.
cryptographic functions appears target softwareinput component metadata oss identification version normalization clusters noise pruned adaptive version per cluster output vulnerability detection sbom adaptive version identification oss code clusteringfig.
high level overview of t iver .
frequently in various oss projects this noise must be filtered out to prevent misidentification.
our approach carefully separates such common code from the unique characteristics that distinguish specific oss versions.
second it is important to distinguish duplicate components.
the target software may reuse the same oss but different versions in various code sections to meet specific requirements.
in these cases it is crucial to distinguish duplicate components and carefully verify the version of each code section for efficient oss management e.g.
vulnerability assessment .
a. approach overview figure shows the high level workflow of t iver .
the distinguishing features of t iver from existing approaches include considering fine grained versioning at the function level and eliminating noise and distinguishing duplicate components through oss code clustering .
tiver begins by identifying the codebase of each reused oss within the target software accomplished by utilizing centris an oss component identification tool.
once the reused oss components are identified t iver assigns versions based on the granularity of individual functions rather than treating the entire component as a single entity.
this fine grained versioning enables t iver to capture the diversity of versions that may exist in a single component.
after assigning a version to each reused function t iver employs oss code clustering to distinguish noise andduplicate components from the reused oss code areas.
finally t iver identifies an adaptive version that encompasses diverse versions of the reused oss code areas.
this is achieved by analyzing the versions of individual functions within each component excluding noise and establishing a representative version or range for the entire component.
in cases where duplicate components exist adaptive versioning is performed for each component.
design assumption.
tiver identifies adaptive versions at the source code level.
t iver can be applied to any granularity level e.g.
files and functions however we focused on function units.
function granularity is ideal for identifying oss components and adaptive versions as it reduces false negatives fns in oss and version identification compared to coarser units e.g.
files and minimizes false positives compared to finer units e.g.
lines .
2460b.
oss identification the initial phase involved identifying oss components within the target software.
because our goal is to identify an adaptive version rather than precisely discover oss components we leveraged c entris due to its ability to identify modified oss components as well as its publicly accessible source code and dataset .
however the original c entris tool provided only a list of component names and reused source files.
to align with our goal we modified the c entris source code to include the information listed in table ii in the output.
table ii modified output of c entris .
element description component name the name of the identified oss component.
common functionsfunctions commonly present between each identified component and the target software.
path informationthe directory path of common functions in the target program.
segmented oss versionsversions to which each common reused function belongs in the original oss.
the c entris dataset lists the versions to which oss functions belong making it easy to extract segmented oss versions.
note that c entris focuses on component identification and does not engage in adaptive version identification.
c. version normalization this paper considers three component semantic versioning i.e.
major .minor .patch see section ii a .
however versions can be handled in various ways in an oss ecosystem.
hence t iver normalizes versions to standardize heterogeneous version strings into a consistent format.
the algorithm operates in the following three steps.
s1.
numeric element extraction.
tiver first isolates numeric elements from the input string.
t iver disregards non numeric characters that may vary across different versioning schemes e.g.
in the case of v0.
.
the non numeric character v is ignored .
s2.
semantic version construction.
tiver constructs a standardized semantic version.
the first extracted number is assigned as major .
ifmajor is present the second number is assigned to the minor version.
t iver then parameterizes the delimiter of numbers e.g.
.
or .
the third or last number is assigned as the patch version and checked for delimiter consistency.
s3.
validation and augmentation.
tiver validates and augments the constructed semantic version.
when the major andminor versions are present but patch is missing t iver assigns as the patch i.e.
zeropadding .
after applying the above steps the version is flagged as invalid if any element is missing.
for instance openssl 1 1 was normalized to a semantic version with a major of minor of and patch of .
this normalization enhances the ability to standardize version information across various oss projects thereby improving the effectiveness of subsequent analyses.d.
oss code clustering to efficiently identify adaptive versions t iver employs an oss code clustering technique that aims to identify noise and distinguish duplicate components.
to achieve this t iver leverages the following two key intuitions.
noisy regions contain only a few reused functions.
duplicate oss codebases contain redundant files.
we use google s filament commit id ce7dd7 as a working example see figure .
we assume a situation in which noise and duplicate components are identified through clustering for onecomponent and the working example introduces the process of clustering for googletest reused in filament .
the clustering consisted of four steps.
step directory hierarchy identification.
the initial step is to identify the directory structure of the target software and determine where it reuses functions from the oss project using the paths of the reused functions recorded in advance see section iii b .
the results are shown in a treestructure where the root node is the target software the leaf nodes are the reused source files from the oss and the inner nodes are the target software directories.
for example figure 2a shows a part of the tree for filament .
because geometry uses general testing logic similar to googletest figure 2a indicates that the geometry directory also includes functions reused from googletest i.e.
noise .
step known duplicates examination.
to cluster the reused code t iver utilizes the names of reused files if oss is redundantly reused files with the same name may coexist in the target software this is discussed in section v b .
however duplicate files may exist in the original oss.
t iver defines duplicated files present in the original oss code before reuse asknown duplicates .
to effectively distinguish duplicate components in later steps t iver identifies known duplicates and their occurrences for each oss using the c entris database see section iv .
if the occurrences of duplicates varied across oss versions t iver considered the maximum value.
step reused code clustering.
reused code clustering was performed based on three main rules.
r1.
by default all child nodes that share the same level parent node are assigned to the same cluster.
r2.
if files included in known duplicates redundantly exist in the tree and their occurrences exceed the number specified in known duplicates tiver locates the lowest common ancestor lca and uses the lca node as a reference node to assign different clusters at the immediate subordinate directory level.
this operation is performed only on directories containing duplicate files.
r3.
if files that are not listed in known duplicates exist redundantly in the tree regardless of their occurrences tiver locates the lca and uses the lca node as a reference node to assign different clusters at the immediate subordinate directory level.
this operation is performed only on directories containing duplicate files.
2461dir file ossfilament libs tests contri blibgtest gtest.ccthird party libassimp gtest gtest.ccgoogletestgeometry test trans coder.cpp a directory hierarchy identification.
filament libs tests contriblibgtest gtest.ccthird party libassimp gtest gtest.ccgoogletestgeometry test trans coder.cpp known duplicates none b known duplicates of googletest examination.
filament libs tests contriblibgtest gtest.ccthird party libassimp gtest gtest.ccgoogletestgeometry test trans coder.cpp cluster i cluster ii cluster iii c reused code clustering based onunknown duplicates.
filament libs tests contri blibgtest gtest.ccthird party libassimp gtest gtest.ccgoogletestgeometry test trans coder.cpp52.
.
.
pruned cluster i cluster ii cluster iii d cluster pruning based on code occupancy.
fig.
diagrams of oss code clustering.
these sequentially depict the clustering for the googletest reused by filament and the goal is to identify noise and distinguish duplicate components.
note that only some nodes are shown in each tree for ease of explanation e.g.
in figure 2d because some clusters are omitted the sum of clusters total proportions is less than .
tiver essentially performs clustering from lower to higher levels down to a level excluding the root node of the tree.
this involves starting each cluster from the level directory to identify the noise that generally exists in paths different from the oss code area more efficiently.
next t iver focuses on duplicate files.
for the known duplicates clustering was performed by comparing the number of occurrences.
in contrast the presence of unknown duplicates indicates that an oss is redundantly reused thus clustering is performed regardless of its occurrence.
we demonstrated that filename based clustering works effectively see section iv a and further issues are discussed in section v b. in our working example all descendant directories and files of third party andlibs are inherently grouped into their respective clusters.
t iver verified that the originalgoogletest contains no known duplicates.
however there are unknown duplicates i.e.
gtest.cc in thethird party cluster thus t iver locates the lca i.e.
third party and creates two separate clusters i.e.
third party libgtest andthird party libassimp see figure 2c .
because the rightmost cluster does not contain any files common to the other clusters according to r1 it is clustered under libs .
using this method t iver can identify the boundaries of oss component codebases within the target software.
step cluster pruning.
after clustering the tree t iver performs pruning to eliminate noise.
to achieve this t iver measures the proportion of the reused functions in each cluster.
tiver considers the total number of functions reused in the target software to be .
t iver calculates their respective proportions based on the number of functions included in each cluster.
if the proportion of functions in any cluster falls below a threshold typically a small value t iver considers this cluster noise and removes it from the directory tree experiments on the threshold sensitivity are presented in section iv b .
for example in figure 2d if we set to .
cluster iii is pruned because the proportion of reused functions is .
i.e.
less than .
after this process the remaining clusters are identified as reused oss code areas.
if two or more clusters remain t iver decides that it is a duplicate component and obtains an adaptive version for each cluster area.e.
adaptive version identification finally t iver assessed the adaptive versions of each cluster.
t iver operates on the principle of identifying the most conservative version range which encompasses all versions present within a given cluster.
letv v1 v2 ... v n be the set of all unique versions vi of the functions included in a cluster.
when a function belongs to multiple versions with the same syntax only the latest version is considered this is discussed in section v a .
version vican be represented as a tuple mi ni pi where mi ni and pirepresent the major minor and patch respectively.
let vobe the oldest version of v and let vxbe an invalid version i.e.
a version that failed to normalize .
the adaptive version vaof the cluster is obtained as follows.
va vo ifv vo voifv vo vx voif vi vj v. mi mj voif vi vj v. mi mj vi vj v. ni nj voif vi vj v. mi mj ni nj vi vj v. pi pj tiver expands upon the semantic versioning of the node package manager npm by incorporating additional elements for more efficient version notation.
first if all functions in a cluster share the same version which is not an invalid version t iver determines that version to be the cluster version.
next if there are one or more invalid versions present in the cluster s version set but excluding the invalid versions if the cluster has only one unique version vo t iver denotes the version of the cluster as vo.
when there is more than one normalized version in the cluster t iver uses the following three notations and .
these notations are similar to the ones used in npm but we clarify the definition of each notation while simplifying it further to avoid confusion with the existing conventions.
the scope of the three notations defined by t iver is as follows.
allows for any major minor orpatch increments.
allows for minor andpatch increments.
allows only patch increments.
for example consider an oss component x i.e.
cluster with the following versions .
the adaptive version for this component would be 1. .
allowing 2462minor andpatch increments from .
.
i.e.
vo onwards such as .
.
and .
.
but not .
.
or higher.
as part of supply chain security through using sbom tiver manages the version of all functions contained within each cluster in a separate file an example is presented in listing .
while the adaptive version can provide a rough idea of which versions of source files have been reused this information allows developers to address propagated vulnerabilities more easily.
for example suppose a cve vulnerability exists in version .
.
of the abovementioned oss component x. because the adaptive version is identified as 1. .
developers should determine whether this vulnerability has been propagated.
in this case t iver s function level versioning can be leveraged.
if the version of the reused function associated with the cve is not .
.
developers can confirm that the vulnerability has not been propagated.
conversely if the function s version is .
.
developers can take appropriate actions such as applying security patches.
the practicality of t iver in vulnerability verification and management is introduced in section iv d. iv.
e valuation in this section we evaluate t iver based on the following four research questions.
rq1 accuracy.
how precise are the algorithms used by tiver for adaptive version identification?
rq2 effectiveness.
how effective is t iver in identifying an adaptive version that encompasses all the versions present within each cluster?
rq3 performance.
how does t iver perform in terms of runtime and resource usage when analyzing large scale oss components with complex version usage patterns?
rq4 practicality.
how can t iver be utilized for supply chain security e.g.
sbom and vulnerability detection?
we ran t iver on a machine with a gnu linux .
.
41generic x86 intel r core tm i9 14900k .70ghz 64gb ram and a 2tb ssd.
architecture of t iver .tiver consists of two modules a target parser and an adaptive version analyzer .
the target parser parses the c c source code in the target software extracts and hashes every function contained for applying centris .
it utilizes ctags a robust regular expressionbased parser to identify and extract the functions.
the adaptive version analyzer identifies adaptive versions using reused code clustering.
it utilizes the anytree library which provides efficient data structures and algorithms for building and manipulating tree structures.
t iver was implemented in python with its main functionality spanning approximately lines of code excluding external libraries.
oss dataset.
to operate t iver centris must first identify oss components.
hence we leveraged a dataset containing oss projects originally curated in april by c entris and updated in april by v1 scan .
this dataset includes functions present in the oss projects acrossall their versions.
because our goal is not limited to identifying adaptive versions in only the latest systems we determined that conducting experiments with this dataset does not raise critical concerns regarding the evaluation of t iver .
target software selection.
to demonstrate the generality of tiver we selected popular software from github as our target.
we collected the top github c c software packages based on their stargazer counts i.e.
a popularity indicator .
we determined that this large scale target dataset with a total of million lines of code was suitable for evaluating the effectiveness accuracy and performance of tiver .
to effectively utilize the oss dataset we evaluated the target software using an older version i.e.
the version released closest to april for each target software .
a. accuracy of tiver methodology.
because we introduce the concept of adaptive versions for the c c components for the first time there is no existing ground truth available.
moreover defining criteria for accuracy assessment is complex due to the fact that any reused function s version falls within the adaptive version while functions from versions outside this range are not reused.
therefore we evaluated the accuracy of the following key techniques crucial for t iver duplicate component distinction noise elimination and version normalization.
because there is no ground truth available we manually examined all results with two analysts one with over years of experience in software engineering and security and the other with over three years.
initially we verified c entris s accuracy by cross referencing the oss and directory names of the reused functions.
next we measured the fps and fns of t iver .
we can closely examine t iver s results because tiver provides all the reused components functions and files in a tree structure.
specifically we reviewed the paths and names of the directories and files in the clusters referring to the source code when necessary.
if a non duplicated component is split during clustering or if non noise code is eliminated it is considered an fp of t iver .
conversely if undistinguished duplicate components or unremoved noise are observed it is classified as an fn of t iver .
any discrepancies between the analysts were resolved through discussion.
we implemented t iver on the target software using a pruning threshold of .
see section iv b for details .
adaptive version identification results.
among the components identified in the target software by c entris .
oss results were fps and were therefore excluded.
note that the results of c entris are independent of the performance of t iver .
even if c entris identifies incorrect components t iver can treat the misidentified function set as a component and precisely identify adaptive versions.
however because a misidentified function set is not particularly meaningful in practical applications we decided to exclude these results.
for the remaining oss components t iver identified clusters and found that of of the 2463table iii accuracy of the t iver s algorithms for target software.
t iver identified adaptive versions of clusters after pruning among reused oss components by effectively identifying duplicate components and removing noise.
tool target software detected components total clustersduplicate component distinction noise elimination totalincluding components tp fp fn precision recall tp fp fn precision recall tiver .
.
.
.
listing example of an fp in duplicate component distinction.
note that the original pybind11 contains only .cpp files but thetnn team created .cc files by cloning the original files.
1target tnn 2oss pybind11 4tnn tools onnx2tnn onnx converter pybind11 test test buffers.cc file test buffers.cpp file test class.cc file test class.cpp file ... identified components were redundantly reused.
in addition tiver identified noise clusters removed them and identified the adaptive versions of the remaining clusters.
table iii summarizes the accuracy of the t iver algorithm.
duplicate component distinction accuracy.
tiver identified duplicate components out of reused components.
among these were true positives tps demonstrating a precision of .
and recall of .
.
most fps occurred when developers cloned a reused code and maintained it under the same file name but with a different extension see listing .
t iver misinterprets these instances as duplicate components and separates them into clusters.
although these could be considered duplicates they were not cases where developers reused oss in multiple locations.
therefore we classified them as fps for t iver .
in contrast fns occurred when the oss was reused disjointly except for the same file or when the file name was completely changed while being reused.
although this was not common and thus fns were relatively lower than fps in these cases t iver failed to correctly separate the clusters resulting in fns in duplicate component identification.
we further compared t iver with c neps .
while cneps focuses on dependencies rather than versions it identifies duplicates based on function call relationships.
if a function in an oss is called from multiple locations with different header paths it is considered a duplicate component.
we evaluated ten target software five with three or more tps and five with at least one fn in the t iver results.
in c neps the fp criterion is ambiguous because detecting multiple dependencies does not necessarily imply that they are duplicates our focus was on comparing tps and fns.
table iv summarizes the comparison results.
notably cneps did not detect any duplicates that t iver missed.
tiver precisely distinguished most of the duplicate components showing higher recall than c neps .
in contrast c neps produced many fns such as when call relationships were ambiguous or when duplicate components existed but the callee functions were different resulting in only recall.table iv accuracy comparison between t iver and c neps .
target softwaretiver cneps tp fn recall tp fn recall openbsd .
.
node packer .
.
alios things .
.
freebsd .
.
overgrowth .
.
ydb .
.
mame .
.
fastsocket .
.
blender .
.
urho3d .
.
total .
.
noise elimination.
next we evaluated the accuracy of the noise elimination process.
t iver identified clusters as noise from all detection results.
among these were tps resulting in a precision of and recall of .
.
most fps in noise elimination were caused by reasons similar to those in distinguishing duplicate components.
when developers reuse oss code and clone it under the same file name t iver locates the cloned code as separate clusters.
if the proportion of functions included in this cluster is less than tiver considers them noise see section iii d resulting in fps in noise elimination.
establishing clear criteria for identifying fns is challenging.
we considered cases where code was not explicitly contained in oss e.g.
referring to its repository but was not pruned in noise elimination as fns.
most fns occurred when the noise cluster shared the same level node with the reused oss code regions but had different file names from the reused oss codebases.
in addition they occurred in cases where the code was not explicitly part of the oss code region but shared sufficient code to avoid pruning e.g.
generating test files by referencing the testing logic of googletest .
in such cases tiver fails to eliminate noise thereby yielding fns.
although t iver yielded false alarms in certain scenarios to our knowledge no attempts have been made to eliminate noise in oss version identification in the presence of duplicate components.
we believe that t iver is effective because it can reduce most of the noise through code clustering.
version normalization.
we examined the results of version normalization using version strings which represent the versions of all the reused functions in the detected oss components.
first t iver reported that .
of its versions aligned with the normalization algorithm without any issues.
additionally .
of the versions were successfully normalized through zero padding.
the remaining of the version strings were deemed invalid.
2464table v effectiveness of t iver .
approaches target components vdi nci v1scan baseline tiver .
.
most of the invalid versions consisted solely of strings such as tags created for testing purposes e.g.
ms bug test .
we assert that identifying invalid versions is not a shortcoming of t iver but rather a necessary step to exclude versions unrelated to semantic versions when identifying adaptive versions.
therefore this underscores the effectiveness of the t iver version normalization algorithm.
answer to rq1.
tiver effectively identified the adaptive versions of reused oss code locations by distinguishing duplicate components with .
precision and .
recall pruning noise with precision and .
recall and effectively distinguishing between valid and invalid versions through version normalization.
b. effectiveness of tiver methodology.
to demonstrate the effectiveness of t iver we compared it with v1 scan which detects vulnerabilities based on the prevalent version of detected components.
since v1scan only maps one version to a component instead of conducting an unfair experiment criticizing v1 scan we assessed t iver by comparing it to a baseline that maps a single version without considering duplication and noise.
in this context we consider the following two metrics.
.
version diversity index vdi .
this metric indicates how well an approach can cover version diversity.
it represents the extent to which different versions coexist.
vdi identified distinct oss versions oss components .
noise cleansing index nci .
this index indicates how well an approach addresses unnecessary versions in the noise that hinders precise version identification.
nci unique oss versions contained in the noise oss components result analysis.
table v summarizes the measurement results.
unlike v1 scan that mapped only one version to a component vdi t iver confirmed that on average more than three versions vdi .
coexist and proposed adaptive versions to encompass them.
compared to v1 scan which does not consider duplicates and noise nci t iver distinguishes duplicate components and identifies the versions of the reused oss by removing more than three noisy versions nci .
.
in summary t iver covers more versions than the baseline and removes noise that interferes with version identification thereby demonstrating its effectiveness in oss management.
case study.
we demonstrate t iver s effectiveness with a case study of unbound oss in openbsd commit id .unbound was redundantly used in two paths openbsd usr.sbin unbound andopenbsd sbin unwind libunbound .
there was considerable noise duelisting directory structure of openbsd where reused code from unbound exists.
1openbsd clusters before removing noise usr.sbin unbound proportion .
rbtree.c file ... usr.sbin nsd proportion .
rbtree.c file ... sbin unwind libunbound proportion .
rbtree.c file ... gnu ... proportion .
lib libc crypt ... proportion .
fp fn detected results threshold .
.
.
.
.
.
.
.
.
.02false positive false negative fig.
experimental results for measuring sensitivity of .
to the cryptography and parsing related functions included in the original unbound codebase.
the clusters identified by tiver for the unbound group were shown in listing .
tiver effectively identifies duplicate components and removes noise using code clustering.
for instance c1 and c2 which share the level node usr.sbin were separated owing to the unknown duplicate rbtree.c .
c1 with a high proportion of functions .
was retained while c2 with a minimal proportion .
was eliminated as noise.
c3 was kept for its significant reuse .
while c4 and c5 containing mostly algorithmic code were eliminated.
consequently only clusters c1 and c3 remained allowing t iver to confirm the redundant reuse of unbound .
the adaptive version is identified for each cluster after noise pruning.
threshold sensitivity.
we used a value of .
in our experiments.
to measure threshold sensitivity we investigated each noise elimination result of t iver while increasing by .
from .
to .
.
figure presents the measurement results.
we confirmed that as decreases the possibility of eliminating noise decreases i.e.
more fns and vice versa .
although the difference was not considerable we selected the point where the balance between fn and fp was the most optimal.
specifically when was set to .
the balance between fn and fp was optimal and notably the total number of false results i.e.
was the lowest among all threshold values i.e.
the f1 score was highest when was .
.
the fact that the accuracy of noise elimination does not change exponentially with different values demonstrates the overall high efficiency of our algorithm.
furthermore we set to .
in the experiment to achieve balanced results.
answer to rq2.
tiver demonstrates its effectiveness by covering various versions that coexist in reused code regions identifying duplicate components and improving version identification accuracy by removing noise.
the case study demonstrates t iver s capability to identify adaptive versions even in complex reuse scenarios.
20000000elapsed time s lines of code fig.
elapsed time for identifying adaptive versions in popular c c software programs with various code sizes.
c. performance of tiver we assessed the performance and scalability of t iver by measuring the time required to identify the adaptive version across target software sizes ranging from 1k to 20m lines of code excluding the c entris execution time .
figure shows the results of the elapsed time measurements.
we confirmed that t iver can quickly identify the adaptive version of oss components even as the target software code size increases.
specifically t iver identified the adaptive version within an average of .
s per target software median of .
s .
while tiver took slightly longer for some oss with a very large number of components or extensive code size it successfully identified the adaptive version within s for all but five target software programs.
the rapid performance of t iver suggests that it can be effectively used for oss management in practice.
answer to rq3.
tiver identified the adaptive version of the oss components within an average of .
s i.e.
fast enough without being significantly affected by the code size of the target software i.e.
scalable .
d. practicality of tiver tiver can be effectively utilized in vulnerability management which is particularly critical in supply chain security.
methodology.
for the oss components identified in section iv a we initially discovered vulnerabilities using centris i.e.
a single version based approach referencing the cpe of the nvd to extract vulnerabilities associated with the identified oss and version .
we then used t iver to examine the fps and fns of this approach focusing on the vulnerabilities associated with the reused oss and version.
.
extract vulnerable functions.
we extract functions associated with cves i.e.
vulnerable functions identified through the single version based approach .
check function reuse.
tiver then determines whether the vulnerable function has been reused in the target program.
first t iver checks whether a function with the same name as the vulnerable function exists in the target software.
if none is found it searches for similar code using tlsh hashes stored by c entris which enable the detection of similar hashes .
if the vulnerable function has not been reused t iver defines this as an fp.
.
verify function version.
for components with multiple versions t iver examines each reused function s version.
if the vulnerable function is reused but its version is not affected by the cve t iver marks it as an fp.table vi the practicality of t iver in vulnerability verification and management for oss components .
category count discovered vulnerable functions single version based fps identified by t iver fps caused by unused code fps caused by function updates fns that can be overcome by t iver total vulnerable functions verified by t iver .
identify missed vulnerabilities.
finally t iver iterates through all cves for the oss extracting vulnerable functions.
if a vulnerable function is reused in the target program belongs to an affected version and was missed by the single version based approach t iver identifies it as an fn.
result.
table vi summarizes the practicality evaluation results.
among the oss components the single versionbased approach initially discovered vulnerable functions associated with cve ids across components.
this high number was due to testing on older versions for a fair comparison with c entris .
using t iver more advanced vulnerability management was achieved.
t iver identified fps where vulnerable functions were not reused.
fps where vulnerable functions were reused but updated to safe versions.
in total t iver eliminated fps .
from the functions identified by the single version based approach.
manual verification of approximately of the fps confirmed that these vulnerable functions were either not reused or had been patched i.e.
correct fps .
in addition t iver identified previously missed vulnerable functions i.e.
fns that were overlooked by the single version based approach because the overall version was determined based on the version to which the majority of reused functions belong.
these vulnerabilities were difficult to detect without t iver s finer grained function level versioning.
in conclusion t iver demonstrated its practicality by leveraging fine grained versioning and adaptive versions to significantly reduce both fps and fns enhancing vulnerability verification and management.
case study.
freebsd v12.
.
reuses openssh primarily based on version v 79p1 but incorporates over different versions within the reused code.
the sbom for freebsd can appear as follows using the cyclonedx format .
first t iver can identify areas where oss has been reused thereby contributing to supply chain security.
for example before pruning see listing t iver detected reused openssh functions spanning versions .
.
to .
.
.
while existing approaches considered all these versions t iver accurately pruned noisy versions identifying the adaptive version as .
.
.
by specifying the version of each reused function i.e.
lines and in listing t iver aids in sbom creation and improves vulnerability detection.
2466listing part of freebsd s cyclonedx sbom using the adaptive version identified by t iver .
?xml version .
encoding utf ?
bom xmlns version metadata ... component type operating system name freebsd name version .
.
version ... components component type library name openssh name version .
.
version ... listing supplementary material for detailed oss management includes the code areas where openssh is reused in freebsd and the versions of each reused function see section iii e .
1openssh before pruning identified adaptive version .
.
after pruning cluster c1 s adaptive version .
.
5crypto openssh freebsd crypto openssh scp.c file sink function .
.
... gss genr.c file ssh gssapi check mechanism function .
.
... contrib directory gnome ssh askpass2.c file passphrase dialog function .
.
... using t iver more advanced vulnerability management is possible.
for example searching for vulnerabilities in openssh v79p1 in the cve report3returned results but not all are relevant to freebsd .
fp example.
cve incorrect authorization in the sink function affecting up to openssh .
.
was flagged by existing approaches as affecting freebsd .
however t iver identified the sink function as originating from openssh .
.
line in listing confirming the issue was resolved in freebsd .
fn example.
cve information disclosure inssh gssapi check mechanism affecting up to openssh .
.
was missed by existing approaches focused on version .
.
.
t iver identified this function as originating from openssh .
.
line in listing showing that the vulnerability remained unpatched in freebsd .
.
but was addressed in later versions.
by identifying the functions harboring each vulnerability and validating the versions of the reused functions a process that can be easily automated t iver can detect only propagated vulnerabilities.
answer to rq4.
tiver can be practically utilized to enhance supply chain security particularly by improving the efficiency of vulnerability verification and management e.g.
eliminating fps which account for .
of the detection results from the single version based approach .
id product id585 version id openbsd openssh .
.htmlv.
d iscussion a. considering the latest versions of reused functions when t iver assesses the adaptive version for each cluster it considers the latest versions of the included functions see section iii e .
from the perspective of oss management our choice to consider the latest version can be justified.
in the latest version among the versions that a function belongs to vulnerabilities present in previous versions are resolved.
if versions other than the latest one are considered it may lead to the false impression that resolved vulnerabilities still exist resulting in fps.
hence t iver identifies the adaptive version by considering the latest versions of the reused functions.
b. using filenames as indicators for clustering tiver identifies duplicate components by examining reused file names.
while we initially used function source code for finer granularity this approach increased false alarms.
for example when different versions of oss are redundantly reused the same function may have different syntax.
addressing this requires similarity based matching but this frequently misidentifies functions with similar syntax as identical significantly reducing clustering accuracy.
we determined that this case occurs far more frequently and causes a greater loss in accuracy compared to changes in file names.
specifically when we investigated cases where file names had changed in our setup this accounted for .
of the total out of reused files .
in such cases t iver may produce incorrect results in clustering.
however this is a rare case and thus we decided that utilizing file names has advantages compared to other levels of granularity.
our experiments demonstrated that the file name based approach is sufficiently effective see section iv a .
c. applications of tiver including the aspects mentioned throughout the paper tiver can be applied in various ways to enhance supply chain security.
for example by identifying reused code areas and determining the version of each function t iver can pinpoint the modified sections which can contribute to more efficient sbom generation.
furthermore when multiple products in a product line reuse the same oss t iver can reduce management complexity by tracking the version and code areas of the oss used in specific product versions.
this can help prevent conflicts between product variations.
d. threats to validity to demonstrate t iver s generality we conducted experiments using oss components and popular software programs.
while this dataset provides valuable insights it may not fully represent the entire oss ecosystem.
next due to the lack of ground truth two annotators manually analyzed t iver s detection results.
most cases .
were clearly classified with conflicts in only out of cases resolved through discussion.
however differences in experience between the annotators introduced potential bias 2467as most conflicts were resolved in favor of the more experienced analyst.
next the concept of adaptive version was first introduced in t iver making direct comparisons with existing research infeasible.
comparisons with c neps and v1 scan aimed to demonstrate t iver s effectiveness not critique prior methods.
in addition in the experiment measuring the practicality of t iver if the cpe provides incorrect vulnerable version information our results may contain minor errors.
finally while efforts were made to align collection dates of software and oss datasets slight discrepancies may have caused minor differences between identified and actual reused versions.
e. limitations and future work despite the significant contributions of t iver several limitations should be acknowledged.
first t iver can only identify adaptive versions when the source code of the target software is provided.
next although t iver demonstrates high accuracy it struggles to correctly distinguish duplicate components where there are no overlapping files among each reused code region.
simply considering the finer granularity does not address this issue because these are more frequently changed during the oss reuse process than file names see section v b .
therefore we plan to investigate methods to utilize alternative granularities and methods to resolve this challenge.
in addition a reused function may not belong to any version of the oss due to developers custom modifications.
when identifying the version of a reused function we utilized the centris dataset which mapped functions that did not belong to any version of the oss to the version with the most similar function.
from a supply chain security perspective custommodified functions can also have considerable implications.
because this issue is more of a policy matter than a technical limitation and represents a tiny portion less than in our experiment we did not consider it in the current study if it becomes an issue we plan to conduct research on this aspect as well.
finally t iver cannot be applied in cases of oss reuse through package managers or the reuse of compiled libraries e.g.
.so or .dll as it does not handle these scenarios.
vi.
r elated work many studies have been proposed to identify reused thirdparty oss components e.g.
.
for example c entris utilizes code segmentation for identifying modified oss components.
libd employs a feature hashing technique to detect reused third party libraries.
cneps attempted to examine dependencies among oss components.
ossfp attempted to detect third party components by generating unique fingerprints of oss.
while ossfp tried to remove noise this was noise in component detection rather than in version identification which could lead to necessary code for oss version identification being mistakenly identified as noise and removed.
furthermore they failed to consider duplicate components and version diversity.
although these approaches can contribute to supply chain security by identifying third party libraries there has beenno existing approach that effectively distinguishes duplicate components see section iv a and removes noise which are prerequisites for identifying the adaptive version.
several approaches have attempted to identify the versions of third party libraries e.g.
.
c entris and v1 scan identify the predominant version of each component as the main version.
binaryai and l ibvdiff operate at the binary level to identify oss components and map them to specific versions.
ves extracts a version in binary as a single string utilizing data flow analysis.
ossp olice and l ibrarian also assign a single version to identified oss components.
l ibdb adopts a function call graph based comparison to detect third party libraries f irmsec determine the oss version with the number of matched features.
these approaches can be utilized for supply chain security through vulnerable version identification.
however they fail to overcome the version diversity issue addressed in this paper.
moreover they lack methods to effectively distinguish duplicate components and eliminate noise.
therefore they cannot be applied to solve our target problem.
vii.
c onclusion software reuse has led to the coexistence of multiple versions of oss functions within target programs making version identification and security management challenging.
in this regard we present t iver a novel approach for identifying adaptive versions of c c oss components utilizing two key techniques finer grained versioning and oss code clustering.
our experiments have demonstrated that t iver effectively identifies adaptive versions while distinguishing duplicate components and eliminating noise.
t iver can be used to perform effective vulnerability management and enhance supply chain security.
data availability the source code of t iver and the package for replicating the experimental results are available in the public repository acknowledgment we appreciate anonymous reviewers for their valuable comments.
this work was supported by institute of information communications technology planning evaluation iitp grant funded by the korea government msit no.rs 2022ii220277 development of sbom technologies for securing software supply chains and no.rs development of automated sbom and vex verification technologies for securing software supply chains .
in addition this research was supported by culture sports and tourism r d program through the korea creative content agency grant funded by the ministry of culture sports and tourism in project name international collaborative research and global talent development for the development of copyright management and protection technologies for generative ai project number rs .
2468references c. v .
lopes p. maj p. martins v .
saini d. yang j. zitny h. sajnani and j. vitek d ej avu a map of code duplicates on github in proceedings of the acm on programming languages vol.
no.
oopsla .
acm p. .
r. duan a. bijlani m. xu t. kim and w. lee identifying opensource license violation and day security risk at large scale in proceedings of the 24th acm sigsac conference on computer and communications security ccs pp.
.
x. zhan t. liu l. fan l. li s. chen x. luo and y .
liu research on third party libraries in android apps a taxonomy and systematic literature review ieee transactions on software engineering .
s. woo s. park s. kim h. lee and h. oh centris a precise and scalable approach for identifying modified open source software reuse in proceedings of the ieee acm 43rd international conference on software engineering icse pp.
.
y .
xiao b. chen c. yu z. xu z. yuan f. li b. liu y .
liu w. huo w. zou and w. shi mvp detecting vulnerabilities using patchenhanced vulnerability signatures in proceedings of the 29th usenix security symposium security pp.
.
s. woo d. lee s. park h. lee and s. dietrich v0finder discovering the correct origin of publicly reported software vulnerabilities in proceedings of the 30th usenix security symposium security pp.
.
c. liu s. chen l. fan b. chen y .
liu and x. peng demystifying the vulnerability propagation and its evolution via dependency trees in the npm ecosystem in proceedings of the 44th international conference on software engineering pp.
.
s. woo h. hong e. choi and h. lee movery a precise approach for modified vulnerable code clone discovery from modified opensource software components in proceedings of the 31st usenix security symposium security pp.
.
y .
wu z. yu m. wen q. li d. zou and h. jin understanding the threats of upstream vulnerabilities to downstream projects in the maven ecosystem in ieee acm 45th international conference on software engineering icse .
ieee pp.
.
y .
gu l. ying y .
pu x. hu h. chai r. wang x. gao and h. duan investigating package related security threats in software registries in ieee symposium on security and privacy sp .
x. zhan l. fan s. chen f. wu t. liu x. luo and y .
liu atvhunter reliable version detection of third party libraries for vulnerability identification in android applications in proceedings of the 43rd international conference on software engineering icse .
ieee pp.
.
s. woo e. choi h. lee and h. oh v1scan discovering day vulnerabilities in reused c c open source software components using code classification techniques in 32nd usenix security symposium usenix security pp.
.
a. dann b. hermann and e. bodden upcy safely updating outdated dependencies in ieee acm 45th international conference on software engineering icse .
ieee pp.
.
c. dong s. li s. yang y .
xiao y .
wang h. li z. li and l. sun libvdiff library version difference guided oss version identification in binaries in proceedings of the 46th international conference on software engineering icse pp.
.
w. tang z. xu c. liu j. wu s. yang y .
li p. luo and y .
liu towards understanding third party library dependency in c c ecosystem in proceedings of the 37th ieee acm international conference on automated software engineering pp.
.
y .
na s. woo j. lee and h. lee cneps a precise approach for examining dependencies among third party c c open source components in proceedings of the 46th international conference on software engineering icse pp.
.
r. croft m. babor and h. chen noisy label learning for security defects in ieee acm 46th international conference on software engineering icse .
ieee acm pp.
.
f. wallner b. k. aichernig and c. burghard it s not a feature it s a bug fault tolerant model mining from noisy data in ieee acm 46th international conference on software engineering icse .
ieee acm pp.
.
b. liang p. bian y .
zhang w. shi w. you and y .
cai antminer mining more bugs by reducing noise interference in 2024ieee acm 46th international conference on software engineering icse .
ieee acm pp.
.
j. wu z. xu w. tang l. zhang y .
wu c. liu k. sun l. zhao and y .
liu ossfp precise and scalable c c third party library detection using fingerprinting functions in ieee acm 45th international conference on software engineering icse .
ieee pp.
.
n. telecommunications and i. administration ntia software component transparency with sbom software bill of materials c. w. krueger software reuse in acm computing surveys csur vol.
no.
.
acm pp.
.
a. decan and t. mens what do package dependencies tell us about semantic versioning?
ieee transactions on software engineering tse vol.
no.
pp.
.
s. kim s. woo h. lee and h. oh vuddy a scalable approach for vulnerable code clone discovery in proceedings of the 38th ieee symposium on security and privacy sp pp.
.
c. team dataset for centris jul.
.
npm node package manager ctags universal ctags anytree simple lightweight and extensible tree data structure.
s. woo e. choi and h. lee a large scale analysis of the effectiveness of publicly reported security patches computers security p. .
owasp cyclonedx m. backes s. bugiel and e. derr reliable third party library detection in android and its security applications in proceedings of the 23rd acm sigsac conference on computer and communications security ccs pp.
.
m. li w. wang p. wang s. wang d. wu j. liu r. xue and w. huo libd scalable and precise third party library detection in android markets in proceedings of the 39th international conference on software engineering icse .
ieee pp.
.
z. ma h. wang y .
guo and x. chen libradar fast and accurate detection of third party libraries in android apps in proceedings of the 38th international conference on software engineering companion icse companion pp.
.
w. tang d. chen and p. luo bcfinder a lightweight and platformindependent tool to find third party components in binaries in proceedings of the 25th asia pacific software engineering conference apsec .
ieee pp.
.
l. jiang j. an h. huang q. tang s. nie s. wu and y .
zhang binaryai binary software composition analysis via intelligent binary source code matching in proceedings of the 46th international conference on software engineering icse pp.
.
x. xu q. zheng z. yan m. fan a. jia and t. liu interpretationenabled software reuse detection based on a multi level birthmark model in proceedings of the 43rd international conference on software engineering icse .
x. hu w. zhang h. li y .
hu z. yan x. wang and l. sun ves a component version extracting system for large scale iot firmwares inwireless algorithms systems and applications 15th international conference wasa .
acm pp.
.
w. zhang y .
chen h. li z. li and l. sun pandora a scalable and efficient scheme to extract version of binaries in iot firmwares inieee international conference on communications icc .
ieee pp.
.
s. almanee a. unal m. payer and j. garcia too quiet in the library an empirical study of security updates in android apps native code in proceedings of the 43rd international conference on software engineering icse pp.
.
w. tang y .
wang h. zhang s. han p. luo and d. zhang libdb an effective and efficient framework for detecting third party libraries in binaries in proceedings of the 19th international conference on mining software repositories mse pp.
.
b. zhao s. ji j. xu y .
tian q. wei q. wang c. lyu x. zhang c. lin j. wu and r. beyah a large scale empirical analysis of the vulnerabilities introduced by third party components in iot firmware inissta proceedings of the 31st acm sigsoft international symposium on software testing and analysis .
acm pp.
.