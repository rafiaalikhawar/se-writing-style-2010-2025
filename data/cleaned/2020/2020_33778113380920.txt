scaling open source communities an empirical study of the linux kernel xin tan department of computer science and technology peking university key laboratory of high confidence software technologies ministry of education beijing china tanxin16 pku.edu.comminghui zhou department of computer science and technology peking university key laboratory of high confidence software technologies ministry of education beijing china zhmh pku.edu.combrian fitzgerald lero the irish software research centre university of limerick limerick ireland bf ul.ie abstract large scale open source communities such as the linux kernel have gone through decades of development substantially growing in scale and complexity.
in the traditional workflow maintainers serve as gatekeepers for the subsystems that they maintain.
as the number of patches and authors significantly increases maintainers come under considerable pressure which may hinder the operation and even the sustainability of the community.
a few subsystems have begun to use new workflows to address these issues.
however it is unclear to what extent these new workflows are successful or how to apply them.
therefore we conduct an empirical study on the multiple committer model mcm that has provoked extensive discussion in the linux kernel community.
we explore the effect of the model on the i915 subsystem with respect to four dimensions pressure latency complexity and quality assurance.
we find that after this model was adopted the burden of the i915 maintainers was significantly reduced.
also the model scales well to allow more committers.
after analyzing the online documents and interviewing the maintainers of i915 we propose that overloaded subsystems which have trustworthy candidate committers are suitable for adopting the model.
we further suggest that the success of the model is closely related to a series of measures for risk mitigation sufficient precommit testing strict review process and the use of tools to simplify work and reduce errors.
we employ a network analysis approach to locate candidate committers for the target subsystems and validate this approach and contextual success factors through email interviews with their maintainers.
to the best of our knowledge this is the first study focusing on how to scale open source communities.
we expect that our study will help the rapidly growing linux kernel and other similar communities to adapt to changes and remain sustainable.
corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
.
.
.
open source communities scalability sustainability multiple committers maintainer workload linux kernel acm reference format xin tan minghui zhou and brian fitzgerald.
.
scaling open source communities an empirical study of the linux kernel.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
.
introduction over the past several decades open source software oss projects have grown rapidly in popularity owing to their unique advantages e.g.
low cost and high quality .
during this time many prominent projects emerged such as the linux kernel and apache http server .
at this stage many of these projects are mature and not merely hobbyist projects but rather represent critical computing infrastructure for society.
both the scale and complexity of these projects have undergone considerable changes e.g.
the linux kernel version .
has over .
million lines of code contributed by contributors representing corporations whereas version .
in had only lines of code.1these projects established their own workflows in the early stages.
in general a small core group does most of the work and coordinates with a considerably larger group of peripheral participants .
however in recent years an increasing number of contributors in several oss projects e.g.
node.js 2dpdk 3and fastlane4 have raised concerns about whether the original workflows can handle the current volume of patches which continues to increase.
this is especially the case in the linux kernel where it has triggered a heated discussion.
the code base of the linux kernel is logically organized into many subsystems each of which has a designated maintainer a contributor who possesses the commit right to the subsystem repository that s he maintains some subsystems have more than one maintainer .
almost all of the code patches are selected and transferred by the corresponding maintainers layer by layer until they are merged into the mainline repository.6it is an undeniable fact .html ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea x. tan et al.
that this hierarchical review workflow is a key factor in maintaining the high quality of the kernel .
however as the scale of the project increases these maintainers need to deal with burdensome review work such as patches in a two week period and hundreds of emails a day .
worse still many subsystems have only one maintainer which means that if those sole maintainers take a vacation become ill or simply become busy at their day job there is no one who can replace them.
meanwhile new maintainers are not easy to train they need to not only review patches but also to shoulder the responsibility of sending that work upstream and acting as a liaison for complaints arriving from other subsystems .
this series of problems have raised widespread concern from both the community and researchers .
people are concerned that the overworked maintainers may not sustain the subsystems and they may become a single point of failure resulting in the disruption of the hierarchical production.
there is a demand to adapt the original workflow to the growing workload and to sustain the community.
the multiple committer model mcm that distributes the workload to a group of contributors by giving commit rights has been created to address this problem.
it is endorsed by the subsystems currently applying it .
although this model is not rare in other projects decentralization by suddenly introducing an increased number of committers is a high risk operation for any community that experiences rapid scaleup.
it may result in unexpected problems and complaints from other maintainers .
many subsystems are reluctant to adjust change the current workflow even though it is widely accepted as problematic.
adopting an invention usually appears as a continuous and slow process because decisions are rendered difficult by the lack of unbiased information sources .
a deep understanding of the factors affecting the choice of a new workflow is essential for its adoption and therefore for resolving the workload crisis.
in this study we attempt to achieve this understanding and to help projects that are undergoing workload problems to make decisions as to how to adjust change the current workflow.
decisions are often the result of a comparison of the uncertain benefits of the new invention with the uncertain costs of adopting it .
therefore we start by seeking to understand the effectiveness of the new model and then investigate the factors most relevant to the adoption of the new model.
rq1 to what extent does the mcm work or how exactly does the mcm help to reduce maintainer s workload ?
rq2 how to apply the mcm?
.1what factors are crucial for successful implementation operation of the mcm?
.2how should candidate committers be selected when maintainers adopt the mcm?
to answer these questions we analyze the commit history of the linux kernel read related online documents and conduct interviews with maintainers.
we focus on maintainers main workload i.e.
reviewing patches and define four categories of metrics to characterize their performance pressure latency complexity and quality assurance.
we utilize these metrics to quantify the effect of adopting the mcm on the i915 subsystem which has been using it since .
we find that after the adoption pressure on maintainers review latency and the complexity of the review relationship between maintainers and patch authors were significantly reduced.at the same time the new model enforces a strict process to ensure patch quality.
after analyzing the online documents and interviewing the maintainers we recommend overloaded subsystems having the following properties to adopt the mcm there are suitable candidate committers maintainers and committers trust each other and they already have or are willing to introduce measures to mitigate risks.
based on these findings we also discuss insights for scaling oss projects.
we expect that our results will help maintainers of the linux kernel and other oss projects become more sustainable.
this work builds upon an earlier page summary .
background we examine the related work in section .
.
the traditional workflow and the new workflow of the linux kernel are introduced in section .
and section .
respectively.
.
related work as software evolves over time it becomes increasingly large and complex .
during the process of software evolution successful oss projects attract many contributors .
these contributors complete various tasks in a project which helps to establish and sustain the project.
however activities in oss projects tend to be skewed i.e a small number of people do most of the work .
this group of people often act as maintainers of projects and take responsibility for the direction of projects .
as the scale of projects expands they face increasing pressure that may challenge their capacity.
for example zhou et al.
found that the distribution of work among the linux kernel maintainers followed the rule for most modules suggesting that a few maintainers may bear the brunt of the increased workload.
these issues have caused oss projects to increasingly worry about their sustainability .
different innovations have been introduced to deal with workload and improve productivity in oss projects.
notable ones include the pull request model and the use of continuous integration ci for automated quality assurance .
for example zhu et al.
found the pull request model to be associated with reduced review time.
hilton found that of the most popular projects on github heavily use ci.
in comparison to projects that do not use ci these projects i release twice as often ii accept pull requests faster and iii developers are less worried about breaking the build .
recent studies investigated bots seeking to automate repetitive tasks in the social collaboration platform such as github .
for example the hound bot was invented to verify code style violations .
although these inventions may accelerate maintainers work the effect is limited because a lot of manual intervention is still required in patch review e.g.
determining whether a patch is necessary whether an implementation has shortcomings or whether there are better ways to implement.
this problem could be addressed by distributing the workload among members to achieve high bandwidth.
as discovered the successful evolution of oss projects depends on the co evolution of the team structure and the software structure .
the linux kernel is organized as a structured hierarchy of modules which allows flexible expansion of modules together with their maintainers .
this is the key to the success of linux.
however as the pressure on maintainers continues to increase it is clear that the current structure needs to evolve.
while the community proposes a new multi committer 1223icse may seoul republic of korea model to adapt to the changes it is unclear to what extent this model works or how this model should be implemented.
therefore in this study we aim to investigate these two questions.
the investigation can deliver insights into scaling of oss communities thus helping oss ecosystems survive the constantly changing environment.
.
traditional workflow the kernel development community is organized as a hierarchy with contributors submitting patches to maintainers who in turn commit those patches to a repository with each maintainer being responsible for their own subsystem repository and pushing them upstream to higher level maintainers.
this hierarchy logically resembles the directory hierarchy of the kernel source itself.
the process requires all maintainers in the chain to take responsibility for the patches.
the maintainers who introduce patches directly from authors take the main responsibility of reviewing patches.
the higher level maintainers who pull the patches from the lower level maintainers are responsible for conducting integration tests they usually do not review these patches.
according to the online documents reviewing patches requires considerable effort and represents the main workload for maintainers.
this is further exacerbated by the fact that the number of patches continues to increase.
maintainers may worry about burnout when undertaking such heavy review work .
in this study we focus on the main burden for maintainers i.e.
reviewing patches.
.
multiple committer model to reduce the workload of maintainers a few subsystems in the linux kernel have attempted to apply new models.
the mcm is the most discussed model in the community and was applied by the i915 subsystem in october .
as shown in figure in the traditional workflow only the maintainers have the privilege to commit patches to the repositories they maintain whereas in the mcm many core contributors are given commit rights allowing them to commit patches to the same repository as the maintainers.
because the committers7share a great deal of review work the maintainers workload is greatly reduced.
in contrasted to the committers the main job of the maintainers is to communicate externally including coordinating with other subsystems sending patches upstream and being responsible for the faults in the subsystems.
maintainer contributor traditional workflow codebase maintainer core contributor multiple committer modelordinary contributor committer figure two types of workflows of subsystems the mcm has been used by the i915 subsystem which is also called intel drm drivers supporting all integrated graphics chipsets with both intel display and rendering blocks.9its main files are under drivers gpu drm i915 of the kernel s code directory.
the number of its maintainers fluctuates between in the studied period.
as shown in figure the numbers of commits modified files contributors and committers appear to grow over time.
7in this study we refer to the regular contributors maintainers not included who have commit right to the repositories as committers.
y earnumbercommits files authors committers 100figure growth of the i915 subsystem methodology .
study design we applied a mixed method approach for this study.
figure shows the overall design of the study including the following steps.
step .
we started from collecting commit history data of the i915 subsystem and identifying the review workload of maintainers as described in section .
.
step .
we designed four categories of metrics to study the effect of the mcm as described in section .
.
step .
we reviewed the online documents related to the mcm and conducted interviews to understand which factors are important for the implementation of the mcm as described in section .
.
step .
as identified in the previous step committers is a critical success factor of the mcm but difficult to identify we borrowed the idea of collaboration network to propose an approach for selecting candidate committers as described in section .
.
step .
finally we conducted interviews within and outside node.js serves as an exemplar the linux kernel to validate the generality of the results as described in section .
.
.
identification of the maintainers workload we cloned the mainline repository of the linux kernel in june and retrieved its commit history.
because the linux kernel moved to git in we ignored the pre history.
we took steps to clean and standardize the raw data for further analysis.
each piece of data i.e.
a commit records the hash of the patch 10the author of the patch the person who committed the patch the time at which the patch was committed the description of the patch and the affected files.
for each affected file we obtained the maintainer of the file and the repository for that file at that time.
the linux kernel contains a file named maintainers that records the name of each subsystem the repository of the subsystem the names of the individuals who maintain it and the files associated with it.
we obtained a version of this file from each month since april when the file was started.11for the i915 subsystem we considered our observations to be only those commits that modified files belonging to the i915 subsystem mainly in drivers gpu drm i915 .
the linux kernel uses signed off by to track patches which is a simple line at the end of the commit message that certifies the person who wrote it or has the right to pass it on.
through communicating with three maintainers we found that generally there are two types of contributors who can add this tag to a patch the author of the patch and the maintainer who accepts it from the author.
the maintainers in the upper layers accept patches by a pull request from maintainers in the lower layers and they 10in this paper commit and patch are used interchangeably.
11for convenience we obtained the first version on the 1st of each month.
1224icse may seoul republic of korea x. tan et al.
literature maintainers filescommit history of the i915 subsystemdocuments commits reviewed by maintainersdiscover and retrieve the commit history of the i915 subsystemretrieve different versions of maintainers file derive metrics to describe maintainers workload construct models to quantify scalability of the mcmidentify maintainers review workload evaluate model effectdiscover and retrieve online materials of the i915 subsystem thematic analysis contextual success factors propose a approach to select committersinterview maintainers of the top busiest subsystems and node.js transcript select committers for the top busiest subsystems and node.jscommits history of the top busiest subsystems and node.jsretrieve the commit history of the top busiest subsystems and node.jscandidate committersvalidate the generality of mcminterview to resolve confusions complement and strengthen the factorslegend data action construct the collaboration network of the i915 subsystemstep .
step .step .
step .step .
figure overall design of the study have no chance to modify the patches.
therefore by analyzing this tag we can identify the maintainers who initially introduce the patches to the hierarchical repositories of the linux kernel.
these maintainers undertake the main workload of patch review as explained in section .
.
for each patch if the individual who signed off the patch is not the author of the patch and her his name is in the maintainers file we consider that s he actually reviewed the patch.
this allowed us to obtain the review workload of each maintainer.
if a contributor committed patches to the repositories but her his name does not appear in the corresponding version of the maintainers file we consider her him to be a committer.
if a committer signed off a patch when s he was not the author s he is considered to have reviewed this patch.
this allowed us to obtain the review workload of each committer.
.
evaluation of the model effects our sequential mixed method research approach comprised two main stages.
in the first stage we conducted a literature review to derive metrics to describe maintainer workload.12stage one concluded with the development of eight metrics across four categories.
based on these metrics the second stage involved an evaluation of whether the metrics exhibited differences before and after adoption.
note that in the second stage we did not seek to prove a causal relationship.
we do show that although the number of patches has continued to increase the burden of the maintainers is significantly reduced after adoption of mcm.
this is also consistent with the perception of the kernel community.
in this section we describe the metrics we used.
the measurement of reviewers workload is quite straightforward in the literature typically the number of patches reviewed or in the pending queue .
however we cannot conduct a comprehensive evaluation of the mcm with just those metrics.
hence we borrowed concepts and metrics that are often used to measure the performance of computer systems i.e.
throughput and latency .
we established four high level categories.
all of the metrics are aimed at a particular subsystem and a particular timespan i.e.
a month.
the related definitions and proposed metrics are as follows.
mntr the set of maintainers and committers patch the set of patches patch i the set of patches signed off by contributor i reviewer p the set of all the reviewers of patch p file p the set of files modified in patch p 12note that because maintainers and committers are all reviewers maintainer may refer to committer and maintainers may include committers in certain scenarios.
author p the author of patch p stime p the time that patch pwas signed off by maintainer atime p the author time of patch p pressure.
maintainers pressure is measured by how much review work they have done.
we define the workload of the busiest maintainer committer as the bottleneck for processing patches in the subsystem.
we also define two additional metrics that describe the distribution of the review workload among maintainers and committers that can reflect the risk of a single point of failure.
m1 maximum review workload the number of the patches reviewed by the busiest maintainer committer.
max rw max i mntr patch i m2 intensity of review workload the ratio of review workload done by the busiest maintainer committer.
intst rw max rw patch m3 entropy of review workload the dispersion of review workload assignment borrowed from information theory .
ent rw i mntrrilog2ri where r i patch i patch .
latency.
latency is a measure of the time delay experienced by a system.
in our study we define latency as the length of time from a patch being submitted by the author to the time it is signed off by the first maintainer committer.13we use this metric because a long latency implies that the maintainer may be overloaded and the possibility of conflict is high.
this metric is also used in practice by maintainers to judge whether they are overloaded .
m4 latency of review workload the median review time of the patches.
lat rw median stime p atime p p patch complexity.
the more complex the work is the more time and effort the maintainer must devote.
the complexity of the code review is found to be related to the number of files and the contact and communication with contributors .
based on these two considerations we define two metrics to characterize the complexity of maintainers review work.
we choose the maximum complexity of all of the maintainers and committers to reflect the bottleneck of the subsystem.
m5 complexity of review relationship among all the maintainers and committers the maximum number of unique 13a patch may go through several iterations versions before acceptance.
here we use the time when the last version of the patch is submitted.
1225icse may seoul republic of korea authors reviewed by a certain maintainer committer.
cplx rr max i mntr author p p patch i m6 file complexity among all the maintainers and committers the maximum number of unique files reviewed by a certain maintainer committer.
cplx f max i mntr f p patch i f filep quality assurance.
the purpose of patch review is to ensure that patches are of high quality.
instead of directly measuring quality we define the following two metrics to measure the effort strategy that is employed to deliver quality.
this is justifiable given that patch quality is very high in this community.
m7 the number of reviewers has been found to be important to ensure patch quality .
we use the average number of unique reviewers per patch including the author as the indicator of the effort strategy for quality assurance.
we retrieved all of the tags that indicated some sort of review including signed off by reviewed by and tested by.
qlty anr p patch reviewer p patch m8 some maintainers pointed out that overload caused a high number of maintainers commits to go unreviewed .
therefore we define the ratio of self commits commits authored by maintainers committers that were reviewed by others as an indicator of the strictness of review for patches contributed by contributors with commit rights.
qlty rsro p p mpatch reviewer p author p mpatch where mpatch p p patch author p mntr .
to mitigate the effects of interference and explore the scalability of the mcm that is how the model works when more committers are introduced we fitted regression models with the response being maintainer burden represented by m1 m8 and the predictor being the number of committers c .
because the burden on the maintainers is likely to be affected by the number of patches p and maintainers m we included these predictors in the models.
each observation represents a month from april to january .
we log transformed skewed variables to satisfy the assumptions of the model.
the final regression equation is ln m1...m8 ln c ln p ln m .
analysis of the contextual success factors the mcm has been stimulating wide discussion and attention in the linux kernel community for some time and many online documents have been created during this period.
therefore we conducted a qualitative analysis to help identify the factors that are crucial for successful implementation and operation of the model and then complemented and strengthened these results with a quantitative analysis on the i915 subsystem.
for the qualitative analysis we utilized the following procedures.
we first used google to search for the keywords multiple committers and linux kernel and used the top most relevant returns as our initial dataset.
we then expanded these documents 14the tags of reviewed by and tested by are usually used by ordinary contributors.table contextual success factors for the mcm higher order codes categories themes overloaded maintainers single point of failureprojects suitable candidates trust among maintainers and committerscommitters sufficient precommit testing strict review process application of tools to simplify work and reduce errorsrisk mitigation by retrieving the embedded links and iterated this process until no new document emerged.
this process resulted in documents.
we read these documents and screened the relevant documents that involve documents from official websites emails from a mailing list and articles and comments from maintainers blogs.
the documents we excluded were mainly those that were irrelevant to mcm or not about the linux kernel.
we also conducted email interviews with three maintainers including two i915 maintainers and one higher level maintainer to resolve any confusion in the documents.
we then applied thematic analysis a widely used technique for identifying and recording themes in textual documents to derive success factors of the mcm.
firstly we read and reread these documents to become familiar with them.
secondly for each document we analyzed we systematically generated initial codes related to the usage and preparation of the model.
we then examined each initial code to see whether it could be related to a more inclusive code and also whether there was an opportunity to merge codes.
for example for the sentence ontributors who want to apply for committer status should have submitted a few nontrivial patches that have been merged already we generated the initial codes non trivial patches and been merged that were mapped to the higher order code category suitable candidates.
these were then mapped to the theme committers .
we also considered edge cases where initial codes could be mapped to multiple categories.
for example the sentence ou have your standard issue overloaded bottleneck was identified as relevant to both overloaded maintainers and single point of failure.
in this case following discussion among the authors we decided to add it to the overloaded maintainers category as the main point was the overloaded maintainers and the bottleneck in this case might not lead to a single point of failure.
this analysis was supported by the maxqda tool.15the analysis revealed different themes related to the contextual success factors.
based on these themes we quantitatively analyzed the relevant characteristics of the i915 subsystem and compared them with other subsystems to augment the former results.
eventually we obtained initial codes that clustered under seven higher order codes categories.
we then compared and further abstracted these into three major themes that represent the factors critical for implementing the mcm as shown in table .
.
selection of candidate committers the analysis in section .
suggests that committers is one of the three critical success factors for the adoption of the mcm.
capable people are always the key to the success .
however for largescale projects it is difficult to identify developers with good potential to become committers we therefore proposed an approach to select committers.
1226icse may seoul republic of korea x. tan et al.
the approach is based on collaboration network which has advantages in visualizing members characteristics and relationships .
by analyzing the contextual success factors we found that developers who are suitable and achieve trust among maintainers and committers are likely to be elected as committers more details are in section rq2.
.
therefore we construct collaboration network for a subsystem to capture those elements of candidate committers.
any node irepresents a contributor.
let wibe the weight of node i defined by the number of commits authored by contributor iin a particular timespan which represents i s capability and suggests whether iis suitable.
let ci jbe the weight of the edge between nodes iandj i.e.
the number of times that the names of both contributor iandjappear in the tags from the same commit message which represents the level of trust between them.
for example if the contributor ireviewed patches from the contributor j there will be commits whose author are jand who are also tagged by i soci j .
in section rq2.
we construct the collaboration network for the i915 subsystem which proves a close relationship between the committers and maintainers.
once we construct the collaboration network for a subsystem we can use the algorithm of identifying the densest subgraph in graph theory to locate the candidate committers.
the details for the selecting approach are illustrated in section rq2.
.
.
approach for the validation to investigate the generality of the mcm we validated the contextual success factors that were derived from thematic analysis and the approach for selecting candidate committers.
specifically we had two aims validate that the contextual success factors are applicable within the linux kernel community and that the committers we selected are appropriate i.e.
they are recognized by the subsystems maintainers investigate whether these findings can apply to other communities.
for validation within the linux kernel we chose the top busiest subsystems among driver subsystems based on eq.
and calculated their candidate committers using the approach proposed in section rq2.
.16for seven subsystems we did not screen out the appropriate candidates because these candidates are already overloaded maintainers in other subsystems.
we emailed the maintainers of the remaining subsystems we chose the busiest maintainer of each subsystem to whom we sent the email.
we introduced the mcm with the quantified effect on i915 and asked the maintainers whether they were willing to try it in their subsystems.
we also provided the list of candidate committers and asked for their opinions.
eventually emails were delivered successfully and we received eight responses.
see section .
for details of the responses.
in order to validate whether our results can apply to other communities we chose to study node.js17for two reasons.
firstly node.js has experienced rapid development especially since and has become the most widely used development framework in the world today.18hence it has experienced rapid scaling issues.
secondly node.js is different from the linux kernel it has typical 16we chose two years as the timespan of commit history to construct the collaboration network.
of many github projects such as more looselycontrolled repository access.
also it has a pull request based model instead of a patch based one.
we read its official documents and interviewed via email one of its maintainers to obtain his view on scaling node.js.
specifically we showed him the contextual success factors and asked whether these factors were consistent with the scaling experience of node.js.
to validate the approach for selecting committers we applied this approach on development data between january and march rapid development period to predict committer candidates who we then compared with real committers between april and june .
results rq1 to what extent does the mcm work?
effect of the mcm.
we compared the maintainers workload before and after adoption of the mcm in the i915 subsystem based on the eight metrics described in section .
.
fig.
shows the values of the different metrics over time.19since the i915 subsystem started using this model in october we calculated the monthly mean and median values of each metric both before and after this date and removed the data before january inactive period and the data of october to reduce noise.
to determine whether these two groups of data were significantly different we utilized the mann whitney u test to compare between two independent groups .
with the exception of file complexity m6 the values of all of the metrics exhibited significant differences before and after the model was adopted.
the results are shown in table .
pressure.
as shown in fig.
a although the number of commits in this subsystem increased the number of patches reviewed by the busiest maintainer dropped significantly especially when the new model was just adopted.
before this model was adopted the busiest maintainer was responsible for over of the workload see m2 in table but after adoption this value decreased to approximately .
m3 reflects the degree of the dispersion of the work and indicates that the workload gradually distributes evenly among the maintainers and committers.
this suggests that after the new workflow was adopted the maintainers maximal workload and the risk of a single point of failure were both reduced.
latency.
when maintainers are overloaded they are unlikely to review patches in a timely manner which may delay the merging of patches.
the latency is shown in fig.
b .
after the mcm was adopted the latency decreased from approximately five days to one day.
before adoption the latency of the i915 subsystem was longer than that of the kernel but it became shorter after adoption.
complexity.
we measured the change in complexity based on the maximum number of contributors files touched by the maintainers and committers .
as shown in fig.
c the complexity of the review relationship m5 appears to be halved after adoption of the new model whereas there is no significant difference in the file complexity m6 see table .
this is reasonable because maintainers tend to have focused areas.
quality assurance.
as shown in table both m7 and m8 are larger after adoption of the model.
we also compared the i915 subsystem to the overall linux kernel as shown in figs.
d and e .
19we calculated all the metrics for both i915 subsystem and the linux kernel for comparison.
for clarity we only present the kernel comparison for a few metrics.
1227icse may seoul republic of korea table statistic results of the eight metrics of i915 subsystem metricsthroughput latency complexity quality assurance m1 m2 m3 m4 m5 m6 m7 m8 mean .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
median .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
p value r .18e .
.13e .
.03e .
.55e .
.06e .
.
.
.45e .
.44e .
in each cell the first number is the mean median of each metric per month when the traditional workflow is used.
the second number is the mean median when the mcm is used.
r represents the effect size r z n .
according to abs r .
abs r .
and abs r .5represent small medium and large effect sizes respectively.
monthnumber .
.
.
.
.01m5 developer complexity m6 file complexity0.
.
.
.
.
.
monthratio .
.
.
.
.01i915 subsystem linux kernel2.
.
.
.
.
.
monthnumber .
.
.
.
.01i915 subsystem linux kernel0 monthnumber of days .
.
.
.
.01i915 subsystem linux kernel0 monthnumber .
.
.
.
.01m1 maximum of workload m2 intensity of workload100 m3 entropy of workload a pressure b latenc y c complexit y d number of reviewers per patch e ratio of self commits reviewed by others figure changes in measurements before and after adopting the mcm before adoption of the new model the number of unique reviewers per patch was lower than that of the kernel but in recent years it has been somewhat higher.
the ratio of self commits reviewed by others in the i915 subsystem is far higher than that of the kernel and almost all of the self commits were reviewed by others after october .
it indicates that the subsystem enforces a strict review process for patches while giving commit rights to more people.
scalability of the mcm.
we fitted regression models see equation to analyze the scalability of the mcm.
the results are presented in table .
in seven of the eight models the adjusted r2was greater than .
while in the remaining one the r2was greater than .
.
except for the file complexity m6 all of the metrics were significantly associated with c p .
it suggests that when more committers are introduced the pressure latency and complexity of review relationship are reduced whereas the entropy of the workload is increased.
we further neglected pand or mto exclude erroneous results caused by multicollinearity while under this condition the effects of care undiminished.
these results indicate that the new model is scalable.
in summary we find that after the mcm was adopted the burden of the i915 maintainers was significantly reduced and also the model scales well to allow more committers.
we also find that the number of committers is negatively correlated with the time needed for patch review and the complexity of the review relationship between committers and authors.
the review workload is shared by multiple committers which can reduce the risk of a single point of failure but may require a strict process to ensure patch quality.table results of modeling m1 m8 metricln c ln p ln m f2 est std.err est std.err est std.err m1 .
.
.
.
.
.
.
m2 .
.
.
.
.
.
.
m3 .
.
.
.
.
.
.
m4 .
.
.
.
.
.
.
m5 .
.
.
.
.
.
.
m6 .
.
.
.
.
.
.
m7 .
.
.
.
.
.
.
m8 .
.
.
.
.
.
.
the data in the gray cells indicate p value .
.
f2 represents the effect size cohen sf2 r2 r2 .
according to f2 .
f2 .
and f2 .35represent small medium and large effect sizes.
rq2.
what factors are crucial for successful implementation operation of the mcm?
the above analysis suggests that the mcm works effectively on the i915 subsystem.
to apply it in more projects it is necessary to clarify the crucial factors for adoption.
by applying the approach described in section .
we obtained seven contextual success factors under three higher level factors as shown in table .
we describe these factors in detail and refer to the analyzed documents as doc and the views from interviews with maintainers as int .
for a deeper understanding of these factors we present a quantitative analysis of these factors based on the development history data of the i915 subsystem.
projects f1 .
here we focus on the factors that suggest a project urgently needs this model.
we identify two contextual success factors extracted from initial codes.
before the adoption of the mcm the maintainer of the i915 subsystem said that as the 1228icse may seoul republic of korea x. tan et al.
single maintainer he gave the subsystem a bus factor of one and when he wasn t available for any reason things simply came to a stop doc .
by distributing the commit right to more contributors the mcm can effectively reduce the workload of maintainer s and handle the risk of a single point of failure that occurs when the sole maintainer takes a break.
naturally the projects with overloaded maintainers f1.
and or single point of failure f1.
should consider using this model note this does not mean that other projects cannot apply the mcm .
we calculated the workload of the busiest maintainer of the i915 subsystem based on the number of patches signed off by him m1 .
we found that before adoption of the new model the workload of this maintainer was ranked in the top .
of all the maintainers whether considering all drivers or the overall kernel.
in contrast after just a month of adoption of the mcm he was ranked in the top .
.
other factors can also indicate that maintainers are overloaded for example difficulty in finding time to take a break or a significant increase in the review latency doc .
by analyzing the commit history data of the linux kernel from june to june we found that out of subsystems subsystems have only one maintainer indicating that they may face the risk of a single point of failure.
there are subsystems with more than active days days with commits per year whereas of them have only one maintainer.
this suggests that a number of the subsystems are taking risks so the mcm has a relatively large number of candidate projects.
committers f2 .
under this theme we identified initial codes that map to two factors.
the basic requirement for applying the mcm in a project is that there exists a group of committers having the ability to commit changes to the repository doc .
this requires that the project has the following two characteristics.
suitable candidates f2.
.
commit right is a critical aspect of open source communities .
communities are very cautious when giving someone a commit right .
as one of the large scale high quality oss projects the success of the linux kernel is closely related to the strictness of its commit access .
however the effectiveness of the mcm is achieved through relaxing the commit right to a certain extent which is a high risk operation that may affect patch quality.
to avoid this problem the community of the i915 subsystem has established a set of strict rules to elect capable contributors as candidate committers.20for example contributors who want to apply for this right should have submitted a few as a rule of thumb non trivial patches not just simple spelling fixes and whitespace adjustment that have already been merged doc .
trust among maintainers and committers f2.
.
trust in open source communities is crucial to facilitating their success .
becoming a committer means that the contributor has the maintainer s trust indicating that they are not only technically competent but also play a key role in the collaboration network e.g.
actively participating in reviews and discussions doc .
another trust related issue is that the candidate committers must put the interests of the community ahead of their own personal interests.
for example some subsystems have multiple hardware vendors that are usually competitors.3modifications by a certain vendor may not be appropriate for other vendors because their hardware commercial objectives are somewhat different.
in this case trust is obviously key within the group regardless of background or employment.
maintainers must act as gatekeepers for balancing the interests of all parties doc .
to understand whether the i915 subsystem satisfied the above requirements before adopting the mcm we followed the approach in section .
to construct its collaboration network as shown in figure .
we used the commit data of the i915 subsystem two years before it moved to the new model october to october .
the size of a node characterizes a contributor s capability and the width of edges is positively related to the level of trust between two contributors.
the nodes with labels are the contributors who were elected as committers immediately after the subsystem applied the mcm october to december .
it is clear that contributors who have contributed substantial commits and played a key role in the network would be elected as committers consistent with the results of the qualitative analysis.
this observation also underpins the approach for selecting candidate committers proposed in section rq2.
.
ville syrj l daniel vetterimre deak paulo zanoni damien lespiau rodrigo vivi jani nikulamaarten lankhorstchris wilsonmika kuoppala figure collaboration network of the i915 subsystem risk mitigation f3 .
when compared to the traditional workflow which requires all patches be reviewed by the maintainers the mcm may increase the risk of introducing bad patches after all more people means more risk and capable people are always in short supply.
worse still because a large number of patches are submitted to the same tree repository it is nearly impossible to rebase the tree.
therefore the subsystem may have to formulate a series of measurements to reduce these risks.
under this theme we found initial codes that map to three contextual success factors.
sufficient precommit testing f3.
.
there is almost no way to identify all embarrassing mistakes without testing.
this requires sufficient precommit testing to ensure that obscure corner cases do not break functionality doc .
for this purpose the i915 subsystem mainly enforces the following two practices supporting continuous integration ci and formulating detailed testing requirements.
ci helps the subsystem to adapt to changes quickly and to better ensure the quality of patches.
in particular for the drivers that support different types or versions of hardware the speed of update makes it particularly challenging to ensure the quality and robustness of patches on various platforms.
for the i915 subsystem intel provides a ci system that consists of multiple intel machines spanning as many generations and display types as possible doc .
strict rules are enforced for ci e.g.
a patch series must pass igt basic acceptance tests bat on all ci machines without causing regressions doc .
1229icse may seoul republic of korea contributors can obtain the build results in real time doc .
in addition to providing abundant hardware resources the community of the i915 subsystem sets up detailed testing requirements.
for example it requires that tests must fully cover user space interfaces.
the subsystem also does pre merge testing of patch series on a multitude of platforms so as to confirm that the changes strictly improve the state of the linux.
the results are automatically sent to contributors by emails doc .
during the interview with an i915 subsystem s maintainer he specifically pointed out that it is important to have a ci system integrated with the bug tracking system int .
strict review process f3.
.
the mcm has strict requirements for patch quality assurance even stricter than the traditional process because it involves more people .
it requires committers to be confident in the patches they push in proportion to the impact of those patches doc .
the confidence must be explicitly documented with special tags e.g.
reviewed by acked by and tested by in the commit message.
in one interview a maintainer stated that having at least two people looking at the code drastically reduces the risk of bugs and regressions int .
as shown in fig.
e almost all self commits are reviewed by others in the i915 subsystem whereas this ratio is only in the overall linux kernel.
if the committers do not feel comfortable pushing a patch for any reason technical concerns conflicting feedback management or peer pressure etc.
it is recommended to defer to the maintainers doc .
application of tools to simplify work and reduce errors f3.
.
the responsibility of a maintainer committer takes considerable time and effort.
therefore it is necessary to apply development tools to automate and simplify work.
for example the i915 subsystem employs dim to provide rich functionality to simplify the work of maintainers and committers.
it can help maintainers automatically test patches and it provides options for error filtering.
it also allows one to conveniently view and manage branches and send pull requests to the upstream branch doc .
in an interview an i915 maintainer pointed out that dim is one of the key factors in the effective operation of the mcm int .
using tools to avoid rather than correcting errors is also key to the model.
when someone makes a mistake a check should be put into the tools to prevent the mistake from recurring if possible doc .
rq2.
how should candidate committers be selected when maintainers adopt the mcm?
in order to select candidate committers for a project we first need to construct its collaboration network as described in section .
and then locate the featured densest subgraph as described below.
for an induced subgraph of a set of nodes p p1 p2 pk we define its density as density k i pwi i j pci ja where kis the number of selected nodes and is a factor to balance the capacity of individuals and the trust among the group.
the key step of our approach is to determine the densest one among all possible sets of nodes p. this problem can be solved using fractional programming and maximum flow approaches first proposed by goldberg .
apart from the density requirement we add some extra conditions to select appropriate candidates.
we force the algorithm to search for the densest subgraph containingthe maintainers of the subsystem because committers have to work with maintainers.
however if contributors are already overloaded maintainers of other subsystems we force the algorithm to exclude them.
if contributors did not do anything in the past three months in the selected date range we consider them to be inactive and not willing to review patches and thus they are also excluded.
to evaluate the effect of this approach we employed it to select committers for the i915 subsystem using the data before october and compared with the actual committers selected in october .
we found that our approach can select five out of eight true committers indicating our algorithm is of high accuracy precision .
recall .
.
we did not identify the other three because they were not active our algorithm cannot see information beyond commit history .
validation we validated that the results of rq2 are applicable within the linux kernel community.
based on the analysis of node.js community we found that the results can also apply to other communities.
.
applying the mcm in the linux kernel our first aim was to validate that the success factors and the approach for selecting candidate committers are significant within the linux kernel community.
we also wanted to gauge maintainers responses regarding their willingness to accept this model and any concerns they might have.
based on the approach described in section .
we eventually received eight responses.21six subsystems no.
expressed interest in the model indicating that we identify the projects f1 fairly well.
five subsystems no.
clearly stated that the selected candidate committers were appropriate indicating not only that the approach for selecting committers is effective but also that the requirements for committers f2 we identified are reasonable.
as for the other three subsystems they did not comment on these candidate committers because they did not need the mcm due to the scaling challenge.
below we report the views of the maintainers to help illustrate the applicability of the model for other subsystems.
the maintainers of the no.
and no.
subsystems clearly indicated that they were applying the mcm and confirmed that the candidate committers that we identified are real committers.
the maintainers of the no.
subsystem were preparing to apply this model but still lacked tooling suggesting that the practice of application of tools to simplify work and reduce errors f3.
is essential.
the maintainers of the no.
subsystem the busiest maintainer forwarded the email to another maintainer showed interest in this model.
however they have concerns regarding the candidates.
because their contributors belong mainly to two competitors mellanox and intel they worried that the decisions made by the committers from one company might harm the other.
their concerns show clearly that trust among maintainers and committers f2.
is important for this model.
we suggested them to set stricter review rules e.g.
the patches submitted by one company should be reviewed by their competitors to which they agreed.
the no.
and no.
subsystems had attempted to apply this model but 21no.
subsystems represent acpi drm drivers gpio subsystem infiniband subsystem intel ethernet drivers mellanox ethernet switch drivers multifuncti on devices mfd and radeon and amdgpu drm drivers respectively.
1230icse may seoul republic of korea x. tan et al.
eventually failed albeit for different reasons.
the maintainer of the former explained i respect all of these candidates and i collaborate with all of them but i don t think they will be interested in the role you are proposing for them.
this indicates the process of selecting committers is a two way choice between maintainers and committers and that motivation is a key factor for candidate committers to become real committers.
the maintainers of the no.
and no.
subsystems also had a similar concern.
as for the no.
subsystem the reason for the failed attempt was the heavy workload for the verification and qa teams which demonstrates the importance of testing and review f3.
f3.
and the necessity of application of tools to simplify work f3.
.
the maintainers of the no.
and no.
subsystems stated that they would not use this model.
we learned that the former subsystem was applying another kind of group model that introduced a verification team to share the review workload of the maintainer and that our approach for selecting candidate committers could afford insights.
although we found that the maintainer of the no.
subsystem was busy the 29th among driver subsystems he did not think he was overloaded at present.
research suggests that innovation is impeded by both the routine of an existing practice and perceived risks associated with the innovation .
applying this model requires practice and some time to reveal benefits.
therefore if maintainers are accustomed to the current workflow they may not want to be the first ones to change and to face new problems.
in conclusion we observed that although many kernel subsystems are interested in the mcm the application of the model is not easy.
the approach we proposed for selecting candidate committers can help maintainers identify suitable and trustworthy candidate committers and their motivation to become committers is also a key factor for actually applying the mcm.
.
applying the mcm in other communities based on the approach described in section .
we validated that the mcm is applicable to node.js.
node.js has subsystems and is currently applying a tier governance structure similar to the mcm new contributors are at the bottom providing support for more than active committers often referred to as collaborators using github s terminology .
the top layer comprises technical steering committee members similar to maintainers in the mcm .
however before there were fewer than five developers who had commit privileges.
the contextual success factors of the mcm we obtained in the i915 subsystem are also applicable to node.js.
in particular it stipulates a series of rules to guarantee the quality of patch a pull request may land if it has approval from more than two developers f3.
andpasses ci f3.
.
itapplies tools to simplify work and avoid errors f3.
e.g.
node core utils a cli command line interface toolkit for node.js core collaborators to facilitate development.22in order to select suitable and trustworthy committers f2 this community stipulates that existing collaborators can nominate someone who has made valuable contributions to become a committer.
in contrast to the i915 subsystem being nominated as a committer in the node.js community is much easier.
it may just require a number of contributions including submitting requests reviewing code reporting bugs etc.
to validate our approach for selecting committers we applied it on the development data between january and march .
compared with real committers between april and june the approach selected out of true committers precision .
recall .
.
in conclusion the contextual success factors we obtained are applicable to other communities e.g.
the node.js community and our approach can accurately identify candidate committers.
discussion we discuss the insights for scaling oss communities by comparing similarities and differences between the kernel and other communities with node.js serving as an exemplar.
.
similarities for large scale development teams the highly experienced developers are the few who are on the top of the pyramid and have commit rights to directly modify the main repository.
as the number of patches increases dramatically these developers come under considerable pressure.
in order to reduce the burden on them and effectively utilize their capability an intuitive approach is to take advantage of the developers in the middle of the pyramid to alleviate the pressure on the upper maintainers.
this hierarchical workflow is not rare in oss projects node.js apache and eclipse for example.
one way to truly scale a community is to distribute control to community members and adopt modular design.
this concept is as old as civilization.
in the agricultural revolution instead of each of us gathering and hunting our own food we created farms that would specialize in growing specific crops.
every empire or nation has a system of delegated authority to local powers.
this is the case even in highly regimented systems such as the crew of a nuclear submarine.
in his book turn the ship around!
captain david marquet showed that the distribution of control and ownership is the most efficient method for improving execution and developing leaders .
as for oss communities which are structured hierarchically re routing code review tasks originally destined for top layer to middle layer developers by giving them commit rights is a good option.
this allows senior developers to focus on complex issues rather than more trivial matters.
decentralization also needs supervision.
for large scale oss projects quality is always paramount all the more so since these systems now provide the critical infrastructure for society.
both the i915 subsystem and node.js reduce the review burden by distributing commit rights to the lower level who do surface quality risks.
consistent with our findings node.js has formulated a series of measurements to mitigate these risks e.g.
any committer is authorized to approve any other contributor s work but they are not permitted to approve their own pull requests.
this suggests that when delegating maintainer authority code review and testing must be stricter for which our analysis provides specific recommendations.
.
differences although the i915 subsystem and node.js both introduced multiple committers the requirement for committer capability is different.
linux is the world s largest and most pervasive oss project.
the 1231icse may seoul republic of korea linux kernel is the largest component of the linux operating system and is charged with managing the hardware running user programs and maintaining the security and integrity of the whole system.
compared to other projects contributing to the linux kernel is more difficult because developers have to understand the basic principles of a computer system to understand the intricacies of the hardware and software which is also confirmed by the maintainer of node.js.
he said for most projects on github most contributions are not very complex and only need a few adjustments e.g.
compliance with basic style requirements that represent one of the largest burdens during review.
however the bar for contributing to the linux kernel is so high it provides a natural filtration mechanism .
it is easier to become a committer in node.js after several contributions which can explain why there are more than active committers conducting reviews in node.js whereas in the i915 subsystem becoming a committer is not so easy.
furthermore committers may be unwilling to review code because it takes considerable time and effort see section .
.
these are the main reasons why the phenomenon of multiple committers is common in other oss communities but has aroused a heated discussion from the kernel community.
in addition the involvement of many hardware vendors with conflicting interests in the linux kernel makes it more difficult to select appropriate committers.
one possible solution is training candidate committers as early as possible and encouraging developers to integrate code review into their daily routine.
any time a change occurs it should be communicated to the different stakeholders who can make the appropriate adjustments in accordance with the objectives of the project instead of personal interests.
limitations we identified the review workload of the maintainers by looking at the signed off by field in the commit messages and the maintainers file which enables us to confirm that the individual named by the signed off by field is indeed a maintainer.
however some problems are difficult to avoid e.g.
individuals who do not wish their names to appear in the maintainers file are excluded.
also because the time of signed off by of a patch is not recorded we used the commit time instead when calculating the review latency.
this may not accurately reflect the review time of maintainers who do not use git since in this case the patches are usually committed by higher level maintainers.
because we analyzed only the mainline repository of the linux kernel a large number of patches that did not gain acceptance into the mainline repository were excluded .
reviewing these patches also consumes maintainers time.
however according to zhou et al.
it is easier for the maintainer to not accept the code at all.
to accept code it takes time to review it apply it handle problems that may ensue possibly fix any problems that happen later on when contributors disappear and maintain it for the next years.
therefore it is reasonable to regard the review workload of the accepted patches as the main burden on the maintainers.
to increase construct validity we interviewed linux kernel maintainers and inspected various online resources.
also the qualitative analysis was complemented and strengthened by quantitative validation.
for example we attained a reasonable understanding of the main burden on maintainers by reading relevant online documentation and by communicating with the maintainers.
after deriving thecontextual success factors for the mcm we also explored whether the i915 subsystem satisfied these factors quantitatively and confirmed our findings based on the feedback from the maintainers of the kernel community and node.js community.
threats to external validity mainly come from two sources.
studying only the i915 subsystem limits external validity.
the mcm was first adopted by i915 in the linux kernel and while the model has been applied by a few subsystems since the i915 is the one that has used the model for a relatively long time which enables us to explore the effect by analyzing the development history data.
however precisely because there are only a handful of subsystems attempting to use the new workflow studying the model is necessary and timely.
the uniqueness of the linux kernel limits external validity.
as a prominent oss project the linux kernel has many unique practices that have been referenced and used by many other projects .
we found that oss projects that emulated the traditional kernel review process also encountered the pressure on maintainers e.g.
the dpdk project.3the implication of delegating commit rights and suggestions for risk mitigation are applicable to general oss projects as discussed in section .
and section .
our framework for quantifying the maintainers workload and our analysis of the mcm may benefit both the subsystems of the linux kernel and other projects encountering similar problems.
conclusions the scaling of oss projects is a common and challenging problem that determines whether projects which are growing can be sustained.
however no in depth study of this topic has been published.
in order to address this problem we conducted an empirical study of the linux kernel which is struggling with scaling issues many developers have raised concerns regarding whether the current development workflow can handle the increasing number of contributors and patches.
while the current workflow guarantees a strict review process it places significant pressure on maintainers who bear the risk of a single point of failure.
we investigated a new model the mcm that has been adopted by the i915 subsystem in the linux kernel to relieve the burden on maintainers.
we found that after adoption the maintainers workload were significantly reduced.
a review process is strictly enforced to guarantee the quality of patches and the effect of the model increases when more committers are introduced.
for other projects with overloaded maintainers if there are trustworthy candidate committers and measures for risk mitigation they are suitable for this model.
our proposed framework to quantify the review workload of maintainers may lead to a better understanding of the factors that impede rapidly growing projects.
knowledge of the factors for implementing the mcm and the approach for selecting candidate committers can help other suitable subsystems to optimize their workflow to achieve a more efficient review process while scaling up.
to facilitate replication of our work or other types of future work we provide the data scripts and retrieved materials used in this study in 33d1a7540c8dc449b90d4771f6dd52ba45e26879 .