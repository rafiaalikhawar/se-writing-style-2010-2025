kg4crasolver recommending crash solutions via knowledge graph xueying du fudan university shanghai chinayiling lou fudan university shanghai chinamingwei liu fudan university shanghai china xin peng fudan university shanghai chinatianyong yang fudan university shanghai china abstract fixing crashes is challenging and developers often discuss their encountered crashes and refer to similar crashes and solutions on online q a forums e.g.
stack overflow .
however a crash often involves very complex contexts which includes different contextual elements e.g.
purposes environments code and crash traces.
existing crash solution recommendation or general solution recommendation techniques only use an incomplete context or treat the entire context as pure texts to search relevant solutions for a given crash resulting in inaccurate recommendation results.
in this work we propose a novel crash solution knowledge graph kg to summarize the complete crash context and its solution with a graph structured representation.
to construct the crash solution kg automatically we propose to leverage prompt learning to construct the kg from so threads with a small set of labeled data.
based on the constructed kg we further propose a novel kg based crash solution recommendation technique kg4crasolver which precisely finds the relevant so thread for an encountered crash by finely analyzing and matching the complete crash context based on the crash solution kg.
the evaluation results show that the constructed kg is of high quality and kg4crasolver outperforms baselines in terms of all metrics e.g.
.
.
mrr improvements .
moreover we perform a user study and find that kg4crasolver helps participants find crash solutions .
faster and .
more accurately.
ccs concepts software and its engineering maintaining software software evolution software testing and debugging .
keywords crash solution recommendation knowledge graph stack overflow x. du y. lou m. liu x. peng and t. yang are with the school of computer science and shanghai key laboratory of data science fudan university china.
m. liu is the corresponding author liumingwei fudan.edu.cn .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
reference format xueying du yiling lou mingwei liu xin peng and tianyong yang.
.
kg4crasolver recommending crash solutions via knowledge graph.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
introduction software crashes have been widely recognized as a type of serious bug and should be fixed in a high priority.
resolving crashes is challenging and time consuming and developers often turn to online q a forums for help e.g.
stack overflow by discussing their encountered crashes or referring to other similar crashes and solutions.
as shown by previous work crash bugs have been actively discussed on stack overflow so i.e.
out of .
million java related so threads are about crashes which provide a large amount of crash solution knowledge for developers.
however describing and understanding a crash often involve very complex contexts.
in addition to the code and the reported crash traces precisely diagnosing the root cause of a crash also relies on the environment that the project is configured with the purpose of the developers writing the code and the symptom of the crash.
therefore developers often write very lengthy posts to describe their encountered crashes.
based on our statistics the average length of the java exception related so threads is around words.
as a result it takes developers a lot of time to search and read many relevant so threads among which they further find the one that shares the most similar crash context as theirs and then fix their own crash based on its solution.
to alleviate the manual efforts in navigating through so many lengthy so threads and to help developers quickly find the solution for their encountered crash researchers have proposed to automatically recommend crash solutions by finding the so thread that discusses the same similar crash context as the encountered one .
existing crash solution recommendation work identifies relevant so threads for a given crash by only searching with the code or the crash trace which have not considered other important elements in contexts e.g.
environment symptom or the purposes of the project .
however these contextual elements are also essential for developers to diagnose the crash.
for example two crashes with the same code snippets and the same crash traces could be caused by different reasons if they involve different environments e.g.
using different versions of the library .
as aesec fse december san francisco ca usa xueying du yiling lou mingwei liu xin peng and tianyong yang result using such an incomplete context to identify relevant so threads could be inaccurate.
in addition for existing techniques that recommend solutions for general software engineering problems by mining online q a forums they actually have limited effectiveness in crash solution recommendation since they concatenate different crash contextual elements e.g.
code and natural language descriptions into a long textual query and such a purely text matching would also lead to inaccurate recommendation results.
to address these limitations we propose a novel crash solution knowledge graph kg which summarizes the complete crash context and its solution with a graph structured representation.
in our crash solution kg the nodes represent different elements in the crash context while the edges represent the relationships between elements.
to construct the crash solution kg automatically we propose to leverage prompt learning to construct the kg from so threads with a small set of labeled data.
based on the constructed kg we further propose a novel kg based crash solution recommendation technique kg4crasolver which precisely finds the relevant so thread for an encountered crash by finely analyzing and matching the complete crash context based on the crash solution kg.
the benefits of recommending crash solutions based on the kg are as follows.
first compared to existing crash solution recommendation techniques that only use code or crash trace in the crash context our crash solution kg is able to represent a complete crash context with all the different elements.
second compared to existing general solution recommendation techniques that simply concatenate different contextual elements into a long textual query our crash solution kg represents the crash context in a more structured way by representing different elements and their relationships with nodes and edges.
therefore compared to these techniques our structured and comprehensive representation of crash contexts enables fine grained and precise context matching between a given crash context and candidate so threads.
in addition with such a kg kg4crasolver could further explain each recommended solution with matching details e.g.
the matching scores in different elements and summarize the solution in a more concise way which increases the usability and readability of the recommended solution for developers.
we construct a crash solution kg with nodes and edges for common java exceptions from so threads and further implement kg4crasolver as an automatic tool.
we first evaluate the effectiveness of our kg construction and find that each key step achieves high precision.
for example our construction approach classifies different sentences e.g.
symptoms or reasons in the crash context with .
precision and .
recall and it further extracts fine grained phrases e.g.
environment from classified sentences with .
bleu and .
em exact match .
we then evaluate the effectiveness of solution recommendation on a newly constructed benchmark of crash bugs from so duplicate question records.
the results show that kg4crasolver outperforms five baselines on the mrr mean reciprocal rank and hit .
furthermore to evaluate the practical usefulness of kg4crasolver for developers we then conduct a user study by asking participants to find solutions for crash bugs with kg4crasolver.
the results show that compared to using baselines the participants could find solutions more accurately .
and faster .
with the helpof kg4crasolver.
moreover we survey the participants and their feedback shows that they consider the solution summary generated by kg4crasolver as complete concise easy to read and useful.
in summary this paper makes the following contributions.
a new knowledge graph for crash solutions that summarizes the complete crash contexts and solutions in a structured and comprehensive way a novel approach for crash solution kg construction that leverages prompt learning to automatically construct the crash solution kg with a very small set of labeled data a novel crash solution recommendation technique kg4crasolver that analyzes the complete context of an encountered crash and finds the relevant so thread in a fine grained manner based on the crash solution kg an extensive evaluation that demonstrates the effectiveness of our kg construction and crash solution recommendation and also shows the practical usefulness of kg4crasolver with a user study.
crash solution kg definition in this section we introduce how we define our crash solution kg.
in particular we first perform a pilot study on a small dataset of so threads to understand what kind of information is commonly included in crash related so discussions and then we design our kg for crash solution based on the results.
pilot study.
we first collect a dataset of crash related so threads.
a thread includes a question with the corresponding answers.
in particular from so data dumps we randomly sample threads that i are related to crash solution with one specific exception type in their question titles or tags and ii have an accepted answer.
similar to previous work we annotate all information units in the threads i.e.
the title tags and all sentences in the question and answer based on what kind of information it could provide to describe the crash context and solutions i.e.
crash descriptive elements and solution descriptive elements .
our annotation follows an open coding procedure which involves three of the authors in discussion.
we start with three codes from previous work i.e.
erroneous implementation error type and error occasion.
during the annotation process if none of the existing codes is applicable we create new codes or refine the names and definitions of existing codes after discussions.
in this way we summarize nine elements that cover the essential crash descriptive information and solution descriptive information in crash related threads.
table further shows the detailed definitions and examples of each element.
an element of a text type is described by natural language and an element of a non text type is described in structured domain specific language e.g.
code .
in particular purpose symptom environment erroneous code crash trace and exception type are elements extracted from the question in so threads and the others are extracted from the answer.
kg schema.
based on these elements we further design the kg for crash solutions.
fig.
shows the conceptual schema of our kg.
in particular the kg consists of two parts the crash scenario knowledge i.e.
the orange part and crash solution knowledge i.e.
the blue part with the elements extracted from the question and answer respectively.
in terms of relation connections the elementskg4crasolver recommending crash solutions via knowledge graph esec fse december san francisco ca usa table definitions of elements in crash solution kg name type definition example purpose text describe the task that the developer wants to complete serving as the background of the crash bug.i am trying to implement a chat application in java using udp for multiple clients.
symptom text describe the situation when the crash occurs which includes the operation before the crash occurs program running status and unexpected program outputs.when i run antlr testparser.g4 javac .java the parser code gets generated and compiled.
when i run grun testparser testrule gui i get the error.
environment text describe the environment where the crash bug occurs such as programming languages operating systems and libraries.java spring spring security spring boot spring boot version .
.
.release reason text describe the root cause of the crash.
in your class user you don t have a name property.
solution step text describe the solution steps of the crash.
the problem is solved by just undeploying and redeploying the respective portlet in liferay.
erroneous code non text buggy code snippets that trigger the crash.
public class cloning cloning c new cloning ... solution code non text correct code snippets that fixes the crash.
static cloning c new cloning crash trace non text error messages and stack traces that are reported with the crash.exception in thread main java.sql.sqlexception can t create table sensors db.one errno at com.mysql.jdbc.sqlerror... exception type non text exception type of the crash.
nullpointerexception related to the crash scenario are centered around the concept node and the elements related to the crash solution are all connected to the concept node .
the solved by relation connects to .
moreover the sentences describing the causes of the exception or the sentences describing the symptoms of the exception are connected by succession relations similarly the sentences describing the are connected by followed by relations.
succession purpose crash tracesuccession reason solution step has erroneous codesolutionfollowed by solution codecrash scenario knowledgecrash solution knowledgeaccompanied byinclude providetype ofhas purposeerroneous codecontext ofhas environmentexplain exception typethrowcorrespond tosymptom crash bugenvironment solved by context of figure conceptual schema of crash solution kg crash solution kg construction in this section we propose an automated approach to construct the crash solution kg from so threads.
the key challenge in constructing such a kg from the massive online corpus is to precisely identify different elements in each so thread.
existing sentence classification and phrase extraction techniques are all learning based approaches and require a large amount of labeled data for model training.
however in our task there is no high quality and readymade labeled data and it is time consuming to manually annotate such a large training dataset.
to this end we propose a few shot learning based approach for crash solution kg construction which leverages prompt learning to precisely identify different elements in so threads with a small set of labeled data.
fig.
shows the overview of our kg construction approach.
step section .
given a large number of so threads we first identify high quality crash related threads which serve as the input of the kg construction.
step section .
we then leverage template based rules to identify non text elements i.e.
crash trace erroneous code and solution code from the question and the answer of each thread.
step section .
we then identify crash descriptive sentence from the question paragraphs and identify solution descriptive sentence from the answer paragraphs by utilizing prompt learning for sentence classification.step section .
we further extract crash descriptive phrases i.e.
purposes and environments from crash descriptive sentences identified in step .
after all the elements have been extracted from so threads we add them to the crash solution kg and establish the relevant relationships according to the schema in fig.
.
crash related thread identification crash descriptive sentences non text content analysis crash solution descriptive sentence classificationcrash descriptive phrase extraction crash solution kgcode tags exception trace symptom reason solution steppurpose environmentquestions answers questions answers so threads figure overview of crash solution kg construction title tags erroneous code solution codetext text textcrash trace figure example of a crash related thread .
running example in this section we illustrate how we construct the kg with a running example.
fig.
shows a so thread which discusses how toesec fse december san francisco ca usa xueying du yiling lou mingwei liu xin peng and tianyong yang display it on jsp display results from poolquestion tablei have results from query and i would like to display it on jspthis literally means that the mentioned class com.example.bean doesn t have a public non static!
the value that i want to display is answer i have loop and i would like to display results from poolquestion table which is join table note that the field itself is irrelevant here the public getter method name must start with get followed by the property name which is capitalized at only the first letter of the property name as in foo.
for boolean not boolean!
properties the getter method name must start with is instead of get.org.apache.jasper.jasperexception an exception occurred ...query query session.createquery ...public foo getfoo return foo crash bug propertynotfoundexceptionexplainsuccession accompanied byhas purposecorrespond to type ofhas erroneous codecrash solution followed byprovideinclude context of throwsolved bysuccession succession jsp has environmentthe above code doesn t works.succession figure an example of crash solution kg fix a propertynotfoundexception exception.
the accepted answer shows that this exception occurs as the program accesses a property without public getter methods.
fig.
shows part of the crash solution kg constructed for this example where orange ellipses and blue ellipses denote crash descriptive elements and solution descriptive elements respectively.
after identifying the example in fig.
as a crash related thread in step we then extract the non text descriptive elements from the thread in step .
for example the crash trace org.apache.jasper.jasperexception an exception occurred processing jsp page web inf views home.jsp at line the erroneous code c foreach items pools var pool ... and the solution code public foo getfoo return foo are extracted as non text descriptive elements in fig.
.
in step the descriptive sentences are classified into the symptoms e.g.
the above code doesn t works.
reasons e.g.
note that the field itself is irrelevant here... and solution steps e.g.
the public getter method name must start with get... with our prompt learning based sentence classification.
in step the key phrases in the purpose e.g.
display it on jsp and environments e.g.
jsp are further extracted from crash descriptive sentences with our learning based phrase extraction.
in this way we extract fine grained crash scenario knowledge and crash solution knowledge to construct the kg which then can be used to support kg based crash solution recommendation in section .
.
crash related thread identification this step extracts high quality crash related threads from so data dumps as the input for constructing the crash solution kg.
in this work we focus on crash bugs in java programs given their prevalence .
with the following criteria we select the threads that have java in the title or tags have exception or error in the title or tags have an accepted answer have a positive vote for its question and contain at least one specific exception type e.g.
nullpointerexception in the given exception type list.
to build a pool of common java exception types we systematically parse java libraries from maven central according to the libraries.io dataset and jdk .
and extract the names of all classes that are a subclass of java.lang.exception orjava.lang.error .
to guarantee the quality of the solutions we only keep the accepted answers in threads.
we further group the crash related threads of the same exception type together.
.
non text content analysis for a crash related thread we first extract its non textual elements i.e.
crash traces erroneous code and solution code from the non textual content.
first we use beautifulsoup to parse the question and the answer from html format to clean text and extract the non text content wrapped by pre code code pre or blockquote blockquote .
we then classify the extracted content into one of three categories namely code snippets crash traces and others.
the classification is based on the list of regular expressions proposed by liu et al.
in their previous work on so content analysis.
the code snippets identified from the question are erroneous code while the code snippets identified from the answer are solution code as shown in figure .
from the identified crash traces we further identify the exception message by matching with regular expressions.
for example from the crash trace shown in figure we identify the exception message javax.el.propertynotfoundexception property answer not found on type com.pool.app.domain.pool .
we replace the recognized non text content with a placeholder code and then split the question and the answer into sentences using spacy for the following sentence classification section .
.
where necessary a .
was added after code to ensure that the following sentence splitting is correct.
.
crash solution descriptive sentence classification in this step we identify crash solution descriptive sentences from the remaining textual content in the thread via a prompt based text classification model.
we then introduce the definition of the task section .
.
the design of the prompt based learning model used section .
.
and the concrete implementations section .
.
respectively.
.
.
task definition.
for sentences in crash related threads we classify them into one or more of the following five categories i.e.
purpose symptom reason solution step and others .
the definitions for the first four categories are shown in table and the sentences e.g.
thanks.
or i was finally able to solve this.
without any concrete information on crashes and solutions are categorized asothers .
in particular a long sentence might contain information of multiple categories.
therefore we formulate our sentence identification problem as multiple binary classification tasks which separately train a binary text classifier for each of the four categories except others and yield binary outputs yof positive orkg4crasolver recommending crash solutions via knowledge graph esec fse december san francisco ca usa negative.
specifically we apply the text classifiers on sentences in the question to identify purpose andsymptom categories and apply the text classifiers on sentences in the answer to identify reason andsolution step categories.
sentences that do not fall into any of these four categories would be regarded as in others category and would be filtered out then.
.
.
model design.
fine tuning a pre trained language model plm for downstream tasks e.g.
text classification machine translation named entity detection has achieved great success and been widely adopted in various domains .
however to achieve good results on downstream tasks it still requires enough labeled data to fine tune the plms in a supervised way.
prompt based learning is a new paradigm in the nlp field for using knowledge in plms .
its idea is to narrow the gap between the downstream tasks and the pre training task by converting the training objective of downstream tasks into a similar form as the pre training stage i.e.
the mlm objective .
as shown in fig.
a natural language prompt i.e.
i think it the reason for this the problem.
is added to the input sentence to make the input format identical to the pre training stage and then the plm will predict the mask token as the pre training task.
prompt based learning methods generally require much less training data compared to traditional supervised learning and have been widely used for fewshot learning or even zero shot learning .
therefore we build our text classifiers based on prompt based learning which only requires a small set of labeled data for fine tuning.
this literally means that the mentioned class com.example.bean doesn t have a public non static!
getter method for the mentioned property foo.
reason i think it the reason for the problem.
is isn tfilled with predicted answer prompt input plm ... othersoutput answer istrue answer cls sep figure an example of prompt based text classification we then detail how our prompt based sentence classifiers work with the example in fig.
.
the original input xis modified with a template into a textual string prompt x that has some unfilled slots and then the plm probabilistically fills the unfilled information to obtain a predicted answer z from which the final output ycan be derived.
in fig.
the input xis the sentence to be classified and the output yis whether the sentence is reason or not.
the prompt functionfprompt x is a function that converts the input into a specific form by inserting the input xand adding a slot where answer zmay be predicted and filled in by the pre trained model.
the predicted answer zwill later be mapped into y corresponding to different class labels.
for example when the predicted answer is a word expressing affirmation e.g.
is the sentence xwill be classified as reason and when the predicted answer is a wordexpressing negation e.g.
isn t the sentence will be classified as others .
for each category of classifier we define the corresponding fprompt x to modify the input text xinto a prompt i.e.
x fprompt x .
it contains three parts for inserting the input x a textual string for the prompt and a slot for the plm to fill later.
purpose i think that is the reason for this problem.
symptom i think this the situation.
reason i think it the reason for this the problem.
solution step i think it a solution for exception repair.
we map each sentence class label we defined to a set of label words or phrases.
the true answer z is defined as is for the positive class label and is not or isn t for the negative class label.
for the example in fig.
the true answer for the prompt is is and the sentence is classified into reason .
.
.
model implementation and dataset construction.
we implement the prompt based text classifier by using openprompt an open source framework for prompt learning with two thousand stars on github.
we build our approach based on the bert base model uncased one of the most representative plms.
we fine tune the classifiers on our training dataset with the following hyperparameters crossentropyloss as loss function adamw as optimizer learning rate .
and training epochs.
to construct the training dataset we randomly select java crash related threads from section .
and manually annotate the sentences in these threads into the five categories.
note that a sentence may be classified into multiple categories if it contains diverse information.
as a result we obtain and sentences for purpose symptom reason solution step and others respectively.
we separate the labeled sentences obtained from the question i.e.
purpose symptom others and those obtained from the answer i.e.
reason solution step others .
for each classifier its positive samples consist of annotated data for the corresponding category while the negative samples consist of all remaining sentences in the question or answer.
the whole labeling process takes about man hours.
such manual costs are much less than traditional supervised learning and fine tuning methods e.g.
previous work takes man hours to label so threads for the sosum dataset construction .
.
crash descriptive phrase extraction in the last step we extract the crash descriptive sentences i.e.
purposeandsymptom from the question.
in fact some crash descriptive sentences contain fine grained descriptive phrases that summarize the purpose verb object phrase and environment noun phrase of a crash.
for example the phrases jsp and display it on jsp in the sentence i have results from query and i would like to display it on jsp summarize the environment and purpose respectively.
compared with the whole sentence these descriptive phrases often contain fewer noise words which is beneficial for more accurate matching in the subsequent solution recommendation.
therefore in this step we further extract crash descriptive phrases i.e.
purposes and environments from the crash descriptive sentences.
we then introduce the task definition section .
.
the design of theesec fse december san francisco ca usa xueying du yiling lou mingwei liu xin peng and tianyong yang eqa based phrase extraction model section .
.
and the concrete implementations section .
.
respectively.
.
.
task definition.
in this step we focus on extracting the descriptive phrases that are related to purposes and environment from the crash descriptive sentences.
we currently do not extract phrases for other elements such as symptoms and reasons given their complexity and diversity in expression.
in summary the task in this step is to extract continuous spans that represent purposes and environment from a given sentence.
.
.
model design.
our phrase extraction task is actually a named entity recognition problem which is often tackled by a sequence tagging model based on a plm model such as bert .
however it requires a large amount of labeled data to train a sequence tagging model since the model needs to predict the tag for each token in the sentence .
our idea is to convert the phrase extraction task into an extractive question answering task which aims finding an answer i.e.
a segment of text or span in a given context paragraph for a specific question .
in this way the extractive question answering task could be done by designing appropriate questions as prompts for pre trained models.
some researchers have designed a bert based eqa model which combines the question and the context paragraphs as the input and predicts the start token and end token of the answer span with a confidence score as the output.
these eqa models have been pretrained in large scale question answering datasets e.g.
stanford question answering dataset squad with questionanswer pairs on articles which have good performance and generalization in extractive question answering.
as shown in figure based on the trained eqa model we combine the crash descriptive sentence as the context and some prompts designed specifically for the descriptive phrases as the question as the input and take the output of the eqa model as the phrase extraction results.
in the example illustrated in figure we performed phrase extraction on the sentence i have loop and i would like to display results from poolquestion table which is join table yielding the extracted purpose phrase display results from poolquestion table .
note that the extraction result of an eqa model is the special token the start of a sentence representing that the model cannot find any answer span from the given context.
in this way we can obtain more flexible extraction results without a large amount of annotated training data.
i have loop and i would like to display results from poolquestion table which is join table what do i want to do?cls sep sep context0.
question .
.table .
.... .
.
.
.to .
.... .
.would .
.like .
.poolquestion .
.display .
.results .
.from .
start label end label eqa model figure an example of eqa based phrase extraction in particular we design the following question prompts.
environment what are the tools and their versions?
what are the environment using tools and their versions?
what are the environment?
what are the using tools?
purpose what am i trying to do?
what do i want to do?
what is the purpose of the project?
what is the goal of the project?
to ensure the quality of extracted phrases we filter out the phrases with low confidence score i.e.
less than .
the phrases without alphabetical characters the environment phrases with more than five words and the phrases with the placeholder token code or the words exception error or code .
.
.
model implementation and dataset construction.
to achieve better performance we propose to fine tune the eqa model with a few data samples i.e.
few shot learning instead of directly using eqa model with the designed question prompts i.e.
zero shot learning .
to this end we build a training dataset for the phrase extraction task by further annotating the sentence classification dataset constructed in section .
.
.
each sample should include three aspects of information the context original sentence to be extracted the question prompts and the extracted answer span.
to enhance the data and allow the model to fully learn different question prompts we apply different question prompts to the same sentence to get different training data.
as a result the dataset includes and samples for purpose phrases and environment phrases respectively.
we implement the phrase extraction model based on transformer a python library providing apis to easily download and to train state of the art pre trained models.
we choose the fine tuned checkpoint of the pre trained distilbert i.e.
distilbertbase uncased distilled squad as the base eqa model which has been trained on squad dataset .
based on it we use the labeled samples to further fine tune it to obtain the final phrase extraction model.
to fine tune the model we use the adam optimizer with a learning rate of .
for a total of training epochs.
kg based crash solution recommendation based on the crash solution kg we further design a crash solution recommendation approach kg4crasolver which precisely identifies the relevant solutions for a given crash by analyzing and matching the complete crash context.
fig.
presents the overview of kg4crasolver which includes four steps i.e.
crash descriptive element extraction candidate solution retrieval candidate solution re ranking and solution summary.
given a crash and its corresponding detailed crash description as input kg4crasolver first extracts each crash descriptive element e.g.
purposes environments and crash traces in the same way as the kg construction second for each crash descriptive element kg4crasolver leverages bm25 based lexical similarity or bert based semantic similarity strategies to retrieve candidate solutions third kg4crasolver further re ranks candidate solutions based on the similarity scores of all crash descriptive elements.
lastly kg4crasolver generateskg4crasolver recommending crash solutions via knowledge graph esec fse december san francisco ca usa a comprehensive summary of the recommended solutions by including the solution crash description and other matching details.
crash solution kg candidate solution retrieval solution summarycrash descriptioncrash descriptive element extractiontitle erroneous code environment purpose symptomcrash trace exception type message crash descriptive information candidate solution re rankingbm25 based lexical matching bert based semantic matching developer candidate solutionsrecommended solutionsexception type recommended solutions with summary figure overview of kg4crasolver .
crash descriptive element extraction given a crash and its crash description e.g.
example in fig.
as input this step extracts all the crash descriptive elements via the same method as section .
to section .
.
in particular we extract the following crash descriptive elements including exception type title purpose symptom environment erroneous code exception type message and crash trace which are then used in the subsequent candidate solution retrieval and re ranking.
.
candidate solution retrieval in this step kg4crasolver leverages each extracted crash descriptive element to retrieve relevant crashes from our constructed kg and regards their solutions as candidate solutions.
first kg4crasolver selects out all the crashes that have the same exception type as the given crash.
among these crashes we then retrieve the top k k 30in our implementation crashes with the highest similarity with each crash descriptive element respectively.
we then consider the solutions of all these retrieved crashes as our candidate solutions.
as for the similarity calculation we leverage two strategies for different crash descriptive elements given their different characteristics i.e.
bm25 based lexical matching for environments erroneous code crash trace title exception type message and bert based semantic matching for symptom and purpose.
we then detail the two matching methods in section .
.
and .
.
.
.
.
bm25 based lexical matching.
bm25 has been extensively used in many search engines and it is an efficient information retrieval method that mainly matches based on keywords.
the code crash trace and exception type message are often in a structured format and environments and title are also short phrases or sentences with concise keywords.
therefore bm25 based lexical matching is inherently more suitable for these crash descriptive elements.
specifically the bm25 similarity score between the query qand the dis computed as equation where f wi q is the wordwi s term frequency in query q idf wi is the inverse document frequency of wordwi.kandbare two free parameters which are used to normalize the range of term frequencies and control the influence of document length.
simbm25 q d n i 1idf wi f wi q k f wi q k b b q avgdl we implement bm25 based lexical matching based on elasticsearch a search engine based on the lucene library using bm25 as the default score function.
each element is cleaned with standard preprocessing procedures i.e.
tokenization lemmatization and stop word removal before matching.
.
.
bert based semantic matching.
recently bert based semantic matching methods have become popular which can preserve the semantic related sequential information .
the method includes a bi encoder based retrieval step and a cross encoder based re ranking step.
in the bi encoder based retrieval step it uses a bert based sentence embedding model to map the query and the documents to a high dimensional vector space where sentences with similar semantics are close and then select candidate documents based on the similarities of their vector representations.
in the cross encoder based re ranking step it uses a bert based sentence relevance prediction model to predict the relevance between the candidate documents and the query and re ranks the candidates based on their relevance.
there may be a large lexical gap in the expression of purposes and symptoms with similar semantics such as display the result and show the answers .
therefore bert based semantic matching is more suitable for these descriptive elements.
we implement the bert based semantic matching based on haystack which is an open source framework for building search systems based on novel nlp models e.g.
bert .
we use the base distillbert uncased in bi encoder based retrieval step and cross encoder based re ranking step and fine tune them with duplicate question title pairs from so data dumps .
.
candidate solution re ranking we re rank candidate solutions by combining the matching scores of all crash descriptive elements.
for the input crash description c we calculate its final matching score with each candidate solution sby summing up the weighted matching scores of all crash descriptive elements according to equation .
edenotes the set of all the crash descriptive elements i.e.
title ttl purposepur symptom sym environment env erroneous code ec exception type message em and crash trace ct .
in equation rankscore normalizes the similarity scores of son each descriptive element tbased on its ranking i.e.
rankt c s .
is a constant hyper parameter set to .
score c s t ewt rankscore t c s rankscore t c s rankt c s as different descriptive elements could have different importance during matching e.g.
environment and exception type message we introduce weights wtin equation .
to avoid overfitting we tune these weights with an hyperparameters optimization framework optuna on a small validation set constructed by all so duplicate question pairs up to pairs of randomly selected exception types.
the reranking of all candidate posts is performed according to the final score as shown in equation and the mr metric of the correct solution served as the objective function for tuning.
each hyper parameter is constrained within a range of with a step size of .
.
wttl .
wpur .
wsym .
wenv .
wec .
wem .
andwct .
.
based on the score c s of each candidate solutions we return the top n nis set to 10esec fse december san francisco ca usa xueying du yiling lou mingwei liu xin peng and tianyong yang in our implementation candidates with the highest scores as the recommended solutions.
.
solution summary for each recommended solution kg4crasolver generates a comprehensive summary of the recommended solution by including the solution crash description and the matching details to help developers better understand the recommended solution and quickly judge the relevance of the recommended solution to the given crash description.
fig.
shows an example of the final summary of the recommended solution.
in particular the resolution summary includes basic information of a relevant post i.e.
post id post title and extra information such as the view count crash descriptive elements i.e.
the environment exception type message purpose and symptom solutions i.e.
the reason and solution steps and the matching degree e.g.
environment score that shows the detailed matching scores of each crash descriptive element during solution retrieval.
in this way developers could have a clear picture of the crash context and solutions as well as the relevant crash descriptive elements that match the given crash.
crash descriptive elements crash solution knowledge matching degree figure an example of the solution summary evaluation we implement kg4crasolver based on the crash solution kg constructed from sampled crash related threads across types of exceptions.
the resulting kg consists of nodes and edges including purpose symptom reason solution and environment .
we then extensively evaluate the effectiveness of kg construction the effectiveness of crash solution recommendation and the practical usefulness of recommended solutions for developers by answering the following research questions.
rq1 effectiveness of kg construction what is the intrinsic quality of the critical steps in the kg construction?
rq2 effectiveness of solution recommendation how effective is kg4crasolver in crash solution recommendation?
rq3 usefulness of recommended solution how useful of kg4crasolver in helping developers solve crash bugs?
.
rq1 effectiveness of kg construction in this rq we evaluate the effectiveness of two major steps in kg construction i.e.
crash solution descriptive sentence classification step and crash descriptive phrase extraction step in section .
.
and .
.
respectively.
.
.
crash solution descriptive sentence classification.
we first introduce the benchmark baseline and metrics used in this evaluation and then present the results.
baseline.
our sentence classifier leverages prompt learning to finetune bert with a small set of training samples.
to investigate the contribution of our prompt design we compare our classifier with a baseline that directly fine tunes bert with the same dataset as ours mentioned in section .
.
.
in particular the baseline appends an additional softmax layer after bert which is a common practice for building a classifier on bert .
benchmark.
we manually construct a benchmark of crashrelated threads as the testing set for evaluation.
in particular we first randomly sample crash related threads that are not overlapped with the training dataset and then involve two ms students with years java development experience to annotate the sentences in these threads.
metrics.
we use four commonly used evaluation metrics in sentence classification tasks i.e.
accuracy precision recall and f1.
accuracy is the proportion of correctly classified sentences precision is the proportion of true positive predictions among all positive predictions recall is the proportion of true positive predictions among all instances and f1 score is the harmonic mean of the precision and recall which balances both values.
results.
as shown in table our sentence classifier outperforms the baseline in all metrics i.e.
.
.
.
and .
improvements in terms of accuracy precision recall and f1 score respectively.
the results demonstrate the effectiveness of our prompt design and also indicate the superiority of prompt learning over traditional fine tuning when the size of training data is small.
table effectiveness on sentence classification sentence typekg4crasolver baseline acc.
f1 prec.
recall acc.
f1 prec.
recall purpose .
.
.
.
.
.
.
.
symptom .
.
.
.
.
.
.
.
reason .
.
.
.
.
.
.
.
solution .
.
.
.
.
.
.
.
average .
.
.
.
.
.
.
.
.
.
crash descriptive phrase extraction.
we first introduce the benchmark baseline and metrics used in this evaluation and then discuss the results.
baseline.
similarly we adopt a bert based sequence tagging model as the baseline to study the effectiveness of our eqa model.
in particular the baseline fine tunes bert with an additional softmax layer which predicts the tag for each token in the input sequence.
in our task we use the bio tag schema and include the following tags i.e.
b purpose i purpose b environment i environment o which represent the start token of a purpose phrase the inside token of a purpose phrase the start token of an environment phrase the inside token of an environment phrase and not an entity token respectively.
by interpreting the tagging results the baseline is ablekg4crasolver recommending crash solutions via knowledge graph esec fse december san francisco ca usa to extract phrases in sentences.
the baseline is fine tuned with the same training dataset as ours mentioned in section .
.
.
benchmark.
we manually construct a benchmark of crashrelated threads as the testing set for evaluation.
in particular we first randomly sample crash related threads that are not overlapped with the training dataset and then involve two ms students with years java development experience to annotate the phrases of purpose and environment in the sentences of the purpose and symptom categories.
metrics.
we use two commonly used evaluation metrics in information extraction tasks i.e.
bleu bilingual evaluation understudy and em exact match .
bleu calculates the n gram precision between the predicted and the reference answers and em is a binary classification metric that calculates the percentage of exact matches between the predicted and the reference answers.
results.
as shown in table our phrase extraction model substantially outperforms the baseline in both bleu and em metrics with .
and .
improvements respectively.
the poor performance of the baseline indicates that it heavily relies on a large training dataset whereas our prompt designs help better utilize the pre trained model when the number of training samples is small.
table effectiveness on crash descriptive phrase extraction phrase typekg4crasolver baseline bleu em bleu em purpose .
.
.
.
environment .
.
.
.
average .
.
.
.
.
.
summary.
the results demonstrate the effectiveness of two major steps in our kg construction i.e.
crash solution descriptive sentence classification and crash descriptive phrase extraction.
additionally the prompt learning is helpful in our scenario when there is only a small number of training samples.
.
rq2 effectiveness of solution recommendation in this rq we evaluated the effectiveness of kg4crasolver in recommending crash solutions.
.
.
benchmark.
so data dumps mark the duplicate relationships between questions and some of them are between crashrelated questions e.g.
stackoverflow error in class constructor and why am i getting a stackoverflowerror exception in my constructor are duplicate questions.
to construct the benchmark we first randomly select exception types involved in our crash solution kg and then collect pairs of crash related questions that belong to these selected exception types and have duplicate relationships.
for each exception type we select at most pairs of duplicate questions leading to pairs of duplicate questions.
in this way our benchmark can cover crash bugs related to diverse exception types e.g.
sqlexception andnosuchmethodexception .
for each pair of duplicate questions we use one of it as the query expressing the crash scenario and the accepted answer of the other one as the ground truth for the crash solution recommendation.
.
.
baselines.
we compare kg4crasolver with baselines of two categories i.e.
existing crash solution recommendation techniques and existing retrieval methods that recommend solutions for general questions.
in particular for the former we include the stateof the art technique crasolver for the latter we include two representative retrieval methods answerbot and clear which represent word embedding based and sentence embeddingbased information retrieval methods respectively.
crasolver .
a crash solution recommendation method that uses bm25 to retrieve relevant questions from so by matching the input crash trace with crash traces contained in the questions.
answerbot .
answerbot includes a module for relevant question retrieval which combines the word2vec model and idf metric to measure the relevance between the input query and the questions in the corpus.
clear .
clear is an automated api recommendation approach with a bert based relevant question retrieval step and re ranking step.
we enhance these baselines by limiting their candidates within crash related threads that contain the same exception type as the query which is consistent with our approach section .
for a fair comparison.
.
.
metrics.
following previous work we use the widelyused information retrieval metrics i.e.
mrr mean reciprocal rank and hit k k for evaluation.
mrr calculates the average ranking of the correct solution in the ranked list and hit k computes the ratio of queries that the correct solution ranked with top n positions in the ranked list to the total queries i.e.
queries .
for each query we focus on the top results in the ranked list returned by each technique.
.
.
results.
table presents the effectiveness of kg4crasolver and all baselines.
answerbot full or answerbot title denotes the baseline answerbot that takes the complete crash description body title or the summarized description only title as inputs.
same as it is for clear full and clear title.
overall kg4crasolver outperforms all the baselines on all metrics by achieving .
.
.
.
.
.
and .
.
improvements in terms of mrr hit hit and hit respectively.
the results indicate that the fine grained matching of different descriptive elements in kg4crasolver is indeed more effective than the whole text matching in baselines e.g.
kg4crasolver vs. answerbot full and kg4crasolver vs. clear full .
moreover the gap between clear full and clear title and the gap between kg4crasolver and crasolver further demonstrate the superiority of using a complete crash context over using a partial context.
table effectiveness on solution recommendation approaches mrr h h h crasolver .
.
.
.
answerbot full .
.
.
.
answerbot title .
.
.
.
clear full .
.
.
.
clear title .
.
.
.
kg4crasolver .
.
.
.
.
.
summary.
the results show that kg4crasolver substantially outperforms solution recommendation baselines indicating the effectiveness of our kg based solution recommendation approach and our fine grained utilization of complete crash contexts.esec fse december san francisco ca usa xueying du yiling lou mingwei liu xin peng and tianyong yang .
rq3 user study on usefulness in this rq we conduct a user study to evaluate the practical usefulness of kg4crasolver in helping developers solve crash bugs.
.
.
study design.
the details of our study design are as follows.
participants.
we invite master students with years java programming experience for this user study.
we conduct a preexperiment survey on their java programming experience and divide them into two roughly equal participant groups gaandgb based on the survey.
crash bugs.
we select questions describing crash bugs from the benchmark constructed in rq2 section .
.
we classify the exception types into three categories based on the number of identified crash related threads section .
i.e.
popular more than threads normal threads and unpopular less than threads .
to ensure the diversity of selected crash bugs we sample four questions for each category respectively and all questions selected belong to different exception types.
we randomly divide crash bugs into two equal groups taandtb each with six crash bugs two crash bugs for each exception type category .
procedure.
the task in this user study is to ask participants to find solutions i.e.
so threads for a given crash bug with the aid of kg4crasolver or with the baseline i.e.
using the default so search engine .
in particular the participants in gaare assigned to solve crashes in tawith kg4crasolver and to solve crashes in tbwith the baseline the participants in gbare assigned to solve crashes intbwith kg4crasolver and to solve crashes in tawith the baseline.
for each task we provide the original so question including title and question body as the input crash context for the participants.
when participants are working on their tasks with the baseline they are allowed to search with any keywords on so with unlimited trials until they find solutions that they consider as correct.
when the participants are working on their tasks with kg4crasolver they make the decision based on only the top recommendation so threads returned by kg4crasolver.
each task has a time limit of minutes and if the task is not completed within the time limit an empty solution will be submitted.
for each task we record the relevant threads they submit their completion time and the time used in finding the first relevant thread.
after all tasks are finished we further conduct a survey to collect user feedback.
participants are asked to evaluate kg4crasolver in terms of readability conciseness completeness and usefulness on a points likert scale disagree somewhat disagree somewhat agree agree by the following statements readability .
kg4crasolver can provide a well organized and easy to understand solution summary.
conciseness .
kg4crasolver can provide a solution summary containing little redundant information.
completeness .
kg4crasolver can provide a solution summary containing all necessary information for solving crash bugs.
usefulness .
kg4crasolver is useful in helping participants solve crash bugs.
.
.
results.
for the tasks the participants submit nonempty results empty results with kg4crasolver and empty result with the baseline .
we then invite two extra participants who are not involved in previous experiments with more than4 years experience of in java development to judge whether the returned threads provide the correct solution for the given crash.
for each submitted thread if it is judged differently by the two participants a third participant is assigned to give an additional assessment to resolve the conflict by a majority win strategy.
the agreement between the judgments is a substantial agreement i.e.
cohen s kappa coefficient of .
.
table results of the user study accuracy first thread time completion time baseline .
92s 275s kg4crasolver .
61s 233s improvement .
31s .
42s .
table presents the results of our user study.
overall with kg4crasolver participants can find solutions more accurately and more efficiently.
in particular compared to using baselines participants find correct solutions for more crashes .
more within less time seconds less .
we further perform welch s t test to assess the statistical significance of the differences.
the p value shows that all the differences are statistically significant p .
.
as for readability completeness conciseness and usefulness of kg4crasolver all participants rate them as either agree or somewhat agree .
specifically with and of the ratings for each category respectively are .
the results as well as the informal feedback from participants indicate that our solution summary is well organized and easy to read.
in particular they consider that the environment exception type message and the retrieval matching scores of each descriptive element are helpful for them to quickly determine the relevance of the recommended thread.
compared to directly searching on so kg4crasolver significantly improves their search efficiency and accuracy.
.
.
summary.
kg4crasolver helps developers find the solutions more accurately and more efficiently and the participants consider the solution summary generated by kg4crasolver as complete concise easy to read and useful.
.
threats to validity a major threat to the internal validity of our studies lies in the subjective judgment in human annotations in rq3.
to mitigate the threat we follow commonly used data analysis principles such as assigning multiple annotators conflict resolution and reporting agreement coefficients.
additionally the participants professional background may also impact the results of rq3.
to mitigate this threat we collected statistics regarding the participants years of experience and proficiency in java development during the recruitment process and ensured that the average level of each group of participants was as close as possible during the grouping process.
a common threat is that the baselines we used in rq1 and rq2 are implemented by ourselves because of no publicly available implementations.
however we carefully reproduced and tested the baselines to avoid introducing errors.
a threat to the external validity is that our experiments are only for java crash bugs.
thus the findings of our studies may not be generalized to other programming languages in practice.
however the design of our kg is not specific to java and the implementation could be easily extended to support libraries of other object oriented languages.kg4crasolver recommending crash solutions via knowledge graph esec fse december san francisco ca usa related work crash solution recommendation.
existing crash solution recommendation techniques mainly use code or crash traces as the input and find relevant so threads based on code matching or crash trace matching .
for example maestro uses the buggy code to search relevant so threads and mahajan et al.
further extend maestro to extract the patch from the so thread to help developers fix java crashes.
crasolver uses the structural information in the crash traces to search relevant so threads.
however these techniques only utilize a part of the crash context i.e.
code or crash traces to identify the relevant solution without using the other important contextual elements e.g.
environment or symptom for crash diagnosis.
our work is different from these techniques by analyzing the crash context in a comprehensive and structured way.
to this end we first construct a novel knowledge graph to represent different crash solution descriptive elements and then perform fine grained matching based on kg to enable more accurate solution recommendation.
in addition there is a series of techniques that recommend solutions for general software engineering problems by mining online q a forums .
for instance answerbot generates a query focused multi answer posts summary for a given technical question and crokage provides the solution for a programming task based on the natural language description.
these techniques search relevant posts with pure natural language queries while crash context contains different descriptive elements in different structures e.g.
code and natural language descriptions .
thus simply concatenating them as a long textual query would lead to an inaccurate recommendation.
our work is different from these techniques by representing the crash context in a more structured way instead of a long textual sequence which further supports fine grained matching rather than pure text matching.
knowledge graphs in the software engineering domain.
researchers in the software engineering domain have constructed knowledge graphs for different kinds of knowledge to support software development tasks such as api kg software development concept kg programming task kg code kg ml dl model kg and bug kg .
to the best of our knowledge our work constructs the first knowledge graph for crash solutions based on which we further automatically recommend solutions for a given crash description.
moreover our work is the first one that uses prompt based learning in kg construction requiring much less labeled data than previous work e.g.
.
conclusions this work proposes a novel crash solution knowledge graph kg to summarize the complete crash context and its solution with a graph structured representation.
we leverage prompt learning to automatically construct the kg from so threads with a small set of labeled data.
based on the constructed kg we further propose a novel kg based crash solution recommendation technique kg4crasolver by finely analyzing and matching the complete crash context based on the crash solution kg.
our results show that the constructed kg is of high quality and kg4crasolver outperformsbaselines in all metrics.
moreover we perform a user study to show the practical usefulness of kg4crasolver.
data availability all data is included in our replication package .