interactive effort aware library version harmonization kaifeng huang fudan university chinabihuan chen fudan university chinabowen shi fudan university china ying wang fudan university chinacongying xu fudan university chinaxin peng fudan university china abstract as a mixed result of intensive dependency on third party libraries flexible mechanism to declare dependencies and increased number of modules in a project multiple versions of the same third party library are directly depended in different modules of a project.
such library version inconsistencies can increase dependency maintenance cost or even lead to dependency conflicts when modules are inter dependent.
although automated build tools e.g.
maven s enforcer plugin provide partial support to detect library version inconsistencies they do not provide any support to harmonize inconsistent library versions.
we first conduct a survey with java developers from github to retrieve first hand information about the root causes detection methods reasons for fixing or not fixing fixing strategies fixing efforts and tool expectations on library version inconsistencies.
then based on the insights from our survey we propose libharmo an interactive effort aware library version harmonization technique to detect library version inconsistencies interactively suggest a harmonized version with the least harmonization efforts based on library api usage analysis and refactor build configuration files.
libharmo is currently developed for java maven projects.
our experimental study on highly starred java maven projects from github indicates that i libharmo identifies library version inconsistencies covering .
of projects and ii the average harmonization efforts are that and library api calls are affected respectively due to the deleted and changed library apis in the harmonized version.
library version inconsistencies have been confirmed and of them has been already harmonized by developers.
introduction with the increased diversity and complexity of modern systems modular development has become a common practice to encourage reuse improve maintainability and provide efficient ways for large teams of developers to collaborate .
therefore automated build tools e.g.
maven provide mechanisms e.g.
the aggregation mechanism in maven to support multi module projects for the ease of management and build.
in contrast to the benefits that multi module project brings to software development one of the drawbacks is the sophisticated dependency management colloquially termed as dependency hell exacerbated by the increased number of modules and the intensive dependency on third party libraries.
in this paper we focus on the dependency management in maven projects as maven has dominated the build tool market for many years .
problem.
it is quite common that different modules of a project directly depend on the same third party libraries.
maven providesflexible mechanisms for child modules to either inherit third party library dependencies from parent modules e.g.
the inheritance mechanism or declare their own third party library dependencies.
besides maven allows the version of a third party library dependency to be explicitly hard coded or implicitly referenced from a property which can be declared in parent modules.
therefore library version inconsistency can be easily caused in practice i.e.
multiple versions of the same third party library are directly depended in different modules of a project.
even if the same version of a third party library is directly depended in different modules the versions can be separately declared instead of referencing a common property.
we refer to it as library version false consistency as it is likely to turn into library version inconsistency when there is an incomplete library version update e.g.
a developer updates the version in one of the modules .
intuitively library version inconsistency could increase dependency maintenance cost in the long run or even lead to dependency conflicts when modules are inter dependent.
for example an issue hadoop was reported to the project apache hadoop and said that multiple versions of the same library jar are being pulled in .... dependent subprojects use different versions.
e.g.
common depends on avro .
.
while mapreduce depends on .
.
.
since mapreduce depends on common this has the potential to cause a problem at runtime .
this issue was prioritized as a blocker issue and was resolved in days.
developers found other library version inconsistencies and finally harmonized the inconsistent versions of libraries avro commons logging commons logging api and jets3t across modules common mapreduce andhdfs .
maven s enforcer plugin uses a dependency convergence rule to detect multiple versions of the same third party library along the transitive dependency graph i.e.
if a module has two dependencies a andb and both depends on the same dependency c this rule will fail the build if adepends on a different version of cthan the version of cdepended on by b. in that sense this rule cannot detect library version inconsistencies across modules that are not inter dependent and does not provide any support to harmonize inconsistent library versions.
as project developers have no direct control to harmonize the inconsistent library versions in transitive dependencies we only consider direct dependencies across modules.
approach.
to better address the problem e.g.
by realizing practical solutions that are acceptable by developers it is important to first understand developers practices on library version inconsistencies.
therefore we conduct a survey with java developers from github to retrieve first hand information about the root causes detection methods reasons for fixing or not fixing fixing strategies fixing efforts and tool expectations on library version inconsistencies.
.
of participants experienced library version inconsistency and .
1arxiv .11066v1 feb 2020esec fse november sacramento california united states kaifeng huang bihuan chen bowen shi ying wang congying xu and xin peng consider it as a problem in project maintenance.
our survey suggests several insights e.g.
tools are needed to proactively locate and harmonize inconsistent library versions and such tools need to interact with developers and provide api level harmonization efforts.
then inspired by the insights from our developer survey we propose libharmo the first interactive effort aware technique to harmonize inconsistent library versions in java maven projects.
libharmo works in three steps.
first it identifies library version inconsistencies by analyzing build configuration files i.e.
pom files .
second for each library version inconsistency it suggests a harmonized version with the least harmonization efforts e.g.
the number of calls to library apis that are deleted and changed in the harmonized version based on library api usage analysis and interaction with developers.
finally if developers determine to harmonize it refactors pom files and also suggests replacement library apis to some deleted library apis based on api documentations.
we have run libharmo against highly starred java maven projects from github.
our experimental results have indicated that i libharmo detects library version inconsistencies which cover .
of projects and ii the average harmonization efforts are that and of the called library apis are respectively deleted and changed in the harmonized version totally affecting and library api calls.
moreover library version inconsistencies have been confirmed and of them has been harmonized by developers.
contributions.
this paper makes the following contributions.
we conducted the first survey with java developers from github to retrieve first hand information about the practices and tool expectations on library version inconsistencies.
we proposed the first interactive effort aware library version harmonization technique libharmo based on our survey insights.
we evaluated libharmo on highly starred java maven projects from github and found library version inconsistencies.
of them have been confirmed with being harmonized.
developer survey our online survey is designed for developers who participated in the development of java maven multi module projects.
therefore we selected java maven multi module projects from github and also restricted that the number of stars was larger than to ensure the project popularity.
finally we had projects.
from these projects we collected developers whose email on profile page was valid.
we sent an email to each of the developers to clarify the library version inconsistency problem and kindly ask them to participate in our online questionnaire survey the questions are shown in table and the complete questionnaire with options is available at .
we promised that their participation would remain confidential and all the analysis and reporting would be based on aggregated responses.
our survey consists of questions covering the following seven aspects to learn about their professional background practices and tool expectations on library version inconsistencies.
professional background q1 q4 .
in response to the invitation emails developers finished the questionnaire within seven days i.e.
a participation rate of .
.
of all participants .
have more than years of java programming experience .
have to years and .
have less than years.
.
participated in thetable survey questions q1 how many years of java programming experience do you have?
q2 how many modules in a java project did you participate in?
q3 have you ever encountered library version inconsistency?
q4 is library version inconsistency a problem during project maintenance?
q5 what are the root causes of library version inconsistencies?
q6 how did you detect library version inconsistencies?
q7 what are the reasons of not fixing library version inconsistencies?
q8 what are the reasons of fixing library version inconsistencies?
q9 which version do you use as the harmonized version to fix library version inconsistencies?
q10 how do you fix library version inconsistencies?
q11 how much time do you spend in fixing library version inconsistencies?
q12 which part of it is most time consuming in fixing library version inconsistencies?
q13 is an automatic library version harmonization tool useful for library management?
q14 which features would be useful for an automatic library version harmonization tool?
development of more than modules in one project .
participated in to modules and .
participated in less than modules.
.
of participants experienced library version inconsistency and .
consider it as a problem in project maintenance.
the participants have relatively good experience in modular development as well as in handling library version inconsistencies.
root causes q5 .
.
and .
named unawareness of the same library in other modules and backward incompatibility issues in library versions as the major root causes of library version inconsistencies.
different development schedule among different modules .
unawareness of the library version inconsistency problem .
and not regarding library version inconsistency as a problem .
are the further root causes.
other minor root causes .
include bad dependency management hygiene unawareness of new library versions usage difficulty with maven etc.
detection methods q6 .
being asked about the detection or manifestation of library version inconsistencies bugs due to conflicting library versions .
is the main way to manifest followed by bugs due to library api behavior changes .
.
manual investigation of module pom files .
is the main way to detect followed by communication with developers of other modules .
and adoption of maven s enforcer plugin .
.
reasons for fixing or not fixing q7 q8 .
the participants reported four main reasons for not fixing heavy fixing efforts due to backward incompatibility issues .
heavy fixing efforts due to intensive library api dependency .
fixing difficulty due to different development schedule in different modules .
and no serious consequence occurred .
.
.
emphasized that they always selected to fix.
on the other hand there are three main reasons for fixing avoiding great maintenance efforts in the long run .
ensuring consistent library api behaviors across modules .
and serious consequences occurred e.g.
bugs .
.
fixing strategies q9 q10 .
when harmonizing the inconsistent library versions .
used one of the newer versions than all currently declared versions with the least harmonization efforts but .
chose one of the currently declared versions with the least harmonization efforts.
besides .
harmonized the versions in all of the affected modules while .
only harmonized the versions in some of the affected modules.
fixing efforts q11 q12 .
.
spent hours in fixing library version inconsistencies .
even spent days and only .
spent minutes.
besides locating all inconsistent library versions .
determining the harmonized version .
and refactoring the source code .
are the most time consuming steps in fixing.
2interactive effort aware library version harmonization esec fse november sacramento california united states other time consuming steps include refactoring the pom files .
and verifying the fix through regression testing .
.
tool expectations q13 q14 .
.
thought an automated library version harmonization tool would be useful but .
thought it would not be useful mostly because they already adopted maven s enforcer plugin.
.
thought it depended on how well it would be integrated into the build process how automated it would be etc.
with respect to the most useful feature in such a tool detecting all library version inconsistencies .
and suggesting the harmonized version .
are the most useful ones followed by reporting detailed api level fixing efforts .
and refactoring the pom files .
.
surprising refactoring the source code .
is less useful than all the previous features.
insights.
from our survey results we have several insights.
i1 tools are needed to help developers proactively locate and harmonize inconsistent library versions as library version inconsistencies are mostly manually detected or passively found after serious consequences.
i2 developers should interact with such tools to determine where and whether to harmonize as library version inconsistencies span multiple modules that have different development schedule and might be not fixed due to heavy harmonization efforts.
i3 such tools need to provide developers with api level harmonization efforts as api backward incompatibility api dependency intensity and api behavior consistency are key factors for developers to determine whether to harmonize.
i4 such tools need to be integrated into the build process for the ease of adoption.
methodology based on the insights i1 i2andi3from our developer survey we propose the first interactive effort aware technique named libharmo to assist developers in harmonizing inconsistent library versions and falsely consistent library versions .
as shown in fig.
it takes as an input a java maven project repository and interactively works with developers in three steps i.e.
detecting inconsistency sec.
.
suggesting harmonized version sec.
.
and refactoring poms and suggesting apis sec.
.
.
libharmo also relies on a library database sec.
.
to provide jar files and documentations.
currently libharmo is at the stage of a prototype and thus it is not integrated into the build process and does not satisfy the insight i4.
.
detecting inconsistency the first step of libharmo is composed of three sub steps it first generates the pom inheritance graph then analyzes the inheritance relations to resolve library dependencies in each pom and finally identifies library version inconsistencies and false consistencies.
generating pom inheritance graph.
maven provides the inheritance mechanism to inherit elements e.g.
dependency from a parent pom.
it does not support multiple inheritance however it indirectly supports the concept by using the import scope .
maven also does not allow cyclic inheritance.
therefore the inheritance relations among poms in a project form a directed acyclic graph.
we define such a pom inheritance graph gas a tuple m e wherem denotes all the poms in a project and edenotes the inheritance relations among the poms in m. each inheritance relation e eis denoted as a tuple m1 m2 where m1 m2 m and m1inherits m2 i.e.
m2is the parent pom of m1 .to constructgof a project libharmo scans its repository recursively to collect all the local poms and put them into m. then for each pom minm libharmo parses it to locate its parent poms based on the inheritance mechanism and the import scope i.e.
libharmo parses the parent section and the dependencymanagement section.
for each located parent pom m an inheritance relation e m m is generated and put into e. asm can be a remote pom libharmo crawls it from maven repository and puts it into m.eis constructed after all the local and remote poms in mare parsed.
example .
.
fig.
presents a generated pom inheritance graph where the nodes represent poms the arrows represent inheritance relations and the dotted lines link to excerpts from poms.
here a b c dandeare local poms and ris a remote pom.
bhas two parent poms aandr.
in particular binherits aby declaring the groudid artifactid andversion ofain the parent section line in b .
binherits rby declaring the groudid artifactid andversion of rin a dependency with type being pom andscope being import in thedependencymanagement section line in b .
resolving library dependencies.
we first introduce maven s dependency declaration mechanisms before diving into the details.
thedependencies section contains the library dependencies that a pom declares to use and such library dependencies will be automatically inherited by child poms whereas the dependencymanagement section contains the library dependencies that a pom declares to manage and such library dependencies will be used inherited only when they are explicitly declared in the dependencies section without specifying their version.
moreover the version of a library dependency can be explicitly declared by a hard coded value or implicitly declared via referencing a property.
a property can be overwritten by declaring the same property with a different value.
example .
.
in fig.
bdeclares two library dependencies bwants to use and the versions are hard coded line in b .cdeclares one library dependency cwants to use line in c and calso declares one library dependency cwants to manage line in c and the version