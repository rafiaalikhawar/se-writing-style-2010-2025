synthesizing document database queries using collection abstractions qikang liu yang he yanwen cai byeongguk kwak yuepeng wang simon fraser university buranby bc canada qla116 yha244 yca452 bka47 yuepeng sfu.ca abstract document databases are increasingly popular in various applications but their queries are challenging to write due to the flexible and complex data model underlying document databases.
this paper presents a synthesis technique that aims to generate document database queries from input output examples automatically.
a new domain specific language is designed to express a representative set of document database queries in an algebraic style.
furthermore the synthesis technique leverages a novel abstraction of collections for deduction to efficiently prune the search space and quickly generate the target query.
an evaluation of benchmarks from various sources shows that the proposed technique can synthesize benchmarks successfully.
on average the synthesizer can generate document database queries from a small number of input output examples within tens of seconds.
i. i ntroduction document databases like mongodb and couchdb have become increasingly popular in various real world scenarios such as online commercial platforms financial services gaming and social media applications .
different from traditional relational databases that primarily use structured data like tables document databases persist data in a semistructured format such as json and bson.
while the semistructured data format provides developers with great flexibility in storing and querying complex data structures directly it also raises significant challenges for users to write queries for document databases.
to help users write document database queries in an easy and convenient fashion we develop a synthesis technique to generate queries automatically.
inspired by prior work on automated synthesis of sql queries for relational databases our technique aims to generate document database queries from input output examples.
specifically the user only needs to provide a small number of examples to demonstrate the query where the input example is a small document database consisting of a few documents and the output example is the desired query result over the input.
the goal of our synthesis technique is to generate a document database query such that executing the query over the input example produces the output example.
however unlike synthesizing sql queries there are several key challenges to synthesizing queries for document databases.
hierarchical and nested data structures .
document databases support hierarchical and nested data structures such as arrays documents and their combinations.
since queries for document databases constantly operate over these complexdata structures it is crucial for synthesizers to reason about complex data structures efficiently for better performance.
specialized query language .
query languages for document databases may use specialized operators over complex data structures that relational databases cannot handle.
for instance mongodb uses a lookup operator in aggregation pipelines to query data over multiple collections.
synthesizers need to support an expressive query language for document databases while maintaining the efficiency of exploring a large search space of the target query.
to address these challenges we have designed a new domain specific language based on the aggregation pipeline in mongodb that can express a representative set of queries with core operators of document databases.
the queries of this language are in an algebraic style similar to relational algebra but tailored towards document databases.
furthermore prior work on program synthesis proposed an approach to speed up the synthesis process by deduction .
for fast synthesis of document database queries we have adapted this approach to our setting and developed a novel abstraction for collections containing hierarchical and nested data structures to prune the search space efficiently.
the key insight is that the shape and size of collections can help the synthesizer quickly prune incorrect queries even if the query is partial.
thus our abstraction consists of two pieces of information about the collection first it includes the type of documents inside the collection.
second it includes a logical formula describing constraints over the sizeof the collection.
more specifically our synthesis technique is presented schematically in figure .
at a high level the synthesis technique takes an iterative approach and has two phases in each iteration.
in the first phase the synthesizer aims to find a query sketch which is a partial query with some unknown constructs.
in the second phase it tries to complete the sketch into a full query that can satisfy all provided input output examples.
in general it is not efficient to check if a sketch is feasible to be completed into a correct full query by checking all possible completions against the examples because a sketch may have a large number of completions.
to avoid such inefficiency the key part of our synthesis technique is a deduction engine which can check if a sketch is feasible to get a correct query without checking its completions.
in particular the deduction engine can directly evaluate the sketch over abstractions of collections and obtain an abstract collection.
if the expected output example is a valid concretization ofarxiv .06102v1 dec 2024io examples schema collection name refinementsketchcompletiondeductionsketch sketchevaluationconcretizationchecking feasible sketch mongodbabstractcollections failfail fig.
schematic workflow.
the resulting abstract collection the synthesizer concludes the sketch is feasible to complete and proceeds to find a correct completion.
otherwise the synthesizer can safely conclude the sketch is infeasible to complete prune the search space accordingly and propose a different sketch to the next iteration by refining the infeasible sketch.
based on this technique we have developed a tool called nosdaq that can synthesize document database queries from input output examples.
to evaluate the synthesis technique we have collected benchmarks from various application scenarios including stackoverflow kaggle mongodb official documents and twitter api documents.
the evaluation result shows that n osdaq can successfully synthesize document database queries within the minute time limit.
furthermore n osdaq only uses input output examples and finishes query synthesis in an average of .
seconds which demonstrates the effectiveness and efficiency of our synthesis technique.
contributions.
to summarize the main contributions of this paper are as follows.
we develop a technique for synthesizing document database queries from input output examples.
we design a new domain specific language to express document database queries in algebraic style.
we design a novel abstraction for collections containing hierarchical and nested data structures and use this abstraction to speedup the synthesis of document database queries based on deduction.
we define the abstract semantics of document database queries based on our abstraction of collections.
we develop a tool called n osdaq and evaluate it over benchmarks from various sources.
the evaluation result shows that n osdaq is effective and efficient in synthesizing document database queries.
organization.
the remainder of this paper is structured as follows.
section ii provides a motivating example to illustrate our technique.
section iii formalizes the synthesis problem posts id title title replies id title title replies id title title replies depth depth depth depth fig.
input example.
and section iv introduces collection abstractions.
sections v and vi present the synthesis algorithm and its implementation details respectively.
section vii presents the experimental setup and evaluation results.
section viii discusses the related work followed by a conclusion in section ix.
ii.
m otivating example to explain our synthesis technique let us consider a concrete motivating example.
given a document database collected from the kaggle website that stores a list of reddit posts.
the database only has one collection called posts with the following schema1 arr id string title string replies arr depth num where arr denotes the array type of .
specifically the posts collection contains an array of documents where each document has three attributes id title and replies .
thereplies attribute is also an array of documents and the document has one attribute depth denoting the nesting level of the reply from the root post.
now suppose the user wants to query the title of posts which have more than one non zero depth replies and the count of these replies.
n osdaq can help the user synthesize this query automatically.
the user needs to provide small input output examples to demonstrate their intention.
for instance figure is an input example and the corresponding output example is reply count title title reply count title title the goal of n osdaq is to synthesize a query such that executing the query on the input example produces the output example.
n osdaq takes an iterative approach to solve the synthesis problem.
in each iteration it first proposes a query sketch that may contain unknowns and then checks if the sketch is feasible to complete.
if feasible n osdaq completes the sketch into a full query by enumerative search and checks if any query satisfies the input output example.
if the sketch is infeasible to complete then n osdaq refines the sketch and starts the next iteration.
first iteration.
nosdaq starts with the simplest sketch in its domain specific language the posts collection and checks its feasibility.
to do so the deduction engine of n osdaq uses the collection abstractions and evaluates the sketch based on its 1the database schema is simplified in this section for illustration.abstract semantics.
specifically the abstraction for the posts collection is c t where t id string title string replies arr depth num is the type of inside documents and l0 is the formula describing the size of the collection is .
n osdaq takes the abstract collection as input and evaluates the sketch posts based on the abstract semantics.
the evaluation result is c1 where c1 t which is exactly the same as c. an important observation here is that the output example is not a concretization of c1because its document has type title string reply count num and its size is .
thus n osdaq concludes the sketch posts is not feasible to complete to a correct query and starts to refine the sketch for the next iteration.
in particular n osdaq generates candidate sketches based on the grammar of its query language such as project posts h andmatch posts .
deduction with collection abstractions.
several iterations later n osdaq encounters the following sketch 2 project match unwind posts h1 h2 this time the evaluation result is c2 where c2 t2 2 where t2is title string and 2isl0 l1 l0 l2 l1 l3 l2 where l3corresponds to the size of c2.
the sketch 2is still infeasible to complete because the output document has an additional attribute reply count that does not match the type t2.
nosdaq prunes this sketch 2and continues to search for a feasible sketch.
feasible sketch.
after a few more iterations n osdaq finds another sketch 3 project match addfields group match unwind posts h1 h2 a a h3 e h4 the evaluation result of this sketch over the abstract semantics is a set of abstract collections meaning the result can be some one inside .
among this set there is an abstract collection c3 t3 3 where t3 ?
any ?
num 3 l0 l1 l0 l2 l1 l3 l2 l4 l3 l5 l4 l6 l5 here ?
0and?
3denote placeholders that can match one or more attributes.
any denotes any value type.
l6is the variable that corresponds to the size of c3.
observe that the output example is a concretization of abstract collection c3 because thetitle matches ?
0andreply count matches ?
.
in addition the size of the output collection is consistent with the size of c3 because l6 3is satisfiable.
therefore nosdaq finds a feasible sketch 3. sketch completion.
given a feasible sketch 3 n osdaq aims to complete 3by finding instantiations of all unknown operators in the sketch such as h1 h2 a etc.
towards this goal n osdaq performs enumerative search and finds the following query finally project match addfields group match unwind posts replies replies.depth reply count schema s n17 tc1 .
.
.
n m7 tcm collection type tc arr td document type td a1 tv1.
.
.
an tvn value type tv td arr tv tp primitive type tp num string bool datetime objectid n collection names a attributes fig.
schema of document databases.
database d n17 c .
.
.
n m7 cm collection c document d a1 v1 .
.
.
a n vn value v d c n collection names a attributes c constants fig.
definition of document databases.
executing this query on the input example produces exactly the output example so the synthesis process is finished.
the query corresponds to the following mongodb query db.posts.aggregate unwind replies match replies.depth gt group id id id title title reply count count addfields title id.title match reply count gt project id reply count title iii.
p roblem formulation in this section we present formulations that are necessary for the rest of the paper and formally define our problem.
a. document schema and database we first precisely define the document schema and document database considered in this paper.
document schema.
as shown in figure a document schema sis a map from collection names to collection types where a collection type is an array of document types.
a document type is a map from attributes to different value types including document types arrays and primitive types such as num string and bool .
document database.
as shown in figure a document database is a map from collection names to their corresponding collections.
a collection is an array of documents.
a document is a map from attributes to values where the value is a document an array of values or a constant of primitive types.
typing and conformance.
figure presents a set of typing rules for conformance checking between document databases and schemas where judgments of the form d smean the database dconforms to schema s.2specifically according to the t primitive rule the type of a constant vis simply type v .
2we view null as a special value of any primitive type.
if an attribute has both null values and non null values in some collection then its type will be the same as that of the non null value.v constants type v v t primitive vi i .
.
.
n arr t array d a1 v1 .
.
.
a n vn vi ii .
.
.
n d a1 1 .
.
.
a n n t doc d n17 c .
.
.
n m7 cm ci ii .
.
.
m d n17 1 .
.
.
n m7 m t db fig.
rules for conformance between databases and schemas.
query q n project q h match q addfields q h e unwind q h group q h a a lookup q h h n a pred h c sizeeq h c exists h expr e h h h f h agga sum h avg h min h max h count logicop arithop n collection names f math functions c constants a attributes h access paths fig.
syntax of mongodb query.
the two array parameters of addfields must have the same length.
the last two parameters of group also must have the same length.
the t array rule describes that all elements viin an array must have the same type.
if the element type is then the array is of type arr .
the t doc rule states that the type of a document d a1 v1 .
.
.
a n vn is a1 1 .
.
.
a n n where i is the type of vi.
finally based on the t db rule the schema or the type of a database is basically a map from collection names to types of their corresponding collections.
b. query language next we describe the syntax and semantics of our query language for document databases.
the query language has a straightforward correspondence to a core query language of the mongodb aggregation pipelines.
the syntax of the query language is shown in figure .
at a high level a query is a sequence of operations including project match addfields unwind group and lookup where different operators take different arguments such as a predicate or an expression e. each operator corresponds to a stage of the mongodb aggregation pipeline.
more specifically the name nsimply retrieves collection nfrom the database.
project q h projects fields with access paths hfrom each document in the collection of q.match q filters the documents in q s collection retaining only those satisfy the predicate .addfields q h e introduces new fields hwith associated values of eto each document in q. unwind q h deconstructs an array field hin the documents ofq mapping each document to a series of documents where the value of his replaced by individual elements ofthe original array.
group q h a a groups documents of q based on grouping keys h transforming each group into a single document with new attributes aand aggregated values a. finally lookup q h1 h2 n a adds a new attribute ato each document of q where the attribute s value is a list of documents from a foreign collection n. this list only includes documents whose specified field h2in the foreign collection is the same as field h1in the original collection.
the predicate can be true false logical comparison h c size equality sizeeq h c existence of an access path exists h and boolean connectives.
the expression ecan be an access path h arithmetics h h and mathematical functions f h .
the access path is a sequence of attributes separated by dots such as a1.a2.a3 denoting the path to access the data from the root document.
example .
let us consider a document id name john class se info score .
the access path for the score attribute in info is info.score .
example .
consider a mongodb query db.coll.aggregate group id name name class class total sum info.score it can be represented by the following query in our language group coll example .
consider a collection n a b the evaluation result of unwind n b is a b a b a b a b c. problem statement before we state the problem to solve in this paper let us first define input output examples.
definition input output example .an example eover schema sis a pair i o where iis the document database over schema s i.e.
i s and ois the output collection.
synthesis problem.
given a database schema s a collection name n dom s and input output examples eovers the goal of our synthesis problem is to find a query qover collection nin the language shown in figure such that for each example i o e it holds that jqki o. here jqki represents the evaluation result of qgiven input database i. iv.
a bstraction for collections in this section we will introduce the abstraction for collections in document databases and how to compute abstractions for queries and sketches.
intuitively since collections in document databases contain an array of documents the abstraction for collections should contain two pieces of information the type of documentsinside the collection and the sizeof the collection.
based on this idea we can define abstract collections and databases.
definition abstract collection .an abstract collection c is a pair that consists of the type of inside documents and the formula about the collection size.
definition abstract database .an abstract database d n17 c1 .
.
.
n m7 cm is a map from collection names to abstract collections.
since the synthesis process also involves partial programs that may yield unknown attributes values or types in the documents we now augment documents with a notion of placeholders.
definition placeholder .a placeholder ?mdenotes a toplevel attribute that can match any concrete attribute and m denotes how many attributes it can match.
?1means the placeholder matches exactly one attribute and ?
means it can match one or more attributes.
accordingly we update the type of documents with placeholders and augment attributes with a special type called any that represents any possible value type.
definition augmented type .an augmented type tis an extension of the document type tdin figure where the attribute can be a named attribute or a placeholder and its type can be a value type tvorany denoting any value type.
example .
let us consider an augmented type a string ?
any ?
num ?
arr c num d string here ?
1is a placeholder that matches one or more attributes of any type.
?
2is a placeholder that matches one or more attributes of num type.
?
3is a placeholder that matches exactly one attribute corresponding to a collection where the document is of type c num d string .
next we can lift the notion of abstract collections to cases where placeholders are involved in the documents.
definition abstract collection with placeholders .an abstract collection c t is a pair consisting of the augmented type tof inside documents with potential placeholders and the formula about the collection size.
in the rest of the paper we simply refer to abstract collections with placeholders as abstract collections if the meaning is clear in the context.
definition match .let be a document type and tbe an augmented type.
we say matches t denoted t if replacing ?1and?
with exactly one and at least one attributes respectively and replacing each occurrence of any with a value type in tyield a type equal to .
having defined the match relation between document types and augmented types we can define the relation between concrete collections and abstract collections.algorithm synthesis algorithm procedure synthesize s n e input database schema s collection name n inputoutput examples e output a query qor indicating failure w n while isempty w do w .dequeue ifdeduce s e then q complete sketch s e ifq then return q w.enqueueall refine return definition collection concretization .a collection cconcretizes an abstract collection c t denoted c c if twhere c arr and sat ln c where n maxlabel .
intuitively if collection cconcretizes abstract collection c t then the type of documents in cmatches the augmented type tof documents in c and the size of cis consistent with the size of cdescribed by formula .
example .
consider the output collection cin section ii reply count title title reply count title title suppose c t is an abstract collection where t ?
any ?
num l0 l1 l0 l2 l1 l3 l2 l4 l3 l5 l4 l6 l5 here l6is the variable for the size of c. first the type reply count num title string matches the augmented type t. second the size predicate l6 2is consistent with formula .
therefore cconcretizes c. we can also lift the concretization relation to databases and abstract databases.
definition db concretization .a database dover schema sconcretizes an abstract database d n17 c1 .
.
.
n m7 cm denoted d d if for all i m s arr i ci i l0 d v. s ynthesis using collection abstractions in this section we present our synthesis technique based on the abstraction of collections.
a. high level algorithm as shown in algorithm our synthesis algorithm adapts the standard iterative approach based on worklists and sketches to the setting of document database queries.
given a database schema s a collection name n and inputoutput examples e the s ynthesize procedure aims to finda query qover schema ssuch that it satisfies the examples e. specifically the worklist wis initialized to be a singleton queue with the simplest sketch n line .
while the worklist is not empty the synthesis procedure enters a loop lines that dequeues the current sketch line and checks if it is feasible to complete line .
if yes the procedure invokes the c omplete sketch procedure and tries to obtain a correct query lines .
if the sketch is infeasible to complete or all of its completions are incorrect the procedure also invokes the r efine procedure to transform the current sketch to a set of sketches based on the grammar in figure line .
this synthesis procedure is repeated until a correct query q is found line or returns if the worklist is empty.
b. sketch enumeration and refinement definition sketch .a sketch is a query qwhere only the collection name is known and other arguments are unknown.
example .
let us consider again the following sketch from the motivating example.
project match unwind posts h1 h2 here the collection name posts is known but access path h1 predicate and access paths h2are unknown.
given a sketch over collection n the r efine procedure substitutes the collection nwith all possible query operators shown in figure and obtains a set s project n h match n addfields n h e unwind n h group n h a a lookup n h h n a and produces six new sketches.
the refined sketches are i s c. abstract semantics since the key novelty of our synthesis technique is performing deduction on collection abstractions to prune infeasible sketches we first introduce the abstract semantics of executing sketches over abstract collections.
at a high level the abstract semantics is consistent with the concrete semantics in describing how an operator modifies the collection size and the type of its documents but it applies to the abstract database.
formally the abstract semantics is defined in figure where judgments of the form d o mean that a sketch evaluates to a set of abstract collections given an abstract database d and the output document type o. specifically by the acollection rule the only abstract collection for query ncan be obtained by looking up the abstract database d. by a match match reduces the collection size without changing the type of its inside documents.
by a project project preserves the collection size but modifies the document type.
in particular the output document only retains a subset of the original attributes and the remaining attributes can be inferred from the output.
according to a addfields addfields adds one or more attributes of any type without changing the size of the collection.
by the a unwind rule unwind h potentially c d d o n c a collection d o t t lj li id iid match p j d o match p a match d o t k todoctype t t k k o lj li id iid project h j d o project h a project d o t t ?
any lj li id iid addfields h e j d o addfields h e a addfields d o t type aa arr notinarr aa t lj li aa t p. q.aa ?q p id iid unwind h j d o unwind h a unwind d o t f todoctype d t n dom d t ?
j arr f lj li f f id iid lookup h h n a j d o lookup h h n a a lookup d o t g ?
j num id k g lj li k todoctype t g g id iid group h a a j d o group h a a a group fig.
abstract semantics.
the todoctype function transforms an augmented type to a document type by deleting all placeholder attributes and the attributes with any type.
the notinarr checks whether an attribute is not nested in an array type otherwise it is unable to be unwinded.
increases the collection size deconstructs the array hof sketch and updates the type accordingly.
by the a lookup rule lookup preserves the collection size but introduces a new attribute to the t where the type of the new attribute is the same as that of the foreign collection.
finally as shown in the a group rule group reduces the collection size and constructs a new type.
in particular it introduces a new attribute id as the key and uses a new gto represent a series of numeric attributes for aggregation results.
gcan also be empty indicating the absence of aggregation attributes.
example .
consider again the following sketch in section ii project match unwind posts h1 h2 based on the rules in figure we recursively evaluate the sketch.
the evaluation result of posts is id string title string replies arr depth num l0 the result of unwind posts h1 is id string title string replies depth num l0 l1 l0 the result of match unwind posts h1 is id string title string replies depth num l0 l1 l0 l2 l1 the result of project match unwind posts h1 h2 is title string l0 l1 l0 l2 l1 l3 l2 next we establish the relationship among queries sketches concrete semantics and abstract semantics with a theorem.
theorem .
let dbe an abstract database over schema s be a sketch qbe a query that is a completion of and i o be an input output example where i sand o arr o .
ifjqki o i d and d o then there exists an abstract collection c such that o c. intuitively the theorem states that the abstract semantics is correct with respect to the concrete semantics.
in particular if the input is a concretization of the abstract database and the query is a completion of the sketch then the evaluation result of the sketch on the abstract database is an over approximation of the output produced by executing the query on the input.
d. deduction by collection abstractions next let us present how to perform deduction based on the collection abstractions.
deduction algorithm.
our deduction algorithm is shown in algorithm .
for each example ej ij oj we compute the document type in oj.
the c ompute type computes the type of ojby the typing rules in figure line .
then the infunction extracts the document type from the type of oj namely in arr .
we also compute the abstract input database djby computing all the abstractions of collections in the database line .
each collection name niis mapped to an abstract collection whose augmented type is the document s type inside the collection and the predicate is l0equals the collection size.
for all pairs of abstract input database djand output document type oj we evaluate the sketch based on the abstract semantics in figure and get a set of abstract collections for each example line .
if for each example ij oj there is an abstract collection c jsuch that ojis a concretization of c then the sketch is feasible to complete line .
otherwise the sketch is infeasible.
concretization check.
recall from definition that to check a collection cis a concretization of abstract collection c t we need to check the type of documents inside cmatches t i.e.
t and the size of cis consistent with the formula .
we use an off the shelf smt solver to check condition by checking the satisfiability of formula ln c where n maxlabel .
we also develop a procedure for type match based on definition which can be best explained with the following example.algorithm deduction by abstract collections procedure deduce s e input the database schema s a sketch and inputoutput examples e output if is feasible otherwise forj 1to e do ij oj e j oj in compute type oj dj ni7 in s l0 ij ni dom s j eval dj oj if j. c. c j oj cthen return else return example .
suppose we have an augmented type t name string id string info tel string ?
num ?
any ?
arr profid string profname string and document type id string name string info tel string newfield bool sum num profs arr profid string profname string here name string id string info tel string intis matched by name string id string info tel string in because the corresponding attributes have the same names and types.
?
arr profid string profname string is matched by profs arr profid string profname string because profs has the same type as placeholder ?
3and?
3matches exactly one attribute.
finally ?
num is matched by sum num because they have the same type and ?
any is matched by newfield bool because any can match any value type.
to understand why our deduction algorithm is correct let us consider the following theorem.
theorem .
given a database schema s a sketch and input output examples e ifdeduce s e returns then there is no completion qof such that for all i o e jqki o. intuitively the theorem states that our deduction based pruning is sound.
in other words if the deduction algorithm returns for a sketch then no completions of the sketch satisfy all the input output examples.
e. sketch completion the c omplete sketch takes as input a schema s a sketch and input output examples eand returns a query qsatisfying all examples or if such a query does not exist.
we use an enumerative search algorithm to fill unknowns in the sketch according to the query operators.
project .
we compute the common attributes in the input and output and use these common attributes as arguments.
match .
we enumerate all predicates obtained from a combination of access paths constants comparisons and logic connectives.
also the observational equivalent class is used to avoid duplicate predicates.
addfields .
we enumerate all possible expressions for newly generated attributes.
unwind .
we enumerate all array attributes in the top level of the document and unwind them.
group .
we enumerate all group keys and accumulators and use value based analysis to prune impossible accumulators.
lookup .
we enumerate all foreign collections and their attributes as arguments.
in addition we also perform type checking to prune impossible arguments.
for instance if the value for a newly generated attribute has a different type than it should be in the output we prune this completion from the search space.
we now conclude this section with two theorems about the overall synthesis algorithm.
theorem soundness .letsbe a database schema e be input output examples and nbe a collection name.
suppose complete sketch is sound if synthesize s e n returns a query q then qsatisfies examples e. theorem completeness .letsbe a database schema e be input output examples and nbe a collection name.
suppose complete sketch is complete if there exists a query accepted by the grammar in figure that is over collection nand satisfies examples e then synthesize s e n does not return .
intuitively the soundness theorem states that if the synthesis algorithm returns a query then the query satisfies all inputoutput examples.
the completeness theorem ensures that if there exists a query in our language satisfying all input output examples then the synthesis algorithm can find a query.
vi.
i mplementation we have implemented the proposed synthesis technique in a tool called n osdaq and use z3 as the smt solver.
heuristics for sketch completion.
based on the observation that most group operators do not have more than two group keys we limit the number of group keys to two during sketch completion.
in addition although n osdaq supports simple constants e.g.
null in sketch completion it expects the user to provide more complicated constants such as string literals.
translation to mongodb queries.
nosdaq performs syntaxdirected translation to transform the document database query in its domain specific language to the mongodb query language.
furthermore it also performs optimizations to improve the conciseness and efficiency of translated queries such as merging continuous addfields andproject operators.table i statistics of datasets.
nis the number of benchmarks.
a d e i o cdenote the average number of document attributes document depths examples collection sizes in input and output examples and constants respectively.
dataset n a d e i o c stackoverflow .
.
.
.
.
.
mongodb document .
.
.
.
.
.
twitter api .
.
.
.
.
.
kaggle .
.
.
.
.
.
total .
.
.
.
.
.
table ii statistics of ground truth queries.
s op p m l u g adenote the number of ast nodes query operators project match lookup unwind group addfields respectively.
dataset s op p m l u g a stackoverflowavg .
.
.
.
.
.
med min max official documentavg .
.
.
.
.
.
.
med min max twitter apiavg .
.
.
.
med min max kaggleavg .
.
.
.
.
med min max totalavg .
.
.
.
.
.
.
med min max vii.
e valuation in this section we present several experiments that are designed to answer the following research questions.
rq1.
is n osdaq effective and efficient to synthesize document database queries from input output examples?
rq2.
how does each component of the collection abstraction affect synthesis time?
rq3.
how does n osdaq compare against other baseline synthesizers?
rq4.
how does the collection size of input output examples impact the performance of n osdaq ?
experimental setup.
all experiments are conducted on a machine with an intel i9 13905h cpu and gb of physical memory running the ubuntu .
wsl2 operating system.
a. benchmarks we have collected benchmarks from representative sources i.e.
stackoverflow mongodb official document twitter api documents and kaggle competitions which cover a wide spectrum of realistic scenarios.
stackoverflow.
the stackoverflow dataset is adapted from stackoverflow posts where developers ask about real world problems.
each post in our dataset has 453k visits 4answers and votes on average which demonstrates these queries attract lots of attention from the community.
most of the the examples and constants are extracted from the post content.
if some post does not provide enough examples we add the examples.
mongodb document.
the mongodb official documents cover a representative set of queries that the mongodb community believes are commonly used in practice.
the examples and constants are all collected from the example section of official documents.
twitter api.
the twitter dataset consists of tweets and user replies which mainly focus on calculating tweet statistics such as the count of replies.
the benchmarks represent typical scenarios for data analysts to get information from social networks and online forums.
the examples are collected from the response data of apis.
kaggle.
the kaggle dataset contains information about satellite images where benchmarks reflect scenarios for scientific research such as extracting different labels for training machine learning models and collecting statistics.
the examples are sampled from the provided json file.
table i summarizes the statistics of these datasets.
among these datasets twitter api and kaggle benchmarks are more complex than stackoverflow and mongodb document in terms of the number of attributes collection sizes etc.
to further understand the complexity of benchmarks we have also collected the statistics on the ground truth queries in table ii.
the maximum ast size of ground truth queries is among all benchmarks and the average is .
over half of the ground truth queries have an ast size larger than .
this indicates a high level of complexity as longer queries typically require synthesizers to explore a larger search space.
furthermore the number of operators or pipeline stages in a single query ranges from to .
frequently occurring operators include project match unwind and group .
notably unwind andgroup pose significant challenges for synthesis as they can substantially change the structure of collections and documents.
in contrast the lookup operator appears infrequently in ground truth queries.
this is consistent with the typical usage of document databases where users try to avoid join operations between multiple collections.
similarly the addfields operator is also not used frequently in our datasets.
b. effectiveness and efficiency the evaluation results and the statistics of synthesized programs are presented in table iii.
given a time limit of minutes n osdaq can solve out of benchmarks and only gets timeout on two challenging benchmarks both in kaggle .
note that the ground truths of these two benchmarks are more complex than the others from our manual inspection.
this serves as evidence of the effectiveness of n osdaq in synthesizing document database queries from examples.
further n osdaq can solve most benchmarks in an average of .
seconds as shown in table iii.
furthermore observing the number of sketches and complete programs q nosdaq iterates over sketches but only completes full programstable iii evaluation results for n osdaq .
nand!denote the number of benchmarks and solved benchmarks and time indicates the time in seconds to solve benchmarks.
q size refer to the number of sketches complete programs and ast nodes of synthesized programs respectively.
dataset n!
time s q size stackoverflow33 33avg .
med .
min .
max .
mongodb document26 26avg .
med .
min .
max .
twitter api5 5avg .
med .
min .
max .
kaggle 44avg .
med .
min .
max .
total 108avg .
med .
min .
max .
on average.
it demonstrates that our synthesis technique based on collection abstractions is efficient in pruning infeasible sketches and thus speeds up the synthesis process.
qualitative analysis.
we observe that the number of attributes in the document the depth of the document the number of constants and the query complexity affect the synthesis time.
for instance the kaggle dataset needs longer synthesis time than others because the benchmark has a large number of attributes and the documents are deeply nested.
in general more complex queries need the synthesizer to iterate more sketches.
more attributes deeper nesting and more constants require enumerating more queries while completing the sketch.
non desired programs.
to understand if n osdaq can synthesize desired queries we have manually inspected all synthesized queries and found of them are equivalent to the desired ones.
there is only one benchmark from stackoverflow where n osdaq synthesized a plausible query in terms of the example but the query is not desired.
the reason is that this benchmark involves a complex predicate that requires numerous unseen examples to eliminate mismatch cases.
however only a few examples are provided on the stackoverflow post so n osdaq cannot find the desired predicate but synthesize an alternative satisfying the examples.
answer to rq1 nosdaq successfully synthesizes out of benchmarks from examples and the average synthesis time is .
seconds.
c. ablation study to understand how the type and size information in collection abstractions may affect the efficiency we perform an ablation study.
specifically we have created three variants of nosdaq that disable the size information the type0 solved benchmarks050100150200250300time s nosdaq nosdaq w o size nosdaq w o type nosdaq w o size typefig.
ablation study.
solved benchmarks050100150200250300time s nosdaq eusolver fig.
comparison between n osdaq and eus olver .
information and both size and type information in the abstraction.
we run all these variants on the benchmarks and obtain the result shown in figure where a point x y means a variant can synthesize xbenchmarks and the time for each benchmark is within yseconds.
as shown in the figure without size in the abstraction the variant times out on more benchmarks and requires approximately seconds longer on average.
without type the variant triggers timeout on more benchmarks and requires around seconds longer on average to complete the synthesis process.
this indicates that the document type in the collection abstraction significantly improves the synthesis time.
answer to rq2 both type and size information can make nosdaq more efficient but the former is more significant.
d. comparison with baselines to compare n osdaq with a baseline we have instantiated the eus olver framework to synthesize document database queries from examples.
as a generic solver eusolver can be easily extended to support documents and collections in the specification since it provides necessary support for lists and maps.
secondly eus olver remains a competitive baseline in program synthesis as evidenced from recent work .
as shown in figure as opposed to benchmarks solved by n osdaq eus olver can only solve benchmarks within the minute time limit due to the large search space of document database queries in general.
to compare n osdaq with the llm based approach we have used chatgpt version gpt 4o to synthesize all of our benchmarks.
specifically we have used the same set of input output examples and constants in each benchmark and asked chatgpt to generate mongodb queries.
to make fair comparisons we did not provide additional natural language descriptions about what the query should do.
the evaluation shows that gpt can only generate the desired collection size051015202530time s median averagefig.
impact of collection size on synthesis time.
collection size5060708090100rate desired plausible fig.
impact of collection size on rates of plausible and desired queries.
query for out of benchmarks.
for benchmarks the generated query is plausible but undesired i.e.
it is consistent with the examples but not equivalent to the desired one.
for the remaining benchmarks the generated query is inconsistent with the input output examples.
the errors made by gpt include misunderstanding the semantics of operators missing predicates etc.
recall that n osdaq can synthesize desired queries for benchmarks and plausible but undesired query for benchmark.
we believe our synthesis technique is more effective and generalizable than gpt to synthesize document database queries from examples.
answer to rq3 nosdaq can solve out of benchmarks whereas eus olver can only solve benchmarks and chatgpt 4o can solve benchmarks.
e. impact of collection size to analyze the impact of collection size on the performance of n osdaq we have conducted experiments across all benchmarks to evaluate how different collection sizes influence nosdaq s behavior.
specifically we sampled documents for each collection and ran n osdaq on variants with collection sizes ranging from to documents.
the impact on synthesis time is presented in figure while the impact on rates of plausible and desired queries are shown in figure .
the plausible rate is defined as the ratio of benchmarks synthesized within a minute time limit to the total number of benchmarks.
the desired rate represents the ratio of benchmarks for which the synthesized query is equivalent to the desired one to the total number of synthesized benchmarks.
as shown in the figures the synthesis time of n osdaq remains relatively insensitive to changes in collection size within the range of to documents in each collection.
similarly the plausible rate also remains stable.
in contrast the desired rate shows a significant increase when the collection size grows from to after which it stabilizes.
this can be attributed to the fact that smaller collection sizes provide insufficient examples to synthesize the desired query leading to simpler queries that are plausible but not desired.answer to rq4 the synthesis time of n osdaq demonstrates minimal sensitivity to changes in collection size.
the rate of synthesizing a desired query increases rapidly as the collection size grows from to and stabilizes thereafter.
f .
threats to validity first although we believe our datasets are representative which are obtained from various real world scenarios our evaluation results are limited to the collected datasets.
the nosdaq tool might perform differently on other datasets.
second our domain specific language only corresponds to a core subset of the mongodb aggregation pipeline.
while it is convenient to extend the abstract semantics to other query operators the performance of the tool might be different due to the change in smt formulas for symbolic reasoning.
third all the experiments are conducted on a machine as specified in section vii.
running the experiments on a different machine may yield different results.
viii.
r elated work program synthesis for software engineering.
program synthesis techniques have been applied to address various software engineering problems such as program refactoring program repair code completion software testing and so on.
this paper focuses on the topic of generating document database queries from input output examples.
synthesizing database queries.
among related papers the most related is a body of work on synthesizing database queries.
sqls ynthesizer s cythe and patsql synthesize sql queries for relational databases from examples while s ickle synthesizes analytical sql queries given computation demonstrations.
sql izer considers nature language description as the specification for sql query synthesis.
however none of the prior work can synthesize queries of document databases such as mongodb.
synthesis with deduction.
a line of work performs deduction to prune infeasible programs in program synthesis .
for example morpheus and n eo utilize smt based deduction that generates formulas based on semantics and inputoutput examples to prune infeasible programs.
ngds and c oncord combine deduction and machine learning techniques to prune the search space.
n osdaq adapts the high level approach of m orpheus and n eo to the setting of document database queries.
however m orpheus mainly focuses on tabular data whereas n osdaq focuses on hierarchical data.
the abstraction used by m orpheus is related to the number of rows and columns of tables.
this abstraction cannot be directly used for deduction in a synthesizer that aims to generate document database queries because these queries operate over more involved hierarchical data.
therefore n osdaq uses the novel abstraction consisting of hierarchically nested types for its documents and the collection size which is one of the main contributions of this paper.synthesis with abstraction.
another line of related work is to synthesize programs using abstractions .
for example s impl uses abstract interpretation to guide the synthesis of imperative programs from examples.
mell et al.
also use abstract interpretation for optimal program synthesis.
b laze constructs and iteratively refines the abstract finite tree automata that represent a set of programs.
this approach iteratively prunes and refines automata when the corresponding programs do not satisfy examples until a correct program is found.
unlike prior techniques n osdaq employs a novel collection abstraction to represent complex hierarchical data e.g.
bson and uses abstract semantics to rule out infeasible sketches representing a large set of programs.
wrangling semi structured data.
various techniques have been proposed to wrangle semi structured data such as json xml documents spreadsheets and log files.
for example there is a line of work that aims to map xml documents to relational data for query processing.
d atamaran converts the semi structured log into a structured relational format.
f lash extract extracts relevant data from text files websites and spreadsheets.
f lash relate extracts relational data from semistructured spreadsheets by examples.
t reex synthesizes extractors for real world large scale websites.
since document databases store semi structured data by nature n osdaq can also be viewed as a query synthesizer over semi structured data.
however different from prior work n osdaq focuses on core query language of document databases and aims to address significant challenges raised by specialized operators such as group unwind and lookup .
synthesizing data transformation scripts.
many synthesizers aim to automatically generate data transformation scripts from high level specifications .
for example h ades synthesizes scripts to handle hierarchically structured data such as file systems xml and hdf files.
m itra aims to synthesize scripts to convert hierarchical data into relational tables.
d ynamite transforms data between various types of databases by synthesizing datalog programs.
in contrast n osdaq is designed to handle complex data structures in document databases and leverage collection abstractions to efficiently synthesize queries from examples which is beyond the capability of prior work.
for instance h ades focuses on structure changes in the transformation but does not support aggregations but n osdaq can synthesize aggregate queries with group operations.
ix.
c onclusion this paper presents a technique that automatically synthesizes document database queries from input output examples.
to achieve better performance we develop a novel abstraction for collections containing hierarchical and nested data structures and leverage this abstraction for deduction to prune the search space of target queries.
an evaluation of benchmarks from various sources demonstrates our technique is effective and efficient in solving benchmarks.