multilingual codeco evolution using largelanguagemodels jiyang zhang utaustin usa jiyang.zhang utexas.edupengyu nie utaustin usa pynie utexas.edujunyijessyli utaustin usa jessy austin.utexas.edumilosgligoric utaustin usa gligoric utexas.edu abstract manysoftwareprojectsimplementapisandalgorithmsinmultiple programming languages.
maintaining such projects is tiresome as developers have to ensure that any change e.g.
a bug f ix or anewfeature isbeingpropagated timelyandwithouterrors to implementations in other programming languages.
in the world of ever changingsoftware usingrule basedtranslationtools i.e.
transpilers ormachine learningmodels fortranslating code fromone language to another provideslimited value.
translatingeach time theentirecodebasefromonelanguagetoanotherisnotthewaydeveloperswork.inthispaper wetargetanoveltask translatingcode changesfromoneprogramminglanguagetoanotherusinglarge language models llms .we design and implement the f irst llm dubbedcodeditor to tackle this task.
codeditor explicitly models code changes as edit sequences and learns to correlate changes acrossprogramminglanguages.toevaluate codeditor wecollect a corpus of aligned code changes from pairs of open source software projects implementing similar functionalities in two programming languages java and c .
results show that codeditor outperformsthestate of the artapproachesbyalargemarginon allcommonlyusedautomaticmetrics.ourworkalsorevealsthat codeditor is complementary to the existing generation based models andtheircombination ensures even greaterperformance.
ccsconcepts computing methodologies machine learning software and its engineering software evolution .
keywords language models code translation software evolution acm referenceformat jiyangzhang pengyunie junyijessyli andmilosgligoric.
.multilingual code co evolution using large language models.
in proceedings of the31stacmjointeuropeansoftwareengineeringconferenceandsymposiumonthefoundationsofsoftwareengineering esec fse december san francisco ca usa.
acm new york ny usa 13pages.
esec fse december sanfrancisco ca usa copyright held bytheowner author s .
acm isbn979 .
introduction to ensure f lexibility and a wide adoption of their software companiesprovideapplicationprogramminginterfaces apis fortheirservices in several programminglanguages.
services such as google cloud and mongodb offer apis written in most popular programming languages including c c java and python.
furthermore popularsoftwarepackages likeantlr andlucene have options to target different programming languages for the purpose ofbeingusedacross various platforms easily.
maintainingsoftwarethatoffersthesamefunctionalityinmultiple programming languages is challenging.
any code change due to a feature request or a bug f ix has to be propagated timely to all programming languages.
at present developers have to manuallyco evolve code.thisrequiresdeveloperstomanually f indthe correspondence between code snippets and apply necessary edits.
therehasbeenworkthatcould intheory helpwithtranslation.
rule based migration tools have been designed to translate between high level programming languages e.g.
java and c .
however rule basedsystemsrequiredeveloperswhohaveexpertisewithbothprogramminglanguagestomanuallywriterulesto specifythetranslationmappings.andtherulesneedtobeupdated with the evolution of programming languages themselves they quickly become outdated .
recent work on automatic code translation aim to directly translate between a source and a target programming language with the help of llms whicharepretrainedonmultipleprogramminglanguages.while these techniques could be used to produce code snippets that look correct they make irrelevant changes that deviate substantially from the newly introduced features in the source programming language or they fail to precisely infer the project speci f ic data types andclass names.
figure1illustrates the limitation of existing models.
developers changedpdfexception tolayoutexceptionmessageconstant in methoddocwithinvalidmapping02 in the java project itext itext7.
in a later commit in the corresponding c project itext itext7 dotnet developersrevisedmethod docwithinvalidmapping02with exactly the same edits while keeping other parts of the methodunchanged.weprovidethejavacodechange thepredictionofanexistinglargelanguagemodel codet5 f ine tuned for code translation and the correct c code change in figure .
the addedlines ofcode are highlighted in green and the removed ones are highlighted in red.
although the existing model is able tocorrectlytranslatetheupdatedexceptiontypefromjavatoc it misses the class name for the f ield htmlroles and incorrectly infers the function call assert.catchas it does notuse the prior version ofc code forreference.
tobuildmorerobustandaccuratetechniquesthathelpsoftware developers co evolve projects implemented in different languages thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 san francisco ca usa jiyangzhang pengyunie junyijessy li andmilos gligoric test 2public void docwithinvalidmapping02 throwsioexception ... 4customrolepara.getaccessibilityproperties .setrole htmlroles.p 5exception e assert.assertthrows pdfexception.
class document.add customrolepara assert.assertequals messageformat.format pdfexception .
role is not mapped to any standard role p e.getmessage assert.assertequals messageformat.format layoutexceptionmessageconstant .
role is not mapped to any standard role p e.getmessage javachangemadeby developers 2publicvirtual voiddocwithinvalidmapping02 ... customrolepara.getaccessibilityproperties .setrole layouttaggingpdf2test .htmlroles.p customrolepara.getaccessibilityproperties .setrole htmlroles.p exception e nunit.framework.assert.
catch typeof pdfexception document.add customrolepara exception e nunit.framework.assert.
isthrows pdfexception.
class document.add customrolepara nunit.framework.assert.areequal string.format pdfexception .
role is not mapped to any standard role p e.message nunit.framework.assert.areequal string.format layoutexceptionmessageconstant .
role is not mapped to any standard role p e.message c changepredicted by existing generation based model 2publicvirtual voiddocwithinvalidmapping02 ... 4customrolepara.getaccessibilityproperties .setrole 5layouttaggingpdf2test.htmlroles.p 6exception e nunit.framework.assert.catch typeof pdfexception document.add customrolepara nunit.framework.assert.areequal string.format pdfexception .
role is not mapped to any standard role p e.message nunit.framework.assert.areequal string.format layoutexceptionmessageconstant .
role is not mapped to any standard role p e.message c changemadeby developersand predicted by our codeditor figure1 exampleofusingllmstohelpdevelopersco evolve code in two programming languages.
the top box shows developer made changes in a java project itext itext7 whichneedstobepropagatedtothecorrespondingc project itext itext7 dotnet.themiddleboxshowstheprediction byanexistinggeneration basedlargelanguagemodel which incorrectly changes irrelevant parts of the code.
the bottom box shows the correct prediction by our model codeditor .
weexplicitlymodelthe changesthatneedtobemade.weformulate a novel task automatically updating code snippets in a target programminglanguage basedonthe changesmadeinthesource programminglanguage.
most of the existing models implicitly tackle the code evolution tasks by generating tokens one by one in accordance with the underlyinglearnedprobabilityinsteadoffocusingonhowthecode shouldbe modi f iedorretained.priorwork have shown that standard generation based models underperform models that explicitly modelthe editsonsoftware editing tasks.
to model code evolution across programming languages we design an llm dubbed codeditor which learns to align the edits acrossprogramminglanguagesandexplicitlyperformseditsonthe oldversionofthecodeinatargetprogramminglanguage.following prior work we enable the model to reason aboutnecessary edits and learn to apply them by directly generating an editsequence.
for training and evaluation we collect the f irst dataset with aligned java and c code changes on the methods with similar functionality and implementations.
speci f ically we extract pairsofcodechangesfrom8open sourcejavaprojectsandthecorresponding c projects on github by mining the commit histories.
thisisthe f irstdatasetcontainingparallelcodechangesoftwoprogramming languages.
we conduct the evaluation in two directions updatingc methodbasedonthejavachanges sourcelanguageis javaandtargetlanguageisc andupdatingjavamethodbasedon the c changes source language is c and target language is java .
our results show that codeditor outperforms all existing models across all the chosen automatic metrics including the large pretrained generative models codex under few shot setting and chatgpt under zero shot setting.
codeditor achieves out of codebleu score on the task of updating c code based on java changes which is more than higher than the large pretrainedgeneration basedmodel f ine tunedonthis task.
further we f indthat codeditor andgeneration basedmodels are complementary to each other as codeditor is better at updating longer code snippets while generation model is better at handling the shorter ones.
thus we combine the two models by choosingeithermodel spredictionbasedonthesizeoftheinput code.ourresultsshowthatthecombinationcanfurtherimprove ourcodeditor model sexact match accuracyby6 .
the main contributionsof this paper include task.
we formulate a novel task of automatically updating code writteninoneprogramminglanguagebasedonthechangesin the corresponding code inanotherprogramming language.
model.
we design and implement codeditor the f irst llm for this task which learns to align the edits across programming languages and explicitly performs edits on the old version of the code intarget programming language.
dataset.wecreatethe f irstdatasetwithalignedcodechangesfor two programminglanguages javaandc from8open source projectpairs.
results.weshowthat codeditor signi f icantlyoutperformsthe existing llms f ine tuned for code translation on exact match accuracyby77 .wealsoshowthat codeditor iscomplementary to generation based llms and the combination can further improvecodeditor sexact match accuracyby6 .
codeditor andour corpusare publiclyavailable ongithub .
task at a high level we work on a system that is triggered when a softwaredeveloper whomaintainsprojectswritteninmultipleprogramming languages makeschangestoonemethod inone ofthe languages i.e.
the source language.
the system would automaticallysuggestupdatestothemethodswithidenticalfunctionality in other language s i.e.
the target language s .
to scope our work inthis paper we focuson javaas the source language and c asthetargetlanguage.weleaveevaluationthattargetsother programming languagesas future work.
696multilingual code co evolution usinglarge languagemodels esec fse december3 san francisco ca usa table the mappings between concise edit sequence and unambiguous editsequence.
edit concise unambiguous insertion insert replacekeepbefore replacekeepafter deletion delete delete replacekeepbefore replacekeepafter replacement replace replace replacekeepbefore replacekeepafter in figure consider a method u1d440 u1d446 u1d45c u1d459 u1d451 docwithinvalidmapping02 writteninthesourcelanguage u1d446andamethod u1d440 u1d447 u1d45c u1d459 u1d451 docwithinvalidmapping02 written in the target language u1d447with identicalfunctionality hencesimilarimplementation .giventhe updated method u1d440 u1d446 u1d45b u1d452 u1d464in u1d446 we de f ine the task to generate the new method u1d440 u1d447 u1d45b u1d452 u1d464in u1d447leveraging context provided by the code changes u1d438 u1d446 such thatits functionality is consistent with u1d440 u1d446 u1d45b u1d452 u1d464.
namely we modelthe conditional probability distribution u1d443 u1d440 u1d447 u1d45b u1d452 u1d464 u1d440 u1d447 u1d45c u1d459 u1d451 u1d440 u1d446 u1d45b u1d452 u1d464 u1d438 u1d446 andgenerate u1d440 u1d447 u1d45b u1d452 u1d464bysampling from the distribution.
model we present the overview of the proposed codeditor model in figure2.codeditor is built upon the encoder decoder framework whichconsistsofatransformer basedencoderandatransformerbased decoder .
many conditional generation tasks including code summarization andtranslation are being addressed with encoder decoder models .
weinitialize codeditor sparameterswiththepretrainedlanguagemodelcoditt5 .coditt5hasshownpromisingresults onvarious software related editing tasks in a singleprogramming language but nonetheless would provide us with a warm start that carries the necessary inductive biases towards modeling edits.
to adapt to the multilingual co editing task we then f ine tune the codeditor modelexploringtwokeycomponents i thecontext fedintothe model ii the outputformat ofthe model.
to encourage our codeditor model to leverage the synchronous code change histories of multiple programming languages in itstraining data we provide the model with context from three sources as shown infigure i code changes on source programming language u1d438 u1d446 ii old version of the code written in target programming language u1d440 u1d447 u1d45c u1d459 u1d451 iii new version of the code writteninsourceprogramminglanguage u1d440 u1d446 u1d45b u1d452 u1d464 .
weexploretwoformatstorepresentthegeneratedcodechanges i the code edits in the target programming language u1d438 u1d447 ii a metaeditsequencethattranslatesthecodeeditsfromthesource programminglanguagetothetargetprogramminglanguage followed by the code edits in the target programminglanguage this is similartotheoutput format ofcoditt5 .
in bothcases we then applythegeneratedcodeeditsinthetargetprogramminglanguage u1d438 u1d447 totheoldversionofthecode u1d440 u1d447 u1d45c u1d459 u1d451 toobtainthenewversion ofthe code u1d440 u1d447 u1d45b u1d452 u1d464 .
.
editrepresentations .
.
concise edit sequence.
we f irst represent edits using a sequenceofeditsidenticaltothatusedincoditt5 whichwecall concise editsequence.eacheditisrepresentedas operation operationend here operation iseitherinsert deleteorreplace.notethat thereplaceis represented in a slightly different structure since wemustspecifyboththeold contentstobereplacedandthenew contentsto replace with replaceold replacenew replaceend forexample infigure thecodechange ontheoldjavamethod canbe represented by replaceold pdfexception replacenew layoutexceptionmessageconstant replaceend .
weusedifflib tocomputethesetofminimaleditsequence from the old andnewversionsof code.
.
.
unambiguouseditsequence.
onedrawbackofcoditt5 s representation speci f ied above is that the concise edit sequence can be ambiguous due to the absence of positional information.
forexample thejavacodechangeinfigure 1canberepresented usingreplace as replaceold pdfexception replacenew layoutexceptionmessageconstant replaceend .withoutfurther speci f ication the edit does not contain any clues regarding whichpdfexception should be replaced as there are two occurrencesof pdfexception intheold codesequence.for similarreasons insertisalwaysambiguousbecauseofnotindicatingwhere toaddthenewcontentsand deleteisambiguousincaseswhere multiple occurrences oftoken spans can be removed.
toeliminatethepotentialambiguityintheconciseeditsequence wedesigntheformatofunambiguouseditsequencebyadjusting the condensed edit sequence proposed by panthaplackel et al .
whichuses anchor tokens to specifythe location to perform edits.
insertion .
we do not use insertsince it will always introduce ambiguitywithoutlocationinformation.torepresentinsertion we f irst f ind unique anchor tokens that are the shortest span of tokens thatiseitherbeforeoraftertheeditlocationandisuniqueinthe inputsequence.thenweuse replacekeepbefore orreplacekeep after whichrepresentsreplacingtheanchortokenswiththeinserted contents and the anchor tokens.
for example in figure supposethejavacodechangeentailsaddingablankreturnstatement after the assertequals statement on line .
the token span getmessage will serve as the minimal span of anchor tokens becauseitisuniqueamongtheoldjavacodesequence anditoccurs right before the edit to be performed.
we disambiguate the edit sequence insert return insertend withthe unambiguous editsequence replaceoldkeepbefore getmessage replacenewkeepbefore getmessage return replaceend this edit sequence indicates that getmessage should be replacedwith getmessage return .weintroduce replacekeep beforewherethetokensthatfollowsthe replaceoldkeepbefore 697esec fse december3 san francisco ca usa jiyangzhang pengyunie junyijessy li andmilos gligoric replaceoldkeepbefore format pdfexception replacenewkeepbefore format layoutexceptionmessageconstant replaceend u1d438 u1d446 ... string.format pdfexception... u1d440 u1d447 u1d45c u1d459 u1d451 ... messageformat.format layoutexceptionmessageconstant.. u1d440 u1d446 u1d45b u1d452 u1d464editstranslation metaedits replaceoldkeepbefore format pdfexception replacenewkeepbefore format layoutexceptionmessageconstant replaceend u1d438 u1d447 replaceold format replacenew format replaceend meta edit sequence replaceoldkeepbefore format pdfexception replacenewkeepbefore format layoutexceptionmessageconstant replaceend u1d438 u1d447... string.format layoutexceptionmessageconstant.. u1d440 u1d447 u1d45b u1d452 u1d464 figure2 work f lowof codeditor formultilingualco editing.
codeditor leveragesthecontextofcodechangehistoriesof multiple programming languages from three sources code changes on the source programming language u1d438 u1d446 the old version ofcodeinthetargetprogramminglanguage u1d440 u1d447 u1d45c u1d459 u1d451 andthenewversionofcodeinthesourceprogramminglanguage u1d440 u1d446 u1d45b u1d452 u1d464 .
codeditor hastwovariantsthatbothgeneratethecodechangesinthetargetprogramminglanguage u1d438 u1d447 butindifferent formats editstranslationdirectlygeneratesthecodechanges metaeditsgeneratesthemetaeditplanwhichedits u1d438 u1d446to u1d438 u1d447 followed by the code changes.
finally we apply the code changes u1d438 u1d447 on the old version of code u1d440 u1d447 u1d45c u1d459 u1d451 to obtain the new versionofcode u1d440 u1d447 u1d45b u1d452 u1d464 inthetargetprogramming language.
should be removed and the tokens following replacenewkeepbefore shouldbeinserted.differentfrom replace thereissome overlap between the tokens to be removed and tokens to be inserted.ifanchortokensdonotexistbeforetheeditlocation weuse replacekeepafter with thetokens after theeditlocation instead.
replacement .
if the span of tokens to be replaced is unique in the old sequence regular replace sequence is sufficient and deterministic in that case we will keep using it.
otherwise it is unclear whichoccurrenceoftokenspanshouldbereplaced.asanexample in figure the java code change is changing from pdfexception tolayoutexceptionmessageconstant intheassertequals statementonline6.thereplacementintheconciseeditsequenceisambiguous because there are two usages of pdfexception on lines and in the old java code sequence after tokenization.
to address this similartotheinsertioncase wesearchfortheminimalanchor tokensbeforeoraftertheeditlocationthatcanformauniquespan inthe old sequence.for example the concise editsequence replaceold pdfexception replacenew layoutexceptionmessageconstant replaceend canbedisambiguateintothefollowingunambiguouseditsequence replaceoldkeepbefore format pdfexception replacenewkeepbefore format layoutexceptionmessageconstant replaceend deletion .similartoreplacement ifthespanoftokenstobedeleted is unique across the old sequence we will keep using delete because it is unambiguous.
otherwise it will be transformed to replacekeepbefore orreplacekeepafter .forexample suppose the token pdfexception .
should be removed from the old java methodonline6infigure .the concise editsequence delete pdfexception.
deleteend willbe transformedto replaceoldkeepbefore format pdfexception.
replacenewkeepbefore format replaceend this edit sequence indicates that format pdfexception .
should be replaced with format unambiguously implying the deletion of pdfexception .
.
to summarize the unambiguous edit sequence contains types of edits replace delete replacekeepbefore and replacekeepafter .themappingsbetweenconciseeditsequence and unambiguousedit sequenceare summarized intable .
given the unambiguous edit sequence we can apply it to the old input sequenceto derive the neweditedsequencedeterministically.
.
model input weaimtobuildperformantmachinelearningmodelsforthemultilingual co editing task by providing the model with code evolution information namelytherevisionsofcodeofbothsourceandtarget programminglanguages.insteadofdirectlytranslatingtheentire codesnippetbetweenprogramminglanguages codeditor translatesthe code changesbetween programming languages.
.
.
sourcecodeedits.
toencouragethemodeltolearnthealignmentbetweendeveloper madechangesacrossprogramminglanguages we provide codeditor with code changes in the source programming language.
to maintain both precision and conciseness of the edits we adopt the unambiguous edit sequence section3.
.
to represent the code changes.
as shown in figure the java code changes u1d438 u1d446 of replacing the pdfexception with layoutexceptionmessageconstant isstructuredinthe form of 698multilingual code co evolution usinglarge languagemodels esec fse december3 san francisco ca usa replaceoldkeepbefore format pdfexception replacenewkeepbefore format layoutexceptionmessageconstant replaceend .
.
history related context.
in addition to the learned representationofcodechangesinsourceprogramminglanguage u1d438 u1d446 weprovide codeditor withtheoldcodeintargetprogramming language u1d440 u1d447 u1d45c u1d459 u1d451 tobetterhelpthemodeltoinferthecorrelated code changes in the target programming language.
the intuition is thatthemodelwillreasonabouthowtotransferandtunetheedits insourceprogramminglanguagegroundingthespeci f icimplementation ofthe methodintarget programming language.
furthermore weappendthenewcodeinsourceprogramming language u1d440 u1d446 u1d45b u1d452 u1d464 as one of the contexts.
we believe this will give the model more context to understand the edits in source programminglanguageandpromotetheconsistencyoftheupdatedmethods intwoprogramminglanguages.
tosumup wecombinehistory relatedcontextfromthreesources codechangesinthesourceprogramminglanguage u1d438 u1d446 oldcode in the target programming language u1d440 u1d447 u1d45c u1d459 u1d451 and new code in the sourceprogramminglanguage u1d440 u1d446 u1d45b u1d452 u1d464 .weconcatenatetheminto asequenceseparatedbyaspecial septoken as the modelinput.
.
model output weproposetwoformatsasthemodel stargetoutputwhichlead to two modes of codeditor editstranslation andmetaedits .
both modes usethe same input andbothmodes target outputs entaila sequenceofeditsonthe target programming language.
editstranslation .
the output of editstranslation mode is the unambiguouseditsequenceintargetprogramminglanguagewhich suggests how the code in target programming language should bechanged.notethatthemodel generatedunambiguouseditsequence can be parsed and applied to old version of codedeterministically.
editstranslation essentially learns to translate the code edits from the source programming language u1d438 u1d446 to the target programming language u1d438 u1d447 grounding the code history context.
editstranslation mode s target output forthe c example infigure1is replaceoldkeepbefore format pdfexception replacenewkeepbefore format layoutexceptionmessageconstant replaceend metaedits .inthismode weadopttheoutputformatofcoditt5 formultilingualco editingsinceourmodelisbuiltuponcoditt5 and it had showed promising performance on software editing tasks.coditt5ispretrainedtogeneratethefollowingoutputformat sep .
the edit plan is a concise edit sequence that represents the steps to edit the input sequence thetargetsequenceistheeditedsequenceafterapplying theproceedingeditplan.wetailoredthisformattothemultilingual co editing task the edit plan represents the edits between the code edits on source programming language u1d438 u1d446 and target programming language u1d438 u1d447 which we call the meta edit sequence .
and the f inal target sequence should be the unambiguous edit sequence on thetargetprogramminglanguage u1d438 u1d447 .fortheexampleinfigure the expected meta edit sequence that converts java edit to c edit isthe following table2 open sourceprojectsusedinourdatasetandnumber ofexamples fromeachproject.
javaproject c project count antlr antlr4 tunnelvisionlabs antlr4cs apache lucene apache lucenenet apache poi nissl lab npoi eclipse jgit mono ngit formicary fpml toolkit java formicary fpml toolkit csharp itext itext7 itext itext7 dotnet quartz scheduler quartz quartznet quartznet terabyte jgit mono ngit sum table statistics of our dataset.
number of examples of training validation and test data average number of tokens in the old version of method and new version of method averagenumberofeditsforthecodechange averagenumber ofadded anddeleted tokens.
train val test count javaavg.len u1d440 u1d45c u1d459 u1d451 .
.
.
avg.len u1d440 u1d45b u1d452 u1d464 .
.
.
avg.
edits .
.
.
avg.
add.
tks .
.
.
avg.
del.tks .
.
.
c avg.len u1d440 u1d45c u1d459 u1d451 .
.
.
avg.len u1d440 u1d45b u1d452 u1d464 .
.
.
avg.
edits .
.
.
avg.
add.
tks .
.
.
avg.
del.tks .
.
.
replaceold format replacenew format replaceend the target sequenceafter applyingthe meta editsequenceis replaceoldkeepbefore format pdfexception replacenewkeepbefore format layoutexceptionmessageconstant replaceend notethatduringinference weonlyusethetargetunambiguousedit sequence to get the updated code in target programming language as metaedits mode sprediction.
dataset thisisthe f irstworktoconsiderthehistoryofsoftwareprojects in a multilingual task hence we also created a new dataset that includesalignedcodechangesbetweenprogramminglanguages.
as the f irst step we build the dataset by mining histories of the open source java and c projects.
we f irst collect the changed methods from the commits of the java and c projects.
we then design heuristics to pair i.e.
align those changes on methods with similar implementations and functionalities.
we consider two directions on our dataset j2cs updating c method based on java changes andcs2j updatingjavamethodbasedonc changes .in this section we describe the approach we use to collect the data section4.
split and preprocess data section .
and f inally present the statisticsofour dataset section .
.
699esec fse december3 san francisco ca usa jiyangzhang pengyunie junyijessy li andmilos gligoric .
data collection tobuild thedataset we extractalignedjavaand c codechanges atthemethodlevelastuples javaoldmethod javanewmethod c oldmethod c newmethod .thecodechangesareminedfrom the git commits.
we consider open source projects as listed in table2whichhavebothjavaandc implementationsandareused inpriorwork .alltheprojectswere f irstdevelopedin java andthen portedto c .
to collect the paired changes we f irst assign a unique identi f ier toeachmethodintheprojects forbothjavaandc projects based on the method signature class name and path to the f ile where the method is de f ined.
similar to the strategy used by lu et al .
we thenpairthejavamethodsandc methodsaccordingto thesimilarityoftheiruniqueidenti f iers.thisstrategyiseffective becausetheportedc projecthasverysimilarstructureandnaming rulesfor classesandmethodsto the corresponding java project.
we use the following rulesto extractthe alignedcode changes foreachjavamethodchange weextractthecodechangesin the paired c method that happen no later than days of the java change as the possible matched code change .
we use the commit dateas the time ofthe change.
to f ilterunrelatedcodechanges wecomputethejaccardsimilarity between c and java added and deleted lines.
we further re f ine the f iltering by sub tokenizing these linesbased on camelcase conventions e.g.
lastmodified tolast modi fied and compute jaccard similarity only for the added and deletedtokens.weonlykeeppossiblematchedcodechanges that have the token level jaccard similarity higher than .
and the line level jaccardsimilarityhigher than0.
.
for each javacode change and c code change we only select themostsimilarcorrespondingcodechangeiftherearemultiple possible matchedcode changes.
.
data preprocessing andsplitting forbothjavaand c methods we remove the inline naturallanguage comments and tokenize the method into tokens using the language speci f ic lexersgeneratedbyantlr .
we envision the following use case for the machine learning model wheneveradevelopermakesachangeintheprojectwritten in the source programming language the developer will use the model trained on the existing historical aligned code changes to migratethatchangetoprojectswritteninothertargetprogramming languages.toevaluatethemodelsunderthisusecase following the recommendations from prior work we split the dataset into training validation and test sets using the time segmented approach.namely thechangesinthetrainingsettookplacebefore thechangesinthevalidationset whichinturntookplacebefore thechangesinthetestset.morespeci f ic foreachjavaandc code changepair we f irstcollectthetimeofthec commitandthensort the code change pairs in chronological order.
we then select the oldest70 ofthecodechangepairsfromeachprojectastraining data next oldest as validation data the remaining as test data.
to morerigorouslyassess thegeneralizationcapabilitiesof the models wealsoevaluatedthemwhensplittingthedatasetusingthe cross project approach which is frequently used in prior workonmachinelearningmodelsforcode.speci f ically thealignedcode changes in the training set are from different projects compared to thoseinthe validation andtest sets.
.
statistics the statistics of the collected dataset are shown in table .
we present the number of examples in the training validation and test dataset using time segmented split approach.
we show the average number of tokens in the old methods avg.
len u1d440 u1d45c u1d459 u1d451 and new methods avg.
len u1d440 u1d45b u1d452 u1d464 after tokenization by the lexers.
to measure the size of the code changes we calculate the average numberofaddedtokens avg.
add.tks anddeletedtokens avg.
del.
tks in the changed java and c methods as well as the average number of edits avg.
edits needed for those changes.
forcomputingtheseedit relatedstatistics werepresentthecode changes using concise editsequences section .
.
.
forbothjavaandc codechanges thedifferencebetweenaverage number of added tokens and deleted tokens is usually small fewer than tokens.
similarly we f ind that the average number of editsneededisfewerthan3andtheeditshappenedinthenewer commits are generally smaller than prior ones.
this is expected as the software projects are becoming more stable as they evolve and thus there will be smaller code changes to be made.
for evaluation werunallthemodelsandbaselinesonthisdatasetintwodirections updating c method based on java changes and updating java method based on c changes.
we denote the former one as j2csandthe latter one as cs2j.
experiments inthissection wedescribethebaselineswecomparetowithour codeditor model section .
theevaluationmetrics section .
andthe detailedexperiment setup section .
.
.
baselines we evaluate our approach against rule based models pretrained encoder decodermodels thestate of the artcode editingmodel whichtargets asingleprogramminglanguage andlargegenerative models pretrainedonbillionsof linesof code.
copy.
this is a rule based model which copies the old code in target programming language u1d440 u1d447 u1d45c u1d459 u1d451 as the prediction.
this is not a trivial baseline since there are quite a few examples in the dataset that entail small edits between two versions.
we include this to benchmarkthe models that actually updatethe code.
copyedits .
based on our observations there are cases where the codechangeinsourceprogramminglanguage u1d438 u1d446 isexactlythe same as the change in target programming language u1d438 u1d447 such aschangingthevariablenameorupdatingthelogmessage.this rule based model copies the u1d438 u1d446and directly applies it to the old code intarget programming language u1d440 u1d447 u1d45c u1d459 u1d451 .
codet5 translation .weconsiderastate of the artmodelthat does not have access to the code change history.
namely a code translationmodelthattranslatescodebetweentheprogramming languages from u1d440 u1d446 u1d45b u1d452 u1d464to u1d440 u1d447 u1d45b u1d452 u1d464 .we usecodet5 anllm pretrainedonlargeamountofdeveloper writtencodefromgithub whichwe f ine tuneonour constructeddataset.
700multilingual code co evolution usinglarge languagemodels esec fse december3 san francisco ca usa codet5 update .thismodelhasthesamearchitectureascodet5translation except that we supply it with code change history.
the model input is the same as for our codeditor models i.e.
with extra context of the old code in target programming language u1d440 u1d447 u1d45c u1d459 u1d451 andthecodechangeinsourceprogramminglanguage u1d438 u1d446 .
different from codeditor model it is trained to directly generate the newcode intarget programminglanguage u1d440 u1d447 u1d45b u1d452 u1d464 .
coditt5.
this is the state of the art model for software editing tasks .
it has the same model architecture and input as codeditor while the output consists of the edit plan to represent the edits on the target programming language and the target sequence whichrepresentstheupdatedcode u1d440 u1d447 u1d45b u1d452 u1d464 afterapplyingtheedit plan.
codex few shot .largepretrainedgenerativemodelssuch asgpt haveshownimpressiveresultsunderthecontextof few shot learning or evenzero shot learning on various generation tasks.
they are ableto generalize to new tasksthey have not seen duringpretrainingwithonlyafeworevennolabeledexamples.to compare the f ine tuned codeditor model with generative models we include codex a large generative model built on gpt and is further pretrained on billions of github data.
following prior work for each example in test data we randomly select severallabeledexamplesinthetrainingdataasthecontext.note that the labeled examples are selected from the same project as the test data.
for j2cs dataset each labeled example is formed as java u1d440 u1d446 u1d45c u1d459 u1d451 u1d440 u1d446 u1d45b u1d452 u1d464c u1d440 u1d447 u1d45c u1d459 u1d451 u1d440 u1d447 u1d45b u1d452 u1d464 to inform the modelthealignedupdatesbetweentwoprogramminglanguages.
thedesignedpromptforinferenceis java u1d440 u1d446 u1d45c u1d459 u1d451 u1d440 u1d446 u1d45b u1d452 u1d464c u1d440 u1d447 u1d45c u1d459 u1d451 .themodeloutputisthepredictionforthenewcodein targetprogramminglanguage u1d440 u1d447 u1d45b u1d452 u1d464 .toconformtotherequired inputlength limit we include 2labeledexamples inthe prompt.
chatgpt zero shot .
chatgpt is an upgraded version of gpt model and is further f ine tuned for conversation generation following human instructions with the help of supervised and reinforcement learning methods.
it has showed strong performance on codecompletionbenchmarkslikehumanevalandmbpp .
for each example in test data we provide instructions including both theprevious and theupdated versions ofthecodewritten in the source programming language subsequently prompting chatgpt to update the old code in the target programming language accordingly.
for j2cs dataset the prompt is formed as the developer updates the java method from u1d440 u1d446 u1d45c u1d459 u1d451to u1d440 u1d446 u1d45b u1d452 u1d464.
please update the c method accordingly.
this is the old c method u1d440 u1d447 u1d45c u1d459 u1d451.
.
evaluationmetrics following priorwork we usemetricsforevaluating thequalityofcodegeneration bleu codebleu xmatch andmetricsforevaluatingthequalityofsoftwareediting sari andgleu .notethatforallthemetricswereportinthispaper they range from 0to 100andhigher scores are better.
xmatch.
when the generated code matches exactly with the expected code in target programming language this metric is otherwise this metric is .
this metric re f lects the percentage of exact matches among the models predictions ontest data.bleu.
it is a widely used metric originally proposed for evaluating the quality of machine translation.
it measures the n gram overlap between the generated sequence and the expected one.
concretely wereportthe1 gramsoverlapbetweenthetokens inthe predictions andtokens inthe ground truth.
codebleu .themetricisproposedforevaluatingthequalityof code generation.
in addition to measuring the n gram overlap it considerstheoverlapoftheabstractsyntaxtree ast anddata f lowgraph between generatedcode andthe expectedcode.
sari.itmeasuresqualityofthesystemsthataredesignedtomake edits.
speci f ically it is computed as the average of the f1 score for kept and inserted spans of tokens and the precision of deleted spans oftokens.
gleu.
it is a variant of bleu.
it was originally proposed for grammatical error correction and designed for rewarding the correct editswhilepenalizingthe incorrectones.
.
experimentalsetup we run all experiments on machines with nvidia ti gpus intel r xeon r cpue5 2620v4 .10ghzfortraining.weimplement our models using pytorch .
.
.
all the hyper parameters ofthecodet5andcoditt5baselinesaresettothesamevaluesasin priorwork .forcodeditor codet5 translation codet5update and coditt5 we early stop the training when the bleu score onthe validation set doesnot improve for epochs and use beam search with beam size during inference.
for codex and chatgpt we settemperature to .
duringinference.
notethatcodexandchatgptareclosed sourceandmaybeupdated deprecated over time.
we used the code davinci version of codex when performing experiments in the time segmented split however openai deprecated codex in march before we could complete our experiments in the cross project split as such we didnot include codex inthis part of results.
results we organize our evaluation around three main research questions rq1 what is the bene f it of using code change history in multilingual co editing?
rq2 how does our edit based model codeditor compare to generation basedmodels for the multilingualco editing?
rq3 how can a generation based model complement codeditor modelto further improve the performance?
.
quantitativeanalysis in tables we present results for baselines and our proposed codeditor models on j2cs cs2j for both time segmented and cross project splits.
we conducted statistical signi f icance testing throughbootstraptests undercon f idence level .
rq1 conntribution of code change histories.
we divide models into two categories with respect to whether a model has access to the information on code change histories copy and codet5translation are history agnostic models and the remaining are history awaremodels.overall thehistory awaremodelsoutperformthehistory agnosticones.therule basedmodelcopyedits 701esec fse december3 san francisco ca usa jiyangzhang pengyunie junyijessy li andmilos gligoric table results on thej2cs dataset.
the results with thesamesuffixes e.g.
u1d6fd are notstatistically signi f icantly different.
models xmatch bleu codebleu sari gleu copy .
.
.
.
.
copyedits .
u1d6fd90.
u1d6fc u1d71291.
.
.
codet5 translation .
u1d6fd87.
.
.
.
codet5 update .
u1d71690.
u1d712 u1d70276.
.
.
coditt5 .
u1d71689.
u1d6fc u1d70275.
.
.
codex few shot .
.
.
.
.
chatgpt zero shot .
.
.
.
.
codeditor metaedits .
.
.
.
.
codeditor editstranslation .
.
.
.
u1d6ff94.
hybrid .
.
.
.
u1d6ff95.
table results on thecs2j dataset.
the results with thesamesuffixes e.g.
u1d6fd are notstatistically signi f icantly different.
models xmatch bleu codebleu sari gleu copy .
.
.
.
.
copyedits .
.
u1d6fc90.
u1d6fd75.
.
u1d712 codet5 translation .
.
u1d6fc77.
u1d6fd83.
.
u1d712 codet5 update .
.
.
u1d6fe79.
.
coditt5 .
.
.
u1d6fe81.
.
codex few shot .
.
.
.
.
chatgpt zero shot .
.
.
.
.
codeditor metaedits .
u1d716 u1d70293.
.
.
.
codeditor editstranslation .
u1d6ff u1d71695.
.
.
.
hybrid .
u1d6ff u1d70296.
.
.
.
table6 resultsonthecross projectsplitusingj2csdataset.theresultswiththesamesuffixes e.g.
u1d6fd arenotstatistically signi f icantly different.
models xmatch bleu codebleu sari gleu copy .
.
u1d6fc89.
.
.
copyedits .
.
.
.
.
codet5 translation .
.
.
.
.
codet5 update .
.
u1d6fc66.
.
.
coditt5 .
.
.
.
.
chatgpt zero shot .
.
.
.
.
codeditor metaedits .
.
u1d6fd91.
.
.
u1d712 codeditor editstranslation .
.
u1d6fd91.
.
.
u1d712 hybrid .
.
.
.
.
which directly applies the code change in source programming language u1d438 u1d446 to the old code in target programming language without any adaptation has comparable performance to the machine learning history agnostic model codet5 translation.
this emphasizesthe importance of contextual information providedby codechangehistoriesinmultilingualco editing.interestingly we f ind that codex few shot which is used under the few shotlearning setting without f ine tuning performs better than f ine tunedcodet5 translation on xmatch while worse than other historyaware f ine tunedmachine learning models.
this again underlines thevalueofcodechangehistoriesandsuggeststhat f ine tuningwill give better performance by leveraging more code history contexts inthe training data.
rq2 codeditor vs. generation based models.
among all the history awaremodels machinelearningmodels suchascodet5updateandcoditt5 achievemuchhigherperformancethanthe 702multilingual code co evolution usinglarge languagemodels esec fse december3 san francisco ca usa table7 resultsonthecross projectsplitusingcs2jdataset.theresultswiththesamesuffixes e.g.
u1d6fd arenotstatistically signi f icantly different.
models xmatch bleu codebleu sari gleu copy .
.
.
.
.
copyedits .
.
.
.
.
codet5 translation .
.
.
.
.
codet5 update .
.
.
.
.
coditt5 .
.
.
.
.
chatgpt zero shot .
.
.
.
.
codeditor metaedits .
.
u1d6fc91.
.
.
u1d6fd codeditor editstranslation .
.
u1d6fc90.
.
.
u1d6fd hybrid .
.
.
.
.
subtokens0.
.
.
.
.
.0xmatch codet5 update codeditor editstranslation figure average percentage of model s predictions that exactlymatchthegroundtruthonexamplesthathavedifferent number of subtokens.
the bands represent the con f idenceinterval.
subtokens050100150200250300350400count codet5 update codeditor editstranslation figure distribution of number of sub tokens in models targetoutputs.
rule based copyedits which demonstrates that the machine learningmodelseffectivelylearnstoreasonaboutthecorrelatedcode changes and adjust them to the target programming language.
we observethat codeditor inbotheditstranslationandmetaedits modes which is trained to f irsttranslate codechanges onsource programming language to target programming language and then apply the edits to the old code in target programming language achieve even higher performance across all the metrics than the largepretrainedgeneration basedmodel codet5 update which directlygeneratesthenewcodeintargetprogramminglanguage from scratch.
this highlights that the models that are trained to explicitlyperformeditsbypredictingtheeditsequencearebetter suited for editing tasks in the software domain than generationbasedmodels.
to further investigate the advantages of codeditor over the best generation based model codet5 update we break down theperformanceofeditstranslationandcodet5 updateoneach example in the test data of j2cs.
in figure we show the average percentage of codeditor editstranslation and codet5 update s predictionsthatexactlymatchthegroundtruthwithrespecttothe number of sub tokens in the input old code u1d440 u1d447 u1d45c u1d459 u1d451 .
note that the codearesubtokenizedusingtherobertatokenizer whichis usedbyallmachinelearningmodels.weexcludetheexamplesthat have more than sub tokens from being shown in this f igure as those outliers only account for less than of the test data.
we canseethattheperformanceofcodet5 updatedrasticallydrops with the increase of number of sub tokens in the code to be edited u1d440 u1d447 u1d45c u1d459 u1d451 buteditstranslation sperformanceisratherstable.this illustrates another bene f it of codeditor in accurately handling longerinput becauseoffocusingontransformingtheeditsinstead ofgeneratingthe entire newcode like codet5 update.
meanwhile most of the existing transformer based models have alengthlimitfortheinputsequencebecausethenaiveself attention has quadratic complexity with regard to the input length.
in figure4 wepresentthedistributionofthenumberofsub tokensin themodels targetoutputsfor codeditor editstranslation and codet5 updateonthetestdataofj2cs.weonlyshowthedistribution of target outputs with fewer than sub tokens for the same reason described in the previous paragraph.
most of codeditor stargetoutputs thesequenceofeditoperations areshorter than codet5 update s output new code in target programming language .
this might explain why codeditor achieves better performance than generation based models on longer code as generatinglongersequencearegenerallymorechallengingtomachine learningmodels.recentstudies havefocusedonexploring approachestoaddressthelimitationofthemodel sinputcontext 703esec fse december3 san francisco ca usa jiyangzhang pengyunie junyijessy li andmilos gligoric 1public static document parsebodyfragment string bodyhtml string baseuri ... 3list node nodelist parsefragment bodyhtml body baseuri 4node nodes nodelist.toarray newnode for inti nodes.length i nodelist.size i for inti nodes.length i i nodes .remove ... javachange 1public static document parsebodyfragment string bodyhtml string baseuri ... 3ilist itext.styledxmlparser.jsoup.nodes.node nodelist parsefragment bodyhtml body baseuri 4itext.styledxmlparser.jsoup.nodes.node nodes nodelist.toarray newitext.styledxmlparser.jsoup.nodes.node 5for inti nodes.length i nodelist.count i nodes .remove ... ... for inti nodes.length i nodelist.count i for inti nodes.length i i ... ... itext.styledxmlparser.jsoup.nodes.node nodes nodelist.toarray newitext.styledxmlparser.jsoup.nodes.node itext.styledxmlparser.jsoup.nodes.node nodes nodelist.toarray newitext.styledxmlparser.jsoup.nodes.node for inti nodes.length i nodelist.count i for inti nodes.length i i ... ... itext.styledxmlparser.jsoup.nodes.
node nodes nodelist.toarray newitext.styledxmlparser.jsoup.nodes.
node node nodes nodelist.toarray newnode for inti nodes.length i nodelist.count i for inti nodes.length i i ...c oldmethod codeditor editstranslation prediction codet5 updateprediction codet5 translationprediction figure qualitative analysis ofallthemodels on oneexample inthetestdata ofj2cs dataset.
window size.
future research should examine the performance difference between translating edit sequences and generating entirely newcode using models capableofhandling longer context.
rq3 combininggeneration basedmodelwith codeditor .
to exploit the superiority of generation based model on short code snippets we combine our strongest generation model codet5update with the strongest codeditor mode editstranslation based onthesizeof thecodesnippet.
speci f ically we usecodet5updateifthecodetobeupdatedhasfewersub tokensthanathresholdanduse codeditor editstranslation otherwise.topickthe thresholdforcombiningtwomodels weperformedagrid search onthevalidationsetandselectedtheonethatgivesoptimalxmatch score.
we refer to the combined model as the hybridmodel and provideitsresultsonthebottomrowoftable 4totable7.bycombininggeneration basedmodelwith codeditor wecanachieve improved performance on most of the reported automatic metrics.
.
qualitativeanalysis figure5shows an example in j2cs dataset and the models predictions.
we show the code changes from java project itext itext7 inthemethod parsebodyfragment .thenewlyaddedcodeishighlightedingreenandremovedcodeishighlightedinred.wealso presenttheoldversionofthecorrespondingc method parsebody fragment fromitext itext7 dotnet and the predicted codechangesfromthreemodels codeditor editstranslation codet5update codet5 translation.
note that codet5 translation only has access to the newversionof java method.
althoughcodet5 translationisabletocorrectlytranslatethe code change in java it fails to infer the full name of the type node and makesan irrelevantedit because it does not have the context of the old version of c code.
codet5 update correctly captures the java change while making an extra irrelevant edit on the c code.
our proposed model codeditor editstranslation accuratelyidenti f iesthepositioninthec methodtomakeeditsand correctlyadjusts the java edits.
limitations studiedprogramminglanguages ..westudythetranslationof code changesbetween two programming languages.
in this paper we focus on open source java and c projects due to the ease oflocating correspondingchangesusing heuristics.nevertheless it is important to note that our approach can be applied to other programminglanguagepairsaswell andweleavetheinvestigation ofsuch pairsfor future research.
correspondencebetweenprogramminglanguages .ourmodel codeditor is intended for developers to migrate code changes fromaprojectwritteninasourceprogramminglanguagetoprojects 704multilingual code co evolution usinglarge languagemodels esec fse december3 san francisco ca usa writtenintargetprogramminglanguages leveragingknowncorrespondences e.g.
methodswithsimilarfunctionalities between the source and target programming languages.
in this work we adoptasimilarstrategyusedin tomatchjavaandc methods.
in practice a code retrieval system can be used as a f irst step to identifythelocationswherethecodechangesshouldbepropagated.
we leave the combination of code retrieval tool and codeditor as future work.
empiricalevaluation .thispaperpresentstheempiricalstudyresultsforinternalmetricsthatareofinteresttoresearchers.however theexternalmeasurementsoftheimpactonsoftware engineering effort are not included in this study.
these measurements could be addressedbyconductinguserstudies.
related work in this section we describe related work on the rule based code translation tools existing machine learning models designed for codetranslation andthemachinelearningmodelsthatareproposed for accelerating software evolution.
rule based code translation .
researchers and practitioners have designed rule basedtools fortranslatingthesourcecodebetween programminglanguages.suchtools usuallycalledtranspilers were built for pairs like java and c c and rust c and go .
nguyen et al .
proposed pbsmt a phrase based statistical machine translation models for source code translation.
gyori et al .
proposed lambdaficator totranslateimperativejavacodeto using the functional stream apis.
ra al .
presented the rule basedmodeltotranslatesequentialjavacodetomapreduce framework.
prior work has shown that existing rule based code refactoring tools can only deal with stylized code snippets over common code patterns.
learning based code translation .
researchers have proposed variousmachinelearningmodelsforthecodetranslationtask.chen et al.
proposed a tree to tree neural network with a tree rnn encoder and a tree rnn decoder.
motivated by the success of large pretrained llms for many natural language processing tasks domain speci f ic models that are pretrained on source code and technical text have emerged.
researchers have applied them to the codetranslationtask.luetal .
proposedcodexglue abenchmark including the code translation dataset consisting of java and c methodswithequivalentfunctionality.they f ine tunedandevaluated codebert on the translation dataset.
results showed that it produced the best results among all the existing baselines.
llms thatarebuiltontheencoder decoderparadigmandpretrainedwith generalunsuperviseddenoisingauto encodingobjectivesshowed promisingresultsonwiderangeofcodegenerationtasksincluding code translation.
such models include codet5 plbart and unixcoder .
for the comparison of codeditor with stateof the art code translation models we include two variants ofthe codet5 basedtranslationmodels withhistorycontextandwithout inour evaluation.
researchersdesignedllmswhicharepretrainedwiththeobjective tailored for code translation.
tipirneni et al .
introduced tasksonpredictingastpathsanddata f lowsduringpretraining.
lachaux et al .
proposed transcoder which is pretrained to do code translation with back translation objective.
to improve thequality of pretraining data roziere et al .
leveraged an automated unit testing system to f ilter out invalid generated programs during back translation.
zhu et al .
proposed must which is a multilingualcodesnippettranslationpretrainingobjective.none of the above work leverages the code change history which is the main contribution of our paper.
we leave improving codeditor withpretrainingobjectivestailoredforcodetranslationasfuture work.
software evolution and machine learning .
new research initiativeshaveemergedaroundbuildingandevaluatingmodelsthataid theprocessofsoftwareevolution.priorwork proposedto updatethecomment giventhe changesinthe associated method e.g.
panthaplackeletal .
builtamodelthattakesthe codechangeascontexttomakeeditsontheoutdatedcomment.nie etal.
presentdifferentapproachestosplitdatasetintotraining validationandtestsetsandstudiedhowdifferentapproachesaffect theevaluationofmachinelearningmodels.kamezawaetal .
presented a dataset rnsum which consists of release notes and the associated commit messages collected from github repositories and designed models to generate release notes based on the commitmessages.zhangetal .
proposedanovelpretraining objective designed for software editing tasks and built coditt5.
coditt5was f ine tunedonthreedownstreamtasksrelatedtothe software evolution.
li et al .
tufano et al .
zhang et al .
proposed models that targeted various tasks through the code reviewprocess.themodelsaretrainedonthehistoricaldataand evaluated on the new pull requests submitted for code review.
our codeditor model incorporates the context from the code changes in source programming language and the old version of method in target programming languages toimprove itsperformance on the multilingual co editing task which helps developers co evolve the projectsimplementedindifferentprogramming languages.
conclusion in thispaper we formulateda new task translatingcode changes acrossprogramminglanguageswiththegoaltosynchronizeprojects that provide the same apis or implementations in multiple programminglanguages.weproposed codeditor amodelwhichuses code change history as contextual information and learns to make edits on the existing version of code written in the target programminglanguage.weshowedthatourmodeloutperformsexisting code translation models and is better than the generation based modelseveniftheyusehistoricalcontext.
codeditor isasigni f icant advancement in supporting developers with the maintenance oftheirprojectsthatincrementallyprovideidenticalfunctionalities inmultiple programming languages.