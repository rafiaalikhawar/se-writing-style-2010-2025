akka mutation testing for actor concurrency in akka using real world bugs mohsen moradi moghadam oakland university usa moradimoghadam oakland.edumehdi bagherzadeh oakland university usa mbagherzadeh oakland.edu raffi khatchadourian hunter college city university of new york usa raffi.khatchadourian hunter.cuny.eduhamid bagheri university of nebraska lincoln usa bagheri unl.edu abstract actor concurrency is becoming increasingly important in the realworld and mission critical software.
this requires these applications to be free from actor bugs that occur in the real world and have tests that are effective in finding these bugs.
mutation testing is a well established technique that transforms an application to induce its likely bugs and evaluate the effectiveness of its tests in finding these bugs.
mutation testing is available for a broad spectrum of applications and their bugs ranging from web to mobile to machine learning and is used at scale in companies like google and facebook.
however there still is no mutation testing for actor concurrency that uses real world actor bugs.
in this paper we propose akka a framework for mutation testing of akka actor concurrency using real actor bugs.
akka is a popular industrial strength implementation of actor concurrency.
to design implement and evaluate akka we take the following major steps manually analyze a recent set of real akka bugs from stack overflow and github to understand their causes design a set of mutation operators with source code changes in akka api to emulate these causes and induce their bugs implement these operators in an eclipse plugin for java akka use the plugin to generate .7k mutants of real github applications with .4k lines of code and .9k tests run these tests on these mutants to measure the quality of mutants and effectiveness of tests use pit to generate .2k mutants to compare akka and pit mutant quality and test effectiveness.
pit is a popular mutation testing tool with traditional operators manually analyze the bug coverage and overlap of akka pit and actor operators in a previous work and discuss a few implications of our findings.
among others we find that akka mutants are higher quality cover more bugs and tests are less effective in detecting them.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
concepts software and its engineering software testing and debugging theory of computation concurrency .
keywords mutation testing actor concurrency mutation operators mutant quality test effectiveness akka akka.
acm reference format mohsen moradi moghadam mehdi bagherzadeh raffi khatchadourian and hamid bagheri.
.
akka mutation testing for actor concurrency in akka using real world bugs.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
introduction actor concurrency is becoming increasingly important in the realworld and mission critical software.
for example paypal uses actor concurrency to serve more than a billion financial transactions per day spark to shuffle hundreds of terabytes of big data and groupon to personalize coupons for million customers in real time .
nasa microsoft twitter verizon capitalone and weight watchers are among many other users of actor concurrency .
this requires these applications to be free from actor bugs that occur in the real world and have tests that are effective in finding these bugs which can cost large sums of money or even lives.
unlike multithreaded concurrency in which lower level threads communicate using shared memory and locks in actor concurrency higher level actors communicate using asynchronous messages .
this makes not only actor concurrency but also its bugs fundamentally different from multithreaded concurrency .
previous work discusses some of these differences.
mutation testing is a well established technique that transforms the source or the binary code of an application to induce its likely bugs and evaluate the effectiveness of its tests in finding these bugs.
mutation testing is available for a broad spectrum of applications and their bugs ranging from web to mobile to machine learning and is used at scale in companies like google and facebook .
however esec fse december san francisco ca usa mohsen moradi moghadam mehdi bagherzadeh raffi khatchadourian and hamid bagheri there still is no mutation testing for actor concurrency that uses realworld actor bugs .
the only relevant work is the work by jagannath et al.
that proposes mutation operators in actorfoundry .
however these operators are based on the individual experiences of the authors and not a curated set of real bugs are not implemented are not evaluated and are often specific to actorfoundry s syntax and semantics and not applicable to today s industrial strength implementations of actor concurrency.
actorfoundry is a nowdefunct research prototype actor language with no industrial use.
we discuss this work further in detail throughout the paper.
in this paper we propose akka a framework for mutation testing of akka actor concurrency using real actor bugs.
akka from lightbend is an industrial strength implementation of actor concurrency among others such as orleans from microsoft and erlang from ericsson.
we focus on akka because it is growing faster than others.
for example in the past five years there are 727akka questions and answers in stack overflow which is .
and .2x more than erlang and orleans respectively.
similarly there are 034akka applications in github which is .
and .3x more than erlang and orleans.
to design implement and evaluate akka we take the following major steps manually analyze a recent set of real akka bugs from stack overflow and github to understand their causes.
design a set of mutation operators with source code changes in akka api to emulate these causes and induce bugs.
implement these operators in an eclipse plugin for java akka.
use the plugin to generate mutants of real github applications with lines of code and tests.
run these tests on these mutants to measure the quality of mutants and the effectiveness of tests in detecting and killing these mutants using ease of killing duplicity subsumption and mutation score metrics that previous work uses often.
use pit to generate mutants to compare akka and pit mutant quality and test effectiveness.
manually analyze the bug coverage and overlap of akka pit and jagannath et al.
s actor operators.
discuss the implications of our findings.
pit is a popular mutation testing tool with traditional logic operators such as math that replaces mathematical operands .
among others we find that mutant quality akka mutants are high quality 2x harder to kill 3x less duplicate and .3x less subsumed than pit.
test effectiveness tests are ineffective for akka mutants .3x less effective in covering and .3x less effective in killing akka mutants than pit.
bug coverage akka bug coverage is high .3x more bug coverage than jagannath et al.
s. and akka bug coverage benefits from the addition of pit akka pit cover .1x more bugs than akka alone and .5x more than pit alone.
a few implications of our findings are in predictive selective and sampling mutation testing and actor concurrency testing.
background in this section we discuss the basics of actor concurrency akka and mutation testing that we use throughout the paper.
.
actor concurrency basic actor concurrency unlike multithreaded concurrency in which a program is a set of threads that communicate using shared memory and locks in basic actor concurrency the program is a set of actors that communicate by sending receiving and processing of asynchronous messages .
an actor has its own thread of execution and behavior and makes its state accessible only through messages to avoid sharing.
to send a message a sender actor sends a fire and forget message without waiting and blocking for its response.
to receive the message a receiver actor enqueues the message in its mailbox .
to process the message the receiver dequeues the message from its mailbox and executes it sequentially and to the end before processing the next message in the mailbox.
during the processing an actor can change state and behavior send a message or create a new actor.
akka actor concurrency to allow for the development of realworld applications akka extends the basic actor concurrency with several necessary features most of which are programmatic and dynamic .
these features are actor path to locate a local or remote actor life cycle to manage the actor life parental hierarchy and supervision to manage the actor creation and failure configurationto configure an application settings actor system to provide the actor dispatch and scheduling dispatch to assign threads to the actor message processings scheduling to schedule the actor message sendings interaction patterns to support more ways of actor interactions stashing to buffer the actor messages for delayed processing deployment to deploy remote actors and clustering for distribution of actors over network.
these features are often the causes for akka bugs and are discussed further throughout the paper.
actorfoundry lacks most of these features.
.
mutation testing basics mutation testing transforms the source or binary code of an application to induce its likely bugs and evaluate the effectiveness of its tests in finding these bugs.
for each bug a mutation operator slightly changes the application code to emulate the cause of the bug and induce the bug.
the operator generates a mutant of the application which is the original application plus the induced bug.
a test is effective if it can detect andkilla mutant by distinguishing its behavior from the original application behavior otherwise the mutant stays a live.
a test cannot kill a mutant that it does not cover .
a test covers a mutant if its execution executes the mutated part of the mutant.
intuitively the more mutants the tests cover and kill the more effective the tests are.
types of mutants there are different types of mutants includingstillborn easy to kill trivial redundant duplicate subsuming subsumed and equivalent .
for a mutant mof an original application pand the set of tests tmcover andtm killthat respectively cover and killm mis stillborn if it includes syntactic and semantic errors that a compiler can catch and thus prevent its compilation.
a mutant m is easy to kill if a large number kof tests in tmcover kill it.
following previous work we set kto .
.
a mutant mis trivial if all the tests in tmcover can kill m. triviality is a special case of ease ofkilling.
a mutant mis redundant if tests that kill another mutant m can also kill m. a redundant mutant is either duplicate or subsumed.
a mutant mis the duplicate of m if their behaviors are the 263 akka mutation testing for actor concurrency in akka using real world bugs esec fse december san francisco ca usa functional equivalent of each other but not equal to p. duplicate mutants are syntactically different from each other but semantically the same.
a subsuming mutant msubsumes a subsumed mutant m iftm killis a subset of tm kill.mis equivalent if its behavior is the functional equivalent of p. an equivalent mutant is syntactically different from the original application but semantically the same.
automatic determination of all duplicate and equivalent mutants is proven to be undecidable .
our definition approximates duplicity using the execution of tests .
approximation of equivalence requires complex heuristics and analyses such as weakest precondition and is out of the scope of this work.
our definitions follow similar definitions from previous work for stillborn easy to kill trivial redundant duplicate subsuming subsumed and equivalent .
quality of mutants the quality of mutants is critical to mutation testing since non quality mutants could bias the testing.
for example previous work shows that using subsumed mutants which are non quality could on average bias the conclusions of of arbitrary sets of mutation testings.
a mutant misquality useful or valuable to mutation testing if it is killable and its killing requires the addition of a new test to set of tests tmcov that cover it otherwise it is non quality .
trivial easy to kill redundant and equivalent mutants are among the most well known non quality mutants .
this is because all and a large subset of tests in tmcovcan kill a trivial and easy to kill m respectively with no need for a new test a non empty subset of tmcovthat kills m can also kill its redundant mwith no need for new tests and there is no test that can kill an equivalent m. our definition follows similar definitions from previous work for quality mutants .
effectiveness of tests mutation testing evaluates the effectiveness of tests in finding bugs that it induces.
mutation score is the most well known metric to measure the effectiveness of tests.
for the set of all tests tcovthat cover at least a mutant the traditional mutation score is the ratio of the number of mutants that tests intcovkill to the number of all mutants.
our definitions follow similar definitions from previous work for the mutation score .
mutant coverage neither all tests cover all the mutants nor all mutants are covered by all the tests.
mutant coverage is the metric that measures the coverage of mutants.
our definition follows the standard definition of coverage .
bug coverage a mutation operator covers a bug if it can emulate the cause of the bug and induce the bug.
our definition follows similar definitions from previous work for bug coverage .
methodology in this section we discuss our methodology to analyze akka actor bugs design and group akka mutation operators for these bugs and measure the quality of mutants that akka and pit operators generate the effectiveness of tests to identify these mutants and the coverage of bugs by akka and jagannath et al.
s operators.
.
akka actor bugs for akka bugs we use a set bof186real bugs from a recent previous work .bincludes 130bugs from stack overflow questions and answers and 56bugs from github applications.
these bugs cover a broad spectrum of causes ranging from api confusion to model confusion to missteps in the application logic and a broad spectrum of symptoms ranging from incorrect messaging to incorrect termination to unexpected application behavior.
.
mutation operators design for each bug in b we take the following steps to design the mutation operator that induces the bug.
first we manually analyze the bug to understand its cause.
for example there is a bug inbin which an actor cannot be created with a cause that its name is not unique.
akka requires unique actor names.
second we manually search akka api and its documentation to identify methods that can emulate this cause by small changes in their syntax .
several methods may emulate the same cause.
for example actorof string name and actorof are two akka methods that their invocations create an actor with a given and random name respectively.
changing these invocations to actorof string name could emulate the cause in which the actor name is not unique if name is an actor name that exists already.
we ensure that the syntactic changes of our operators do not violate the compile time syntax and semantic requirements of akka java api.
third we select a name for the mutation operator that describes the changes it makes.
for example we give the name change name to the operator that changes actorof string name and actorof toactorof string name .
for a stack overflow bug we analyze its questions answers and comments to understand its cause and design its operator.
similarly for a github bug we analyze its commit messages original and modified code snippets pull requests and issues.
we use the open card sort to identify api methods their source code changes and the name of a mutation operator.
in the open card sort there are no predefined api methods source code changes and operator names instead they are developed during the sorting process.
to sort the first and second authors individually analyze the bugs and reiterate and refine until they agree.
the second author is a software engineer and programming languages professor with extensive expertise in actor and multithreaded concurrent systems.
the first author is a ph.d. student with extensive coursework in concurrent and mobile systems.
the third and fourth authors are software engineer professors with extensive expertise in concurrent and streaming systems and testing and fault localization respectively.
first three authors have several years of extensive industrial work experience.
in total we design 32mutation operators using source code changes in 138akka api.
table shows these operators and their short descriptions.
the formalization and api source code changes for these operators can be found in our replication package .
grouping we use the same open card sort to group the mutation operators based on the semantic relation between the bug causes they emulate.
for example change path groups together change name andchange hierarchy operators that change the related name and the hierarchy parts of the path of an actor.
in akka the path of an actor denotes its physical location in a system and 264esec fse december san francisco ca usa mohsen moradi moghadam mehdi bagherzadeh raffi khatchadourian and hamid bagheri includes its name and hierarchy among others.
in total we group our operators into 8groups.
table shows these groups.
compile time and logic bugs to avoid the generation of stillborn mutants we do not design mutation operators for compiletime bugs.
generation and compilation attempts for stillborn mutants decrease the efficiency of mutation testing because they can neither be compiled nor executed.
a bug is a compile time bug if its cause is a syntactic or semantic issue that prevents its successful compilation.
for example there is a bug inbin which the compilation fails because of using an undeclared variable.
there are21 .
compile time bug in b. similarly to avoid the redesigning of non akka and traditional operators that already exist we do not emulate logic bugs.
a bug is a logic bug if its cause is a misstep in the application logic.
for example there is a bug inbin which the lookup and message delivery for a remote actor fails because an skipped if conditional creates the wrong path for the actor.
the traditional operator negate conditional in pit can emulate this bug by negating the condition of the conditional.
there are .
logic bugs in b. in total we design mutation operators to emulate the causes of .
bugs in bthat are neither compile time nor logic bugs.
.
evaluation quality of mutants we use three well known metrics to measure the quality of mutants that akka and pit operators generate.
these metrics are ease to killing duplicity and subsumption which section defines.
intuitively the lower the number of easy to kill duplicate and subsumed mutants the higher the quality.
previous work uses the number of ease of killing duplicity and subsumption often to measure mutant quality.
effectiveness of tests we use the well known metric mutation score that section defines to measure the effectiveness of our tests to identify akka and pit mutants.
previous work uses mutation score often to measure the effectiveness of tests.
we execute the tests to measure the mutant quality and test effectiveness.
however a test can be flaky and produce different outcomes for different executions.
to prevent flaky tests from skewing measurements we follow previous work and use the average of three executions of our tests to calculate our metrics.
bug coverage we use the same open card sort to identify b bugs that jagannath et al.
s operators can induce and cover and their overlap with akka .
mutation operators and groups in this section we discuss and illustrate the mutation operators using real bug examples.
in addition we compare our operators with jagannath et al.
s .
table shows our mutation operators their eight groups 8groups path configuration communication type life cycle exception interaction race and cluster and their short descriptions.
.
path in akka an actor has a path that denotes its physical location in a system.
the path includes an address and a name .
the address can be either local or remote.
an actor is local if it is in the same java virtual machine jvm and is remote otherwise.
alocal address specifies the actor system that the actor resides in and a hierarchy of its ancestors following akka actor system hierarchy name format.
actors form a hierarchy in which a parent creates its children.
a remote address also specifies a host protocol and a port for remote connections following akka.protocol actor system host port hierarchy name format.
an akka developer is responsible to understand actor paths and their different parts and their programmatic and dynamic modifications and manually provide correct values for these parts otherwise incorrect actor paths can cause bugs as the previous work shows.
path group includes six mutation operators that change the name protocol actor system host port and hierarchy parts of an actor path to induce the bugs that are caused by the use of incorrect values for these parts.
for example there are three bugs inbin which an actor cannot be created because its name is not unique.
akka requires actor names to be unique in a system.
change name incudes these bugs by changing the name of an actor to an actor name that already exists in the system.
similarly there is a bug in which an actor cannot be looked up and messages sent to it cannot be delivered because its hierarchy is missing an ancestor.
change hierarchy induces this bug by changing the hierarchy of an actor to a hierarchy with one less random ancestor.
table describes all the mutation operators in path and the bug causes they emulate.
jagannath et al.
use their individual experiences to propose unimplemented mutation operators in groups for the research actor language actorfoundry.
these operators inside parentheses and their groups outside parentheses are messaging remove send receive modify message parameters reorder message parameter modify message name modify message recipient and change synchronization type constraint remove constraint and modify constraint and creation deletion remove creation deletion modify creation parameter and reorder creation parameters .
all six mutation operators in path are new and cannot be found in the previous work by jagannath et al.
s. .
configuration a configuration defines the properties of an application using a set of parameter and value pair settings.
in akka a default configuration defines default settings.
these settings define the properties of actors and actor systems of an application and their deployment mailboxes dispatchers and routers among others.
for example the mailbox can be configured to be either unbounded or bounded with a specific capacity for the number of its messages.
an application configuration can override the default settings define new settings such as a new dispatcher with a different max and min number of threads in its thread pool or fallback on another configuration for the settings that it does not define.
an akka developer is responsible to understand the default and application configurations their parameter and value settings overriding and fallback and their programmatic modifications and manually configure non default settings otherwise incorrect configurations can cause bugs .
configuration includes six mutation operators that change application fallback mailbox dispatch routing and deployment settings to induce bugs that are caused by using incorrect 265 akka mutation testing for actor concurrency in akka using real world bugs esec fse december san francisco ca usa table mutation operators for actor concurrency in akka their groups and descriptions.
group mutation operator description pathname change the name of an actor to an existing or random actor name protocol change the local protocol of an actor to a remote protocol and vice versa actor system change the actor system name of an actor to an existing or random actor system name host change the host name or ip address of an actor to a random host name or ip address port change the port number of an actor s host to a random port number hierarchy change the ancestral hierarchy of an actor to a hierarchy with one less random ancestor configurationapplication change the application configuration to an empty configuration or drop it fallback change the fallback configuration to an empty configuration or drop it mailbox change the mailbox configuration of an actor to an empty or random configuration or drop it dispatch change the dispatch configuration of an actor to an empty or random configuration or drop it routing change the routing configuration of an actor to the default or no router configuration or drop it deployment change the deployment configuration of an actor to the default or drop the configuration communication typesend type change the set of message types that an actor sends to a set with one more random type receive type change the set of message types that an actor receives to a set with one less random type life cyclelookup change the lookup of an actor to occur in another existing or random actor system starting change the starting pre and post behaviors of an actor to empty or supertype behaviors stopping change the stopping pre and post behaviors of an actor to empty or supertype behaviors restarting change the restarting pre and post behaviors of an actor to empty or supertype behaviors termination change the termination of an actor or actor system by removing or delaying the termination monitoring change monitoring of an actor by removing the monitoring exceptionfailure change the failure behavior of an actor to throw an exception supervision change the supervisory behavior of an actor to another random behavior interactionsynchrony change the synchrony of a message that an actor sends from sync to asynch and vice versa blocking change the blocking behavior of an actor by increasing or decreasing its wait or sleep durations timeout change the timeout behavior of an actor by increasing or decreasing its timeout durations forwarding change the sender of a message that actor forwards to a random actor reference sender change the sender of a message that an actor sends to an existing actor reference receiver change the receiver of a message that an actor sends to an existing actor reference scheduling change the scheduling of a message that an actor sends by increasing or decreasing its delays race sharing change the sharing of data between an actor and its concurrent future or async tasks ordering change the ordering between two messages by delaying the first message clustersubscription change a cluster event that an actor subscribes for to another akka cluster event unsubscription change a cluster event that an actor unsubscribes from to another akka cluster event settings for these configurations.
for example there is a bug inbin which an actor system cannot be configured and created because its application configuration does not load.
change application induces this bug by replacing the application configuration with an empty configuration with no settings.
similarly there is a bug in which an actor cannot stash its messages because its mailbox is not configured properly.
change mailbox induces this bug by removing the mailbox configuration of an actor.all six mutation operators in configuration are new and cannot be found in jagannath et al.
s. .
communication type in classic akka unlike akka typed an actor neither knows about the types of messages that it may receive nor the type of messages it can send.
an akka developer is responsible to manually discover these message types and ensure that the actor can receive all the messages that others send to it and sends only messages that 266esec fse december san francisco ca usa mohsen moradi moghadam mehdi bagherzadeh raffi khatchadourian and hamid bagheri others can receive otherwise sending or receiving messages with incorrect types can cause bugs .
communication type includes two mutation operators change receive type andsend type that change the type of messages that an actor can receive or send to induce the bugs that are caused by receiving or sending incorrect message types.
for example there are two bugs inbin which the application behavior is undesired or terminates prematurely because an actor receives a message of a type that it cannot process.
change receive type induces these bugs by changing the set of message types that a receiver actor can receive to another set with one less random message type.
similarly change send type can induce these bugs by changing the set of message types that a sender actor can send to another set with one more random message type.
ourchange receive type partially overlaps with jagannath et al.
s remove send receive rsr operator in their messaging group that mimics the omission of messages by removing sends receives .
similarly our change send type overlaps with their messaging modify message name mmn operator in messaging that modifies the name of a message being sent .
.
life cycle in akka an actor and its enclosing actor system go through different stages in their life cycle such as creation lookup starting stopping restarting termination and monitoring .
an akka developer is responsible to understand these life cycles and their programmatic stages and manually manage these stages and their pre and post behaviors correctly otherwise incorrect management of life cycles can cause bugs .
life cycle includes six mutation operators that change lookup starting stopping restarting termination and monitoring of an actor and its actor system to induce the bugs that are caused by the incorrect managements of these stages.
for example there are two bugs inbin which the application does not shutdown or consumes all its available memory because its actor system and actors do not terminate.
change termination induces these bugs by removing the termination of an actor and its enclosing actor system.
similarly there is a bug in which the termination of an actor goes unnoticed because the actor that is responsible to manage the termination is not monitoring the terminating actor.
change monitoring induces this bug by removing the termination monitoring of an actor.
ourchange termination partially overlaps with jagannath et al.
s remove creation deletion rcd operator from their creation deletion group that mimics the omission of creation deletion of an actor by removing an actor creation deletion .
all other five mutation operators in life cycle are new.
.
exception in akka a parent actor is not only responsible to create but also supervise its child actors and manage their failure when they throw exceptions.
the supervision strategy of the parent specifies to either stop resume or restart the failed child or escalate the exception up the supervision hierarchy to the parent of the parent.
an akka developer is responsible to understand actor failures and exceptions programmatic supervisory hierarchies and supervision strategiesand handle these exceptions correctly otherwise incorrect handling of exceptions can cause bugs .
exception includes two mutation operators that change failureandsupervision behavior of an actor to induce the bugs that are caused by incorrect handlings of exceptions.
for example there are two bugs inbin which the application does not terminate or swallows an exception because an actor throws an exception that its ancestor does not handle properly.
change failure induces these bugs by changing the behavior of an actor to throw an exception.
similarly there are two bugs in which an actor does not restart properly because its parent is using the wrong supervision strategy.
change supervision incudes these bugs by changing the supervision strategy of an actor.
both mutation operators in exception are new.
.
interaction in akka there are several ways in which an actor can interact with another.
in addition to an asynchronous fire and forget message a sender actor can send a synchronous request response message to a receiver and wait and block for its response in a future variable for atimeout period.
a future is a placeholder for an incomplete task with a result that is not ready yet.
similarly a receiver can forward a message it receives to another actor without changing the sender of the message or schedule to send a message in specific intervals.
an akka developer is responsible to understand these programmatic interactions and their semantics and use them correctly otherwise incorrect interactions can cause bugs .
interaction includes seven mutation operators that change synchrony blocking timeout forwarding sender receiver andscheduling of actor interactions to induce bugs that incorrect uses can cause.
for example there are two bugs inbin which a receiver actor cannot respond to its sender more than once because the temporary actor that a request response message creates to receive the response terminates after receiving the first response.
change synchrony induces these bugs by changing an asynchronous fire and forget message to a synchronous requestreply message.
similarly there is a bug in which a receive cannot process its messages because the messages are sent too fast.
change scheduling induces this bug by decreasing the initial and interval delays between messages that a scheduler sends.
ourchange synchrony overlaps with jagannath et al.
s change message synchronization type cst in messaging that changes a synchronous send to an asynchronous send and vice versa .
similarly our change receiver overlaps with their modify message recipient mmr in messaging that modifies the recipient of a message .
all other five operators in interaction are new.
.
race a race occurs if two concurrent computations access the same memory and one modifies the memory.
in akka to avoid races an actor processes its messages sequentially and one at a time.
however both lower level data races and higher level message races are still possible.
a data race occurs when a concurrent future or async task that runs outside the actor shares memory with the actor and either the actor or the task modifies the memory.
similarly a message race occurs when two messages arrive at the same actor out 267 akka mutation testing for actor concurrency in akka using real world bugs esec fse december san francisco ca usa of their desired order and the processing of either of the messages modifies the actor memory.
an akka developer is responsible to understand data sharings and message orderings among all actors and non actor concurrent computations of a system and make sure they are free from races otherwise races could cause bugs .
race includes two mutation operators that change sharing of data and ordering of messages to induce the bugs that incorrect sharing and message ordering can cause.
for example there are seven bugs inbin which a response is not delivered to a sender actor or the application does not behave as desired because an actor and its future task share the variable sender which the actor modifies.
the variable sender is the sender of the current message that the actor is processing and changes when the actor starts to process another message.
change sharing induces this bug by changing a random actor reference in a future or async task with getsender .
the method getsender accesses reads and returns the value of the shared variable sender .
similarly there is a bug in which the application produces incorrect results because two messages that initiate the warmup of a simulation and production of the results arrive out of order.
change sharing induces this bug by delaying the sending of a message to reorder the arrival of messages.
ourchange sharing overlaps with jagannath et al.
s change message reference type crt in messaging that changes a message sent by reference to a message sent by value and vice versa to change the sharing between actors.
change ordering is new.
.
cluster in akka a cluster is a group of actor systems that provide distribution load balancing and failover for their actors.
an actor system is a logical node of the cluster.
an actor in the cluster can subscribe for the membership domain and reachability events of the cluster receive messages when these events occur and process these messages accordingly.
similarly the actor can unsubscribe from these events.
an akka developer is responsible to understand these events their semantics and their subscriptions and unsubscriptions and manage them correctly otherwise incorrect subscriptions or unsubscriptons can cause bugs .
cluster includes two mutation operators that change subscription andunsubscription of actors in a cluster to induce bugs that are caused by incorrect subscriptions.
for example there is a bug inbin which an actor misses a cluster leader change event because it subscribes for an incorrect member event instead of the correct domain event.
the leader change event is a domain event.
change subscription induces this bug by changing the cluster event that an actor subscribes to another random cluster event.
similarly change unsubscription can induce this bug by changing the cluster event that an actor unsubscribes from.
both mutation operators in cluster are new.
evaluation in this section we discuss the implementation of our mutation operators in akka evaluate the mutant quality and test effectiveness of real application in akka and pit and study the bug coverage and overlap of akka jagannath et al.
s and pit operators.
.
implementation for real world applicability we implement our mutation operators as an eclipse plugin in a framework that we call akka .
akka uses 138source code changes of java akka api to implement our 32operators.
for efficiency in addition to not generating stillborn mutants we integrate the following popular techniques from previous work into akka .
first we use conditional mutation that uses conditional statements to integrate all the mutants and the original application into a single application.
this allows a single compilation to compile all mutants all at once and efficiently instead of one by one and inefficiently.
second we generate and use coverage information to execute mutants only if they are covered by tests .
this allows to not execute the tests that do not cover mutants and mutants that are not covered by tests.
.
akka applications table real world akka applications from github.
id project loc domain stars ditto ditto internet of things iot lms sunbird lms learning management wot wot servient web of things flower flower reactive microservices comb servicecomb transactional data rhino rhino web performance testing parc parallec asyncronous web flink flink rpc web performance testing fuse fuse rest server mony money transfer money transfer api total we use github to randomly select a set of mature and realworld java akka applications with a total of 444lines of code.
table shows these applications which cover a broad spectrum of sizes ranging from 951to15 527to3 136lines of code of domains from internet of things iot to web performance testing to money transfer and of starts from to to .
an application is considered to be an akka application if it uses java akka apis in its source code.
due to compilation issues in eclipse we include connectivity internal things gateway and base subsystems of ditto and the rpcsubsystem of flink and not all their subsystems.
.
akka s mutant generation and coverage table shows the number of mutants that different mutation operator groups generate gen and the number of these mutants that the tests can cover cov.
the table shows these numbers in aggregate for all applications and separately for individual applications.
gen is the ratio of the number of mutants that an operator generates to the number of mutants that all operators generate.
cov is the ratio of the covered mutants of an operator to its generated mutants.
dark gray light gray and boxed denote higher lower and average values respectively.
generation according to table row gen for all applications in aggregate the number of mutants that different mutation operator groups generate are substantially different with interaction 268esec fse december san francisco ca usa mohsen moradi moghadam mehdi bagherzadeh raffi khatchadourian and hamid bagheri table mutant generation gen and coverage cov for different mutation operator groups.
id mutation group total path config comm life excep inter race cluster gen cov gen cov gen cov gen cov gen cov gen cov gen cov gen cov gen cov ditto lms wot flower comb rhino parc flink fuse mony total gen .
.
.
.
.
.
.
.
cov .
.
.
.
.
.
.
.
.
alone generating more than a third .
of the mutants which is the most and configuration generating the least .
.
this excludes the outlier cluster that generates .
of mutants with only mutants.
four operator groups interaction life cycle race and communication type that include out of .
akka operators together generate the majority .
of mutants whereas the other four cluster configuration exception and path generate only a small minority .
.
finding 2of akka operators generate 10of mutants.
coverage similarly according to row cov tests can cover less than half .
of akka mutants and leave more than half .
uncovered with substantially different coverage for mutants of different operators.
exception mutants are the most .
covered and configuration the least .
excluding cluster .
finding tests are ineffective in covering 2of akka mutants.
.
akka s quality of mutants table shows the numbers of easy to kill eas duplicate dup and subsumed mutants sub for akka mutation operator groups.
eas dup and sub respectively are ratios of easy to kill duplicate and subsumed mutants of an operator to its covered mutants.
ease of killing according to table row eas less than a fifth .
of mutants are easy to kill and non quality whereas more than four fifth .
are hard to kill and quality with substantially different ease of killing for mutants of different operators.
configuration mutants are the most .
easy to kill and path the least .
excluding cluster .
finding 5of akka mutants are hard to kill and quality.
duplicity according to row dup more than a seventh .
of mutants are duplicate and non quality whereas about six seventh .
are unique and quality with substantially different duplicity for mutants of different operators.
path mutants are themost .
duplicate and exception the least .
excluding cluster .
finding 7of akka mutants are unique and quality.
subsumption according to row sub less than a quarter .
of mutants are subsumed and non quality whereas more than three quarters .
are subsuming and quality with substantially different subsumption for mutants of different operators.
path mutants are the most .
subsumed and race the least .
excluding cluster .
finding 4of akka mutants are subsuming and quality.
altogether the quality of akka mutants differ substantially for its different operators.
race mutants are the highest quality as the second least easy to kill third least duplicate and the second least subsumed whereas configuration mutants are the lowest quality as the seventh easy to kill most duplicate and subsumed.
finding race interaction cluster exception life communication path and config are highest to lowest akka mutants.
.
akka s test effectiveness table shows the traditional mutation scores for tests of different applications.
according to table tests are effective in killing only a sixth .
of akka mutants and leave about five sixth .
alive.
in addition finding says that the tests are ineffective in covering more than half of akka mutants.
finding tests are ineffective not only in covering 2of akka mutants but also in killing .
.
pit s mutant quality and test effectiveness table shows the generation coverage and the quality of pit mutants of our applications.
due to compilation and execution issues in pit we include six applications ditto lms wot flower parc and fusethat we used previously.
generation coverage and 269 akka mutation testing for actor concurrency in akka using real world bugs esec fse december san francisco ca usa table mutant ease of killing eas duplicity dup and subsumption sub for different mutation operator groups.
id mutation group total mutation score path config comm life excep inter race cluster eas dup sub eas dup sub eas dup sub eas dup sub eas dup sub eas dup sub eas dup sub eas dup sub eas dup sub ditto .
lms .
wot .
flower .
comb .
rhino .
parc .
flink .
fuse .
mony .
total .
eas .
.
.
.
.
.
.
.
.
dup .
.
.
.
.
.
.
.
.
sub .
.
.
.
.
.
.
.
.
quality of akka mutants for these six applications can be easily calculated using table .
table mutant quality and test effectiveness in pit.
id pit mutations mutation score gen cov eas dup sub ditto .
lms .
wot .
flower .
parc .
fuse .
total .
cov .
eas .
dup .
sub .
coverage according to table row cov tests cover more than half .
of pit mutants and leave the other half uncovered which is a third more than .3x the .
coverage of akka mutants for these six applications.
finding tests are .3x less effective in covering akka than pit mutants.
ease of killing duplicity and subsumption according to roweas less than a half .
of pit mutants are easy to kill which is more than twice .64x the .
ease of killing for akka mutants.
similarly according to row dup less than a half .
of pit mutants are duplicates which is thrice .2x the .
duplicity for akka mutants.
finally according to row sub less than a half .
of pit mutants are subsumed which is a third more than .3x the .
subsumption for akka mutants.
finding akka mutants are higher quality than pit 2x harder to kill 3x less duplicate and .3x less subsumed.effectiveness of tests table shows the traditional mutation scores for tests of our six applications.
according to table tests are effective in killing more than a third .
of pit mutants which is .3x the .
test effectiveness for akka mutants.
in addition finding says tests are .3x less effective in covering akka mutants.
finding tests are .3x less effective in covering and .3x less effective in killing akka mutants than pit.
.
bug coverage by pit and jagannath et al.
s figure shows the coverages of non logic and logic bugs in our bug setb by mutation operators in akka jagannath et al.
s and pit and the overlap of these coverages.
the bug coverage of an operator is the ratio of the number of bugs that it can induce and cover to the number of all bugs in b. similarly the coverage overlap of an operator with another is the ratio of the number of bugs that the former covers to the latter.
for example akka interaction covers about one seventh .
of bugs in band jagannath et al.
s messaging overlaps with interaction in covering about one third .
of bugs that interaction covers.
messaging .
creation deletion .8messaging .
cluster .6pit .
non logic bugs logic bugs not covered by akka overlaps with pitcovered by akka overlaps with jagannath et al.
slife cycle .
race .4config .
path .
exception .3interaction .
logic .
comm .
figure bug coverage by akka jagannath et al.
s and pit.
270esec fse december san francisco ca usa mohsen moradi moghadam mehdi bagherzadeh raffi khatchadourian and hamid bagheri in figure akka coversb s non logic bugs and there is an overlap between bugs that akka scommunication type interaction and life cycle cover and jagannath et al.
s messaging and creation deletion.
in total jagannath et al.
s cover about a third .
of non logic bugs that akka covers.
finding akka covers .3x more bugs than jagannath et al.
for non logic bugs that akka does not cover pit covers less than a fifth .
of these bugs.
together akka and pit cover more than two third .
of non logic and logic bugs which is .1x the .
coverage of akka alone and .5x the .
coverage of pit alone.
finding akka pit cover .1x more bugs than akka .
implications predictive mutation testing for actor concurrency to improve efficiency previous work uses characteristics of mutants as features to build and train models that can predict mutant killing without executing the mutants.
for example mao et al.
uses characteristics such as the coverage of a mutant numtestcover and the operator group that generates the mutant mutatorclass for their .
accurate predictions of mutant killing in real world java applications with more than million lines of code.
while still non existent future prediction mutation testing tools for actor concurrency can use akka mutants and their characteristics such as mutation operator group coverage ease of killing duplicity and subsumption to build and train models that predict the killing of actor concurrency mutants.
n selective and n sampling mutation testing for actor concurrency similarly to improve efficiency previous work approximates mutation testing using a select set of mutation operators that excludes n operators that generate the most more mutants while maintaining the mutation score.
for example offutt and rothermel use and selective mutation testing with operators in fortran applications and achieve mutant reductions of .
and .
.
while still non existent future actor concurrency mutation testing can use akka operators mutants and statistics about their generation for n selective testing.
according to table a selective testing that excludes the four operators incommunication type andrace groups could potentially reduce our mutant numbers by .
if their exclusion maintains the mutation score.
similarly previous work approximates mutation testing by sampling n of mutants per criteria such mutation operator method or class.
future actor concurrency mutation testing can use akka operators operator groups and mutant quality as new guiding criteria for sampling.
actor concurrency testing to improve tests previous work uses mutation testing to guide where to test and what to improve.
for example fraser and zeller test uses alive mutants to generate oracles and tests that kill of all mutants in java libraries with 416classes.
future actor concurrency testing can use akka to guide similar oracle and test generations.
threats to validity some of our decisions during this work could be a threat to its validity.
the bug set bthat we use to understand akka bugs andtheir causes may not be representative of all akka bugs and could be a threat.
however the large number of bugs in bfrom both popular stack overflow and github and the large number of stack overflow posts and github commits that the previous work uses to construct bcould help mitigate this threat.
the manual analysis that we use to understand the bugs design and group mutation operators and understand bug coverages can be a threat.
to minimize this threat we use well known sorting techniques with multiple sorters that previous work proposes and often uses .
the metrics that we use to measure the mutant quality and test effectiveness can be another threat.
to minimize this threat we use well known metrics that previous work proposes and often uses for mutant quality and test effectiveness .
the applications that we use in our evaluations may not be a representative of all akka applications and could be a threat.
to minimize this threat we select a random set of applications that are different in sizes domains number of stars and developers.
related work concurrency the work by jagannath et al.
is the closest to our work.
we discuss this work and its semantic and bug coverage overlap with out work in detail in sections and .
jagannath et al.
propose mutation operators in groups for actorfoundry that are based on individual experiences of authors and not a curated set of real bugs are not implemented are not evaluated and are specific to the syntax and semantics of actorfoundry and not applicable to today s industrial strength implementations of actor concurrency.
six out of our 32mutation operators .
and the remaining twenty six .
in path configuration life cycle interaction race and cluster groups are new.
there are six operators that are unique to jagannath et al.
s. two remove constraint rc and modify constraint mc are inapplicable to akka because akka does not allow conditional constraints to disable the receiving of messages.
for the remaining four modify message parameter mmp reorder message parameter rmp modify creation parameter mcp and reorder creation parameter rcp there were no bugs in bthat required a similar operator.
previous work proposes conman and ccmutator to mutate multithreaded concurrency and its constructs such as threads locks conditional variables and atomic blocks in languages like java and c c .
however the fundamental differences between actor and multithreaded concurrency the syntax and semantics of their constructs and their bugs make multithreaded mutation testing inapplicable to actor concurrency.
languages and paradigms previous work proposes mutation testing for different programming paradigms such as functional object aspect and declarative oriented programming and different programming models such web mobile and machine learning .
previous work also proposes mutation testing for specification modeling and a broad range of programming languages such as java javascript c c c and ruby .
however none of these works design implement and evaluate mutation testing for actor concurrency using real bugs.
271 akka mutation testing for actor concurrency in akka using real world bugs esec fse december san francisco ca usa mutant quality previous work propose several techniques such as subsuming dominator disjoint minimal and surface mutants to reduce non quality trivial redundant and equivalent mutants.
others quantify the mutant usefulness using the triviality equivalence and dominance of the mutant and relate the usefulness to the program context of the mutant .
however none evaluate the quality of actor mutants.
efficiency previous work proposes comutation to select a small subset of multithreaded mutation operators with less number of mutants but the same test effectiveness and mutmut for efficient execution of multithreaded mutants.
however selective and efficient mutation testing are outside the scope of this paper.
conclusions and future work in this work we propose akka for mutation testing of akka actor concurrency.
to design implement and evaluate akka we manually analyze a set of real akka bugs design mutation operators to induce these bugs implement these operators in an eclipse plugin generate .7k mutants of real applications measure the quality of mutants and effectiveness of tests generate .2k pit mutants and compare with akka analyze the bug coverage and overlap between akka pit and actor operators in jagannath et al.
s and discuss a few implications of our findings.
one avenue of future work is to use program context to predict and avoid generation of lower quality mutants .
another avenue is predictive mutation testing for actor concurrency using machine learning.
data availability all the data and tools that we use in this work are publicly available in our replication package .
these include akka s mutation operators their formal definitions akka api source code changes and the source code of our eclipse plugin.