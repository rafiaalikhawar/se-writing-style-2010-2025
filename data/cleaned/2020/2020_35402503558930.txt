jsimutate understanding performanceresults throughmutations thomaslaurent lero university collegedublin dublin ireland thomas.laurent ucd.iepaoloarcaini nationalinstituteofinformatics tokyo japan arcaini nii.ac.jp catia trubiani gransassoscienceinstitute l aquila italy catia.trubiani gssi.itanthonyventresque lero university collegedublin dublin ireland anthony.ventresque ucd.ie abstract understandingtheperformancecharacteristicsofsoftwaresystems is particular relevant when looking at design alternatives.
however it is a very challenging problem due to the complexity of interpretingtheroleandincidenceofthedifferentsystemelements onperformancemetricsofinterest suchassystemresponsetime or resources utilisation.
this work introduces jsimutate a tool thatmakesuseofqueueingnetworkperformancemodelsandenablestheanalysisofmutationsofamodelreflectingpossibledesign changestosupportdesignersinidentifyingthemodelelementsthat contribute toimprovingorworseningthe system s performance.
ccsconcepts software and its engineering software performance general and reference performance metrics.
keywords performance analysis queueingnetworks mutation operators acm referenceformat thomaslaurent paoloarcaini catiatrubiani andanthonyventresque.
.jsimutate understandingperformanceresultsthroughmutations.in proceedingsofthe30thacmjointeuropeansoftwareengineeringconference andsymposiumonthefoundationsofsoftwareengineering esec fse november 14 18 singapore singapore.
acm new york ny usa 5pages.
introduction thereisagrowinginterestinthesoftwareengineeringcommunity for performance characteristics of software systems and recently many techniques have been developed to identify root causesofperformanceanomalies .whenfocusing on developer needs it becomes clear that current state of theartmethodologiesdonotprovideenoughsupportto i understand the performance characteristics ofsoftware systems inparticular esec fse november 14 18 singapore singapore copyright held bytheowner author s .
acm isbn978 .
there is a large set of design alternatives and ii trace the cause effect chain by identifying which components most likely in directly affect the system s performance.
understandingperformanceresultsischallenging sinceanalysisresultsonlygiveinformationofthesystem sperformancebut do not provide any hint of whythese results are obtained and their root causes.
however this type of information would be very useful.
indeed system designers are also interested in knowing which portions of the software system contribute to improving orworseningperformanceresults.theactualbenefitcomesfrom identifying which system components are responsible for bad systemperformance orwhichdesignchoicesleadtoexpensivesoftware hardwaresettings increasingtheoverallcostofthesystem.
therefore to understand performance results system designers usuallyneedtorunexpensivesoftwareperformancetestingcampaigns toverifywhetherdesignchangesactuallyaffectthe system sperformance.suchanapproachshowsseveralweaknesses itrequiresperformance basedtestingexpertise itiscomputationallyexpensive itismanual anditmayalsobeerror prone.thus automation is desirable toaddress these challenges.
thispaperintroducesatool namely jsimutate thatcansupport designers in understanding the performance characteristics ofasoftwaresystemandinsizingitsresourcesinasuitableway forinstancebyidentifyingperformancebottlenecks challenging workloads andanalysingdesignchanges.thetheoreticalelements underlying jsimutate wereintroducedinpreviouswork however they were not implemented in an easily applicable way for designers.
this work describes how jsimutate was designed to automatetheapproachandprovideauser friendlyinterfacesothat it can be easily used.
forperformanceanalysis weleverage softwareperformanceengineeringtechniques in particular queueing networks qns performancemodels sincetheyarerecognisedasprovidingaccuratepredictionswhenanalysingrealsystems andthere exist well assessed frameworks e.g.
jmt to simulate these modelsandcollecttheperformancemetricsofinterest.toeasily implement design alternatives we take inspiration from mutation analysis we systematically apply changes toperformance modelsbasedondefined mutationoperators andautomaticallyevaluatetheirperformancetosupportacosttrade offanalysis.inother terms our tool embeds the specification of mutation operators and itgeneratesasetofmutatedqueueingnetworkmodels withthe thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse november14 18 singapore singapore thomas laurent paoloarcaini catia trubiani andanthonyventresque goaltobetterunderstandtheperformanceoftheoriginalsystem andofalternativedesigns.thisway wecanautomaticallycompare theperformanceresultsproducedbythese mutantswith thoseof the original model when executed with typical system workloads.
tosummarise this paperpresents jsimutate a toolthathelps designers understand performance results through mutations.
this means to evaluatedesign alternativesand selectthe ones thatare beneficial from a performance based perspective as possible systemrefactoringstobesuggestedtosoftwaredevelopers.
jsimutate manipulates performance models and simulates typical workloads definedbythedesigners.
jsimutate wasdesignedtoberobustand easy to use and implements a set of changes to the qn models thathavebeenproposedintheliterature andthatareoften usedbysystemdesignerswhentuningthecostandperformance ofasystem.thisshouldmake jsimutate easilyadoptablebypractitioners.
jsimutate is available at and a screencast showing ituse isavailable at .
background this section provides background information on queueing networks i.e.
the used performance modelling formalism and modelbasedanalysisto getsystemperformance metrics ofinterest.
queueingnetworks.
themainconstituentelementsofaqn model are i processing nodes representing system resources ii a set ofcustomer classes that refer to the external users requests of services and iii structuralnodes denotingtheflowofrequests .
processingnodescanbedistinguishedaccordingtotheirroleinthe system.first servicecentres arecomposedofa serverandaqueue.
serversaremeanttoprocessajob fromtheirqueue and routethe processed request to another node.
queues can be characterised by afiniteoraninfinitesize.second delaycentres differentiatefrom the service centres since they have no queue.
service and delay centresareconnectedthrough linksthatcontributetothenetwork s topology.a routingnode canbeintroducedtoroutecustomerclasses to differentnodes according to somegiven probabilities.
inotherwords aqnmodelcanbeexpressedasadirectedgraph whosenodesareservice delaycentresandwhoseedgesrepresent theirconnections.
jobscirculatethroughthegraph sedgeseton thebasisofthecustomers servicerequests.afurthertypeofnodes is theforkthat expresses parallelism i.e.
one task is split into multiple jobs that can be executed in parallel and synchronised throughthe joinnode.toregulatetheparallelism thereare finite capacity regions that explicitly specify the maximum number of requests allowedto run inparallel.
model based performance analysis requires to parameterise the qnmodelwithtiminginformation.thetimespentbyeachrequest inprocessingnodesismodelledbyprobabilitydistributions e.g.
exponential or deterministic distributions.
delay centres are regulatedbyadeterministicservicetimethatdenoteshowlongjobs are delayed before proceeding in further delay or queueing centres.
service centres also include the service times needed to process thedifferenttypesofrequests alongwiththepolicytomanagethe requestswaitinginthequeue e.g.
first come first served fcfs .
the workload can be modelled as open i.e.
specified by an arrival rate orclosed i.e.
a constant number nof requests specified asthepopulationsize .incaseofanopenworkload requestsare figure example ofaqueuingnetwork takenfrom generatedby sourcenodes connectedwiththerestoftheqn and terminatein sinknodes denotingthatallrequeststoresourceshave been completed.
fig.1providesanillustrativeexampleofapubliclyavailableqn model thatwillserveasrunningexampleinthepaper.asource node namely requests representsanopenworkloadofusers requests.twodifferenttypesofrequestshavebeendefined i class0 followsanhyperexponentialdistribution and ii class1presents anexponentialdistribution.bothclassesareroutedtothe raid0 fork node and the finite capacity region called apache maxclients .each requestroutedtothe raid0fork nodeistransformed to three tasks that are forwarded to the next queueing network centres i.e.
disk1 disk2 anddisk3 eachwithacertainservice time distribution.
the completionof forkedtasks is regulatedby the join node join0.
this node is connected to the replysink node thatdeterminesthecompletionofsuchrequests.eachrequestin thefinitecapacityregionfollowsitsrules specifically theregion capacityissetto100 thatmeansnomorethatonehundredrequests are allowed to reach the loadbalancer routing node at a time.
a strategyofroutingissetforeachjobclass forinstance class0joins theshortestqueue and class1followstheshortestresponsetime criterion.
two queueing centres i.e.
webserver andwebserver are connected to the routing station to balance the load that terminatesinthe replysink node.
model basedperformanceanalysis.
qnsareadoptedtopredict the performance characteristics of software systems.
when using qnsto perform operationalprofileassessment thesystem s designers defines the system s typical workloads and some performancerequirements e.g.
systemresponsetimeshouldnotbe larger than seconds.
jsimutate simulates these workloads and measuresthesystem sperformance whichcanbecheckedbythe designer against the requirements and can help find possible modificationsofthe system eitherto meet violated requirements e.g.
by adding additional resources or to minimise costs of the system e.g.
byremovingunnecessaryresources .
jsimutate usesjmt astheback endtoolforqnmodellingandsimulationtocollectthe performance metrics of interest.
for each performance metric it ispossible tospecifythemaximumrelativeerror thatdenotesthe precision requiredinthesimulation.followingtheliterature jsimutate relies on three performance metrics.
system response time srt is defined as the time interval between a user s request ofaserviceandtheresponseofthesystem striscomputedforthe wholenetwork i.e.
atthe systemlevel .utilisation ut isdefinedas theratioofbusytimeofaresourceandthetotalelapsedtimeofthe measurementperiod utiscomputedatthe componentlevel i.e.
thereisanutilisationvalueforeachnodeofthenetwork.
system 1722jsimutate understandingperformance results through mutations esec fse november14 18 singapore singapore s s s ss i m u l a t i o noriginal model mutantsperformance resultsjsimutate ?compare resultsmetric metric metric performance expert jsimgfile model.jsimg workloads workloadid worload1 openclassesexponential name class1 ... input json file performance resultsresult tabless s s mutant jsimg files mutation operators figure jsimutate sworkflow drop rate sdr is defined as the rate at which customers requests are dropped from a station or a region due to a maximum capacity sdriscomputedbothatthe componentlevel andatthe systemlevel .
3jsimutate this section describes jsimutate its use case and workflow the waysitmutatesqueueing networks andhowto use it.
.
use case queueing networks can be used to model and evaluate the performance of a system under certain expected workloads when designing the system.
this activity is referred to as operational profile assessment .inthissetting asystem designermightrealise that the systemdoes not meetthe performance requirements that havebeenset orthatthesystemistoocostlytobuild.thedesigner then wants to refactor the system in order to achieve the same functionalitywithbetterperformance orusing fewer resources.
exploringandunderstandingtheperformanceeffectsofpossible refactorings is a tedious and error prone task when donemanually asitismostlydoneinthecurrentdevelopmentpractice.
jsimutate allows to automate this task by presenting the performance effects ofdifferent changes in the modelto the designer in asummarised way.
the designer can then easily find refactorings that might help achievetheirperformancegoals andcanbetterunderstandtherole andimportanceofeachofthe elements intheirnetwork.
.
workflow given a queueing network and a set of workloads jsimutate systematicallyappliesa setofcommonlyusedrefactorings referred to asmutations in the tool to the network and evaluates the effect of these mutations on the system s performance using a set of performance metrics .
fig.2illustrates this workflow.
the designer i.e.
the performance expert inputs the model and the workloads they want to study performanceunder asajson file described further in section3.
.
.jsimutate simulates these workloads on the system measuringasetoforiginalperformancemetricsvalues.
jsimutate then applies mutations to the network defined by the mutation operatorsdescribedinsection .
simulatestheworkloadsonthese mutatedsystems measuringtheperformancemetricsofinterest.
then jsimutate compares thevalues of the performance metrics achievedbytheoriginalsystemandeachofthemutatedsystems asdescribedinsection .
todeterminetheeffectofthedifferentchangesonthesystem sperformance.finally itoutputsasummary ofthis comparison inasetof outputfilesdescribedinsection .
.
.
mutation operators jsimutate implementsthefollowingoperators mimickingpossible refactorings ofthe network change queue size creates a mutant for each node in the model modifying the size of its queue.
it creates multiple mutants per node dividing the queue size by removing oneunit doublingthequeuesize andaddingoneunit.for infinite queues only one mutant is created and the queue is given an arbitrary finitesize of .
change queue strategy creates a mutant for each node in themodel modifyingthequeueingstrategyofitsqueue.the fcfsandlcfs strategiesareswapped giving theopposite strategyfrom the originalto the mutatedqueues.
change number of servers creates a mutant for each processing node inthe model modifyingits numberof servers processingunits .itcreatesmultiplemutantspernode dividing the number of servers by removing one server doublingthe number of servers andaddingone server.
.
measuringtheimpactofthemutations whenjsimutate simulatesthedifferentworkloadsontheoriginal networkandthemutatednetworks itcollectsasetofperformance metrics consisting of the system response time including the responsetimeofeachnodetothedifferenttypesofrequestsreceived theutilisationofeachnode andthesystemdroprate.thesemetrics are then used to compare the performance of the original network with that of the mutated network to measure the impact of the mutationsto the system sperformance.
asallmetricsareestimatedwithacertainprecision theoriginal andmutatednetworks performanceresultswouldalmostalways differ.
hence jsimutate filters differences that are deemed insignificant.
to evaluate if a mutation had a significant impact on a particularmetric jsimutate comparestheresultsoftheoriginal network for this metric represented by whereml andmuarethelowerandupperboundsmeasuredforthemetricin thesimulationand mmthemeanvalue andtheresultsofthemutated network represented by m l m m m u .jsimutate considers whetheramutationhadasignificantimpactontheperformance ofthe system withregardsto ametric.
specifically if themetric s meanvalue changed by more than ofits original value andthe range ofvaluesmeasuredforthe originaland mutatednetworks do not overlap i.e.
m m mm mm .
mu m l m u ml in this case we say that the mutant has been triggered.
.
running jsimutate jsimutate isdistributedasajarfileandcanberunonthecommand line.
its main input is a json file that points to the queueing networktosimulateandmutate asa jsimgfile andtheworkloads under which the system must be simulated.
jsimutate can also take in some options such as the list of mutation operators to use 1723esec fse november14 18 singapore singapore thomas laurent paoloarcaini catia trubiani andanthonyventresque jsimgfile .
2cl 10stat fcr fork whatif.jsimg workloads workloadid w1 openclassesexponential name class1 referencestation requests interarrivaldistributionlambda .
openclasseshyperexponential name class0 referencestation requests p .
lambda1 .
lambda2 .
workloadid w2 openclassesexponential name class1 referencestation requests interarrivaldistributionlambda .
openclasseshyperexponential name class0 referencestation requests p .
lambda1 .
lambda2 .
figure example of jsimutate sinput file jsonformat table example of jsimutate s output raw results excerpt w load location operator class measuretypeorig lowerlimitorig meanvalueorig upperlimitmut lowerlimitmut meanvaluemut upperlimittimeoutmutsignificant difference... w1 webserver1 cns srt .
.
.
.
.
.
false false ... w1 webserver1 cns class0 utilization .
.
.
.
.
.
false true ... w1 webserver1 cns systemdr .
.
.
.
.
.
false false ... w1 webserver1 cns dr .
.
.
.
.
.
false false ... w2 webserver1 cns srt .
.
.
.
.
.
false false ... w2 webserver1 cns class0 srt .
.
.
.
.
.
false false ... w2 webserver1 cns class1 srt .
.
.
.
.
.
false false ... w2 webserver1 cns utilization .
.
.
.
.
.
false true ... w2 webserver1 cns class0 utilization .
.
.
.
.
.
false false ... w2 webserver1 cns class1 utilization .
.
.
.
.
.
false true ... w2 disk3 cnsp class1 dr .
.
.
.
.
.
false false ... w1 webserver1 cqsize srt .
.
.
.
.
.
false false ... w1 webserver1 cqsizem1 srt .
.
.
.
.
.
false false ... w1 webserver2 cqstrategy class0 utilization .
.
.
.
.
.
false false ... ... fortheanalysis orthetimeoutsetwhensimulatingthemutated networks and used in case one of the mutations prevented the simulation from converging.
.
.
input file.
the main input file is a json file that contains thepathtothejsimgfiledescribingthenetworktoanalyseinthe jsimgfile attribute andadescriptionoftheworkloadstosimulate in theworkloads attribute.
the workloads are represented as a jsonobjecteach whichcontainsadescriptionofthedifferentuser defined classes i.e.
typesof requestssent to the server .
different typesofuserclassessuchasopenorclosedclasses deterministic or exponential loads can be defined in this format.
fig.
3shows an example input file for the network shown in fig.
defining two workloads eachcontainingtwouserclasses oneexponentialand the otherone hyper exponential.
.
.
outputfiles.
jsimutate smainoutputconsistsofthreetables that summarise the comparison between the original and mutated models performance in the form of .tsvfiles.
optionally jsimutate can also save the mutated models as .jsimgfiles so thattheusercaneasilyreuseamutatedmodelthattheypreferto comparewiththeoriginalmodel.thissectionillustratesthesefiles byusingtheresultsproducedbytheinputinfig.
3onthemodel infig.1as an illustrative example.
the first output file contains the raw results of the performance comparison between the original and mutated models.
table showsanexcerptoftherawresults thewholeresultscontain2952 rows and some additional columns with details on the collected metrics .
for each mutated model each workload and each performance metric it contains a row displaying the original model s values for the metric under analysis the mutated model s valuestable2 example of jsimutate s output mutant workload matrix excerpt w loadchange numberservers disk 1change numberserversm1 disk 1change numberserversp disk 1change numberservers disk 2change numberservers webserver1change queueingstrategy webserver2... w1 true true false false true false ... w2 false false false false true false ... table example of jsimutate s output mutant metric matrix excerpt measure descriptionchange numberservers disk1change queuesizem1 disk1change numberservers disk3change numberservers webserver1change queueingstrategy webserver2... drop rate class0 disk1 false false false false false ... drop rate class0 webserver false false false false false ... system drop rate na na false false false false false ... system response time class0 na false false false false false ... system response time class1 na false false false false false ... system response time na na false false false false false ... utilization class0 webserver false false false false false ... utilization class1 disk false false true false false ... utilization class1 webserver false false false true false ... ... for such a metric whether the mutated model timed out the simulationdidnotconverge andwhetherthetwosetsofvalueswere significantly different as specifiedbyeq.
.
the two other files summarise the information contained in the raw results as matrices.
the first table shows for each mutantworkload pair whether the mutant produced a significantly differentresultfor any ofthemetrics ortimedoutwiththismetric see table2for an excerpt of this matrix the whole matrix contains columns correspondingto all themutants .the second matrix shows for each mutant metric pair whether the mutant produced asignificantlydifferentresultforthismetricunderanyoftheworkloads seetable 3foranexcerptofthismatrix thewholematrix contains columns for all the mutants and rows for all the performance metrics measuredonthe differentnodes .
thesetablesprovidequantitativeinformationtothedesigners whocandecidehowtomodifythesystembasedonthemutants impactontheperformance.
jsimutate automaticallyevaluatesthe differentmutantsandpointsoutsthoseimpactingtheperformance metrics ofinterest.
conclusions queueingnetworksarewidelyusedtoassesstheperformancerequirements of a system.
a typical analysis technique consists in checking whether the system is properly equipped for meeting performancerequirements orif itiseitherover equipped unnecessarilycostly orunder equipped notmeetingtheperformance requirements .inthispaper weproposed jsimutate atoolthat automatisesthisapproachbycheckingtheperformanceofmutated versionsofthe originalnetwork undertypical workloads.