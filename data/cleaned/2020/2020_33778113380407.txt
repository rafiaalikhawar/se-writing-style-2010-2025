slacc simion based language agnosticcode clones ge orge mathew chrisparnin kathrynt stolee northcarolinastateuniversity george2 cjparnin ktstolee ncsu.edu abstract successfulcross languageclonedetectioncouldenableresearchers anddeveloperstocreaterobustlanguagemigrationtools facilitate learningadditionalprogramminglanguagesonceoneismastered andpromotereuseofcodesnippetsoverabroadercodebase.however identifyingcross languageclonespresentsspecialchallenges totheclonedetectionproblem.alackofcommonunderlyingrepresentation between arbitrary languages means detecting clones requires one of the following solutions a static analysis framework replicated across each targeted language with annotations matching language features across all languages or a dynamic analysisframeworkthatdetectsclonesbasedonruntimebehavior.
inthiswork wedemonstratethefeasibilityofthelattersolution adynamicanalysisapproachcalledslaccforcross languageclone detection.likepriorclonedetectiontechniques weuseinput output behavior to match clones though we overcome limitations of priorworkbyamplifyingthenumberofinputsandcoveringmore data types and as a result achieve better clusters than prior attempts.since clusters aregenerated based oninput outputbehavior slacc supports cross language clone detection.
as an added challenge we target a static typed language java and a dynamic typedlanguage python.comparedtohitoshiio arecentclonedetectiontoolforjava slaccretrieves6timesasmanyclustersand hashigher precision .
vs. .
.
this is the f irst work to perform clone detection for dynamic typedlanguages precision .
andthe f irsttoperformclone detection across languages that lack a common underlying representation precision .
.
it provides a f irst step towards the larger goalof scalable language migrationtools.
ccsconcepts softwareanditsengineering softwaremaintenancetools object oriented languages functional languages information systems clustering .
keywords semanticcode clone detection cross languageanalysis acm referenceformat george mathew chris parnin kathryn t stolee.
.
slacc simionbasedlanguageagnosticcodeclones.in 42ndinternationalconferenceon permission to make digital or hard copies of all or part of this work for personal or classroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributed for pro f it or commercial advantage and that copies bear this notice and the full citationonthe f irstpage.copyrightsforcomponentsofthisworkownedbyothersthan acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspeci f icpermission and or a fee.
request permissions frompermissions acm.org.
icse may23 seoul republicofkorea associationforcomputingmachinery.
acmisbn978 ... .
engineering icse may seoul republic of korea.
acm newyork ny usa 12pages.
introduction modernprogrammerstypicallyworkonsystemsbuiltwithacocktailofmultipleprogramminglanguages .arecentsurveyfound thatprofessionalsoftwaredevelopershaveameanofsevendifferentprogramminglanguagesintheirindustrialsoftwareprojects and open source software projects frequently have between programming languages .
programmers are also expected to continue learning multiple programming languages on a daily basis.
tolearn a new programminglanguage studies have shown that programmers attempt to use a cross language learning strategybyreusingknowledgefromapreviouslyknownlanguage .
this means programmers often need the ability to relate code snippets acrossmultiple programminglanguages.
traditional clone detection often works with only a single programming language meaning that typical applications and tools are not applicable to modern programming systems and contexts.
these applications include bug detection in ported software maintaining quality through refactoring and protecting the securityofproducts .forexample securityteamsatmicrosoft use clone detection to scan for other instances of vulnerable code that might be present in any production software .
in short thereisaneedtoextendclonedetectiontoworkincross language contexts but limitedsupportexists for them.
this paper presents simion based language agnostic code clone detection technique slacc a cross language semantic clone detection technique based on code behavior.
our technique can match whole and partial methods or functions.
it works in bothstaticanddynamiclanguages.itdoesnotrequireannotations or manual effort such as seeding test inputs.
critically unlike any otherclonedetectiontechnique weareabletodetectsemantically similarcodeacrossmultipleprogramminglanguagesandtypesystems e.g.
pythonand java .
slacc f inds semantic clones by comparing the input output io relationshipofsnippets called simions shortfor similarinput output functions in line with prior work .
slacc segments a target code repository into smaller executable functions.
arguments for the functions are generated using a custom input generator inspired by grey box testing and multi modal distribution.functionsareexecutedonthegeneratedargumentsandsubsequently clustered based on the generated arguments and corresponding return values.
the similarity measure for clustering is based on the io behavior of code snippets and is independent of their syntactic features.
hence slacc generates cross language clusterswithcodesnippetsfromdifferentprogramminglanguages.
to validate our technique using a single static typed language weperformanempiricalstudywith19 188javafunctionsderived from google code jam gcj submissions and demonstrate ieee acm 42nd international conference on software engineering icse icse may23 seoul republic of korea m athewetal.
that slacc identi f ies 6x more clones and with higher precision .
vs. .
compared to hitoshiio a state of the art code semantic clone detection technique.
using a single dynamic typedlanguage weperformastudywith17 215pythonfunctions derivedfromgcjand f indthatslacccanidentifytruebehavioral cloneswith87.
precision.forcross languageclones slacc f inds clusters with both python and java functions demonstrating that detection of code clones does not depend on a common type system.
insummary thispaper makes thefollowingcontributions forsingle languagestatictypedclonedetection anempiricalvalidationdemonstratingslacccanbeusedtoidentify 6x more and better code clones clusters than the state ofthe artcode clone detection technique hitoshiio.
the f irstexplorationofclonedetectionforadynamic typed language and demonstrated feasibility in python with precisionof .
.
the f irstexplorationofcross languageclonedetectionwhen thelanguages lackanunderlyingrepresentation slaccis successful in identifying cross language clone clusters betweenpythonand javawith94.
precision.
an open source tool for detection of semantic code clones between different programminglanguages.
motivation avery is preparing for a technical interview and was given a few practicecodingchallenges toworkon.averyismorecomfortablewritingcodeinjavaduringaninterviewsettingbutisworried because thecompany exclusively codes inpython.as practice for the interview avery wants to code with python.
first avery decidestowritethecodeinjavatounderstandthesolution andthen translatethosesolutionsintopythoncode.
one of the practice questions asks the coder to interleave the resultsof twoarrays.avery quickly writes thissolutioninjava 1publicstring interleave int a int b 2s tring result quotedbl.var quotedbl.var 3inti 4for i i a.length i b.length i r esult a result b 8int remaining a.length b.length ?
b a 9for intj i j remaining.length j result remaining 12returnresult whileoneapproachistodirectlytranslatethecodeintopython averywondersifthereareotherwaystotakeadvantageofidioms and capabilities in python.
after spending a few hours searching stackover f low andgithubgists avery f indsafewcode snippetsthat seemtodo thesamething.
the f irst one seems a bit too complex and relies on another dependency.
1deffancy interleave l1 l2 fromitertools importchain3 return quotedbl.var quotedbl.var.join str x forxi nchain.from iterable zip l1 l2 this other solution is similar to the java solution but is using somethingnew a zipfunction.averyisexcitedtolearnsomenew pythontricks!
1defproblem2 l1 l2 r esult quotedbl.var quotedbl.var for e1 e2 i n zip l1 l2 result str e1 result str e2 returnresult a veryfoundthestrategyofwritingcodeinjavaandtranslating that code into python helpful.
however the process of manually searching and translating the code between languages was timeconsuming.
avery s unfamiliaritywith pythonmade it difficult to verify whether thesesnippetswere trulythesame.
at the interview avery was relieved to be asked to solve the sameinterleave problemfromthepracticeset!however whilecodingupasolutioninpython theinterviewerasked doesthishandle interleavingunevenlists?
theoriginaljava basedsolutionhandled thiscase butthepythontranslationdidnot.becausesearchingfor code took solong avery never had thechance tofullyverifythat thepythonsolutionworkedthesameasthejavasolution.avery s assumptionthatthenew zipfunctionwouldworkonunevenlists waswrong!hadtherebeenabetterwayforaveryto f indsemantically related snippets in other programming languages this issue may have beenavoided.
inthiswork weintroduceslacc whichcoulddetectthatthese functions are not equivalent.
from a corpus of code it could instead f indthissemanticallyidenticalsnippet justoneofmanyapplications enabled bycross languageclone detection 1defvalid interleave1 l1 l2 r esult quotedbl.var quotedbl.var a a2 len l1 len l2 forii nrange max a1 a2 ifi a1 r esult str list1 ifi a2 r esult str list2 returnresult simion basedlanguage agnostic code clonedetection code clones can be broadly classi f ied into four types as describedintable1.typesi iiandiiirepresentsyntacticcodeclones where similarity between code is estimated with respect to the structure of the code.
on the other hand type iv indicates functionalsimilarity.syntacticcodeclonedetectiontechniquesareimpractical for cross language code clone detection as it would require an explicit mapping between the syntax of the languages.
this is feasible for syntactically similar languages like java and c butmuchharderfordifferentlanguageslikejavaandpython.
on the other hand semantic approaches for cross language code detection relyonlargenumberoftrainingexamplesbetween the languages and was yet again tested on similar programming languages.
211slacc simion based languageagnostic codeclones i cse may23 seoul republic ofkorea figure1 highlevel work f low forslacc.
w e propose simion based language agnostic code clone detection slacc a semantic approach to code similarity that is predicated on the availability of large repositories of redundant code .
instead of mapping api translations using prede f ined rules or using embedded api translations slacc uses io examples to cluster code based on its behavior.
further it relaxes the bounds of the datatypes across programming languages which helps dynamic typed code snippets e.g.
python tobeclusteredalongside statictypedcode snippets e.g.
java .
in slacc we build on the ideas pioneered by eqminer for using segmentation and random testing for clone detection.
slaccstartsbyidentifyingsnippetsfromalargecodebaseandinvolvesamulti stepprocessdepictedinfigure1 whichstartswith a segmentation of the code base into smaller fragments of code calledsnippets b functioncreation fromthesnippets c input generationforthefunctions d execution ofthefunctions ande clone detection based on clustering functions arguments and execution results.
.
segmentation inthe f irststage codefromallthesource f ilesinaprojectisbroken intosmallercodefragmentscalled snippets.consecutivestatement blocks of threshold min stmt or more are grouped into a snippet.
astatement block can be declaration statement.
e.g.
intx assignment statement e.g.
x blockstatement e.g.
static x loopstatements.
e.g.
for while do while c onditional statements.
e.g.
if if else if switch trystatement.
e.g.
try try catch algorithm illustrates the segmentation phase.
for an ast afo f a function the algorithm performs a pre order traversal of all the nodesintheast line5 andthenusesaslidingwindowtoextract table1 typesofcodeclones.typesi iiandiiiaresyntactic whiletypeivare semanticorbehavioral clones type description i identical sans whitespace andcomments i i identicalastbutusesdifferentvariablenames types or functioncalls iii similarastbutusesdifferentexpressions statements.
for example a using whilein place of forloops or b usingif else if in place of switchstatements.
i v different syntax but behaviorally same.
for example an iterative stack approach or a recursive approach can be usedforbreadth f irstsearchof agraph.algorithm s egmentation i nput af ast node output s listof segment procedure s e.sc g.sc m.sc e.sc n.sc t.sc af s stmts preordertra v.alterse af foralli range len stmts do si stmti stmts forallj range i len stmts do stmtj stmts si.append stmtj if len si min stmtsthen s s si ifstmtj.haschildren then s s segment stmtj returns segments of size greater than a minimum segment size m in stmt lines .
further for statements like block loop conditional and try which have statements in its nested scope the algorithm is called recursivelyonthem lines14 .
.
functioncreation next snippets are converted into executable functions.
this section describes how arguments return variables and types are inferred.
inferring arguments and return variables.
we adapt a data f low analysissimilartothatusedbysuetal.
.foreachmethod potential return variables are identi f ied as variables that are de f ined or modi f ied within the scope of the snippet.
if the last de f inition ofavariableisaconstantvalue thatvariableisremovedfromthe set of potential return variables.
arguments are variables that are usedbutnotde f inedwithinthescopeofthesnippet and2 not declared as public static variables for the class.
for each potential returnvariable inasnippet afunction iscreated.
inferring types.
in the case of static typed languages argument types and return values can be inferred via static code analysis.
for dynamic typed languages the parameters can take multiple typesofinputarguments.thisincreasesthepossiblevaluesofthe arguments generated see section .
to identify its behavior.
in many cases the possible types for the arguments can be inferred by parsing the code and looking for constant variables in its context.
this technique has been used in inferring types in other dynamiclanguageslikejavascript .forexample inthefollowingpythonfunction thetypeof ncanbeassumedtobeaninteger since it iscompared against an integer.
1deffib n ifn returnn returnfib n fib n i n cases where the types of the parameters could not be inferred at compile time suchas 1defmain a printa 212icse may23 seoul republic of korea m athewetal.
1classshape public int length intwidth private int height publicshape int l intw inth l ength l width w height h 9publicshape func s int l intw intx return new shape l x w x 12public int func l int l intw intx returnfunc s l w x .length 15public int func w int l intw intx returnfunc s l w x .width figure an example depicting conversion of a function with object as a return type to multiple functionswith nonprimitivemembersof theobject s class.
a generic type is assigned i.e.
for a allowing the argument to assume any of the primitive types used in argument generation section3.
.
convertingobjectreturntypesintofunctions.
ifasnippetreturns anobject theobjectissimpli f iedintomultiplefunctionsreturning each of its non private members independently.
for example in figure func shas a return type of shape.
shape has two members lengthandwidth.
hence func sis broken down into two functions func landfunc w whichreturnthe lengthandwidth of the shape object independently.
note that a third function for heightis not created sinceit is aprivatemember.
permutingargumentorder.
foreachofthesnippets wegenerate differentpermutationsbasedontheinputofargumentssinceorder matters for capturing function behavior.
consider the two functions in figure the f irst function divides awithbusing the division operatorwhiletheseconddivides dividend withdivisor usingthesubtract operatorrecursively.fortheinputs the two functions would produce the values and respectively.
but if the arguments for the second function was reversed it would producethesameoutput2.thus foreveryfunction wecreateduplicatesindifferentpermutationsofthearguments args resulting in args !
different functions.
to limit the creation of this exploding space we set an upper limit on the number of arguments per functionthat isincluded inthe analysis args max .
.
inputgeneration a set of inputs are required to execute the created functions.
followingthis clusteringisperformed.
input creation.
inputs are generated based on argument type andusingacustominputgeneratorinspiredbygrey boxtesting and multi modal distribution .
first the source code is parsed1public int divide simple int a intb if b return0 returna b 5public int divide complex int divisor intdividend same as dividend divisor if b return0 intquotient while dividend divisor dividend dividend divisor quotient returnquotient figure3 anexampleillustratingtheneedforreorderingarguments.thetwofunctionsperformintegerdivisionbutdo not return the same return value for the same set of inputs duetotheorderof argumentsinthefunctionde f inition.
and constants of each type are identi f ied.
next a multi modal distribution is declared for each of the types with peaks at the constants.
finally values for each type are sampled from this multimodal distribution.
our experiments create inputs per function as justi f iedinsection .
.
memoization.
foreveryfunctionwiththesameargumenttypes a common set of inputs have to be used to compare them.
this is ensured using a database and the input generator.
the generator is used to create sample inputs for the given argument types and stored in the database.
for subsequent functions with the same signaturefor thearguments thestoredinput values arereused.
supportedargumenttypes.
slacccurrentlysupportsfourtypes of arguments.
primitive.
the multi modal distribution for the argument type is sampled to generate the inputs.
this includes integers and longs shorts f loats and double characters booleans and strings.
objects.objectsarerecursivelyexpandedtotheirconstructorwithprimitivetypes inputsaregeneratedforthetypes.
arrays.
a random array size is generated using the input generator for integers1.
for each element in the array a valueisgeneratedbasedonthearraytype primitiveorobject .
files filesarestoredasasharedresourcepoolofstringsin thedatabase.ifaseed f ile s isprovided it israndomlymutatedandstoredasastringinthedatabase.intheabsenceof aseed constantsfromthemulti modaldistributionaresampledandstoredasstrings.foranargumentwitha filetype oritsextensions atemporary deletedontermination f ile object is created usingthestoredstrings.
type size restrictions.
comparing code snippets requires compatiblesizesoftypesacrossprogramminglanguages.forexample java has integer datatypes byte short intandlongwhich occ upy sizes of and bytes respectively.
on the other hand 1if a negativeinteger is sampled thedistribution is re sampled.
213slacc simion based languageagnostic codeclones i cse may23 seoul republic ofkorea python has two integer datatypes intwhich is equivalent to the longdatatype in java and l ongwhich has an unlimited length.
thus wemakearestrictionwhengeneratinginputsforfunctions across different languages inputs are generated from the smaller boundofthetwoprogramminglanguages.forexample inthecase ofjavaandpythonfunctionthathasan int inputsaregenerated w ithinthebounds of java.
.
execution inthenextstage thecreatedfunctionsareexecutedoverthegenerated input sets and the subsequent return values are stored.
each function is assigned an execution time limit of tlseconds after which a timeout exception is raised.
this occurs most frequently whenthereisanin f initeloop suchas while true w hentheloop invariant is an argument.
each execution of the function is run onanindependentthread.subsequently thereturnvalue runtime andexceptionfortheexecutedfunctionovertheinputsetisstored.
.
clonedetection the last stage of slacc is identifying the clones where the executed functions are clustered on their inputs and outputs.
slacc uses arepresentative based partitioning strategy to cluster theexecuted functions.
similarity measure.
in this work a pair of functions have the highestsemanticallysimilarityifforanygiveninput thefunctions returnthesameoutput.thesimilaritymeasurebetweentwofunctions is computed as the number of inputs for which the methodsreturnthesameoutputvaluedividedbythenumberofinputs sameasthejaccardindex.thiscreatesasimilarityvaluebetween twofunctionswitharangeof with1.0beingthehighest.
consider the functions from section interleave fancy interleave andvalid interleave .forvalues a a ndb we see that interleave a b f ancy interleave a b a ndvalid interleave a b .
functions interleave andvalid interleave are similar since they have the same output for the same input but interleave andfancy interleave are not similar.
in contrast fora a ndb allthreefunctionswouldreturnthe same output .
based on these two inputs interleave andfancy interleave have a similarity of .
interleave and valid interleave haveasimilarityof1 .
andfancy interleave andvalid interleave haveasimilarityof0 .
.thisprocessisrepeated for many such inputs aandbto compute similarity scores between each pair of functions.
functions are only compared if they have the same number of arguments and cast able argument types.
for example consider the four functions f1 inta string b f longa file b f file a string b andf4 string a .
functions f1andf2 can be compared since intcan be cast to a longvalue.
but they c annot be compared to f3since primitive types cannot be cast to file.
similarly f1 f2andf3cannot be compared f4due to the difference innumber of arguments.
clustering.
a function is compared to a cluster by measuring its similarity with the f irst function added to the cluster calledalgorithm c lustering i nput f list of functions withinput andoutput output c list of clusters procedure c l.sc u.sc s.sc t.sc e.sc r.sc f c forallf fdo forallc cdo o getrepresentive c if similarity o f sim tthen c c f break if c c f nelementcthen c c f setrepresentative c c f c c c c returnc representative .theclusteringalgorithmisbrie f lydescribedinalgorithm2.anemptysetofclustersis f irstinitialized line4 .each function line is compared against each cluster line .
if the similarity between the representative line and the function is greater than a prede f ined similarity threshold sim t line the function is added to the cluster line .
if the function does not belonginanycluster line11 asingletonclusteriscreatedforthe function line and the function is set as the cluster s representative line13 .thesingletonclusterisaddedtothesetofclusters line evaluation ourgoalistoevaluatetheeffectivenessofslacc.thereisathreephase evaluation f irst to compare slacc to a comparable technique in a single static typed language.
next we apply slacc to a single dynamic typed language python and then to a multilanguage context in both cases slacc is compared to type iii clones.
.
researchquestions slaccisbenchmarkedagainsthitoshiio withrespecttocoverage and precision of code clone detection.
this leads us to our f irstresearch question research question h oweffectiveisslacconsemanticclonedetectioninstatic typed languages?
priorresearchhasalreadyshownthatsemanticclonescanbefound in static typed languages like c and java.
in our literature search we failed to f ind techniques that identi f ied semantic codeclonesindynamictypedlanguages.therefore weuseanast based comparison approach as an alternative baseline to benchmarkslacc.
thisleads us tothenext researchquestion 214icse may23 seoul republic of korea m athewetal.
table2 projectsusedinthisstudywiththenumberofvalid submissionsinboth javaandpython.
year problem id java python irregular cake y11r5p1 perfect game y12r5p1 cheaters y13r5p1 magical tour y14r5p1 total research question h ow effective is slacc on semantic clone detection in dynamictyped languages?
prior work identi f ied code clones between languages by mapping apis between similar languages e.g.
java and c using prede f inedrules orusinganembeddedapitranslations .asa result thesecodeclonesaresyntacticratherthansemantic.therefore research question h ow effective is slacc at cross language semantic clone detection?
.
data we validate this study on four problems from google code jam gcj repository and their valid submissions in java and python.
gcjisanannualonlinecodingcompetitionhostedbygooglewhere participants solve the programming problems provided and submit their solutions for google to test.
the submissions that pass google s tests are considered valid and are published online.
we use the f irst problem from the f ifth round of gcj from to .
the details about the problem and submissions are in table2.overallinthisstudy weconsider247projects 170fromjava and from python.
the java gcj submissions contain methods and generated java functions.
the python submission contains methods and generated python functions.
the code projects and execution scripts for the project can be foundinour githubrepository .
.
experimental setup the experiments were run on a node cluster with each node havinga4 coreamdopteronprocessorand32gbddr31333ecc dram.our experiments havefour hyper parameters minimum size of snippet min stmt section .
we set thisto2tocapture snippetswithinterestingbehavior.
maximumnumberofarguments arg max section3.
this value is set to .
hence if a snippet has more than arguments itis omittedfromtheexperiments.
2early rounds have many submissions to create a reasonably scoped experiment.
thus wechosesubmissions from thequarter f inals in round f ive.
number of executions section .
we execute each snippet with generated inputs section .
see section .
for details onthis choice.
similaritythreshold sim t section3.
wesetthisto1.
forourexperiment.thisimpliesthattwofunctionsareonly considered to be clones if for allinputs they generate the same outputs.
sensitivitytothenumberofexecutionsand arg maxisexplored and discussedinsections .
and6.
respectively.
.
metrics our study uses three metrics primarily to address the research questions wepose.
numberofclusters aclusterisacollectionoffunctions withacommonproperty i.e.
typei ivsimilarity .thismetricisthenumberofclustersgeneratedbyaclonedetection algorithm.thisisrepresentedas clusters clustersor c. numberofclones afunctionthatbelongstoaclusteris called a clone.
this metric is the total number of functions in all the clusters generated by a clone detection algorithm.
thisisrepresented as clones clones or m. number of false positives a false positive is a cluster which contains one or more functions which does not adhere to the similarity measure of the cluster.
this is represented as false positive falsepositives or fp.
.
baselines toanswerrq1 rq2 andrq3 weusebaselinetechniquestoillustratethecapabilities of slacc.
.
.
rq1 hitoshiio.
asabaseline weusetheclosesttechnique to ours hitoshiio .
this tool identi f ies functional clones for javavirtualmachine jvm basedlanguagessuchasjavaandscala.
itusesin vivoclonedetectionandinsertsinstrumentationcodein the form of control instructions in the application s bytecode to record input and output values at runtime.
inputs and outputs are observed using the existing workloads which allows it to observe behavior and identify clones in code for which input generators cannot generate inputs.
the methods with similar values of inputs and outputs during executions are identi f ied as functional clones.
hitoshiio considers every method in a project as a potential functional clone of every other method and returns pairs of clones.
for comparison against slacc we group the pairs into clusters as follows two pairs of clones are grouped into a cluster if both the pairs have a common function between them i.e.
for pairs a b and b c a clone clusteris created with a b c .
like the similarity threshold sim tin slacc hitoshiio has a similar parameter that provides a lower bound on how similar twomethodsmustbetobeconsideredafunctionalclone.aswith slacc hitoshiioalsohasaparameterforanupperboundonthe number of iopro f iles consideredfor each method.
we used an existing and public implementation of hitoshiio.
theworkloadusedtobenchmarkhitoshiiowithgcjarethesample test input f iles.
gcj provides only two sample input f iles for 3github.com programming systems lab ioclones commithash aa5b5b3 dated 215slacc simion based languageagnostic codeclones i cse may23 seoul republic ofkorea a validating a submission.
however in slacc each method was executed256times.tocreateabalancedbenchmark werandomly fuzzed the test input f iles times before sending it to hitoshiio.
notethatwetriedfuzzingthe f iles256timesbuttheclone detection phaseof hitoshiiocrashedfor largenumbers of inputs.
.
.
rq2 automatedastcomparison.
tothebestofourknowledgewecouldnot f indapriorworktodetectsemanticcodeclones indynamiclanguages.hencewebenchmarkedslaccfordynamic andcross languageclonesbymatchingtheabstractsyntaxtrees asts as a proxy for similarity.
this technique has been adopted bymanygraph based anexampleoftype iiiclone codeclonedetectiontechniques inc and java .
like slacc the f irst phase of the ast comparison segments the code into snippets.
next an ast is generated for the snippets.
we use the javaparser tool and python ast module to construct the asts in the respective languages.
we measure similaritybymatchingtheasts.forclonesinthesameprogramming language rq1 rq2 wematchtheastsandconsiderthemtobe type iiiclonesiftheastsareequivalentorhaveadifferenceofat mostone node.
.
.
rq3 manual cross language ast comparison.
the automatedastcomparisonapproachcannotbeadoptedforcrosslanguageclones rq3 duetothedifferenceinformatoftheasts for both the languages.
in this case conservatively we sampled cross language snippets with extremely similar outputs and manuallyveri f iedtheastsforsimilarity.todothis werandomlysample1millionpairsof ajavafunctionandapythonfunction.if the input and output types are compatible and the outputs are the sameforthesameinputsoroffbya consistent value thenwemanually evaluate the asts for similarity.
consistency is determined based on the output type.
values of primitive types are consistent iftheyhaveaconstantdifference forbooleanornumericvalues constant ratio for boolean or numeric values or constant levenshteindistance forstrings betweentheoutputs.objectsare consistent if each member of the object is consistent.
finally two arraysareconsistent ifallthecorrespondingmembersofthearray areconsistent.
forexample giventwomethods inta intx a nddefb y ifa b a andb thena and b aresimilarsincetheiroutputshaveaconstantratio .ofthe similar pairs all had identical asts or had a difference of at mostone node making themtype iii clones.
.
precision analysis slacc and hitoshiio are both clustered using io relationships of the functions.
however given a different set of inputs some functionsinaclustermightproduceadifferentsetofoutputssuch thattheyarenotclones suchclustersaremarkedas falsepositives and considered invalid.
we identify false positives at the clusterlevel inkeepingwith priorwork .
to detect false positives slacc clusters are re executed on a new set of inputs generated using random fuzzing based onatriangulardistribution andclustered.ifanymethodinacluster is not grouped into the same cluster using the new input set the whole cluster is marked as a false positive.
we observe thattable number of whole method clones identi f ied by hitoshiio h slacc s and both the approaches after accountingforfalsepositives.
problem hitoshiio h slacc s h s irregularcake pe rfect game cheaters magical tour total thenumberofclustersandfalsepositivesisrelativelystableabove inputs section .
.
todetectfalsepositivesinhitoshiio werandomlyfuzzthetest input f iles times section .
to generate a new test f ile that is 32x the size of the original and then re execute hitoshiio.
clone pairs are clustered and false positives are detected when a new cluster does not match anoriginalcluster asdone for slacc.
false positives in clusters generated by ast comparisons are identi f ied in a similar manner to slacc.
asts in the clusters are f irstconvertedtofunctions asdescribedinsection3.
.thefunctionsarere executedon256inputslikeslaccclustersandchecked forfalsepositives.anyclusterthatcontainsadifferentmethodafter execution is markedas a falsepositive.
results the results show that slacc identi f ies more method level clones compared to prior work and with higher precision rq1 successfully identi f ies clones in dynamic typed languages rq2 and successfullydetects clones between java andpython rq3 .
.
rq1 static typed languages the885javamethodsgenerated19 188javafunctionsforanalysis.slaccwasabletosupport691ofthe885javamethods.from the whole methods functions are derived into partial method snippets.
of the total generated functions are clones resulting in clusters.
these clones derive from 038partial methodsnippetsand142wholemethods.wecallthem statementlevel clones and methodlevel clones respectively.
.
.
methodlevelclones.
webenchmarkslaccagainsthitoshiio by comparing clones detected by slacc at a method level granularity.weprovideall885javamethodstohitoshiio whichgroups of the methods into clusters.
false positives were identi f ied for of the clusters precision .
.4the remaining valid clusters from hitoshiio contain methods.
from the java methods slacc detected methods grouped into clusters.
false positives were identi f ied for of the clusters precision .
.
the remaining valid clusters for slacc contain methods.
table3showsthenumbersofvalidclustersforeachapproach as well as their intersection.
all valid clusters from hitoshiio are 4false positive rates in the original hitoshiio paper are computed at the pairlevel rather than cluster level and used student opinions rather than code behavior which may accountfortherelatively lowprecision reported here.
216icse may23 seoul republic of korea m athewetal.
slaccs tmt 1importy14r5p1.stolis.mmt3 parent class mmt3 2public static int func a bufferedreader br snipped from y14r5p1.stolis.mmt3.main 4if !mmt3.in.hasmoretokens m mt3.in newstringtokenizer br.readline 6inta integer.parseint mmt3.in.nexttoken 7returna slaccm ethod 1importy12r5p1.xiaowuc.a parent class a 2public static int func b scanner in y12r5p1.xiaowuc.a.next 4while a.tok null !a.tok.hasmoretokens a .tok newstringtokenizer in.readline 7returninteger.parseint a.tok.nexttoken hitoshiio 1public static int func c streamtokenizer in y11r5p1.burdakovd.a.nextint 3i n.nexttoken 4return int in.nval 1public static int func d streamtokenizer in y11r5p1.sammarize.main.next 3i n.nexttoken 4returninteger.parseint in.nval 1importy14r5p1.eatmore.a parent class a 2public static int func e scanner in y14r5p1.eatmore.a.next 4a .in in 5returninteger.parseint a.nexttoken 1public static int func f scanner sc snipped from y11r5p1.dooglius.a.go 3intnext sc.nextint 4returnnext fi gure4 semanticclustersdetectedbyhitoshiio slaccon methodlevel slacc method and slacc onstatement level slacc stmt .theclustercontainsfunctionsthattakeanobject thatreads a f ileandreturns thenextintegertoken.
containedwithinthevalidclustersforslacc h h s demonstrating that among the valid clones slacc subsumes hitoshiio forthisexperiment.however thelowprecisionforhitoshiiomay beduetotheuseoflimitedinputsortheexecutioncontext sofurtherinvestigation isneeded for generalization of this result.
anexampleofaclusterthatcontainsmethodsfrombothslacc andhitoshiioisshowninfigure4.theclustercontainsfunctions that take an object that reads a f ile and returns the next integertable of java python and cross language clusters detected by slacc compared against ast type iii clusters.
java python java python slacc ast slacc ast slacc ast clusters valid precision .
.
.
.
.
.
token.
functions f unc candfunc dare clones detected by hitoshiio.
within the same cluster slacc methodadditionally identi f ies two more method level clones that were not detected by hitoshiio func bandfunc e. .
.
statement level clones.
additionally slacc identi f ies clusters with statement level code clones.
of these clustersarefalsepositives precision .
.thelargenumberofcode clonesisintuitivebecauseeachmethodcancontainmultiplemodular functionalities.
that said it should be noted that the higher precisionforstatementlevelclusterswouldleadustobelievethat detecting clones forsuccinct behavior ismoreaccurate.
statementlevelclonescanbeclusteredwithwholemethodclones.
for example in figure slacc stmtrepresents a slacc cluster based on partial methods func aandfunc fare functions segmentedfromthe mainmethodinclass y14r5p1.
stolis.mmt3 and t hegomethodin y11r5p1.
dooglius.a respectively.
rq1 me thod level clones slacc identi f ies more method level clones compared to hitoshiio at higher precision.
statementlevelclones segmentationofcodeincreasesthe precisionofslaccandyieldsahighernumberofsemantic clones.
.
rq2 dynamic typed languages slaccidenti f iedthat3 .
ofthe17 215extractedpython functionshadcloneswhichresultedin482cloneclusters.ofthese 482clusters 421arevalid resultinginprecisionof87.
.asabaseline usingthesamepythonfunctions wesystematicallylookedfor type iii clones.
there exists clusters of which are valid .
precision these results are shown in the pythoncolumn of table4 where astshowsthetype iiiclones.forsakeofcomparison theexperimentwasrepeatedforjavaclones asimilardifferential between slacc and ast precision was observed .
vs. .
.
whentheseclustersarevalidated 61ofthe482slaccclusters .
were deemed to be false positive.
this is more than the percentageoffalsepositivesinjava .
butwesuspectthatby executingthefunctionsoveralargersetgeneratedarguments the subsequent clusteringcould yieldmore robustresults.
an example of python clones identi f ied by slacc can be seen infigure5.boththefunctionsinthisexamplecomputethesumof an array.
func db8e uses a loop that maintains the running sum where each index in the array contains the array sum until that index.thelastindexofthearraywouldcontainthearraysumand 217slacc simion based languageagnostic codeclones i cse may23 seoul republic ofkorea 1deffunc db8e a n len a sum0 n forii nxrange n sum0 sum0 a a llv sum0 returnallv 1deffunc 43df items sum sum items j len items return sum fi gure semantic cluster of python functions detected by slacc.theclustercontainsfunctionsthatreturnsthesum ofan inputarray.
1static long func 3b0e long x2 l ong res null l ong arr x2 intlen arr.length for inti i len i longxx arr if xx res continue r es xx returnres 1deffunc 6437 y y min min y count returnymin fi gure semantic cluster of a java function and a python functiondetectedbyslacc.theclustercontainsfunctions thatreturnstheminimumvalueinan inputintegerarray.
iseventuallyreturned.incontrast func 43df usesthesumlibrary functiontoperformthe sametask.
rq2 s lacccansuccessfullyidentifycodeclonesfordynamictyped languages withhighprecision .
.
.
rq3 acrossprogramminglanguages we execute slacc on the java and python projects from gcj.
from extracted snippets slacc identi f ied java and pythonfunctionsclusteredinto34cross languageclusters singlelanguage clusters are omitted from the rq3 analysis .
on validation we f ind that of these .
clusters are false positives whichisbetterthanthepercentageoffalsepositivesfoundinjava andpythonindependently.thatsaid slaccwouldproducemore clusterswhensupport forthe languages is broadened.
wediscover616type iiiclustersbycomparingtheastsofjava andpythonsnippets ofwhich25clustersarevalid .
precision .
it should be noted that this is a conservative precision estimate thebaselinewascreatedbystartingwithclosebehavioraltable mean and variance in parenthesis of clones clusters and false positives for repeats when inputs varying between .
the mean and variance are reported.
inputs clones clusters false positives matches hencegivingtheastanalysisaslightedgeonprecision section .
.
.
an example of a pair of java python clones can be seen in figure .func 3b0eis a java function that uses a loop to f ind the minimum in an array while func 6437 is a python function uses the inbuilt minfunctioninpython.
rq3 s laccsucceedsinidentifyingclonesbetweenprogramming languages irrespective of theirtyping.
discussion wehavedemonstratedhowslacccansuccessfullyidentifyclones in single language multi language static typed language and dynamic typed language environments.
compared to prior art hitoshiio slaccidenti f iesasupersetoftheclustersandwithhigher precision.
compared to type iii clone detection slacc achieves a much higher precision in python and in cross language situations.
this would lead us to believe that traditional methods that detect syntactic type iii clones cannot be used for cross language clonedetection despitesuccessfulapplicationsinsinglelanguages foridentifyinglibrarieswithreusablecode detectingmalicious code catchingplagiarism andidentifyingopportunitiesfor refactoring .
next weexplorethesensitivityofcodeclonestothenumberof inputs thenumber of arguments and thesizeof the snippets.
.
impact of input sizes prior studies have shown that varying the number of inputs can alter the accuracy of clone detection techniques .
this wasparticularlyevidentintheearliestclonedetectiontechniques by jiang and su where the authors limited the number of inputsto10withamaximumof120permutationsoftheinputdueto theneedforlargecomputationalresourcesandthecorresponding runtime.
we test the impact on clones clusters and false positives by varying the number of inputs from to in powers of and repeating slacc using the generated java functions.
each experiment is repeated times on a set of randomly generated inputs.
foreachsetofinput werecordthemeanandvarianceforthenumberofclones clustersandfalsepositives asshownintable5.for 218icse may23 seoul republic of korea m athewetal.
figure cumulative clones with arguments varying bet ween1 .
figure clones for lines of code between ranging from .cloneswith30 ormorelinesare grouped into30 a given number of inputs each row represents the mean and variance in parenthesis of the number of clones clusters and false positives.forlownumbersofinputs weseemorefunctionsbeing marked as clones and fewer clusters.
as the number of inputs increases the number of clones reduces and the number of clusters increases demonstrating that the additional inputs are critical at differentiating behavior between functions.
the counts of clones clusters andfalsepositivesappeartoplateauafter64inputs.this highlights that inputs used by jiang and su would not be sufficientforoptimallyidentifyingtruefunctionalclonesandwilllead toalargenumberoffalsepositives assuggestedinpriorwork .
.
in f luenceof argumentsin clones weuseourengineeringjudgmenttoset args max maximum numb er of arguments to limit the number of functions generated from snippets.
figure represents the cumulative number of cloneswithargumentsvaryingfrom1to5andcanbeusedtojustifyourchoiceof args max .mostclonesdetectedbyslacchave two arguments or less.
in java functions of clones detected have less than three arguments.
cross language functions are fewer in number and typically contain functions with argumentsorless 125outof131 .thiswouldseemintuitiveasmodular functions are more frequent compared to complex functionalities.
asargs max increases it begins to plateau around .
hence alargervalueof args max maynotyieldsigni f icantlylargernumber of code clones but would incur more computational resources args max!
functionexecutions .
.
clonesvs linesof code priorworksuggeststhereismorecoderedundancyatsmallerlevels of granularity .
aggregating all the cloned functions identi f ied by slacc in rq1 rq2 and rq3 we have total valid cloned functions in java and python duplicates removed as the samefunctioncouldbeincludedinanrq1andanrq3cluster for example .
figure8representsthenumberofcloneswithlinesofcodevaryingfrom1to29.cloneswith30ormorelinesaredenotedas .
morethan50 ofthevalidjavacloneshave6linesofcodeorless whilethemedianofvalidpythoncloneshave5linesor less .thisimpliesthatsnippetswithmorelinesofcode aremoreuniqueandhardertoclonefunctionally.onthecontrary smaller snippets are more likely to contain clones in a code base.
thegreatermedianforjavaclonescomparedtopythonclonescan beattributedtotheverbosityinjavacomparedtothesuccinctnatureof python .
related work in keeping with the survey on code clones by roy et al.
research on code clones can broadly be classi f ied as syntactic which represent structural similarities and semantic whichrepresent behavioral similarities.
eqminer is the closest related work with respect to our methodology.
they examined the linux kernel v2.
.
by using a similar segmentation procedure used randomly generated inputstoexecutethem andclusterbasedoniobehavior.compared with slacc eqminer crucially ignores cross language clone detection.furthermore theimplementationofeqminercontainsseverallimitations notedbydeissenboeck thatmakecross language detectioninfeasibleandevenreplicationitselfimpractical.asaresult webuildontheideaspioneeredbyeqminer whileovercominglimitationsinitsoriginaldesign.weintroducenovelcontributions suchasusinggrey boxanalysistoovercomethelimitations ofsimplerandomrandomtesting scaletheinputgenerationphase from to inputs which drastically reduces false positives introduce several steps and components to support complex language features such as lambda functions and handle differences arisingfromcross languagetypes.finally slaccintroduces f lexibility in clustering as it permits a tolerance on similarity due to thesim thyper parameter.
hitoshiio by su et al.
also performs simion based comparisonstoidentifyclones.itusesexistingworkloadsliketest casesor main function calls to collect values for the behavior rather than the random testing approach proposed in eqminer or the greybox analysis approach used in slacc.
research shows that existing unit tests do not attain complete code coverage and as a result the application of such a technique to open source repositories might not be produce a comprehensive set of clones.
this conjecture can be observed in rq1 where slacc identi f ies more clones to hitoshiio by an order of magnitude.
further hitoshiio operates at a method level granularity while slacc can operate atmethodorstatementlevelgranularity.naturally thisensuresa greater number of code clones since slacc can identify succinct behavior incomplex code snippets.
219slacc simion based languageagnostic codeclones i cse may23 seoul republic ofkorea lasso by kessel and atkinson like hitoshiio is another clonedetectiontechniqueformethodlevelclonesfromlargerepositories using test cases.
but unlike hitoshiio it does not use prede f ined test cases lasso generates test cases using random generation via evosuite .
that said lasso has many deviations compared to hitoshiio and slacc.
firstly lasso identi f ies only clones that have the same signature and method name excluding case .
secondly it detects clones only in methods where the arguments are primitive datatypes boxed wrappers of primitives strings and one dimensional arrays of these datatypes.
it fails to supportobjects slaccsupportsobjectsthatcanbeinitializedrecursively using constructors of its members section .
.
finally lassosupportsonlystronglytypedlanguagesasitdoesnothave atypeinference engine likeslacc does.
mostclonedetectiontechniques havebeen proposedforsinglelanguageclonedetection.withrespecttocross language clone detection we failed to f ind any techniques based onsemanticbehaviorofcode.asmallnumberoftechniqueshave been proposed on syntactic code features .
api2vec detectsclonesbetweentwosyntacticallysimilarlanguagesbyembeddingsourcecodeintoavectorrepresentationandsubsequently comparing the similarity between vectors to identify code clones.
clcdsa identi f ies nine features from the source code ast and uses a deep neural network based model to learn the features anddetect crosslanguage clones.
segmentationusedinslaccisinspiredbymethodsthatparse asts of the source code .
these methods encode the asts into intermediate representations and do not account for the semantic relationships.
for example deckard characterizes sub treesoftheastintonumericalvectorsandclustersthembased on the euclidean distance which fails to capture the behavior of codeintheclusters .thislimitationhasbeenobservedinother syntacticmethodsaswellandisareasonforadoptionofsemantic techniques todetect code clones .
limitationsandthreats threatstoexternalvalidityincludethefocusontwolanguagesas instances of static and dynamic typing so results may not generalize beyond java and python.
the use of gcj code may not generalize to more complex code bases.
threats to internal validity include that for rq3 where we help the ast matching by starting with behavioral clusters and then determining if the asts are similar which overestimates the precision of cross language ast matching.
our implementation of slacc hasthe followinglimitations dynamic typing.
slacc does not support two primitive types longandcomplexforpython.thatbeingsaid weveri f iedthatthe gcj projects used in this study do not explicitly use these values in the source code and they are not present in the input f ile used by the baseline hitoshiio.
further in case of a failure to identify the type of a function argument the function was fuzzed with arguments of all supported types.
in this study we supported primitive types and the simple data structures tuple set listanddict.supportforothersophisticateddata structurescanbeincorporatedbyextendingtheexistingslaccapiwithinstructionsin the wiki .
unsupported features.
although slacc supports object oriented features such as inheritance and encapsulation it is limited toobjectsderivedfromprimitivetypes.hence thecurrentversion of slacc cannot scale to more sophisticated objects like threads anddatabaseconnections.similarly forpythonwedonotsupport moduleslikegeneratorsanddecorators.nevertheless itwouldbe possibletosupportthesefeatures withmore engineeringeffort.
dead code elimination in the code clone examples of figure andfigure6 weseethepresenceoflinesofcodethatdonotin f luencethereturnvaluei.e.
deadcode.atthemoment thefunctions donotfailduetodeadcodebuteliminatingthemwouldmakethe functions more succinct and comprehensible.
this will be an avenue for futurework forspeci f ic applications of slacc.
conclusion inthispaper wepresentslacc atechniqueforlanguage agnostic code clone detection that precisely yields semantic code clones across programming languages.
this is the f irst research to identify semantic code clones in a dynamic typed language and also across differently typed programming languages.
slacc identi f iesclonesbycomparingtheiorelationshipofsegmentedsnippets of code from a target repository.
input values for the segmented code are generated using multi modal grey box fuzzing.
this results in fewer false positives compared to current state of the art semantic code clone detection tool hitoshiio.
in our study we identify code clones between java and python from google code jam submissions.
compared to hitoshiio slacc identi f ies signi f icantly x more code clones with greater precision .
vs. .
.
slacc also detects code clones in a multi language code corpora.thenumberofclonesdetectedwasfewerandthenumber offalsepositiveswasslightlymorecomparedtocodecloneswithin thesamelanguage.however futureworkthatbroadenslanguage support is likely to improve these metrics.
these results have implications for future applications of behavioral code clones such as enabling robust language migration tools or mastery of a new programminglanguage once oneis known.
slaccisopen sourceandthedatausedinthisstudyispublicly available .