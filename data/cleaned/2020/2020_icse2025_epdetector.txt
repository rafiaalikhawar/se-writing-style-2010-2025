ep detector automatic detection of error prone operation anomalies in android applications chenkai guo qianlu wang naipeng dong lingling fan tianhong wang weijie zhang enbao chen zheli liu and lu yu dissec college of cyber science nankai university china haihe lab of itai china the university of queensland australia college of computer science nankai university china national university of defense technology china anhui province key laboratory of cyberspace security situation awareness and evaluation china guochenkai wql linglingfan tianhongwang liuzheli nankai.edu.cn n.dong uq.edu.au a505025234 gmail.com yulu nudt.edu.cn abstract android applications are pervasively adopted and heavily relied on in our daily life leading to the growing demand for enhanced user experiences such as ease for operation and robustness.
nevertheless developers continue to prioritize traditional functionality and performance overlooking the pivotal role of user experience in real world scenarios.
for example poorly designed page elements can lead to user confusion resulting in unexpected outcomes termed as the error prone operation anomalies epas .
in this work we undertake the first effort to uncover the underlying essence of the epa problem.
to achieve this objective we investigated the root causes of epas from three dimensions i.e.
subject object and environment.
these causes were identified by multi stage attribute capturing and precise similarity computation.
in this process the causes are categorized into fine grained classes namely confusing behaviours unsuitable layout and resource overload.
building upon these insights we propose a dynamic gui based testing tool ep detector to facilitate detecting the epas in real world apps.
the ep detector is equipped with widget exploration based target navigation and automatic test oracle enabling it to detect error prone page elements and simulate events with both comprehensiveness and precision.
to systematically study the prevalence and severity of real world epas we conducted experiments on 53popular android apps with ep detector.
the confirmed results not only validate the high precision and completeness of ep detector but also highlight that epas are prevalent in current apps with at least one epa existing in every two page widgets on average and .
of them may lead to security and functionality issues or risks.
the ep detector is available at index terms android application user operation anomaly detection error prone operation automated test i. i ntroduction android applications apps for short are software running on mobile systems which are normally equipped with numerous graphical use interfaces guis for miscellaneous user interactions.
user behaviours are the typical input to android apps driving the execution of the apps underlying functionality.
the diversity of user behaviours and their temporal nature corresponding author lingling fan.raise the complexity of an app s execution routines thereby posing a challenge in gui based app testing.
since the pioneering work by hu et al.
in the testing of gui based mobile apps has gradually emerged as a focal area of interest in both industry and academia .
traditional gui based testing generates test cases to approximate critical user interactive behaviours or guide the execution paths which facilitates uncovering fatal crashes framework weaknesses non crashing functional bugs or security vulnerabilities .
in existing gui based testing works a latent but strong assumption is that all test cases are correctly and accurately executed by users.
however achieving this assumption can be challenging in the practical use of android apps.
on one hand as user requirements for rich functionalities increase the user events specified by android tend to be more miscellaneous and complex.
for instance android introduced an optional gesture system including swipe up swipe in a hook move etc.
in version .
which allows replacing all bottom buttons with a single bar.
however users often find these swiping operations confusing leading to imprecise and incorrect operations.
on the other hand android apps typically operate under stringent device limitations and within complex scenarios compared to traditional pc devices which further amplifies the challenge of performing correct operations.
for instance the screen size of mobile devices are normally limited.
users are required to accomplish diverse operations with a bigger cursor fingers on a relatively smaller range.
in addition the operations of mobile apps can hardly be stable due to the heterogeneous use scenarios e.g.
users usually operate the mobile device when standing walking or even lying down.
moreover the system resources of android e.g.
cpu ram and network are constrained and such resource limitation tends to raise system freezes and crashes which further increases the risk of misoperations.
the misoperations are often triggered by unreasonable design of page elements.
a sound page design should be a too small cancel b confusing three fingered screenshot x c erroneous payment caused by page loading 3fig.
.
motivating examples.
robust to the aforementioned sensitivities.
that is the user will not experience misoperations resulting from inadequate interactions with widgets layout issues of widgets or resource environment constraints.
in this work we refer to the user s misoperation caused by error prone page elements as the error prone operation anomaly epa .
the ubiquity of epas which will be verified in our later experiments produce negative impacts on apps such as degraded user experience execution crashes and security risks for users without professional exercise.
however to the best of our knowledge there is still lack of systematical study and precise detection for the epas.
the challenges of epa detection are two fold.
first the consequences of epa have diverse manifestations making it difficult to capture the underlying root causes.
second given the probabilistic occurrence of epas it is challenging to trigger and identify various types of such unconventional misoperations in a consistent manner.
in this paper we address the challenges by proposing a novel dynamic testing technique ep detector .
to identify the root causes of epas ep detector analyzes each target widget that users interact with based on three factors subject object andenvironment .
thesubject refers to user behaviours interacting with the target widget.
if similar user operations yield different outcomes termed confusing behaviours and if the widget supports them users are likely to be misled.
the object refers to design of widgets capable of triggering error prone operations.
one prominent issue is the unsuitable layout in the widget for example the elements size and spacing which often results in misoperations.
theenvironment refers to the resources that facilitate the execution of the target widget such as the cpu ram and network.
drastic environmental changes such as resource overload can lead to misoperations particularly if the widgets are sensitive to the changes.
ep detector then develops gui based testing from the above insights.
to address the challenge for triggering and identifying epas ep detector employs the following techniques multiple execution strategies and test oracle methods are designed to capture the heterogeneous dynamic nature of the testing.
a two stage target navigation with fine grained trace guidance and multi level target identification is designed and implemented to ensure a smooth and accurate detection.
optimization strategies such as page level abstraction and operation grouping are devised to enhance detection efficiency.
the performance of ep detector is evaluated on well known real world apps covering diverse app categories containing widgets across pages.
the ep detector detects confirmed epas with an average precision of .
.
the results illustrate that epas are prevalent in current apps with at least one epa existing in every two page widgets on average and .
of them may lead to security or functionality risks.
in summary the contributions of this paper are as follows we are the first to conduct a systematic study of the error prone operation anomalies epas in android apps including their prevalence root causes and impacts.
we propose a novel testing technique ep detector for the dynamic detection of epas covering behaviour layoutand environment based error prone page elements.
experiments on 53real world apps validate the effectiveness of the ep detector.
the experimental results reveal intriguing findings with careful examination of typical epa cases showcasing the impacts of the detected epas.
ii.
m otivating examples this section motivates our research by presenting three types of error prone user operations within the same android app.
illustrated in figure is the gui of a well known chinese banking app exemplifying these irreversible error operations epa when a user opens the app she will be directed to the home page.
as shown in figure a an advertisement dialog pops up on top of the actual home page.
if the user wants to close the advertisement and visit the home page she may find that the closing button is small and somewhat hidden as shown in a 1 .
this can result in accidentally pressing the wrong area which redirects the user to the advertisement page instead.
epa when the user visits the main operation page and attempts to use the three finger swipe for taking a screenshot provided by the huawei harmony to save the key page information as shown in b 1 the systemmay mistakenly interpret it as a click due to the excessive force of the first finger.
this inadvertent click could trigger the bank scan function b 2 leading the app to the scan page.
if coincidentally a payment qr code appears in front of the camera b 4 the app will be redirected to the payment transfer page.
epa the user intends to visit the my payment page as shown in c 1 to set the payment limit.
however if the page loading is stuck due to for example the network delay the user may assume it s her operation fault and repeatedly click on the screen c 2 .
when the my payment page eventually loads these additional clicks may inadvertently trigger actions if there are buttons placed in the same position on the my payment page e.g.
the payment scan button as shown in c 3 .
as a result these unintended clicks lead the app to the payment scan and subsequently to the payment transfer page if a payment qr code is detected in front of the camera.
the above examples demonstrate that app design and implementation may lead to user s error prone operations which result in irreversible and unexpected consequences that significantly reduce user experience and increase security risks.
iii.
p roblem definition the entire process of epa detection can be formally represented as a tuple a q where qis the set of execution states represents the set of events triggering state changes and q qrefers to the state transitions.
the contains three error prone event groups eb ea ee eb ea ee representing the epa events caused by behaviour layout and environment respectively.
let e es eb eebe an epa event group e1ande2are error prone events within the same group e1 e e2 e s qis an execution state s e1 st1 and s e2 st2are two state transitions triggered by e1 ande2respectively the epa problem can be defined as diff st1 st2 where the diff is a differential function defined later for computing the difference between st1andst2 is a given threshold.
the intuition is that if there exists e1ande2leading to states that cannot be distinguished then epa occurs.
we require that an execution state s qis determined by the current app page s.pand its corresponding execution environment s.env denoted as s p env each event e must has a widget win the page pwith operable attributes p w .attrs detailed in iv c as its carrier and the ehas to meet the p w .attrs denoted as e p w .attrs .
iv.
ep d etector given a target app ep detector identifies epas for each widget through the following three modules as shown in figure .
the target navigation module navigates to the target pages and widgets relying on the page widget identification .
to reduce cost the event trace during the navigation is logged in the recorder to guide new navigation.
the target pages andwidgets are then fed into the detection execution module to simulate the execution paths triggered by the epa sensitive events defined in iv c .
finally the test oracle module incorporates an automated oracle to compute the diff function eq.
determining the existence of three types of epas.
in this process change of environment env sim and page similarity psimbefore and after an event are computed.
the system environment is collected by the resource monitor andpsimis used to determine if a target page is reached in target navigation and detection execution.
auttarget navigation resource monitordetection execution confusing behaviour bepa unsuitable layout aepa resource overload eepa test oracle diff for bepa aepa eepa s device resource android envrecorder pageid widgetid click pageid widgetid click pageid widgetid longclick pageid widgetid click event target pages widgets two stage navigation target identificationtrace page similarity fig.
.
the workflow of ep detector.
a. two stage navigation to identify and locate widgets e.g.
buttons text editors sliders that may cause error prone operations ep detector adopts a widget exploration approach deviating from the typical path exploration approach in the majority of existing model based gui testing .
in this process the target navigation module incorporates two stages.
stage page navigation.
lets.pbe the original page where sis the execution state of an epa detection the target page st.ptcan be reached in a sequence of state transitions s e11 s11 ... s1i e1i s ... s ek1 sk1 ... skj ekj st named as the event trace .
essentially we try to trigger each element in the original page in the breath first search bfs way following the order of the page layout.
each triggering of an element vleads to various states s ev1 sv1 ... svi evi s with a state transition back to the original state sat the end.
the event trace is the concatenation of multiple element triggering transactions until the target event is identified.
stage widget navigation.
once the target page pis located we proceed to identify the target widget p w by matching its index.
the widget is characterised by its errorprone attributes p w .attrs which is used to initiate the errorprone operations in the subsequent epa detection by triggering the corresponding event e p w .attrs .
to reduce exploration overhead optimization strategies are implemented based on the following two observations.
observation .
reversing to the previous state occupies a great majority of page navigation tasks.
as shown in stage detecting the epas on a target widget p w at state srequires triggering multiple errorprone events at the page s.pforming an event trace.
foreach triggering of an element vwith transition s ev1 sv1 ... svi evi s ep detector collects detection element information of svifor later steps navigates to the original sfor next transition.
one can observe that for a given sthere are many reverse transitions svi evi s. this observation inspires the optimization .
optimization .
reverse transition sv e sis implemented by clicking the page level back buttons in the epa detection with the highest priority in page navigation.
observation .
not all state transitions lead to new page rendering when execution anomaly occurs.
if a system crash app freeze or failed rollback ocurs the reverse transition in optimization becomes invalid.
to ensure the page navigation still restart from the initial state s we record the navigation trace which is a sequence of eventwidget pairs ei pi wi where eiis a triggering event and pi wi is the corresponding widget wiin page pi.
the idea is to leverage a space for time strategy for an express navigation to the target page ignoring the repeated page exploration.
optimization .
each navigation trace for a target page pt i.e.
e1 p1 w1 ... ei pi wi ... et pt wt is recorded in the recorder module to guide subsequent repeated navigation from the initial state.
b. target identification the process of page navigation and widget navigation involve frequent decision making to determine whether the target page or widget is reached defined in page identification andwidget identification respectively.
page identification in traditional model based dynamic testing the page state identification often relies on absolutematching .
that is the attributes of the target page state is first encoded using abstraction techniques e.g.
hash code or customized template .
then a given page state is identified by matching the abstraction results.
however such absolute matching is often invalid in detecting real world apps.
observation .
the attributes of the target page may change if being repeatedly accessed.
formally let sbe an original state stands tbe two target states transited from swith the same event trace e1 e2 ... e k we may have st.p.attrs !
s t.p.attrs where denotes the identical relation and p.attrs denotes the attributes of the page p. this phenomenon is often observed in deep interactive apps e.g acfun bilibili andloklok and its rootcause lies in the updating of dynamic elements e.g.
advertisements random animations or page reconstruction .
in details page updating during each rendering may increase reduce attributes for localization e.g.
elementid resourceid and class modify the attributes for content and action e.g.
text isenable and clickable .
therefore traditional attribute based absolute matching may fail to identify pages leading to decreased precision of navigation.
this inspires us to exploreanrelative matching identification by introducing a jaccard distance based page similarity psim pt p t pt.attrs p t.attrs pt.attrs p t.attrs .
if thepsimis larger than a given threshold p the target page is identified.
in practice not all the page attributes are needed in the computation.
we prefer attributes for localization rather than for content and action due to their high stability during the page reconstruction.
the utilization of psimspans across multiple stages of ep detector in the page navigation iv a the psim is used to identify the target page.
this similarity based navigation is also frequently used in the computation of diff.
in the test oracle stage iv d the psimplays a critical role in computing the diff function eq.
that is relied upon to automatically determine an epa in the test oracle.
the function diff calculates the differences between two given states sandstby comparing the similarity of both their page and environment as they collectively define an execution state i.e.
s p env in iii .
therefore diff is computed as diff s st psim s.p s t.p env sim s.env s t.env where env sim s.env s t.env denotes the environment similarity defined in the following eq.
.
env sim n1 n2 x env i envsetzi env i n1 n2 where envset is the set of environment factors e.g.
cpu ram and network ziis the normalization coefficient computes the value change between n1 n2.
in the detection execution stage iv c the psimalso serves as state abstraction in epa detection.
specifically pages exhibiting similarity within a predefined threshold are treated as identical and states sharing identical pages are clustered together as the same page state .
widget identification in the two stage target navigation once the target page is identified the target widget can be identified based on the types of widgets that are frequently interacted with users e.g.
button checkbox andscrollbar .
however such type based identification may fail in practical detection.
observation .
not all interactive widgets are capable of executing the expected operations necessitating their detection.
for example a general imagebutton s reaction to long click depends on the long clickable attribute setting rather than the button type.
under this insight the widget identification of ep detector is attribute based rather than type based.
we consider a concise but effective attribute set forwidget identification specific for the epa operations listed in table i .
the identification procedure contains four steps filter the widgets through the status attributes determine the operation behaviours through action attributes note that theaction attributes only cover epa related behaviours table i extracted widget attributes .
type name dtype type name dtype id element id text links href text actionclickable bool statusvisibility category scrollable bool displayed bool checkable bool enabled bool longclickable bool size bounds numeric determine the operation area through size attribute record theidfor further check and comparison.
based on these attributes user behaviours under specific scenarios are simulated and realized see iv c1 .
c. detection execution the occurrence of an epa requires the integration of three core factors i.e.
subject object and environment as stated in i. under this philosophy the epa can be partitioned into three types according to these factors i.e.
confusing behaviours bepa unsuitable layout aepa and extreme resources eepa detailed in each subsection.
confusing behaviours the types of user behaviours working on widgets are complicated making it challenging to determine the confusing ones.
particularly it is difficult to consider behaviors that may be interfered with by natural factors such as voice control voice input and phone shaking due to their high uncertainty.
therefore our focus is shifted to the user gesture events.
guided by the gesture callbacks contained within gesture related android classes e.g.
android.view.view android.widget android.view.gesturedetector and motionevent we can summarize the user behaviours associated with these callbacks.
however detecting all behaviours for each widget is costly.
redundant and less critical behaviours are filtered using the following strategies.
for the behaviours with multiple directions only the most commonly used one is preserved e.g.
we preserve upswipe and filter out downswipe .
for similar behaviours only the representative one is preserved e.g we preserve swipe and filter out fling.
the system specific and rarely used behaviours e.g.
knuckle tap andtwofingerdoubleclick are omitted.
as a result 12typical behaviours are collected shown in table ii where the behaviour name starts with the number represents the behaviour has two operation directions and behaviours used with low frequency in experimental trials are denoted with appearing only in specific apps.
table ii confusing groups of collected behaviours .
category gesture widget attributes click click doubleclick twofingerclick longclick swipe clickable checkable longclick longclick click swipe twofingerlongclick long clickable scroll 2scroll 2swipe 2twofingerswipe pinchopen draggable scrollablethe behaviours are divided into three confusing groups click longclick and scroll based on their confusion degree defined as follows definition .
confusion degree.
given two user behaviours haand hb their confusion degree is the sum of their distances on the four operation dimensions the number of operations opn number of fingers opf operation distance opd and duration opt i.e.
conf ha hb p opx op ha.opx hb.opx where op opn opf opd opt .
the values of opn andopf are obtained by a simple counting of the behaviour.
opt andopd are discretized coarsely based on their semantics.
for opt standard and long are quantified as 1and2 foropd only in place operations and operations with distance are distinguished quantified as and1respectively.
for example the opn opf opd opt ofdoubleclick and swipe are and respectively and their confusion degree can be computed as .
the confusing behaviours are identified based on their pairwise confusion degree .
each group has a basic behaviour underlined in table ii h additional behaviours hxin the same group are identified if the equation conf h hx holds.
after that the confusing behaviours in the same group are simulated one by one whose results are recorded for the determination of bepas by the following test oracle.
the basic behaviour simulation is implemented by calling apis inappium .
but there are no available apis for operations like doubleclick and twofingerswipe they are achieved by simulating the combination of basic behaviours.
unsuitable layout unsuitable widget design prone to epas encompass a range of factors including colour shape size spacing and textual states .
however only layout related factors e.g.
size andspacing can be checked through dynamic detection which are the primary focus of epdetector.
epas triggered by unsuitable layout is called aepas.
definition .
unsuitable layout.
given the center point pcof the target widget wt the minimum width widmin wt ofwtis defined as min dis pc px px pt where ptis the set of boundary points of wt.
assuming that wnis another widget closest to wt the minimum spacing distance spcmin wt wn between wtandwnis defined as min dis pc pn pn pn where pnis the set of boundary points of wn.
an unsuitable layout is the widget design that satisfies both cond 1andcond where cond widmin wt wviolates the specified safe distance for widget size w and cond spcmin wt wn s violates the safe space between widgets s. figure illustrates typical cases of unsuitable layout a refers to a suitable widget size i.e.
!cond b indicates an unsuitable size but suitable spacing i.e.
cond !cond c indicates an unsuitable layout i.e.
cond cond .
from this figure we can also see that we only need to use win defining the safe area as sserves the purpose.definition .
safe area.
given a center point pcof the target widget wt the safe area for wtis a circular area with the center being pcand the radius being w. widget a24dp widget awidget awidget b 24dp widget awidget c 24dp b cond1 !cond2 c cond1 cond2 d dynamic test 24dp a !cond1widget asafe areasafe area safe areasafe area fig.
.
cases of unsuitable layout.
the wcan be determined through the guidance of android suggestion for accessible user experience where they recommend that each interactive ui element should have a focusable area or touch target size of at least 48dpx48dp .
thus the wis set to the same size value accordingly.
the unsuitable design can be detected statically during the page navigation since the boundary of the target widget can be captured through parsing the layout .xml tree.
however in static detection we could not observe the aepas and their properties like location.
hence dynamic operation simulation is used in ep detector.
as shown in figure d we could guide the dynamic simulation of operations to approach the boundary of safe area and evenly distributed in the safe area to avoid the location concentration of simulated operations.
resource overload insufficient device resources for app running e.g.
cpu ram and network capacity can result in epas.
for instance when the device resources are overloaded and about being exhausted execution anomaly such as page freezing and operation failing are prone to occur interrupting user operations and leading to misoperations.
in response to execution anomalies users commonly resort to continuousand repeated c r operations despite their high risk nature.
this practice results in two types of eepas shown in figure .
heavier overload.
as indicated in figure a the c r operations on the same widget of a frozen page would incur heavier overload on running resources e.g.
cpu ram and network which can raise further irreversible running exceptions e.g.
system crash and data loss.
unintended misoperation.
as indicated in figure b the c roperations are first performed on the frozen page a .
when the page suddenly jumps it is difficult for a user to realize in time that the user may mistakenly apply the same c roperations to the same position on the new page b resulting in an unintended exception.
the two types of eepas that triggered by real running environment are hard to be checked by static analysis.
so ep detector employs a dynamic analysis to detect them which includes three steps.
try to click the widgets with clickable true onpage a and checks whether page ajumps to another page b .
if no jump occurs continuously simulate identical click operations and performs them at the same position of page a for5times with the interval a heavier overload overloadc r operations running resouces b unintended misoperation page b jumped from page a a sudden transition freezed page freezed page ac r ops on widget wtfig.
.
two types of eepas.
of0.3s the value of times and interval correspond to the average c rfrequency and speed of humans respectively simultaneously monitoring the changes of cpu ram and network speed.
if a jump occurs simulate the click operation at the same position of page b and monitors whether a new state transition happens.
note that for the sake of cost efficiency ep detector only supports click simulation in the detection.
in implementation ep detector uses thread.sleep to suspend the ui main thread to simulate the page freezing.
d. test oracle ep detector supports an automated test oracle where the function diff eq.
in iii and iv b is computed using different strategies for the three types of epas.
detection of bepa .given current state sand a pair of confusing behaviours e1ande2 from the same behaviour group in table ii the test oracle aims to determine whether diff s s e2 diff s e1 s e2 holds.
if it does a bepa is found.
the underlying rationale is that once the new page triggered by the confusing behaviour e2 is neither the same as the original page s nor the same as the page triggered by the basic behavior e1 it could lead to undesirable consequences.
detection of aepa .given current state sand a pair of identical operations on safe area iv c2 e1ande2 the test oracle aims to determine whether diff s e1 s e2 holds.
if it does an aepa is found.
the underlying principle is that two identical operations within the safe area should lead to the same outcomes otherwise it could result in anomalies.
detection of eepa .the test oracle contains two parts heavier overload.
assuming sands are the states before and after c roperations respectively the oracle determines whether env sim s.env s .env envholds unintended misoperation.
through page identification the test oracle first checks if a page jump frompage a topage b occurs when c roperations are performed.
then assuming sands are the states before and after operating on page b respectively the oracle determines whether diff s s holds.
if both conditions are satisfied an eepa is found.
the principle here is that an unintended page jumping accompanying with a heavier overload causing significant environment changes may result in risky consequences.
determining and .to calculate the diff function in addition to computing psimandenv simfollowing their formula eq and eq we need to determine the parameters and .
except for the detection of heavier overload the parameters and indiff formula see eq.
are determined in a dynamic way as follows.
psim p psim p env sim env .
.
otherwise.
v. i mplementation ep detector is implemented in python .8with more than 4klines of code excluding library files.
it adopts existing api support libraries including the appium dynamic test api the adb screenshot command the cv2 command for drawing points the xml.etree plugin for parsing xmlfiles the subprocess pipeline command for sending adb commands etc.
specifically to meet the detection request of bepa extra user behaviours are simulated and customized based on the appium including drag and drop operations and multitouch interactions.
the experiments are conducted on multiple versions of android i.e.
android .
.
and .
.
the test device is equipped with gbram and cores cpu.
following the approach in iv for each app target we first navigate to each widget to trigger all designed simulated events in each type of epa and uses the test oracle to determine the epas.
to decide the best values for the parameters p page identification and env test oracle a common used parameter optimization method grid search was employed to fine tune these parameters with a step of .1within an imperial value range .
.5for and envand0.
.
for p. optimal performance in epa detection was observed when p .
.2and env .
where .
of the epas and .
page states were accurately identified on testing pages.
vi.
evaluation based on the results of the above execution the epdetector is then evaluated from four perspectives precision completeness efficiency andseverity of the detected epas.
a. precision benchmark to ensure the fairness and effectiveness of the evaluation we select the evaluation benchmark with the following three rules.
comparability collect the three apps in loc evaluated by the existing dynamic gui testing works i.e.
wordpress k mail and myexpense .
prevalence collect the top apps with download amounts of no less than 100k.
comprehensiveness to balance the coverage of both categories and complexity the collected apps are evenly distributed across 9functional categories the number of pages in the apps is evenly distributed across the intervals and the apps should be collected from multiple markets.
following these rules we collect popular apps for each category in google play and 5top apps in chinese market i.e.
wechat alipay bankcomm bilibili anduc browser .
at last 53eligible real world apps are collected as the benchmark.
epa confirmation the detection outcomes of epdetector are automatically marked epas on the anomalous widgets of gui screenshots which need to be manually verified.
we recruited 3volunteers with rich experience in using mobile systems in our college to conduct the confirmation.
to ensure the fairness of the confirmation we conducted necessary training for the volunteers which was mainly divided into three stages familiarize the volunteers with the process of target navigation and epa detection especially with the detection indicators introduced in test oracle iv d .
randomly select 60existing epa samples 20for each type of epa for them to identify.
if one sample is identified incorrectly an additional 5samples are added to identify until they are all identified correctly.
ensure that each detected epa and navigated page are confirmed by at least two volunteers.
if there is contradiction the third volunteer or the author completes the final confirmation.
in total the manual confirmation for both page states and detected epas takes 8hours.
results the apps with detected epas in the benchmark along with their precision computed after confirmation are presented in table iii.
the overall precision .
is encouraging which indicates the ep detector can significantly assist in saving on manual inspection efforts in detecting the epas.
among the three types of epas the tool has the highest accuracy in detecting bepas .
and the lowest accuracy for eepas .
.
this is mainly because the occurrence of eepas requires specific runtime environment and it is difficult to ensure the stability of the system environment consistently during app operation.
in contrast the detection of bepas focuses only on a few operations in specific positions on the page reducing the likelihood of confused operations during the detection.
to delve deeper into the limitations of ep detector in the detection precision we randomly select about of the false positive cases and analyze their underlying causes which are summarized as follows nearly half of the false detected cases are caused by the intersecting influences among specific system resources or execution processes.
for example the continuous use of network resources by streaming media on the target page may lead to confusion in resource consumption when detecting epas on other widgets on the page resulting in falsely reported anomaly.
nearly a third of the false cases result from settings for resources e.g.
ram and network traffic and similarity parameters e.g.
and envin iv c .
variations in widget functionalities lead to different degrees of resource consumption.
setting a low threshold may cause ep detector to falsely label healthy widgets as error prone false positives while a high threshold may result in overlooking epas false negatives .
the remaining nearly 6false cases are mainly raised from extraneous factors such as interruptions of systemlevel events and abnormal fluctuations in network.
we would like to highlight that these false positives do nottable iii precision performance of ep d etector in epa sdetection .
appsizedownload precision of detected epas mb aepa bepa eepa total itranslate .
.
.
50m .
.
.
battery hd pro .
.
.
100k .
.
.
memo .
.
.
10m .
.
.
notepad .
.
.
10m .
.
car launcher .
.
.
.
1m .
.
.
bankcomm .
.
.
50m .
.
.
.
days matter .
.
.
1m .
.
alipay .
.
.
10m .
.
.
.
everydoggy .
.
.
500k .
.
.
frandroid .
.
.
500k qr .
.
.
500m .
.
gjj .
.
.
100k .
.
.
right gallery .
.
100k .
.
google books .
100m .
.
.
.
google maps .
.
10b .
.
google translate .
.
.
1b .
.
.
gmail 10b google earth .
.
.
.
500m .
.
.
.
gcamator .
.
.
10m .
.
.
.
listen free .
.
.
100k .
.
iqilu .
.
.
100k .
.
.
jetour traveller .
.
.
1m .
.
.
.
komorebi memo .
.
5m photo editor pro .
.
.
.
10m .
.
.
line webtoon .
.
.
100m .
.
.
car scanner .
.
.
10m .
.
.
.
picsart studio .
.
.
1b .
.
.
pleco .
.
.
5m .
.
.
.
music speed .
.0b5 .
10m .
.
news .
.
.
900m .
.
.
.
mangasuki .5d .
100k .
.
.
wechat .
.
.
100m .
.
.
.
china daily .
.
.
1m .
.
skyeye .
.
.
100m .
.
uc browser .
.
.
800m .
.
.
weather .
.
.
1m .
lazycook .
.
.
50m .
.
.
zillow map .
.
.
10m .
.
.
.
faceapp .
.
.
500m .
.
raise to answer .
.
100k .
.
multinotes .
.
5m .
.
landroid .
.
500k .
.
.
socksdroid .
.
.
500k .
.
anymemo .
.
.
100k .
.
lumii .
.
50m .
.
.
motolog .
.
.
100k .
.
.
zarchiver .
.
.
100m .
.
tunein .
.
.
100m .
.
.
.
loklok .
.
.
5m .
.
.
wordpress .
.
10m .
.
.
.
k mail .
.
5m .
.
myexpense .
.
.
1m .
.
.
.
bilibili .
.
.
800k .
.
.
.
average .
.9m .
.
.
.
necessarily indicate significant precision flaws in ep detector.
on the one hand the intersecting influences and extraneous factors are difficult to completely eliminated during app execution.
on the other hand the trade off raised by parameters belongs to the inherent challenge in the bug detection tasks and we have mitigated the performance degradation through various techniques such as grid search in vi.
summary ep detector shows a high effectiveness in epa detection with an average precision of .
.
the factors that constrain the precision include intersecting influences parameter settings andwork extraneous impacts .
b. completeness the completeness is evaluated from two perspectives the coverage of page state and the detection false positive .
coverage of page state to evaluate the coverage of page state we compared ep detector with two widely used dynamic gui testing tools stoat and ape.
stoat simulates user device interactions by constructing a random finite state machine model of the apps with both static and dynamic analysis.
ape is a dynamic gui testing framework employing decision tree to represent dynamic page states.
metric.
thecoverage of page state is measured by the ratio of the explored page states to the total ones.
note that toalleviate navigation redundancy the page states with psim are treated as the same page state.
benchmark.
when stoat and ape were used to test the benchmarks some apps frequently crashed or stopped midway might be raised by the incompatibility to the android version .
to ensure fair comparison we conducted an in depth analysis of 10apps that are fully tested on both frameworks.
ep detector ape stoat102030405060708090100 a coverage of page state ep detector ape stoat0510152025 b average number of page states ep detector ape stoat fig.
.
comparison of page coverage.
results.
as illustrated in figure a the coverage performance of ep detector is slightly better than the other two methods which achieves an average coverage rate of .
surpassing ape s .
and stoat s .
.
through manual confirmation there are valid page states in total detailed in table iii where ep detector detects 61of them averaging .1page states per app illustrated in figure b .
to ensure the effectiveness of the simulated operations epdetector neither employs tree based abstraction like ape nor uses a dynamic static hybrid method like stoat.
instead epdetector employs a novel approach through comprehensive widget navigation and fine grained similarity calculations to achieve promising page coverage during the simulation of error prone operations.
we also carefully analyzed the page states that were not navigated primarily due to two reasons first some page states require to be triggered by events that are difficult to simulate such as password authentication and qr code input.
second dynamic widgets e.g.
ad widgets that vary in each round of visiting significantly disturb the page navigation occasionally making target pages unreachable.
summary ep detector achieves an average coverage rate of60.
surpassing ape s .
and stoat s .
.
the failed page navigation mainly attributes to specific events anddynamic widgets .
false negative due to the absence of dedicated detection work and complete ground truth for epas directly identifying false negatives of the ep detector outcomes is challenging.
to alleviate this evaluation challenge we investigate a widely used industry product google accessibility scanner which partially overlaps with ep detector in detecting epas.
the accessibility scanner evaluates widgets from three perspectives color contrast labeling for guidance and touch size.
the detection results for the benchmark of 10apps is depicted in figure .
ep detector identified 417confirmed epas whereas accessibility scanner detected anomalies with 156aepas being identified by both tools.
unlike ep detector as ep010203040506070number of epas google translate21 as ep0102030405060number of epas google earth3258 as ep05101520number of epas komorebi memo21 as ep0246810121416number of epas qr as ep0102030405060708090number of epas gcamator7583 as ep0246810number of epas raise to answer310 as ep0102030405060number of epas everydoggy56 as ep051015202530number of epas socksdroid1128 as ep020406080number of epas landroid90 as ep0102030405060number of epas car launcher57 by ep by as by bothfig.
.
result comparison between accessibility scanner and ep detector.
accessibility scanner detects epas solely through static analysis of widget attributes e.g.
android background android layout andandroid text .
for that reason it hardly detects the bepas confirmed and eepas confirmed which requires dynamic operation simulation.
as to the area related anomalies the accessibility scanner reports significantly more results vs. than ep detector especially for the typical two apps car launcher andqr.
except for the anomalies raised by the color contrast and label hint the accessibility scanner checks touch sizerelated anomalies where 18of them cannot be checked by ep detector.
from further analysis the touch sizes of out of the detected widgets are indeed smaller than the standard but there are no other widgets within their safe areas which are unlikely to cause error operations.
the remaining anomalies are identified as the false negatives of ep detector.
through careful analysis the overlooked epas are raised by the invalid simulated operations under the slow network and laggy system.
summary ep detector reports significantly more confirmed epas than accessibility scanner in detecting typical apps but still have 4aepa false negatives due to invalid simulation.
c. efficiency to assess the efficiency of ep detector we have recorded the time consumption details during the detection of 53apps illustrated in table iv.
on average each app costs about .
hours which is acceptable for offline testing compared to existing dynamic testing works .
the efficiency is significantly influenced by the number of pages and widgets.
for example wechat spends the longest detection time with .4hours attributed to its substantial page states and widgets.
for detailed analysis among the modules and stages of ep detector the target navigation is the most timeconsuming module accounting for .
of the total time.
this is primarily due to the bfs based navigation which initiates numerous restarts from the original page iv a .
despite optimizations implemented including simulating reverse transition and building trace recorder the time consumption for this part remains substantial.table iv average efficiency of ep d etector in epa d etection .
app hr page min widgets min navigation hr oracle hr exec hr .
.
.
.
.
.
a positions of o2t and video acceleration widgets.
b animation prompt by video acceleration event.
c animation prompt by o2t event.
fig.
.
aepas caused by one click triple interaction and video acceleration.
summary the efficiency of the ep detector is overall acceptable for offline detection with .3hours per app and24.8minutes per page.
however the time overhead of specific apps may be significant due to complex app design.
d. severity from table iii ep detector on average detects .91confirmed epas for each app with one epa identified for every two widgets .
the aepas are the least prevalent in the apps with only .04per app and .87per page while bepas are the most common ones with an average of .94per app and3.91per page.
apps with simple page layouts like qr weather typically have few less than epas which aligns with intuitive expectations.
on the contrary apps like alipay andwechat have a high prevalence of epas more than200 due to their integration of hundreds of services and numerous widgets for navigating to other services.
upon further analysis of the potential consequences of these epas we discovered that some operations could directly pose security threats e.g.
undesirably clicking a payment button while others might only affect user experience e.g.
mistakenly opening an unwanted page.
figure illustrates a security related aepa from bilibili detected by epdetector.
the functionalities of one click for triple hit o2t and video acceleration are designed to be triggered by the longclick event on two small buttons with overlapped safe area illustrated by the grey dot and red frame in figure a .
this unsuitable layout could result in unintended acceleration figure b or an irreversible loss of bilibili coins against one s will figure c .
this inspires us to further explore the types and distribution of the consequences triggered by epas.
by an in depth study on the detected epas we conclude 5categories of potential harmful consequences security sec functionality fun advertising adv efficiency eff anduser experience use .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
sec .
fun .
adv .
eff .
use .
productivity .
e commerce .
utility .
streaming media .
image .
iot .
system tools .
reading .
payment .
.
.
.
.
.
.300cscore fig.
.
relation between consequences app categories.
combined with the categories of apps we compute a finegrained proportion named cscore i j defined as eq.
to indicate the distribution across different types of consequences.
cscore i j nijp i cset j asetnij where nijdenotes the number of the epas in the i th consequence type and j th app category cset andaset denote the set of consequence types and app categories respectively.
the overall distribution is illustrated in figure .
it can be observed that the cscore of serious consequence categories sec12.
and fun .
are smaller compared to others but the total counts of these categories and832 are significant.
although these consequences are only potentially triggered they deserve the attention of both developers and users.
we provide related suggestions in the following section.
we can also observe that the payment apps e.g.
alipay bankcomm andwechat exhibit a higher prevalence with security consequence accounting for .
among app categories.
interestingly ep detector didn t discover any epa with advertising consequence in the productivity apps but detected many such epas in system tools .
by careful analysis the advertising consequence tends to be triggered by unintended operations on simplified page with singular functionality.
the system tools provide many such scenarios such as battery testing file management and network monitoring.
summary epas are significantly prevalent in current realworld apps an average of .91per app with nearly one epa for every two widgets and their number increases with the complexity of the app pages.
the epas capable of causing security and functionality consequences are in the minority .
but their total counts and832 are considerable.
vii.
t hreats to validity detection efficiency.
both widget navigation and simulated operations employed in ep detector are time consuming.
although optimization strategies like page level abstraction behaviour grouping for bepa and simplified operations for aepa eepa have been applied detecting a single page still costs .6minutes on average.
dozens of hours are spent on detecting large size real world apps e.g wechat with238pages.
exploring efficient navigation for example using static analysis could scale up the approach as a future improvement.
failed pages.
due to delays in page rendering and interruptions from advertising a small number of pages and their event traces cannot be recorded into the recorder leading to failed detection of these pages.
a potential future improvement is to set a failed checker to detect the page failure and mark the triggering traces for further investigation.
customized behaviours.
customized third party systems and specific apps are not supported in the current version of ep detector due to their rare emergence in practical use.
to support them a way is to add a detection dispatcher compatible to the customized behaviours according to the attributes of the target system and app.
viii.
r elated work a. gui test in android the event driven nature of android apps increases the complexity of its execution routines making gui based dynamic testing a challenging task.
traditional gui based testing approaches tend to simulate user operations and system events using frameworks provided by android e.g.
monkey and its variants to achieve enhanced testing accuracy and optimized performance.
to further improve the test coverage and expose more crashing bugs model based gui testing is proposed to exhaustively explore the the execution paths through abstracting the app behaviours guided by a model and enforcing various user system interactions.
subsequently non crashing functional bugs stemming from execution logic errors have received increasing research attention as they significantly affect user experience .
the functional bugs are triggered in rare program paths which is difficult to capture using the traditional test models.
hence fine grained attribute targeted test tactic such as metamorphic fuzzing and state differential analysis are employed to generate task oriented test inputs.
the epas in this work are anomalies rooted from both crashes and functionality logic errors.
the widget centric navigation is inspired by the existing attribute targeted exploration.
b. oracle for android testing dynamic app testing necessitates automated test oracle to explore and confirm the test results efficiently.
the test oracle must be adaptable to different testing goals.
for instance to detect security vulnerabilities the oracle often compares the test results with given fingerprint features of the ground truth in benchmarks.
to detect crash bugs the oracle monitors the sharp changes of the device status and evaluates them with a given threshold.
the detection of non crashing functional bugs commonly needs to perceive the gap between the page under test and the expected page requiring the oracle to compare page elements or attributes.
for vision related page checking the oracle usually employs straightforward visual comparison between screenshots of critical execution points .
these worksmaintain independent gui scripts for the identification of testing targets.
the epa detection is a novel testing problem involving collecting page widgets and monitoring of device environment.
therefore the test oracle in the ep detector integrates multiple comparison strategies targeting at attributes of page widgets and resource status of devices.
ix.
c onclusion this work systematically studies three types of error prone operation anomalies epas in android applications.
using dynamic gui detection and automatic monitoring an automated detection tool ep detector is developed to facilitate the study of epas which utilizes multiple optimization strategies and epa oriented detection designs.
using ep detector error prone operations are detected in 53commonly used realworld android apps illustrating the prevalence and severity of the epas.
as future work we plan to integrate the static analysis to alleviate the heavy time consumption and support a wider range of operations such as special operations provided by third party systems.
in addition we aim to conduct in depth study on the pages that fail the detection to further enhance the ep detector s practicability.
acknowledgment the authors would like to thank the anonymous reviewers for their valuable feed back.
this work was supported in part by the natural science foundation of tianjin of china grant no.
23jcybjc00320 21jczdjc00740 science and technology project of haihe lab of itai grant xchr20230701 the national natural science foundation of china grant no.
and the open fund of anhui province key laboratory of cyberspace security situation awareness and evaluation grant no.
cssae .