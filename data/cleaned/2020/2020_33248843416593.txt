continuous compliance martin kellogg1 martin sch f2serdar tasiran2michael d. ernst1 1university of washington2amazon web services usa kelloggm cs.washington.edu schaef amazon.com tasirans amazon.com mernst cs.washington.edu abstract vendorswhowishtoprovidesoftwareorservicestolargecorporationsandgovernmentsmustoftenobtainnumerouscertificates of compliance.
each certificateasserts that the software satisfies a complianceregime likesocorthepcidss toprotecttheprivacy and security of sensitive data.
the industry standard for obtaining a compliance certificate is an auditor manually auditing source code.thisapproachisexpensive error prone partial andprone to regressions.
wepropose continuouscompliance toguaranteethatthecodebase stays compliant on each code change using lightweight verificationtools.continuouscomplianceincreasesassuranceandreduces costs.
continuous compliance is applicable to any source code compliance requirement.
to illustrate our approach we built verification tools for five common audit controls related to data security cryptographically unsafe algorithms must not be used keys must be at least256bitslong credentialsmustnotbehard codedintoprogram text https must always be used instead of http and cloud data stores must not be world readable.
we evaluated our approach in three ways.
we applied our toolstoover5millionlinesofopen sourcesoftware.
wecompared our tools to other publicly available tools for detecting misusesofencryptiononapreviously publishedbenchmark finding thatonlyoursaresuitableforcontinuouscompliance.
wedeployed a continuous compliance process at aws a large cloudservices company we integrated verification tools into the complianceprocess includingauditorsacceptingtheiroutputasevidence and ran them on over million lines of code.
our tools and the data for the former two evaluations are publicly available.
ccs concepts software and its engineering software verification automated static analysis data types and structures.
keywords compliance soc pcidss fedramp keylength encryption hardcoded credentials pluggable type systems some of the work was performed while this author was an intern at aws.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
ase september virtual event australia copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
reference format martinkellogg martinsch f serdartasiran andmichaeld.ernst.
.
continuous compliance.
in 35th ieee acm international conference on automatedsoftwareengineering ase september21 virtual event australia.
acm new york ny usa pages.
.
introduction a compliance regime like the pci dss fedramp or soc encodes a set of best practices.
for example all of these regimes require that data be stored encrypted and that the encryption used be strong.
manyorganizationsarerequiredbylaw bycontract orbyindustry standard to only use software that is compliant with one or more regime.
for example visa requires companies that process credit card transactions tousesoftwarethatiscompliantwiththepcidss payment card industry data security standard .
pci dss certification assures card issuers that merchants will safely handle consumer credit card data .
other card issuers have similar requirements andsomeu.s.statesdefinenon compliance asatype ofcorporatenegligenceforwhich companies canbe sued .
the u.s. government requires that cloud vendors be compliant with fedramp federal risk and authorization management program .
manycustomersofsoftwareprovidersexpectasoc system andorganizationcontrols report whichisusedtoevaluate how seriously potential vendors take security .
when making a purchasing decision an organization with compliance requirements typically requests an up to date compliance certificate from an accredited third party auditor also known as a qualified security assessor qsa .
acomplianceregimeismadeupofmany requirements.foreach requirement theqsaimposessome control aspecificrule usually defined by industry standard and a process for enforcing that rule.
for example a qsa might impose the control use bit mode aes for the requirement use strong encryption.
a compliance regime may also make requirements about the processused to create or run the software such as what data is logged or which employees have access to data.
this paper focuses on requirements about the source code.
continuous compliance automates checking of these compliance requirements.
.
problems with manual audits currently the enforcement of source code controls is primarilymanual employees of the auditor examine selected parts of the softwaretoensureitfollowseachcontrol.thestateoftheartsuffers the following problems 35th ieee acm international conference on automated software engineering ase costto sell its product a vendor must participate in audits often multiple times per year to show continuing adherence to thecomplianceregime.thevendormustpaythesalaryofits internal compliance officers spend engineering time gathering evidence and pay external auditors often at significant and rising expense more than .
million each for a sample of organizations in .
a failed audit can cost millions of dollars more .
judgment humanscanmakemistakesofjudgment.engineers may provide non compliant code for audit which may lead to expensivefailedaudits.auditorsmayincorrectlycertifynoncompliantcode falsenegatives.auditorsmayraiseconcerns about safe code false positives that must be investigated at further expense.
sampling auditors routinely sample randomly from the code underaudit becauseitistooexpensivetomanuallyexamineit all.
the standard reporting format for a pci dss audit includes a section dedicated to sampling procedures .
regressions audits occur periodically typically every six or twelvemonths.everycodechange isachance forthesoftwaretofall outof compliance.
ina studybyverizon saudit division only52.
oforganizationswithanactivecompliancecertification passed their re audit without significant changes .
ourgoalistoreducecosts increaseassuranceandcoverage and prevent regressions by deploying lightweight verification tools.
.
our approach continuous compliance wepropose continuouscompliance whichrunsaverificationtool on every commit to check compliance properties in source code.
moreformally continuouscomplianceistheprocessofautomatically enforcing source code compliance controls whenever the code is changed such as on every compiler invocation commit or pullrequest.continuouscomplianceisaninstanceofcontinuous testing and continuous integration .
continuouscomplianceeliminatestheneedformanualaudits for specific source code controls resolving the problems described insection1.
.themarginalcostofanauditisnegligible because auditors accept the results of running the verifier.
the opportu nity for mistakes is smaller our tools found dozens of findingsof interest to compliance auditors that all prior approaches hadmissed because the verifier checks the entire codebase.
regressions are caught immediately when they occur when it is cheaper fordeveloperstofixthem .evenifcontinuouscomplianceis implemented only for some source code controls it reduces the scope of manual audits and makes them easier cheaper and more reliable.
implementingasystemforcontinuouscomplianceischallenging.
tobeacceptabletoauditors developers andcomplianceofficers the continuous compliance system must be sound it must not miss defects.
if it might suffer a false negative missedalarm thenamanualauditwouldstillberequired.
applicable to legacy source code.
scalable to real world codebases.
simplesothatbothdevelopersandnon technicalauditorscan understand it and interpret its output.
preciseenough to produce few time wasting false alarms.
.
contributions there are four main contributions of our work aconceptual contribution therecognitionthatsource codecomplianceisanexcellentdomainforthestrengthsandweaknesses of some varieties of formal verification.
anengineering contribution we designed and built five practicalverificationtoolscorrespondingtocommoncompliance controls.
anempirical contribution weevaluatedtheverificationtools efficacyon654open sourceprojects.wealsocomparedthem to state of the art alternatives to demonstrate that only verificationtoolsaresuitableforcontinuouscompliance unsound bug finding tools are insufficient.
anexperiential contribution wedeployedcontinuouscompliance at amazon web services aws .
we report the reactions of developers and auditors to the introduction of continuous compliance.webelievethatthiscontributionisthemostimportant itisaconcretesteptowardmakingverificationpractical for everyday developers.
ourkeyconceptualcontributionisrecognizingthebenefitsof verification tools tocompliance auditors.
the ideas werenot obvioustocomplianceofficersandauditors.thestateofthepracticeis manualcodeexamination andthestateoftheartisrun timechecking.
research roadmaps for improving the certification process do not even mention source code verification .
the ideas were not obvious to working developers.
they believed that formal verification would require high annotation burden and would produce many false positive warnings.
the ideas were not obvious totheverificationcommunity whohavefocusedonprogrammers or modelers rather than other important stakeholders such as compliance auditors.
ourengineeringcontributionsaremodestbutnon trivial.we implementedfiveopen sourceverificationtoolsforjava.thefive compliance controls are common to many compliance regimes encryptionkeys mustbesufficiently long insecurecryptographic algorithmsmustnotbeused sourcecodemustnotcontainhardcoded credentials outbound connections must use https andcloud data stores must not be world readable.
we implemented our analyses as typecheckers because typecheckers scale well and are more familiar to developers than other automated verification approaches such as abstract interpretation model checking and smt based analysis.
ourempiricalcontributionsapplythesetoolsto654open source projects section6 andcomparethemtostate of the arttoolsfor findingmisusesofcryptographicapisonapreviously published benchmark with a focus on their suitability for continuous compliance section .
only our tools suffered no false negatives that is they did not miss any real problems.
our experiential contribution is deploying a continuous compliance systemat scale ataws as partof its regulardevelopment process.
currently of its core services with a compliance requirementrunverificationtoolsoneachcommit ensuringcontinuous compliance.
external auditors accepted our verification tools asreplacements for manual audits for these services section .
.
both developers andcompliance teams are nowmore receptive to formal methods than they were before both aws and the auditors 512figure a sample of evidence that the nitor vault program only uses bit keys to encrypt data in its source code.
havespokenpubliclyonhowverificationhasimprovedtheirprocess .
security and compliance teams also run verifiers on a significant fraction of code at the company on a regular schedule themostrecentrun section8.
scannedover68millionlinesof code and required only type annotations.
compliancecertificationworkflow section2.1describesthestate of the artapproachforcompliance certification of source code properties and section .
describes ourcontinuouscomplianceapproach.eachsubsectionhighlights three key phases of the workflow for comparison development of the source code preparation for an audit and reviewby auditors.
asarunningexample considertheindustrycompliancestandard for aes encryption which is to use the bit mode.
this rule corresponds to testing procedure .
.
.b in the pci dss .
.
traditional audit workflow while developers developsoftware they must keep in mind the compliancerulesandmentallychecktheircodeastheywriteit.because compliance failures are very serious significant code review effort is also expended toward keeping the codebase compliant.
toprepare for the review an internal compliance officer requestsevidencethat the program uses bit keys.
each engineeringteammusttaketimetorespondtothisrequest.typically the developers search the codebase for encryption keys api usages and related code.
the evidence they provide is screenshots like fig.
or links into their codebase.
atthetimeofthe review thehumanauditorrandomlysamples thesecodesnippetsandcheckstheselectedsnippetsmanually.ifthe auditor has a concern about the code they contact the engineering teamresponsibleandquestionthemaboutthecode.iftheengineers are unable to satisfy the auditor then the auditor refuses to certify compliance.thisprocessisdependentontheauditor sjudgment and trust in the engineering teams the auditor only examines a small part of the code directly.
.
auditworkflowwithcontinuouscompliance while developers develop software they write and maintain lightweight machine checked specifications of its behavior.
in a case studyataws thesespecificationsconsistedof9annotationsacross 628linesofcode section8.
.
.theverificationtoolrunson everycommitand optionally everytimethedevelopercompiles the code.
if the tool issues a warning the developer examines it.
if the warning is a true positive that is the code is incorrect the developerfixesthecode.ifthewarningisafalsepositive thedeveloper suppresses the warning and writes a brief explanation as acipher cipher cipher.getinstance aes ecb pkcs5padding cipher.init cipher.encrypt mode mysecretkey return cipher.dofinal message figure code example for encrypting a message.
a common compliance requirement is that the algorithm name that is passed to cipher.getinstance must be fips compliant .
code comment which creates an easily searchable audit trail in the code.suppressingawarningwasnecessaryonlyonceinover68 million lines of source code at aws see section .
no action is needed to preparefor a review.
at the time of the review the auditor rejects the code if the verification tool outputs any warnings.
if developers suppressed any warnings the auditor inspects the code near the suppressed warning theyareautomaticallysearchable .theauditorcanalso check the implementation of the verification tool which is very short changesrarely andispubliclyavailable.inourexperience auditors are willing to accept that the tool is part of the trusted computing base in much the same way that they do not inspect the compiler.
continuous compliance controls we have implemented verification tools for the following controls.
.
cryptographic key length the pci dss and other compliance regimes require strong encryptionkeystobeused.inpractice acontrolusedforthisrequirement is that encryption keys must be sufficiently long.
our analysis handles key generation libraries.
for javax.crypto.spec asecretkeyspec objectmaybeconstructed using a length parameter since it is specified in bytes or a byte array that is at least bytes long.
for java.security.securerandom the nextbytes byte methodmust bepassedanarrayofatleast32bytes and next int mustbepassed an integer .
both methods are often used to generate keys.
for org.bouncycastle.crypto e v e r y keygenerationparameters object must be constructed with a strengthargument that is .
foraws skeymanagementservice kms adatakeymust be at least bits long.
a client sets the size of the generated data key by calling methods on a key request object call withnumberofbytes int with a value or call withdatakeyspec string with the string aes 256 o r call withdatakeyspec datakeyspec with datakeyspec.aes 256. .
cryptographic algorithms another common requirement in compliance regimes is the use ofstrong cryptographic algorithms .
figure shows a use of encryptioninjava.acompliancecontrolforthiscodeisthatthe string passed into the jce method cipher.getinstance must be on an allow list from the compliance regime .
awshadpreviouslywrittenalexicalanalysistovalidateuses ofcryptographicapis butitwasnotsufficient.infigs.1and2 a literal is the argument to a key generation routine but this was rarely the case at aws whose default style guide suggests the use of static final fields.
these fields are not necessarily in the same classasthemethodcall andthevaluescanbeheldinvariablesand 513passed around the program.
another failed attempt at aws was to searchforallstringliteralsintheprogramandrejecttheprogramif anyliteralstringwasnotonthecomplianceallowlist.thissufferedtoomanyfalsepositivesthatrequiredhumanexamination because differentalgorithmsarepermittedfordifferentuses.theseissues motivated the need for a semantic analysis like ours.
.
web requests pcidssrequirement4.
mandatesthatcommunicationacross opennetworksbeencrypted othercomplianceregimeshavesimilarrequirements.acommoncontrolfortheserequirementsisthatweb requests be made over https rather than over http.
in practice thiscontrolissatisfiedinjavacodebycheckingthatstringspassed to the url constructor start with https .
a syntactic check is insufficient aurlmightbeconstructedbyconcatenatingseveral variables or might be stored in a field far from its use.
.
cloud data store initialization data subject to compliance requirements is sometimes stored inthe cloud.
even if the cloud provider has the appropriate compliance certification there are often additional controls on how cloud services are used.
for example third party guidelines for hipaa compliant use of amazon s3 a popular object storage service include new buckets must not be and cannot become world readable new buckets must be encrypted and newbucketsareversioned sothatdataisnotlostifoverwritten.
enforcingtheseguidelinesrequirescheckingthatthecorrespondingsettermethodsofthebuilderusedtoconstructthebucketare called and that their arguments are certain constant values.
.
hard coded credentials credentials passwords cryptographickeys etc.
mustnotbehardcodedinsourcecode.thepcidsshasanentiresection devoted to requirements on passwords .
hard coded credentials violate several of these requirements that passwords must be unreadable duringstorageandtransmission .
.
andthatcredentialsnot be shared between multiple users .
.
our analysis handles these apis inthe java.security package securerandom mustnotbeinitialized withahard codedseed.
keystore sstoreand loadmethodsmust not use a hard coded password.
in the javax.crypto.spec package these must not be hard coded secretkeyspec skeyparameter pbekeyspec spasswordparameter pbeparameterspec ssaltparameter and ivparameterspec sivparameter.
.
other controls ourvisionforcontinuouscompliance thatis automatedchecking of source code compliance properties is broad.
the above are just afewexamplesofcontrolsthatcanbeenforcedusingcontinuous compliance.webelievethatanycompliancerequirementcurrently controlled by manual audits of source code could be automated using our proposed approach of lightweight verification tools.
theaudit procedure is designed to be tractable for a human unfamiliarwiththesourcecode sothepropertytobecheckedisusually simple and local which both make it likelier to be amenable to programanalysis.twofurtherexamplesthatwehaveprototyped arethatdatamustbeencryptedatrest thatis whenstoredondisk as opposed to in ram and data must be protected by a checksum.
the procedure to implement a new analysis which we followed fortheabove is talktotheauditors findachecktheycurrently enforce with manual code audits then formalize and implement it.
technical approach in order to satisfy the requirements of section .
we designed dataflow analyses to perform verification.
.
dataflow analysis via typechecking wechosetoimplementeachanalysisasatypesystem.thecontinuouscomplianceapproachcanbeinstantiatedwithotherautomated verification techniques such as abstract interpretation or symbolic execution.
we chose type checking because it was already familiar to the java developers at aws.
type checking is also modular fast and scalable.
pluggable type checking is sound and the proof extendsdirectlytoallthetypesystemsinthispaper proofsomitted for space .
our implementation uses the checker framework a framework for building pluggable typecheckers for java.
our implementation handles all java features including polymorphism.
it per forms local type inference within a method body so developers write annotations only at method boundaries where they serve as machine checked documentation.
aswithanytypesystem everyassignmenttoavariablemust be from an expression whose type is a subtype of the variable sdeclared type.
for example when a formal parameter type has a qualifier itisatypeerrorifanycallsite sargumentdoesnotsatisfy the given property.
.
an enhanced constant value analysis our analysis needs to estimate for each expression in the program whether the expression s value is any of the following single integer value.
single string value.
setsofvalues.forexample anexpressionmightbeknownat compiletimetoevaluatetooneofthestrings aes cbc pkcs5padding aeswrap o r rsa ecb oaeppadding .
integer ranges including unbounded ones.
estimates of array lengths and sets of them.
user defined enumerated types and sets of them.
regular expressions to represent sets of strings and sets of regular expressions so users do not need to write disjunctions within regexes.
a traditional constant propagation and folding analysis handlesthefirsttwofeatures.weuseanenhancedconstantfoldingandintervalanalysisthathandlesthethirdandfourthfeatures .
weuseanarrayindexinganalysisthathandlesthefifthfeature .
we made numerous bug fixes and enhancements to the existing tools to improve precision.
we designed and implemented the last two features sections .
and .
.
514table1 examplesofannotationsfrom thatareusedbyourverificationtool.allannotationargumentsarecompile timeconstants.
declaration meaning intval int x xhas exactly the value stringval a b string s s has the value a or b intrange from to int x x s value is in the range byte arraylen a acontains exactly elements ourimplementationexpressesabstractvaluesastypes.forexample intval is a type qualifier and the type intval int represents an integer whose run time value is either or equivalently itrepresentstheset .table1showsthemost important abstractions of the constant value analysis.
our type systems use and or extend these abstractions.
the type hierarchy appears in our extensions fit in naturally.
.
enums tohandleenums werepurposedtheexistinghandlingofstrings the stringval annotation .
our implementation treats the enum name as the string value.
this implementation approach re uses existing logic without the need for code duplication.
.
regular expressions we added anewabstraction matchesregex that expresses apossiblyinfinite set of strings via a set of regular expressions.
for example class cipher static cipher getinstance matchesregex aes gcm.
rsa ecb.
string algorithm thetypeofthe algorithmparameteris matchesregex ... string and it restricts the values that may be passed as arguments.
subtypingforregularexpressiontypesisahardproblem.subsumption for regular expressions is exptime complete .
standard butnotregular featuressuchasbackreferencesmakeeven regexmatching np hard .
precise subtyping for regular expressiontypes isasleastashardastheseproblems.however we need a fast decidable algorithm that is understandable to developers.ourimplementationimposesthefollowingsound approximate subtyping relationship s1ands2are sets of regular expressions s1 s2 matchesregex s1 string matchesregex s2 string this approximation was always adequate in our case studies.
atypequalified by stringval canbea subtypeofonequalified by matchesregex skis a string and rkis a regular expression i j si.matches rj stringval s1 ... sm string matchesregex r1 ... rn string no other types are subtypes of matchesregex ... string .
if another typeflowstoanexpressionwithsuchatype includingstringvalues not in the allow list the tool issues a warning.
.
type inference we implemented a whole program type inference tool that inferstypesviafixpointanalysis.thecheckerframeworkimplements local intra method type inference.
the type inference tool repeatedly runs a type checker records the results of local type inference and appliesthem to the next iteration.
theannotations are stored in a side file to avoid changing programmers source code.
when a fixed point is reached the user is shown the final results of type checking.
for example consider the following program int id int y return y i n tx id x ... typeinferenceonthepossibleintegervaluesinthisprogramwould produce three intval annotations one on the field x because 1is assigned to x one on the parameter y because idis called with xas an argument and oneonthereturnvalueof id becausethereturnvalueflows from the parameter to annotate the above program our type inference approach would take three rounds one for each of the required annotations because each is dependent on the previous one.
note that this type inferenceapproachissound becauseitstillrunstheverifieronthe annotatedcode ithasthesameinterfacetotheverifierasahumanannotator.bythesametoken inferencecanwriteoverly restrictive types as in the example above id s parameter and return type are annotated as intval but a human would have instead written a polymorphic specification .
type inference is useful to auditors who otherwise would be illequipped to reason about source code.
it also enables type systems whoseannotationburdenwouldbeimpracticalforahuman see section .
.
verifying compliance controls this section details the verification tools we built to verify that java programs are compliant with the controls in section .
our framingoftheproblemmadeitsimpletoexpressandimplement the dataflow analyses.
.
cryptographic key length our key length typechecker is just an application of our enhanced constant value analysis.
anyanalysisrequiresaspecificationoflibraryapis.thisonetime manual process is performed by a verification engineer work ingwithacomplianceofficer.oncewritten thespecificationcanbere useduntilthelibraryinterfacechanges whichishighlyunlikely or the compliance regime is updated which is rare .
figure is the full specification for the kms api.
when these restrictions on all uses of the api are enforced at compile time no datakeycanbegeneratedthatissmallerthan256bits meetingthe compliancecontrolinsection3.
.thespecificationsfortheother libraries of section .
are similar but simpler fig.
is the largest.
515package com.amazonaws.services.kms.model class generatedatakeyrequest withkeyspec stringval aes 256 string keyspec withkeyspec stringval aes 256 datakeyspec keyspec withnumberofbytes intrange from integer numberofbytes setkeyspec stringval aes 256 string keyspec setkeyspec stringval aes 256 datakeyspec keyspec setnumberofbytes intrange from integer numberofbytes class generatedatakeywithoutplaintextrequest withkeyspec stringval aes 256 string keyspec withkeyspec stringval aes 256 datakeyspec keyspec withnumberofbytes intrange from integer numberofbytes setkeyspec stringval aes 256 string keyspec setkeyspec stringval aes 256 datakeyspec keyspec setnumberofbytes intrange from integer numberofbytes figure3 ourfullspecificationforawskms.theselibraryannotations guarantee that the keys kms generates are bits or more.
.
cryptographic algorithms ourcryptographicalgorithmtypecheckerisimplementedontop of the enhanced constant value analysis.
weannotatedlibrarymethodsthatacceptcryptographicalgorithmsasinput suchas javax.crypto.cipher orjava.security.signature with an allow list of accepted algorithm names.
for user convenience our tool defines cryptoallowed as an alias for matchesregex .
cryptoallowed behaves identically but makes it clear to readers that the code is cryptographically relevant.
ourtoolhasaliasesofparticular cryptoallowed annotationsfor eachcomplianceregime.
cryptoallowedpci forexample corresponds totherequirementsofthepcidss.eachaliasisdefinedonce bya cryptography expert and a compliance officer together.
a welcome side effect of centrally defined allow listing annotations is that adjusting the analysis to changes in compliance requirements is easy the regular expressions in the allow list can be updated without changing any program source code not even type annotations.
.
web requests ourwebrequesttypecheckerisasimpleextensiontoconstantvalue analysisthatintroducesanewannotation.
startswith x issyntacticsugarfor matchesregex x.
.forexample startswith matches but not foo or .
.
cloud data store initialization to prove that a new amazon s3 bucket is properly initialized two kinds of facts are necessary setter methods for the required properties on the bucketor bucketprops builder object must have been called and the arguments to the setter methods must be certain constants.
forexample toshowthatabucketisversioned the versioned boolean method must be called and its argument must be true.
fortheformer ouranalysismusttrackthesetofmethodsthat havedefinitelybeencalledonthebuilderobject andcheckthatthe required methods are all included in the set when buildis called.
an accumulationanalysis arestricted form of typestateanalysis thatdoesnotrequireawhole programaliasanalysisforsoundness can verify that all required methods are called on a builder.weusedtheimplementationfrom andwrotespecifications for bucketand bucketprops .
our enhanced constant value analysis handles the latter.
.
hard coded credentials we implemented a dataflow analysis similar to taint tracking to track the flow of manifest literals through the program.
thesources in our taint analysis are manifest literals in the program text strings like abcd integerslike bytearrays like 0xa 0x1 etc.
.thesinksarecallstotheapisinsection3.
.thetypechecker enforces that manifest literals do not flow to the sinks.
our type system has two type qualifiers maybederivedfromconstant is the type of any manifest literal and of any expression into which a manifest literal might flow.
for example abcd and x 1have this type.
nonconstant is the type of any other expression in the program.
it is the default qualifier meaning that an unannotated type like stringactually means nonconstant string .
nonconstant isasubtypeof maybederivedfromconstant .thismeansthat a program may assign a non constant value to a variable whose type is qualified with maybederivedfromconstant but not vice versa.
.
.
using whole program type inference.
thistaint trackingtype system requires substantially more user written annotations than theprecedingconstant propagationtypesystems becausemany variables and values in programs are derived from constants.
ingeneral typeinferencefortaint trackingisdifficult becausea humanmustfirstlocateallthesourcesandallthesinks.inourcase however thesourcescanbeidentifiedautomatically manifestliter alsintheprogram andthesinksareknownaheadoftime theapis listed in section .
.
the inference tool section .
can therefore determinewhethereachprogramelementmighthavebeenderived from a constant without the need for human intervention that is all required annotations can be derived automatically.
casestudyonopen sourcesoftware to permit reproduction we open sourced our tools and applied them to open source software.
the scripts and dataused for sections and are available at zenodo.
.
.
methodology for each api mentioned in section we searched github for projects that contain at least one use of the relevant api.
we used all projects for which running a standard maven or gradle build task mvn compile orgradle compilejava intherootdirectorysucceeds under either java or java .
running our tool requires supplying a processor argument to each invocation of javac.
we augmented do like javac for that purpose.
it first runs the build system in debug mode and scans thelogsforinvocationsof javac.then itreplaysthoseinvocations with the processor command line argument added in the same environment for example after other build steps that compilation may depend on.
sometimes replaying the build is not success ful this is reported as infrastructure error in table .
the most 516table2 ourverificationtools runonopen sourceprojectsthatuse relevant apis.
ver is verified projects.
tp is projects with true positives but no false positives.
t fp is projects with both true andfalse positives.
fp is projects with false positives but no true posi tives.
ie is infrastructure errors projects on which do like javacfails.
to is timeouts hour limit .
total is the total number of projects.theloccolumnomitsinfrastructureerrorsandtimeouts.
throughout loc is non comment non blank lines of java code.
api ver tp t fp fp ie to total loc key length 373k crypto.
algos.
.4m web request 6k cloud data 5k credentials .0m total .7m common reasons are that the project s custom build logic is not idempotent therearenoobservablejavaccommands ortheproject uses javac options that are incompatible with the processor flag.
tofullyautomatetheprocess weranallverifierswithwholeprogram inference section .
enabled.
we set a timeout of one hour.
our verifiers are fast but inference might not terminate.
our typecheckerscontainwideningop eratorstoprev entinfiniteascending chains but do not contain corresponding narrowing operators.
insomecases inferencethereforeintroducesaninfinitedescending chain leading to a timeout.
wemanuallyinspectedeachwarningissuedbyeachverifier and classified it as a true positive a failure to conform to a compliance requirement or a false positive a warning issued by the tool that doesnotcorrespondtoacomplianceviolation .wecountedcrashes and bugs in the checker framework as false positives.
.
findings table shows the results.
the key takeaways of our study were muchopen sourcesoftware initsdefaultconfiguration contains compliance violations.
compliance officers should review open source software before it handles customer data.
mostwarningsweretruepositives.amajorattractionofunsound bug finding tools is that they tend to have low falsepositiverates butoursoundverificationtoolsdoreasonably well seesection7foradirectcomparisontobug findingtools .
themajority offalsepositivesareissuedbythecredentials checker.therelativelyhighrateoffalsepositivesfromthischecker is due to the limitations of the type inference tool section .
itcannotalwaysinfertheappropriatetypequalifiersfortypear guments java generics .
any time it is incorrect the credentials checker issues a false positive.
.
example compliance violations figure shows two examples of compliance violations a anhsm hardwaresecuritymodule simulator usesthe desencryptionalgorithm.anhsmisaphysicaldeviceused for managing encryption keys.
practical brute force attacks against des were public knowledge as early as .if scommand.contains s secretkey sk w key vnn new secretkeyspec b w key vnn des ... a an example use of an insecure encryption algorithm.
private static final string key j8m2gnzbvkavx7c2a94g ...byte keybytes key.getbytes utf messagedigest sha messagedigest.getinstance sha keybytes sha.digest keybytes secretkeyspec secretkeyspec new secretkeyspec keybytes aes b an example use of a hard coded key.
figure example compliance violations our checkers found.
b acommand lineemailclient usesahard codedkey.the secretkeyspec thus generated is used to encrypt user passwords a major security risk.
the maintainers of these projects might not consider these compliance violations to be bugs because they might not care about whethertheirprojectsareusableincontextsthatrequirecompliancecertification suchaseducation healthcare commerce orgovernment work.
however if theseprojects were to be used in such contexts each compliance violation would be a serious concern.
comparison to other tools we compared our tool to previous tools for preventing misuse of cryptographic apis.
previous tools do not warn about short keylengthsormisuseofcloudapis soourevaluationfocuseson selectingcryptographicalgorithms hard codedcredentials andthe useofhttpvs.https.thedevelopersofcryptoguard have developedamicrobenchmarksetofmisusesofcryptography which they call cryptoapibench .
their paper evaluates cryptoguard against spotbugs coverity and cognicrypt sast.
we repeated theirexperiments andextendedthemtoincludeourverification tools forthesubsetoftheirevaluationthatourtoolscover categories of cryptographic misuse .
we evaluated on two versions ofthebenchmark theoriginalandaversionwhoselabelingofsafe and unsafe code reflects compliance rules.
.
tools compared wecomparedourverifiertofourstate of the arttoolsthatdetect misuses of cryptographic apis.
spotbugs isthesuccessoroffindbugs aheuristic based staticanalysistoolthatusesbugpatterns.somebugpatterns relatetocryptography.itisheavilyusedinindustry.weused two versions of spotbugs configured differently the standard desktop version .
.
spotbugsd and version .
.
configured with the ruleset from the swamp which contains additionalsecuritybugpatterns spotbugss .forbothversions we only enabled warnings in the securitycategory.
coverity isacommercialbug findingtool.weusedcoverity s free trial in april for the experiments in this section.
they provided no version number.
cognicrypt sast is a tool that checks user written specifications in the custom crysl language consisting of typestate 517table comparison of tools for finding misuses of cryptographic apis on relevant parts of cryptoapibench.
spot spot cover cogni crypto this bugsdbugssity crypt guard paper original labeling precision .
.
.
.
.
recall .
.
.
.
.
.
compliance labeling precision .
.
.
.
.
recall .
.
.
.
.
.
properties required predicates forbidden methods and constraints on method parameters using synchronized push down systems.
we used crysl version .
.
for these experiments with the included jca rules.
cryptoguard isabug findingtoolaugmentedwithaslicing algorithm to allow it find more bugs.
its design emphasizes maintainingalowfalsepositiveratewhilescalingtorealistic programs.
we built cryptoguard from source code .
thesetoolsweredesignedtopreventmisuseofcryptography1 not tosupportthecompliancecertificationprocess.thesetwogoalsare related both aim to reduce the number and cost of vulnerabilities that occur in the wild but lead to different design choices bug finding tools like the above four tools aim for low false positive rates high precision or high confidence that eachreported warning is useful even at the cost of false negatives unsoundness .bycontrast automatedcompliance requires verification no false negatives.
given an unsound tool thecodewouldstillneedtobeauditedbyhandincasethe tool missed an error.
put another way auditors prefer sound approaches over manual examination and they prefer manual examination over unsound tools.
compliancerequirementscanbestrongerthantypicaldeveloper guidelines.
for example section .
describes the compliance requirement to use a bit key.
none of the above tools implementsthischeck so toavoiddisadvantagingthosetools we did not use it in our comparison.
.
results table3showstheresultsofthecomparison.precisionandrecall are defined identically to cryptoapibench .
our numbers differ from slightlybecauseweusednewerversionsofthetools.only our verifier achieves recall the other tools are unsound.
fromacomplianceperspective cryptoapibenchmisclassifies some unsafe code as safe cryptoapibench labels unsafe calls in unexecuted code similar to fig.
as safe.
cryptoapibench s insecure asymmetric encryption requirement allows any rsa algorithm so long as the key is not 1024bits.
our compliance controls also specify the padding scheme becausetherearepublishedattacksagainstthedefaultpadding scheme used by java .
cryptoapibench labels calls to cipher.getinstance rsa that use the default padding as safe.
1the tools also have other capabilities but our evaluation focuses on this aspect of their functionality.public secretkey getkmskey final int keylength generatedatakeyrequest request new generatedatakeyrequest if keylength request.withkeyspec datakeyspec.aes 128 else request.withkeyspec datakeyspec.aes 256 set other parameters...generatedatakeyresponse response awskms.generatedatakey request ... figure5 codefromaservicewithacodepaththatcouldhavebeen used to generate a bit key.
the compliancelabeling intable3reclassifiesthesecallstoreflect compliance rules.
overall the results show the promise of sound approaches to detecting and preventing program errors such as misuses of cryptography with high precision while maintaining soundness.
case studies at aws we performed two case studies at amazon web services aws .
inthefirstcasestudy 7teamswithacompliancerequirement ran the key length verifier section .
on each commit.
if the verifier fails to prove compliance their continuous delivery process is blocked.thiscasestudyshowsthattheverifierisrobustenough tobedeployedinarealisticsetting andthatdevelopersandcomplianceofficers seeenough valuein ittoopt intoa verification tool that could block deployment.
in a second case study we ran both the key length verifier and the cryptographic algorithm verifier as part of large scale security scanning infrastructure.
this second case study shows that both verifiers can be easily integrated in an automated system and that they produce high quality findings.
.
continuous delivery case study this case study investigates whether a compliance officers care about the output of our verifier and b developers accept a verification tool as part of their continuous integration.
some key findings of this case study were theverifierreportsnowarningsonanyofthecoreawsservices that were subject to compliance requirements.
old manual audit workflows missed compliance relevant code.
using verification tools saved time and effort for developers.
developers who were initially skeptical of formal verification technology were convinced of its value by our tool s ease of use and effectiveness.
.
.
results.
the key length verifier was easy to use.
developers had to write only type qualifiers in lines of code stringval annotations intvalannotations and intrangeannotations.thetoolissuedonly1warningthatthecomplianceofficersdidnotconsideratruepositive.thiswasaneasydecisionforthem the code was manifestly not compliance related.
we determined thatitwascausedbythecheckerframework soverly conservative polymorphic that is java generics type inference algorithm .
whilerunningtheverifiers developersfoundseveralservices that were compliant but error prone or confusing.
as one example 518consider the code in fig.
.
this code can generate a bit key but its clients never cause it to do so.
a developer verified thisfact by changing the type of the keylengthparameter from intto intval int and runningour verification tool.it verifiedevery client codebase proving that the keylength codepath is not used.
without a verification tool like ours that can run on each commit the presence of such code paths even if unused is danger ous adevelopermightchangeclientcode orwritenewclientcode withoutconsideringthecompliancerequirement.ourtoolallows developers to discover unsafe code paths and also to be certain that they are not being used when they are discovered.
atthe timeofwriting thecontinuousintegration jobhasrun times and has issued a warning times each of which was quickly fixed.
the small number of failures is probably because most developers run it on their local machines before committing.
we do not know how many of those local runs have revealed a problem with the code.
another discovery while typechecking was that four services hadprovidedincompleteevidencetoauditors theevidencedidnot cover every part of their codebase that generated encryption keys.
developers explained that they had not realized that those parts of thecodewerecompliance relevant.bycontrast ourverifierchecks allofthecode.theexternalauditorswereparticularlyexcitedby this finding one said that it eliminates a lot of the trust that auditorspreviouslyneededtohaveinengineeringteamstoprovide them with complete evidence.
externalauditorswereexcitedtobeonthecuttingedgeofautomation for compliance they can advertise as providing higher assurancethanotherauditors andtheircostsgodown.theaws internal compliance officers can continuously monitor compliance via continuous integration jobs triggered on every commit.
aws encourages its customers and providers of third party services to use these tools .
.
.
developers reactions.
we began rolling out our verification tools to compliance relevant services at aws in september .
tooursurprise weencounteredlittleresistanceaswebeganthe rollout the first team we contacted immediately integrated the key lengthverifierandenableditintheircontinuousintegration process andthencanceledthemeetingwehadscheduledwiththem.
theseearly adoptingdeveloperstoldusthattheywerefrustrated bycompliance songoingcost gatheringevidenceisanirritating distraction from their regular work.
other engineering teams are also convinced.
each team saves time by not having to prepare for audits.
one developer told us thecheckerframeworksolutionisagreatmechanismandstep toward automating audit evidence requests.
this has saved myteam hours every months and we also don t have to worryabout failing an audit control.
the hour savings is per team percontrol forthedevelopersalone.
theeffortofonboardinga projecttouseaverificationtoolislessthantheengineeringcostofprovidingevidencefortheveryfirstaudit nottomentionsavingstocomplianceofficersandtheexternalauditor.afterthat thesavings accumulate.
2they set up a second ci service so that compliance is monitored even if the engineering team were to disable the verifier in their ci setup.table running the key length and crypto algorithm verifiers at aws.
the key length verifier is only run on packages that use the specific library routine.
the crypto algorithm verifier is run on a subset of all java code at aws.
key length crypto algorithms verified no annotations packages packages verified annotations packages packages true positive warning packages packagesfalse positive warning package packages total packages packages loc loc .
scanning at scale case study inthesecondcasestudy asecurityteamrantwoofourverifiers key length and crypto algorithms sections .
and .
on code beyondwhatneedstobeaudited.thiscasestudydemonstratesthat our approach requires few developer written annotations and that warningsoftenrevealinterestingissues.ourverifiersareintegrated into a system that scans a set of highly used packages on a fixed schedule.findingsofthesescansarereportedtosecurityengineers and triaged manually.the security team is interested in analyzers that report security related findings that can be triaged without in depthcodeknowledge andthathaveasignal to noiseratiothat is manageable by a security engineer.
table categorizes each package into one of four categories verified no annotations the verifier completed successfully without any manually written annotations.
if subject to a compliance regime these codebases would be verifiable withoutany human onboarding effort.
verified annotations the verifier initially issued an error on these codebases.
after writing one or more type annotations in the codebase theverifiersucceeds.ifsubjecttoacomplianceregime theseprojectswouldbeverifiable withhumanonboardingeffort.in cases once in each of packages the call to a key generation library was wrapped by another method a developer had to write one annotation to specify each wrapper method.
because typecheckingisintraprocedural anannotationmustbeplacedwhere relevantdataflowscrossprocedureboundariesorentertheheap.
thetypecheckerissuesawarningifaneededannotationismissing.
thus developers canuse thetoolto identifythese locations.note thatdeveloper writtenannotationsarechecked nottrusted.the only trusted annotations are those for libraries e.g.
fig.
.
true positive the verifier issued an error that corresponds to a compliance violation if that codebase were to be subjected to acomplianceaudit.thekeylengthverifierfound15instancesof code that used bit keys.
the crypto algorithm verifier found uses of weak or outdated crypto algorithms.
aws s internal complianceofficersconfirmedthatnoneofthesecodebaseswere actually subject to audits.
all true positives were examined by a security engineer to ensure that the findings were correct and that no production code was affected.
the crypto algorithm verifier received positive feedback from security engineers since it is easy to configure and outperformed an existing text based check that was running in the scanning infrastructure.
519false positive the verifier issued an error indicating that it cannot prove a property.
manual examination determined that the code never misbehaves at run time but for a reason that is beyond the capabilities of the verification tool.
the key length verifier reported false positive the keylength was hard coded correctly butwasloadedviadependencyinjection whichourverifierdoes not precisely model.
we computed the compile time overhead of using our tools.
we randomly sampled projects using the key length verifier and projectsusingthecryptographicalgorithmverifierfromthosein table .
we recorded their run time with and without our tools.
on average our tools increased the full compile time for the project from to seconds .
.
as part of a continuous integration workflow developers found this overhead acceptable.
threats to validity our verification tools check only some properties a program they approve might fail unrelated compliance controls or might contain otherbugs.itdoesnotchecknativecode andaverifiedprogram maybelinkedwithunverifiedlibraries.ithasmodesthatadoptunsoundnessesfromjava suchascovariantarraysubtypingandtype arguments in casts.
like any implementation it may contain bugs.
oursampleprogramsmaynotberepresentative.wemitigated this threat by considering over million lines of code from a variety of projects but it is all java code.
lessons learned verification is a good fit for compliance.
a key contribution of this work is the observation that source code compliance is a good targetforverification.existingcompliancecontrolsareinformalspecifications that are already being checked by humans.
these properties are relatively simple.
yet the domain is mission critical.
though researchers have struggled to make verification appealing todevelopers wehavediscoveredanothercustomerforverification technology compliance auditors.
because controls are designed to be checked by a human unfamiliar with the source code most are amenable to verification.
therearetwopropertiesofcompliancecontrolsthatmakethem more verification friendly the controls are usually local so that a human can check them quickly.
the controls are usually simple so that a human without indepth knowledge of the code can check them.
both of these properties make it more likely that a given control can be automated.
we believe that any compliance property that is currently checked by manual examination of source code can be automated.
does someone else ever have to read the code?
compliance certificationisanexampleofa codereading task someoneotherthanthe developerexaminesthecodetocheckforaspecificproperty.other codereadingtasksarealsoamenabletoautomation.forexample checkingtheformattingofcodeisanothercodereadingtaskwhich has already been automated.using verification tools changes developer attitudes.
this work hashadasignificanteffectinchangingattitudestowardverifica tion.
developers and compliance officers started out skeptical of formalmethods butnowtheyareenthusiastic.equallyimportantly developers on teams notsubject to compliance requirements are observing their peers using verification.
the adoption of new technologyisfundamentallyasocialprocess andsocialpressureis an important factor influencing whether security tools are adopted bypractitioners .webelievethatsimple scalabletechniques are both a research contribution and the best way to widely disseminate formal verification.
we encourage other researchers who areinterestedinimpacttodeploytheirtoolsinwaysthatreduce developers workload by eliminating existing tasks that developers must perform regularly.
verificationcansavetimefordevelopers.
whendevelopersconsiderusingverificationtechnologiesinisolation theymusttrade offdevelopertime towriteannotations runtheverificationtool etc.
against improved software quality.
the developers we worked with at aws are busy and some were initially skeptical of verification.
they believed that a formal verification tool would have two serious costs3 developerswouldhavetospendalotoftimeannotatingthe codebase before seeing benefits from the tool.
the verification tool would issue false positives that would waste engineering time to investigate then rewrite the code or the annotations.
thesefears were grounded inexperience withformal verification toolslikeopenjml thataredesignedtoprovecomplexproperties.becausedevelopersmustalreadydotheworktocertifytheir software as compliant they found the introduction ofverification toautomatethat taskawelcomechange.rather thanverification becoming an extra task for them verification replacedan existing unpleasant task.
we encourage other verification researchers interested in impact in practice to use verification to replace existing tasks developers must perform.
moveothernon testingtasktocontinuousintegration.
inmuchthe samewaythatcontinuousintegrationimprovessoftwarequality byrunningtestsmorefrequently continuouscomplianceincreases the confidence of auditors that compliance is maintained between audits.webelievethatresearchersshouldexplorewhetherthereareothersoftware adjacenttasksthatcanbemovedintothecontinuous integrationworkflow aswehavedoneforcomplianceusingour verification tools.
verification is useful for stakeholders other than programmers.
compliance auditors are a non traditional customer of verification technology.
nevertheless we found that auditors readily accepted verification and that it fit well into their workflow.
compliance like verification is concerned with soundness the cost of a failed auditisastronomical especiallyforacompanylikeawswithmany customers who must remain compliant themselves.
this similarity inthinkingandgoalsbetweencomplianceandverificationmade our success possible.
we encourage other verification research 3thedeveloperswere notconcernedaboutcodeclutter theywereusedtothebenefits of annotations from using tools like lombok guice and spring.
520interestedin impactinpractice toinvestigateother stakeholdersin the correctness of software besides the developers themselves.
related work practitionersandresearchersrecognizethecurrentlimitationsof manual compliance audits and they are actively seeking improvements.
we classify previous work into manual approaches testing run time checking and static analysis.
manual.theindustry standardapproachtocode levelcomplianceismanualexamination.therehasbeensomeworkonimproving the current manual audit approach by simplifying the software inspection process .
by contrast our approach aims toreplace parts of the manual process with an automated one.
testing.mostpreviousresearchonsource codelevelcompliance hasaimed toapplyautomated orsemi automatedtesting .automatedtestsreducecostsandpreventmistakesmade while manually executing the tests but not those in designing and implementingthetests .however testsarestillincomplete tests can show the presence of defects but not their absence.
e commerce merchants who must be compliant with the pci dss can use an approved scanning vendor asv to automatically certify that their websites meet some parts of the pci dss.
recent work hasshownthatextantasvsareunsoundandmis certify many vulnerable websites in practice.
further most merchant websites have one or more must fix vulnerability showing the need for sound verification tools like ours.
run time checking.
a recent approach is proactive compliance which is analogous to run time checking.
even if run time checks are exhaustive and correct a violation causes the program to crash.
researchinthisareaaimstoimproverun timeperformanceand retain interoperability with uninstrumented code .
staticanalysis.toourknowledge ourworkisthefirsttouseautomated sound static analysis lightweight verification for sourcecode compliance properties like those described in section .
arecentliteraturereviewsplitcomplianceautomationintothree categories retroactive i.e.
log scanning intercept and check i.e.
atruntime checkoperationsforcompliance andproactive which theydescribeaslikeintercept and check butwithsomeprecomputationtoreducethe run time burden .theydonotmention soundverification.ullahetal.describeaframeworkforbuildingan automatedcloudsecuritycompliancetool .theirframework does not include sound static analysis perse but does have a place forasvs whichtheyregardasbest effortbugfinders.recentwork ondesigningacloudservicewhichcouldbecontinuouslycompliant did not consider using a verification tool to achieve that goal .
formal methods like process modeling have been applied to compliance problems especially in safety critical domains such as railway andautomotivesystems .thecompasproject isacollectionofformalapproachestobusinessprocessmodeling appliedtocompliance.kokashandarbabmodeledprocessesinthe reo language and analyzed them for compliance .
tran et al.
developed a framework for expressing compliance requirements in a service oriented architecture .
these approaches are complementary to ours.
they check properties about a process or about a modelof thesystem but theygiveno guarantees aboutits source code or its implementation.thereisawealthofspecificationandverificationworkthatis notrelatedtocompliancerequirements.pavlovaetal.developed a technique for inferring jml annotations that encode security policies of javacard applets .
their approach utilizes the jack proof assistant so it is neither automated nor usable by workaday programmersorauditors.furthermore thesecuritypoliciesthey checkdonotoverlapwiththerequirementsofcomplianceregimes.
our work assumes cooperation between a developer and an auditor.
a similar assumption is made by the sparta toolkit for statically verifying that android apps did not contain malicious information flows which posits a hypothetical high assurance app store.
we address a differentdomain compliance and we report on wide scale real world usage.
analyzing uses of cryptography apis.
most or more java applications that use cryptography misuseit and most securityvulnerabilitiesrelatedtocryptographyareduetoimproper usageofcryptographicapis .cognicrypt sast isatechniquebasedonsynchronizedpush downsystemsforfindingunsafe usesofcryptographyapis.cryptoguard isaheuristic based tool based on program slicing for finding unsafe uses of cryptography apis.
we compare to both in section .
conclusion complianceis anexcellentdomainto showthatverification tools are ready for real world deployment to solve real world problems especiallytodeveloperswhomightotherwisebeskepticalofthe value of verification.
lightweight verification tools like typecheckers are a good fit for compliance they provide much higher assurance than either manual audits or unsound bug finding tools atlower cost.
sound verifiers can be narrowly scoped to individualproperties like compliance controls.
this makes them simple to design andimplement.
it alsomaintains a lowannotation burden making them as easy to use as unsound bug finding tools.
ourexperienceshowsthatverificationscalestoindustrialsoftware at aws and that the business derived significant value from ourefforts.aslongasverificationautomatesworktheyarealready developers are enthusiastic about adopting it.
we look forward to a future in which verification technology is widespread bothforcomplianceandforcorrectness.ourtools running in production at aws for a large cohort of real developers saving them time and effort are a step towards that goal.