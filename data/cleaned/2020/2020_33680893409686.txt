ubitect aprecise and scalable methodto detect use b efore initializationbugsinlinuxkernel yizhuozhai yzhai003 ucr.edu uc riverside usayu hao yhao016 ucr.edu uc riverside usahang zhang hang cs.ucr.edu uc riverside usa daimeng wang dwang030 ucr.edu uc riverside usachengyusong csong cs.ucr.edu uc riverside usazhiyun qian zhiyunq cs.ucr.edu uc riverside usa mohsen lesani lesani cs.ucr.edu uc riverside usasrikanth v.krishnamurthy krish cs.ucr.edu uc riverside usapaul yu paul.l.yu.civ mail.mil u.s. armyresearchlaboratory usa abstract use before initialization ubi bugs in the linux kernel have serioussecurityimpacts suchasinformationleakageandprivilege escalation.
developers are adopting forced initialization to cope with ubi bugs but this approach can still lead to undefined behaviors e.g.
nullpointer dereference .
asit is hardto infer correct initializationvalues webelievethatthebestwaytomitigateubi bugs is detection and manual patching.
precise detection of ubi bugsrequirespath sensitiveanalysis.thedetectorneedstotrack anassociatedvariable sinitializationstatusalongallthepossible program execution paths to its uses.
however such exhaustive analysis prevents the detection from scaling to the whole linux kernel.
this paper presents ubitect a ubi bug finding tool which combines flow sensitive type qualifier analysis and symbolic execution to perform precise and scalable ubi bug detection.
the scalable qualifier analysis guides symbolic execution to analyze variablesthatarelikelytocauseubibugs.
ubitect alsodoesnot require manualeffort forannotations and hence it can be directly applied to the kernel without any source code or intermediate representation ir change.onthelinuxkernelversion4.
ubitect reported bugs among which bugs were deemed by us as true positives and52 were confirmedbylinux maintainers.
ccs concepts security and privacy operating systems security systemssecurity.
esec fse november 8 13 virtual event usa copyright held by the owner author s .
acm isbn .
use before initialization bug detection type qualifier symbolic execution acmreference format yizhuo zhai yuhao hang zhang daimeng wang chengyu song zhiyun qian mohsenlesani srikanthv.krishnamurthy andpaulyu.
.ubitect apreciseandscalablemethodtodetectuse before initializationbugs in linux kernel.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november8 13 virtualevent usa.
acm new york ny usa 12pages.
introduction linux kernels provide a secure foundation upon which services for user applications can be built.
however security vulnerabilities existing inside kernel code violate the security guarantees thatitintendstoprovide.amongsuchvulnerabilities use beforeinitialization ubi is an emerging threat.
a recent report from a microsoft security team shows that the number of patched ubi bugsissimilartothenumberofpatcheduse after freebugs .
ubi bugs open up significant security threats against the operating system they could enable attackers to take control over the entire system leaksensitive information and can be exploitedusing automatedmeans .
bothstaticanalysisanddynamicanalysishavebeenappliedto detect ubi bugs.
modern compilers provide the wuninitialized optiontofacilitatethedetectionofubibugsatcompiletime.unfortunately duetoitslimitedanalysisscope i.e.
intra procedural this cannot detect ubi bugs that involve multiple functions.
in practice manyubibugsdooccurinter procedurally.forexample objects can be allocated in one function initialized in another function and used in a third function.
static symbolic execution like that in clang static analyzer csa can perform more accurate analysis but due to the path explosion its ability to perform intermoduleholisticprogramanalysisislimited.dynamicanalysisused in memorysanitizer andkmemcheck canalso detectubi 221this work is licensed under a creative commons attribution international .
license.
esec fse november8 virtualevent usa y. zhai y. hao h.zhang d. wang c.song z.qian m. lesani s.v.
krishnamurthy p. yu bugs but their limited code coverage means that they will miss manybugs.
zeroing the allocated object is a popular mitigation strategy for ubibugs.forexample pax s stackleak plugin forcestheinitialization of kernel stacks during context switches between the kernel and user space.
unisan forces the initialization of memory objects that may be uninitialized and may leave the kernel space e.g.
copy to user .
safeinit does so for all stack and heap variables.
however we point out that forced initialization can only be used to mitigate information leaks but not other types of ubi bugs.
the reason is that the value 0used for initialization may violate a program s semantics and lead to undefined behaviors.
for instance initializing a pointer to nullis sufficient towards preventinginformationleaks butdereferencinga null pointerresultsin a different type of vulnerability viz.
cwe which is not desirable in os kernels .
for normal data a few patches we submitted were also rejected due to incorrect initializationvalues.
based on this observation we conclude that a better way to mitigate ubi bugs is to warn developers and let them decide upon the correct initializationvalues.
there are two particular challenges for reporting ubi bugs to developers.first thelinuxkernelhasabout27.8millionlinesof codeandso theanalysismustbe scalable.
second mostubibugs arepath sensitive meaning that they can only be triggered if there is a feasible path between the allocation site and the use site along whichtheinvolvedvariablewillnotbeinitialized.becauseofthese ubi bugs are uniquely challenging to comprehensively discover and require inter procedural path sensitive analysis.
we are not aware ofany such analysisscalingto the wholekernel.
flow sensitive static analysis and symbolic execution are two state of artsolutionsthatcanhelptowardsdiscoveringubi bugs.
our evaluations show that the former method scales well but generates too many warnings to inspect manually.
moreover there are lots of false positives in those warnings.
symbolic execution reports fewer false positives but suffers from pathexplosion.
inthiswork weseektoaddresstheaforementionedtwochallenges anddesignatoolsuitableforreportingubibugsformanual inspection and fixing.
to this end we have developed ubitect a tool that combines flow sensitive type qualifier inference and symbolicexecutiontofindubibugsinthelinuxkernel.inthefirst stage ubitect uses a soundy flow sensitive field sensitive andcontext sensitiveinter proceduralanalysistofindpotentialubi bugs.foreachpotentialbug thisstepalsogeneratesaguidancefor path exploration so as to avoid paths that will never reach the use site or paths that will initialize the involved variable.
in the second stage ubitect uses under constrained symbolic execution to find a feasible path according to the guidance.
if a path is found ubitect will report the bug together with the corresponding path to make the manual inspection andfixeasier.
weperformathoroughevaluationof ubitect onlinuxv4.14underallyesconfig whichincludes16 163fileswith616 893functions.
ubitect reported bugs among which bugs were deemed by usas truepositives yielding a falsepositive rate of59 .among truepositives wefoundthatthecorrespondingcodeof9bugshave been removed from the mainline kernel due to feature updates and 11bugswerealreadyfixedinthemainline.wesubmittedpatches fortheremaining58bugsand37wereconfirmedandappliedby1 file drivers crypto mv cesa.c uninteresting code lines are omitted 4typedef void crypto completion t 5structcrypto async request req interr 7structcrypto async request 8crypto completion t complete 11staticintqueue manag void data backlog is defined without initialization 14structcrypto async request backlog 15if cpg eng st engine idle backlog crypto get backlog cpg queue 17if backlog uninitialized pointer dereferenced!
backlog complete backlog einprogress 20return0 figure a ubi bug in the linux kernel.
variable backlogis not initialized if cpg eng st !
en ine idle .
it allows arbitrary code execution once an attacker exploits the bug to controlthevalue left on the kernelstack.
kernelmaintainers.inaddition basedonthesebugs weapplysome intuitive heuristics and uncover more bugs thereby confirming bugsintotal.
details are providedin section .
contributions inthispaper ourcontributionsareasfollows design.wedesign ubitect whichcombinesscalabletypequalifier inference with symbolic execution to perform scalable and precisedetectionofuse before initializationbugsinthelinux kernel.
implementation.
we implement ubitect on the llvm .
.
compiler toolchain and klee with loc.
the tool is open sourced .
results.
ubitect found78bugsinthev4.14linuxkernel where were already fixed and were confirmed by linux maintainers.
use before initialization bugs in thissection we highlightthe severityof ubi bugsandthe challengesindetection.
.
from ubito arbitrarycodeexecution the firstexample isa bug thatwas found inthe queue manag function simplifiedin figure1 andpatchedinrevision 1a92b2b.the rootcauseforthisbugisthatthepointer backlog line14 isonly initialized line16 when cpg eng st engine idle .
although this case is simple it highlights the severity of the securityimpactofubibugs.thevariable backlogbelongstothetype structure crypto async request which contains a function pointer complete line8 .when backlogisleftuninitialized itcouldpointto an arbitrary memory location depending on what value was stored 222ubitect a preciseandscalablemethodto detectuse before initialization bugsin linuxkernel esec fse november8 virtualevent usa atthataddress backlog before and backlog complete couldalso point to arbitrary code.
since backlogis allocated on the kernel stack by utilizing stack spray an attacker can control backlog andthus thefunctionpointer backlog complete .consequently whenthisfunctionisinvokedatline19 theattackercanachieve arbitrary code execution.
in addition to control flow hijacking attacks an attacker can also launch arbitrary reads and writes by overlapping attackercontrolleddatawithuninitializedpointers e.g.
cve .
moreover ifacriticaldecisionvariable e.g.
authenticated isuninitialized anattackercanbypasssecuritychecksandinduceother unexpected control flows.
a subsequent research effort has shown thatsuchattacksarepracticalandcanbeconstructedinanautomatedmanner .
.
challenges in detecting ubibugs the key challenge in detecting ubi bugs is the need for highprecision analysis to reduce false positives which can conflict withour goalofscaling upthe analysis to the entire linux kernel.
figure2depictsagoodexample function vmw translate mob ptr takes three input arguments and an output argument vmw bo p which is supposed to be initialized at line .
under normal circumstances i.e.
the lookup succeeds vmw bo p will be initialized.
however when the callee enters an error related return path line vmw bo p isleft unchanged.
needforinter proceduralanalysis.
aconservativeintra procedural analysis can require that all the variables must be initialized at all levels e.g.
both the pointer and the data the pointer points to when passed to a callee.
however since the callee may not access all input arguments e.g.
when an error is returned at line thisrequirement is too restrictive and will generate too many false positives.
therefore an inter procedural analysis is necessary.
moreover since vmw bo p isleft unchangeduponan errorreturn whether the actual argument is uninitialized or initialized depends onthecallingcontext i.e.
whetherthecallerhasalreadyinitialized it .hence acontext sensitiveinter proceduralanalysisispreferable.similarly sincethecalleemaynotaccessallthefieldsofan argument e.g.
sw context performing a field sensitive analysis is preferable.
needs for path sensitive analysis.
another interesting part of thisexampleisthatthelocalvariable vmw bo isnotinitializedat first line10 andmaynotbeinitializedifthecalltothefunction vmw user dmabuf lookup fails line12 .
however since vmw translate mob ptr checksthereturnvaluetodetecttheerror line the uninitialized value will not reach a use line .
thus in essence having a data flow between where the variable is uninitialized and used is a necessary condition for ubi bugs but is not sufficient i.e.
the corresponding execution path must be feasible .unfortunately nopath sensitiveanalysis e.g.
dynamic analysis canscaletocoverallthepathsinthekernel.asapractical compromise ubitect uses under constrained symbolicexecution to verifythe feasibilityofapotentialbuggy path.
file drivers gpu drm vmwgfx vmwgfx execbuf.c uninteresting code lines are omitted 4staticintvmw translate mob ptr structvmw private dev priv structvmw sw context sw context svgamobid id structvmw dma buffer vmw bo p 10structvmw dma buffer vmw bo null 11uint32 t handle id 12intret vmw user dmabuf lookup sw context fp tfile handle vmw bo 14if unlikely ret !
return einval vmw bo p vmw bo 17return0 figure an inter procedural ubi bug in the linux kernel.
argument vmw bo p may remain uninitialized during error return.
figure3 theworkflowof ubitect qi qualifierinference qr qualifier requirements qu qualifier updates overview inthissection weshowhow ubitect combinestypequalifierinferenceandsymbolicexecutiontodetectubibugs.
figure3illustrates theworkflowof ubitect andwewillexplaineachcomponentin the following content.
the design of the type inference will be presentedmore formally in subsection .
.
.
pre processing tomaketheanalysiseasier ubitect firstcompileslinuxsource code to its llvm intermediate representation ir .
to improve the scalability of the type inference ubitect adopts the bottom up style inter procedural analysis.
to support the bottom up style analysis the second step is to build the call graph of the whole code base so as to resolve indirect call targets build the dependency tree between caller and callee s and find potential recursive chains.
223esec fse november8 virtualevent usa y. zhai y. hao h.zhang d. wang c.song z.qian m. lesani s.v.
krishnamurthy p. yu .
typequalifierinference type qualifiers have been used in previous works to detect securitybugs.forexample johnsonandwagner introducedtwo qualifiers kernelanduserto trackthe provenance ofpointers i.e.
whether their values are controlled by user space and find unsafe dereferences of user supplied pointers.
in this work we adopt the flow sensitive type qualifier inference to detectubibugs.
from a high level we introduce two new qualifiers initand uninit whereinit uninit i.e.
initisasubtypeof uninit anddefines the subtype relations between qualified types e.g.
init int uninit int .
besides the trivial check that an expression of uninit cannotbeassignedtoalocationof init ubitect addsadditional checks assertions to detectuse ofinitializedvariables onlyexpressionsof inittype can be dereferenced and only expressions of inittype can be used in conditional branches.
ubitect onlyconsidersthosetwoassertionsthatcaptureubi bugswithsecurityimplicationshereandignoreothertypesofuses ofsuchvariables.forexample addingtwouninitializedvariables reflectsan uninitializedusage but isnot security critical.
sincetheirgeneratedbythecompilerdoesnotcontainanyqualifier ubitect performsautomated inference toassignaqualifierfor every variable at every program point within a function including its argument s and return value s .
if ubitect can successfully infer all the qualifiers then the analyzed function is free of ubi bugs.otherwisewefindpotentialubibug s andthecorresponding guidance will be generated andpassed to ubitect s symbolicexecutionengine.we will firstexplain how ubitect infersqualifiers within a function and generates function summaries then we will describe howinter proceduralqualifier inference works.
intra proceduralqualifierinference.
theintra proceduralqualifier inference is done as follows.
ubitect assigns each expression llvmvalue withasymbolictype .
alongdifferenttypes of expressions ubitect generates subtyping constraints accordingtorulesin subsection4.
.
whenencounteringthesecurity critical operations listed above ubitect enforces that the corresponding expression has the concrete qualifier init.
ubitect resolvesthesymbolictypesintoconcretequalifiedtypesbysolving the constraints.
takeaa splitn fqname infigure as an example.
at the entry of the function line ns nameandns lenare assigned with two symbolic types 1const char 3 and 4size t 5 .
because ns name andns len in basic block bb 7are dereferenced as pointers the qualifier of the pointer should be init.ubitect can then resolve their qualified types at least to be uninit const char uninit init initialized pointer to uninitializedpointer to uninitializedconstant char and uninit size t init initializedpointer to uninitializedinteger .
functionsummariesgenerations.
afterintra proceduralqualifierinference ubitect generatesfunctionsummaries fs forevery function.
each function summary includes qualifier requirements qr over theinputarguments for thetarget functionto be invoked without triggering ubi bugs qualifier updates qu for inandoutparameters and qualifier ofthe return value.
here we continue using aa splitn fqname as an example and focus on how we generate qr and qu for the input argumentsns nameandns len.
let us assume that the actual argument types are 1const char init and 4size t init where iis symbolic i.e.
eitherinitoruninit .byassigningtheconstantinteger to ns name line and ns len line their qualified types will be updated to 1const char init init andinit size t init .
however when the control flow merges at basic block 8before returning becausethesetwovariablesarenotwritten tointheother branch when name null the updates to the qualifier when aa splitn fqname returnswill be decidedby the least upperbound of 2andinit i.e.
2 init as well as 4andinit.
toenablecontext sensitiveinter proceduralanalysis wekeep 2and 4assymbolicas updatestotheparameters inthefunction summary and calculate the actual updates according to the calling context.
inter proceduralqualifier inference.
after we derive the summary of aa splitn fqname we can proceedto analyze aa fqlookupn profile .
the arguments ns name and ns len pointtomemoryobjectsallocatedonthestackandthus the qualifiedtypesare uninit char uninit init anduninit size t init .
their qualified types are compatible with the qr generated above.
after invocation according to the qu their types remain the same because when 2 uninit uninit init uninit.
when processing the ifstatement on line ubitect enforces that the expression used as the branch condition has a qualifier init.
however in aa fqlookupn profile thissubtypingconstraint cannot be satisfied because the qualified type of ns name is uninit char uninit .
due to this conflict the inference module outputsapotentialubibugonline22 bb ofaa fqlookupn profile .
guidance for symbolic execution.
tomitigatethepathexplosionproblem ubitect generatesaguidanceforthesymbolicexecution engine se .
the guidance includes an avoidlist and a mustlist of basic blocks.
a basic block is inserted into the avoidlist when the involved variable is initialized or the basic blocks can never leadtotheusesite.abasicblockisinsertedintothemustlistwhen the involved variable becomes uninitialized or the uninitializedvariable isused.for the ubibugdetectedabove ubitect passes se a avoidlist containing 7where the variable is initialized andamustlistcontaining 3where ubihappens.
.
symbolic execution aftergettingtheguidance ubitect usesunderconstrainedsymbolicexecutiontosearchforafeasiblepath i.e.
whosesymbolic pathconstraintscanbesatisfied fromtheallocationsite i.e.
the entryof aa fqlookupn profile totheproblematicusesite while avoiding .ifafeasiblepathisfound e.g.
bb ubitect outputs areport for manual inspection togetherwiththe path.
4ubitect design this section describes the design details of ubitect including points to and aliasing analysis the formalization of the type inference andthe symbolic executionengine.
.
points to andaliasinganalysis asaprecursortoflow sensitivequalifierinference ubitect performsaflow sensitiveandfield sensitiveintra proceduralpoints to 224ubitect a preciseandscalablemethodto detectuse before initialization bugsin linuxkernel esec fse november8 virtualevent usa file security apparmor policy.c uninteresting code lines are omitted 4constchar aa splitn fqname constchar fqname size tn constchar ns name size t ns len 7constchar name skipn spaces fqname n 8if !name returnnull ns name is not initialized ns name null ns len populate ns name 13returnname 16intaa fqlookupn profile structaa label base constchar fqname size tn 18constchar name ns name 19size tns len 20name aa splitn fqname fqname n ns name ns len 22if ns name ubi!
ns aa lookupn ns labels ns base ns name ns len 26return0 figure4 aninter proceduralubibugintheapparmormodule andcorresponding llvm ir with control flow graph.analysis specifically towardsthisitappliesstandarddata flowanalysis.foreachstatement apoints tomapismaintainedandupdated accordingtothecontrol flow.thisallows ubitect tohavedifferent points to sets for the same pointer at different program points i.e.
flow sensitive .
because type casting is common in the linux kernel the pointstomaptracksallvariablesand field extended objectsregardlessof whethertheirtypesarepointersornot.thisallows ubitect tohandle i casting between pointers and integers and ii integer based pointerarithmetic.
ubitect alsohandlestwotypesofcastingsthat areespeciallytroublesomeforpoints toanalysis container of and casting from a voidpointer.
when handling such cases ubitect dynamically extends the allocated object size i.e.
number of fields in astructtype if the destination type contains more fields than the original object.
since such castings usually happen on function arguments thisprocedureenablesmoreprecisefunctionsummaries whichwillbe explainedin subsection .
.
.
qualifierinference our qualifier inference component is an extension of the flowsensitive analysis by foster et al.
and the inference rules for basic expressionsare the same.in addition we consider pair types which model the fields inside a c struct type and present their correspondingtypeinferencerules.providingseparatequalifiers for elements of pairs i.e.
structfields is important as structis usedextensivelyinthelinuxkernel.moreimportantly pointersto structareoftenpassedbetweenkernelfunctions andwhethera fieldof a structisor isnotinitializedis independentofthestates ofthe otherfields inthe struct.
given a program in llvm ir we present a type qualifier inference system to infer a qualifier either initoruninit for each registervariable i.e.
llvmexpression andeachfieldthatbelongs to an allocated memory object.
we perform the inference functionby functioninabottom upfashion.ifwecansuccessfullyinferthe qualifiers then the analyzed function is correct otherwise we find potentialubibug s .
whileweneitherelaboratenorcontributetothesophisticated theorybehindtypequalifiershere wetrytokeepthenarrativeselfcontained bydescribing the notationsand conceptsappliedin the referencerules.interestedreaderscanreferto forfurtherdetails.
we retain the standard qualifier notation from foster et al.
and onlypresent thetype inferencerules for pair expressions thefull set of inference rules is available to the interested reader in the supplementary material .
the subtyping relation between the two qualifiers is straightforward init uninit i.e.
initisasubtypeof uninit meaningthata variable of init tcould be valid wherever uninit tis expected but not vice versa.
defining the subtyping relations for qualified types andinparticularqualifiedreferencetypes issubtle.considering the primitive type int its subtyping relation of qualified intis q q qint q int thismeansthatifqualifier q q thenqintisasubtypeof q int for instance initintis a subtype of uninitint.
when it comes to