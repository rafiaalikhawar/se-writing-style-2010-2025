technical leverage in a software ecosystem development opportunities and security risks fabio massacci university of trento it vrije universiteit amsterdam nl fabio.massacci ieee.orgivan pashchenko university of trento it ivan.pashchenko unitn.it abstract in finance leverage is the ratio between assets borrowed from others and one s own assets.
a matching situation is present in software by using free open source software foss libraries a developer leverages on other people s code to multiply the offered functionalities with a much smaller own codebase.
in finance as in software leverage magnifies profits when returns from borrowing exceed costs of integration but it may also magnify losses in particular in the presence of security vulnerabilities.
we aim to understand the level of technical leverage in the foss ecosystem and whether it can be a potential source of security vulnerabilities.
also we introduce two metrics change distance andchange direction to capture the amount and the evolution of the dependency on third party libraries.
the application of the proposed metrics on distinct library versions from the foss maven based java libraries shows that small and medium libraries less than 100kloc have disproportionately more leverage on foss dependencies in comparison to large libraries.
we show that leverage pays off as leveraged libraries only add a delay in the time interval between library releases while providing four times more code than their own.
however libraries with such leverage i.e.
of libraries in our sample also have .
higher odds of being vulnerable in comparison to the libraries with lower leverage.
we provide an online demo for computing the proposed metrics for real world software libraries available under the following url index terms software security dependencies vulnerabilities leverage technical debt empirical analysis maven free open source software i. i ntroduction finance and software have always found interesting correspondences between concepts .
for example the notion oftechnical debt captures the short term developers action actually inaction to fix that may lead to a later cost of maintenance .
most academic studies see a review in only consider poorly written own code of a project as a source of a technical debt for a software project.
at the dagstuhl seminar researchers reviewed and consolidated the view on technical debt to clearly limit its scope to the internal system qualities of a software project.
nowadays developers often import functionality from thirdparty free open source software foss libraries by including them into their projects as dependencies .
such software engineering practice allows developers to use foss libraries as building blocks and therefore reduce development cost and time .
even for proprietary software the fraction of homegrown code decreased to .
industry reports showthat third party code inherited through dependencies is four times larger than the size of the own code base as an industry average .
it can be up to four orders of magnitude in our foss sample.
to capture this phenomenon we introduce the notion of technical leverage to assess the dependence on third party functionalities.
similarly to the financial ratio between debt other people s money and equity one s own money leverage is the ratio between third party code and one s own code.
additionally we introduce the change distance andchange direction metrics to measure the qualitative changes of a library between two consecutive versions.
these metrics capture the polar coordinates of the changes in the plane described by the sizes of own code and third party code.
an angle of degrees means that in the new version the developer is improving its own capital i.e.
code while keeping the same third party code on which is old version is leveraged.
since developers have different strategies we are interested to check whether the proposed metrics characterizes in some way the foss ecosystem.
for example developers of a small library may want to increase functionality of their library as fast as possible while developers of a mature and large library i.e.
with more than 100kloc might likely focus on fixing bugs and vulnerabilities and refining functionalities.
rq1 is there a difference in leverage distance and direction of changes between small and large libraries?
the next two research questions focus on the trade off between risk and opportunity that leverage may bring.
for example a large leverage means that several libraries are used and they might require integration and update costs.
indeed developers often decide not to update the third party libraries they are using due to the possibility of introducing incompatible breaking changes .
thus leverage might significantly delay the releases of one s own code.
if that happened the opportunity of leverage would turn out to be not a real opportunity but only an illusion since the time interval between library releases is linked to profitability and costs .
rq2 opportunity do leverage distance and direction of changes impact the time interval between library releases?
on the risk side using many libraries increases the attack surface and third party libraries are known to introduce functionality bugs and security vulnerabilities into the projects that13862021 ieee acm 43rd international conference on software engineering icse .
ieee use them .
in some cases dependent projects keep using outdated components for a decade or more thus increasing also the window of possible exploitations.
rq3 risk does leverage distance and direction of changes impact the risk of including vulnerabilities?
to answer the rqs above we applied the proposed metrics to more than 10k distinct library instances used in the foss java maven based ecosystem distinguishing between large libraries over 100kloc and small medium libraries.
summary of findings our analysis suggests that smallmedium libraries less than 100kloc have a high leverage on third party foss dependencies and their developers prefer to adopt new dependencies change direction at degrees .
large libraries have far smaller leverage and their developers mostly increase their own code.
the proposed metrics also partly explain the time interval between library releases but even a large leverage more than times one s own code which is present in of the small and medium libraries in our sample yield a very minimal change to such interval less than .
leverage is thus a concrete opportunity for the developers of a library.
yet a large leverage also increases the odds ratio of shipping code with vulnerabilities by .
so leverage is an equally concrete risk for the users of the library.
such findings bring new challenges for empirical software engineering your software and hence its quality depends way more from your choices of third party libraries than your coding and software security economics code users bear the risk while code developers reap the benefits .
ii.
t erminology we rely on the terminology established among practitioners e.g.
the users of apache maven and consolidated in alibrary is a separately distributed software component typically consisting of a logically grouped set of classes objects or methods functions .
to avoid ambiguity we refer to a specific version of a library as a library instance.
adependency is a library instance whose functionalities are used by another library instance dependent instance .
adirect dependency is directly invoked from the dependent library instance.
adependency tree is a representation of a library instance where each node is a library instance and edges connect dependent library instances to their direct dependencies.
atransitive dependency of a library instance at a root of a dependency tree is connected to the root library through a path with more than one edge.
aproject is a set of libraries developed and or maintained together by a group of developers.
dependencies belonging to the same project of the dependent library instance areown dependencies while library instances maintained by other projects are third party dependencies.
additionally for each library instance in our sample we identify the following dimensions that characterize a library own code size own as the number of lines of own code in the files of a library.
dependency code size dep as the sum of the lines of code of third party direct dependencies dir and transitive dependencies trans of a library total code size total as the sum of the two.
the qualifier third party is important as noted by pashchenko et al.
for convenience developers might have decided to structure their own code in separate libraries.
they might be mistakenly counted as other people s code while in reality is developed within the same project and by the same developers hence should be counted as own code.
as an example one could refer to scala libraries.
software projects always leverage some functionality from standard libraries of the programming language so that one should consider also the size of the the baseline of programming language libraries std.
iii.
t echnical leverage to capture the effect of software dependencies on the dependent projects we introduce the notion of technical leverage definition.
thetechnical leverage of a library is the ratio between the size of code imported from third party libraries besides the baseline of programming language libraries std and the own code size of the library dir trans std own in our empirical analysis the programming language platform is the same over all libraries java and maven so std const.
if one wanted to compare libraries across different ecosystems e.g.
python vs c libraries the difference can be significant.
further standard libraries are typically more mature than a third party library and splitting leverage by type might be needed for a more fine grained analysis.
this is also done in finance where one distinguishes between different type of debts.
similarly to allman who drew parallels between technical and monetary debts we illustrate the similarities between financial and technical leverages in table i. additionally the project maintenance routine requires developers to assess whether they have to update dependencies of their project i.e.
to evaluate the difference between different versions of the same library.
to facilitate this process and help developers to have more meaningful comparison of changes occurred between two library versions we propose to use change velocity vectors figure .
definition.
change velocity vector h dep ownicharacterizes how a library changes between releases r0andr1with respect to the size of its dependencies and its own size h dep owni h dep r1 dep r0 own r1 own r0 i in particular the library development behavior can be qualitatively described using polar coordinates of the change velocity vector and .
we use them to introduce the notions of change direction and change distance.
1387table i financial leverage vs technical leverage financial leverage technical leverage financial leverage is used to undertake some investment or project with the help of borrowed money debt software developers reuse already existing functionality from dependencies to focus only on new features in their projects financial leverage decreases the corporate income tax liability and increases its after tax operating earning using dependencies reduce the time and thus cost to develop new projects and sometimes increase project performance e.g.
numpy orpandas in python the debt implies an interest rate and must be eventually paid or refinanced an observation not present in dependencies have to be monitored and updated the concept similar to refinancing one s monetary debt unless one introduces security vulnerabilities financial leverage multiplies losses as well which might lead to a crisis if the amount of work required for the dependent project to update its dependencies become too high the developers might decide to stop updating dependencies and experience serious technical difficulties fig.
.
library change types depending on the angle of a change velocity vector definition.
the change distance characterizes the amount of change in code size between two consecutive library version.
q 2own dep albeit still measured in kloc this is obviously different than the pure change in the code base captured by own.
table ii and table iv later in section iv show that is on average larger than the library total size own.
definition.
the change direction characterizes the type of evolution of a library between two consecutive versions.
arccos dep own otherwise considering different values of we identify four main directions of a library evolution figure dependency adopting 0o software developers increase the size of library dependencies while not changing its own size dep own!
own size increasing 90o developers do not change the dependency size while increasing its own size dep!
own dependency removing 180o software developers decrease the dependency size while not changing its own size dep own!
own code removing 270o developers do not change the dependency size while decreasing own size of their libraries dep!
own combination of these library evolution directions can describe every change of a library.
for example if both own 1formally when we assume that .
experimentally is never zero as some changes are always present when one releases a new version.and dependency sizes increase between two library releases 0o 90o one may say that its developers both adopt new dependencies and perform self development of this library.
hence we qualitatively classify developers actions as follows 315o 45o developers mostly operate with dependencies dep own grey area in figure 45o 135o developers mostly change own code own dep dotted area in figure moreover the change velocity angle indicates whether developers increase or decrease the total size of their libraries 315o 135o developers increase total size total 135o 315o developers decrease total size total iv.
d ata selection for the study of the foss ecosystem we have selected the maven ecosystem.
we use the information directly available from the dependency management system.
the foss libraries distributed via apache maven are published on the maven central software repository2 that keeps all the publicly released versions of its libraries i.e.
their packages for example jar project object model files pom files and often some extra information such as source code of a library or its documentation javadoc .
maven also provides a dependency plug in that allows us to retrieve a list of dependencies of a particular library instance.
in this study we use only direct dependencies since developers have a habit of reacting to the issues connected with the own code of their libraries or their direct dependencies 1388table ii descriptive statistics of the library sample we consider distinct library versions gavs group artifact version coordinate in maven terminology starting from the most popular foss java libraries ga used by a multinational software development company in its customers or internal production level software and removing the library versions that have no source code in maven central.
mean st.dev min q25 medianq75 max lib versions direct deps own kloc dep kloc relinterval days .
moreover including the analysis of transitive dependencies increases the chance of introducing additional biases as transitive vulnerabilities are known to be overcounted .
we do notpreclude the analysis of transitive dependencies as they are known to introduce security vulnerabilities to some extent .
proper understanding of their effects requires networks and contagion analysis an interesting challenge for future work section x .
to identify the relevant main libraries and compute their leverage one needs a reference point anchor selected from the outside of the analysed ecosystem.
indeed just using the number of usages of within maven itself would have been severely biased as it would not correspond to the popularity of the software in the world which is what makes the study interesting but only to the internal use.
hence selecting an anchor from within an ecosystem we would have some important libraries e.g.
apache tomcat underrepresented in the library sample while several service libraries which nobody really uses would have been disproportionately selected.
hence we follow and started from the top foss maven based libraries used by a large software manufacturer across over java projects actual customers products or production level software developed by the company for internal use .
the resulting set corresponds to library instances when considering all versions and includes widely used libraries such as org.slf4j slf4j api and org.apache.httpcomponents httpclient.
algorithm is used to identify the own size of a library instance.
to calculate the size of library dependencies we recursively apply the algorithm to each dependency and then sum the resulting number of lines of code locs .
for some library instances or their dependencies there was no source code available so we removed them from our analysis.
we have also removed library versions with own size lines of code as these library versions do not carry actual functionality but only serve as apis or documentations for other libraries.
the final list comprises library instances.
table ii presents the descriptive statistics of the selected library sample.
developers of some libraries maintain several versions of the library at the same time3.
for example the developers of apache tomcat4project supported four versions .
.x 3in our sample libraries supported several versions simultaneously for a total of chains.
extract own size of a library version input a folderdirwith the source code of a library output the number of lines of code in a library numlocs 1filelist getallfilenames dir get the list of all file names in the folder dir 2numlocs 3forfilejfile2filelist do counting the number of lines in a file 4lines readalllines file load content of a file ifiscodefile file then including only code containing files forline2lines do counting only lines that are not empty and are not comments ifline andisnotcomment line then numlocs numlocs end end end 12end algorithm extract consecutive release chains from a library set input a set of library names libraries output a set of lists of consecutive releases releases 1releases 2forlibrary2libraries do 3curlib library getga use groupid artifactid as identificator for the current library 4releases 5branches prepare a list for storing library branches fori2range len library do 7libversion library get i th library instance of a library ifreleases then releases end 11libvid curlib libversion calculate id of a library version iflibvid2branches then releases append libversion else iflibversion releases then branches append libvid releases else releases append lib version end end end 23end .
.x .
.x and .
.x of org.apache.tomcat tomcat catalina library for the last three years starting from march .
these parallel versions might introduce errors into the analysis results if date ordering of library releases is used.
ordering versions by date we obtain .
.
.
.
.
.
.
.
.
.
.
.
because versions are released in groups typically a simultaneous fix of bugs .
.
and .
.
were released within minutes.
hence before the analysis we have distinguished release chains according to algorithm .
to estimate security risks we use the presence of a se1389table iii descriptive statistics of the vulnerabilities in the sample mean st.dev min q25 medianq75 max vulns own vulns dep table iv descriptive statistics of the proposed metrics we report the values of the introduced metrics for the library instance in our sample for which source code could be extracted and had at least lines of own code i.e.
where not clearly just apis for other libraries .
mean median st.dev min max q25 q75 dir kloc .
degrees curity vulnerability that affects the analysed library.
here we consider only vulnerabilities that affect the own code of analysed libraries for the quality assessment and not the one coming through transitive dependencies.
in other words when claiming that a library is vulnerable we will only count the library own vulnerabilities and the vulnerabilities of the direct dependencies which would be own vulnerabilities for each dependency .
at first this avoids double counting as the same library may be transitively included several times .
second the presence of vulnerabilities in the direct dependencies is a knowledge available to a developer.
thus there is a potentially deliberate choice of selecting a new vulnerable direct dependency or keeping vulnerable dependencies outdated .
to identify whether the own code of a library is affected by vulnerabilities we used the snyk database5that is constantly updated and for august contains data about more than vulnerabilities on the maven based libraries.
each entry in the database contains the information about a security vulnerability the library which own code is affected by the vulnerability and the range of affected library versions.
table iii shows the descriptive statistics of vulnerabilities per individual library in the selected library sample.
finally table iv shows the descriptive statistics of the proposed metrics for the selected library sample.
in the section vii we will use a leverage of four as a running example for the impact of direct leverage on small and medium libraries which is the reported value for industry average it is the value for q25 in our sample table iv and corresponds to the log mid point between a leverage of almost all libraries are above it and over half of the the libraries are above it as visible from figure .
the equivalent number for big libraries would be .
log mid point between the median direct leverage of and the bottom line of .
v. rq1 d ifference in direct leverage and direction of changes between libraries several studies suggested that a software project might have different development practices depending on its size.
hence we present results separately for small medium libraries whose code size does not exceed 100k lines of code klocs and large libraries that have more than klocs.
we observe from table ii foss developers widely adopt dependencies to reduce their development effort.
this especially applies for the small medium libraries with a code base less than klocs figure we observe that library instances use a large code base of direct dependencies that may .
times exceed their own size and of smallmedium libraries rely on .
times bigger code base of their direct dependencies median small libs which is bigger than the direct technical leverage of any library in our sample with own size exceeding klocs.
the increase of the own size of a library obviously leads to a decrease in its leverage the pearson correlation test suggests that there exists linear negative correlation between log dir andlog own r p value .
from the selected library sample of big libraries have direct technical leverage less than half of their own size median big libs including several libraries that have .
times smaller size of software dependencies.
considering the kernel density estimation kde plot for the change velocity angle for the libraries in our sample figure we observe the following small medium libraries own 100klocs figure 3a the developers mostly prefer to adopt thirdparty dependencies the pick around 0o rather than focus only on increasing the code of their own libraries the kde for 90ois less than .
.
sometimes developers also reduce the size of their dependencies and or optimize the size of their libraries the kde for 180oand for 315oare higher .
.
large libraries own 100klocs figure 3b the developers tend to increase the size of their libraries the kde for 90ois .
however the maximum kde value for the large libraries is more than times lower than the maximum kde for the small medium libraries.
moreover we observe that the developers also sometimes adopt new dependencies but they simultaneously increase own code of their libraries the kde for 45ois around .
.
sometimes developers of big libraries also optimize their libraries by reducing their own code and the code of their dependencies a pick around 250o .
discussion both analysis of direct leverage and change direction suggest that the developers of small and medium libraries rely on functionality of third party foss dependencies.
this corresponds to a general intuition since the thirdparty dependencies allow small libraries to grow faster.
too many dependencies might become difficult to manage which exposes dependent libraries to bugs and security vulnerabilities introduced by library dependencies.
hence developers of bigger and consequently more mature libraries tend to decrease the direct leverage of their libraries on third party dependencies the negative linear correlation between log dir and log own figure and a shift of development preferences from dependency adopting in small and medium libraries to mostly increasing the own code for large libraries figure .
1390developers of relatively small software libraries with own size smaller than klocs almost always ship more code than their own direct leverage .
for the majority their own code is only a small fraction of the overall codebase less than corresponding to a median direct leverage of .
in other words they ship mostly somebody else code.
the direct leverage of large libraries klocs is typically much smaller than the size of their own code and hardly exceed corresponding to at least of own code.
fig.
.
the direct leverage in comparison to the own size of a library key takeaway small medium libraries by far ship other people s code and at each round they add more.
vi.
rq2 d oes direct leverage impact time interval between library releases ?
big software projects typically involve developers working in parallel to increase the speed of development.
to capture this phenomena we will use log relinterval as the dependent variable for the regression.
we add to a time interval between library releases to correct for the approximate granularity in the measurement as in some cases releases happen on the same day although at different times .
a large direct leverage means that a library mostly relies on the work of other developers.
so we expect that direct leverage and library release time interval have a proportional relation rather than a linear one.
since we define as a fraction of dependency and own size of a library we could use dirdirectly in the regression.
however this would mean that moving direct leverage by a factor of would yield an exponential jump in a time interval between library releases.
however we observe that direct leverage spans eight orders of magnitude fig while the leverage coefficient in table v suggests that a change in magnitude in direct leverage aka effect of scale does not determine a proportional change in the time interval between library releases only a small linear change.
therefore we use log dir for the regression.
we expect that the change distance in own and dependency sizes will mostly require an increase of the time to test the added functionality into a new library version i.e.
a returns to scale effect.
hence we use log for the regression.
notice that 0as a new release always implies some changes.
change direction indicates i how developers change the total size of their libraries increase or decrease and ii whether they mostly change a library s own code or its dependencies.
to capture the effect of change in the total code size we consider the following 135oand 315ocorrespond to 0change in total while 45oand 225oindicates max change in total total increases when 315o 45o 135o 225o and decreases when 225o 315o 45o 135o .
to consider these effects into the regression we introduce thecos 45o transformation of the change direction metric.
if developers change own code of their libraries they have to both develop and test their projects.
on the other hand the change of library dependencies in most cases require only testing of dependent projects.
to capture these effects into the regression we consider the values of that indicate whether developers work with dependencies or own code of their libraries and introduce the sin transformation of the change direction metric6.
finally we consider the time interval between the previous release and its preceding one with the corresponding transformations as for the current time interval between library releases into the regression to capture the impact of project release practices e.g.
bi weekly daily releases .
we use the multivariate linear regression model to check the correlation between the proposed metrics and the time interval between library releases.
the previous discussion clarifies how the transformations above may help towards a linear regression model as the direct relation between the proposed metrics and the estimated parameters might not be necessarily linear e.g.
consider the example of figure .
the resulted linear regression model has the following form log relinterval log relintervalprev log dir log cos 45o sin table v shows the estimates standard errors t statistics and p values for both small medium and large libraries.
we observe that for the libraries with own code smaller than klocs all metrics have significant impact on the time interval between library releases p value direct leverage the change in total code and previous release have positive correlation with the release time interval of a library while the 6one might argue that cos andsin correlate and therefore could not be used as variables into a linear regression.
however eubak and speckman proved that cos andsin can be used simultaneously in a linear regression model and cos d can be transformed in a linear combination of cos andsin .
a for small and medium libraries the picks at the kde for the angles of library evolution plots suggest that developers of libraries with own code size smaller than klocs tend to operate with their dependencies they mostly adopt new dependencies and sometimes consolidate them.
b for large libraries the kde of the library evolution vectors for the libraries bigger than klocs suggest that developers of such libraries tend to increase the size of own code while importing some functionality from new dependencies both adopting new dependencies and upgrading currently used ones .
fig.
.
kernel density estimation plots for angles of library evolution vectors change distance and change in own code correlate negatively with such interval.
for large libraries the change distance and time interval between the previous and its preceding releases have significant impact on time interval between library releases p value .
discussion.
the increase of change distance corresponds to a slight decrease in the time interval between library releases.
such change is minor in quantity when change distance doubles such interval decreases only by .
since the size of is mostly determined by dependencies this observation shows that adopting dependencies speed up the evolution of a library in spite of large implicit changes to the code base.
what makes the difference is the type of changes.
for small libraries changing total cos 45o in the regression lengthen the time interval between library releases.
most likely we observe such an effect since the change in total code base means the major functionality changes e.g.
addition of new functionality .
in contrast when developers focus on own code of their libraries such interval reduces by the developers are likely fixing bugs and vulnerabilities in their libraries which might be of a higher priority due to the necessity to ship the fixed version to the library users.
a qualitative study might yield more insights into such changes.a.
does direct technical leverage pay off?
to understand the practical implication of direct technical leverage we analyze further the impact of the coefficient of direct technical leverage in .
since the log dir coefficient is positive having a large direct leverage increases the time interval between releases of a small medium library having too many dependencies might require additional time for the library developers to manage them.
however the value of the coefficient is small and therefore a more precise estimation is needed.
let therelinterval0and therelinterval be two release time intervals of libraries that are separated by a leverage factor of i.e.
.
from the regression we can reconstruct the following approximate relation log relinterval0 log relinterval log log which can be simplified to relinterval0 relinterval considering the estimates in table v for a library with own code 100klocs and direct technical leverage of four the 1392table v linear model fit to check the correlation between dir and release time interval these are the result of the regressions log relinterval log dir log cos 45o sin log relintervalprev .
for small and medium libraries with own size smaller than klocs there is root mean squared error .
r2 andr2 .
for large libraries with own size greater than klocs the root mean squared error .
r2 andr2 .
release time interval small medium libraries large libraries 100kloc log relinterval coefficients estimate std.err.
tstat p value estimate std.err.
tstat p value intercept direct leverage log dir change distance log change in total code cos 45o change in own code sin previous release interval log relintervalprev size of its direct dependencies is four times bigger than its own size the delay in the time interval between library releases in days will be less than .
so leveraging on third party libraries pays off you add 4x more code at the price of a small delay in your release time interval around two days on average .
even if you have many dependencies e.g.
slightly above the median for small libraries and your own code is essentially of the total code size the time interval between library releases only increases by around a week considering the average time interval in table ii .
key takeaway direct leverage pays off.
shipping an overall project four times larger than your own code base will only take a couple of extra days on average .
vii.
rq3 d oes direct leverage increase security risk ?
in medicine the effect of a parameter on a rare disease is described by the odds ratioor of a disease .
we use the or to have a first understanding of the impact of leverage on the security risk7of using a library by mapping i the fact that at least one vulnerability affects a software library onto disease and ii the condition that the direct technical leverage exceeds our running example value for leverage four for small libraries onto the state of exposure or jhighleveragelibs vulnlibsj jhighleveragelibs vulnlibsj jlowleveragelibs vulnlibsj jlowleveragelibs vulnlibsj table vi shows the contingency table where we use our running example 4for small and medium libraries own code 100klocs median direct leverage around and dir for large libraries own code 100klocs median direct leverage around .
the corresponding library groups have the following odds ratio or small libs confidence interval .
for big libraries the or big libs with confidence interval .
fisher exact test for both small medium and big libraries rejects h0 p value small libs p value big libs .
these results confirm our intuition the more you increase your total code size the more likely you are to step into a vulnerability.
the major 7as we only know reported vulnerabilities for the dependencies in our sample as vulnerabilities might be present but might not have been found yet we cannot use the risk ratio.
however since vulnerabilities are rare the or approximates the risk ratio .table vi contingency table for vulnerable leveraged libraries for small and medium libraries the larger the direct leverage the larger the risk of being vulnerable or small libs .
for large libraries own code 100klocs the risk is inverted the more own code the more likely to be vulnerable or small libs .
small libraries big libraries vuln not vuln vuln not vuln dir dir dir dir difference is that for small and medium libraries some of these vulnerabilities are most likely in other people s code and therefore out of control of the developer.
since a vulnerable library has normally more than one vulnerability see table iii it is interesting to understand whether the number of vulnerabilities change with leverage8.
further a library may have different level of leverage from version to version while the number of vulnerabilities may remain unchanged.
these two facts are due to the phenomenon that some vulnerabilities are in the third party code in dependencies that requires developers of these dependencies to release a fixed version of a dependency.
in other words developers might have added a new library left most peak in figure while keeping an old version of another dependency.
figure shows the distributions of maximum direct leverage per library in time grouped by the number of vulnerabilities that affect that library intended as a ga .
our running example threshold leverage equal to four provides clear visual separation of the exposed and not exposed libraries i.e.
libraries with high direct leverage are more likely to be exposed to a security vulnerability.
the exception in figure are the libraries with a high number of vulnerabilities extreme right but a direct leverage lower than .
they are the big libraries own 100k locs which are anyway exposed to the big number of vulnerabilities due to the large own size.
hence the direct leverage metric has a potential to be used as an indicator for a library to be exposed to security vulnerabilities.
further investigations are worth pursuing.
figure shows the relation between direct leverage and direction of library changes .
we observe that small medium libraries own code klocs with are more likely to be vulnerable.
such libraries 8from a user s perspective the library ga in maven s terminology is the same it is just a different version ga v in maven s terminology .
1393direct leverage equal to allows visual separation between the libraries exposed to high number of vulnerabilities vs libraries exposed to a small number of security vulnerabilities in our library sample.
the only excpetion are the handful of libraries at the extreme right.
they are libraries with large own code base 100k locs which are always affected by security vulnerabilities just because of their size.
fig.
.
max direct leverage per library vs number of vulnerabilities in a library version either include remove functionality from software dependencies or increase their own code base and therefore are likely to be under active development.
in contract there are less vulnerable small libraries with .
such libraries decrease the size of their own code and therefore they are likely to review the already developed functionality instead of developing new features i.e.
to be mature .
visual analysis of the direct leverage change direction relation plots for libraries with own code 100klocs suggests that in case of a big library there always exists a chance that its own code is affected by a security vulnerability.
discussion we observe that the fact of being affected by a security vulnerability for small medium libraries correlates with direct leverage and change distance while for big libraries the significant effect comes from change in own and total code.
most likely this happens due to the different strategies followed by library developers the developers of small libraries tend to quickly increase the functionality of their libraries and therefore adopt new dependencies which increase the total code size of their libraries while the developers of big libraries focus on changes in their own code.
while changes in own code may increase the attack surface they normally also include eliminating bugs and security vulnerabilities in software libraries.
in contrast adding libraries only eliminates security vulnerabilities as a side effect if a version or a whole library without vulnerabilities is selected.key takeaway direct leverage increases the security risk.
shipping four times your code base will increase the risk of shipping a vulnerable version by .
viii.
r elated works several technical studies showed that foss dependencies although being widely used by both commercial and foss projects are not often maintained properly a large share of projects up to have outdated dependencies.
several of them are not aware that some of those dependencies introduce serious bugs and security vulnerabilities .
as allman drew parallels between technical and monetary debts one may relate dependencies infoss to the well studied financial leverage instruments.
however we do not find a study that would try to quantitatively assess the technical debt introduced by software dependencies.
manikas and hansen presented a systematic literature review of papers on the studies regarding software ecosystems.
although the number of software ecosystem research papers is increasing the majority of studies are report papers.
hence the authors reported the lack of analytic studies of software ecosystems.
this statement is supported by another extensive literature review of papers on software ecosystems .
similar results are found by manikas in a more recent literature review of empirical studies spanning over software ecosystems there exists a lack of deeper investigation of technical and collaborative aspects.
boucharas et al.
proposed a standards setting approach to software product and software supply network modelling.
although this allows developers to anticipate upcoming changes in the software ecosystems the approach aims at development within one company and therefore does not suit the purpose of modelling foss infrastructure.
bonaccorsi and rossi proposed a simple model to helps software developers to decide whether to include foss components into their projects.
their model estimates the value of foss libraries based on the possibility of receiving additional support from the developers of an foss community.
hence our study fills an important gap in the state of the art by providing instruments for evaluation of the impact of technical leverage in the software ecosystems.
ix.
t hreats to validity the internal validity may be influenced by the fact that we have based the foss library selection for this study on their popularity from within a company.
we surveyed the usage data of the selected sample from mvnrepository.com9and the number of users from blackduck openhub10.
since both sources showed that libraries in our sample are also popular 1394fig.
.
direct leverage vs change direction for safe libraries blue left and vulnerable libraries red right with own size 100klocs among the foss developers we believe the internal validity threat of our study is minimal.
the generalization of these results may be exposed to an external validity threat since we considered only maven based libraries.
however since maven has the largest share of users between the developers in the java ecosystem11 our results reflect the practice of the majority of java developers.
in this study we aimed at creating awareness regarding the effects of technical leverage within software ecosystems and therefore proper case control studies are needed to for example validate the effect of odds ratio.
in this respect our study is easy to replicate for other dependency management systems.
x. c onclusions and future work by extending the metaphore from finance started by the notion of technical debt we have introduced the new notion of technical leverage and some associated code metrics leverage change distance and change direction to capture the relative importance and evolution of one s own code and third party code into a software library.
this notion is particularly important in today s software ecosystem where homegrown code is only a fraction of the total code base that is shipped to customers see e.g.
and table iv .
we have applied the proposed metrics to foss library instances from java maven stemming from an industry relevant sample of the top libraries used by a large rebellabs java tools and technologieslandscape 2016multi national corporation for its customers.
the results show that small medium libraries have high leverage on third party foss dependencies and their developers prefer to adopt new dependencies to speed up the development process.
large libraries have relatively small leverage and their developers mostly increase own code of their libraries.
the proposed metrics correlate with time interval between library releases and could be used to estimate the risk of a library to be affected by a security vulnerability.
libraries whose developers perform operations with e.g.
adopt or remove dependencies tend to be affected by vulnerabilities more often in comparison than libraries whose developers mostly change libraries own code.
we briefly recap the key findings of our paper as follows small and medium libraries with less than klocs of own code by far ship other people s code and at each round they typically add more.
with a median direct leverage of .
most libraries in our sample include less than of homegrown code.
direct leverage pays off.
shipping four times the size of your own code base as of small and medium libraries do will only take two extra days on average.
direct leverage increases the security risk.
shipping four times the size of your own code base will increase the odds of shipping a vulnerable version by .
for sake of comparison if all presently unbelted drivers and right front passengers were to use the provided three point lap shoulder belt but not otherwise change their behavior fatalities to this group would decline by .
1395these findings have also interesting implications for novel research directions in empirical software engineering and software security economics.
within empirical software engineering metrics of developer behavior e.g.
unfocussed contribution different development priorities code complexity large code changes etc.
are often studied to explain code quality.
yet as we have seen for small and medium libraries developers ship overwhelmingly other people s code.
so their skills and behavior as coders which may be captured by the logs of software repositories only contribute in minimal part to the quality of the overall code they ship.
in contrast their decision making behavior about the choice of libraries to be used as dependencies in one s own code has much larger impact.
unfortunately such behavior is not equally well documented and captured by traditional software repositories.
it might be captured by nlp analysis of the mailing lists or discussion blogs of the foss project or company internal mechanisms .
from the perspective of security economics our empirical data shows that technical leverage creates a decision dilemma a moral hazard in the economics terminology .
the benefit of a large leverage are reaped by the developers who can ship more code i.e.
more functionalities with a limited delay of time interval between releases which is associated with greater profitability and have been shown to have a log linear relation with costs .
yet the risk of using a vulnerable software are borne by the users of the library which might be hit by hackers if they kept an old vulnerable version that was however perfectly functional from their perspective see the equifax data breach12 .
since updating one s software is often not a technically feasible solution as illustrated by a quantitative study on android libraries in almost every second library update broke the dependent project and qualitatively explained in the presence of such dilemma may require to identify alternative solutions to software updates.
we also plan to investigate the broader impact of the proposed metrics.
for example leverage may predict a boundary for the amount of dependencies beyond which maintenance and update become unwieldy how many are too many?
this might require to correlate leverage with additional metrics such as the number of open issues the effort of developers etc.
also we may expect that library maintainers prefer different development strategies captured by change direction depending on the stage of maturity of a library and it would be interesting to determine whether there is such an effect.
another important direction for future work is the study of the impact of transitive dependencies on technical leverage albeit this should be done with care to avoid double or triple counting .
above all it will be interesting to further investigate the impact of technical leverage on other programming languages and software repositories.
media alert the apache softwaremore information for the interested readers we provide an online demo for computing the proposed metrics for the software libraries of this study and others at the following url https techleverage.eu