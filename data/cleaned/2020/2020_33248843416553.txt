cross contract static analysis for detecting practical reentrancy vulnerabilities in smart contracts yinxing xue university of science and technology of china hefei china yxxue ustc.edu.cnmingliang ma university of science and technology of china hefei china sa517245 mail.ustc.edu.cnyun lin national university of singapore singapore dcsliny nus.edu.sg yulei sui university of technology sydney sydney austrilia yulei.sui uts.edu.aujiaming ye university of science and technology of china hefei china sa517462 mail.ustc.edu.cntianyong peng university of science and technology of china hefei china sa517270 mail.ustc.edu.cn abstract reentrancybugs oneofthemostseverevulnerabilitiesinsmartcontracts have caused huge financial loss in recent years.
researchers have proposed many approaches to detecting them.
however empirical studies have shown that these approaches suffer from undesirablefalse positivesandfalse negatives whenthecode under detectioninvolvestheinteractionbetweenmultiplesmartcontracts.
inthispaper weproposeanaccurateandefficientcross contract reentrancy detection approach in practice.
rather than design ruleof thumbheuristics weconductalargeempiricalstudyof11714 real world contracts from etherscan against three well known general purpose security tools for reentrancy detection.
we manuallysummarizedthereentrancyscenarioswherethestate of the art approaches cannot address.
based on the empirical evidence we presentclairvoyance across functionandcross contractstatic analysis to detect reentrancy vulnerabilities in real world with significantly higher accuracy.
to reduce false negatives we enable for the first time a cross contract call chain analysis by tracking possibly tainted paths.
to reduce false positives we systematically summarizedfivemajorpathprotectivetechniques ppts tosupportfastyetprecisepathfeasibilitychecking.weimplementedour approachandcomparedclairvoyancewithfivestate of the art tools on real worlds contracts.
the results show that clairvoyanceyieldsthebestdetectionaccuracyamongallthefivetools and also finds unknown reentrancy vulnerabilities.
ccs concepts securityandprivacy distributedsystemssecurity software and its engineering software safety.
yun lin is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
reentrancy vulnerabilities static taint analysis cross contract analysis smart contracts acm reference format yinxing xue mingliang ma yun lin yulei sui jiaming ye and tianyong peng.
.
cross contract static analysis for detecting practical reentrancy vulnerabilities in smart contracts.
in 35th ieee acm internationalconferenceonautomatedsoftwareengineering ase september virtualevent australia.
acm newyork ny usa 12pages.
introduction poweredbytheblockchainplatform smartcontractsareexecutable contracts written in the form of computer programs which facilitate verify andenforcethetradingtransactionsbetweenbuyers and sellers in an automatic and transparent way without involving third parties.
on the most popular platform i.e.
ethereum contracts are written using solidity language.
security issues as surveyed in are the major concerns of solidity programs.
reentrancy alsoknownasthenotoriousdaoattack has caused a devastating financial loss of around million stolen ether digital currency for many ethereum accounts.
the vulnerability lies in that the attacker can leverage fallback functionalities insoliditytorepetitivelyincurthepaymentuntilexhaustingthe balance of the victim an example is shown in fig.
.
to addressthis issue existing approaches define a varietyofrulestodetectandavoidillegal orsuspicious useofthe fallback function in solidity program.
in this regard most generalpurposesecurityscanningtools e.g.
slither oyente zeus mythril manticore contract fuzzer and securify claim to support reentrancy bug detection.
however therelacksastudyonhowtheexistinggeneral purpose security tools actually perform on large scale reentrancy detec tion from real world contracts.
to answer this problem in thispaper we initially conduct a large scale empirical study on us ing three general purpose static tools for reentrancy detection i.e.
oyente from ccs securify from ccs and slither from industry on real world contracts from etherscan .
the empirical evidence shows that 35th ieee acm international conference on automated software engineering ase programmers have already invented many programming paradigms to avoid reentrancy attack.
without being aware ofthoseparadigms existingstate of the artsecuritytools report many false positives fps on the other hand existing tools usually define rules at intra procedurallevel whichincurstheincompletemodelingofprogrampaths particularlycross contractandinterproceduralcallpathsinsolidityprograms.italsocausesa considerable number of false negatives fns .
inthiswork weformallysummarizethose paradigmstoavoid reentrancyattackas pathprotectiontechnique ppt andproposea cross function and cross contract static analysis approach for reentrancybugdetection.ourapproachmodelsmoresoundinterprocedural paths to reduce fns and identifies feasible interprocedural paths by considering ppts to reduce fps .
more specifically we first construct a cross contract interprocedural control flow graph xcfg on which a static taint analysis is performed to identify potential paths that contain a reentrancy and then perform a lightweight symbolic analysis based on ppts to eliminate infeasible paths andfinallyreportreentrancy bugsbasedontherefinedfeasible program paths.
based on the technique we build and publish ourtoolclairvoyance avaiableat .wecomparedclairvoyancewithfivestate of the arttoolson17770contractsfromgoogle bigqueryopendataset.theexperimentalresultsshowthatclairvoyance yields the best detection accuracy among all the tools and finds unknown reentrancy vulnerabilities.
in summary this paper makes the following contributions wepresentalarge scaleempiricalstudyto evaluatethe ineffectiveness of three state of the art static tools to detect reentrancyattackinpractice and understandthepractical programming paradigm summarized as ppt to avoid reentrancy attack.
we present a new static reentrancy detection approach to enable more sound analysis by modeling cross function cross contract behaviors and more precise analysis by applying a light weight symbolic analysis based on ppts.
unlikeexistingstatictools whichyieldabinaryresult vulnerable or not our approach supports a more accurate bug reporting method by providing the feasible call chain s that causethereentrancy.sothe understandability ofdetection results is improved.
wehavecomparedourtool clairvoyance withthethree state of the art static tools i.e.
oyente securify andslither andtwodynamictools i.e.
mythril andsfuzz on17770contractsfromgooglebigquery open dataset.
the results show that clairvoyance hassignificantly better accuracy than the compared tools and successfully finds unknown reentrancy bugs that are all missed by the compared tools.
our experimental results are publicly available at .
background and motivation in this section we briefly introduce the fallback mechanism ofsolidity and explain how it can cause reentrancy.
then we introducethreestate of the artstatictools includingslither securify andoyente withexamplesofthefnsandfps.1contract partner mapping address uint256 public balances function deposit 4balances msg.
value function withdraw uint256 amount public require balances amount require msg.sender.
call.value amount 9balances amount figure a simple example for reentrancy vulnerability.
.
fallback function of solidity program on ethereum most smart contracts are implemented in solidity which supports basic structural elements including contract similartoclass inoop variable function etc.oncesoliditycontract is published e.g.
on ethereum the program is regarded as a law andcannolongerbealtered.giventhelawproperty specialmechanisms such as fallback function are introduced.
from law point of view the contract should define its behavior in any case.
hence fromtechnicalpointofview theexecutionoffallbackfunctionis triggered to handle some exceptional cases such as when its owningcontractiscalledwithanunknownfunctionname or when the contract receives plain ether i.e.
ehtereum currency withoutdata.nevertheless suchamechanismintroducesnotorious reentrancyvulnerabilities causingdevastatingeconomicloss .
.
reentrancy vulnerability fig.
shows an example of a reentrancy vulnerability.
the partner contractsupportsothercontractstodepositmoneyto via deposit functionatline3 orwithdrawmoneyfrom via withdraw function at line its account.
the other contract account is represented by balances field inpartnercontract1.i nt h ewithdraw function partnercontractfirstcheckswhether balances has a sufficient amount line .
if so partnertransfers to the other contract line and updates the balances line .
the root cause lies in that the malicious contract can repetitively incur the payment line without finishing the call tothe method withdraw until exhuasting the balance.
assume a maliciouscontract malihastwofunctions onefunction attack thatcalls partner.withdraw andtheotherfunction thefallback function that calls partner.withdraw .
the attack happens when mali.attack callswithdraw function whichexecutesline8of fig.
.theexecutionof msg.sender.call.value functionatline will trigger the fallback function of malicontract.
note that mali contractcancraftitsownfallbackfunctiontocall partner.withdraw function for his or her own benefits.
once the fallback functionof malicontract is triggered to call partner.withdraw function the control flow goes back to line and line before balances can be updated at line .
such a trick nullifies the condition check at line .
by this means malican repeatedly withdraw money from partnercontract.
.
state of the arts and their limitations existingstaticsecuritytoolssuchasslither securify and oyente claim to address this vulnerability.
these tools 1in solidity each contract has an address.
keyword msg.sender represents the address of contract interacting with the owner contract.
10301contract trader 2tokensale tokensale newtokensale internal contract defined at line in the same file function combination 4tokensale.buytokensw ithwei 5tokensale.buytokens beneficiary 8contract tokensale 9tokenonsale tokenonsale external contract ... function set address add tokenonsale tokenonsale add function buytokens address beneficiary if starallocationtotokensale tokenonsale.mint beneficiary tokens function buytokenswithwei onlytrader wallet.transfer weiamount figure complicated call graph and control flow graph crosscontracts anfnforslither oyenteandsecurify.
havetheirself definedrulesforcheckingvulnerabilitiesinasolidity program.
for example according to slither s rule a reentrancy may happen if it satisfies the following condition parenleftbig r var w var parenrightbig followsexterncall followsw var reentrancy in rule r andw denote the read and write operations respectively var denotes a certain public variable followsdenotes the executionorderbasedontheprogram scontrolflow externcall denotestheexternalcalltothe payment functionsexcept built in functions send andtransfer .thus therulemeansthatifthere existsanexternalcalltoapaymentfunctionandthecallisbetweentwowriteoperations tothesamepublicvariable areentrancymay happen.
in fig.
function withdraw is identified as a vulnerable function by this rule.
specifically a read access to a public state variable at line then a call to an external address via the low level function call.value at line and a write access tothepublicstatevariable atline9 .oyenteandsecurifyhave similar static rules to detect the reentrancy in fig.
see .
these simple rules have been proved to be effective in some cases but more often make detection results fall into fps or fns.falsenegative missingcompletecallchain existing static tools for smart contracts usually fail to consider cross function orcross contractcallchains missinganalysisofsomeimportant yet suspicious program paths.
fig.
shows a contract contains a reentrancy vulnerability that is missed by slither securify and oyente.fig.3showsitscorrespondingcross contractcfg xcfg where each rectangle represents a function each circle represents a statement denoted by its line number in fig.
and each directed edgerepresentsthecontrolflow.moreover weuseavirtualnode denoted by v in the function of tokensale.buytokens to show the returned control flow a grey node to represent payment statement anddashedrectangletorepresentanunknownfunctionof an external contract i.e.
tokenonsale.mint .notably the dashed rectangle could call any function as its behavior is unknown.
fromfig.
wecanseethat aslongas tokenonsale contractis malicious thereexistsacallchain circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt ?
circlecopyrt circlecopyrt ... which allows the attacker to recursively call wallet.transfer weiamount line .
such attack crosses multiple figure3 cross functionandcross contractcfgforfig.
.
note the grey node circlecopyrtdenotes a statement of payment function reentrancy vulnerability requires reentering of a payment function ?
circlecopyrtdenotes amaliciousstatementintheexternalunknownfunctionthatmaycallback.
contracts and functions and does not write any public variable which makes it hard to enumerate rules for its detection.
falsepositive inaccuratepathfeasibility existingstatictools canhardlyidentifypathfeasibility.fig.4showsacontractthatis mistakenly reported as a reentrancy vulnerability by slither and securify as it conforms to their defined rules.
fig.
shows its xcfg.
we can see that there exists a reentered call chain circlecopyrt circlecopyrt circlecopyrt circlecopyrt ?
circlecopyrt circlecopyrt circlecopyrt ... as the unknown function zthtkn.buyandsetdivpercentage.value mayusethefallbackfunctiontocallbackfunction receivedividends .however inpractice suchpathincfgtoexercisethechaincanneverbefeasible.the reasonisthat circlecopyrt circlecopyrtrequiresreentered truewhile?
circlecopyrt circlecopyrt circlecopyrtrequiresreentered false.
they are contradictory.
fig.
is a typical example where a path protective technique ppt is applied as a countermeasure for reentrancy attack.
the logic of the code ensures that the check condition line can alwaysprotecttheexecutionofpaymentstatement.unfortunately both slither and securify fail to recognize this infeasible path.
notably to accurately identify this ppt from code light weight symbolicanalysisisrequiredtochecklockingatline8andunlockingat line10 andsuchanalysiscouldbejustlimitedintheinternalfunction.
toovercomingfps fnsisnon trivial whichrequiresaddressing these challenges giventhebehaviorofthepossibleexternally interactingcontract is unknown how do we model its unknown call graph?
thepathnumberexplodeswhenthefunction contractnumber increases howdoweefficientlyidentifythosesuspiciousreentrancy attack paths from a set of solidity programs?
can we conduct the light weight path feasibility analysis which can achieve the efficiency meanwhile not compromising the soundness completeness of our approach?
how can we incorporate solidity specific features impacting control flowgraph likefunction modifier address binding etc.?
we propose a scalable static approach that can systematically compute those suspicious and feasible paths to cause reentrancy vulnerability with respect to both cross contract call chains and 10311contract zethrbankroll is erc223receiving 2zthinterface public zthtkn 3bool inter nal reentered function receivedividends public payable if !reentered ... if actualbalance .
ether reentered true zthtkn.buyandsetdivpercentage.
value actualbalance address 0x0 reentered false 14contract zthinterface to be inherited for implementing the function buyandsetdivpercentage function buyandsetdivpercentage address referredby uint8 divchoice string providedunhashedpass public payable returns uint declaration figure complicated path constraints due to using an execution lock reentered an fp for slither and securify.
zethrbankroll.receivedividends 8v zthtkn.buyandset divpercentage ?
figure cross function and cross contract cfg for fig.
.
pathfeasibility.thecross contractcallchainconstructioncaneffectively mitigatethe problem of missingreentrancy control flow.
identifyinginfeasiblepathsmainlyreliesonpathprotectivetechniques ppts toreducethefpswherereentrancyvulnerabilities never exist.
overview problem statement.
weargue thatreentrancyattackcouldhappenwhen there exists a feasible program path in cross contract cfg xcfg of solidity contracts which starts from setting an insecure contract oraddress andendswiththepaymentfunctioncall e.g.
call .value of that contract or address .
assumption challenges.
ourapproachfollowstheclose world assumptionofanalyzingsmartcontracts.givenatargetcontract our analysis scope includes the source code of all its caller and calleecontracts.thesolidityapisofaprogramwithoutfunction bodies e.g.
fallback and low level built in functions are analyzed based on their side effect summarization following the standard approach in static analysis.
fig.
shows an overview of our approach which takes as input the source code of solidity contracts and its caller callee and reports call chain s with path conditions to explain how a malicious contractcanconstructareentrancyattacktoexploitthevulnerability.infig.
eachrectanglerepresentsanartifact eachellipse representsastep orprocess eachedgerepresentstheworkflowof how a step takessome artifacts and outputs some new artifact.in addition we highlight the input output in grey.
as shown in fig.
our approach consists of the following four steps figure system diagram s1.
xcfg construction we first construct cross contract call graphandcfgamongtheinputsmartcontracts.inthisstep wehandlesolidityspecificfeatures e.g.
modifier fallbackfunction and collect all call chains starting from public functions.
s2.
static taint analysis next weidentifytaintedcontractobjectsoraddresses andtrackhowtheyareusedandpropagated along the call chain from the xcfg.
in this step we identify vulnerable call chains from xcfg which start with a suspicious contract address or object and end with the external function call.
s3.
empirical study summarizing ppts in order to mitigate the fps of reported paths abstracted by the vulnerable call chains we summarize a set of ppts for reentrancy attack through an empirical study which could be used for checking the path feasibility in a scalable way.
s4.
path filtering fortheseppts wedefinethecorresponding filtering patterns via program analysis paths with access control pathswithhard codedaddress pathswithexecutionlocks paths with internal updating before payment etc.
then given thevulnerablecallchainsfroms2andthefilteringpatternsbe hindpptsfroms3 wefilteroutinfeasiblepaths whichcannot form reentrancy in practice and hence lead to fps.
finally the remaining reachable paths will be the outputting results.
s1 .
and s2 .
are designed for mitigating fns while s4 .
and .
is designed for addressing fps.
next for readability we first explain s3 the empirical study for reasons quantitatively analyzing how in effective existing static tools on smartcontractsinthefield howeffectiveoursummarizedppts are.
then we proceed to elaborate on each step of our approach.
empirical study of typical false positives for existing rules in our empirical study slither v0.
.
oyente v0.
.
and securify v1.
run on frequently used real world contracts from the well known third party website etherscan for contract indexing and browser .
for the detection results we recruit researchers to spend months in reviewing the results and summarizing the patterns of fps for rules in these tools.
.
rules of existing tools in .
thedetectionruleof slithercheckswhetherthereexistsan externalcall of money transfer functions except built in functions 10321contract cozytimeauction function buycozy uint256 pepeid uint256 cozycand address peperec public payable require address pepecontract msg.sender 4pepeauction storage auction auctions 5totalfee ... ignore the details 6auction.seller.transfer price totalfee transfer if !pepecontract.cozytime auction.
pepeid cozycand peperec ... externa l call 8delete auctions write after call ... figure a real case of using access control ppt1 for the account address an fp for slither and securify.
send transfer thathappensbetweenwritestoapublicvariable.similarly accordingto wefindthatsecurifyproposes thecompliancepattern nowritesafter call topreventreentrancy2.
hence thecorrespondingviolationpatternistohavewritesafter call as shown by the rule externcall followsw var reentrancy wherew var means write operation s to a public variable and externcall refers to the external call for money transfer functions.
oyentesupportsthefollowingrule3 accordingto r var astrans vart a vard a parenleftbigw var followsexterncall parenrightbig reentrancy wherer andw means read and write operation s to a public variable astrans means the gas for transaction must be greaterthan2300 thetransferamount vart amustbegreaterthan the deposit amount vard a and the public variable var should be changed before the external call denoted by follows .
as oyente works on the evm bytecode instructions the gas consumption is estimated on the instructions.
notably slither and securify considerwritesaftercalls asoneconditionthatformsreentrancy but oyente considers writes before calls as one key condition3.
after we investigate the implementations of these three stateof the arts we observe that their detection rules are too simple andcoarse grained basicallyignorantofthepossibleprogrammingskillsusedbythedeveloper topreventthereentrancy.
shortly path in feasibility analysis is insufficiently supported by the three staticstate of the arts.
hence it is expected that these tools will yield many fps for real world contracts.
.
ppt1 access control before payment fig.7givesanfpreportedbyslitherandsecurifybasedonits rule .
the code firstly reads the state variable auctions then calls an external function via pepecontract.cozytime last writes deleteinstruction belongs to the general write operations to the public variable auctions .
however in reality reentrancy cannot be triggered by external attackers due to the require checkrequire address pepecontract msg.sender atline3in fig.
.
access control usually checks the invoker of the payment functions checkingwhethertheidentityof msg.sender satisfies 2in securify two types of detected errors are related to reentrancy i.e.
daoand daoconstantgas.thetwoerrorswillleadtoreentrancy andtheonlydifferenceis whether the gas will be recursively used or not with constant gas .
3we confirm this rule from the implementation of oyente.1interface hginterface function buy address add payab le external returns uint256 4contract richer3d ... mapping uint256 datamodal.roundinfo rid 7hginterface constant p3d hginterface xb3775fb83f7d12a36e0475abdd1fca35c091efbe function calculatetarget public if increasebalance targetbalance if increasebalance p3d.buy.
value ethforp3d p3daddress ... rid .lasttime timestamp ... figure a real case of using the constant value ppt2 forthe contract address an fp for oyente and securify.
1contract rtb2 2modifier onlyhuman address addr msg.sender uint256 codelength 5assembly codelength extcodesize addr require codelength sorry humans only function buy uint256 amt exter nal onlyhuman payable require balances amt require msg.sender.
call.value amt balances amt figure9 arealcaseofusingaself definedmodifierforpro tection ppt3 anfpforslither oyenteandsecurify.
certainconditions e.g.
insomeauthorizedlist withagoodreputation or having the dealing history .
notably ppt1 needs to reside inthe samefunction asexternal calls otherwise itcan beavoided.
.
ppt2 hard coding payment address fig.8showsanfpreportedbyoyenteandsecurify whichadopts a hard coded address to prevent the malicious external attack.
according to rule as this code block has a balance check and alow level call for money transfer it is reported by oyente as a reentrancy.similarly accordingtorule2 thereisawriteoperationtothepublicvariable rid .lasttime aftertheexternalcall and hence securify detects it.
however this example cannot be exploitedbyanyarbitraryexternal address owingtothe20bytes hard codedaddress i.e.
0xb3...efbe forcontractobject p3datline in fig.
.
hence ppt2 restricts the external malicious access.
.
ppt3 protection by self defined modifiers fig.
gives another fp that is reported by the existing tools ignoring ppt3.
this code block actually considers the security issue and adds the self defined modifier onlyhuman before the potential vulnerable function buy .
sinceonlyhuman restricts that the transactioncanbeonlyconductedbytheaddressof msg.sender via the usage of keyword extcodesize which returns if it is called from the constructor of a contract.
in such a way via ppt3 buy could not be recursively called by external attackers.
.
ppt4 protection by execution locks different from the above ppts relying on access control or re stricted addresses to prevent external malicious calls ppt4 preventstherecursiveentranceofthefunction eliminatingtheissue 10331contract pvpcrash function withdraw gasmin public returns bool address user msg.sender uint256 userbalance if !roundended withdrawblock maxnumblock userbalance getbalance user if balance userbalance if userbalance user.transfer userbalance externalcall emit with draw user userbalance return true return true figure10 arealcaseofupdatinginternalstatesbeforepayment ppt5 an fp for oyente.
from root.
for instance in fig.
the internal instance variable reentered will be checked at line before processing the business logicbetweenline8and10.topreventthereenteringduetocalling zthtkn.buyandsetdivpercentage.value reentered willswitchto true after the transaction is finished it will be reverted to false to allow other transactions.
hence by virtue of ppt4 this solution issimilarwithusingmutex whichpreventsthereentrancyfrom both the authorized addresses or external malicious addresses.
.
ppt5 internal updating before payment ppt5isrequiredtofinishallinternalwork i.e.
stateandbalance changes andthencalltheexternalpaymentfunction.accordingto the report from consensys the recommended pattern is composed of three steps all the requirechecks are atthe beginning of function buy the tokens in the middle are the internal state changes for bool and numeric variables at the end is the call of built inpaymentfunctions transfer ofsomeexternal contracts or addresses.
this pattern is also recommended by solidity official documentat namedas checks effects interactionspattern to prevent reentrancy.for example for thecode in fig.
it follows this safe pattern.
however according to rule for oyente this code block is mistakenly reported as vulnerable.
.
fp statistics of existing rules finally weauditalltheresultsofthethreetools andsummarizethenumber of fps due to mis considerations or unsatisfactory supportoftheseppts.asaresult .
offpsareaccountedforthe5pptsinslither .
offpsareforpptsin oyente and95.
offps are for ppts in securify.
hence we can confirm that the available statictoolsignoreorunsatisfactorilysupportthesepptsincode.
notethatrecallisnotstatisticallyevaluatedinthisempiricalstudy as our goal is to understand the reasons behind the fps of these tools.
accordingtoourobservation securifyandslitherhavebetter recalls than oyente as rule and are more general than rule .
approach in this section we will detail each step of our approach in fig.
including xcfg construction static taint analysis path filtering based on ppts and finally outputting reachable vulnerable paths.table fps due to the inconsideration or unsatisfactory support of ppts for different tools in our empirical study.
slither v0.
.
oyente v0.
.
securify v1.
ppt1 ppt2 ppt3 ppt4 ppt5 ppts all fp .
.
.
.
xcfgconstruction callchaingathering xcg and cfg generation.
we first build the cross contract call graph xcg forsolidityprograms whicharedirectedgraphswherenodesaresolidityfunctionsandedgesbetweenthemdenotecalling relations.thecallgraphofsolidityprogramsisgenerallysimilar withthatofotherooplanguages exceptthatthefallbackfunctions and self defined modifiers need to be considered to add additional call edges for a more accurate call graph.
for each function inside thexcg wealsobuilditscfgadoptedfromslithir afterthe abstract syntax tree ast parsing.
xcfg generation.
xcfg is a combination of xcg and all the cfgsoffunctionsofasolidityprogram notexplicitlysupported byslither .accordingtothexcg wecanconnectallthecfgs forallfunctionsandmodifiers andattainthecorrespondingxcfg.
let us denote the two parts of a function call cross contracts a call site node ciand a return site node ri.
there is a cross contract edgeci scfrom a call site node to the start node sc of the calledcontract c thereisalsoacorrespondingedge ec rifora dedicatedexitnode ec.forexample thexcfgisillustratedinfig.
andfig.
.differentfromcallchainsstartingfromtheentryof main function in java a call chain can start from any publicfunction in solidity and is considered valid if its cross contract edges are matched i.e.
each riis matched with the corresponding ci .
in our study we aim to find vulnerable call chains from xcfg that satisfy the condition call chains with a loop due to calling unknown external functions that may call back to the current callee function.hence theproblemcanbereducedtothat howtofindvulnerable call chains on the xcfg as complete as possible a typical graph traversing problem.
the collector.
we design the call chain collector with the followingalgo.
.giventhexcfgofasoliditysourcecodefile theinput includes the taint input source isthat is listed in table the set of all public functions fand the set of all call chains cfin the xcfg.
the output yielded by the approach is the set of vulnerable call chains vc each of which actually abstracts a possible vulnerable path vp that leads to a reentrancy attack at execution time.
algo.
is composed of three steps identifying the vulnerable call chains via static taint analysis at line to see .
fil tering the call chains that are actually non vulnerable due to the adoption of ppts at line to see .
and finally outputting allremainingvulnerablecallchainsasresultsatline12.iftheinput source file s have in total nfunctions the maximum length of a call chain without loop and mlines of code the maximum length of a path without loop the time complexity of algo.
is o nm .
themosttime consumingpartisthetwo levelloopatline1to8.
1034algorithm collectingvulcallchain traversing the xcfg and collecting vulnerable call chains input is all the input source input f all the public functions in xcfg input cf all the call chains in xcfg output vc the set of potentially vulnerable call chains 1foreachcall chainc cfdo get the concrete paths for con the xcfg 3pc c. etconcretepaths 4foreachpathp pcdo s etsource is p get input source for p pt propa atebyrules p s taint propagation ifissinkoftainted pt is truethen vc vc c break cis vulnerable 9foreachcall chainc vcdo 10ififexistppt c is truethen if a filtering pattern in table is found vc vc c cis non vulnerable 12returnvc table2 thesourcesandrulesofthestatictaintanalyzerfor solidity programs.
is msg.sender tx.origin parameters of public function rules data assignment a address type address address binding object contractofobject address return value of functions address object functon sinkobject.method if object is tainted then it is tainted address.call.value if address is tainted then it is tainted asnandmare usually not large in real world contract files the overall performance is practically good on real world contracts.
.
static taint analyzer giventheconcretepathsrepresentedbycallchainsfromthexcfg we identify vulnerable functions vfs and vulnerable paths vps by our static taint analysis as follows target of static taint.
in this study vulnerable functions vfs refertothoseunsafefunctionsthataresusceptibletoreentrancy attack.vulnerablepaths vps refertotheexecutionpathsallowing toreadexternalinputparameters pi e.g.
externaladdressortransactionamount andleadtoavfwithvariablesvaluesdependingon pi.wealsocallthesetofinputsource is ofparametersastainted data.
thus we aim to identify the critical vps that are susceptible to reentrancy attack on the xcfg of a program via the tainted data dependencypathsflowingfromanistoavf.however unlike thetaintanalysisforjavaorc programs weneedtoconsider the special features of solidity language.def anduse relations.
wefirstbuildthedatadependencyrelationshipamongthevariablesinsolidityprograms.therearetwo types of program points or nodes on xcfg on the def use chain relations a usesite that only reads one or multiple variables and adefsitethatatleastwritestoonevariable.forthe5typesoftable the filtering patterns behind ppt1 ppt5.
ppt filtering pattern ppt1 parenleftbigisauthorized ms .sender haspermit ms .sender parenrightbig followsms .sender .externalcall ppt2 parenleftbigvaradd const varobj contract const parenrightbig follows parenleftbigvaradd.externalcall varobj.externalcall parenrightbig ppt3the above two patterns in the self defined modifiers of functions that have external payments ppt4 parenleftbigischecked vl followsw vl followsexternalcall followsw prime vl parenrightbig w vl !
w prime vl ppt5ischecked vint followsw vint follows parenleftbigvarobj.transfer parenrightbig variables and types of operations in slitherir we build the def use relations for each of the types of ir operations.statictaintrules.
asshownintable2 weproposetheisfortaint analysisandthepropagationrulesthatsuittosolidityprograms.
theisfortaintincludestheparametersofpublicfunctionsandthe twospecialfeaturesofsolidity namely tx.origin andmsg.sender .
the former refers to the original external address that starts the whole transaction while the latter just refers to the external address that calls the current contract.
all the is may be tainted with malicious external addresses and propagated to the vfs via the propagationrules.
similarwith otherooplanguages thedata assignment operation rule and the function return assignment rule3 propagatethetainteddata.uniquely insolidity theaddress bindingoperations creatingacontractobjectfromanaddressin rule also propagate.
finally in the xcfg a vp is identified if there is a path satisfying any of the two conditions if a contract object is tainted calling any of its public methods potentially invokingthefallbackfunction isvulnerable ifanaddressvariableis tainted calling any of its low level functions is vulnerable.
specifically rule for program data assignment involves the following operations in slitherir assignment binary unary new operator push convert array initialization memberforthethree typesofvariables statevariable localvariable andsolidityvariable.
rule involves the operations of member convert assignment array initialization and index as the address binding may refer to one address or an array of addresses.
last rule involves the operations of member call returnandassignment.
.
path filtering based on ppts given the vps reported by the static taint analyzer we need to apply the filters that take into account the ppts.
behind each ppt we define a filtering pattern shown in table .
the filtering pattern for ppt1 is to check whether msg.sender is within a list of authorized contracts or addresses or has the permissiontodothis e.g.
msg.sender owner andfinallytheabove checkisrequiredtobewithinthesamefunctionand before denoted by follows the external call of the tainted address or contract.
the filtering pattern for ppt2 is to check whether the tainted address or object has been initialized in declaration or modified before the external call with a byte length string constant.
thepatternforppt3isactuallyapplyingtheabovetwopatterns inself definedmodifiersofthefunctionwiththesuspicioustainted object or address that has the external call.
1035the patternfor ppt4 is tocheck the existenceof the execution lock where vldenotes the boolean variable to be used as the lock andischecked vl denoteswhether vlischeckedvia require orif assertchecks etc.
.
w vl denotes the firsttime of write operation tovl andw prime vl denotesthe secondtimeofwriteoperationto vl.
hence w vl !
w prime vl meansthatthefirstandthesecondwrite operation assign the different values to vl.
the pattern for ppt5 is to check the existence of checks effectsinteractions pattern where vintdenotes the set of internal variables for the current contract w vint refers to the write operations tovintfor the internal state or balance changes and last varobj.transfer denotestheexternalcallofthebuild infunction transfer .
notably even if varobjis tainted the code is still nonvulnerable asthebuilt infunction transfer usingafixedamount of gas and will not repeatedly reenter the payment function.
.
light weight symbolic analysis tomaketheppt basedfilteringmoreaccurate alight weightsymbolic analysis isdeveloped and employed across ppt1 assisting the reentrancy detection.
our light weight symbolic analysis is bothintra proceduralpath sensitiveandcontext insensitivetosynthesize a symbolic path from tainted source to the fallback call.
then we feed the path into z3 solver to check its feasibility.
given a user defined threshold h we abstract the loop analysis by unrolling the loop for hiterations.
moreover we abstract eachfunctioncallwithanewvariableofitsreturntype.inother words our result ensures the soundness of a reported infeasible path.
despite such an abstraction still suffers from fps in some cases itlargelyreducesourrun timedetectionoverhead whilestill allowsustoavoidpotentialfpsinaconsiderableway.fortheexamplein fig.
we synthesizeapath !
reentered actualbalance .
reentered true which is solved to be infeasible which helpsusavoidthefalsealarm.last ifthesolverreturns unknown resultforthesynthesizedsymbolicpath wediscardthepathand use the result of ppt for detection.
afterthefilteringisfinished theremainingreachablecallchains or feasible paths in vcwill be outputted as the detection results.
evaluation we have conducted extensive experiments to evaluate the effectiveness of clairvoyance.
specifically weattempt to answerthe following research questions rqs rq1.
howeffectivearethesummarizedppts?comparedwiththe three available static tools how is the precision of clairvoyance?
rq2.how useful is the cross contract static taint analysis?
compared with the three static and two dynamic tools how is the recall of clairvoyance?
rq3.howefficientisclairvoyanceinanalyzingreal worldsolidity programs?
rq4.canclairvoyancediscoverreal worldunknownreentrancy vulnerabilities which can lead to dao attacks?
.
setup .
.
baselines.
inevaluation weusetheirlatestversions namely slither v0.
.
oyente v0.
.
and securify v1.
.
to compare clairvoyancewiththedynamictoolsintermsofrecall wealsotable the detection accuracy at function level for clairvoyance and the other three tools on the contracts .
sli.
v0.
.
oye.
v0.
.
sec.
v1.
c.v. n tp fp note n refers to the number of detection results tp refers to the number of true positives and fp refers to the number of false positives.
include mythril v0.
.
and sfuzz v0.
.
in the tools pool.
as no multi threading options are available only the default settings are used under the same machine environment.
.
.
dataset for tool evaluation.
in our evaluation to fairly compare clairvoyance with the other tools we choose the dataset of 17770smartcontracts whichcomefromgooglebigqueryopen dataset adifferentsourceotherthanthe11714contractsusedin ourempiricalstudy.inparticular the11714contractsusedinour empirical study see are directly crawled from ethereum block chain.
in this experiment we obtained smart contracts by trackingtheirdeploymentaddressesfromthepublicgooglebigquery dataset .wedownloaded17770contractsthroughtheetherscan api with their deployment addresses.
.
.
experimental setup.
clairvoyanceisimplementedinpython on top of the slitherir library.
during the evaluation all the experimentsandtoolsareconductedonamachinerunningonubuntu .
with core .10ghz intel xeon e5 2620v4 processor gb ram and tb hdd.
.
.
manual inspection.
to validate the false positives fps or true positives tps from these results we hire four experienced soliditydeveloperstocheckthedetectionresultstogetherwiththeir corresponding source code via the aid of the two dynamic tools i.e.
mythril and sfuzz in two months time.
more specially we asked developers to conduct cross reference to manually evaluate the results.
we divide the developers into two groups each with two members .
in each group one developer evaluated the results and the other was responsible for double checking the results.
.
rq1 evaluating the precision table4liststhenumbersofdetectionresultsofthefourstatictools i.e.
608bysecurify 168byclairvoyance 162byslitherand28 byoyente.after thevalidation itisfound thatthough securify i.e.
usingrule2 reportsmorebugs mostofthemarefps.oyente reportsfewestbugs andislimitedincatchingthe truebugsfound by other tools dueto its coarse grained checking rule i.e.
rule .
in comparison clairvoyance has the most tps and the fewest fps.
to understand the reasons behind the fps reported by each evaluated tool we first classify the fps into the five categoriesbased on ppts.
the results in table show that most of the fps reported by the static tools are due to ignorance or limited support of these ppts including of fps in slither of fps in oyente and of fps in securify most of the fps are due to our summarized five ppts.
this confirms that clairvoyancehas the best support of these ppts and hence achieves the best precision.
1036table fps due to the inconsideration or unsatisfactory support of ppts for different tools on the contracts.
sli.
v0.
.
oye.
v0.
.
sec.
v1.
c.v. ppt1 ppt2 ppt3 ppt4 ppt5 sum perc.
in all fps .
.
.
.
1contract betting function betting public payable constructor 3owner msg.sender 4betcontrinterface bettingcontrinterface owner function reward internal ... calculate house fee if total bettors forcevoidrace else require house fee address this .balance total reward total reward.sub house fee betcontrinterface.payhousefee.
value house fee figure11 arealcaseusingppt2 thehard codedaddress in constructor at deployment time an fp for clairvoyance.
morespecifically wesummarizethefollowingobservationsfrom thefp results securifyfailsto considerpermissioncontrols hard codedaddressesandself definedmodifiers.italsofalselyreports the write operations after calling built in functions send andtransfer asvulnerable causingfpssinceitdoesnotconsider ppt5.
oyente basically ignoresthe protectionsin self defined modifiers and has many fps mostly because it ignores ppt3.
among all the fps of slither it generally has a good support for ppt3 by considering the code of security check in modifiers.
however it still has many fps due to lack of any symbolic analysis for ppt1 cases and ppt2 cases .
considering a relatively small numberofcasesinusingexecutionlock ppt4 slitherignores the protection by execution lock s .fp example of clairvoyance.
as shown in table the fps of clairvoyance root in the limited support of ppt1 ppt2 andppt5.
after looking into the code of these fps the reason for 9fps of ppt1 mainly lies in the complicated path conditions e.g.
user defined functions in condition control which cannot be wellhandledbyourlight weightsymbolicanalysis actuallythepathisinfeasibleduetostrictconstraintsintheuser definedfunctions butclairvoyancereportsitfeasible.thereasonsof10fpsofppt2aretwofold 5fpsareduetothehard codedaddressinaconstructor see fig.
fps are also due to the complicated condition solving e.g.
involving string operations for address constants.
last the14fpsofppt5allbelongtothiskindofcornercases thestatementsrelevanttoppt5areallinsideanexternallyunreachable branch but clairvoyance falsely reports them reachable.
infig.
weshowanfpexample whereourfilteringpatternfor ppt2 failsbecause of the hard codedaddress in aconstructor.accordingtoalgo.
webuildandsearchallcallchainsstartingfromapublicfunction however theconstructorisnotconsideredasanordinarypublicfunctionincallchains asitisonlyexecutedatthecontractdeploymenttimeandcannotbecalledbyotherinternal externalfunctions after that.
for function reward in fig.
our taint analyzer figure12 thevenndiagramforillustratingtheoverlappingand unique tps among the evaluated static tools.
table the detection results for two dynamic tools on the vulnerable contracts detected by clairvoyance .
tool n tpr detection time min.
mythril .
.
.
sfuzz .
.
.
note the two dynamic tools cannot finish on contracts within one week and hence are applied on vulnerable contracts.
suggests that the low level call .payhousefee.value at line isvulnerable as betcontrinterface isintaintinputsourceandwithoutanyprotectionfrom ppts.however thiscaseisanfp asthe constructor has assigned the contract address with msg.sender during the deployment time msg.sender is the account address of the deploying programmer .
as betcontrinterface is never modified in other places its address is the account address of the deploying programmer.noexternaladdresscantriggerthereentrancy and hence it is an fp due to overlooking of ppt2 in the constructor.
besides there are fpsof clairvoyance due to other ppts not included in strict gas consumption checks for one entranceto prevent reentrancy of the payment function runtime condition checks on the basis of using block.number orblock.time which sometimes rely on the chain status.
in general these two other ppts cannotbehandledbystaticanalysis.duetopagelimit moredetails and examples of other ppts are available at the website .
answertorq1 ingeneral clairvoyanceexhibitsasignificantlybetterprecisionthantheotherthreestatictoolsowing tobettersupportoffiveppts.theotherthreetoolsneedto improveintermsofppt1toppt3 whileclairvoyanceneedsthedeploymentanalysisandmoreaccuratesymbolicanalysis.
.
rq2 evaluating the recall in fig.
this venn diagram shows that tps are found byclairvoyance tps by slither tps by securify and tps byoyente.fortheoverlappingpart only2tpsarefoundbyall the four static tools slither and securify report the same tps oyente has tps thatare also found by clairvoyance.
notably our tool reports unique tps missed by the three static tools.
after we inspect the tps of clairvoyance we find the low recall of the three static tools is attributed to two factors out of122 ownthevulnerablecallchainsthatinvolvemultiple contracts except the external attack contract which could be 10371contract redenvelope function create address token ... public payable ... checks and calculattion for other variables 4infos info token msg.sender amount ... 5emit redenvelopecreated hash function sendback bytes32 hash public 8info storage info infos require info.owner msg.sender ... more checks uintback info.amount info.fill if info.isspecialerc20 specialerc20 info.toke n .transfer msg.
sender back else erc20 info.token .
transfer msg.
sender back emitredenvelopesendback hash msg.
sender back figure a real case of misusing ppt1 at line due to the issue of supporting struct info an fn for clairvoyance.
similar with the call chain in fig.
and the three static tools fail to conduct cross contractanalysis.
the other 67tp residing in singlecontractmostlyhavethecalltoexternallydefinedhigh level functions notthoselow levelfunctions e.g.
call however the three static tools mainly check the call to low level functions.
in addition to static tools two dynamic tools are compared in terms of recall in table .
out of tps found by clairvoyance mythril and sfuzz detect and respectively.
hence the two dynamictoolsshowabetterrecallthanthethreestatictools butstillmissmostofthetps.asdynamictoolsaresignificantlyslowerthan statictools itwilltaketoomuchtimetorunonthewhole17770 contracts.
so we just randomly pick up the other contracts to have testing in the wild for the two dynamic tools and find two vulnerable contracts fns that are missed by clairvoyance.
fn example of clairvoyance.
tps mightbemissed by clairvoyanceduetothemisuseoftheppts.forexample thefnshown in fig.
mistakenly applies ppt1 access control for line and removesthiscasefromthesetof vc.nevertheless aftermanualauditing wefindthat therequirecheckatline9isnottocheckthekey member info.token but to check an irrelevant member info.owner .
accordingto hash thesource ourtaintanalyzerreportsthe whole structinfoas tainted due to the initialization of the struct at line and then appliesppt1 at line .
occasionally due to thegranularityissueofthetaintanalyzer itcannotaccuratelyanswerwhich memberofastructobjectistainted.apartfromthefninfig.
anothertrickycaseofmisusingppt1causestheotherfnforclairvoyance the external low level call of a tainted address and a permission check are meanwhile inside an ifcondition control which is mistakenly matched with the ppt1.
answer to rq2 in general clairvoyance exhibits much betterrecallthantheotherthreestaticandtwodynamictools owingtocross contractcallchainanalysis.butmisusingppts will falsely filter some tps and cause fns for clairvoyance.
.
rq3 evaluating the efficiency on the contracts we observe that light weight static analysistools aremostefficient tools basedonverificationor symbolic execution are relatively slower.
in table slither and clairvoyance take the least time minand 181min respectively.oyente is less efficient taking min.
surprisingly securify is the least efficient using min.
although oyente supports types of vulnerability and securify supports types the analysis overheadsdonotincreaseverymuchevenwhensupportingmoretypes.table the time min.
of reentrancy vulnerability detection for each tool on contracts.
dataset sli.
v0.
.
oye.
v2.
sec.
v1.
clairvoyance slither and clairvoyance both depend on light weight data control flow analysis.
our tool has more overheads due to the support ofcross contractstatictaintanalysis.oyenteisbasedonsymbolicexecutionofevmirdisassembledfromevmbytecode.theperformance issue of securify roots in the time consuming conversion of irs into datalog format and then the verification on the datalog.
to sum up the efficiency is essentially determined by the inherent complexity of different techniques.
answer to rq3 in general clairvoyance is efficient as a light weight cross contract static taint analysis tool which avoidsusingverificationorheavy weightsymbolicexecution.
.
rq4 reproduction of dao attack to confirm the vulnerabilities of tps found by clairvoyance we manuallyinspect101tps notdetectedbyanyotherstaticordynamictool andexperimentwiththetriggeringofthem.accordingto the hints e.g.
the vulnerable call chains provided by clairvoyance we conclude that out of tps could be easily triggered with high confidence owning to two reasons no clear ppts are foundalongthevulnerablecallchains indicatingtheirfeasibility the contexts of the call chains are not too complicated to understand allowingus orexternalattackers tounderstandtheflaws in the business logic.
the remaining tps for which we are with lowconfidence havecomplicatedlogicforunderstandingandown complex constraints in paths that may be undecidable for staticanalysis.
in the tool website we have added the exploitation code succeedon ourprivatechain for20outofthe82tps andwe will gradually add more.
here we detail two interesting tps case1at 0x7bc51b19abe2cfb15d58f845dad027feab01bfa0 .asimple caseisthecontract dividenddistributor with6transactiontimes and a total transaction amount of .
ethers.
the vulnerable call chaininvolves5functionsfrom 2contractsandhasaninternalvul nerablefunction loggedtransfer whichproceedsthetransaction with unchecked the transfer target and the amount.
the low levelcall of the transfer function is tainted.
we can easily trigger this reentrancy and steal money from it.case at 0x526af336d614ade5cc252a407062b8861af998f5 .a complicated case is the contract saiproxy with transaction times and a total transaction amount of ethers.
the shortest vulnerablecallchaininvolves4externalcontractsanditslengthis8 functions.thefunctioncall tub.gem .deposit.value msg.value isthelow level calloftaintedobject tub.wecanrecursivelycall this function for causing gas exhaustion.
answer to rq4 based on the vulnerable call chains reported by clairvoyance triggering the tps of reentrancy is facilitatedandprovestheeffectivenessof clairvoyancein practice.
.
discussion .
.
generality of ppts.
ppts can be applied for other bug types likeself destruct abusing .
for example ignoring ppt3 selfdefined modifiers when detecting self destruct abusing causes fps since strict permission control could be done via ppt3 and make the function selfdestruct not accessible by the non owner.
besides ppt3 is also found to prevent the bug of unexpected revert andtoolsignoringppt3willinevitablyyieldfps.moredetails on using ppts for detecting other types of bugs are available in .
.
.
threats to validity.
threats to internal validity come from the threshold hused in the light weight symbolic analysis.
currently his set to2 for unrollingevery loop e.g.
while upto twice.
wefindthatincreasingthevalue e.g.
upto5 doesnothavesignificantimpactonourresults.thereasonisthatnotmanyloops aresolved alongthe pathsfor theppts.
threatsto externalvalidity mainly come from the representativeness of the two datasets of smart contracts.
however there is no dataset available in previous papers .
during the past two years we have tried our best to collected and downloaded real world contracts from etherscan to assess the existing tools and summarize the ppts.
toavoidthebiasofusingonedataset weusethe17770contracts in google bigquery open dataset for tools evaluation.
we will release and contribute our datasets to the community.
.
.
future enhancement.
our clairvoyance is not designed for the compositional analysis i.e.
how can we avoid redundant interproceduralanalysiswhenafewnewcontractsareaddedintoour analysisscope.themajorruntimeoverheadfornon compositionalanalysisofourapproachliesinthatclairvoyanceneedstosearch through all the contract scope for its caller contracts.
the larger the scope the more overhead it will incur.
in the future we plan to investigate incremental and compositional analysis for reentrancy detectionbycachingandindexingthecallrelationamongcontracts.
note that the overhead for re analyzing for callee contract is acceptable as a contract consists of only up to a few hundred lines of code whichrequiresonlyabout0.5secondforthecalleeanalysis of individual contract.
related work .
reentrancy detection in smart contracts recently many security scanners have been proposed for vulnerability detection in smart contracts.
among them manticore mythril sfuzz mythx echidna contractfuzzer and ethracer belong to dynamic testing fuzzing tools.
other scanners including slither oyente smartcheck securify octopus zeus maian andscompile arebasedonstaticanalysis.notably maian and scompile support inter contract function call analysis and apply verification technique but do not support reentrancy detection.
however instatictools onlyslither oyente securifyand zeus support the detection of reentrancy vulnerability.
among them slither servesasananalysisframeworkandrunsthe built in reentrancy detector on the basis of intra contract control dataflowanalysis.oyente worksontheevmirandleveragesz3 solver forconstraintsolvinginsymbolicexecution.securify convertsevmbytecodeintodatalogrepresentationand then applies verification on the datalog.
zeus adopts xacml as a language to write the safety and fairness properties converts them into llvm ir and applies a verification engine e.g.
seahorn .
notably zeus is not included in tool comparison as it isnotopen sourced.recently verx anautomatedverifier has beenproposedtoprovefunctionalpropertiesofethereumsmart contracts.
verx could detect a wide range of vulnerabilities viatechniques of reducing temporal property verification for reach ability checking a new symbolic execution engine and delayedpredicate abstraction.
compared with all above tools clairvoyancemakesthefirstattemptatadoptingpptsforpathfeasibility analysis.
.
interprocedural analysis callgraphconstructionisthefundamentalrequirementforinterprocedural static analysis which is used in many program analysisapplicationssuchassoftwaredebuggingandtesting code recommendation and template based code reuse .
there exist many call graph construction algorithms for resolvingvirtualdispatches andindirectcallsfor traditionaljavaand c c programs by using class hierarchy analysis rapid type analysis variabletypeanalysis andpointeranalysis .
unlikeconventionaljavaorc c programs solidityhasnewand complicated language features such as low level calls explicit manipulations of contract addresses via keywords e.g.
msg.sender andaddress this fallback mechanisms and inter contract callbacks similartoresolvingcallbacksinevent drivenprogramssuch as android apps .
interprocedural static taint analysis has alsobeenstudiedasaninstanceofdata flowanalysis.theanalysisnormallyconductsreachabilityanalysisontopofaprogram s data flowgraphwhichiseitherpre computedusingfastandimpreciseanalysis orbeingbuilton the flyinademand driven manner .
different from previous approaches on java and c c thisworkconductsinter contractstatictaintanalysison topofsmartcontractprogramsbyconsideringsolidity s14types of ir operations to support precise taint propagation in detect ing reentrancy vulnerability one of the most important types of vulnerabilities in smart contracts.
conclusion inthispaper wepresentareentrancydetectionapproachbasedon applying the light weight cross contract static taint analysis to findreentrancycandidatesand integratingthepptstorefinethe results.onthepubliclycollected17770contracts clairvoyance significantlyoutperformsthethreestatictoolsintermsofprecisionandrecall andtwodynamictoolsintermsofrecall.inthefuture we will extend ourapproach by combining withdynamic approaches for detecting more vulnerability types.