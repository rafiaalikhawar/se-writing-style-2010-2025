history driven test program synthesis for jvm testing yingquan zhao college of intelligence and computing tianjin university china zhaoyingquan tju.edu.cnzan wang college of intelligence and computing tianjin university china wangzan tju.edu.cnjunjie chen college of intelligence and computing tianjin university china junjiechen tju.edu.cnmengdi liu college of intelligence and computing tianjin university china liumengdi tju.edu.cn mingyuan wu southern university of science and technology china mail.sustech.edu.cnyuqun zhang southern university of science and technology china zhangyq sustech.edu.cnlingming zhang university of illinois urbana champaign united states lingming illinois.edu abstract java virtual machine jvm provides the runtime environment for javaprograms whichallowsjavatobe writeonce runanywhere .
jvm plays a decisive role in the correctness of all java programs running on it.
therefore ensuring the correctness and robustness of jvm implementations is essential for java programs.
to date various techniques have been proposed to expose jvm bugs via generating potential bug revealing test programs.
however the diversity and effectiveness of test programs generated by existing researcharefarfromenoughsincetheymainlyfocusonminorsyntactic semantic mutations.
in this paper we propose javatailor the first history driven test program synthesis technique which synthesizesdiversetestprogramsbyweavingtheingredientsextracted from jvmhistorical bug revealingtest programsinto seed programsforcoveringmorejvmbehaviors paths.morespecifically javatailor first extracts five types of code ingredients from the historicalbug revealingtestprograms.then tosynthesizediversetest programs it iteratively inserts the extracted ingredients into the seedprogramsandstrengthenstheirinteractionsviaintroducing extradatadependenciesbetweenthem.finally javatailoremploys these synthesized test programs to differentially test jvms.
our experimentalresultsonpopularjvmimplementations i.e.
hotspot and openj9 show that javatailor outperforms the state of the art techniqueingeneratingmorediverseandeffectivetestprograms e.g.
testprogramsgeneratedbyjavatailorcanachievehigherjvm code coverage and detect many more unique inconsistencies than thestate of the arttechnique.furthermore javatailorhasdetected 10previouslyunknownbugs 6ofwhichhavebeenconfirmed fixed by developers.
junjie chen is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
concepts software and its engineering software testing and debugging compilers.
keywords javavirtualmachine programsynthesis jvmtesting compiler testing acm reference format yingquanzhao zanwang junjiechen mengdiliu mingyuanwu yuqun zhang and lingming zhang.
.
history driven test program synthesis forjvmtesting.in 44thinternationalconferenceonsoftwareengineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction java virtual machine jvm is the fundamental infrastructure to supporttherunningofjavaprogramsandtheprogramsthatare written in other programming languages but can be compiled to java bytecode .
over the years many jvms have been developed by various organizations or companies such as hotspot from oracle openj9 from ibm gij from gnu andzulufromazul .althoughmanyofthemhavebeenelaborately maintained for many years like other software systems jvmalsocontainsbugs .duetoitsfundamentalrole jvmbugs couldleadtounexpectedbehaviors evendisastersinsafety critical domains of any programs running on top of it.
therefore it is crucial to ensure jvm s quality.
in recent years some jvm testing techniques have been proposedtoguaranteethequalityofjvm including classfuzz and classming .thesetechniquesdesignvariousmutationoperators to generate a large number of java classfiles .class based on real world classfiles also called seed classfiles as test inputs for jvmtesting.inthispaper wecalljvm stestinputs testprograms andseed classfiles seedprograms followingthe existingwork .
specifically classfuzz designsaseriesofsyntacticmutationoperators e.g.
changing the modifier or type of a variable .
however itsgeneratedtestprogramsareusuallyinvalid causingthatthey are rejected at the jvm s startup stage i.e.
loading linking and initialization and thus cannot reach the follow up verification and executionstages.togetridofthislimitation thestate of the art ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yingquan zhao zan wang junjie chen mengdi liu mingyuan wu yuqun zhang and lingming zhang technique i.e.
classming was proposed which designs some mutation operators e.g.
inserting gotoorreturninstructions to alter the control and data flow of seed programs instead of syntactic mutation.
althoughthesetechniqueshavebeendemonstratedtobeableto detect some new jvm bugs they still suffer from the effectiveness problem.specifically theyjustaimtogeneratethetestprograms with diverse control and data flow by accumulating minor mutations rather than bug revealing test programs.
that is their goal is notdirectlyalignedwiththetestinggoal leadingtospendingplenty of time on generating and executing the test programs without the bug revealing capability and thus hindering their effectiveness.
moreover the great control and data flow diversity of test programsdoesnotmeandiversetestingcapabilitiesforthejvmunder test.
in particular their minor mutations e.g.
mutating some keywords actually limit the space for constructing new test programs andthuslimittheirtestingcapabilities.forexample inourstudy to be presented in section the state of the art technique i.e.
classming only increases .
jvm line coverage compared with theseedprogram i.e.
avrora afterexecuting3 765itsgenerated test programs.
therefore more effective jvm testing techniques are still desirable.
tofurtherimprovetheeffectivenessofjvmtesting inthiswork we propose a novel technique called javatailor which aims to generate bug revealing test programs as much as possible in order toapproachtheidealtestinggoal.toachievethisgoal javatailor investigatesthetestprogramsrevealinghistoricaljvmbugsand then extracts bug revealing ingredients from them to facilitate the generation of new bug revealing test programs.
the key insight liesinthateachhistoricallybug revealingtestprogramcontains the ingredients facilitating the detection of the bug which may involvecomplicatedcodelogicorcovercornercases.ifwecombine theingredientsextractedfromvarioushistoricallybug revealing test programs orput these ingredients into different contexts it is verylikelytogeneratethetestprogramsthatcancovermoreinterested jvm sbehaviors paths leading todetecting newbugs.
with this intuition we design javatailor consisting of three steps first javatailorextractstheingredientsfromourcollectedhistorically bug revealing test programs to form an ingredient pool.
in particular we systematically extract five types of ingredients at the block level to balance extraction efficiency and effectiveness.
second javatailor generates a new test program by synthesizing a randomly selectedingredientfromthepoolandareal worldclassfile i.e.
a seedprogram .theseedprogramisresponsibletoprovidedifferentcontextsfortheextractedingredient.themaintechnicalchallenge of javatailor lies in this step since it is necessary to guarantee thesynthesizedtestprogramtobevalid.here javatailordesigns two strategies i.e.
reusing variables in the seed program and constructing new definitions to fix the broken syntactic and semantic constraintsin theextracted ingredient.in particular javatailorallowssynthesizingtheseedprogramwithmultipleingredientsinan iterativeway whichishelpfultocombinedifferentbug revealing ingredients for jvm testing.
third javatailor adopts differential testingtocheckwhetherthegeneratedtestprogramcanreveala jvm bug or not.
to evaluate the effectiveness of javatailor we conducted extensive experiments on two popular jvm implementations i.e.
hotspotandopenj9 involving5openjdkversions bytaking8 real world benchmarks as seed programs and collecting his torically bug revealing test programs.
our experimental resultsdemonstrate that javatailor is able to detect much more unique inconsistenciesthanthestate of the artjvmtestingtechnique i.e.
classming achieving792.
.
improvementsacross alltheopenjdkversionsexceptopenjdk14 onlyjavatailordetects inconsistencies on this version and thus we cannot calculate theimprovementonit .also onthebasisoftestcoverageachieved bytheseedprograms javatailorisabletofurtherimprovemuch morelinecoverage branchcoverage andfunctioncoveragethan classming .
in particular javatailor detects unknown bugs in the latest hotspot and openj9 among which has been confirmed or fixedbydevelopersaftersubmittingthemtothecorrespondingbugrepositories.thoseresultsdemonstratethesignificanteffectiveness of javatailor.
tosumup thisworkmakesthe followingmajorcontributions direction.
we open a new direction for jvm testing while priorworkonjvmtestingfocusedonminorsyntactic semantic mutations ourworkopensanewdimensionforjvmtesting via history driven test program synthesis to cover more diverse jvm paths behaviors.
technique.
we propose a novel jvm testing technique called javatailor which aims to generate bug revealing test programs as much as possible by elaborately utilizing historically bug revealing test programs.
implementation.
wedevelopandreleaseatooltoimplement javatailor including systematically extracting ingredients from historically bug revealing test programs and synthesizingtheingredientswithagivenseedprogramto produce a valid test program.
study.weconductanextensivestudytoevaluatejavatailor based on popular jvm implementations i.e.
hotspot andopenj9 demonstrating the significant superiority of javatailor overthe state of the artjvm testingtechnique.
in particular javatailor has detected unknown bugs of which have been confirmed or fixed by developers.
motivation and challenges here we use an example to illustrate the motivation of javatailor and its major challenges.
figure1ashowsatestprogramgeneratedbyjavatailor which detectsanunknownopenj9bug.thisbugiscausedduetomissing nullchecks for the parameters in memorynotificationinfo in theopenj9implementation.
memorynotificationinfo isaninternal class under java.lang.management package which is used to notifywhenthememoryusageexceedsathreshold.thenotifiedinformation is vital for debugging when error occurs.
when running this test program with a nullparameter i.e.
usage on openj9 it isexecuted normallywithoutany exception.however whenrunningthesametestprogramonhotspot a nullpointerexception is thrown since its implementation contains nullchecks for the parameters in memorynotificationinfo .
the different behavior exhibitedbythemindicatestheexistenceofabuginatleastone ofthem.throughourmanualinvestigationandsubmittingabug report to the bug repository of openj9 the bug was confirmed authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
history driven test program synthesis for jvm testing icse may pittsburgh pa usa public static void main string args string str anystring string name str memoryusage usage null long count generate by random memorynotificationinfo mn mn new memorynotificationinfo name usage count count mn.getcount system.
out.println str a test program public static int run string argv printstream out memoryusage mu new memoryusage check negative count mn new memorynotificationinfo poolname mu count mn.getcount if count !
out.println failure .
out.println wrong count count expected testfailed true ... b historical test program figure motivating example public memorynotificationinfo string poolname memoryusage usage long count super if poolname null throw new nullpointerexception .getstring k0d02 if usage null throw new nullpointerexception .getstring k0d03 this.poolname poolname this.usage usage this.count count figure openj9 bug and fixed by openj9 s developers bug id .
the patch provided by them is shown in figure in which nullchecks have been added for memorynotificationinfo s parameters.
thisbug revealingtestprogramisgeneratedbysynthesizingthe ingredientextractedfromahistoricalbug revealingtestprogram asshowninfigure1b andanarbitrarilyselectedseedprogram as showninfigure1awithoutthecodemarkedinred .pleasenote thatthehistoricaltestprogramcannottriggertheabovedetected bug since no parameters in memorynotificationinfo are set to null.
specifically we extract lines from the historical test programastheingredientandtheninsertittotheseedprogram.
as shown in figure 1a we insert the ingredient at lines to produceatestprogram.here directlyinsertingtheingredientto the seed program cannot make the synthesized test program valid due to lack of definition of some variables such as mnand the parametersof memorynotificationinfo andwehavetoconduct extra operations to make it valid.
to better integrate the ingredient and seed program for the triggering of interesting corner case interactions between them we prefer to replace the undefined variables in the ingredient with the existing variables satisfying type compatibility in the seed program.
thus we assign strdefined at line to the first parameter ofmemorynotificationinfo as shown at line .
if the seed programalsodoesnotcontainsuchtype compatiblevariables wehavetogeneratedefinitionsforthecorrespondingvariables.forexample thesecondparameterof memorynotificationinfo belongstothe type ofmemoryusage and thus we generate its definition as shown at line .
since the second parameter is initialized to be null the synthesized test program is able to trigger the bug.wefurtheranalyzedwhetherexistingjvmtestingtechniques can detect this bug.
regardless of classming orclassfuzz they just conduct minor mutations e.g.
changing the modifier of a vari able or inserting the gotokeyword on the seed program in an iterative way which aims to change the data and control flowinside the seed program.
if the seed program does not contain memorynotificationinfo like the one used in the example i.e.
the seed program contains only lines and as shown in figure 1a thesetechniques cannot generate testprograms revealing thebugnomatterhowtochangeitsdata andcontrol flow.aspre sentedabove however synthesizingtheingredientsfromhistorical testprogramsismorelikelytointroducebug revealingprogram features indicatingthepromisingdirectionofminingtheingredients accumulated in a large number of historical bug revealing test programs for constructing better jvm test programs.
whileitisapromisingdirection synthesizingnewbug revealing test programs based on historically bug revealing test programs is not trivial which suffers from two major challenges challenge howto measureandextractingredients inhistorically bug revealing test programs?
a test program tends to contain various language structures which can be represented at different granularities such as variables blocks or files .
if we measure and extract ingredients at a very fine grained granularity e.g.
variable granularity the process of ingredient extraction could become costly and the whole syntactic or semantic features relevant to bugdetectionmaybedamaged.ifthegranularityistoocoarse e.g.
file granularity the interaction between the extracted ingredients and theseedprogramcouldbeweak whichaffectstheintegrationof theingredientswithnewcontextsandthusimpairsthetestingperformanceof synthesizedtest programs.therefore measuringand extractingingredientsatanappropriategranularityisimportant and non trivial.
challenge howtoguaranteethatasynthesizedtestprogram is valid?
a test program usually involves various syntactic and semanticconstraints.violatingthemcanmakeitbecomeinvalid and an invalid test program will be rejected by the jvm under test thusimpairingthetestingperformance.whensynthesizing the ingredients extracted from one test program with another test program it is scarcely possible to produce a valid test program by directly combiningthem since theytend to involve verydifferent syntactic and semantic constraints.
therefore it is very important but challenging to make the different constraints from the two test authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yingquan zhao zan wang junjie chen mengdi liu mingyuan wu yuqun zhang and lingming zhang programscompatibleduringthesynthesisprocess sothatavalid test program can be produced.
approach in this paper we propose a novel jvm testing technique called javatailor whichaimstogeneratenewbug revealingtestprograms by synthesizing the code ingredients extracted from historically bug revealing test programs with given seed programs.
the keyinsightbehindjavatailoristhat1 existingtestprogramsreveal ing historical bugs contain the code ingredients facilitating thedetection of bugs which tend to contain more complicated code logic or cover various corner cases and combining various such code ingredients and or putting them into different code contexts canpotentiallycoverevenmoreinterestingjvmbehaviors paths important for new jvm bug detection.
figure shows the overview of javatailor which consists of three stages.
first javatailor extracts the ingredients from thecollected test programs revealing historical bugs to construct an ingredient pool section .
.
more specifically we systematically designvarioustypesofcodeingredientsattheblockgranularity injavatailortobalancebotheffectivenessandefficiency.second javatailor synthesizes a randomly selected ingredient from the ingredient pool with a given seed program to generate a valid test program section .
.
meanwhile javatailor fixes the broken syntactic and semantic constraints in the code ingredient i.e.
missing variables definitions byeitherutilizingthetype compatiblevariablesintheseedprogramorautomaticallyconstructingthemissingdefinitions.third javatailorexecutesthesynthesizedtestprogram for jvm testing section .
.
it adopts differential testing basedon different jvm implementations e.g.
hotspot and openj9 tocheck whether the test program reveals a bug or not.
if there is noinconsistenciesidentifiedbythesynthesizedtestprogram the test program will be put into the pool of seed programs for further combining with more ingredients.
.
ingredient extraction asdiscussedinsection2 theeffectivenessofextractedingredients could be affected by its extraction granularity.
in javatailor weadopt the block granularity as the trade off between extraction efficiencyandeffectiveness.specifically wesystematicallydeign fivetypesofblocksforingredientextractionasfollows.inparticular ourimplementationforjavatailorisbasedonsoot awidelyused tool for analyzing java classfiles and our five types of blocks can cover all the types of instructions supported by soot.
based on soot javatailor extracts ingredients from the java classfile i.e.
jimple code transformed by soot level rather than the source code level which can acquire the following benefits there are a numberofoperationsonjimplecodesupportedbysoot facilitating the implementation of javatailor it facilitates to generate more testprogramswithrichersemanticsbygettingridoftheconstraints from front end compilers e.g.
javac .
sequentialingredient seq .aseqreferstoablockcontaining a sequence of instructions without any branches.
ifingredient if aifcouldhaveseveralbranches i.e.
if else if andelse and it includes the conditions of all the branches and the corresponding bodies.
loopingredient loop aloopcouldbe while do while orforloop.
it includes the loop condition and the corresponding body.
switch ingredient switch a switch includes the conditionandallthecases.insoot itcontainsboth lookupswitch andtableswitch.
try catch ingredient trap it includes the trybody and the statements used for handling the caught exception.
to implement the extraction of ingredients javatailor transformsahistoricalbug revealingtestprogramintoacontrol flow graph cfg based on the jimple code obtained after soot s pro cessing.inacfg anodereferstoabasicblockincludingoneor moreinstructions andan edgerepresentsthe codelogicbetween two basic blocks.
an ingredient in javatailor includes one or more basic blocks in a cfg.
based on the cfg of a test program javatailor first identifies the starting points i.e.
basic blocks of the latter four types of ingredients according to the types of instructions included in each basic block.
for example if a basic block contains a switchinstruction it can be regarded as the starting point of a switch ingredient.then foreachstartingpointofaningredient javatailor searches for its dependent basic blocks to form a whole ingredient.
for example after identifying a basic block including a switch instruction javatailorsearchesforthebasicblocksforallthecases ofthisswitchcondition andfinallyallthesebasicblocksforma switch ingredient.
there is a special case in implementations and we further illustrate it in detail if a basic block contains an if instruction it ishard todeterminewhether itisthe startingpoint ofanifingredient.thisisbecauseinsoot loopsarerepresented asthecombinationof ifandgotoinstructions.thus weneedto checkwhetheritssuccessorbasicblockscontaina gotoinstruction.
if agotoinstruction is found and its target is the starting point this basic block is actually the starting point of a loop ingredient otherwise it is the starting point of an if ingredient.
for a basic blockthatcannotbeidentifiedasthestartingpointofanyofthe latter four types of ingredients javatailor treats the basic block as a seq ingredient.
to further illustrate the extraction process we take an example showninfigure4 whichisacfgofnested for if.foreachbasic block in the cfg javatailor checks whether it is the starting point of one of the ingredients.
for example for the block labeled as alsocalledblock2 itcontainsan ifinstruction indicatingthat itmaybethestartpointofanifingredientoraloopingredient.
tofigureoutitstype javatailorrecursivelygetsallitssuccessor blocks andfindsthatthereisa gotoinstructionthatpointstoblock 2inblock5 indicatingthatthisisaloopingredient.itcorresponds to the part labeled as for in this figure.
for block there is no gotoinstruction pointing to it in all its successor blocks and thus it is an if ingredient corresponding to the part labeled as if in this figure.
when the extraction process is completed javatailor canextract ingredients in this example as shown at the bottom of figure4.notethatthestartandendblocksofcfgarefilteredhere due to its simple code logic.
through extracting the five types of ingredients from all the collectedhistoricalbug revealingtestprograms aningredientpool can be built by javatailor.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
history driven test program synthesis for jvm testing icse may pittsburgh pa usa raw historical test programs ingredient pool seed poolno difference foundstep2 ingredient extractionstep3 ingredient selection difference report failing synthesized programsnormal synthesized programstep4 seed selectionstep5 insertion step1 seed initialization seed programs input synthesis phase execution phase outputother jvms... figure overview of javatailor label if i0 goto label label returnif i0 goto label 2for if r1 java.lang.system.out r1.println i0 label i0 i0 goto label1r0 parameter i0 extracted ingredients if seq loop figure control flow graph of nested for if .
test program synthesis to generate a new test program javatailor randomly selects an ingredient from the ingredient pool as well as a seed program andthensynthesizestheingredientwiththeseedprogram.also javatailorrandomlyselectsaprogrampointintheseedprogram for inserting the extracted ingredient we call it synthesis point in this paper .
such random operations are helpful to generate diversesynthesizedtestprograms.asdiscussedinsection2 itis challenging to ensure that the synthesized test program is validdue to breaking the original syntactic and semantic constraints oftheingredient i.e.
missingvariabledefinitions .therefore to obtain a valid synthesized test program javatailor has to fix those broken constraints during the synthesis process.
to achieve this goal javatailorhastwostrategies i.e.
reusingvariablesintheseed program and constructing new definitions.
reusing variables in the seed program .foravariable missing itsdefinitionintheingredient javatailorpreferstofindwhether thereisavariableintheseedprogramthatcanbeusedtoreplacethe variable in the ingredient.
in this way the interaction between the ingredient and the seed program can be stronger enabling the new context to produce larger impact on the historical bug revealing ingredient which in turn is more likely to trigger different jvm behaviorsandrevealnewbugs.specifically javatailorsearchesforthetype compatible variablesintheseedprogramwiththevariableingredient depth depth seed variable string s0 s class1 string str class2 c2 class2 int i float f int i float f .
string str s0 invoke method fun class1 c1 reusing seed variable creating new variables figure fix broken constraints missingitsdefinitionintheingredientfromthecodebeforethesyn thesispoint.ifsuchavariableisfound javatailorthenreplacesthe ingredient svariable withthe identifiedtype compatiblevariable in order to recover the broken constraints.
constructingnewdefinitions .notallthevariablesmissingdefinitionsintheingredientcanfindsuchtype compatiblevariablesin theseedprogram especiallywhenthevariabletypeisan object type.
at this time javatailor has to construct definitions for those variables in order to fix the broken constraints.
algorithm formally illustrates the definition construction process.
regarding the primitivetypes javatailordirectlyconstructsthecorresponding typesofvariableswitharandominitializationatline5.otherwise ifavariable stypeisan objecttype wecaninvokethecorrespondingconstructortodefinethevariableatline9 butitisalsovery likely to come across the parameters with other objecttypes in the constructor as shown in lines .
then javatailor is also required to define these parameters by invoking their constructors at line .
that is this process is recursive until all the requiredparameters are primitive types.
in particular to avoid costly or evenendlessrecursion javatailorsetsamaximalrecursiondepth denoted as d as the terminating condition in lines .
if the recursion depth exceeds d javatailor directly initializes the corresponding parameters as null.
figure shows a simple example to further illustrate the processoffixingbrokenconstraintsinjavatailor wheretheselected ingredient is a function call with a parameter c1of theclass1 type.
to create the definition of c1 javatailor first needs to create variables for the parameters of its constructor i.e.
string str authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yingquan zhao zan wang junjie chen mengdi liu mingyuan wu yuqun zhang and lingming zhang algorithm constructing new definitions input type the missing type depth current iteration depth output v newly generated variable 1function createvarwithtype type depth 2ifdepth dthen return null 4iftype t is primitive type or string then v randomly create variable with type t 6else cs identify all constructors of type ifcscontains non parameter constructor then v create variable with non parameter constructor else c randomly select a constructor in cs ts identify all parameter types of c foreach t tsdo pt pt createvarwithtype type t depth v create variable with candpt 16return v andclass2 c2 .
since there is a stringtype variable defined in seed program we reuse it at circlecopyrt.
however there is no variable of typeclass2defined in the seed program javatailor needs to recursively create variables of class2and its parameters of types intandfloatin the next recursion.
since the missing dependent variablesof class2areallprimitivetypes werandomlycreatea value for them at circlecopyrtand3 circlecopyrt.
then the variable of class2can be created at circlecopyrtand finally create the definition of class1 c1 at5 circlecopyrt.
after fixing those broken constraints javatailor inserts the processedingredientintothesynthesispoint.pleasenotethatjavatailorreplacesthe returninstructionswith gotoinstructionsinorder to avoid terminating the synthesized test program prematurely.
also it is necessary to assign a labelfor eachgotoinstruction.
toboosttheinteractionbetweentheingredientandtheseedprogram javatailor inserts the labelto the code belonging to the seed program.
.
synthesized program execution after generating a new test program via synthesis javatailor then executesitandcheckswhetheritrevealsajvmbugornot.here javatailor adopts differential testing as the test oracle which comparestheoutputsofdifferentjvmimplementations suchashotspot and openj9 with regard to this test program.
since a test program mayproducealargeamountofoutputs whichmayincludenondeterministicoutputs suchastime relatedoutputs itmayincur theinaccuracywhendetermininganinconsistency.moreover faced with the same exception different jvm implementations may also produce different stack traces further aggravating the difficulty of determining an inconsistency.
javatailorrelievesthischallengefromthefollowingthreescenarios if one jvm terminates normally while another jvm crashes javatailor regards it as an inconsistency without doubts if both jvm implementations crash during the execution of the same synthesizedtest program javatailor extractsthe exceptionmessagesfrom the producedstack traces by employingregular expressions such as identifying the lines including the keywords of exception errorandfailure in order to reduce the influence of different stylesofstacktracesproducedbydifferentjvmimplementations.
then if the extracted exception messages are different javatailor regards it as an inconsistency.
if both jvm terminates normally the outputs are also produced by the synthesized test program.
to reducethenoiseofdetermininganinconsistency javatailorfirst filters out some non deterministic messages by employing regular expressions suchasincludingthekeywordsof time randomand thread andsomecommontimeformats andthenfiltersoutthe messagesproducedbythethird partylibraries suchasjunitand log4j usedbythetestprogram.then iftheremainingoutputsarestilldifferent weregardsitasaninconsistency.regardingthelatter twoscenarios wefurthermanuallycheckwhethertheidentified inconsistencyisareallybugorafalsepositivebeforereportingit to the jvm s developers.
in particular if an inconsistency is a false positive we furtherdesign arule withregardto itand thenincorporate it in javatailor to further boost the accuracy of determining an inconsistency.
pleasenotethatifthereisnoinconsistencyidentifiedbyasynthesizedtestprogram javatailorputsitintothepoolofseedprograms.
in this way it can be used as a seed program for the following synthesis andthusatestprogramcombiningmultipleingredientsfromdifferenthistoricalbug revealingtestprogramscouldbegenerated which may be more helpful to reveal new jvm bugs.
evaluation in the study we aim to address the following research questions rq1 how does javatailor perform in detecting jvm inconsistencies?
rq2 can javatailor achieve higher jvm coverage?
rq3 are the ingredients extracted from historically bugrevealingtestprogramsmoreeffectivethanexistingmutation operators for jvm testing?
rq4 canjavatailordetectpreviouslyunknownbugsinthe latest jvm implementations?
.
evaluation settings subjects.
following the existing work we adopted two popularjvms i.e.
hotspot andopenj9 assubjects.table1shows thesubjectsusedinourstudy.wedidnotuseopenjdk9andopenjdk10 since they are no longer maintained in openj9.
we can find thatforeachopenjdkversion weusedonerelativelyoldbuildandone latest build for each jvm.
here to investigate the effectivenessofjavatailorbasedonmoresignificantresultsinstatistics weusedtheserelativelyoldjvmbuildsasthesubjectsundertestsincethey tend to contain more bugs.
we call an experiment based on therelatively old hotspot build and the relatively old openj9 build ofoneopenjdkversion adifferential testingexperiment.intotal we have five differential testing experiments due to evaluating on five openjdk versions.
regarding these latest jvm builds they areusedtodeterminewhetheraninconsistencydetectedbyjavatailor on the relatively old builds in a differential testing experiment is a real one by checking whether the inconsistency has been fixed by the latest jvm builds more details about it will be presented in the authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
history driven test program synthesis for jvm testing icse may pittsburgh pa usa table studied jvm implementations for differential testing openjdk versionjvm implementationjvm version build .
b70 hotspotbuild .
b10 build openj9 .
.
openjdk8 openj9build openj9 .
.
build hotspotbuild .
.
build openj9 .
.
openjdk11 openj9build openj9 .
.
build hotspotbuild .
.
build openj9 .
.
openjdk12 openj9build openj9 .
.
build hotspotbuild .
.
build openj9 .
.
openjdk13 openj9build openj9 .
.
build hotspotbuild .
.
build openj9 .
.
openjdk14 openj9build openj9 .
.
part ofevaluation metrics .
in particular we also applied javatailor to test the latest jvm builds to investigate whether it can detect previously unknown jvm bugs.
historicalbug revealingtestprograms.
wecollectedthetest programsrevealinghistoricalbugsfromthehotspottestsuite.this isbecauseitwellintegratesthebug revealingtestprogramsfrom its bug repositories and each bug revealing test program in its test suiteisequippedwiththecorrespondingbugdescription which isconvenientforustodistinguishwhetheratestprograminthe test suite is bug revealing or just a normal test.
in particular we removed the test programs that can reveal bugs directly on the subjects under test in order to clearly investigate the effectiveness of javatailor.
moreover we filtered out the test programs that cannot run successfully in our experimental environment.
finally we collected bug revealing test programs in total.
based on them javatailorextractsalargenumberofingredients i.e.
including17 716seqingredients 914ifingredients 122loop ingredients trap ingredients and switch ingredients.
seed programs.
wecollectedthebenchmarksthatwereusedin the existing jvm testing study and the test programs from the test suites of hotspot and openj9 as seed programs.
table showsthebasicinformationofourusedseedprograms.theformer six benchmarks are selected from the existing study and only one classfile the one including mainfunction in each of them is used as the seed program following the study .
there are someotherbenchmarksusedintheexistingstudy butthey cannot run successfullyin our experimental environment due to their old outdated versions.
the fourth column shows the number of jimple instructions in the seed programs for each benchmark.table benchmarks description idproject size inst iter p1 avrora p2 eclipse 20000p3 pmd p4 jython 6000p5 fop p6 sunflow p7 hotspot tests daysp8 openj9 tests days besides weconstructedtwointerestingscenariosbyusingthe test programs from the test suite of hotspot and openj9 as seed programs.first weusedtheabove630historicallybug revealing test programs from hotspot as seed programs which is helpful to investigatethepowerofintegratingvarioushistoricalbug revealing test programs.
second we also collected the test programs from the test suite of openj9 as seed programs which is interestingto investigatewhether the ingredientsfrom thetest programs inone jvm i.e.
hotspot can augment the effectiveness of the test programsintheotherjvm i.e.
openj9 .similarly wediscarded the test programs that can reveal bugs on our used subjects or cannot run successfully in our experimental environment.
in total we obtained test programs from the test suite of openj9 as seed programs.
compared approaches.
in the study we compared javatailor with the state of the art jvm testing approach i.e.
classming .
classming designs several mutation operators to minorlymodify a seed program aiming to alter the control and data flow of theseedprogram whichincludestheinsertionoffivekeywords goto return throw lookupswitch andtableswitch .different from the testing process of javatailor i.e.
for generating each test program it randomly selects an ingredient and a seed program forsynthesis classming incorporatesthemcmc markovchain montecarlo algorithmtoguidetheselectionofmutationoperators in order to iteratively mutate a given test program for generating a series of mutated test programs.
to further evaluate the contribution of our ingredient synthesis method we mitigate the difference of the testing process between javatailor and classming .
specifically we constructed a variant of javatailorbyreplacingouringredientsynthesismethodwiththe minormutationoperatorsproposedin classming whichiscalled javaming .
that is for generating each test program javaming randomly selectsamutationoperatorandaseedprogram andthen applies the mutation operator to the seed program to produce a newtestprogram.ifitdoesnotrevealajvmbug thistestprogram will be placed into the pool of seed programs for future selections.
implementation and environment.
we implemented javatailor based on openjdk8 a popular openjdk version and soot a mature program analysis tool for java classfiles that has been widely used in the existing work .
regarding using soot in implementing javatailor it definitely can be replaced with other libraries but we chose soot for a fair comparison with the state of the art classming whichis also implemented on soot .
in javatailor the maximal recursion depth i.e.
d of constructing authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yingquan zhao zan wang junjie chen mengdi liu mingyuan wu yuqun zhang and lingming zhang newdefinitionsissetto5.sincetheimplementationfor classming is not available we carefully re implemented it based on the descriptionintheexistingwork .allthesettingsareconsistentwith theexistingwork .inparticular weranourre implementation ofclassming accordingtothestudydesignofitsoriginalwork andindeedobtainedverysimilarresults whichdemonstratesthe validity of our re implementation.
all our experiments are conducted on a sever with two dodecacorecpusintel r xeon r silver4214cpu .20ghzand251gb ram running ubuntu .
.
lts bit .
the implementation of javatailor and our datasets can be found at our project homepage for future usage and replication.
evaluation metrics.
we considered three metrics to measure the effectiveness of javatailor.
the first one is the number of unique inconsistencies.
to answer rq1 we applied each jvm testing approachtoeachpairofjvmbuilds i.e.
thepairofrelativelyoldjvm buildsofhotspotandopenj9 ineachdifferential testingexperiments.
during the given testing period each approach may detect anumberofinconsistenciesbetweeneachpairofjvmbuilds.as presented in section .
an inconsistency may be a real bug or a false positive and we further ran each approach on the correspondingpairofthelatestbuildsofhotspotandopenj9inorder to check whether the inconsistency still exists or not.
if the inconsistency disappears we regarded it as a bug and this bug has been fixedinthelatestbuilds otherwise wefurthermanuallyinvestigatedittoobtaintheconclusionoftheinconsistency.also some inconsistenciesmaybeduplicatedduetothesamebug andthus we further de duplicated them according to the crash messages sincemostofinconsistenciesinvolvedthecrashesofatleastone jvm implementation in each pair in our study.
we call the number of inconsistencies after de duplication the number of unique inconsistencies.
relying on crash messages may not achieve perfect de duplication but it is the most widely used automatic method to identify unique failures in the existing work .
indeed it is a potential threat and we will design more accurate metrics in the future.
since we also applied javatailor to test the latest jvm builds in rq4 we cannot use the above method to automatically determinewhethereachdetectedinconsistencyisarealbugorafalse positive.
here we manually investigated them and then created andsubmittedabugreporttothecorrespondingbugrepositoryforeachpotentialbugafterourmanualinvestigation.then wecanobtainthe number of detected unknown bugs according to developers feedback which is the second metric in our study.
furthermore wefurthermeasured thetestcoverageofjvm that is the third metric in our study achieved by each approach inorder to deeply understand the effectiveness difference between javatailor and classming .
here we measured the widely used line coverage branch coverage and function coverage respectively.
.
process toanswerrq1 ineachdifferential testingexperiment weraneach approachforthesametestingperiodoneachbenchmark.forthe formersixbenchmarks theexistingworkproposing classming provides the number of iterations for each of them.
here we kept the samesettingfor classming toshowitsexpectedeffectivenessandrecordedthetestingtimespentoncompletingthecorresponding iterationsoneachbenchmark thenranjavatailorforthesametest ingtimeonthecorrespondingbenchmarkforfaircomparisonwith classming .
for the latter two benchmarks we ran each approach forthreedaysrespectively.since classming isaniterativeprocess on a seed program it is required to set the number of iterationson each seed program in the two benchmarks.
according to the formersixbenchmarks wecanobtainthatoneinstructionrequires iterations on average.
thus for the latter two benchmarks after selectingaseedprogram wesetthenumberofiterationsonitto the number of instructions of the seed program forclassming .
the testing process of each approach terminates after running for threedaysforfaircomparison.toanswerrq3 weran javaming following the same setting of rq1.
to answer rq2 we tookhotspot build internal for openjdk11astherepresentative fortestcoveragecollection.therunning process of each approach is consistent with the setting of rq1.tocollectthecoverageofhotspot wecompileditwiththe flag enable native coverage and then adopts gcov and lcov to collect and analyze the line coverage branch coverage andfunctioncoverageachievedbyeachapproach.inparticular we consider all the source code irrelevant to the underlying platforms in hotspot for coverage collection.
in total there are 978lines of code 173branches and 351functions.
toanswerrq4 weappliedjavatailortothelatestjvmbuilds and ran it on each differential testing experiment for a longer testing time i.e.
five days .
since manually analyzing and reportingeach unknown bug is time consuming especially the process ofreducing a bug revealing test program into a small but still bugrevealingone wechoseopenjdk8andopenjdk11astherepresentatives for testing in this experiment.
.
results and analysis .
.
rq1 effectivenessof javatailor.
table3 showsthe comparison results among javatailor classming andjavaming in terms of the number of detected unique inconsistencies.
bycomparingjavatailorand classming wefoundthatjavatailor is able to detect much more unique inconsistencies than classming foreachdifferential testingexperimentoneachbenchmark.bytak ingthedifferential testingexperimentforopenjdk8asanexample classming detectsunique inconsistencieson fourbenchmarksand thetotalnumberofuniqueinconsistenciesis35 whilejavatailor detects unique inconsistencies on all the eight benchmarks and the totalnumberofuniqueinconsistenciesisupto377.theimprovements ofjavatailor over classming rangefrom .
to .
acrossallthedifferential testingexperimentsexceptopenjdk14 onlyjavatailordetectsinconsistenciesonthisversionandthuswe cannot calculate the improvement on it in terms of the total number of unique inconsistencies on all the benchmarks.
the results demonstratethesignificantsuperiorityofourproposedapproach javatailor over the state of the art approach classming .
wefurtheranalyzedthereasonwhyjavatailorsignificantlyoutperformsthestate of the artapproach classming .thelatterfocuses onexploringvariouscontrol anddata flowoftheseedprogram based on the ingredients itself in an iterative way which actually limitsthe spaceof constructing testprograms.
differentfrom authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
history driven test program synthesis for jvm testing icse may pittsburgh pa usa table jvm inconsistencies detection effectiveness comparison idopenjdk8 openjdk11 openjdk12 openjdk13 openjdk14 c.m.
j.t.
j.m.
c.m.
j.t.
j.m.
c.m.
j.t.
j.m.
c.m.
j.t.
j.m.
c.m.
j.t.
j.m.
p p 2080020060000p 3092060010030010p 4080020120110000p 000p 0080050140010p7 0p8 total c.m.
and j.t.
are the abbreviations of classming and javatailor respectively6 figure inconsistency distribution by ingredient types table confirmed fixed unknown bugs bug id jvm affected versions status bug openj9 openjdk fixedbug openj9 openjdk fixedbug openj9 openjdk fixedbug openj9 openjdk confirmedbug openj9 openjdk confirmed jdk hotspot openjdk confirmed classming javatailorincorporatesvariousbug revealingingredientsfromhistorical testprogramstogeneratenewtest programs which not only can construct the test programs with diverse even bug revealing control and data flow but also enlarges the test programspacetoincreasethechanceofproducingbug revealing testprograms.
besides accordingto theresultson thebenchmark of hotspot s test programs javatailor detects much more unique inconsistenciesthan classming demonstratingthatcombiningvariousingredientsfromdifferenthistoricallybug revealingtestprogramsismoreeffectivethanjustindividuallyexploringeachhistoricallybug revealingtestprogram.accordingtotheresultson the benchmark of openj9 s test programs javatailor also detects a largenumberofuniqueinconsistencies showingthatthetesting capability of one jvm s test suite can be augmented by another jvm s test suite.
we also investigated whether each type of ingredients can help detect some unique inconsistencies whose results are shown in figure .
this figure presents the percentage of each type of ingredients resulting in the detection of unique inconsistencies.
here we integrated the results of all the differential testing experiments.
wefoundthateverytypeofingredientsareabletodetectunique inconsistencies.inparticular thereareasmallnumberofswitch ingredientsinourdataset i.e.
buttheyalsorevealedunique inconsistencies.thatdemonstratesthecontributionofeachtype of ingredients.
as expected for each type of ingredients the number of detected unique inconsistencies is strongly correlated to the number of thetype of ingredients in our dataset.for example weextractedthelargestnumberofseqingredientsandindeedit detected the largest number of unique inconsistencies.
.
.
rq2 jvm s coverage comparison.
we compared javatailor andclassming in terms of jvm s coverage including line coverage branch coverage and function coverage achieved by them respectively inordertofurtherexplainwhyjavatailorperforms better than classming .
figure shows the coverage comparison results wherethe graylines presentthe coverage achievedby the seedprograms andthegreenandyellowlinespresentthecoverageachievedbyjavatailorand classming onthebasisoftheseed programsrespectively.wefoundthatregardlessoflinecoverage branchcoverage orfunctioncoverage theimprovedcoverageby classming overtheseedprogramsisverysmalloneachbenchmark indicating that just altering control and data flow of the seed programs based on their own ingredients is hard to bring large jvm coverage increments.
regarding javatailor its improved jvm coverage over both classming and the seed programs is obvious on all the benchmarks except p7 .
the results demonstrate that incorporatingmoreingredientsfromothertestprogramsintothe seedprogramsaremorehelpfultoimprovejvmcoverage resulting in the detection of more unique inconsistencies than classming .
the reason for p7 is that both the ingredient pool and the seed programs are from the same test programs in the hotspot s test suite leadingtothesmallcoverageincrements.however wecan observethattheimprovementintermsofbranchcoverageonp7is larger than that in terms of line coverage and function coverage indicating thatcombining variousingredients from differentbugrevealingtestprogramsfacilitatestocoveragemoreinterestingjvm branches paths and thus can reveal more unique inconsistencies.
.
.
rq3 comparisonbetweenjavatailorandjavaming.
wefurthercomparedouringredientsynthesismethodandexistingminor mutationoperatorsbymitigatingtheinfluenceofthetestingprocessbycomparingjavatailorand javaming .thecolumns j.t.
and j.m.
intable3showthecomparisonresults.weobtainedthesimilarconclusionswithrq1 i.e.
javatailordetectsmuchmoreunique inconsistencies than javaming .
the improvements of javatailor overjavaming range from .
to .
across all the differential testingexperimentsexceptopenjdk14 onlyjavatailordetect inconsistencies on this version in terms of the total numberofuniqueinconsistenciesonallthebenchmarks demonstratingthe significant superiority of our ingredient synthesis method over the existingelaboratelydesignedminormutationoperators.inaddition classming performsbetterthan javaming ingeneral demonstrating authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yingquan zhao zan wang junjie chen mengdi liu mingyuan wu yuqun zhang and lingming zhang figure jvm code coverage comparison public static method main ljava lang string v stack locals new class java util arraylist dup invokespecial method java util arraylist.
init v astore 0 stores arraylist ... l13 stack frame type full aload 0 loads arraylist checkcast class java util list compares string with list ... if icmplt l13 getstatic field system.out ljava io printstream ldc string success invokevirtual method ...println ljava lang string v return figure openj9 bug the effectivenessof the mcmc based testingprocess in classming .
that further motivates a promising direction of improving javatailorthroughdesigningmoreeffectivestrategiestoguidetheprocess of test program synthesis which will be discussed in section .
.
.
rq4 unknown bugs detected by javatailor.
we also applied javatailortotestthelatestbuildofbothhotspotandopenj9fortwo most popular openjdk versions i.e.
openjdk8 and openjdk11 .
during the test time of five days javatailor detects unknown bugsand6havebeenconfirmedorfixedbydevelopers whileclassmingandjavamingdidnotdetectanyunknownbugs.onepossiblereasoncouldbethatclassminghasappliedagainstthejvmsbefore making them immune to the classming like approaches.
table showsthedetailedinformationfortheconfirmed fixedunknown bugs detected by javatailor.
in particular all these bugs cannot be detectedby classming andjavaming basedonourusedbenchmarks duringthegiventestingperiod.wethenusedoneunknownbug as en example for further illustration.
figure8showsanopenj9bug bug detectedbyjavatailor whichisrepresentedbyjasm abytecode likeassembly language that allows testers to reorganize bytecode order in a specific way .
in this example lines corresponding to the system.out.println success statementintheseedprogram which should be executed and output success .
however this statementwasnotexecutedonthelatestopenj9 forbothopenjdk8andopenjdk11 duetoabugintheopenj9 soptimizer.lines 13oftheinsertedcodecontainacomplexnestedloop.duetothe space limit we only showed the outermost loop.
openj9 optimizes this complex loop for better execution performance.
specifically jvm stores the first parameter if exists of the staticfunction i.e.
string in themainfunction at line to the local variable table at index and then this local variable is overwritten by an arraylist atline7.sincetheoptimizerofopenj9assumesthat the types of these parameters in the local variable table will not change during execution it compares string withlistat line but actually should compare arraylist withlist.
then the optimizer believes that the checkcast must fail due to impossible conversion between string andlist and thus removes all theinstructionsafterthe outermostloop causingthat success cannot be outputted.
the developers of openj9 fixed this bug by makingthefunction sparametersinthelocalvariabletablebecome changeable during the optimization process since these types may bechangedduringexecution.notethat classming failedtodetect thisbug since1 classming cannotintroducesuch acomplicated loop into the seed program it cannot introduce the instructions that overwrite the local variable table into the seed program.
discussion .
future work first as presented in section .
.
regarding classming mcmcbasedmutationismoreeffectivethanrandommutation andthusit maybehelpfultoimprovetheperformanceofjavatailorbydesigning an effective strategy for guiding synthesis.
the strategy should guidetoselectbothaningredientandaseedprogram aswellas thesynthesispointintheseedprogram.second inourstudywe cameacrossonecommonbutinterestingtypeoffalsepositives i.e.
hotspot and openj9 have different implementations for the same openjdk specification but both of them believe they conform the specification.therootcausemaylieinthatthespecificationisabit general.
in the future we may report such kind of inconsistencies to openjdk for further understanding.
third although we eval uatedjavatailoronjvmimplementations theideaofjavatailoris actually general.
this idea could be generalized to other softwaretakingprogramsastestinputs suchascompilers symbolic executors and database as long as there are a large number of test programs revealing historical bugs that can be collected.
.
threats to validity theinternalthreattovaliditymainlyliesintheimplementationsof javatailorand classming .toreducethiskindofthreat twoauthors carefully checked all code and we implemented them based on the mature tool soot.
regarding the re implementation of classming authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
history driven test program synthesis for jvm testing icse may pittsburgh pa usa we implemented it according to the description in its paper and checked its correctness by reproducing its original evaluation.
the external threat to validity mainly lies in the benchmarks andhistoricallybug revealingtestprogramsusedinourstudy.in ourstudy weusedsixbenchmarksfromtheexistingstudy and constructedtwobenchmarksbasedonthetestsuitesofhotspotand openj9.also wecollected630testprogramsrevealinghistorical hotspot s bugs from its test suite.
to further reduce this kind of threat we will evaluate javatailor on more benchmarks and the test programs revealing other jvm s bugs.
the construct threat to validity mainly in the randomness involved in those approaches.
to reduce this threat we conducted fivedifferential testingexperimentsinsteadofrepeatingoneexper imentseveraltimes.indeed ourresultsdemonstratethatjavatailor stably outperforms classming in all the five experiments.
related work since the first work on fuzzing various techniques have been proposedforfuzzingsoftwaresystemsfromdifferentapplication domains .whileallsuchtechniquesarerelated tothiswork wemainlytalkaboutthemostcloselyrelatedworkin the areas of jvm testing and compiler fuzzing in this section.
jvm testing.
due to the crucial role of jvm both industry and academiaproposedvarioustestingtechniquestoensurejvm squality .
besides classming andclassfuzz introduced before sirer et al.
proposed lava whichgenerates test programs basedon the production grammar.
yoshikawa et al.
proposed a random testprogramgeneratortotestthejitcompiler.freundetal.
developedaspecificationtoverifybytecodeverifiersintheformof atypesystem.calvagnaetal.
usedafinitestatemachine modelofthe jvmspecificationtoassesstheconformance ofjvm.
hwang et al.
proposed justgen which designs a set of domainspecificlanguagesandgeneratestestprogramsbyidentifying unspecified cases from the jni specification.
all of them except classming andclassfuzz target one componentinjvm.differentfromthem javatailorisindependentofacertain component in jvm.
for example our collected historicalbug revealing test programs for ingredient extraction cover the testingofawiderangeofjvmcomponents suchasc1 clientcompiler c2 server compiler andgc garbage collection .different fromclassming andclassfuzz javatailorsynthesizestheingredients extractedfrom historicalbug revealing testprograms withaseed programtoproducevalidnewtestprograms andourexperimental resultshaveshownthatjavatailorsignificantlyoutperformsthestate of the art classming .
in actual javatailor can be combined with existing research such as concurrency testing to target different components in jvm.compiler testing.
similar to jvm the test inputs of compilers are also programs andthus we also brieflyintroduce the related work on compiler testing .
for example yang et al.
proposed csmith which generates c programs based on the grammar of the c language.
lidbury et al.
proposed clsmithonthebasisofcsmithforopenclcompilertest program generation.
chen et al.
.
proposed hicond which useshistoricaldatatoinferasetofbug revealingtestconfigurations foreffectivetestprogramgeneration.leetal.
proposed emi whichgeneratesaprogramvariantequivalenttotheoriginaltest program under the given test inputs and then uses these program pairstotestcompilers.basedontheideaofemi researchersfurtherproposedathena andhermes .differentfromthem javatailor targets jvm testing by mining the ingredients in historical bug revealing test programs and then inserting them to a seedprogramfortestprogramgeneration.suchhistory driventest program synthesis is also novel in the area of compiler testing and could be generalized to this area as discussed in section .
.
conclusion inthispaper weproposeahistory driventestprogramsynthesis approach called javatailor.
it first tackles the challenge of extractingingredientsfrombug revealingtestprogramsbydesigningfive types of ingredients.
then it inserts these extracted ingredients intoseedprograms andautomaticallyfixesthebrokensyntactic and semantic constraints in the ingredients in order to produce valid synthesized programs.
finally these synthesized programs areusedtodifferentiallytestjvms.weconductedextensiveexperiments on popular jvm implementations i.e.
hotspot and openj9 toevaluatetheeffectivenessofjavatailor.theexperimentalresults demonstrate that javatailor significantly outperforms the state of the art technique.
that is javatailor can achieve higher jvm code coverage and expose more unique inconsistencies.
moreover javatailor found unknown bugs that have been confirmed or fixed by developers.
acknowledgment wethankalltheicseanonymousreviewersfortheirvaluablecomments.
we also thank all the jvm developers for analyzing andreplying to the bugs we reported.
this work is partially fundedby the national natural science foundation of china grant no.
and the tianjin intelligent manufacturing special fund project grant no.
.
this work is also partially supported by national science foundation under grant nos.
ccf2131943 and ccf as well as ant group.