symtuner maximizing the power of symbolic execution by adaptively tuning external parameters sooyoung cha sungkyunkwan university republic of korea sooyoung.cha skku.edumyungho lee korea university republic of korea myungho lee korea.ac.krseokhyun lee korea university republic of korea seokhyunlee korea.ac.krhakjoo oh korea university republic of korea hakjoo oh korea.ac.kr abstract we present symtuner a novel technique to automatically tune externalparametersofsymbolicexecution.practicalsymbolicexecution tools have important external parameters e.g.
symbolic arguments seed input that critically affect their performance.
due tothehugeparameterspace however manuallycustomizingthose parameters is notoriously difficult even for experts.
as a conse quence symbolic execution tools have typically been used in a suboptimalmannerthat forexample simplyreliesonthedefault parametersettingsofthetoolsandlosestheopportunityforbetterperformance.inthispaper weaimtochangethissituationby automatically configuring symbolic execution parameters.
with symtuner that takes parameter spaces to be tuned symbolic executors are run without manual parameter configurations instead appropriate parameter values are learned and adjusted during symbolicexecution.toachievethis wepresentalearningalgorithm thatobservesthebehaviorofsymbolicexecutionandaccordingly updatesthesamplingprobabilityofeachparameterspace.weevaluatedsymtunerwithkleeon12open sourcecprograms.the resultsshowthatsymtunerincreasesbranchcoverageofkleeby onaverageandfinds8morebugsthankleewithitsdefault parameters over the latest releases of the programs.
acm reference format sooyoungcha myungholee seokhyunlee andhakjoooh.
.symtuner maximizingthepowerofsymbolicexecutionbyadaptivelytuning external parameters.
in 44th international conference on software engineering icse may21 pittsburgh pa usa.
acm newyork ny usa pages.
introduction decadesofresearchhavetransformedsymbolicexecutionintoa mainstreamtechniqueinsoftwaretesting.thebasicideaofsymbolic execution is to replace program inputs by symbolic variables andexploretheexecutionpathsofaprogramsymbolically.sinceitsinception symbolicexecutionhasbeenanactiveresearch area .inparticular thelastdecadehasseenremarkableadvances significantly mitigating main challenges such as path explosion corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
klee simplify sym indices max memory optimize use forked solver use cex cache external calls all max sym array size max instruction time 30s max time 60min max memory inhibit false max static fork pct max static solve pct max static cpfork pct switch type internal search random path search nurs covnew batch instructions .
pgm.bc sym args011 sym args022 sym files sym stdin sym stdout ... figure the parameter setting of klee used in and constraint solving .
equipped withthese techniques symbolic executiontools such as klee have become publicly available and widely used in both academia and industry .
despitetheprogress however maximizingtheperformanceof modernsymbolicexecutiontoolsisnotoriouslydifficultinpractice.
onemainreasonisthatstate of the artsymbolicexecutorshave a number of important external parameters that critically affect theireffectiveness.forexample figure1showsatypicalcommand for running klee which was tailored to gnu coreutils by the originalauthorsofklee .theseparameters forexample aretoselectwhichsearchstrategytouse todecidethesymbolic arguments andtochoosethememorybudget.itiswell knownthat these parameters have a huge impact on the runtime performance of symbolic execution and therefore must be carefully tuned for each target program .
manuallytuningsuchparametersischallengingevenforexperts.
note that more than half of the parameters in figure are of nonbooleantypes e.g.
stringorinteger andtheircombinationinduces an enormous search space.
consequently klee has typically been used without proper configuration of those parameters existing workseither simplyrelyontheparametersettinginfigure1 evenforprogramsbeyondcoreutils or manually tunespecificparameters e.g.
symbolicarguments atopthedefault parametervalues .recently afewtechniques have been proposed for tuning search heuristics automatically but other critical parameters still need to be configured manually.
in this paper we present symtuner a novel technique for automatically tuning symbolic execution parameters.
initially from the users symtuner takes as input the sample spaces for the parameterstobetuned.then with symtuner symbolicexecutiontools such as klee can be run without manual parameter tuning appropriateparametervaluesforthetargetprogramareautomatically adjusted by symtuner during symbolic execution.
to do so along ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa sooyoung cha myungho lee seokhyun lee and hakjoo oh the symbolic execution process symtuner uses a custom learning algorithmthatrepeatedlysamplesasetofparametervaluesfrom thesamplespaces evaluatestheperformanceofsymbolicexecution withthesampledvalues andrefinestheprobabilitydistributions of the sample spaces based on the evaluation result.
experimentalresultsshowthatsymtunerremarkablyenhances symbolicexecutionintermsofbothcodecoverageandbug finding.
we applied symtuner to klee a representative symbolic execution tool for c programs and evaluated it on the latest versions of12gnuopen sourceprograms rangingfrom5kto161kloc .
klee with symtuner covered and morebranches on average than conventional klee with its default parameter values andtheparametersettinginfigure1 respectively.also symtuner enabled klee to discover different bugs that cause the latest versionsoftheopen sourceprogramstocrash faroutweighingthe conventionalkleethatendedupfindingthreeofthem.compared to klee with anaive approach that randomly samples parameter values symtuner succeeded in increasing the number of covered branches and found bugs by and respectively.
we also show that our approach is also applicable to crest a tool for concolictesting anothermajorapproachofsymbolic execution.
contributions.
we summarize our contributions below we present symtuner a new technique for automatically tuningdiverseparametersofsymbolicexecution.thekey technicalcontributionis thedomain specificlearningalgorithm for symbolic execution which observes the behavior ofsymbolicexecutionwithrandomlysampledparameters and gradually learns to sample effective parameter values.
weconductextensiveevaluationof symtuner on12gnu open source programs.
we make our tool symtuner opensourced and the benchmarks publicly available.
preliminaries .
basic symbolic execution symbolic execution explores the execution paths of a program by maintaining a set of program states where a state is a triplet instr store of an instruction instr to be executed a symbolic memorystore store mappingprogramvariablestosymbolicvalues andapathcondition thatisasequenceofsymbolicbranches representing the path exercised by the current state.
algorithm1describestheoverallalgorithm.ittakesasinputa program pgm atestingbudget budget andavectorofparameter values v .
for the moment let us ignore the last input the role of the parameters v will be described in section .
.
at line the algorithm creates the set of initial states i.e.
a singleton set of the initial state s0 instr0 store0 true where instr0denotes the first instruction of the program and store0is the initialsymbolicmemory.theset toftestcasesisinitiallyempty line3 .afterinitializing sandt symbolicexecutiongoesintothe loop at lines .
at line symbolic execution selects a state sfromsto navigate deeper into the program and removes sfroms line .
at line7 theinstructioninthecurrentstate instr store isexecuted 1symtuner symbolic execution input program pgm budget budget and parameter values v .
output a set of test cases t procedure symexecutor pgm budget v s s0 s0 instr0 store0 true t test cases repeat s choose s s instr store s s s s prime execute s s prime instr prime store prime ifinstr primeis a branch whose condition is then ifsat then true branch is reachable s s instr1 store prime ifsat then false branch is reachable s s instr2 store prime else ifinstr primeis a halt instruction then t t model generate a test case untilbudgetexpires or s returnt producing the next state instr prime store prime .i finstr primeis a branch instruction whosecondition is thealgorithm checkswhether the both sides of the branch are reachable from the current state.
if thetruebranchisreachable i.e.
sat weaddtheupdatedstate instr1 store prime tos line where instr1denotes the first instruction in the true branch.
similarly we add the updated state for the false branch to swhen the path condition i.e.
issatisfiable line12 .when instr primeisahaltinstruction line13 a test case is generated from the model of the current path condition.
thesymexecutor procedurerepeatsthe processdescribedsofar untilthegivenbudgetexpires.upontermination theset toftest cases is returned.
.
parameters of symbolic execution although the basic algorithm is simple real world symbolic executiontoolsinvolvevariousparametersthathaveacriticalimpacton the performance of algorithm .
for example symbolic executors suchasklee takeaparameterthatdetermineswhichprogram inputs to be replaced by symbolic variables e.g.
sym args in figure in algorithm the initial symbolic memory store0 i s defined by this parameter value.
another example is a parame ter that specifies the maximum memory capacity available e.g.
max memory infigure1 whichisanimportantfactorinpractice asstateexplosionfrequentlyoccurswhenrunningsymbolicexecu tiononsizableprograms.the choosefunctionitselfatline5isalso a parameter called search heuristic and users of klee canchoosefrom10differentoptions e.g.
search nurs covnew in figure and interleave them.
the constraint solver used bythe satandmodelfunctions in algorithm can be configured as well for example users can decide which smt solver to useand fine tune their behavior.
figure shows that klee also providesvariousparameters including max instruction time and batching instructions which have a large space e.g.
integer .
manually tuningthose parametervalues is sonontrivial that it hasbeentypicaltousesymbolicexecutionwithoutproperconfiguration .
the goal of this paper is to authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symtuner maximizing the power of symbolic execution by adaptively tuning external parameters icse may pittsburgh pa usa figure overview of symbolic execution with symtuner change this unfortunate practice by automating the task of tuning parameters of symbolic execution.
our approach figure2illustrateshow symtuner andsymbolicexecutioninteract.
initially symtuner takeskpredefinedparameterspacesasinput where a parameter space prescribes possible values that the parameter can take on.
at a high level symtuner iteratively samples kparametervalues basedon thelearned probabilitydistributions of the parameter spaces and runs symbolic execution with the sampled parameter values.
as output of symbolic execution a set of test cases is generated which is in turn used for adjusting the probability distributions of the sampling spaces.
during the first few times symtuner focuses on exploration by running symbolic executionwithvariousrandomparametervalues.onceanadequate number of test cases is collected symtuner starts to update the sampling probabilities and exploit the learned knowledge.
symtuner worksinthreephases evaluate extract andupdate.
thefirststepproduceslearningdatabyevaluatingthequalityof the parameter values used for generating each test case in terms of both code coverage and found bugs.
the aim of the second step extract is to identify meaningful data from the total amount of datageneratedbythefirststep.usingtheextracteddata thelast step update updatestheprobabilityofhow symtuner samples fromthekparameterspaces.byrepeatingtheaboveprocesswhich interleaves symtuner and symbolic executor the sampling probabilitiesaregraduallyupdated.upontermination i.e.
hittingatime limit the set of all test cases generated so far are returned.
.
parameter space basically wedefinethesamplespaceofeachparametertobediscrete rather than continuous to circumvent unnecessarily large searchspace.forinstance supposethatwedefinetheparameter spaceformemorybudget mb asallintegersbetween100and2000.
onthebasisofaparametervalue e.g.
1000mb inthespace the adjacent values such as 999mb and 1001mb are unlikely to have asignificant impact on the performance of symbolic execution compared to the farther values e.g.
500mb 2000mb thus our sample space for each parameter is discrete to maintain only the values which are likely to affect performance.
in our approach we assume that kpredefined parameter spaces denoted s s1 s2 sk aregiven.eachspace si i k for thei th parameter consists of two components si svi max i wheresvi sv1 i sv2 i svn i is the set of possible parameter valuesfor siand max idenotesthemaximumnumberoftimesto samplefromtheset svi.formostparameterspaces maxis1as aparametervalueistypicallyusedonlyonceduringasinglerun of symbolic execution e.g.
max memory in figure .
in general however it can be bigger than .
for example the value of max for symbolic arguments can be any natural number as we can use multiple symbolic arguments with different size in a single run e.g.
sym args in figure .
for instance the parameter space for symbolic arguments can be given as follows sargs .
which means we can select up to three symbolic arguments where each argument has the length of one of the elements in .
.
.
sample.
to sample from each predefined space si let us define and use the following samplefunction sample si pc i pi pvi the inputs are a parameter space siand two probability functions piandpc i. the former pi svi denotes the sampling probability of each parameter value in sviand the latter pc i max i representstheprobabilityforthesamplingtimes.
wedenotetheoutputof samplebypvi svi whichisaset ofsampledparametervalues.here weallow pvitobeamultiset that has duplicated elements and we abuse the notation svi to denote the set of all sub multisets of svi.
to obtain pvifrom the space si thesamplefunction first determines the number m of sampling times based on the probability pc i. then we sample a candidate value from sviformtimes using the probability piand addthevalueto pvi.forinstance whenthe samplefunctiontakes theparameterspace sargsshownabove thepossibleoutcomesof sample i.e.
pvargs are as follows where denotes a multiset that allows duplicated elements.
sincethetwoprobabilitiesinthe samplefunctiondeterminethe parametervaluesusedwhenperformingsymbolicexecutiononthe target program the most important question is how to learn these probabilities pc iandpi for each parameter space si i k t o maximizetheperformanceofsymbolicexecution.toresolvethis symtuner learnsthoseprobabilitiesbasedonthedataaccumulated during symbolic execution.
.
symbolic execution with symtuner tolearnparametervalues weperformsymbolicexecutionmultiple times with diverse parameter values by dividing the total time budget into smaller budgets.
it enables symtuner to interact with symbolic executor multiple times during the given time budget and to gradually find more effective parameter values through the multipleinteractions.wedescribehow symtuner interactswith symbolic executor algorithm in detail.
algorithm2takesasinputaprogram abudget and kpredefined parameter spaces.
at lines the algorithm first initializes each of the following four components to an empty set or vector the vectorv sv1 sv2 svk ofparametervalues recall svi denotes the set of all sub multisets of svi the set dof learning data the set tof test cases and the set totaltof authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa sooyoung cha myungho lee seokhyun lee and hakjoo oh algorithm symbolic execution with symtuner input program pgm budget budget kparameter spaces s .
output test cases totalt angbracketleftv d t totalt angbracketright angbracketleft angbracketleft angbracketright angbracketright dis learning data flag budgets budget ratio ratio .
repeat fori 1to stepdo step v d symtuner t s v d flag t symexecutor pgm budgets v totalt totalt t flag budgets budgets untilbudgetexpires returntotalt accumulated test cases.
then the flagvalue is also initially set to line the value of makes symtuner focus only on exploration bytryingdiverseparametervaluesinthe kparameterspaces.at thenextline thealgorithminitializesthetimebudget budgetsfor a single run of symbolic execution by multiplying the total testing budgetbudgetand the hyper parameter ratio.
in the experiments we set the hyper parameter ratioto a small value such as .
.
atlines5 symbolicexecutorand symtuner iterativelyinteract with each other by exchanging test cases and parameter values.
at line symtuner takes five input values test cases t parameterspaces s previouslyusedparametervalues v learningdata d andflag flag andreturnsaccumulatedlearningdatawith newly sampled parameter values at first symtuner generates the parametervaluesbyrandomlysamplingfromthepredefinedspaces s line .
then the symexecutor is run with the program the currenttimebudget andthenewparametervalues.asoutputof symbolic execution a set tof test cases is produced line .
at line8 weaccumulate tintheset totaltoftotaltestcases.afterthe firstinteractionbetween symtuner andsymexecutor isrepeated steptimes lines the algorithm sets flagto which indicates thatsymtuner isreadytoperformonlinelearning.inexperiments weset step .atline10 itdoublesthesizeofthetimebudget budgetsas more learning data accumulation increases the confidenceinhowtotuneparametervalues.theouterlooprepeatsuntil the total time budget budget is exhausted.
upon termination the algorithm returns as the final output the accumulated test cases.
.
symtuner algorithm describes how symtuner generates the set dof learning data from the set tof test cases and how it updates the sampling probabilities of the parameter spaces based on d.symtuner worksinthethreesteps evaluate extract andupdate.aftergoing throughthesethreesteps itreturnsasoutputthevector v primeofnew parameter values and d. .
.
evaluate.
thegoalofthefirststepistoevaluatethequality oftheparametervector vusedforgeneratingthetestcases tin terms of code coverage and detected bugs.
to this end symtuner generates data dfor each test case t t lines .
a single data dis represented by the quadruple br bu t v wherebrandbuarethesetsofbranchescoveredandbugstriggeredalgorithm symtuner input test cases t spaces s values v data d flag flag output new parameter values v prime and data d procedure symtuner t s v d flag step evaluate the quality of test cases for each t tdo d d d d evaluate t v step extract effective parameter values from data d corev totalv extract d step update sampling probabilities policy sample from exploit explore with prob v prime angbracketleft angbracketright fori 1tokdo s s1 s2 sk if policy explore or flag then pc i pi explore totalv si else pc i pi exploit corev totalv si pvi sample si pc i pi v prime v prime pvi appendpviat the end of v prime returnv prime d by the test case t respectively.
we identify a bug with an error location a pair of the function name and the line number e.g.
foo .
to obtain the two sets brandbu theevaluate function at line executes the program with each test case tand performs a coverage analysis e.g.
using gcov .
the evaluate function takes as inputasingletestcase tandavector vofusedparametervalues and returns data das output.
symtuner collects all data in d. .
.
extract.
aftersymtuner obtainstheset dofdata itmoves ontothenextstep extract whereitextractsaslearningdatatwo sets corevandtotalv of parameter value vectors from cored andd respectively.
intuitively the set coredincludes only core elements of d which we define as the smallest subset of dthat covers allbranches andall bugs in d. toconstruct cored wefirst compute the set d d argmax d prime d uniondisplay.
br bu d prime br unionmultibu .
where argmax denotes the set of all possible arguments which maximizethegivenobjective e.g.
thenumberofcoveredbranches and detected bugs and unionmultidenotes the disjoint union.
from the setd we define the set coredto be the smallest one in d i.e.
cored argmind prime d d prime here we assume argmin returns an arbitrarysingleargumentthatminimizesthegivenobjective .in otherwords coredrepresentstheminimumsubsetof dthatcollectively maximizes the number of covered branches and found bugs.
for instance suppose that the data dhas four elements d b1 b2 b5 b5 foo b1 b2 b3 b4 b2 b3 b4 whereeachelementin dconsistsofaquadrupleofasetofcovered branches asetofbugs atestcase andavectorofparametervalues.
from the set d we can extract coredas cored b5 foo b1 b2 b3 b4 .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symtuner maximizing the power of symbolic execution by adaptively tuning external parameters icse may pittsburgh pa usa calculating coredcorrespondstosolvingthesetcoverproblem whichis awell known np completeproblem.
we compute cored usingagreedyalgorithmthatiterativelyselectstheelementhaving the largest number of uncovered branches and bugs at each stage.
fromcoredandd we collect the learning data corevand totalv.
we first obtain the set corevof effective parameter values incoredas follows corev v v cored .
note that we deliberately define the set corevas a multiset to tracktheinfluentialparametervaluesmoreeffectively.forexample supposethat corevis v1 v2 v1 wherev1isduplicated.since the existence of duplication implies that the duplicated value is usedmorethanonceintheset cored wecanconcludethat v1is the vector of more influential parameter values than v2in terms of performance.
we also collect the set totalvof all parameter values used in the accumulated data das totalv v v d .
note that the set totalvis a standard set which does not allow duplicated elements.
the extractfunction returns as output the two setscorevandtotalvfor the final step.
.
.
update.
the aim of last step is to update sampling probabilities of parameter spaces based on the extracted data corev andtotalv andtogenerateanewvector v primeofparametervalues using the updated probabilities.
more specifically we update the probability functions piandpc iby using the following two policies exploreandexploit.ingeneral theexplorationpolicy explore gives more opportunities to parameter values which have beenused less frequently.
on the other hand the exploitation policy exploit increases the probabilities for parameter values with good performance while taking into account the number of times the valueshavebeenused.asbalancingexploitationandexploration is a well known important problem based on trial and error weset the sampling probability of exploitandexploreto be70 and respectively that is we set the hyper parameter to .
at line in algorithm .
exploration.
whentheselectedpolicyis exploreorthevalue offlagis line symtuner updates the probability for the i th parameterspace sibyusingthe explorefunction line14 andthen samples the i th parameter value by using the samplefunction line .
the explorefunction takes as input the set totalvof all parameter vectors used before and the i th parameter space si svi max i and returns as output the updated probability functions.
toupdatethesamplingprobability explore totalv svi max i first scores each value v primeinsvias follows scorei v prime v totalv v prime vi wherevidenotesthe i thelementofvector v.thedenominator isthenumberoftimesthevalue v primeisusedasthe i thcomponent duringthesymbolicexecutionsofar.whenthevalue v primeisnever used i.e.
dominator wegiveahighestpossiblescorefor v prime.the intuition is that we give higher scores to parameter vectors that have been used less frequently so that symtuner explores unseenparametervalues.with scorei wedefinetheprobabilityfunction pi svi as follows pi v prime scorei v prime summationtext.
sv sviscorei sv the probability is the normalized score of v primedivided by the sum of the scores of all parameter values in svi.
intuitively if the number of all distinct parameter values used is the same the sampling probabilityisevenlydistributed symtuner samplestheparameter values at complete random in this case.
likewise toobtaintheprobability pc iofthenumberofsampling inthei thspace si svi max i wecalculatethescoreforeach numberm primeof sampling m prime max i usingscorec idefined as scoreci m prime v totalv m prime vi the denominator is the number of times the value m primeequals to the sample size vi .
we compute pc i max i as follows pc i m prime scoreci m prime summationtext.
m max iscorec i m at lines with the two updated probabilities piandpc i the algorithm generates new i th parameter value pviusing the samplefunction and then adds pvito the vector v prime.
exploitation.
besidesexploration weemployanexploitation policy exploit tolearnthesamplingprobabilitiesofeachparameter space lines .
the policy uses the exploitfunction which increases the sampling probability of the values that have been used more often as influential parameter values in corev.
basically theexploitationmethodcomputestheprobability pi ofeachparameterspaceinthesamewayastheexplorationmethod.
the scoring function however is different and defined as follows scorei v prime v corev v prime vi v totalv v prime vi intuitively the score for the value v primeindicates how often v primeis usedasinfluentialparametervaluesin corev.moreprecisely the numerator represents the number of times the value is used in the i th componentin theset corev.
notethat wedivide thisnumber by the total number of times the value has been used preferring parametervalueswithhigher hitrates insteadofjustpreferring parametersin corevsimplybecausetheyhavebeentriedfrequently.
similarly we define the score function scorec iforpc ias follows scoreci v prime v corev v prime vi v totalv v prime vi after the score calculation the exploitpolicy updates the probabilitiespiandpc iusingtheequations and atline16.then it generates new i th parameter value based on the samplefunction.
through the three steps evaluate extract andupdate algorithm accumulates the set dof learning data and returns it as output.byrepeatingalgorithm3 theset discontinuouslyupdated andsymtuner graduallymakesasmartdecisiononhowtosample kparameter values from kpredefined parameter spaces towards maximizing the performance of symbolic execution.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa sooyoung cha myungho lee seokhyun lee and hakjoo oh experiments in this section we experimentally evaluate the effectiveness of our approach.
research questions are as follows coverage how effectively does symtuner enhance symbolic execution in terms of branch coverage?
bug finding does the interaction between symtuner and symbolic executor enhance the bug finding ability?
impact of parameters and the spaces what is the most influential parameter?
how does the performance of our approach change depending on different parameter spaces?
generality issymtuner applicable to concolic testing another approach to dynamic symbolic execution?
weusedklee 2asabasesymbolicexecutortointeractwith symtuner becausekleeisoneofthemostpopularandactively maintained symbolic execution tools available today.
all experiments were conducted on a machine with two intel xeon gold 6230r and 256gb ram.
.
experimental settings .
.1predefined parameter spaces.
symtuner takes as input predefined parameter spaces s .
in our experiments we aimed to tune all more precisely parameters in figure where their typesconsistof7integer 3double 4string and6booleantypes.in particular for the first parameters which are not boolean types we defined their spaces as ssearch s1 s2 s10 sargs sfiles sstdin smem sbatch sinstr time sarray size sfork scpfork ssolve .
.
sswitch simple internal sseed sexternal concrete all therationalebehindthespacesistwofold.first foreachparameter we simply chose values around the value used in figure .
second we tried to subsume the settings used in prior work .
in the first space s search s1 ... s10denote the ten search strategies implemented in klee.
note that we also tuned the seed input parameter seed file not involved in figure as itsimpactontheperformanceofsymbolicexecutioniswell known in the literature .
despite its importance however it is not appropriate to predefine the seed sample space e.g.
sseed because the corpus of seed inputs highly depends on the program under test which requires additional manual efforts for the end users to use symtuner .
thus we did not predefine sseed but let it be dynamically determined during symbolic execution.
more precisely on every iterationof theloopat lines5 in algorithm2 symtuner calculatestop 20testcasesintermsofcoveredbranches anddetectedbugs andupdates sseedwiththem.thatis unlikeother predefined spaces the candidate values in sseedmay change as the learning progresses.
2we used klee .
released in march .table benchmark programs programs loc of branches programs loc of branches xorriso .
.
161k enscript .
.
49k gcal .
89k combine .
.
32k grep .
82k trueprint .
12k gawk .
.
77k diff diffutils .
9k sed .
66k du coreutils .
8k nano .
54k ls coreutils .
5k in total the product of the parameter spaces s induces different parameter settings.
.
.2baselines.
wecomparedourapproach klee symtuner withthreebaselines kleedefault kleehand andklee randtuner .
thefirstbaseline kleedefault usesthedefaultparametervaluesprovidedbykleewithoutanymodification.thesecondone kleehand uses the hand tuned parameter setting in figure .
more precisely itsconfigurationisthesameastheparametervaluesprovidedinthe kleedocumentation whichhasbeenaconventionalchoice inpriorwork .thelastone klee randtuner is a baseline that randomly samples parameter values from ourparameter spaces defined in section .
.
we simply substituted randtuner for symtuner on line in algorithm .
for afair comparison ofklee defaultand klee hand weran each baseline in two different modes respectively and then reported thebestresults.theonlydifferencebetweenthetwomodesisin how the given time budget is used.
the first method is to perform symbolic execution algorithm only once for the total budget e.g.
10h whiletheotheristorunalgorithm1multipletimesby dividingthe totalbudget intosmaller budgets.more precisely the secondmethodistorunalgorithm2withouttheparameter tuning process.
.
.3benchmarks and time budgets.
we used gnu opensource c programs in table .
our benchmark suite includes the largest programs used in prior works .
for example the last three programs in table are the largest or second largest onesingnucoreutils .32anddiffutils .
.foreachbenchmark program we collected the most recent releases as of march .forallexperiments wesetthetimebudgetto10hoursfor eachbenchmarkprogram.werepeatedeachexperiment4times and reported average results.
.
branch coverage our approach significantly outperformed the three baselines onall benchmarks in terms of branch coverage.
on average over allbenchmarkprograms klee symtuner achieved31 and56 higherbranchcoveragethan kleehandandkleedefault respectively.
symtuner also succeeded in covering more branches than randtuner showingthetruebenefitofonlinelearningalgorithm.
as the final outputs of our approach algorithm and three baselinesarethetestcasesgeneratedduringsymbolicexecution wedepictedthecoveragegraphovertimeinfigure3byaccumulatingthenumberofbranchescoveredbythetestcasegeneratedat eachtimestep.todoso weused gcov atoolformeasuringcode coverage.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symtuner maximizing the power of symbolic execution by adaptively tuning external parameters icse may pittsburgh pa usa time s of covered branchesxorriso .
.
161k klee symtuner klee hand klee randtuner klee default time s of covered branchesgcal .
89k klee symtuner klee randtuner klee hand klee default time s of covered branchesgrep .
82k klee symtuner klee randtuner klee hand klee default time s of covered branchesgawk .
.
77k klee symtuner klee randtuner klee default klee hand time s of covered branchessed .
66k klee symtuner klee default klee hand klee randtuner time s of covered branchesnano .
54k klee symtuner klee randtuner klee hand klee default time s of covered branchesenscript .
.
49k klee symtuner klee randtuner klee hand klee default time s of covered branchescombine .
.
32k klee symtuner klee randtuner klee hand klee default time s of covered branchestrueprint .
12k klee symtuner klee randtuner klee hand klee default time s of covered branchesdiff 9k klee symtuner klee randtuner klee default klee hand time s of covered branchesdu 8k klee symtuner klee randtuner klee hand klee default time s of covered branchesls 5k klee symtuner klee randtuner klee hand klee default figure the average number of covered branches achieved by our approach and three baselines on benchmarks the results in figure show that klee symtuner consistently achieves the highest branch coverage on all benchmarks.
in particular theresultsforthetwolargestbenchmarks xorriso andgcal arenoteworthy klee symtuner wasabletocover3 093branches on average for xorriso whilekleehandandklee randtuner covered and branches respectively.
for gcal the average number of branches covered by klee symtuner was whichis353and1 062morethan klee randtuner andkleehand respectively.
excludingourapproach klee randtuner wasgenerallybetter than the other two baselines where this result implies that performingsymbolicexecutionwithvariousparametervaluesis usuallymoreeffectivethanrunningitwiththefixedvalues.among kleehandandkleedefault theformerachieved19 higherbranch coverage than the latter on all benchmarks.
that is using handtunedparametervalueswasbetterthanblindlyusingthedefault values provided in klee.
one interesting point is that klee randtuner is sometimes eveninferiortothetwobaselines kleehandandkleedefault which donotchangetheparametervaluesatallduringsymbolicexecution.
onxorriso andsed klee randtuner managed to cover about and branches less than kleehandandkleedefault respectively klee randtuner achievedthelowestcoverageon sed.
the instability of randtuner supports that our approach algorithm is essential to consistently achieve higher coverage.
the standard deviations of branch coverage averaged over all benchmarks and trials are as symtuner randtuner table2 thebranchcoverageachievedbyrunning symtuner and randtuner with multiple cores in parallel o f c o r e s xorriso .
.4symtuner randtuner gcal .1symtuner randtuner kleedefault and kleehand thesedifferencesareinsignificant considering the coverage gap between ours and the baselines.
additionally we investigated whether symtuner still outperformsrandtuner evenwhenrunningtheminparallel.wewondered if running klee with more diverse parameters simply by using many cores in parallel would diminish the advantage of symtuner comparedto randtuner .so wecompared symtuner andrandtuner byaccumulatingtheresultsofrunningthem e.g.
algorithm2 withdifferentnumberofcoresinparallel respectively.
table2reportsthenumberofcoveredbranchesachievedbyeach technique according to the number of cores used in parallel on the two largest benchmarks xorriso andgcal.
the results show that the difference in branch coverage between the two techniques becomes larger when more cores are used.
for instance on xorriso runningsymtuner with cores in parallel succeeded in covering about more branches than running randtuner with the same settings.
that is even in parallel settings smartly tuning authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa sooyoung cha myungho lee seokhyun lee and hakjoo oh table comparison of bug finding ability of the three baselines and symtuner.
symtuner klee symtuner benchmarks error types error locations bug triggering test cases symtuner randtuner klee handkleedefault gcal .1segmentation fault line in src file io.c denotes an ascii character of .
segmentation fault line in src gcal.c at segmentation fault line in libc string strncasecmp.c ... .. .. u z abnormal termination line in libc string strcpy.c a adenotes a symbolic file.
abnormal termination line in libc string memcpy.c a enscript .
.
segmentation fault line in libc stdio vfprintf.c to gawk .
.
abnormal termination line in main.c w nost combine .
.0segmentation fault line in src field.c f field segmentation fault line in src field.c re fi d.e0 segmentation fault line in src df options.c pp no ch fi r.o1 r memory exhaustion line in libc string memmove.c ecut fiel symtunersym argsearchseed file switch type max memory max sym array size max static fork pct max static solve pct max static cpfork pct max instruction time batch instructions simplify sym indices external calls sym files sym stdin use cex cache max memory inhibit use forked solver optimize sym stdout2000240028003200xorriso .
.
of covered branches symtunersym argsearchseed file switch type max memory max sym array size max static fork pct max static solve pct max static cpfork pct max instruction time batch instructions simplify sym indices external calls sym files sym stdin use cex cache max memory inhibit use forked solver optimize sym stdout20002400280032003600gcal .
of covered branches symtuner sym arg searchseed file switch type max memory max sym array size max static fork pct max static solve pct max static cpfork pct max instruction time batch instructions simplify sym indices external callssym files sym stdin use cex cache max memory inhibit use forked solveroptimize sym stdout200024002800grep .
of covered branches figure the average branch coverage achieved by tuning only individual parameter on the three largest benchmarks parametersisstillmoreeffectivethantryingvariousparametersindiscriminately.asfuturework tofurtherimprovetheeffectivenessof symtuner whenrunningitinparallel weplantoapplythecore ideas of the existing techniques such as swarm testing .
.
bug finding table shows that symtuner also has considerable promise in improvingthebug findingabilityofklee.insummary symtuner detected different real bugs from four open source programs while the best one among three baselines randtuner found just six of them.
columns in table denote the benchmark program error type error location bug triggering test case produced by symtuner and indication of success or failure for each technique.
in particular we note that the failure mark indicates that the correspondingtechniquecompletelyfailedtofindthebugwithin 40hours 10h 4repetitions .conversely ifsucceedingonthebug detection at least once during the four trials we marked the result as success .
ourapproach klee symtuner found11differentbugsintotal and we classified them into three error types abnormal ter mination segmentation fault and memory exhaustion.
the firsttwoerror typescausetheprogramtocrashwhilethethirdoneis a performance bug.
for example the bug triggering input at generated by klee symtuner for the program gcal causes a segmentation fault which terminates the programabnormally.klee symtuner also found fatal bugs in combine the input ecut fiel leads to a serious performance degradation which consumes all available memory of the machine.
thesebug triggeringtestcasesintable3areeasilyreproducible.
forexample ongawk .
.
executingthecommand .
gawk w nost willaborttheprogramexecutionimmediately.anunexpectedresultintable3isthat randtuner failedtofindabugthat kleehanddiscovered in gcal that is randtuner is unstable even in terms of bug finding capability.
additionally we also investigated whether randtuner could findmorebugswhenrunningitinparallelwithmultiplecpucores.
compared to running randtuner on a single core using cores inparallelwasabletofindmorebugs butitstillfailedtofindsome bugswhichwerediscoveredby symtuner e.g.
thebugfoundin thefile strncasecmp.c of gcal .whenweexecuted randtuner formuch longer e.g.
20h using10cores inparallel randtuner was eventually able to find all bugs that symtuner found with a single core for hours.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symtuner maximizing the power of symbolic execution by adaptively tuning external parameters icse may pittsburgh pa usa 1062459symtuner spaces symtuner symtuner paramsxorriso .
.
1802684symtuner spaces symtuner symtuner paramsgcal .
2852603symtuner spaces symtuner symtuner paramsgrep .
1483326symtuner spaces symtuner symtuner paramsgawk .
.
figure venn diagrams illustrating the sets of branches covered by symtuner with different parameter spaces chameleon chameleon symtunergawk .
.
chameleon chameleon symtunersed .
chameleon chameleon symtunergrep .
figure venn diagrams depicting the sets of covered branches by chameleon with without symtuner .
impact of parameters and their spaces impactofindividualparameters.
weinvestigatedwhichof the parameters in table had the greatest impact on the performanceof symbolicexecutionfor thethreelargestbenchmarks xorriso gcal andgrep.
to do so we performed symbolic executionwhiletuningeachparameteronebyone andreportedthe average branch coverage for each parameter tuning with the same setting of symtuner 10h repetitions .
figure4showsthatthemostinfluentialparameterstendtobe similar across the three programs but the least influential ones are different depending on the target program.
the two parameters symboliccommand linearguments sym arg andseedinput seed file were consistently included in the top most influential parametersforallthebenchmarks.also themostcrucialparameter forgcalandgrepwasequalassearchstrategy search butthe search strategy parameter was not included even in top important parameters for xorriso which means that every important parameter was not shared across all the programs.
likewise theforth most important parameter batch instructions on gcal was the most unimportant one on xorriso.
on the other hand the least influential parameter for each program is different as batch instructions xorriso use cex cache gcal and sym stdin grep .
these results support our claim that we should take a program adaptive method to tune various parameters for symbolic execution.
an unexpected observation from figure is that the parameter type itself seems to be related to its importance.
first the string type parameters e.g.
search seed file ranked the most in the most important top parameters while none of the parametersbelongedtotheleastimportanttop 4parameters thatis thestring typeparameterisimportanttotunecarefully.second booleantypetable parameter spaces added for symtuner params boolean boolean integer or double use branch cache cex cache exp redzone size use constant arrays cex cache superset seed time solver optimize divides cex cache try all max stack frames allocate determ equality substitution allocate determ size rewrite equalities max static cpsolve pct .
.
parameters are less valuable to tune than the other type parametersasbooleantypesaccountfor50 oftheleastimportanttop parameters.
the results in figure also demonstrate that tuning only the most influential parameter is less beneficial than symtuner which adjusts the parameters simultaneously.
in particular symtuner covered11.
morebrancheson grepthantuningonlythemost influential parameter search .
also in terms of bug finding capability wefoundthattuningonlythemostinfluentialparameter ongcalwas able to discover only a single bug located in src fileio.c amongthetotal5bugsfoundby symtuner ongcalintable3.
impactofparameterspaces.
weevaluatedhowtheperformance of symtuner changes depending on different parameter spaces.
to do so we compared symtuner with its two variants symtuner spacesandsymtuner params havingdifferentparameter spaces.theformer symtuner spaces isavariantthatdoubleseach space of the parameters with integer or double type definedin section .
.
respectively.
for example the space of s argsof symtuner is between and but the space for symtuner spaces will be between and .
that is the parameter spaces for the first variant will be which is about times larger than the spaces for symtuner .
the latter symtuner params is another variantthattunesmoreparametersthanthe20parameterstobe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa sooyoung cha myungho lee seokhyun lee and hakjoo oh tunedoriginallyin symtuner .morespecifically thisvariantaimed tosimultaneouslytuneatotalof34parameters includingthe20 parametersthat symtuner tunedandthe14additionalparameters in table we manually added the parameters that are likely to affecttheperformanceofsymbolicexecutionamongthetotalparametersprovidedtoklee.weevaluatedthetwovariantswiththe samesettings e.g 10h 4repetitions as symtuner on4largest benchmarks and reported the average results.
figure shows the venn diagrams which describe the relationshipsintermsofthesetsofbranchesreachedbyeachtechnique.
the results show that symtuner is able to cover different code areasofthetargetprogrameffectivelydependingontheparameter spacestobetuned.intermsofthetotalnumberofcoveredbranches symtuner achieved the highest branch coverage on gcaland the lowest coverage on grep.
exactly opposite symtuner params achieved the lowest branch coverage on gcaland the highest coverage ongrep.
figure also shows that there exist many branches thatsymtuner anditstwovariantsareabletoexclusivelyreach.
for example symtuner spacesexclusively covered branches ongrep andsymtuner paramssucceededincovering332unique brancheson xorriso.thatis thepotentialof symtuner mayvary depending on different parameter spaces.
.
generality of symtuner we checked if our approach is applicable to concolic testing anothermajorapproachtodynamicsymbolicexecution.we appliedsymtuner tocrest asitisapubliclyavailabletool andchameleon the state of the art technique for tuning search heuristics for concolic testing is implemented on top of crest .hence ourapproach chameleon symtuner aims totunetheotherparameterswhileletting chameleon tunesearch strategies in its own way.
to do so we implemented symtuner on topofchameleon andfiguredoutwhether symtuner wasable to enhance chameleon.
unlikeklee crestonlyprovidesthreeexternalparameters others are hard coded inside the tool and difficult to tune fromthe outside.
in our experiments we tried to tune all of the threeparameters symbolic command line argument seed input and the number of program executions.
on the basis of the parameter valuesusedin chameleon wedefinedtheirspacesasfollows sargs sseed i0 sexecution inparticular wefirstinitializedthespace sseedwithaninitialinput i0 providedin chameleon andletitbedynamicallydecided during concolic testing like the space sseedin section .
.
.
for evaluation weusedthesamethreebenchmarkprogramstakenfrom chameleon allocatedthe timebudgetto 10hours and reported the number of covered branches averaged over times.
figure6showsthatourapproach chameleon symtuner has itsownbenefitintermsofexclusivelycoveredbranches.forthe three benchmarks chameleon symtuner succeeded in covering about30 moreuniquebranchesthan chameleon alone.weexpect that the usefulness of symtuner will be greater if various parameters provided in klee are also added to crest in the fu ture.
note that since symtuner uses a symbolic execution tool e.g.
klee and crest as a blackbox we expect that applying symtuner toothersymbolicexecutiontools doesnotrequire much effort.
.
threats to validity weevaluated symtuner onlyforkleeandcrest.wechose themastheyaretherepresentativesymbolicexecutorsforcprograms buttheresultsreportedinthispapermaynotbevalidfor other testing tools such as evosuite a widely used unit testing tool.
we manually defined the parameter spaces of klee bychoosing5 10valuesaroundthevalueusedinfigure1.however these predefined spaces may not be appropriate for the other target programs beyond our benchmarks.
our approach algorithm involves hyper parameters e.g.
ratioand step which were selectedheuristically.
thesevalues mayneedto beset properly for target programs.
we used programs including the largest real world programs up to 161kloc among those used in priorworks forevaluatingklee.however these might not be representative enough.
related work improvingsymbolicexecution.
toourknowledge symtuneris thefirsttechniquetotunegeneralparametersofsymbolicexecution automatically.
over the past decade a lot of research has been conducted to advance symbolic execution and they can be clas sified into three groups according to the main approach searchstrategies pruning techniques and constraint solving techniques .
first prior works on search strategies aim to preferentially explore the execution paths of the program that are likely to maximize the performance e.g.
code coverage .
for example the cfds strategy prioritizes the program s paths closest to the branches that have not yetbeenreached andthecgsstrategy favorsexploringthe paths with a new context i.e.
new sequence of branches .
second path pruningtechniquesfocusonremovingtheredundantpaths oftheprogrambasedonthepredefinedcriteria.forinstance jaffar et al.
presented a criterion that eliminates the execution pathsguaranteednottoreachtheerrorlocations.lastly diverse techniques have emerged to reduce the cost for constraint solving one major bottleneck in symbolic execution by simplifying the arrayconstraints orreusingtheconstraintsolutions .
symtuner is orthogonal to the above three approaches and we believethatsymtunercanfurther enhancetheexistingapproachesby automatically tuning external parameters.
software testing with learning.
our approach follows a recent trend in software testing that leverages machine learning .paradyse boostsconcolictestingbyautomatically generating search strategy via offline learning.
using online learningtechnique chameleon adaptivelyswitchesthesearch strategiesofconcolictesting.leo aimstoimprovetheefficacy ofsymbolicexecutionbylearninghowtousecompileroptimizations for code transformation.
in android gui testing qbe usesreinforcementlearningtoexploreguiactionsthatarelikelytodetectbugsandincreaseactivitycoverage.retecs learnshow to preferentially select buggy test cases in continuous integration authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
symtuner maximizing the power of symbolic execution by adaptively tuning external parameters icse may pittsburgh pa usa based on reinforcement learning.
in this paper we use learning for a novel application i.e.
tuning symbolic execution parameters.
search based software testing.
our work can be considered an instanceofsearch basedsoftwaretesting sbst using meta heuristic search technique in the field of search based softwareengineering .sbstaimstofindgoodsolutionsfrom anextremelylargesearchspaceinareasonabletimeforenhancing testingefficacy.todoso eachtechniqueinsbstdefinesitsown optimizationproblemandproposesafitnessfunctionspecialized forsolvingtheproblem.inourwork weformulatedtheproblemof tuning parameter values of symbolic execution as an optimization problem that maximizes both the number of covered branches and found bugs and presented a specialized algorithm to solve it.
automatic parameter tuning.
automatic parameter tuning has beenstudiedextensivelyinvariousfields.forexample researchershavedevelopeddomain specificalgorithmsfordatabasesystems web systems image segmentation and big data processingsystems .ourworkliesinthislineofresearch andpresents analgorithmspecializedfor symbolicexecution.existing frameworks for algorithm configuration e.g.
paramils opentuner are inappropriate for our purpose.
note that these are offline approaches they aim to discover good parameter settings of algorithms and the same settings are used without change atruntime.bycontrast themainbenefitof symtuner comesfrom adaptively adjusting the parameter values online during symbolic execution whichiscrucialinourcaseasoptimalparametervalues varysignificantly depending onthe targetprograms section4.
.
also using these tools effectively often requires domain expertise our goal is to enable users to use symbolic execution without any prior knowledge.
conclusion automatictuningofsymbolicexecutionparametershasreceived little attention despite its importance in practice.
in this paper we called for attention to this problem and presented symtuner for automatically tuning parameters of symbolic execution via online learning.experimentalresultsshowedthatrunningkleeinconcert with symtuner leads to sharp increases in branch coverageand found bugs.
we hope that symtuner will help end users to maximallybenefitfrompowerfulyetdifficult to usemodernsymbolic execution tools.