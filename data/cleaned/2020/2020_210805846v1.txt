automating the removal of obsolete todo comments zhipeng gao monash university australia zhipeng.gao monash.eduxin xia monash university australia xin.xia acm.orgdavid lo singapore management university singapore davidlo smu.edu.sg john grundy monash university australia john.grundy monash.eduthomas zimmermann microsoft research united states tzimmer microsoft.com abstract todo comments are very widely used by software developers to describe their pending tasks during software development.
however after performing the task developers sometimes neglect or simply forget to remove the todo comment resulting in obsolete todo comments.
these obsolete todo comments can confuse development teams and may cause the introduction of bugs in the future decreasing the software s quality and maintainability.
manually identifying obsolete todo comments is time consuming and expensive.
it is thus necessary to detect obsolete todo comments and remove them automatically before they cause any unwanted side effects.
in this work we propose a novel model named tdcleaner todo comment cleaner to identify obsolete todo comments in software projects.
tdcleaner can assist developers in just intime checking of todo comments status and avoid leaving obsolete todo comments.
our approach has two main stages offline learning and online prediction.
during offline learning we first automatically establish code change todo comment commit msg training samples and leverage three neural encoders to capture the semantic features of todo comment code change and commit message respectively.
tdcleaner then automatically learns the correlations and interactions between different encoders to estimate the final status of the todo comment.
for online prediction we check a todo comment s status by leveraging the offline trained model to judge the todo comment s likelihood of being obsolete.
we built our dataset by collecting todo comments from the top python and java github repositories and evaluated tdcleaner on them.
extensive experimental results show the promising performance of our model over a set of benchmarks.
we also performed an in the wild evaluation with real world software projects we reported obsolete todo comments identified bytdcleaner to github developers and of them have already this is the corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
confirmed and removed by the developers demonstrating the practical usage of our approach.
ccs concepts software and its engineering software maintenance tools .
keywords todo comment obsolete comment code comment inconsistency code comment co evolution bert model acm reference format zhipeng gao xin xia david lo john grundy and thomas zimmermann.
.
automating the removal of obsolete todo comments.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
introduction todo comments in source code are extensively used by developers to denote their pending tasks.
after completing some of the documented pending tasks developers should update or remove their associated todo comment s .
such an example is shown in ex.
of fig .
here a developer added a todo comment line todo check rackspace file existence to notify themselves or others of the unfinished task.
when the developer or someone else in the team updated the source code highlighted in green colour to perform this task the accompanying todo comment was also deleted highlighted in red colour .
however due to time constraints or carelessness developers may have completed or partially completed the task specified by the todo comment but forget to remove it or update it .
this results in todo comments becoming obsolete and more and more irrelevant and unreliable when the software changes and evolves.
in this work we define a todo comment as an obsolete todo comment if its corresponding task is accomplished but the todo comment itself is not removed.
these obsolete todo comments lay down outdated tasks that need not or should not be followed any longer.
a good todo comment can help developers in understanding the designed tasks as well as the source code .
on the contrary an obsolete todo comment can obscure the source code and affect code comprehension.
previous studies have shown that developers lose confidence in the reliability of the system when they encountered outdated comments.
moreover once obsolete todo comments get separated from their code theyarxiv .05846v1 aug 2021esec fse august athens greece zhipeng gao xin xia david lo john grundy and thomas zimmermann table 1ex.
commit message check for file existence on rackspaceex.
commit message convert lambda to class to reduce coupling figure example of code change and todo comment become incorrect and unreliable documentation of ever decreasing accuracy which can mislead developers and cause the introduction of bugs in the future .
therefore the obsolete todo comments increase the cost of software maintenance and development which have negative impact to the quality and reliability of the system.
it is thus highly desirable to have a tool that provides just in time automatic detection of obsolete todo comments and removes them before they mislead developers and cause any damages.
however making such a tool is difficult with respect to the following challenges capturing comment semantics detecting obsolete todo comments first requires understanding the semantics of the comments.
compared to source code comments are written in natural language and have no mandatory format.
when source code changes they can go through a series of software testing to ensure their correctness however there is no way to test comments to see if they are still valid or not.
moreover the source code and comments are of different types together they form a heterogeneous data that cannot be easily matched to each other due to their lexical gaps.
therefore it is a non trivial task to determine which todo comments have been addressed and which ones have not.
capturing correlations it is very hard to determine if a todo comment is resolved or not by just reading the source code.
a more obvious and reliable way is to check the code change history with respect to the todo comment and determine if these code changes resolve the associated task as shown in ex.
in fig.
.
however sometimes checking the code changes alone is not sufficient.
ex.
in fig.
presents such a case.
even though the todo comment and code change are presented one can not easily claim this todo comment is resolved due to his her unfamiliarity with the code.
the associated commit message can provide additional clues to fill this gap.
therefore to better identify todo comments are up to date or obsolete it is necessary to consider the correlations between the todo comments code changes and commit messages.
in this work to help developers better maintain the todo comments in their software systems we propose a novel neural network model named tdcleaner todo comment cleaner which can automatically detect the stale todo comments in software repositories.
tdcleaner consists of two phases offline learning and online prediction.
during offline learning we collect todo comments from top python and java github repositoriesrespectively.
we automatically establish positive and negative training samples in terms of whether a todo comment is resolved or not.
our tdcleaner can be trained as a binary classification model with these two kinds of training samples.
to capture the semantics of the heterogeneous data we employ three encoders i.e.
todo comment encoder code change encoder and commit message encoder to embed todo comments code changes and commit messages into contextualized vectors respectively.
tdcleaner then learns correlations and interactions between them by optimizing the final probability score.
when it comes to online prediction for a given todo comment we pair it with the associated code change and commit message and fit them into the trained tdclearner model to estimate their matching score.
to verify the suitability of our proposed model we conducted extensive experiments on python and java datasets.
by comparing with several benchmarks the superiority of our proposed tdcleaner model is demonstrated.
in summary this work makes the following main contributions we propose a novel model tdcleaner to automatically detect obsolete todo comments by mining the histories of the software repositories.
tdcleaner can help developers to increase the quality and reliability of software and alleviate the error prone code review process.
we build a large dataset for checking obsolete todo comments from github repositories which contains more than 410k todo comments for python and more than 350k todo comments for java dataset.
to the best of our knowledge this is the first and by far the largest dataset for this task.
we extensively evaluate tdcleaner using real world popular open source projects in github.
tdcleaner is shown to outperform several baselines and reduce the developer s efforts in maintaining the todo comments.
we have released our replication package including the dataset and the source code of tdcleaner to facilitate other researchers and practioners to repeat our work and verify their ideas.
the rest of the paper is organized as follows.
section presents the motivating examples and user scenarios of our study.
section presents the details of our approach.
section presents the data preparation for our approach.
section presents the baseline methods the evaluation metrics and the evaluation results.
section presents the in the wild evaluation.
section presents the threats to validity.
section presents the related work.
section concludes the paper with possible future work.
motivation we show several motivating examples from popular github repositories of the sorts of problems mentioned above.
we then present user scenarios of employing our proposed approach to address these problems.
.
motivating examples developers change their source code but forget to remove or update associated todo comments from time to time.
fig shows twoautomating the removal of obsolete todo comments esec fse august athens greece table 1motivating example google clusterfuzz stars .4k todo ochang remove include strageties once refactor is complete motivating example sublimehaskell sublimehaskell stars class sublimehaskellautocomplete sublime plugin.eventlistener def init self todo start the inspectoragent as a separate thread self.inspector inspectoragent def parse performance features log lines strategies arguments include strategies true def parse performance features log lines strategies argument self.inspector.run self.inspector.start figure motivating examples examples of stale todo comments we found in real world github repositories.
we can see that producing obsolete todo comments is not only done by inexperienced developers even developers within experienced teams such as ethereum and google may ignore or neglect such updates.
for example motivating example presents such an obsolete todo comment example from the clusterfuzz project developed by the google team.
the todo comment within the method get client ip states that remove include strategies once refactor is complete .
however when the task was resolved and include strategies was removed from the method the corresponding todo comment was not updated.
until the time we report this issue this stale todo comment has existed for over year.
during this time such a comment may hinder program comprehension cause miscommunication between developers and confuse developers who perform the subsequent development.
a lot of software bugs are caused by the mismatch between code s implementation and developer s intention while a stale todo comment itself might be harmless it can mislead developers and cause the introduction of bugs in the future.
for example in our motivating example the task todo comment was fulfilled and should not be followed any longer.
however since the todo comment stayed around other developers can easily misunderstand the software component and violate the assumption and later lead to bugs.
.
user scenarios we illustrate a usage scenario of tdcleaner as follows without our tool consider a developer bob.
daily when bob reads other people s code to perform the development he encounters a few stale todo comments.
these out of date todo comments can clutter the code and have a harmful effect for bob to understand the current state of the code correctly.
bob may lose confidence in the reliability of the system and even ignore the remainder of useful comments.
furthermore since bob hasno idea that this todo comment had already been resolved bob tries his best to perform the pending task with respect to this task comment by refactoring the code.
however due to his unfamiliarity with the code or the system these updates are risky and very likely to cause the introduction of bugs in the future.
with our tool now consider bob adopts our tdcleaner .
before working on the software bob can use our tool to automatically check for the presence of stale todo comments.
moreover tdcleaner can identify the specific code change which resolved the todo comment thus helping to improve developer s confidence in verifying the obsolete todo comments.
with the help of our tool bob successfully removes the stale todo comments in the current software repository efficiently and accurately which can increase the reliability and maintenance of the system and decrease the likelihood of introducing bugs.
our approach we first define the task of identifying obsolete todo comments for our study.
we then present the details of our proposed model.
the overall framework of our approach is illustrated in fig.
.
.
task definition the motivation of our work is to automatically detect and remove obsolete todo comments in software projects.
to do this we need to detect if a todo comment is resolved in a commit or not.
we formulate this task as a binary classification learning problem as per below.
for a given commit let cbe the code changes extracted from the diff file mbe the corresponding commit message and tbe the todo comment associated with the code changes if a todo comment appears within the default number of context lines of a code change we claim this todo comment is associated with the code change .
our target is to automatically determine the status sof the todo comment where sis positive when the todo comment is resolved and negative when the todo comment is unresolved.
in other words our goal is to train a model using c t m triples such that the probability p s c t m is maximized over the given training dataset.
mathematically our task is defined as findingy such that y argmax sp s c t m p s c t m can be seen as the conditional likelihood of predicting the status sgiven the c t m input triples.
.
approach details .
.
encoders.
identifying the resolved todo comments from the unresolved ones is a non trivial task.
this is because the code changes and the todo comments are of different types source code vs. natural language and cannot be easily mapped by simple matching of their lexical tokens.
to bridge this gap tdcleaner adopts three encoders i.e.
todo comment encoder code change encoder and commit message encoder to embed the code change todo comment and commit message into a vector representation respectively so that semantically similar concepts across the three modalities can be correlated in the higher dimensional vector space.
through the embedding techniques heterogeneous data can be easily linked through their vectors.esec fse august athens greece zhipeng gao xin xia david lo john grundy and thomas zimmermann githubrepository code change todocomment commit message code change vectortodocomment vectorcommit message vector hcmlp layer mlp layer mlp layer x mlp sisitraininglosstargetprobability scorehthctrained model offline training online predictionsadd layernormlinearconcatenatedot product attentionadd layernormlinearlinearlinearlinearnx embeddingsbert tokenized inputcontextualized vector figure overview of our approach recently neural networks have been widely used to capture the code semantic features by encoding code into vectors in this study we employ bert as the encoder template for our task.
this is because bert has been proven to be effective for capturing semantics and context information of sentences in many other works .
bert consists of layer transformers each of the transformers being composed of a self attention sub layer with multiple attention heads.
the input to each bert embedding component is a sequence of tokens.
given a sequence of tokens x x1 ... xt of lengthtas input bert takes the tokens as input and calculate the contextualized representations hl hl ... hl t rt das output where ldenotes the l th transformer layer and ddenotes the dimension of the representation vector.
we take the final hidden state of the first special token hl as the embedding vector for the input sequence.
our tdcleaner consists of three encoders i.e.
code change encoder todo comment encoder andcommit message encoder .
these three encoders are nearly the same in structure and responsible for mapping three kinds of inputs i.e.
code changes todo comments and commit messages into their corresponding embeddings.
code change encoder thecode change encoder embeds code changes into vectors.
code changes contain multiple aspects of useful information such as code tokens added lines and removed lines.
consider a code change c c1 c2 ... cnc comprising a number of nctokens.
the code change encoder embeds it into a vector hcusing bert.
todo comment encoder the todo comment encoder embeds the todo comment into vectors.
consider a todo comment t t1 t2 ... tnt comprising a number of nt tokens.
after feeding tinto the todo comment encoder we can get the embedding vector htfor the todo comment.
commit message encoder the commit message encoder embeds commit messages into vectors.
likewise the commit message m m1 m2 ... mnm is embeded into a contextualized vector hm.
.
.
multi layer perceptron.
so far the code change todo comment and commit message are represented as independent contextual vectors.
to capture the relationships between them it isnecessary to link and fuse their information.
to do this we add a multi layer perceptron mlp to address this need which is shared with the three encoders.
we first concatenate three encoders contextual vectors i.e.
hc ht and hm to combine the semantic features.
to further capture the correlation and reference of the latent feature vectors we next add a standard mlp on the concatenated vector.
in this sense we can endow the model with a large level of flexibility and non linearity to learn the interactions between the three encoders.
the mlp takes the the contextualized representations i.e.
hc ht and hm as input and outputs the likelihood of the final status s .
more precisely the mlp is defined as follows z1 1 hc ht hm hc ht hm z2 2 z1 a2 wt 2z1 b2 ... zl l zl al wt lzl bl p s j c t m zl wx bx and axdenote the weight matrix bias vector and activation function for the x layer s perceptron respectively.
is the sigmoid function x e x which will output the final probability of status sbetween and .
for the probability score we want this score to be high if the todo comment is resolved and to be low if the todo comment is unresolved.
dataset preparation we present the details of our data collection and construction process.
we build our dataset by collecting data from the top repositories ordered by the number of stars in github for python and java repositories.
to the best of our knowledge this is the first and by far the largest dataset for collecting todo comments from github repositories.automating the removal of obsolete todo comments esec fse august athens greece table 1commit message issue adds log for request failing issue forward all params from client to githubdiff except requests.exceptions.httperror as err todo handle sort and other parapeters code change except requests .
exception .
httperror as err nl pass nl logging .
warning fetching comments failed params nl params request .
args .
copy commit msg issue issue id adds log for request failing issue issue id forward all params from client to githubtodo comment todo log the message todo handle sort and order parameterslebel positivenegative pass todo log the message logging.waring fetching comments failed params params request.args.copy figure data preparation examples .
data collection .
.
identifying todo related commits.
we first clone the top repositories from github.
the git repository stores software update history each update comprises a commit message alongside adiff that represents the differences between the current and previous version of the affected files.
for each cloned repository we first checkout all the commits from the repository history.
following that for each commit if todo appears within the diff we consider this commit as a todo related commit .
we have identified more than 410k todo related commits from our python repositories and more than 350k commits from our java repositories.
.
.
normalize diff and commit message.
this step aims to normalize the commit sequence and remove some semantic irrelevant information.
after identifying the todo related commits we extract the diff and the commit message from the commits and normalize them for later use.
for the diff we convert it into lowercase and delete the diff header by using regular expressions.
commit ids within the diff are replaced with commit id and commits with a diff larger than 1mb are removed.
for the commit message we first lowercase the commit message and retain the first sentences of the commit message as the target since the first sentences are usually the summaries of the entire commit message .
similar to diff normalization github issue ids and commit ids are replaced by issue id and commit id respectively to ensure semantic integrity.
the two examples in fig.
demonstrates the process of normalization.
.
.
extract todo comments.
this step is responsible for extracting todo comments from the corresponding diff .
adiff may contain multiple todos.
we remove such instances because they are likely to be comment updates which might introduce noise for the later data construction process.
hereafter each diff contains a single todo comment and pairs with a commit message.
we then use regular expressions to locate comments within thediff if todo appears in the comment then this comment is identified as a todo comment.
the todo comment is extracted out of the diff astodo comment and the rest of the diff stay the same referred to as code change in this paper.
it is worth mentioning that the difference label i.e.
and are deleted from the todo comment otherwise our model can learn directly from the difference labels instead of learning the semantics of the todo comments.
until now we are able to establish code change todo comment commit msg triples.
.
data construction .
.
data labelling.
in this work we consider a diff consists of three parts linesadded linesremoved and linesequal .linesadded are the lines that were added to the current version when compared to its previous version.
similarly linesremoved are the lines that were removed from the current version when compared to its previous version.
linesequal were the lines that remained unchanged between two versions.
we automatically label each code change todo comment commit msg triple as follows i if todo comment is within the scope of the linesremoved which means the todo task is already performed by the developer we label such triple instances as positive samples .
ii if todo comment is within the scope of the linesequal which means the code change is not responsible for resolving the todo task we label such triple instances as negative samples .
iii if todo comment is within the scope of the linesadded we ignore such triple instances.
this is reasonable since thetodo comment within the scope of linesadded corresponds to the first time todo comments are added.
however our research focuses on detecting obsolete todo comments from the existing ones.
this requires that the todo comments have been already added to the source code.
fig.
demonstrates the data labelling results for a positive sample and a negative sample respectively.
we found more than 38k triple instances that are considered as positive samples and 35k triple instances that are considered as negative samples for python and 33k positive samples and 32k negative samples for java.
.
.
manual checking.
we automatically built our positive and negative training samples via heuristic rules.
we can not ensure that there are no outlier cases during the label establishment process.
therefore we performed a manual checking step to examine the label of the training sample is correct or not.
we randomly sampled samples including positive samples and negative samples from our dataset.
then the first author manually examined each sample and classified the todo comment is resolved or not based on checking the associated code change and commit msg .
finally of the positive training samples are marked as resolved and all of the negative training samples are marked as unresolved.
thus we are confident in the labels of our provided dataset.
.
.
data splitting.
we split the constructed data samples into three chunks percent of the triple samples are used for training percent are used for validation and the rest are held out for testing.
the training set is used to adjust the parameters while the validation set is used to minimize overfitting and the testing set is used only for testing the final solution to confirm the actual predictive power of our model with optimal parameters.
the number of training validation test sets of python and java dataset are displayed in table .
empirical evaluation we first present the baselines the evaluation metrics and our experiment settings.
we then describe the results of our quantitative evaluation and manual analysis.esec fse august athens greece zhipeng gao xin xia david lo john grundy and thomas zimmermann table data statistics python todo commits positive samples negative samples train set val test set java todo commits positive samples negative samples train set val test set .
baselines to demonstrate the effectiveness of our proposed model tdcleaner we compared it with the following chosen baselines tco t odo codechange overlap is a reasonable heuristic baseline to identify if a todo task comment is resolved or not.
tco looks at the overlapping words in the todo comment andcode change .
for example as shown in the positive example in the logging function was added to the source code to resolve the todo comment todo log the message .
therefore we created the tco baseline as follows if there is a common word between the todo comment and the code change then we declare this todo task comment to be resolved.
tmo t odo commit msg overlap baseline is based on the overlapping words of the todo comment and the commit msg .
in general commit messages are meant to explain the purpose of the source code changes.
we thus make the tmo baseline as follows we compare the words in the todo comment and the commit msg if there is a match we claim this task todo comment to be resolved.
tcmo we combined the status predicted by tco and tmo to make the tcmo baseline.
for a testing sample we declare this task todo comment as resolved if either tco ortmo method predicts so.
irsc sridhara proposed a method irsc information retrieval based status checker that performs well in identifying the status of the task todo comments.
different from our task their method requires the signature and body of a method as input then automatically checks if the associated task comment is up date with the code or obsolete.
irsc uses a cosine similarity between the task comment and the linesadded by incorporating tf idf weightings.
.
evaluation metrics we define four statistics with respect to our task i true positive tp represents the number of resolved todo comments that are classified as resolved.
ii true negative tn represents the number of unresolved todo comments that are classified as unresolved.
iii false positive fp represents the number of unresolved todo comments that are classified as resolved.
iv false negative fn represents the number of resolved todo comments that are classified as unsolved.
based on the aforementioned four statistics weadopted the widely accepted metrics i.e.
accuracy precision recall and f1 score to evaluate the performance of tdcleaner and baselines.
our evaluation metrics are defined as follows accuracy accuracy represents the proportion of correct predictions both true positives and true negatives among the total number of cases examined.
the accuracy metric is defined as follows accuracy tp tn tp tn fp fn precision precision represents the proportion of todo task comments that are correctly classified resolved among all the resolved comments.
the precision metric is defined as follows precision tp tp fp recall recall represents the proportion of all resolved task comments that are correctly classified as resolved.
the recall metric is defined as follows recall tp tp fn f1 score f1 score is the harmonic mean of precision and recall which combines both of the two metrics above.
it evaluates if an increase in precision or recall outweighs a reduction in recall or precision respectively.
the f1 score metric is defined as follows f1 precision recall precision recall the higher an evaluation metric the better a method performs.
note that there is a trade off between precision and recall.
f1 score provides a balanced view of precision and recall.
.
experimental settings we implemented tdcleaner in python using the pytorch framework.
we used the pre trained bert model as the encoder for embedding training samples which provides a powerful contextdependent sentence representation.
bert can be easily extended to a joint classification model.
in our model code change encoder todo comment encoder and the commit message encoder are jointly trained to minimize the cross entropy.
after the encoding process code change todo comment andcommit msg will be mapped to a dimensional vector respectively.
during the training phase we optimized the parameters of our model including the bert parameters and mlp parameters using adam with a batch size of .
we use the relu as the activation function and employ three hidden layers for mlp.
a dropout of .
is used for dense layers before computing the final probability.
the model is validated every batches on the validation set with a batch size of .
we set the learning rate of adam to .
and clip the gradients norm by .
the model with the best performance on the validation set was used for our evaluations.automating the removal of obsolete todo comments esec fse august athens greece .
quantitative analysis .
.
rq1 the effectiveness evaluation.
to evaluate the effectiveness of our proposed model i.e.
tdcleaner we evaluate it and the baseline methods on our testing set in terms of accuracy precision recall and f1 score.
the evaluation results for python and java dataset are shown in table and table respectively.
from the table we can observe the following points in general the methods based on bag of words matching i.e.
tco andtmo achieve the worst performance.
tco andtmo methods identify the resolved todo comments based on whether common words can be found in the input.
as a result they are unable to consider the context of thetodo comment code change and commit msg and the relationship between them which is reflecting that simply checking the overlap words is not enough for our task.
it is notable that the tmo method gets relatively high recall i.e.
.
for python and .
for java.
this is reasonable because commit msg often describes the purpose behind commits if commit msg matches the todo comment it is very likely that the developer has completed this task comment and described this update in the commit msg an example is shown in the positive example of fig.
.
however not all commit messages are meaningful and related to the task comment.
this also explains its surprisingly low score on precision and f1 score.
tcmo performs better than tco andtmo respectively.
for example it improves over tco on f1 score by .
on python dataset and java dataset and it improves over tmo on f1 score by .
on python dataset and .
on java dataset.
instead of solely based on code change orcommit msg tcmo combines the advantage of tco andtmo by incorporating useful information in both code change and commit msg .
this results in its superior performance to the other two approaches.
it also signals that code change and commit msg convey much valuable information for our task of identifying the obsolete todo comment.
irsc has its advantage as compared to the words overlapping based methods i.e.
tco tmo andtcmo .
rather than checking if the words are overlapping irsc employed the tf idf metric which can extract descriptive terms and identify the up to date status of the todo comment by computing their similarities.
however tf idf is still based on bag of words model therefore irsc can only capture the lexical level features but unable to capture the semantic features and co occurrences in separate input sequences.
that is why its performance is comparatively suboptimal.
our new model i.e.
tdcleaner outperforms all the baseline methods by a large margin in terms of all evaluation metrics.
we attribute this to the following reasons first it uses code change todo comment commit msg triple as input which considers the useful information across different resources.
second compared with bag of words models the advantage of our proposed model is also clear.
our model employs bert as encoders to embed code change todo comment commit msg into high dimensional vectors.table effectiveness evaluation python measure accuracy precision recall f1 tco .
.
.
.
tmo .
.
.
.
tcmo .
.
.
.
irsc .
.
.
.
tdcleaner .
.
.
.
table effectiveness evaluation java measure accuracy precision recall f1 tco .
.
.
.
tmo .
.
.
.
tcmo .
.
.
.
irsc .
.
.
.
tdcleaner .
.
.
.
these vector representations learn the semantic and structural features from the input and assists tdcleaner to separate resolved task comments from the unresolved ones.
by comparing the evaluation results of the different datasets i.e.
python and java we can see that tdcleaner is stably and substantially better than the other baselines.
this suggests that our approach behaves consistently across different programming languages.
this supports the likely generalization and robustness of our approach which also justifies that our approach is language independent and we believe it can be easily adapted to other programming languages.
answer to rq how effective is our approach for identifying the obsolete todo comments?
we conclude that our approach is highly effective for identifying the resolved todo comments from the unresolved ones.
.
.
rq2 component wise evaluation.
the key to our obsolete todo detection task is to effectively capture the relationship and