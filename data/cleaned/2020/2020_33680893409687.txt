when does myprogram do this?
learning circumstancesofsoftwarebehavior alexander kampmann cispa helmholtz center for informationsecurity saarbr cken germany alexander.kampmann cispa.saarlandnikolas havrikov cispa helmholtz center forinformationsecurity saarbr cken germany nikolas.havrikov cispa.saarland ezekiel o.soremekun cispa helmholtz center for informationsecurity saarbr cken germany ezekiel.soremekun cispa.saarlandandreas zeller cispa helmholtz center forinformationsecurity saarbr cken germany zeller cispa.saarland abstract aprogramfails.underwhichcircumstancesdoesthefailureoccur?
ouralhazen approach starts with a run that exhibits a particular behaviorandautomaticallydeterminesinputfeaturesassociated withthebehaviorinquestion weusea grammar toparsethe inputintoindividualelements.
weuseadecisiontreelearner toobserveandlearnwhich input elements are associated withthe behavior in question.
we use the grammar to generate additional inputs to further strengthen or refute hypotheses as learned associations.
by repeating steps and we obtain a theory that explains and predicts the given behavior.
in our evaluation usinginputsfor find grep nethack andajavascripttranspiler the theories produced by alhazen predictandproducefailures with high accuracy and allow developers to focuson a small set of input features grepfails whenever the fixed strings option is usedinconjunction withan emptysearch string.
ccs concepts softwareanditsengineering softwaretestinganddebugging theory of computation grammars and context free languages oraclesand decision trees active learning.
keywords debugging errordiagnosis machine learning software behavior acmreference format alexanderkampmann nikolashavrikov ezekielo.soremekun andandreas zeller.
.
when does my program do this?
learning circumstancesofsoftwarebehavior.in proceedingsofthe28thacmjointeuropean software engineering conference and symposium on the foundations of softwareengineering esec fse november8 virtualevent usa.
acm newyork ny usa 12pages.
esec fse november virtual event usa copyright held by the owner author s .
acm isbn .
learnergeneratorinitial inputs test outcomes input grammar hypotheses to r efine or refuteinput features test outcomes theory figure how alhazen w orks.
given a set of initial inputs andtheirtestoutcomeswhichdeterminewhetherthebehavior in question is present or not we parsethe input into its elements using a given input grammar a learnerthen determinestheassociationsofinputpropertiesandoutcomes producing hypotheses on the circumstances under which the behavior occurs.
by producing inputs from the grammar we generate additional tests to further refine or refute hyoptheses eventuallyobtaininga theorythatexplainsand predicts whenthe behavior inquestionoccurs.
introduction whendiagnosingwhyaprogramfails oneofthefirststepsisto preciselyunderstandthe circumstances ofthefailure thatis when the failure occurs and when it does not.
such circumstances are necessary for three reasons.
first knowing the circumstances is necessarytoprecisely predictwhenthefailuretakesplace thisis importanttodevisetheseverityofthefailure.second oneneeds them to design a precise fix a fix that addresses only a subset of circumstancesisincomplete whileafixthataddressesasuperset may alter behavior in non failing scenarios.
third one can use themtocreate testcases thatreproducethefailureandeventually validate the fix.
1228this work is licensed under a creative commons attribution international .
license.
esec fse november8 virtualevent usa alexander kampmann nikolas havrikov ezekielo.
soremekun andandreas zeller in this paper we introduce alhazen an approach that automaticallydeterminesthecircumstancesunderwhichsomeprogram behaviorofinteresttakesplace.1asallprogrambehaviorisdeterminedbyitsinputs weseefailurecircumstancesaspropertiesof theprograminput ouraimisthustodetermineinputfeaturesthat wouldbe associatedwiththe behaviorinquestion.
as an example of how alhazen works and what it produces assumesomeprogram ptoevaluatemathematicalfunctions the inputsqrt forinstance producestheoutput .giventheinput sqrt however phangs.
at this point the astute reader alreadymayhaveanideaonthecircumstancesofthefailure but we want to determine these automatically .
to do so alhazen makesuse ofthree key ingredients illustratedin figure parsing.
we use a grammar toparseprogram inputs into individual elements.
this allows us to express fine grained relationships between input elements and their features and program behavior i.e.presenceorabsenceofafailure .
figure2liststheinputgrammarfor p.thisgrammarwillallow us to expressfailure circumstances by means of the function being usedandthe number being passed.
learning.
we use a decisiontree tolearnwhichfeatures ofinput elementsareassociatedwiththeprogrambehaviorinquestion.
by default the features used in alhazen test whether a particular element occurs in the input or not in our failure inducing input sqrtis present whereas sinis not.
if some element has anumericalinterpretation suchas number italsousesits maximum valueas feature.
the decision tree learner produces a tree that explains and predictswhenthebehaviorinquestionoccursbasedonasubset of the input features.
figure 3shows the initial decision tree learnedfromthepassinginput sqrt andthefailinginput sqrt .
the initial hypothesis is that the failure occurs whenthelargest2 number islessthanorequalto .5 a predicatechosenbythedecisiontreelearneras afeaturethat correctlydistinguishes allobservations sofar.
1h.asanibnal haytham latinizedas alhazen 965 wasanarabresearcher of the islamic golden age.
his kit ab al man az.ir book of optics 1011 1021 was one of the first embodiments of the modern scientific method proving hypotheses through reproducible experiments that vary the experimental conditions in a systematic manner .
2in the example there cannot be more than one number but alhazen would be able to handleit if therewere.
start function number function sqrt sin cos tan number ?
.
?
figure agrammarforevaluating functions.
max parenleftbig number parenrightbig .
?
yes no figure alhazen sinitial hypothesis inthesqrtexample.
function sqrt ?
max parenleftbig number parenrightbig .
?
no yes yes no figure final decision tree after iteration .
function sqrt ?
result .0max parenleftbig number parenrightbig .
?
result .0result .0noyes yes no figure circumstancesforthe resultbeing .
ormore.
generating.
to precisely capture the failure circumstances we needfurtherexperiments.tothisend alhazen usesthegrammar as aproducer of inputs and systematically explore alternativesto the inputs observed so far.
for each decision branch in thetree alhazen generatesfurtherinputstorefineorrefute the associationwiththe predictedoutcome.
inourexample alhazen wouldgeneratemoreinputsforeach branch in figure .
these satisfy the given conditions from the tree butotherwisearerandomlychosenfromthegrammar say cos .
for the left branch and cos .
for the rightbranch.sincebothpass theoriginaldecisiontreeisinadequate.instead alhazen refinesthefailurehypothesissuchthat number must be less than .
.
note that this hypothesis isconsistent withallobservations sofar.
asalhazen generatesfurther inputsfor allbranches iteventually learns that the failure depends on sqrt being called.
after iterations alhazen deliversfigure which correctly describes the failure conditions the function sqrt is used andthe number isless thanorequal to .
beyond just pass and fail predicates alhazen can be applied to obtain explanations and predictions for arbitrary predicates over theprogramexecution.forinstance onecanuseittodeterminethe circumstances under which a specific output is produced figure showsthecircumstancesfortheoutputbeing4ormore.
notethat the trigonometricfunctionsreturn valuesinthe range .
since it requires no program analysis alhazen scales to arbitrarylargeprograms.
nethackisanadventuregames consistingof lines ofcode.
in january it was found thatnethack wasvulnerabletoabufferoverflow .usinga.inigrammarto parse its configuration file alhazen easily determines that the failure occurs as soon as some line in the configuration file has more than619characters figure .
alhazen can be seen as a full automation of the scientific method creating refining and refuting hypotheses from observations over specifically constructed experiments to eventually produce a theoryof when the program exhibits a specific behavior.
1229when doesmy program dothis?
learning circumstancesof software behavior esec fse november8 virtualevent usa len parenleftbig line parenrightbig ?
yes no figure decision tree foranethackfailure.
the grammar serves as parser and producer of inputs the decision tree captures the circumstances that distinguish program behavior.
the structure of this paper follows its three main contributions input elements as features.
section2 usingagrammartoparse inputsintofine grainedelements wecanassociatethepresence orabsenceof suchelementswithobservedprogrambehavior.
thismakestheseelements featuresformachinelearnersthat can thus infer precise models of program behavior from observed runs.
to the best of our knowledge ours is the first approach to combine general purpose parsing and machine learninginsoftware engineering.
creatinghypotheses forprogram behavior.
section using a decision tree learner we can extract associations between inputfeaturesandprogrambehavior.decisiontreelearnersare not very precise but they provide very good explanations to humans inourcase predicatesoverinputfeaturesthatcapture thecircumstancesofthebehavior.tothebestofourknowledge thisisthefirstuseofmachinelearnersovergeneral purpose inputfeatures for predicting fixing andproducing failures.
refining andrefuting hypotheses.
section using the grammar we can produce additional test cases to refine or refute hypotheses as produced from the learner we thus combine the explainability of decision trees with the production power ofgrammars.asthegrammarallowsustosystematicallytest alternatives this active learningapproach makesthe resulting diagnosis much more precise.
to the best of our knowledge the production of additional inputs to satisfy and refine decision tree constraints is novel making ours the first automated debuggingapproachproducingatheoryoversyntacticfeatures.
insection we evaluate the models generated by alhazen for their accuracy.
applied on a variety of real world bugs in standard programs including grepandfind wefindthattheresultingmodels preciselycapture failurecircumstances.
applied on javascript and its processors alhazen is able to isolate nontrivial conditions over elements that lead to failure.
after discussing related work section6 section7 closesthepaperwithconclusionandfuture work as well as linksto code anddata.
inputelements asfeatures alhazen associates properties of the input with program behavior.
thosepropertiesarederivedfromacontext freegrammarofthe inputlanguage.weusepresenceandabsenceofnon terminalsymbolsinthegrammar thelengthofindividualnodesinthepathtree thecodepointofcharactersinnodesandthenumericinterpretationofparsetreenodesasfeatures.thefollowingsectiondescribes the extractionofthesefeatures from an input.
start empty start suffix suffix a empty figure agrammarwith aloop.
.
context freegrammars a context free grammar consists of a start symbol and a set of production rules.
a production rule p consists of a nonterminalsymbol p ontheleftandacontrolform ontheright.
a controlform can be one of the following terminalsymbol.
a quotedstring.
non terminal symbol.
a symbolname inangle brackets.
concatenation.
a sequenceof controlforms.
quantification.
acontrolform calledthesubject annotatedwith one of or?.
alternation.
a sequenceof controlforms separatedby .
whenwriting grammars we use regular expressions delimited with slashes as control forms for better readability e.g.
in the number production of figure .
this is possible because any regular expression can be transformed into an equivalent context free grammar.weuseparenthesestoavoidconfusionaboutprecedence.
if a production rule has an alternation as its right hand side we call the control forms within this alternation the alternatives of the non terminal.
in a production rule p p has the alternatives and .
note that and are not considered alternatives of p ontheir own.
aproducer generates a parse tree from a grammar.
a simple basealgorithmforaproduceristogeneratethenodesofthetreein pre order.contrarytomoststandardtextbooks wehaveanodefor eachcontrolform soaderivationfor function sqrt cos has three nodes in total one for function one for the alternation andone for the chosenalternative.
wecallthesequenceofcontrolformsintheorderthenodeswere producedthe derivationsequence .onepossiblederivationsequence for the parse tree of sqrt is start concatenation of function number function alternation of sqrt tan ... sqrt number .this isapre order traversal of the parse tree.
there is one catch to look out for when implementing this algorithm.assumewewanttogenerateaparsetreeforthegrammar infigure and we want the leaf word to contain a .
within a node for start we need to decide which alternative we want.
we choose the second as this allows us to generate a .
in a pre order traversal we need to generate another node for start now.
as we didnot yet generate a it isquite easy to take thesame decision again and run into an endless loop.
we therefore allow the algorithm to create the child nodes for a concatenation in any order andadd themto the parentnode inthe requiredorder.
however this means that there are several derivation sequences forthesameleafword.asanexample start concatenation of function number function alternationof sqrt tan ... sqrt number isapossible derivation sequencefor sqrt just as well.
in some cases there can be different parse trees for the same word.
in this case we call the grammar ambiguous .
ambiguities in 1230esec fse november8 virtualevent usa alexander kampmann nikolas havrikov ezekielo.
soremekun andandreas zeller before therewrite start function number function sqrt tan sin cos number ?
.
?
after therewrite start function number sqrt function sqrt tan sin cos number ?
.
?
figure the last alternatives for startandnumber are added by therewritestep.
grammars usually stem from the fact that disambiguation relies on propertiesnotreflectedinacontext freegrammar apoorquality ofthe formalizationofthe inputlanguage oramixture ofboth.
throughoutthispaper weneedanotionofwhetheracontrol form q isreachable from a control form p .
thedistancefrom a controlform p toacontrolform q isthe minimalnumberof operations required to create a node labeled q after the creation ofanodelabeled p inthesubtreeof p .iftherecanbeanode labeled with q in the subtree of a node labeled with p we call q reachable from p .otherwise q isnotreachable from p andthe distancefrom p to q isinfinite.
.
grammartransformation thebehaviorswewanttoexplainaretriggeredbycomplexinput structures.whileallinputsarewordsofthegrammar thegrammar is often too fine grained to capture the essence of what causes a bug.
therefore we perform a rewrite step which adds additional alternatives that capture more complex structures.
to this end for allnon terminalsymbolsinthegrammar wedeterminetheword derivedbythissymbolinthebug triggeringinput and addthose wordsasalternativestothesymbol.
figure8showstherewritten grammarfor the calculatorexample.
in the rewritten grammar is added as alternative to number .
also the full string is added as an alternative to the start symbol.
we do not add sqrt as an alternative to function because it is already there.
note that the rewrite step makes all our grammars more ambiguous as they always have at least two parse trees for the inputwe startedwith.
creating hypotheses forprogram behavior weuseadecisiontreelearner tolearnassociationsbetween programbehaviorandinputfeatures.ineachiteration alhazen trains a learner on all known input samples and uses the obtained treetogeneratemoreinputs whichhelptorefinethetreeinthe nextiteration.
decisiontreelearnersexpressassociationsintermsofpredicates over numeric features i.e.max number .
.
as we want to reason about program inputs we need to extract numeric features fromprograminputs.wedosoby parsingeachinput andextracting features from the parse tree.
for each production rule and each alternative we considerthe following features existence.
this feature has a value of iff the production rule wasusedinthederivation sequencefor an inputat leastonce.
we write the existence feature for the production start as exists start .foralternatives wehaveanexistencefeature forthenon terminal e.g.
exists function andindividual existence features for each alternative e.g.
exists function sqrt .
length.
if for a production p p itself is reachable from p or a quantification is reachable from p we use the number of charactersin the word derived by p as a feature.
forthe production number we write this feature as len number .
iftheright handsideoftheproductionrulefor p isaquantification we insteadintroduceafeature qu len p which gives the number of child nodes of this quantification.
if p isusedmultipletimesinthederivation weusethemaximum valuefor both lenandqu len.
maximalcodepoint.
for all productions p that have more than one derivation we introduce a feature max char p for themaximal code point that is the maximal integer representation for all characters in the word derived by p .
if there are multiple wordsderived by p we usethemaximumcode pointacrossallwords.
numericinterpretation.
if a production p only derives words composedofthecharacters .and weintroduceafeature max p whichinterpretsthewordasafloating pointnumber.
again weusethemaximumvalueformultipleproductionuses.
all those features are derived from the parse tree of an input.
due to the ambiguity in our grammars we need to consider all possibleparsetrees.therefore weuseanearleyparser which gives usallpossible parse trees ratherthanjust one.
table1showsthefeaturevaluesfor sqrt .the start rule isused andsoisournewly introducedalternative so exists start andexists start sqrt bothhaveavalueof1.the length of this word is characters and the maximal code point is which corresponds to t .
if we had just one parse tree that wouldhavebeenall.however wecanalsoseethealternativeparse tree whichuses the pre existing rulefor start .in this parsetree wehaveexists function andexists function sqrt as1 but function cos as0.wecanagainseemaximumcode point features for function and number as well as the numeric interpretationfor number whichis .
generating tests to refinehypotheses asshownin figure1 alhazen usesafeedbackloop tosystematicallyrefineorrefutehypotheses.tothisend we generatetests that explore the variouspathsfrom the decision tree.
.
extracting predictionpaths in a decision tree each internal node contains a predicate f v wherefis a feature.
leaves are labeled with the program behavior.
whenadecisiontreelearnerclassifiesasample s ittraversesits internalstructureinthefollowingway startingattherootnode the predicate in the node is checked against the features of the sample.ifitisfulfilled the yes branchisexaminednext otherwise the traversal continues at the no branch.
as soon as the traversal 1231when doesmy program dothis?
learning circumstancesof software behavior esec fse november8 virtualevent usa table1 allfeaturevaluesfor sqrt andthetransformed subgrammarin figure feature value max char start len start function sqrt function cos function sin exists start exists start sqrt function tan max char function number number max char number max number len number reachesaleaf thelabelofthisleafistheprediction.thatis each prediction traverses a path from the root to a child node of the tree the predictionpath for this sample.
each path in the tree from root to leaf can be written as a sequenceofpredicates ofthe form fi vorfi v. to generate test inputs for all paths in the tree we take all subsetsofpredicatesonthepathand negatethem.forinstance for a path with the predicates f1 v1andf2 v2we would generate f1 v1 f2 v2 f1 v1 f2 v2 f1 v1 f2 v2 and f1 v1 f2 v2.
letusnowgeneratesampleswhichfulfillthesesetsofpredicates.
we then proceedinthree steps weslicethe grammar into a subset that does not contain productions prohibitedbythe tree predicates section .
.
we eliminate predicate sets that are infeasible within the grammar section .
.
we produce solutions for feasible predicates section .
whichwerepeatuntilthebestpossiblecandidateisfound within atime budget section .
.
.
slicing thegrammar westartbygeneratinga subsetofthegrammarwithoutproductions that would be prohibited by the existence predicates that is it excludesallproductions or alternativeswhere the predicate states that the existence feature is .
as an example if the predicate exists number .5isinthepredicateset wewould rewrite the production rule for number as number ?
.
?.
due to ambiguity a production may implicitly use a different productioninanotherderivationsequenceforthesameword.in the transformed grammar for our example figure using start sqrt means that number is used implicitly viaadifferentparsetreeforthesameword.forallproductions and alternatives which derive the same word in all parse trees that is the right hand side contains only terminal symbols or nonterminal symbols with just one production that recursively always derives the same word we precompute the set of productions that are used implicitly.
we also remove a production if this setcontains a prohibited production.
in the example the predicate exists number .5wouldleadtoremovalofboth and sqrt .
this addresses the ambiguity we introduced in the grammar transformation but not necessarily all ambiguities inthe grammar.
.
feasibility check inournextstep weidentifyandeliminatepredicatesetsthatare infeasible within the grammar existence.
productions and alternatives corresponding to existence features with f .
predicates are required by the predicateset.wecheckwhetherthosearereachablewithinthe grammarwithoutprohibitedfeatures.
length.
forlengthfeatures wecheckreachabilityonly aswith the existencefeatures.
maximalcodepoint.
we check reachability of the production rule and we check whether there is a terminal symbol that containstherequiredcodepointreachablefromtheproduction.
numericinterpretation.
we try to parse the string of the requiredvaluestarting at the production of the feature.
as an example let s assume we want to fulfill the predicate setmax char number .
is the ascii value for and canbecontainedin ?
.
?.so thepredicatesetpassesthefirsttest.next wecheckreachability within the sliced grammar.
number is reachable via the start production andtherefore this test ispassedas well.
ifapredicate setfailsoneof thosetests itisinfeasibleandwill not be considered.
.
producinginputs inthenextstep weproducecandidatesforderivationsequences that fulfill the given predicates.
togenerateaninput weproducethenodesofaparsetreeinpreorderasdescribedin section2.
.duringthisprocess thealgorithm needsto make three decisions for aconcatenation decidethe order of the children.
for aquantification decidehowmanychildren to add.
for an alternation decidewhichcontrolform to use.
each of those decisions corresponds to an element in the derivationsequence andeverytimethereismorethanonepossiblechoice.
each derivation sequence is split into a prefixand apostfix.
when this process creates a new sequence it lists all possible choices for the first decision in the postfix and generates one derivation sequencefor eachof those byappendingeachone ofthosetothe prefixofthissequence.foreachnewderivationsequence ituses a greedy approach to finish off the sequence.
the part that was generatedgreedilyisthenewpostfix.inthefollowing wedescribe this greedy approach.
each feature is associated with a control form.
when the greedy approach has to take a decision we choose an option such that the label in the new or next child node minimizes the distance to the closestofthosecontrolforms.whenthiscontrolformisreached mostfeatures require otherheuristics for the subtree of this node.
1232esec fse november8 virtualevent usa alexander kampmann nikolas havrikov ezekielo.
soremekun andandreas zeller forcodepointfeatures thereisalwaysaterminalsymbol that contains the required code point and we can use it as a target for the distancecheck.
for numeric interpretations we parse the required value and try to reach the root of this parse tree and the same children as inthe knownparse tree belowthe root.
forlengthpredicates wecanusethedistancetotheproductionthatthelengthrequirementbelongsto andwecanthen try to use longer orshorterderivations.
if there is no predicate which influences a decision we use the alternative whichallowsfor the shortest derivation sequence.
.
searching thebest derivation sequence the processin section .
can generatedifferent candidates which needto be rankedandrefined.
the search process maintains a list lof already analyzed derivationsequences.werankthosesequencesbasedonhowmanypredicates they fulfill and choose the current best derivation sequence for modification.
the newly generated derivation sequences are added to the list and may be chosen for refinement in the input productionfrom section .
.assoonasaderivation sequencefulfills all predicates the algorithm returns this input as a solution andterminates.
this search process will not terminate if the feature set is infeasible that is if it contains a combination of predicates that cannot befulfilled.ifwecouldnotgenerateasamplewithinthetimeout oftwominutes we considerapredicate setinfeasible.
withinalhazen wealwayshavealistofpredicatesetswhen westartthesearch.whileweuseonlyonesetforratingderivation sequences andstartwithempty lforthenextpredicatesetassoon aswefindasolution wecheckeachderivationsequenceagainst all predicate sets and output all matching inputs for each sequence.
evaluation we evaluate alhazen inthree differentscenarios predictor.
canalhazen beusedtopredictwhetheraninputtriggers the bug?
section .
producer.
canalhazen be used to produce more inputs that trigger the bug?
section .
debugging aid.
doesalhazen reducethesearchspaceindebugging?
section .
aswearenotawareofotherapproachesthatactaspredictorsor producers weevaluatethe accuracy ofalhazen inthesescenarios.
by assessing the quality of decision trees both as predictors andproducers weensurethattheyneitheroverspecialize which wouldmakethemaccurateproducers butinaccuratepredictors nor overgeneralize whichwouldmakethemaccuratepredictors but inaccurate producers .
for the third scenario we evaluate whether alhazen separatesrelevantfromirrelevantinputfeatures allowing developers to focusonasubsetofthe inputlanguage.
.
evaluationsetup .
.
subjects.
for any predicate over observable program behavior alhazen can explain the circumstances that trigger this behavior in terms of input features.
in our evaluation we focustable subjectsand predicates ofinterest bugid predicate bugid predicate ofinterest ofinterest calculator.
errormessage find.24bf33c0 property closure.
exception find.b445af98 regression closure.
exception find.e1d0a991 regression closure.
exception find.ff248a20 timeout closure.
exception grep.c96b0f2c property closure.
exception grep.2be0c659 regression closure.
exception grep.3220317a crashoracle rhino.
exception grep.3c3bdace crashoracle rhino.
exception grep.55cf7b6a regression genson.
exception grep.5fa8c7c9 timeout find.07b941b1 crashoracle grep.7aa698d3 regression find.091557f6 crashoracle grep.c1cb19fe regression find.dbcb10e9 crashoracle on explaining undesired program behavior bugs .
table 2lists our subjectsandpredicates.
usingthesamefuzzeras wefoundninebugsinthegoogle closurecompiler themozillarhinojavascriptruntime andthe gensonjson parser .
thosebugsareagoodfitfor alhazen becausetheyaretriggered by a specific input by construction fuzzing generates inputs .
all three subjects are written in java and report the exception type fileandlinenumberifanerroroccurs.weusedthisinformation for our predicate ofinterestinthe same wayas did.
asfourthandfifthsubject wetookthe grepandfindcommand lineutilsfromthedbgbenchbenchmark .dbgbenchprovides themeanstocompileandexecuteoldversionsof grepandfind and documents the bugs that were present in those old versions.
we useddifferentpredicates of interesthere.
crash.we checkwhether the program crashes.
timeout.
wecheckwhethertheprogramterminateswithin500ms.
regression.
wecheckwhethermorerecentversionsof grepor findrespectivelyshowthe same behavior.
property.
greponly ever outputs a substring of the input and find only ever outputs path to existing files.
we use checks for thosepropertiesas oracles.
table2listsour subjectsandthe relatedpredicate type.
.
.
evaluation grammars.
in our evaluation we use a grammar for eachsubject forthegoogleclosurecompiler mozillarhino andgenson we adaptedgrammarsfound inthepopular githubrepository for antlr grammars .
antlr is a widely knownparser generator.
forgrepandfind we wrotegrammars ourselves.
forgrep the grammar generates a full shell command consisting of an input a list of environment variables and an invocation of grep.
the input is an alphanumeric string whichmaycontainutf 8multibytecharacters.thegrammar allows for all environment variables that are documented in the man page of grepfor the oldest version we used.
the grammar allows for all command line flags that are documentedinthe manpage of grepfortheoldest version we used.
1233when doesmy program dothis?
learning circumstancesof software behavior esec fse november8 virtualevent usa thefindgrammaralsogeneratesafullshellcommand and allowsforenvironmentvariablesandcommandlineflags.in addition the findgrammar generates a sequence of mkdir touchandlnshellcommandstogeneratedirectories files andsymbolic links.
.
.
generatingdatasets.
asothermachinelearningapproaches evaluatingourapproachrequiresalargesetofinputdata.wecould just generate samples randomly but it is very unlikely to generate abehavior triggeringsamplewithapurerandomproducer.having nobehavior triggering samples inthe data setmakesituseless.
toavoidthis weuseamodifiedversionofthe moreofthesame approach taken by pavese et al.
.
a word is derived from the grammarbyreplacingnon terminalswiththeright handsideofone oftheirproduction rules untilthereisnonon terminalleftinthe resulting sequence.
if a production rule has multiple alternatives a random produceris employedto select which alternative is chosen.
the input sample is a word in the grammar therefore it has a sequence of derivations that generate it.
in our sample generation weincreasetheprobabilityofchoosingthesamealternativeasin the initialbug triggering input.
foraword w let w p bethenumberofoccurrencesof p withinw s derivation sequence and let p be the number ofoccurrencesofthealternative p withinthissequence.for ambiguous grammars let w be the sumofthosecounts for all possible parse trees.
using those counts to calculate probabilities directly would generatethesamesampleoverandoveragain.foraproductionrule q wethereforedefineasmoothedcount s q withs q q .further s q isthesumover thesmoothed counts for all alternatives of q .for our grammarbased fuzzing the probability to choose the alternative q over q or q isp q s q s q .
this approach may still generate the same sample over and overagain soweremoveduplicates andre rununtilwehave1000 unique behavior triggering samples the number of non behaviortriggering samples usually is larger than at this point .
we stoppedwithasmallernumberofsamplesif20re runscouldnot generate enough behavior triggering samples or a timeout of hourwasexhausted.
table3givesthenumberofbug triggeringand nonbug triggeringsamplesforeachsubject.pleasenotethatwe ranthisalgorithmwiththetransformedgrammars see section2.
.
itisclearlyvisiblethatsomebugsarehardertotriggerthenothers.forfind.07b941b1 andfind.24bf33c0 itseemstobe eveneasiertotriggerthebugthangenerateabenigninputsamples.
ontheotherhand somebugsareparticularlyhardtotrigger.for grep.7aa698d3 wehavejust25bug triggeringinputsamples.
thisbugrequiresamultibytecharacterintheinput and aregex matching this multibyte character as an argument to grep.
the probabilities do not model relations between different parts of the input sothe producergeneratesthis structure only bychance.
then we split the generated samples into sets.
4of the bugtriggeringsamples thebenignsamples iftherewerelessbenign thanbug triggeringsamples willbeusedastrainingset andthe remaining3 4of them will be the test set.
afterwards we randomly selectbenignsamplesforthetrainingset suchthatthetrainingset has the same number ofbenign andbug triggering samples.table3 numberofbug triggeringvs.nonbug triggeringinputsafter generating inputs.
subjectallsamples trainingsamples benign bug triggering benign bug triggering calculator.
closure.
closure.
closure.
closure.
closure.
closure.
rhino.
rhino.
genson.
find.07b941b1 find.091557f6 find.24bf33c0 find.b445af98 find.dbcb10e9 find.e1d0a991 find.ff248a20 grep.2be0c659 grep.3220317a grep.3c3bdace grep.55cf7b6a grep.5fa8c7c9 grep.7aa698d3 grep.c1cb19fe grep.c96b0f2c next we split the remaining samples into sets such that each set isas large as the training set each set has the same number of benignandbug triggeringsamplesandeachsampleiscontained inat leastone set.
.2alhazen as apredictor toevaluatewhether alhazen canpredictwhetheraninputisbugtriggering wegeneratedsamplesetswithadifferentapproach see section .
.
andcalculatedprecision andaccuracyonthose.
weranalhazen onthetrainingsetwithtwodifferentseedsfor therandomproducer andevaluatedeachrunonallthesets.within theseruns weperformedatmost40iterationsofthefeedbackloop andstoppedifwedidnotgenerateanynewsamplesinaniteration.
theresultsarereportedin table4.precisionandaccuracynumbers are averagesover tworuns for eachset.
we see that alhazen works very well as apredictor used as predictor alhazen classifies of all inputs correctly.
besidesdemonstratingthehighaccuracyofthedecisiontrees produced by alhazen this also has some practical value.
most importantly it means that alhazen can be used for automatic workarounds divertingpotentially failure inducinginputbefore it reachestheprograminquestion afeaturethatwouldbeespecially valuable if the failure of interest is a vulnerability.
since alhazen runs fully automatically such workarounds can be deployed as soonas afailure isdetected.
1234esec fse november8 virtualevent usa alexander kampmann nikolas havrikov ezekielo.
soremekun andandreas zeller table precision and accuracy when using alhazen as a predictor.all valuesare averages over2 runs.
bug precision accuracy bug precision accuracy calculator.
.
.
find.ff248a20 .
.
closure.
.
.
genson.
.
.
closure.
.
.
grep.2be0c659 .
.
closure.
.
.
grep.3220317a .
.
closure.
.
.
grep.3c3bdace .
.
closure.
.
.
grep.55cf7b6a .
.
closure.
.
.
grep.5fa8c7c9 .
.
find.07b941b1 .
.
grep.7aa698d3 .
.
find.091557f6 .
.
grep.c1cb19fe .
.
find.24bf33c0 .
.
grep.c96b0f2c .
.
find.b445af98 .
.
rhino.
.
.
find.dbcb10e9 .
.
rhino.
.
.
find.e1d0a991 .
.
total .
.
the only case where alhazen has an accuracy of less than isgrep.2be0c659 wherethefailureoccursifagivenregex matches the input a property not modelled by our features.
while alhazen can check for features which make such a match more likely e.g.a .
inthe regex the predictive power suffers.
.3alhazen as aproducer let us now examine how well alhazen performs as a producerfor moresamples.weran alhazen onthetrainingsetswegeneratedin section5.
.
andobtainedthepredicatesetsfromthefinaltree.as before wegeneratedsamplesforallpaths andgeneratedvariations ofthosesubsetsasdescribedin section4.wethencheckedwhether the prediction ofthe tree matches actual program behavior.
table5givestheresultsforthisexperiment.the failinginputs column lists the absolute number of new failure inducing inputs generated.
the final decision tree may have multiple paths that leadtothepredictionofafailure.
alhazen generatesanewsample foreachofthesepaths however ifitrunsintoasamplethatfulfills allpredicatesononepathwhilesolvinganother thissamplewill also be reported.
hence a value of means either that the tree had four paths or it had two paths and three solutions for one of them were discoveredwhilesearching for asolution for the otherone.
forthelargemajorityofsubjects alhazen produced several new failure inducinginputs.
such additional inputs that trigger the bug can be very valuable in practice.
in manual debugging they can serve as a test set to ensurethebughasactuallybeenfixed.forautomatedrepairs they canensurethatallaspectsofabughavebeenfixed andnotonly the symptoms ofthe singlefailure inquestion.
the precision columnshowsthepercentageofthesefailureinducing inputs within the entire set of inputs.
we see that in total about two thirdsof allproducedinputs actuallytrigger the failure.
3in practice what would be helpful here is a more domain specific feature such as regex matches .
for this evaluation however we stick to the generic features introduced in section which we chose well before starting the evaluation.
overspecialization in the set of features is a real risk for evaluation in the extreme a hypothetical will fail featurewould always yield perfect results.table precision and accuracy when using alhazen as a producer.precision and accuracyare averages over2 runs.
bug failing inputs precision accuracy calculator.
closure.
.
.
closure.
.
.
closure.
.
.
closure.
.
.
closure.
.
.
closure.
.
.
find.07b941b1 .
.
find.091557f6 .
.
find.24bf33c0 .
.
find.b445af98 .
.
find.dbcb10e9 .
.
find.e1d0a991 .
.
find.ff248a20 .
.
genson.
.
.
grep.2be0c659 .
.
grep.3220317a .
.
grep.3c3bdace .
.
grep.55cf7b6a .
.
grep.5fa8c7c9 .
.
grep.7aa698d3 .
.
grep.c1cb19fe .
.
grep.c96b0f2c .
.
rhino.
.
.
rhino.
.
.
total .
.
on average .
ofthe inputsproduced by alhazen as failure inducingactuallytriggerthe failure.
for programs where a bug is easily triggered this number indicatesahighefficiencyoftestgeneration.evenifatestunexpectedly passes one can simply repeat it with the next input a precision of .
means that fewtests needto be repeated.
for some programs however the conditions to trigger a bug arehardtomeet andevenhardertomodel.indeed forsomesubjects alhazen doesnotgenerateanynewfailure inducinginput atall.forbug grep.c96b0f2c alhazen needstogeneratean inputthatcontainsanemptyline andaregexwhichmatchesan emptyline for closure.
thebugistriggeredonlybyaspecific nesting of syntax elements.
both regex matching and element nestingare not reflectedbyour genericinputfeatures.
on the other hand if one uses alhazen to produce passing inputs a failure is very unlikely.
this is reflected in the accuracy column where we see how manyoftheinputs produced by alhazen as passing and failing actually are passing and failing.
the total shows the overall very high accuracy of alhazen as a producer.
on average .
ofthe inputsproduced by alhazen as passing orfailingactuallypassand fail as produced.
1235when doesmy program dothis?
learning circumstancesof software behavior esec fse november8 virtualevent usa .4alhazen as adebuggingaid wealreadyhaveseenthatusing alhazen aspredictorandproducer can be very useful in debugging.
it may also be interesting how to use thetrees directly.however it isnot yetclear tous and outof scope for this work howto present thosetrees to developers.
most published automated debugging techniques are evaluated for theirfault localization capability that is their ability to predict whereabugshouldbefixed.focusingoncodeisnotappropriate foralhazen as it does not predict a bug location actually as it treats the program under test as a black box it neither has nor needs nor produces any concept of a fault location.
this makes alhazen especially useful if the program in question say a neural network has noconcept ofafaultlocation either.
otherautomateddebugging techniquesallow developersto focus on the relevant parts of the input delta debugging for instance automaticallyreducestheinputtoaminimuminwhich allcharactersarerelevantforproducingthebug.theamountby whichthesearchspaceis reduced however depends moreonthe input which may contain more or less relevant characters than the actual approach.
thisismoresuitablefor alhazen asalhazen alsoworkson input representations.
however we do not minimize an existing input as delta debugging does instead we report which parts of inputstructurearerelevant.wedonotyetknowhowtopresent this information to developers butwe assume that a model which reportsasmallpartoftheunderlyinggrammarallowsthedeveloper tofocusmuchmore.smallerislesscomplicated andthereforeeasier to interpret.
for evaluating how much alhazen can help in reducing the searchspace wethereforeintroduceameasurethatisindependent ofanimplementation andindependentofconcreteinputs.in table6 we have evaluated how many of the non terminal symbols and alternatives from the grammar occur in the decision tree.
the idea behindthisisthateachnonterminalandalternativeinthegrammar standsforaspecificconcept thefewersuchconceptsaprogrammer hastodealwith theeasieritwillbeforhertocapturethespecifics ofthe bug andeventually to fixit.
ifthetreeuses exists number inonenodeand max number in another one this will be counted as one nonterminal symbol number the programmer will have to deal with as a relevant concept in contrast to string loop and several more that do not occur inthe tree andthus are deemedirrelevantfor the bug.
we see that on average the decision tree makes use of only .
of nonterminals and only .
of alternatives in the respective grammar.
in other words whatever happens with .
of nonterminalsisirrelevantfortherespectivefailuretooccur.this meansthatprogrammerscanindeedfocusonasmallpercentage ofrelevantinputfeatures.
the decision trees produced by alhazen allow programmers to focusonlessthan5 ofinputfeatures.
theactualpercentagehighlydependsonthesizeofthegrammar.
forcalculator.
whichusesthegrammarin figure2 .
of thegrammararemarkedasrelevant however withsuchasmalltable tree size and ofgrammarused persubject.
bug nodes leaves ofgrammar used non terminals alternatives calculator.
.
.
.
.
closure.
.
.
.
.
closure.
.
.
.
.
closure.
.
.
.
.
closure.
.
.
.
.
closure.
.
.
.
.
closure.
.
.
.
.
find.07b941b1 .
.
.
.
find.091557f6 .
.
.
.
find.24bf33c0 .
.
.
.
find.b445af98 .
.
.
.
find.dbcb10e9 .
.
.
.
find.e1d0a991 .
.
.
.
find.ff248a20 .
.
.
.
genson.
.
.
.
.
grep.2be0c659 .
.
.
.
grep.3220317a .
.
.
.
grep.3c3bdace .
.
.
.
grep.55cf7b6a .
.
.
.
grep.5fa8c7c9 .
.
.
.
grep.7aa698d3 .
.
.
.
grep.c1cb19fe .
.
.
.
grep.c96b0f2c .
.
.
.
rhino.
.
.
.
.
rhino.
.
.
.
.
average .
.
.
.
unicode no minus u ?
no len start ?yes yes lc all en us.utf ?no no first inputchar digit digit digit yes len first inputchar ?no len inputstring ?yes yes no yes no figure decision tree forgrep.7aa698d3.
grammar this means two non terminal rules.
for the largest grammar in our selection javascript used with closure and rhino alhazen can reduce the relevantelements to .
onaverage.
.
limitations whileallowingprogrammerstofocusonspecificaspects theinferreddecisiontreescanstillbecomplex.thisreflectsthecomplexityoftheunderlyingbugs whichinturnalsoshowsthelimitsof ourapproach.infact thebugsinourevaluationhavenon trivial 1236esec fse november8 virtualevent usa alexander kampmann nikolas havrikov ezekielo.
soremekun andandreas zeller descriptionseveninnaturallanguage andthiscomplexityisalso reflectedinthedecisiontrees asweseeinthefirsttwocolumnsof table the average decision tree has about nodes and leaves.
the tree in figure forgrep.7aa698d3 is a typical example reflecting complex conditions.
the actual bug occurs with all characters where the unicode representation of the lower case variant has fewer bytesthanthe representation ofthe upper casevariant.
since our tree can only use numeric comparisons of unicode codepoints itcannotfullycapturethiscomplexcondition shortof listingallcharacterswiththisproperty notethatunicodecharacters with this property are not in a continuous area of the unicode representation.
.instead thetreechecksforthesingleunicodecharacter u i with dot for which the above condition holds.
this ofcourse isan overspecialization.
the notation digit digit digit is an alternative for how unicodecharacterscanbeencoded sothetreere iteratesthatthere should be aunicode character inthe input.
to more precisely capture the failure condition as above one would again have to provide alhazen with specific features to check for in our case a vocabulary over external and internal unicodeproperties.butevenwiththetreebeingimperfect itclearly points to the correct features namely the one important unicode character as well as the unicode context.
both of these are very relevantfeatures outofseveralhundredinthegrepinputgrammar for understanding the circumstances of the failure and provide importanthints for fixing it.
forbest results theset ofinputfeatures used by alhazen shouldbeadaptedtothefunctionalityoftheprogramundertest.
.
threatsto validity insection5.
weusethesamealgorithmtogenerateinputsasin alhazen siterations.ifthereissomepropertyoftheproducerthat leads to properties of the generated input that are not described inthedecisiontrees thiswouldhaveapositiveinfluenceonour results.
one such property could be that our producer always tries to minimize the derivation sequences.
we are not aware of any otherproducerthatcouldgeneratesamplesfromagrammarand apredicate sothereiscurrentlynoalternativetothisevaluation.
atthe sametime ourclaimis that alhazen canhelp togenerate more inputs which trigger the desired behavior which is true even if itworks only withour producer.
related work grammars andgrammar mining.
the key ingredient to alhazenisagrammar usedfor extractingfeaturesfromtheinput byparsingit and generating additionalinputsforrefiningand refuting hypotheses.
the double usage of grammars as parsers and producersiswell knownintheliterature.whatisnewin alhazen 4what we also see are three lenpredicates in the tree.
the first one captures the fact that you need a minimum length of in our setting to have a unicode character passed as an argument.
the other two are cases of coincidental correlation that is featuresthathappentomatchallobservationssofar butwhichhavenotbeenrefuted byourgenerationalgorithmyet.thesefeaturesdonotsignificantlyimpedeprediction or production accuracy however and would be eliminated with an increasing number of iterations.though is the generic usage of a grammar to learn features for machine learning and debugging as well as the combination of parsingandproducing as embodimentof the scientificmethod.
recentdevelopmentsin mininggrammars fromprograms might considerably reduce the effort of writing the required grammars.parser directedtestgeneration caneliminatethe needfor sample inputsto learn grammars from.
input reduction.
input reduction refers to techniques that automaticallydetermineasubsetoftheinputthatstillreproducesthe failure such simplification is an important prerequisite for debugging.deltadebugging istheearliestandsimplesttechniquefor reducing inputs going through a number of tests it reduces any input to a minimum in which removing any character no longer causesthe failure.
later variantsof input reductioncombine delta debugging with grammars for faster reduction or are set upto simplifycomplex inputlanguages .
alhazen sharesanumberofideaswithinputreduction notably the goal of eliminating circumstances that are irrelevant for the failure theconceptofworkingonsysteminput and theidea of refining or refuting hypotheses via generated tests.
there are two core differences though.
first alhazen can create theories fromobservationsonly withouttheneedforexecutingadditional tests.
second alhazen generalizes over reduction techniques in that the resultisnot one singlesimplified input butamodel for a set ofinputs that explains andreproduces the failure.
statisticalfaultlocalization.
statistical fault localization searchesfor statisticalassociations betweenprogramfailures andprogramruntimefailures notablytheexecutionofspecificcode locations.
given a sufficiently large number of executions a small setoflinesexecutedonlyinfailingrunsmaybedetermined making these natural candidates for further investigation or even fixes.
whiletheusefulnessofstatisticalfaultlocalizationforprogrammers isdisputed thegivenlocationsmakeimportantstartingpoints for automatedrepairtechniques .
chen et al.
use a decision tree to learn which component in a large internet site causes a specific failure.
this is close to our approach in that it uses decision trees but still a kind of fault localization as a specific component within a multi component systemisidentified.
just like statistical fault localization alhazen creates associations involving program failures.
however the alhazen associations refer to features of the input which is an important conceptual difference.
since input features refer to the problem domain and areindependent ofagiven implementation theymaybeeasierto understandthancode locations withoutany context.
a second important conceptual differenceisthat alhazen allows for refining or refuting hypotheses through test generation this is possible as it uses its grammar as producer.
in practice this means thatalhazen can start with a single failing run only.
a similar feature for statistical fault localization would require the ability to generate tests that execute or do not execute a particular line whichishardinpracticeandundecidable ingeneral.
holmes alsousestestgenerationtocreatemoretestssimilar to a failing test but does so on pure luck there is no systematic explorationofhypothesis.r leretal.
combinestatisticalfault localization with test case generation and therefore systematically 1237when doesmy program dothis?
learning circumstancesof software behavior esec fse november8 virtualevent usa test hypothesis.
they however still work on source code rather thaninputs.
dynamic invariants.
dynamicinvariantsarepropertiesinferred overobservationsinagivensetofprogramruns.iftheargument x tosqrt x is always non negative for instance a dynamic invariantdetectorlikedaikon caninferthepreconditioncandidate x .daikonachievesthisbystartingwithalargesetofpotential invariants keeping only thosethat apply inallruns.
likedynamicinvariants alhazen generatesabstractionsthatapplyinasetofruns itspredicates however applytoinputelements ratherthanfunctionargumentsandreturnvalues thisalsogives alhazen theabilitytogenerateadditionaltestsasneeded whichis not easily possible for dynamic invariant generation.
however the alhazen predicates atthis pointonly involve the presence of specific elements or production alternatives.
a wider set of features as with daikon including arithmetic set and string properties over input elements could dramatically improve the diagnostic capabilitiesofalhazen albeitattheexpenseofmakingtestgeneration more difficult.
conclusion and futurework learninghowinputfeaturesdetermineprogrambehavior as alhazendoes opensnewperspectivesforprogramunderstanding anddebugging notonlycharacterizingthecircumstancesunder which a program fails but also predicting failures for given inputs as well as producing additional inputs that cause failures.
our evaluationshowsthat alhazen performsallofthesetaskswithhigh accuracy demonstrating the potentialofthe approach.
weseealhazen asabigsteptowardsbetterdebugging butalso asaplatformandopportunityforlotsoffurtherresearch.future work includes domain specific features.
the vocabulary that alhazen can usetocharacterizefailurecircumstancesisintentionallylimited to the very syntactical and numerical basics.
adding more featuresthatcatertothedomainoftheprogramathandcouldyield much crisper and possibly even more precise failure characteristics.thechallengeistostriveabalancebetweengenerality andspecificity.
explainable ai.
astheprogramundertestcanbearbitrarylarge or obscure alhazen can also be used to produce explanations for the behavior of artificial intelligence systems again one wouldneeddomain specificfeaturesthathelpdistinguishing behavior.
efficient refinement.
weareexploringmoresophisticatedmethodsfor testing hypothesesthat systematically cover language features.
intercorrelated features.
inagrammar severalfeaturesintercorrelate with each other in our expression example a number canonlyoccurifa function occursaswell.thelearnercan settleoneitherofthesetodistinguishpassingfromfailingruns suchchoices however mayimpactperformanceanddiagnostic qualityofthe resultingtrees.
alternatelearners.
whiledecisiontreescanbeeasilyreadbyhumans othermachinelearners suchassvmsorneuralnetworks could capture failure circumstances much more precisely.
the challenge will be to use these learners to generate additionalinputs to refine hypotheses and to extract human readable descriptionsoffailure circumstances.
program analysis.
guidance from static or dynamic program analysis could greatly enhance hypothesis forming and testing.
beyond failures.
thediagnosticcapabilitiesof alhazen easily extend to arbitrary program behaviors such as the circumstances under which a particular resource is accessed a data flowtakesplace afunctioniscovered memoryisexhausted andmanymore.
alhazen andallexperimentsdescribedinthispaperareavailableforreplicationandextension.forreviewpurposes wehave compiledareplication package withallcode anddata at