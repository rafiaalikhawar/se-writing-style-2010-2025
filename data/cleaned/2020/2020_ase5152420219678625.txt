automated repair of size based inaccessibility issues in mobile applications ali s. alotaibi university of southern california usa aalotaib usc.edupaul t. chiou university of southern california usa paulchio usc.eduwilliam g.j.
halfond university of southern california usa halfond usc.edu abstract an increasing number of people are dependent on mobile devices to access data and complete essential tasks.
for people with disabilities mobile apps that violate accessibilityguidelines can prevent them from carrying out these activities.size based inaccessibility is one of the top accessibility issuesin mobile applications.
these issues make apps difficult to use especially for older people and people with motor disabilities.existing accessibility related techniques are limited in termsof helping developers to resolve these issues.
in this paper we present our novel automated approach for repairing size based inaccessibility issues in mobile applications.
our empiricalevaluation showed that our approach was able to successfullyresolve of the reported size based inaccessibility issues andreceived a high approval rating in a user study of the appearanceof the repaired user interfaces.
i. i ntroduction mobile devices have become one of the most essential means for accessing information and services.
from ecommerce to covid vaccine passports the ability to accessmobile applications apps is important for everyone.
this isparticularly true for the of the global population withdisabilities that depends on mobile devices to complete dailytasks .
despite the various legislation and efforts to ensure mobile technologies are accessible to all mobileapps today still suffer from a wide range of accessibility issues that prevent users from interacting with theapp s intended functionalities.
touchscreen technology has been the most prominent input method for users to interact with mobile devices .
yet interacting with mobile devices by touch can be difficultfor many people such as older adults and those with motorimpairments e.g.
paralysis tremors or neurological diseases .these difficulties can translate into imprecise touches in creased touch mistakes or even the inability to access im portant functionalities in mobile apps.
studies have shownthat inadequate size of touch targets is the root cause thatmanifests these difficulties .
this typeof issue known as size based inaccessibility issue sbii occurs when the size of a touch target is less than the minimumsize specified by the accessibility guidelines .recent studies have shown that sbiis are among the mostprevalent accessibility issues that affect mobile apps .in fact a study on real world apps from app categories ofthe google play store showed that small touch target size wasranked as the second top accessibility issue .
another recentlarge scale empirical study on accessibility issues found that78 of apps had more than of their elements too smallto pass the accessibility tests .
automatically repairing sbiis is a challenging task for several reasons.
first a repair must account for multiple sbiisholistically in order to preserve the relative consistency of theoriginal user interface ui design.
second due the complexrelationship between android ui components there is no clearway of identifying the set of views and properties that needsto be modified for a given sbii.
finally assuming that therelevant views and properties can be identified a change in sizeof one touch target element can introduce further alignmentor spacing issues to other areas of the ui.
together thesechallenges make a seemingly simple repair difficult to achieve.
existing approaches cannot help developers repair sbiis.
research by zhang et al.
developed prototypes to addressandroid accessibility by enhancing user interactions.
theirwork interactiles focuses on making touchscreens accessible by attaching a hardware interface to the android phone sscreen to enhance tactile interaction for the visually impaired.similar hardware overlay techniques have beenproposed in hci research but they do not fix the underlyingissues and require the hardware cutouts to be tailored to fit thedevices.
software based approaches to improve touchscreenaccessibility are more robust but they mostlyfocus on using audio based interaction techniques to allowthe visually impaired to access touchscreens.
zhang alsointroduced interaction proxies to be inserted on top of anapp s original ui for disabled users to more easily manipulatethe app .
while this approach can potentially address size based inaccessibility it relies heavily on manually remappinginteraction into new interactions.
touch guard helpsusers to access inaccessible small touch targets by enhancingtheir touched areas with screen magnification to enlarge andto disambiguate the bounds between multiple targets.
theseexisting tools merely operate as assistive technologies toprovide increased usability.
however they do not provide away to help app developers repair the root causes of theproblem.
in this paper we introduce a novel approach for automatically repairing sbiis in android apps.
our approach definesa novel graph based model called the size relation graph srg that models the visual and rendering relationshipsamong elements in an android ui.
the srg allows our 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee approach to effectively identify the set of problematic touch targets that need to be modified to repair the ui.
to computethe best repair our approach employs a multi objective geneticalgorithm to search for a solution that minimizes layoutdistortion.
our approach generates a repair patch and uses itto automatically generate a new apk of the repaired androidapp.
the results show that our repairs can effectively fix sbiis.
in a user study that evaluated the repaired uis of theparticipants rated the repaired ui as equal to or more preferredthan the original.
overall these results are very positive andindicate that our approach can help developers improve theaccessibility of their mobile apps.
the contributions of ourpaper are as follows the first ever technique for automatically generating repairs to improve size based accessibility in android apps.
a novel graph based model of the visual and rendering relationships among the elements in an android ui.
an empirical study on real world apps that shows our approach is effective in improving android accessibility.
a user study that shows our repairs do not compromise the ui s attractiveness and are preferred for mobile usage.
our paper is organized as follows in section ii we providebackground information on mobile accessibility.
then in sec tion iii we present our approach in detail and its evaluationin section iv.
we discuss related work in section v andconclude in section vi.
ii.
b ackground an android app consists of a set of activities.a n activity is the class that creates the user interface ui window and isitself comprised of a group of elements that are either views or viewgroups.a view occupies a rectangular area on the screen and is visible by default e.g.
buttons .
a viewgroup is a view that can contain other views as children.
a touch target refers to any element on the ui that a user can touch click orinteract with to perform some action.
these include interactiveelements e.g.
buttons and non interactive elements attachedto event handler that allow them to respond to user actions e.g.
implementing an onclick method for an imageview or alinearlayout .
the visual properties of an element can be configured using a set of attributes.
android uses these attributes to determinethe size and placement of elements when rendering the ui.the size of an element is expressed as a width and a heightthat can be configured using the attributes layoutwidth and layoutheight respectively.
each attribute can be specified by using a specific number e.g.
30dp or using a certain size constant i.e.
match parent o r wrapcontent .
if an attribute is specified using a specific number then it canhave a size that is equal to at most that number although itmay not be able to achieve that size due to constraints of theui .
an element with an attribute specified as match parent means that the element wants to match the size of its im mediate parent.
an element with an attribute specified as wrap content means that the element wants to expand to fitits content or children .
other attributes may also affect thesize of an element.
these include attributes such as padding which defines the spacing between an element s borders andits encompassed content minwidth andminheight which specify a minimum bound constraint on the height and width andmargin which defines the spacing between an element and its neighboring elements.
changing the value of oneattribute may impact the value of the other.
for example increasing the size of an element may reduce the spacing ithas with another element.
all of the elements in an activity can be represented in a tree based model of the layout called a view hierarchy vh .the vh contains information about the logical relationshipsamong views e.g.
parent child and information about thevisual aspects of each view such as color size and location.numerous tools such as ui automator can be used toto extract an xml file representing the vh.
other tools likelayout inspector can also parse the app s layout filesto extract these attributes and then augment this informationwith the information obtained from dumping the state of therunning ui.
web and mobile accessibility guidelines require apps to have touch targets that are sufficient in size.
the requirementis outlined in google s material design principles for androidaccessibility and guideline .
.
of the international ac cessibility standard wcag .
.
the guidelines formallyspecify that mobile apps touch targets should be at least48dp 48dp with respect to the screen .
testing tools such as google accessibility scanner accessibilitytesting framework and ibm s mobile accessibilitychecker can detect touch targets issues in mobile appsbased on these guidelines.
in this paper we use the term size based inaccessibility issue sbii to refer to any violations ofthis guideline where a touch target falls below the requiredsize threshold.
iii.
a pproach the goal of our approach is to automatically repair the sbiis in a mobile app s ui while maintaining as much as possible the aesthetics and design of the original ui.
fixing sbiis asdescribed in section ii requires changes to the properties thatcontrol the size and placement of elements in the ui to allowthe ui to meet the accessibility requirements.
finding the newvalues that fix the sbiis while maintaining the ui s aestheticis complicated by several challenges.
the first challenge is to maintain the visual consistency of the ui design.
for example for a navigation bar with a set ofmenu items changing the size of one item without updatingthe other menu items will distort the navigation bar s visualconsistency.
the second challenge is knowing what needs to be changed in order to fix the sbiis.
directly changing the elements with accessibility problems does not always fix theproblem due to the fact that the final rendered appearance of anelement depends not only on its properties but its containingelements and nearby elements.
therefore the set of elementsand properties that need to be adjusted to fix the sbiis often 731localization compute generate a repairapply repair to ui generate repaired apk repaired apk app s vh a11y report identifying visual groups repair clustering visually related groups eaea e p fitness score terminate?
construct srg yesno fig.
an overview of our approach include other elements in addition to the one with an sbii.
the third challenge is that a repair can have a cascading effect .a change to one part of a ui can trigger a chain of changesin other parts of the ui as elements change and move toaccommodate the change.
this challenge is compounded withthe existence of multiple sbiis in a ui or when many elementsmust be adjusted together to maintain the visual consistency which increases the likelihood that the final layout will bedistorted.
figure shows an overview of our approach which can be broken into three phases identifying visually related elements localization and repair.
the input for our approach is an apkof an app along with a detection report that lists each ofthe app s inaccessible activities ias activities that exhibit sbiis along with details about the sbiis of each of theseactivities.
the detection report can be provided by automateddetection techniques such as google accessibility scanner or accessibility test framework for android gatf for each ia in an app this step analyzes its layout to identify and group visually related elements that need to beadjusted together to maintain the visual consistency of the ui.the localization step then identifies and relates sbiis to a setof elements and properties that need to be adjusted to repair thesbiis.
finally the repair step performs a guided search to findthe best values for the identified set of elements and propertiesthat repair the sbiis in the ia while maintaining as much aspossible the aesthetics of the ui.
when the search terminates the best values obtained for all selected elements are used toupdate the ia s corresponding static layouts.
once all of theias in the app are repaired the app is compiled and providedas the output of the approach.
we now explain the parts of theapproach in more detail in the following subsections.
a. phase identifying visually related elements the goal of this phase is to identify the sets of elements that should be adjusted together to maintain the visual consistency of the repaired layout.
maintaining the consistency amongvisually related elements e.g.
items in a menu list is essentialto maintaining the aesthetics and design of the original ui.however identifying these sets is challenging since apps uisvary significantly from each other.
this variation can evenexist within the same app as different uis may have their ownlayouts with a varying number of elements and a differentset of visual relationships.
this means relying on a predefinednumber of groups with fixed rules on how to map the elementsin any ui to those groups is not practical.
instead these groupsneed to be identified on a per ui basis.
a simplistic approachto identifying these groups might put elements that have thesame class type e.g.
all buttons or style into the same group.however in our experience this was generally inaccurate sinceelements with the same class type can vary widely in theirappearance and styles are not used in a disciplined way bymost developers.
techniques with similar goals but targetedto web applications e.g.
rely on variousmetrics such as dom structure to group elements and inour experience this also resulted in inaccurate groupings whenapplied to mobile app uis.
to identify visually related elements we characterized the problem as a clustering problem where elements representthe data points that need to be made into clusters and thecluster membership is determined by the similarity of the ele ments rendering attributes.
to cluster elements our approachuses the well known density based clustering technique db scan .
this particular techniques is well suited for ourproblem since the algorithm does not require predefiningthe number of clusters and produces mutually exclusiveclusters i.e.
hard clustering .
both of these attributes areimportant for our problem domain since the variance of appui layouts means they can have varying numbers of groupingsand having non mutually exclusive clusters could preventour search technique section iii c from converging.
todefine the distance function we found that logical location represented by the xpath element size and elementclass type consistently resulted in the most useful groupings.in our experience elements with a similar xpaths had ahigher chance of being related in terms of sharing a similarvisual appearance and or inheriting the same properties froma mutual parent for example icons in the navigation bar .
wealso found that elements with a similar size were often visuallyrelated e.g.
lists of buttons or items .
finally we found thatwhile element class type was by itself insufficient to indicateelement grouping when combined with the other dimensions it helped to improve the grouping s accuracy.
we define our element clustering techniques as follows.
first our approach analyzes the vh of the ia and extractseach unique element and its properties.
the elements becomethe data points that will be clustered.
next to determinethe distance between those data points our approach defines fig.
example that shows two apps uis annotated with a simplified version of the visually related groups that wereidentified by our clustering algorithm.
a function based on the three above mentioned metrics.
to calculate the location distance our approach computes thelevenshtein distance between elements xpath.
the leven shtein distance between two xpaths is the minimum numberof xpath tags that need to be modified to change one xpathinto the other.
our approach then normalizes the value of thelocation distance metric to a range of .
a metric valueof zero indicates a complete match between the two elements while one indicates a maximum difference.
to calculate thesize distance our approach computes a metric for each of thesize properties height width and margins .
if elements v andv2have the same size propriety e.g.
height then the metric value for that property is set to otherwise it is setto .
similarly our approach computes a metric to calculatethe element class type distance.
if two elements have thesame element class type then the metric value is set to .otherwise it is set to .
our approach then calculates theoverall distance as a weighted sum of the normalized value ofeach of the above three metrics.
the weights of the metricswere determined empirically based on our experiments.
thedbscan algorithm then uses this information to group theelements into different clusters.
each cluster then representsa set of visually related elements and the set of all clustersis the output of this phase.
fig.
shows a simplified versionof the visually related groups identified for two mobile apps uis.
each number on the graph represents an identified group.
b. phase localization of elements and properties the goal of this phase is to identify for each of the sbiis the set of elements and properties that need to be changed in order to repair the sbii.
although the reports fromaccessibility detection tools can be used to identify elementsthat exhibit sbiis they do not necessarily indicate whichelements need to be adjusted to repair the sbiis nor whichproperties should be adjusted.
there are several reasons for this limitation.
first the size of the element may be set based on an interaction of its propertieswith the properties of other elements that are located close byor of elements from which it inherits display constraints.
forexample the size of an element that is set to fill the availablespace depends on its neighbors size or an element s size maybe bounded by the fixed size of another element in whichit is visually contained.
second maintaining the consistencyof the repaired ui requires modifications to other elements which may themselves have relationships with other elementsthat need to be modified to maintain consistency.
one couldaddress both of these challenges by making the repair phase ofour approach consider modifying all elements and propertiespresent in the ia.
however such a solution would dramaticallyincrease the search space for a possible repair and meansthat the search process could take a long time to complete.therefore in this phase our approach tries to identify a subsetof all elements and properties in the ia that is safe in thatit contains the elements and properties that when modified canrepair the observed sbii and keep the ui consistent and minimal to reduce the runtime needed to identify a successfulrepair.
to accomplish this goal we define an approach based on building and analyzing a model of the visual and renderingrelationships among the elements in an activity.
given a set of sbiis our approach can use this model to identify aminimal set of other elements and their properties that shouldbe considered as candidates for the repair.
to serve as thismodel we introduce a new graph that we call the size relationgraph srg which is defined by a tuple angbracketleftv e m angbracketright.
a node v vcorresponds to an element in the ia.
eis a set of directed edges that represent one of two relationships betweenelements in the ia consistency relationships which exist between elements that need to be changed together to maintainthe visual consistency of the ui i.e.
elements that belong tothe same visually related group identified in section iii a and size dependency relationships which exist between two elements if the size of one constrains in some way the sizeof the other.
mis a function that maps each edge to a set of tuples of the form angbracketleftp angbracketright .p p wherep height width and is a ratio of the drawing values of pfor the edge s nodes.
after building the srg our approach computes a subgraph for each visually related group that contains an sbii.
thesubgraph identifies the elements that will be targeted by therepair methodology in section iii c. the edges of the sub graph and their corresponding annotations identify propertiesto be considered for the repair and provide information onhow to propagate that repair to the other elements in thesubgraph.
to compute the subgraphs our approach iteratesover each visually related group that contains an sbii.
foreach such group g our approach identifies the set of elements and properties that may need to be changed to resolve thesbii ing.
to do this our approach computes a subgraph of 733the srg that corresponds to the transitive closure of the graph originating from the element vaing wherevarepresents the view that has the sbii.
if gcontains more than one element with an sbii our approach chooses as va the element that requires the largest size increase to fix its sbii.
the intuition ofselecting vin this way is that the largest size increase applied to this element will also likely repair the other elements thatrequire a smaller size increase.
the computed subgraphs arerepresented as a set of tuples a with each tuple of the form of angbracketlefti sb angbracketrightwhereirepresents the id of the element v a v that contains an sbii and sbrepresents the subgraph of the srg computed for that node.
we now describe each of thetwo edge types in more detail.
aconsistency edge is created to represent the size relationships between elements within a visually related group g. the goal of this type of relationship is to ensure size changes arepropagated among elements within gto maintain their visual consistency.
for example for the ui shown on the left handside of fig.
our approach creates consistency edges betweenthe nodes in the srg that represent the three buttons in group to ensure that a change applied to one can be propagated to the others.
to create the consistency edges for g our approach iterates over its elements and for each pair of elements v andv2 our approach creates a consistency edge between their correspondent nodes in the srg.
the approach then createsan edge tuple to capture the relationship between each of thepair s dimensions i.e.
height and width and calculate theratio for that tuple by dividing the drawing value of the dimension for v 1over the drawing value of the dimension for v2.
returning to the example in fig.
for the edge created between the nodes in the srg representing the sign up and privacy policy buttons our approach creates a tuple thatmodels the height relationship between them.
since the heightof both buttons are 30dp the tuple will be initialized with the value angbracketleftheight .
angbracketright.
adependency edge is created to represent the size relationship that can exist between an element and one of its ancestors.the goal of modeling this type of relationship is to identify theset of nodes and properties that given a change to a propertypfor an element v may need to be changed to accommodate the change in v. to create the dependency edges our approach iterates over the nodes in the vh of the ia.
for each nodev our approach iterates through the set of its ancestors i.e.
containing layouts starting from its parent.
then based onthe size attributes defined for that ancestor our approach willeither create a dependency edge with that ancestor or skip itand move on to the analysis of the next ancestor.
our approachdetermines that based on the following three cases.
first ifthe size attribute is set as an exact number then our approachmarks that ancestor as the target node for the dependency edge.the reason for that is that an ancestor with a size attribute setas a fixed number does not change in response to the changein the size of v. therefore the size of vis dependent on this ancestor.
second if the size attribute for the ancestor isset aswrap content then our approach will only mark that ancestor as the target node for the dependency edge if the sizeattribute for vwas set as matchparent.
that is because this is the only case where that ancestor may need to be changeddirectly as v s size can not be directly increased.
third if the ancestor size is set as match parent then our approach skips that ancestor and moves to the next one.
the reason is that anancestorv pwith size set as matchparent follows the size of its own parent.
therefore if vp s parent increased then vp s size will increase allowing vto change.
the dependency edge is created between vand the identified ancestor in the srg as determined by these three cases.
the approach then creates anedge tuple to capture the relationship between the two nodesand calculates the ratio for that tuple by dividing the value ofvover the value of the identified ancestor.
c. phase repairing the activity the goal of this phase is to generate a repair that resolves the detected sbiis in the ia without distorting the ui s ap pearance.
identifying such a repair is complicated for multiplereasons.
first a perfect repair may not exist due to ui layoutconstraints.
therefore the repair may need to represent atradeoff between resolving sbiis and minimizing distortion.second the space of possible solutions that can be consideredgrows exponentially as more elements and properties needto be considered.
third assessing the quality of a repair isdifficult to do since it requires knowing exactly how a set ofproposed repairs would affect not only the changed elementsbut if they cause any cascading changes to other parts of theui.
together these challenges motivate the use of a search based approach for finding a repair since these techniques canefficiently explore large solution spaces consider tradeoffs inidentifying a best solution and use approximation functionsto avoid expensive modeling operations i.e.
ui renderingimpact .
the search based technique we define follows the general approach of a genetic search algorithm.
therefore we onlygive a brief overview below of the overall flow of the searchand then describe the unique parts the fitness function prob lem representation initial population and repair generation in more detail.
in each iteration of the search our approachevaluates the candidate repairs in the current population usingthe metrics defined in section iii c1 then performs selec tion uniform crossover and uniform random mutation.
ourapproach terminates the search once the maximum numberof predefined generations has been reached or the approachreaches a fixed point where no improvement in the populationhas been observed for multiple generations.
fitness function the goal of our fitness function is to guide our search to a solution that resolves as many sbiias possible.
however solutions that resolve sbiis may doso by increasing the size of touch targets dramatically andin a way that distorts the ui of an ia.
therefore we designour fitness function to include not only metrics that guide thesearch to a ui with improved accessibility but also metrics thatpenalize solutions that cause the resulting ui to significantlydiffer from the original or introduce new design problems.based on our experiments with the automatically generated 734touch target size adjustments we identified several aspects of repairs that when penalized helped our approach to generateuis that minimally altered the ui while generating repairs.these were changes to view alignments the relative positionof views spacing between views and the amount of view sizechange.
the fitness function for a candidate repair is calculatedas the weighted sum of these four objectives.
accessibility heuristic this metric represents the primary representation of how good a solution is with respect toimproving the identified sbiis.
ideally this could be measuredby inserting a solution into the app and then running google saccessibility scanner on the modified app and calculatinga new accessibility score based on its report.
however theprocess of running the scanner can take a significant amountof time.
therefore we utilized an approximation of the acces sibility score.
our approach inserts a candidate solution intothe app then scans the rendered ui to identify the actual sizeof each touch target that had been reported as having an sbiiand is still below the minimum threshold for accessible size.simply using this number as the metric is insufficient sinceit defines a step function that does not provide meaningfuldiscernment powers among solutions where both results in thesame number of sbii violations but one may be closer.
toconvert this information into a gradient function with moreuseful notions of correctness we calculate the amount of sizethat the touch targets would need to increase to satisfy thetouch target minimum.
this enables the approach to valuesolutions that are getting closer to a satisfying solution even ifthe resulting ui has not yet completely resolved the detectedsbiis.
relative positioning and alignment of views changes to the size of touch targets can cause changes to the relativeposition and alignment of elements in the ui as they moveto accommodate the repaired elements changed size.
in somecases this can significantly distort the original layout of the ui.therefore we introduce two metrics that favor solutions thatresult in lower amounts of change in the relative positioningand alignments of its elements with respect to the original ui.our approach realizes these metrics using the following steps first our approach extracts the position of each element inthe vh of the original ui and identifies the type of alignmentand relative position it has with the other elements.
forrelative position any two elements may have the followingrelationships intersection containment above below to the left of or to the right of.
for alignment any two elements may be top aligned bottom aligned left aligned or right aligned.
these relationships canbe determined by comparing the xandycoordinates of each element s minimum bounding rectangle mbr .
forexample two elements are bottom aligned if the yvalues of their bottom right and bottom left coordinates are equal.the same process is repeated for an ia after a candidatesolution has been applied to it.
then the two sets of alignmentsand relative positions are compared.
if a difference exists then our approach computes the magnitude of the changeby computing the minimum euclidean distance between thecurrent position of the changed element and where it wouldneed to be located in order to restore the violated relationship.for the bottom aligned example this would be the absolutedifference between the ycoordinates.
our approach sums the differences for all elements that have violated a prior alignmentor relative position relationship and reports this as the metricfor the candidate solution.
minimum spacing between views touch targets that expand in size can do so by expanding into the space betweeneach pair of touch targets.
however so can have animpact on the layout of a ui and cause it to look verydifferent from its original design.
therefore we introducea metric to favor solutions that do not cause the spacingbetween any pair of elements to become too small.
to realizethis metric our approach computes the distance between thembrs of each pair of touch targets and if the resulting spaceis below the minimum value required by google s materialdesign guidelines then the solution is penalized.
this allowssolutions to utilize some of the space between touch targetsbut only penalizes them if it falls below this minimum value.this realization of the metric reflects our observations thatmany sbiis could not be repaired without significant distortionwithout utilizing at least some of the space between touchtargets.
amount of view size change a drawback of our accessibility heuristic is that it favors solutions that always increasethe size of the touch targets.
this can favor solutions thatunnecessarily increase the size of the touch targets which inturn increases the amount of distortion relative to the originalui.
to penalize these changes our approach defines a metricthat favors solutions that minimize the amount of change in thesize of the touch targets.
to realize this metric our approachcompares the size of a touch target in the original ui using theelement s mbrs and compares this to the size of the touchtarget in the ui produced by a candidate repair.
the sum ofall such changes in the element is used as the metric.
solution representation and initial population each candidate repair chromosome is comprised of a set sof tuples each tuple corresponds to a gene where each tupleis of the form angbracketlefti p v angbracketright.
in this tuple ican refer to either a group as defined in section iii a or an individual element v denotes the amount of change or adjustment that the repair willmake toi andpindicates the property of ito which vwill be applied and can be the height spacing or width.
our candidaterepairs allow our approach to change an entire group if irefers to a group with one adjustment or an individual element.
thegroup identified genes allow our approach to explore solutionsthat maintain consistency while the individual identified genesrepresent elements that have a size dependency relationshipwith the element containing the sbii.
for a given ia that contains sbiis our approach defines the genes that will be included in the chromosome in thefollowing way.
for each visually related group gand the subgraph identified for gin section iii b the approach first identifies the subset of properties e.g.
height or width thatmight need to change to repair the sbiis.
these properties 735can be identified based on the violation reported in the sbii detection report.
for each such property p the property defines a gene for gand a gene for each element that is connected tovain the subgraph via a dependency edge.
for example if height is the property that needs to be changed for g and vbis the node connected to vavia a dependency edge then our approach will create two tuples in s. the first tuple is created with ireferring to the group gto which vabelongs andp height .
the second tuple is created with ireferring tovbandp height .
note that the value field vof each tuple is undefined at this point since this step only defines thechromosome structure.
based on this chromosome structure our approach then creates an initial population of size nof candidate solutions.
for each of the nsolutions the approaches creates a chromosome with the gene structure defined using the above process.
thenthe approach iterates over each gene and initializes its valuefieldvby sampling a random value in a gaussian distribution based on the element s value.
generating a repair when a candidate solution is ready to be evaluated by the fitness function our approachconverts the solution to a repair that can be inserted intothe ia.
given a candidate solution c our approach performs the following steps for each gene in c our approach propagates the change represented by the gene to all ofthe elements in the subgraph.
then our approach againtraverses the subgraphs capturing the changes in a set r of concrete repairs each of which is represented as a tuple angbracketleftx r pr ar vr angbracketright wherexris the xpath of the node in the vh that need to be changed pris the property to be changed ar is the attribute that needs to be modified when applying thechange to the layout files and v ris the new value for pofxr.
after generating r our approach rewrites the app s layout files and generates a new apk that can be run.
these foursteps are also used for generating the final and best solutionidentified by our approach.
in the first step each gene in the candidate solution c i s applied to each of the subgraphs.
to do this our approach tran sitively traverses each outgoing dependency and consistencyedge in each subgraph and for each edge v r vt traversed our approach computes vt s new value of pby multiplying the value assigned to pofvrby the ratio defined by the edge tuple between vrandvt.
our approach then uses this new value of pto computes new values for the other size related properties defined for vt such as padding and minimum size.
this ensures that the ratio between these properties and pis maintained after the size change.
for each property changedforv t our approach creates a corresponding node in r. in the second step our approach once again traverses the set of identified subgraphs.
for each subgraph our approach setsthe values of the corresponding tuples in rwith the value set for the node in the subgraph.
for each node changedin the subgraph our approach determines the value of a r based on a predefined mapping between each property andthe corresponding attribute used in android for that property.this is a direct mapping except in two cases.
first whenthe value of the attribute that pis mapped to is defined as awrap content then instead of mapping pto that attribute our approach maps pto its corresponding min attribute e.g.
android minheight .
second if the value of the attribute is set asmatchparent then the change of pcannot be directly applied to the attribute in vt. instead this change is indirectly achieved by propagating the change using the dependencyedges to a containing node.
in the third and final step our approach iterates over the set of changes in r and for each our approach modifies the corresponding attributes in the app s layout files.
the nodesin the subgraphs vh and the app layout files all use thesame identifier which simplifies the mapping and matchingbetween the representations.
note that we omit the details ofthis step since this is mainly an engineering challenge anddid not require the development of any new techniques oralgorithms.
iv .
e v aluation to evaluate our approach we designed experiments to answer the following research questions rq1 how effective is our approach in repairing sbiis in android applications?rq2 how long does it take for our approach to generate repairs for sbiis in android applications?rq3 how does our approach impact the visual appeal of android applications after applying the selected repair?
a. implementation we implemented our approach in java as a prototype tool size based inanaccessibility repair in mobile apps salem .
our implementation uses apktool to disassemble apk resource files and repack the modified files into a newapk file.
to collect ui information we used ui automator and adb to dump the layout hierarchy files andcapture the screenshots when running an app on an androidemulator based on android .
.
for detecting the sbiis inan app we used google accessibility scanner and thenfiltered its output to capture sbiis.
to get the style informationand build the vh for activities we used a tool based on layout inspector in addition to ui automator.
we ranour experiments with the following configurations populationsize generation size .
we ran our approach on an amdryzen 2700x bit machine with 64gb memory runningubuntu linux .
.
lts.
the implementation of salemand subjects will be made available to the community via ourproject website .
b. subjects we conducted our experiments on a set of activities from real world mobile apps gathered from a dataset of apps used in a recent large scale study on accessibility issuesin mobile applications .
this dataset consists of 000apps collected from across categories in the google playstore .
to select our subjects we ran an accessibilityevaluation tool on the dataset and randomly selected 736table i. results for salem s effectiveness in repairing sbiis rq1 and its run time rq2 .
original repaired of touch targets of sbiis accessibility rate of sbiis accessibility rate running time mins all average median max min apps that contained sbiis.
we confirmed these reported sbiis by manually verifying the size of each element reported.
foreach of these apps we selected the activities that the detection tool reported to have at least one sbii.
from thelist of sbiis in each activity we filtered out the ones that were part of webviews oradviews which our approach does not handle as they require modifying web content which ourapproach does not handle.
in total we have sbiis in 58unique activities across the subjects.
c. experiment one protocol to address rq1 and rq2 we ran salem on each of the subject s faulty activities.
to account for the non determinism of our approach s search technique werepeated the experiment times for each activity and reported the results based on the average numbers.
to evaluate theeffectiveness of our approach for each activity we calculated its number of sbiis and its accessibility rate before and after the repair.
the number of sbiis was determined basedon the reports from google accessibility scanner .
theaccessibility rate was calculated as the ratio of the number of touch targets that are free of sbiis over the total numberof touch targets in the activity.
this is a widely used metric to measure and rank the accessibility of uis in a mobile app .
to address rq2 we measured the time it took to runsalem during the experiment.
presentation of results the results for effectiveness rq1 and time rq2 are shown in table i. the original and repaired columns correspond to the results before andafter applying salem s repairs.
we list the number of sbiisand the resulting accessibility rate under of sbiis and accessibility rate for the original and repaired versions.we also calculated the total average median maximum andminimum rounded to whole numbers across all activities for each of the metrics.
due to space constraints we do notlist the details of the subjects in the paper but include themas supplementary material on our project website.
discussion of results overall the results of our experiment show that salem was able to significantly reducethe number of sbiis in the subject apps.
out of the totalnumber of reported sbiis our approach was able tocompletely fix of them.
the total accessibility rate across all activities after the repair was compared to only before the repair.
these results indicate that ourapproach was effective in repairing the sbiis and improvingthe accessibility of apps.
we investigated the two sbiis intwo different activities that our approach could not repair and found they were ui elements whose size properties are definedin code.
these sbiis can only be repaired by analyses thatwould require analyzing and rewriting the source code whichis not handled by our approach.
the results for rq2 shows that salem was able to generate repairs within a reasonable time.
we analyzed theruntime breakdown of each individual step in our approachand found that our approach spent a significant amount of time evaluating the candidate repairs by compiling a newapk for each repair and then running them on the emulator.this part can be further optimized by running the approach inparallel e.g.
using amazon aws .
d. experiment two protocol to answer rq3 we conducted a user based study where we asked users to compare the original and repaired uis.
the goal of this evaluation was to understand how our repairs affect the ui s visual layout from a user sperspective.
the surveys presented side by side screenshots ofthe original and the repaired uis each calibrated to be shownin the resolution of the nexus 6p mobile device that was usedto run the experiment.
this device has a display and resolutionthat is within the range of the most popular android mobilescreen sizes .
the order of the screenshots placement wasrandomized and only labeled v ersion and v ersion .
each survey was divided into two parts.
for the first part we wanted to measure the participants general opinion ofthe original and repaired versions of the uis.
we presentedthe two versions and asked each participant to rate theirpreference on a point likert scale and rate each ui sattractiveness on a numeric scale from to .
we also askedparticipants to provide a written explanation of their answers tounderstand the reason for their preference.
for the second partof the survey we wanted to measure the participants opinionof the two versions after knowing about the accessibilityimprovements.
we presented the same set of ui screenshotsas the first part but this time we highlighted the sbiis oneach screenshot in the same way as they would be shownin google s accessibility scanner .
we also presented ashort description explaining the issues and the functionalitiesthat are activated by each touch target affected by the sbiis.we then asked the participants to again rate their preferencebetween the original and the repaired on a point likert scale.
19before after before after before sci after sci i strongly prefer the original ui.i prefer the original ui.
no prefe rence.
i prefer the repaired ui .
i strongly prefer the repaired ui.
fig.
participants preference between the original and repaired ui versions we conducted the survey on participants from two sources amazon mechanical turk amt a crowd sourcing platform that has been widely used to conduct user studies and a group of disabled users that suffer paralysis withlimited hand mobility.
for the amt participants we separatelycollected responses from those that are under years oldand those years old or older.
to ensure the participantsunderstood our instructions we limited the locality to u.s. andcanada.
we chose only those workers that had been rated ashighly reliable with an approval rating of over and whohad completed over approved tasks.
we also followedamt best practices by employing a captcha and a checkquestion.
in total we had responses from the group responses from the group and responses from thegroup with motor impairment.
presentation of results the results from the user study are shown in figure .
the bar chart shows the distributionof the point likert scale preference ratings where the lighterbars are the preference ratings before accessibility awarenessand the darker bars are those after accessibility awareness.
weused solid bars to represent the group that is under yearsold group striped bars to represent the group that is years old or older group and dotted bars to represent the group of users with motor impairment sci group .
in terms of average attractiveness the participants rated the original o slightly higher than the repaired r withan average of o .
r .
among the group.
forthe and the sci groups the repaired version had aslightly higher rating of o .
r .
and o .
r .
respectively.
the rating difference for the groupwas not statistically significant p value .
.
and the rating differences for the and the sci groupswere statistically significant p values .
.
and .
.
respectively .
we used the wilcoxon signed rank test for the analysis because we were comparing pairedratings from two dependent samples and these ratings werenot normally distributed.
discussion of results the result from the user study showed that our approach was very successful in maintainingthe visual appeal of its repaired uis.
for preference a majorityof participants rated no preference when deciding betweenthe original and repaired versions.
this is a very good indica tion that our repair did not negatively affect user preferencewhile it was able to fix almost all of the sbiis.
in fact acrossall three groups when combining no preference with thosethat prefer the repaired ui our repair was in favor among90 of the ratings.
we investigated the comments providedby the who did not prefer our repaired ui and found thatthe reason participants preferred the original was because theyperceived smaller ui components to be more attractive.
sincethis is a personal preference we do not think it underminesthe quality of our repairs.
participants preferred our repairs even more once they were aware of the implications of the sbiis.
across the threegroups we see an average of increase in favor of therepaired ui.
particularly the number of ratings that stronglyprefer the repaired ui doubled for the general group andquadrupled for the group.
this is a very strong indicationthat participants value accessibility and are willing to changetheir initial preference for the trade off.
we revisited those10 that did not favor the repair and preferred smaller layoutto see whether their preference changed.
interestingly overhalf of them switched to either no preference.
or preferredthe repaired version leaving only under still preferring theoriginal after awareness.
the comments from the participantsthat switched were overwhelmingly positive expressing thatthey were unaware of accessibility at first but had no problemadapting to the repaired ui for a greater gain.
one commented 738fig.
example that demonstrates salem.
the left screenshot shows the original ui the middle screenshot highlights the sbiis detected by google accessibility scanner and the right screenshot shows the ui after applying salem s repair.
... and it still looks good and now it is workable.
in addition to a positive impact on visual appeal the userstudy also showed that our repair was considered to be moreaccessible.
we investigated the comments provided by theparticipants to understand the reason of the repaired ui beingboth more attractive and preferable among the and scigroups.
we found in general these groups perceived biggerui components to be better and more usable even beforeaccessibility awareness.
many participants explained that thebigger touch targets from the repaired ui could help them bemore efficient and avoid mistakes during interaction.
amongthe of the sci group that strongly prefer the repairedui is a quadriplegic participant that uses his knuckles insteadof fingertips to active touch screens.
he explained the largerspacing between lines would make it considerably easier forme to access each input box with my knuckles.
these types of insights from actual mobile users show that our approachcan be impactful in addressing accessibility.
e. threats to v alidity external validity the first potential threat is that the selection of participants for the user based study in our experiment may not be representative of individuals impacted by sbiis.to address this threat we implemented an age question in ouramt surveys and sought motor impaired paralysis patients toensure our participants are diverse in age and abilities.a second threat is that the repaired uis may not rate as well when displayed on screen dimensions different from theone we used in our evaluation.
this aspect of generalizabilitywas not tested in our evaluation.
however we believe thatsince our approach s focus was on maintaining relative visual relationships and android uses a dynamic layout renderingapproach that repairs on screens with other dimensions wouldlikely look similar from an aesthetics point of view.
internal validity one potential threat is that screenshots used the user based study may appear differently in sizedepending on the participants displays.
to mitigate this threat we asked the participants to enter the display device they usedfor answering the survey and included only those results witha screen ppi that would render the screenshots to near theactual size of the nexus 6p device s ui that was used in theemulator to generate the screenshots.
another potential threat is that users rated the uis based on the screenshots without directly interacting with the uison a mobile device.
our decision to use screenshots wasfor the following reasons.
first our user study does not askusers to evaluate apps usability which would require directinteraction with the apps.
instead users are only asked torate the attractiveness of the rendered uis.
second the use ofscreenshots allows us to avoid any variations in the results thatmay happen due to the differences in the participants mobiledevices or their selected settings.
third the use of screenshots 739allows for easy comparison as users can view the two versions of the uis next to each other instead of having to install run and then uninstall different versions of our subjects.
finally screenshots are frequently used in user study that attempt toevaluate the attractiveness of uis e.g.
.
construct validity a potential threat is that our definition of sbiis is dependent on the reports of gatf and the googleaccessibility scanner .
the use of this definition is rea sonable because it is based on google s own material designresearch .
the guidelines metric is what is considered asthe accessibility threshold by experts.
as further validation weanalyzed the severity of the repaired sbiis to see how muchlarger they had to be in order to be considered accessible.we found that the sbiis needed an average increasein their area.
of special note of the sbiis requireddoubling their touch areas and of the sbiis required anarea increase of over three times to become accessible.
thisindicates that many of the repaired sbiis were undersized andrequired significant size increases to become accessible.
another potential threat is that the attractiveness and preference ratings by participants are subjective.
to mitigate thisthreat our survey is designed to measure relative values with either side by side comparison or before and after repair ver sions for the activities.
this ensures the same pair of activity receives consistent ratings even though different participantsmay rate according to different standards.
v. r elated work many empirical studies in the literature have studied the prevalence of accessibility issues in mobile applications andhow they impact end users .
although theyprovide useful insights that drive accessibility research incen tive such as our work they do not offer solutions to solvethese underlying issues.
many android accessibility toolstoday contribute to solving accessibility issues by detectingand identifying known issues based on violations of guidelines .
however they are only able to locate not repair these types of issues.
similarly recent techniqueshave been developed to address various types of accessibilityissues in the web domain.
kafe focuses on detectingaccessibility issues related to the keyboard interface.
a xeray focuses on detecting semantic inconsistencies related towai aria specifications.
vizassert uses formalverification techniques to detect layout based accessibilityissues in web applications.
improving accessibility in the mobile domain has become an active area of research.
work by wu et al.
aims topromote users awareness of the built in assistive servicesby automatically recommending services to users based ontheir needs .
recent mobile accessibility research focuses on making mobile ui components accessibleto assistive services such as talkback by annotatingthe app s interface elements with semantics and accessibilitymetadata.
similar work has motivated repair tools to makeimage based buttons with missing content labels accessible .
labeldroid and coala are repair techniquesbased on using deep learning to automatically predict thelabels of ui icons while brady et al.
proposed a techniqueto suggest content labels using crowd sourcing .
theseapproaches can repair known issues that affect disabled usersfrom interacting with the apps via assistive technologies butthey do not address sbiis.
research in hci has helped to address difficulties in touchscreen usage via both hardware and software.
hardwaretechniques use physical attachments to thephone to improve tactical interactions.
software techniquesprovide aids to circumvent small touch targets by zoomingor increasing size .
while these techniques may assistdisabled users on a case by base basis they do not resolve theunderlying root causes of sbiis.
there has been approaches that attempt to repair general ui layout issues.
owleye focuses on repairing android guilayout issues such as text overlap blurred screen and missingimages.
other techniques such as if ix and cbrepair repair internationalization presentation issues in webapplications and mf ix repairs presentation issues in the mobile web environment.
although these tools target repairsof ui bugs they do not fix sbiis in mobile applications.
program repair have also been the focus of many techniques from the research community .
droix uses a search based technique to automatically repair crashesin android applications.
elixir is a technique that canautomatically generate patches for java applications.
the focusof this line of research is to facilitate the generation of patchesto repair application crashes and defects but they do not repairaccessibility issues.
vi.
c onclusion in this paper we introduced an approach for automatically repairing sbiis in mobile apps.
our approach builds a graph based model of the mobile ui to identify the set of elementsand properties that need to be modified to repair the ui.
toidentify the best repair our approach uses a genetic algorithmguided by a fitness function that accounts for accessibility andui distortion introduced by the repairs.
once the best repairhas been found our approach automatically generates a newapk of the repaired android app.
our empirical evaluationshowed that our approach was able to successfully resolve99 of the sbiis in a set of subject apps.
in a user study thatevaluated the repaired uis of the participants rated therepaired ui as equal to or more preferred than the original and valued the increased accessibility offered by the repairs.overall these results are very positive and indicate that ourapproach can help developers to improve the accessibility oftheir mobile apps.
a cknowledgment this work was supported by the national science foundation under grant .
740references who disability and health.
.
available j. t. morris m. w. sweatman and m. l. jones smartphone use and activities by people with disabilities survey journal on technology persons with disabilities vol.
p. .
.
available j. lazar the potential role of u.s. consumer protection laws in improving digital accessibility for people with disabilities u. pa. jl soc.
change vol.
p. .
level access what accessibility standards apply to mobile applications?
updated .
s. yan and p. g. ramachandran the current status of accessibility in mobile apps acm transactions on accessible computing vol.
no.
pp.
feb. .
.
available c. vendome d. solano s. li n an and m. linares v asquez can everyone use my app?
an empirical study on accessibility in androidapps in ieee international conference on software maintenance and evolution icsme sep. pp.
issn .
a. alshayban i. ahmed and s. malek accessibility issues in android apps state of affairs sentiments and ways forward p. .
a. s. ross x. zhang j. fogarty and j. o. wobbrock an epidemiology inspired large scale analysis of androidapp accessibility acm transactions on accessible computing vol.
no.
pp.
apr.
.
.
available m. e. mott r. d. vatavu s. k. kane and j. o. wobbrock smart touch improving touch accuracy for people with motor impairmentswith template matching in proceedings of the chi conference on human factors in computing systems ser.
chi .
new york ny usa association for computing machinery may pp.
.
.
available s. n. duff c. b. irwin j. l. skye m. e. sesto and d. a. wiegmann the effect of disability and approach on touch screen performanceduring a number entry task proceedings of the human factors and ergonomics society annual meeting vol.
no.
pp.
sep. publisher sage publications inc. .
available x. valencia j. e. p erez m. arrue j. abascal c. duarte and l. moreno adapting the web for people with upper bodymotor impairments using touch screen tablets interacting with computers vol.
no.
pp.
nov. .
.
available t. guerreiro h. nicolau j. jorge and d. gonc alves towards accessible touch interfaces in proceedings of the 12th international acm sigaccess conference on computers and accessibility ser.
assets .
new york ny usa association forcomputing machinery oct. pp.
.
.
available l. nurgalieva j. j. j. laconich m. baez f. casati and m. marchese a systematic literature review of research derived touchscreen designguidelines for older adults ieee access vol.
pp.
conference name ieee access.
material desing accessibility.
.
available w3 target size.
.
available bbc mobile accessibility guidlone.
.
available x. zhang t. tran y .
sun i. culhane s. jain j. fogarty and j. mankoff interactiles 3d printed tactile interfaces toenhance mobile touchscreen accessibility in proceedings of the 20th international acm sigaccess conference on computers andaccessibility ser.
assets .
new york ny usa associationfor computing machinery p. .
.
available b. taylor a. dey d. siewiorek and a. smailagic customizable 3d printed tactile maps as interactive overlays in proceedings of the 18th international acm sigaccess conference on computers andaccessibility ser.
assets .
new york ny usa associationfor computing machinery p. .
.
available l. he z. wan l. findlater and j. e. froehlich tactile a preliminary toolchain for creating accessible graphics with 3d printed overlays and auditory annotations in proceedings of the 19th international acm sigaccess conference on computers andaccessibility ser.
assets .
new york ny usa associationfor computing machinery p. .
.
available s. k. kane m. r. morris and j. o. wobbrock touchplates low cost tactile overlays for visually impaired touch screen users inproceedings of the 15th international acm sigaccess conferenceon computers and accessibility ser.
assets .
new york ny usa association for computing machinery .
.
available s. k. kane m. r. morris a. z. perkins d. wigdor r. e. ladner and j. o. wobbrock access overlays improving non visual access to largetouch screens for blind users in proceedings of the 24th annual acm symposium on user interface software and technology ser.
uist .new york ny usa association for computing machinery p. .
.
available s. k. kane j. p. bigham and j. o. wobbrock slide rule making mobile touch screens accessible to blind people using multi touchinteraction techniques in proceedings of the 10th international acm sigaccess conference on computers and accessibility ser.
assets .
new york ny usa association for computing machinery p. .
.
available s. azenkot c. l. bennett and r. e. ladner digitaps eyes free number entry on touchscreens with minimal audio feedback inproceedings of the 26th annual acm symposium on user interfacesoftware and technology ser.
uist .
new york ny usa association for computing machinery p. .
.available x. zhang a. s. ross a. caspi j. fogarty and j. o. wobbrock interaction proxies for runtime repair and enhancement of mobileapplication accessibility in proceedings of the chi conference on human factors in computing systems ser.
chi .
new york ny usa association for computing machinery p. .
.
available y .
zhong a. weber c. burkhardt p. weaver and j. p. bigham enhancing android accessibility for users with handtremor by reducing fine pointing and steady tapping inproceedings of the 12th international web for all conference.florence italy acm may pp.
.
.
available ui automator.
.
available layout inspector.
.
available google accessibility for android.
.
available android accessibility help get started with accessibility scanner .
google accessibility test framework for android dec. original date 12t00 01z.
.
available ibm mobile accessibility checker may original date 06t14 17z.
.
available a. sanoja and s. ganc arski block o matic a web page segmentation framework in international conference on multimedia computing and systems icmcs apr.
pp.
.
s. mahajan and w. g. j. halfond detection and localization of html presentation failures using computer vision based techniques in2015 ieee 8th international conference on software testing v erifi cation and v alidation icst apr.
pp.
issn .
s. mahajan n. abolhassani p. mcminn and w. g. j. halfond automated repair of mobile friendly problems in web pages inproceedings of 40th international conference on software engineering.gothenburg sweden acm may pp.
.
.available m. ester h. p. kriegel and x. xu a density based algorithm for discovering clusters in large spatial databases with noise p. .
apktool a tool for reverse engineering 3rd party closed binary android apps.
.
available google developers android debug bridge adb updated .
salem project web site aug. .
.
available google android apps on google play.
.
available screen sizes updated .
amazon mechanical turk.
.
available s. mahajan a. alameer p. mcminn and w. g. j. halfond automated repair of internationalization presentation failures in web pages usingstyle similarity clustering and search based techniques in ieee 11th international conference on software testing v erification andv alidation icst pp.
.
a. alameer p. chiou and w. g. halfond efficiently repairing internationalization presentation failures by solving layout constraints inproceedings of the ieee international conference on software testing verification and validation icst apr.
tex.acceptancerate tex.pubtype conference.
m. linares v asquez g. bavota c. bernal c ardenas m. d. penta r. oliveto and d. poshyvanyk multi objective optimization ofenergy consumption of guis in android apps acm transactions on software engineering and methodology vol.
no.
pp.
sep. .
.
available s. hao b. liu s. nath w. g. halfond and r. govindan puma programmable ui automation for large scale dynamic analysis of mobileapps in proceedings of the acm international conference on mobile systems applications and services mobisys june .
n. salehnamadi a. alshayban j. w. lin i. ahmed s. branham and s. malek latte use case and assistive service driven automatedaccessibility testing framework for android in proceedings of the chi conference on human factors in computingsystems.
new york ny usa association for computingmachinery may no.
pp.
.
.
available p. t. chiou a. s. alotaibi and w. g. j. halfond detecting and localizing keyboard accessibility failures in web applications inproceedings of the 29th acm joint meeting on european softwareengineering conference and symposium on the f oundations of softwareengineering ser.
esec fse .
new york ny usa associationfor computing machinery aug. pp.
.
.
available m. bajammal and a. mesbah semantic web accessibility testing via hierarchical visual analysis in ieee acm 43rd international conference on software engineering icse may pp.
issn .
p. panchekha a. t. geller m. d. ernst z. tatlock and s. kamil verifying that web pages have accessible layout in proceedings of the 39th acm sigplan conference on programming languagedesign and implementation ser.
pldi .
new york ny usa association for computing machinery jun.
pp.
.
.available p. panchekha m. d. ernst z. tatlock and s. kamil modular verification of web page layout proceedings of the acm on programming languages vol.
no.
oopsla pp.
oct. .
.
available j. wu g. reyes s. c. white x. zhang and j. p. bigham when can accessibility help?
an exploration of accessibilityfeature recommendation on mobile devices in proceedings of the 18th international web for all conference.
ljubljanaslovenia acm apr.
pp.
.
.
available x. zhang l. de greef a. swearngin s. white k. murray l. yu q. shan j. nichols j. wu c. fleizach a. everitt and j. p. bigham screen recognition creating accessibility metadata for mobile appli cations from pixels .
a. s. ross x. zhang j. fogarty and j. o. wobbrock examining image based button labeling for accessibility in androidapps through large scale analysis in proceedings of the 20th international acm sigaccess conference on computers andaccessibility ser.
assets .
new york ny usa associationfor computing machinery p. .
.
available google our all new talkback screen reader updated .
x. zhang a. s. ross and j. fogarty robust annotation of mobile application interfaces in methods for accessibility repair andenhancement in proceedings of the 31st annual acm symposium on user interface software and technology ser.
uist .
new york ny usa association for computing machinery p. .
.
available j. chen c. chen z. xing x. xu l. zhu g. li and j. wang unblind your apps predicting natural language labels for mobile gui components by deep learning mar.
.
.
available f. mehralian n. salehnamadi and s. malek data driven accessibility repair revisited on the effectiveness of generating labels for icons inandroid apps in proceedings of the 29th acm joint meeting on european software engineering conference and symposium on thef oundations of software engineering ser.
esec fse .
newyork ny usa association for computing machinery aug. pp.
.
.
available e. brady and j. p. bigham crowdsourcing accessibility human powered access technologies f oundations and trends in human computer interaction vol.
no.
pp.
.
.
available android accessibility help magnification .
z. liu c. chen j. wang y .
huang j. hu and q. wang owl eyes spotting ui display issues via visual understanding in proceedings of the 35th ieee acm international conference on automated softwareengineering ser.
ase .
new york ny usa associationfor computing machinery p. .
.
available a. alameer p. t. chiou and w. g. j. halfond efficiently repairing internationalization presentation failures by solving layout constraints in2019 12th ieee conference on software testing v alidation and v erification icst pp.
.
r. k. saha y .
lyu h. yoshida and m. r. prasad elixir effective object oriented program repair in 32nd ieee acm international conference on automated software engineering ase oct. pp.
.
s. h. tan z. dong x. gao and a. roychoudhury repairing crashes in android apps in proceedings of the 40th international conference on software engineering ser.
icse .
new york ny usa association for computing machinery may pp.
.
.
available r. s. shariffdeen s. h. tan m. gao and a. roychoudhury automated patch transplantation acm transactions on software engineering and methodology vol.
no.
pp.
dec. .
.
available f. long and m. rinard automatic patch generation by learning correct code in proceedings of the 43rd annual acm sigplan sigact symposium on principles of programminglanguages ser.
popl .
new york ny usa association forcomputing machinery jan. pp.
.
.
available