featuretrace recording paul maximilianbittner paul.bittner uni ulm.de universityof ulm ulm germanyalexander schulthei alexander.schultheiss hu berlin.de humboldt universityof berlin berlin germanythomasth m thomas.thuem uni ulm.de universityof ulm ulm germany timo kehrer timo.kehrer hu berlin.de humboldt universityof berlin berlin germanyjeffreym.young youngjef oregonstate.edu oregonstateuniversity corvallis usalukas linsbauer l.linsbauer tu braunschweig.de tubraunschweig braunschweig germany abstract tracingrequirementstotheirimplementationiscrucialtoallstakeholdersofasoftwaredevelopmentprocess.whenmanagingsoftwarevariability requirementsaretypicallyexpressedintermsof features a feature being a user visible characteristic of the software.whilefeaturetracesarefullydocumentedinsoftwareproduct lines ad hocbranchingandforking knownasclone and own is stillthedominantwayfordevelopingmulti variantsoftwaresystems in practice.
retroactive migration to product lines suffers from uncertainties and high effort because knowledge of feature traces must be recovered but is scattered across teams or even lost.
we propose a semi automated methodologyfor recording feature tracesproactively duringsoftwaredevelopmentwhenthenecessary knowledge is present.
to support the ongoing development of previouslyunmanagedclone and ownprojects weexplicitlydeal withtheabsenceofdomainknowledgeforbothexistingandnew sourcecode.
we evaluatefeature tracerecording byreplayingcode edit patterns from the history of two real world product lines.
our results show that feature trace recording reduces the manual effort tospecifytraces.recordedfeaturetracescouldimproveautomation in change propagation among cloned system variants and could reduce effortif developers decideto migrateto aproduct line.
ccs concepts softwareanditsengineering softwareconfigurationmanagement andversioncontrolsystems software evolution .
keywords featuretraceability featurelocation disciplinedannotations cloneand own software product lines acmreference format paulmaximilianbittner alexanderschulthei thomasth m timokehrer jeffreym.young andlukaslinsbauer.
.featuretracerecording.in proceedingsofthe29thacmjointeuropeansoftwareengineeringconference andsymposiumonthefoundationsofsoftwareengineering esec fse august 23 28 athens greece.
acm new york ny usa 14pages.
publication rights licensed to acm.
acm acknowledges that this contribution was authoredorco authoredbyanemployee contractororaffiliateof anationalgovernment.assuch thegovernmentretainsanonexclusive royalty freerighttopublishor reproducethisarticle orto allowothers to do so for government purposes only.
esec fse august 23 28 athens greece copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
introduction for comprehending maintaining and extending existing software itiscrucialtofindlocationsofinterestinasoftwaresystemquickly reliably and exhaustively .
to that end tracing requirementstotheirimplementationisoneofthemostcommonactivities of developers and crucial to all stakeholders of a software development process .
whenmanaging software variability requirementsaretypicallyexpressedintermsof features afeaturebeinginformallydefinedasauser visiblecharacteristic of the software .
afeature trace identifies those artefacts of the softwaresystemthatimplementacertainfeature thusindicating where how andwhichfeatures are implemented .
while features their dependencies and their locations are fully documented in software product line engineering it is rarely adopted in practice.
the reasons for poor adoption are unforeseenrequirementsatthebeginningofdevelopment a highup frontinvestment lackoftoolsupport missing flexibility andnecessary workflowadaptations .
inpractice developmentbegins withonly asingle systemvariantofthesoftwaresystemtoreducecomplexityandcosts orbecause the need for future variants is unknown .
when the demand for a new variant emerges a fast and easy approach is clone and own bycloningthewholesoftwaresystem toalterspecificpartsindependentlyfromthepreviousvariant e.g.
using branches or forks developers can explore new ideas rapidly andwithoutputtingtheactualsystematrisk .thesecloned variantsaremeanttoco existwiththeoriginalvarianttoimplement variability.unfortunately propagatingchangessuchasbugfixesto other cloned variants is increasingly difficult and ambiguous with agrowingnumberofvariants .therefore a considerable amount of research focuses on migrating clone andown software to product lines allowing developers to switch to an integrated platform when managing a set of variants in parallel becomes infeasible .
however migrations suffer from high uncertainties because knowledge of feature traces is scattered across the team or even lost .
the migration to a product line may even fail and thus bears considerableeconomical risks .
wepropose featuretracerecording amethodologytoinferfeaturetracessemi automaticallyuponsourcecodechanges.themain ideaisthatbyrecordingfeaturetracesduringdevelopment they neither have to be recovered retroactively suffering from uncertainties nor specified explicitly in a separate step which causes esec fse august 23 28 athens greece p. m. bittner a.schulthei t. th m t. kehrer j. m. young l.linsbauer void pop storage null insert context safestack void pop if !empty storage null move context null void pop if !empty storage null context immutablestackdelete stack t pop stack t c clone if !empty c.storage null return c update context immutablestack void pop stack t c clone if !empty c.storage null return c insert context immutablestack void pop if !empty figure feature traces are recorded upon edits fromthefeature contextspecified by the developer.
overheadstotheactualsourcecodeeditingandbecomesincreasinglydifficultastimepassessincethelastedit.whilejietal.showed withhighmanualeffortthatrecordingfeaturetracesearlycansupportteamsinmanagingclone and ownsoftware wearethe firsttoproposeasemi automatedmethodologythatinspectsdeveloper edits.
our core design philosophy is that contributing domain knowledgeintheformoffeaturetracesmustplaceminimalburden ontheuserinordertobeaccepted.asdevelopersmightnotalways know to which feature an edited artefact belongs and because feature traces are initially absent inclone and own development we specificallydealwithabsentdomainknowledgeonbothnewand existing sourcecode.
in our envisioned methodology software development is performed according to a session oriented editing model where developers mayspecify the feature or feature interaction they are currently implementing.
from the edits developers make under suchafeaturecontext ofaneditingsession ourrecordingalgorithm infers feature traces for changed source code automatically.
moreover by employing disciplined annotations by k stner et al.
withabstractsyntaxtrees asts wereleasedevelopersfrom manual laborious anderror pronetasks suchasassigningopening andclosingbracketstospecifyfeaturetraceswhicharescattered among several code fragments.
in summary our contributions are feature tracerepresentation sec.
.wegeneralizesoftware product line concepts to clone and own by explicitly encodingmissingdomainknowledge.
feature tracerecording sec.
.wepresentamethodologyfor recording feature traces upon artefact changes from a possibly empty featurecontext specifiedbythe developer.
prototype andevaluation sec.
.
we show that feature trace recordingreducesmanualefforttospecifytracesandenables evolving variability in clone and own at the level of edits common to software product lines.
overview beforeformallyintroducingfeaturetracerecording weillustrate how developers can record feature traces and show its potential impact by describing how recorded feature traces can guide synchronisationsinclone and owndevelopmentand beused as inputfor amigrationto asoftware product line.
.
motivating example fig.
1illustrates feature trace recording from the perspective of an imaginary java developer called alice who is responsible for a singlesoftwarevariant e.g.
abranchorfork .alicerefinesthe pop methodofaclass stack.wehighlightsourcecodeimplementing certainfeatures withcorresponding colours.
nofeaturetracesarepresentintheinitialcode illustratedby theabsenceofcolours.alicenoticesthe popmethodisunsafe it doesnotcheckforanemptystack.shedecidesthiserrorshouldonly bepreventedwhendefensiveprogrammingisdesired namelywhen thefeature safestack isimplemented.alicemakesthisdecision explicit byspecifying safestack as thefeature context of heredit shown below arrows in fig.
.
she inserts a condition to check whether the stack is empty yielding snapshot .
the inserted codeis recordedasbelonging to thefeature safestack .
afterthe insertion alicehastomovetheoriginalimplementationofthe pop methodintothecondition.asaliceisnottheoriginaldeveloperof thepopmethod whichdoesnotexhibitanyfeaturetraces sheis unsurewhichfeaturethemovedstatementbelongsto.byswitching totheemptyfeaturecontext denotedas null alicecancontinue her working session without having to recover missing knowledge.
insnapshot themovedstatementisnotassociatedtoanyfeature.
later alice is assigned anew issue stacksshould be immutable .
shesetsthefeaturecontextto immutablestack forthesessionand continuesworkingonthe popmethod.first shedeletesthestatement that modifies the stack s storage leading to snapshot .
second she inserts new code to implement the immutable variant ofpop.
all inserted code is recorded to belong to the feature immutablestack asspecifiedbythefeaturecontext.finally thereturntypeof pophastobeupdatedfrom voidtostack t leading tosnapshot .featuretracerecordingassigns immutablestack to the updatedreturn type.
in this example alice did not have to specify traceability informationforeachchangedcodefragmentmanually.instead she could record feature traces for almost the entire popmethod from justthreedifferentfeaturecontexts.thefeaturecontextisaconceptweintroduceforfeaturetracerecording.it maybespecified bydeveloperstoindicatethefeatureorfeatureinteractiontheyare currently editing.
ingeneral featuretracerecordingisnottiedtoanyspecifictask intheworkflowofdevelopers suchascommitstoaversioncontrol 1008feature trace recording esec fse august 23 28 athens greece figure feature traces recorded in several variants.
featuresare indicated by differentcolours.
system.
instead we record feature traces at the granularity of edits whichweachievewithdifferencingtechniquesorloggingediting commands as explained later in sec.
.
in our example alice could commit to versioncontrolafter herfirsttwoeditsandat the end.
.
scenario1 enhancing clone and own infig.
weframehowfeaturetracerecordingcouldenhancecloneand own development.
by knowing feature traces top row and which variants implement those features bottom row target variants and code chunks for change synchronisation can be identified automatically.
the only prerequisites are thatdevelopers agree on acommonsetoffeatures anddocumentwhichfeaturesare implemented by which variant .
this means a cloned variantisequippedwitha configuration stating foreach feature whether it is implemented in this variant or not.
in our example alice knows that her variant s configuration bottom left includesatleastthetwofeatures safestack andimmutablestack .
imagine a second developer bob wants to propagate alice s changesfrom fig.1intohisvariant assumingthatbothvariants are two of several cloned variants in a clone and own project.
bob s variant implements the feature safestack but not feature immutablestack .furtherassumethatbothvariantsstartedwith version of popinfig.
1and bob did not apply simultaneous changes.propagatingalice seditstobob svariantyieldstheimplementation shown in fig.
.
assafestack is implemented in alice sandbob svariant propagatingthefirsttwoeditsfrom fig.
will yield the same code as in snapshot .
subsequent edits on immutablestack arenotsynchronisedasthisfeatureisnotpresent inbob svariant.
nonetheless alice deletedthestatement storage nullfromfeature immutablestack .thismeansthatthestatement doesnotbelong to immutablestack but it is still valid in those variantsthatdonotimplement immutablestack e.g.
bob svariant .
thus we recorded the feature trace immutablestack for the statement removed by alice although it is not present in her variantanymore.wedosobystoringthehistoryofeditssuchthat we can recall where and when artefacts got deleted.
the feature trace is then synchronised to bob s variant in which the statement shouldstillbepresent purplecolourin fig.
.thesameapplies forthereturntype voidthatwasupdatedbyaliceinhervariant.
notably the recorded trace immutablestack is different from alice sfeature context immutablestack as alice sedit indicatedthat the deletedartefact does not belong to the editedfeature.void pop storage null propagate applicable changes made in fig.
voidpop if !empty storage null figure propagating alice s edits see fig.
to bob s variant.
ifdef immutablestack 2stack t else 4void endif 6pop ifdef immutablestack 8stack t c clone endif ifdef safestack if !empty endif ifdef immutablestack c.storage null else storage null endif ifdef safestack endif ifdef immutablestack return c endif figure the variants of alice and bob migrated to an integrated codebase.
.
scenario2 migratingto aproductline formigratingasetofclonedsystemvariantsintoasoftwareproduct line feature traces are essential to extract corresponding source codeto forexample modulesinaframeworkoranintegratedcode base.
however recovering feature traces in a post mortem fashion requirestohaltdevelopmentforanunknowndurationand is error pronebecauseknowledgeonfeaturesisusuallywidespread across developers or even lost .
we argue that feature trace recording could help in increasing migration accuracy as feature traces were recorded when developer s had the necessary knowledge and reduce migration time as less feature traces mighthave to be recovered.
fig.4showsthe popmethodaftermigratingthevariantsofalice andbobtoapreprocessor basedsoftwareproductline.allvariants are unified in a single code base where feature traces are specified internally i.e.
inside the source code via ifdef directives.
thus weomitcoloursasweusecolourstorepresentfeaturetracesthat are stored externally i.e.
in a separate document .
as shown in fig.
alicerecordedtraceabilityinformationforalmostallcode elements of popby step .
hence little effort is required to reach full traceability as only the feature of the definition of popitself remainsunknown black colourin fig.1and3 .forthisexample we assign trueto the definition of pop meaning it is included in all variants and thus not surrounded by preprocessor directives in fig.
.aliceandbobcanretrievetheirvariantsfrom fig.4using theirrespective configurationsfrom fig.
.
.
ourcontribution in this paper we focus on alice s part of the example see sec.
.
formallyintroducingthemethodologyoffeaturetracerecording and evaluating its applicability.
the described scenarios of enhancingclone and ownandmigrationstoproductlinesservetoillustrate potential benefits of recorded feature traces.
we leave a more detailed investigation of the scenarios to future work for which feature traces are an essentialprerequisite.
1009esec fse august 23 28 athens greece p. m. bittner a.schulthei t. th m t. kehrer j. m. young l.linsbauer featuretracerepresentation while most stakeholders are usually interested in feature traces i.e.
knowing which artefacts implement a given feature from a technical point of view it is more natural to consider feature mappings i.e.
whichfeaturesareimplementedbyagivenartefact .
aswewilllaterexplaininmoredetail featuretracescanbeinferred from feature mappings andvice versa.
we do not store feature mappings by annotating source code directly with preprocessor macros or similar annotations for two reasons.
first preprocessor macros are known to be errorprone as they obfuscate source code thus reducing readability and maintainability as emphasized in fig.
.
second we aimto maintain developers existing workflows inwhichfeaturetracesmaynothavebeendocumentedatallyet.
tothisend westorefeaturemappingsexternally i.e.
inaseparate file andvisualisethembycolouringsourcecodeasshowninour motivatingexample in fig.
.
.
minimizing syntaxerrors in general removing artefacts that implement the same feature should not invalidate the program but should instead create a new variant.
we refer to program invalidation in terms of violating a programming language s grammar as syntax errors .
linebased feature traces such as preprocessor macros are unaware oftheunderlyinglanguage.itisthedeveloper sresponsibilityto ensure that no syntax errors occur when deriving variants.
for instance in fig.
the closing bracket in line 19has to be mapped to the same feature safestack as the opening bracket in line .featuretracesthatdonotcausesyntaxerrorsuponremoving associatedimplementationartefactsarereferredtoas disciplined annotations .
we transfer the product line concept of disciplined annotations by k stner et al.
to variant oriented development such as clone and own bymappingfeaturestonodesofanabstractsyntax tree ast insteadofsourcecodelines.
astsdescribethesyntactic structureofanimplementationartefactandareconstructedfrom the grammar of the artefact s language by abstracting from concretesyntax .inotherwords an astrepresentsthestructural elementsofthecorrespondingprogram1.fig.5showsthe astof version ofthe popmethodinour motivatingexample in fig.
.
whenfeaturesaremappedto astnodes developersdonothave totakecareofsyntacticelementssuchascommasorbrackets.in fig.
threenodesareassignedtothefeature safestack indicated by the solid blue colour we describe the shapes and colours in detailbelow.tominimisepotentialsyntaxerrorswhenremovinga feature snodes weadheretothefollowingtworulesintroduced byk stneretal.
optional onlyrule onlyoptionalnodesmaybeassignedtofeatures .forinstance entiremethodscanbesafelyremovedfrom theast.incontrast the statements nodebelowthe methoddef shownin fig.5ismandatory asremovingitwouldinvalidatethe method.though mandatorynodescanstillberemovedwhenthey arepartofanoptionalsubtree e.g.removingtheentire methoddef 1ifnogrammarisavailable e.g.
forareadmefile asafallbacksolution linebreaks canbeused to separateelements i.e.
lines of text .methoddef pop type voidstatements condition expression unaryop !
expression funccall empty argsstatements exprstatement expression assignment varref storage expression literal nullparametersdef optional node mandatory node wrapper mapped to safestackinheritssafestack in presence condition figure astofversion ofthe popmethod from fig.
.
subtreefromitsclass .an ast srootisalwaysoptionalasentire files classes or modules can always be removed.
in fig.
optional nodeshavesolidbordersandmandatorynodeshavedottedborders.
all mandatory nodes are uncoloured or hatched as they are not mapped to any feature.
though exceptions for some mandatory nodes are useful .
for instance we consider the return type of a method as optional as it can be implemented differently across variants as inour motivatingexample in sec.
.
subtree rule asts directly unveil membership relations.
for instance statementsthatformtheimplementationofthe popmethod canbefoundinthesubtreeof pop s nodein fig.
.
asthese statementscannotexistwithoutthesurroundingmethod theyshould onlybe presentwhenthe method isalsopresent.
thus wepropagateanode sfeaturemappingtoallitsdescendants i.e.
allnodesin itssubtree .anexceptiontothisruleare wrappers dashedbordersinfig.
constructssuchasconditions loops orthe unaryop infig.
5that wrap nodes of the same type as the wrapper s parent canberemovedsafelywithoutremovingtheirwrappedcontent.for instance removing the conditiontogether with its expression subtree leftsubtreein fig.
butwithoutitswrappedstatements right subtree yieldsavalid ast again.
wrappers are alwaysoptional.
formally wewrite v tifanodevisfoundinan astt.nodes canpotentiallybepartofmultiple asts forinstancetheoldand newversionofan astbeforeandafterachangebythedeveloper.
in the next section we describe how features are assigned to ast nodes andhowwe implement the optional only andsubtree rule.
.
encoding missing knowledge with feature trace recording we support ongoing development of unmanaged clone and own projects in which artefacts may not be associated to features at all.
for instance alice did not know the feature of the statement she moved and feature knowledge on 2we employ differencing or structural editing to determine if anodecanbefoundin the newand old version of anast cf.
sec.
.
.
1010feature trace recording esec fse august 23 28 athens greece thepopmethod and its return type was initially missing.
thus the corresponding ast nodes are uncolouredin fig.
.
formally we introduce the propositional atomic value null.
we treatnullastheneutralelementinnegationsandconjunctions i.e.
null nulland null for any propositional formula yielding the ternary logic by soboci ski .
we refer to a propositional formula whose literals may have nullas a possible valueasnullablepropositionalformula .assoftwareartefactsmaybe associatedtosinglefeatures featureinteractions orevennegations of features we allow assigning nullable propositional formulas over features to ast nodes definition3.
.
afeaturemappingisafunction fthatmapseach optionalastnode to a nullable propositional formula over the set offeatures.
thisdefinitionoffeaturemappingsrespectstheoptional only rule cf.sec.
.
as we only assign a formula to optional nodes.
alsonotethat froman astwithacorrespondingfeaturemapping one can acquire feature traces stating which artefacts implement a given feature fby grouping all nodes vwheref f v we write a bif andonly if a bisatautology .
to account for the subtree rule we introduce the presence condition.givenafeaturemapping f thepresencecondition pc t f v of a node v tis a nullable propositional formula which states whenvmust be present depending on its own mapping and its embedding into t pc t f v f v logicalandtext.
a at v f a visoptional pc t f pt v else.
wherept v istheparentnodeof vintandat v denotestheset ofalloptional non wrapper ancestors of vint.
the presence condition of an optional node is a conjunction of its own feature mappingf v and the mappings of all its surrounding constructs e.g.
methods and classes .
as mandatory nodes are not assigned to any feature and belong to their parent s definition they have the same presence condition as their parent the else case .
in fig.
solid and hatched blue nodes have the presence condition safestack .
if a nodev tis unmapped i.e.
f v null it neitherinvalidates norcontributestoitspresenceconditionas nullisneutralinconjunctions.
for the same reason a node mapped to nullalso does notinfluencethepresenceconditionsofitsdescendants.differentiatingbetweenfeaturemappingandpresenceconditionseparates two concerns assigning features to individual artefacts ast nodes and respectinganartefact sstructure ast toemploy disciplinedannotations.thisallowsustoonlylookat feature mappings duringrecordinginthe nextsection while presence conditions willensure discipline automatically.
insummary werepresentfeaturetracesasassignmentsofnullable propositional formulas to astnodes formally referred to as feature mappings to account for missing knowledge on feature traces.
with asts we can minimize syntax errors when removingartefactsofacertainfeaturebyimplementingdisciplinedannotations through the presence condition.
we store feature mappingsexternallytosupportexistingworkflowsinwhichfeatureswereprobablynotdocumentedbydevelopersyetandtoavoid shortcomingsofpreprocessorannotations.
featuretracerecording equippedwithaformalspecificationforfeaturetracesandartefacts we now turn to theirevolution by recordingfeature traces during development.
we first formalise our notions of edits and feature context in sec.
.
and present our recording algorithm in sec.
.
.
.
editingofdevelopmentartefacts the goal of feature trace recording is to enable developers to document their domain knowledge during development.
in accordance with our ast based representation of feature traces we handle softwareevolutiononthelevelof asts.specifically wedescribe changes onasts as functionsto whichwe refer as edits definition .
.
an editeis a function transforming an asttto anotherast t e t .
therearemanytypesofedits whereinsertionanddeletioncanbeconsideredprimitivesasthey can modelany change by deletingeverything and inserting a new version.however suchanapproachisinfeasibleasexistingfeature mappingsmaybelostupondeletion.hence wealsoconsider updatesandmoves whereupdateschangepropertiesofnodes such as names andmoves relocate subtrees .
asintroducedinourmotivatingexamplein sec.
.
weassociate eacheditwithafeaturecontext anullablepropositionalformula describing on which feature or feature interaction the developer is currentlyworking.thefeaturecontextcanbe nullasdevelopers might sometimes not know to which feature an edited artefact belongs such as alice inher secondeditin fig.
.
we restrict the feature context to formulas that are satisfiable in the current variant.
this means the feature context must be eithernullorsatisfiablegiventhecurrentvariant sconfiguration cf.sec.
.
.thus whendevelopersspecifythefeaturecontext we ensure that they can only edit features comprised by their variant.
detecting edits is possible through differencing where a list of edits is derived from the old and new version of an ast e.g.
on commit to version control or document save .instructuralediting usedfordomain specific or graphical programming languages user interactions with the ide yield a list of edits directly.
given such a list of edits we apply our algorithm sequentiallyto eacheditseparately.
inspecting astsduringdevelopmentisacommonmechanism forstaticanalysisandcodehighlightinginmodernides evenon syntacticallyinvalidstates.thus wedonotexpectscalabilityissues whenextendinganidewithfeaturetracerecordingbecausewecan reusethe astsprovidedbytheideduringruntime.whenadopting feature trace recording outside of an ide e.g.
upon commit to version control every changed file has to be parsed exactly once.
.
featuretracerecording algorithm feature trace recording is defined in alg.
.
it takes an edit emade to anasttoldunder feature context and the existing feature mappingfold.
itcomputes thefeature mapping fnewfor the new versionofthe ast tnew e told .
featuretracerecordingisdesignedasaframework foreachtype of editt it provides a dedicated recording function rthandling edits of that type.
each rtis a function that takes the old ast 1011esec fse august 23 28 athens greece p. m. bittner a.schulthei t. th m t. kehrer j. m. young l.linsbauer algorithm1 feature tracerecording input edite feature context asttold feature mappingfold output newfeature mapping fnew t type ofe ins del mov up ast nodes involvedin e fnew rt told fold recordnewmapping returnfnew table recorded feature mapping fnew v for edited ast nodesv depending on the feature context and the old feature mapping fold v .
fold v rins rdel rmov rup defined defined pc told fold v fold v defined null nulldefined falsefold v fold v null null null null null null told theset ofedited astnodes theoldfeaturemapping fold and the feature context to derive the next feature mapping fnew fortnew.
here the edit eitself does not need to be considered in detailaswehandleitstype tbychoosingaspecialisedrecording function rtand collecting the involvednodesinthe set .
the set comprisesallinserted removed orupdatednodes dependingon theeditbeinganinsertion deletion orupdate respectively.
ifthe editisamove isthe setofallnodes inthe movedsubtree.
asaframework featuretracerecordingcanbetailoredtospecific needs by providing custom implementations for the recording functions rt.inthispaper weintroducerecordingfunctionsfor insertion deletion move andupdate i.e.
t ins del mov up butthegeneralframeworkisopentobeextendedbyfunctionsthat handle domain specific editoperations e.g.
refactorings .
table1providesanoverviewofthemapping fnew v produced by eachof our recordingfunctions rtfor edited nodes v .we discuss the construction of each recording function rtin detail in the following section.
.
recording featuretracesforspecific edits in the following we describe our implementation of the recording functions rtforinsertion deletion moves andupdates.according toalg.
wedeterminefeaturemappingsforalleditednodes v from the previous mapping foldin the old asttoldand feature context andkeepmappings ofunchangednodes v .
insertions .wedefinetherecordingfunction rinsthatisused uponinsertionsas follows rins told fold v braceleftbigg v fold v else.
as inserted astnodesv are new to the code base they do not haveafeaturemappingyet i.e.
foldisundefinedforthem .the featurecontext describesexactlythefeatureorfeatureinteractiondevelopersarecurrentlyediting.thus weconsiderinserted nodes being addedto that feature formula and assign to them.
if developers do not specify a feature context we do not know to which feature formula inserted nodes belong and thus assign null.
feature mappings of existing nodes v remain unchanged because they are not affectedbyinsertionsofothernodes.deletions .deletions of artefacts v should be propagated to exactly those variants that should not contain vanymore as illustratedin sec.
.
.thus themajortaskfor rdelistodifferentiate between total deletions removing an artefact from all variants andpartialdeletions removinganartefactinaparticularfeature interaction .
we assign feature mappings to deleted artefacts for the sake of change synchronisation and to introduce the mappings to variants in which the artefacts are not deleted.
we do so by storing the edit history to remember where and when artefacts weredeleted aspointedoutin sec.
.
.fortheremainderofthis paper we abbreviate the presence condition pc told fold v of a nodevinthe old versionof the ast with pcold.
rdel told fold v pcold v null false v null pcold null null v null pcold null fold v v .
we cover each case from top to bottom in a separate paragraph except forthe lastcase v which statesthat mappingsof nodes being unaffectedbythe editremainunchanged.
when developers delete a node vunder a feature context null vdoes not belong to that feature formula anymore.
however vmay still be a valid implementation in those variants not implementingthecontext butv scurrentfeatureformula pcoldas is shown in our motivating example in fig.
alice removed the statement storage null fromhervarianttoreplace it with an implementation for immutablestack but the statement wasstillavalidimplementationinthosevariantsnotimplementing immutablestack such as bob s variant.
thus deleting a node v under context introduces a feature interaction.
we can refine itsmappingbyconjunction with andtherebyremove vfrom exactly those variants containing the interaction pcold .
we reason on the presence condition pcoldof a deleted node vhere instead of just its mapping fold v because when removing vfrom theast weloseinformationonpreviousancestors.thus wehave to inline the presence condition here to remember existing dependencies.
in case vdoes not have a presence condition we assign null tovasweonlyknowthat vshouldnotbepresent invariants implementing anymore.
ifthedeveloperdoesnotgiveinformationonwhichfeatureis currentlyeditedexplicitly i.e.
null butthedeletednode v has a presence condition pcold null we know that vwas a valid implementation in at least those variants whose configurations satisfypcold.wethusaimtoremove vfromallvariantsimplementing pcoldandcouldassign pcoldtov.however thiswouldmeanthat vshould be present even in those variants satisfying pcoldwhich did not contain vbefore the deletion and should not do so afterwards.
thus there is no variant at all that should contain vafter thedeletion.wemakethisexplicitbyassigning falsetovasfalse is unsatisfiableinallvariants.infact asimilar situationmayalso occurinthefirstcaseof rdel whenthefeaturecontext isdefined and equal to the deleted artefact s presence condition pcold.
in this case vhastoberemovedfromallvariantsbecauseitshouldnotbe presentinthosevariantsimplementing pcoldbutshouldalsonot 1012feature trace recording esec fse august 23 28 athens greece beinsertedtothosevariantsnotimplementing pcold.thisisindeed thecasebecause pcold falsewhen pcoldand null.asbefore assigning falsetovisimportantbecausejust wouldmeanthat vshouldbecontainedinthosevariantsthat didnot contain vbefore the deletion.
when neither a feature context is given nor the deleted node v ismapped i.e.
it spresenceconditionis null weonlyknow that it cannot be present in the current variant.
as this does not give insight on which variants should contain v we make this uncertainty explicit byassigning nullto deletedartefacts.
moves.the advantage of considering moves explicitly is the opportunity to keep existing mappings of moved nodes that would be lost when expressing moves interms ofdeletion andinsertion rmov told fold v braceleftbigg fold v v fold v else.
movingan artefactmeansextractingitfrom oneplacetolocate it somewhereelse forinstance movingamethodfromoneclassto another.
this means the method does not belong to its previous class but to the new one.
however the method may be assigned a feature formula and also its statements may or may not implement severalfeatures.thus wedecidetokeepthemappingsofmoved artefacts e.g.
the method and its statements but not the entire presence condition as developers decided to extract the artefacts from its surroundings e.g.
the class .
instead presence conditions of moved artefacts adjustautomatically according to surrounding constructs i.e.
previous and new ancestors in the ast .
when developersindicatethecurrentlyeditedfeatureformulainterms of thefeature context weknowthemove affectsthat feature or featurecombination .hence weintroduceafeatureinteraction fold v .
when developers do not specify a feature context i.e.
null we keep the existing mapping without extending it becausefold v fold v null fold v .
this is what happenedwhenalicemovedastatementinourmotivatingexample insec.
.1withoutknowing whichfeature sheisediting.
updates.asformoves consideringupdatesexplicitlyallowsto keepexistingfeaturemappingsthatwouldbelostwhenexpressing updatesjustinterms ofinsertionsanddeletions rup told fold v braceleftbigg null v fold v else.
when a node v is updated we have to ensure that this update affects all variants implementing the currently edited feature .
in contrast to moves updates change the artefacts themselves and thus can be seen as more functional changes to the source code e.g.
when a function call is renamed and could point to a different function afterwards .
thus we replace existing mappings of updated nodes v if a feature context is given.
for instance in our motivating example in sec.
.
alice changed the return type of thepopmethodforthefeature immutablestack .themappingof thereturntypeshouldbe immutablestack aftertheupdateeven if it would have been mapped to another feature previously.
when no feature context is specified we keep existing mappings as there is no evidence by the developer that the edited feature is not the feature ofthe updatedartefact itself.summary .withalg.
feature traces can be recorded upon editstothesoftwarefromthedeveloper sfeaturecontext.when performingmultipleeditsonthesamefeature thecontextcanbe keptanddoes nothavetobeswitchedasshownin fig.
.feature tracerecordingcanbeemployedonpreviouslyunmanagedcodeto gradually record knowledge on the code base as we explicitly deal withabsent knowledge cf.
sec.
.
evaluation by recording feature traces upon source code edits developers can be released from three key challenges of documenting feature traces for multi variant software systems taking care ofdisciplined feature mappings dealing with the absence of domain knowledge and tracingartefacts thatare deleted inthe course ofevolution.thesearequalitativeachievementsovertraditional source code annotations which are known to be error prone seesec.
enforceanimmediatedecisiononfeaturemappings and cannothandle the annotation of deletedartefacts.
furthermore weevaluatetheapplicabilityoffeaturetracerecording by investigatingwhether itenables developers to edit variable softwaresystems rq1 .recordingshouldimposealowburdenfor developers rq2 and ideally be easier than specifying feature traces manually rq3 .
rq1doesfeaturetracerecordingsupportcodechangesthatare common when developingvariable software?
rq2howoften mustthe feature contextbe switched?
rq3how complex is the feature context in comparison to the desiredfeature trace formula?
.
studydesign ideally featuretracerecordingwouldbeevaluatedbyanalysinga real world history of editswith feature contexts.
as we introduce thenotionofafeaturecontextinthispaper therearenoexisting datasetswecoulduseforthesakeofevaluationdirectly.furthermore feature traces are usually missing in existing clone and own projectsorareimprecisewhenrecoveredretroactively e.g.
on migrationsasin sec.
.
.thisimpedesverifyingthecorrectness of recorded traces as we are missing a ground truth to compare our results with.
to the best of our knowledge exact and complete feature traces can only be foundinsoftware product lines.
we thus inspect real world edits to software product lines as feature traces are known beforeandafteredits.
this lets us understandhow featuretraces havetochangewhen developersedit sourcecode.tothisend weanalyseifandhowanedittoasoftware productlinecanbeturnedintoaneditonvariantswhenemploying feature trace recording e.g.
in clone and own .
in terms of our motivating example this means to inspect if alice and bob can reproducepossibleeditstotheunified popmethodin fig.4when they instead develop their respective variants with feature trace recording.
therefore wereusetheclassificationofeditstosoftwareproduct lines by st nciulescu et al.
.
they derived a set of edit patterns that classify all edits in the history of the product line marlin3 and .
of the edits in the product line busybox4.
each pattern 3up to commit 3cfe1dce1 in 4up to commit a83e3ae in 1013esec fse august 23 28 athens greece p. m. bittner a.schulthei t. th m t. kehrer j. m. young l.linsbauer describes a possible kindof edit to software artefacts and their feature mappings at a fine granularity i.e.
not on the level of commitsbutedits .infact acommitmayconsistofseveralpattern applications .
in our study we analyse each edit pattern to seeiffeaturetracerecordingiscapableofreproducingrespective changes to feature traces andwhichfeature contextisnecessary.
.
reproducingeditsto softwareproduct linesin clone and own in this section we examine if and how edits to software product lines can be turned into edits when developing variants directly with feature trace recording e.g.
in clone and own .
table 2gives an overview of the examined edit patterns.
as feature trace recordingworksoncodechanges weomitallpatternsdescribingchanges tofeaturetracesonly.changingtracesexplicitlythatwayisorthogonaltoourrecordingandcanbeprovidedbyidetools.foreach pattern the number of matched edits in marlin s commit history is given in the editscolumn computed by summing the multi and only columns in the original paper .
we give the ratioofeditsforeachpatterninthe ratiocolumn.featuremapping formulasthataretobeinferredbyapatternaredenotedbyapropositionalformula m.weusethistargetfeaturemappingformula m asourbaselinetoanswerrq2andrq3becauseexistingtechniques forproactivefeaturetracingduringdevelopment require specifying mfor eachartefact manually cf.
sec.
.
each pattern is a possible kind of edit to source code and to the associated feature mappings.
thus we depict feature mappings as preprocessorstatementsasin fig.4whendisplayingthepatterns.
thisenablesus toshow ifand howfeaturemappings arealtered wheneditingcorrespondingsourcecode.accordingly preprocessor statements are notpart of the edited code.
instead they describe howfeaturemappingschangeuponaneditwhenturningapattern to an edit on variants just as preprocessor statements represent featuremappingsinthemigrated popmethodin fig.4butnotin alice andbob svariants of popinfig.
1andfig.
.
conditions could be expressed by any of ifdef ifndef or if ofwhichwechose ifinthefollowingasitisthemostgeneral.
for visualising patterns we adopt the unified diff notation.
added lines are green and labeled with .
removed lines are pink and labeled with .
lines without colour or marker remain unchanged.
wealsosimulateeachpatterninourresearchprototype5with structural editing to see if derived feature contexts are indeed suitabletoreproduceapattern.additionally ourprototypereproduces our motivatingexample from fig.
.
.
.
addifdef.
thefirsteditpatterncoverstheinsertionofsource code withafeature mapping formula m ifm inserted code endif ingeneral codeisinsertedandmappedto m.wecanreproducethis patterninanyvariantwhoseconfigurationisasatisfyingassignmentforthecondition m.insuchavariant insertingcodeunder featurecontext mwouldreproducethispattern.ouralgorithm 5github editpatternswith necessary feature contexts .
patternname edits ratio target in insiderespectively variants in mapping general mapped scope toedit addifdef .
m m nullor m addifdef .
m1 ... mnmi1 ... mij mik nullor mik j addifdefelse .
m m nullor m m m nullor m addifdefwrapelse .
m mm addifdefwrapthen .
m m m addnormalcode .
m m nullor m remnormalcode .
false trueor pcoldnullor pcold remifdef .
false nullor pcoldnullor pcold where m means hastobeequal toor weaker than m i.e.
m and j n usesrinsandtherebyassigns totheinsertedcodefragment.this happens in our motivating example in sec.
.
when alice inserts code under contexts safestack andimmutablestack .inside an optionalscopemappedto m e.g.
aclassormethod thecodecan evenbeinsertedwithoutanycontext i.e.
null .itwillinheritthe outer scope s formula min its presence condition cf.
eq.
.
thus setting the context tonullor any formula that is more general thanm i.e.
m is feasible.
for instance when m true or m ... thepresenceconditionofthecodewillbe m m. .
.
addifdef .
thispatterngroups napplicationsofthepreviousaddifdef with conditions m1 ... mn n .
as some of the conditionsmightbeidentical thefeaturecontexthastobechanged at mostntimes.
thus we have to repeat pattern addifdef jtimes j n with contexts k mik k ... j where each ik ... n denotes a unique index such that each conditionis considered exactly once.
when some conditions contradict each other e.g.
aand a orwhenthereisnovariantimplementingall conditions atonce wehave toadd thosecondition scodeto adifferentvariantaswecanonlyaddcodetoavariantifitimplements thedesiredformula k.soinworstcase all jcontextscontradict eachotherandthus the number of variants to editislimitedby j. .
.
addifdefelse.
similarto addifdef codesurroundedbyacondition isinsertedbut togetherwithan elsebranch ifm inserted code else inserted code endif the two inserted code fragments are supposed to have the feature mappingsfnew mandfnew m.we cannotreproduce thispatterndirectlyinasinglevariantbecausebothfeaturemappingsaremutuallyexclusive i.e.
contradicting .eachfragmenthas tobeaddedinavariantwhoseconfigurationsatisfiestherespective formula.in general each code fragment has to be inserted with the correspondingfeaturecontextsuchthat rinswillbeusedtoassign thecontextasmapping similarto addifdef.notably thealternative codefragment hastobeinsertedunder m.thisispossible as we decided to use propositional formulas for feature context andmappingsinsteadofsimplerconstructssuchaslistsoffeatures employed elsewhere .inside an optional scopemapped to m or mrespectively insertingcodeunderfeaturecontext nullor withm for code and m for code respectively is sufficient justas for addifdef.
1014feature trace recording esec fse august 23 28 athens greece .
.
addifdefwrapelse.
this pattern replaces an existing code fragment withan implementationfor acertainfeature ifm inserted code else existing code endif in general reproducing this pattern is possible with just the single featurecontext mtorecordbothmappings.wehavetoedita singlevariantthatimplements mandisnotsupposedtocontainthe existingcode anymore.bydeletingcode itwillbemapped to mbyrdel.
the new code can then be inserted under the same feature context to map it to mwithrins.
this is what alice did in the motivating example with her third and fourth edit infig.
shesetsthefeaturecontextto immutablestack deletes storage null and replaces it with the immutable version afterwards.
that way alice inserts new code mapped to immutablestack after deleting existing code that is recorded as belongingto immutablestack i.e.
theelsecase .insideanoptional scope mapped to m this pattern would be ill formed as it introducesdeadcode evenintheproductlineitself e.g.
marlin theelsecase wouldgetthepresencecondition m m false.
.
.
addifdefwrapthen.
reciprocal to addifdefwrapelse this pattern maps an existing artefact as belonging to a specific feature whileintroducing the more generalcase ifm existing code else inserted code endif ingeneral thispatterncanbereproducedthesamewayas addifdefwrapelse butwiththeinversefeaturecontext m.in avariant containingthecode andsatisfying m deleting willlet rdel determine m mas the new mapping.
subsequently code hastobeinsertedunderthesamecontext.again froma singlefeature context twodifferentfeature mappingsarerecorded.
insideanoptionalscopemappedto m thispatternisill formedeven inaproduct line justas for addifdefwrapelse .
.
.
addnormalcode.
this pattern comprises the insertion of code without any associated feature mapping.
the inserted code is eithernon variableorissupposedtoexistinsideotherexisting if scopes.in general the new code has to be inserted under feature context mbeing the target mapping m m truefor nonvariable code just as for addifdef.inside an optional scope mapped tom the new code can be insertedunder feature context nullor a formula weaker or equal to mjust as for addifdef as the code will inherit the outer scope sformula inits presencecondition.
.
.
remnormalcode.
thispatterndepictstheremovalofacode fragment regardless ofwhether itismappedto afeature ornot ifm removed code endif as artefacts are removed from the entire software they have to disappear from each variant containing them which means the code has to be assigned false.in general any feature context weaker than the deleted code s presence condition pcold e.g.
true is feasible.
rdelwill record pcold falseas both termscontradicteachother cf.
eq.
.ifpcold null thecontext has to be set to true.inside an optional scope mapped to m the feature contextcan even be setto nullasrdelwillassign false.
.
.
remifdef.
this pattern comprises the removal of preprocessorblocks.itcovers annotations withandwithout elsebranch ifm removed code else removed code endif as forremnormalcode the removed code has to be assigned false as it is removed from the entire software.
as for addifdefelse both casescontradicteachother andthustwovariantshavetobeedited.
asthe artefacts have a presence condition deletingthem without any feature context i.e.
null is sufficient as rdelwill record false.
analogousto remnormalcode anycontext withpcold works asrdelwillrecord pcold falseinthis case.
summary.
we summarise the results of our investigation of the abovepatternsin table2.thepossiblefeaturecontextstoreproduce each pattern and the number of variants that have to be edited are given in the respective columns.
all patterns can be reproduced.
when a pattern is applied inside a scope mapped to the target mapping even nullor multiple formulas are sufficient to record desired traces.if multiple variants have to be edited this is dueto contradictory mappings.
.
discussion rq1 applicability.
we showed that feature trace recording can beappliedsuccessfullytoreproduceallpresentededitpatterns.we alsoreproduce allpatterns inour prototype cf.
sec.
.
.
feature traces can be recordedfor allconsiderededitpatterns.
rq2 featurecontextswitches.
weconsiderhowmanyvariants havetobeedited andhowoftenanewfeaturecontexthastobe setto reproduce eachpattern.
differentvariantshave tobe editedwhen feature formulascontradict each other or when no variant is compatible to all formulas atthesametime.webelieveeditingmultiplevariantsatoncetobe unlikely for clone and own development.
even in marlin artefacts withcontradictingfeaturemappingswereaddedorremovedless often than editing just a single mapping or variant only .
of the edits were classified by addifdefelse .
byremifdef and .
byaddifdef where the latter two may contain cases without conflicting feature mappings.
forallpatterns theamountofrequiredfeaturecontextswitches isequaltoorsmallerthanthenumberofdifferenttargetmappings asshown in table .asingle featurecontextcould alsobereused whenapplyingseveralpatternsinarowasdonebyalicein sec.
.
.
forreproducing singlepatterns userinputisrequiredlessor as frequent as for directly specifying mappings.
feature context switchesarepotentiallylessfrequentwhenapplyingmultiple patterns in a row.
in at least .
of the cases only one variant has to be edited.
1015esec fse august 23 28 athens greece p. m. bittner a.schulthei t. th m t. kehrer j. m. young l.linsbauer rq3 featurecontext complexity.
to answer thisquestion we compare the feature contexts with the target feature mappings for eachpattern summarisedin table2.
allinsertionrelatedpatterns i.e.
add... exceptfor addifdefwrapthen can be reproduced in our clone and own scenario by settingthefeaturecontexttoexactlythedesiredfeaturemapping of the artefact to edit.
when deleting artefacts developers can differentiate whether they want to replace an artefact cf.
addifdefwrapelse addifdefwrapthen from a certain feature formula or want todeleteitfromallvariants cf.
remifdef remnormalcode by specifying a corresponding feature context.
in case of uncertainty deletinganartefact vunderafeaturecontext isalwaysa validoptionbecauseitsrefinedmapping pcold shrinkstheset ofvariantscontaining v.thisway developerscaniterativelydecide whethervhastoberemovedfromfurthervariants e.g.
variants they are responsible for such that vmay indeed be removed from every varianteventually.
forallpatterns includingthemostcommonones addnormalcodeandremnormalcode that comprise of all edits the featurecontextmayevenbeomitted.whenartefactsareinserted ordeletedinside scopes e.g.
aclass or method that already have the target mapping nullor several formulas are feasible.
only the rare patterns addifdefwrapthen andaddifdefwrapelse .
are ill formedinthiscaseastheyintroducedeadcodewhenperformed inthe product linealready.
in general the feature context has to be equal to the target featuremapping.fortwopatterns differentmappingscanbe recorded with just a single context.
for more than of the edits nulloravarietyofformulasareafeasiblecontextwhen an outer scope isalready assignedto the target mapping.
.
threatsto validity internal validity.
a possible bias could be introduced the way wedeterminedthefeaturecontext.ifmultiplepossibilitiesforreproducing a pattern exist we present the simplest one we could identifyin termsof numberof editsanddivergence ofthe feature context from the targeted feature mapping formula.
in practice developers could choose more complicated contexts but they could alsodosofor directannotations.
st nciulescuetal.admitthattheymighthaveintroducedbias whenidentifyingthepatterns .theyiterativelyidentifiedregular expressions until all edits in the considered history of marlin wereclassifiedandcross validatedtheirresultswiththeproductlinebusybox.
external validity.
the considered evolution might not be representative for clone and own development.
as discussed in our studydesignin sec.
.
softwareproductlinesturnedouttobethe only feasible datasets for our evaluation because clone and own software suffers from absent or imprecise feature traces.
however evensoftwareproductlineslackthedirectavailabilityoffeature contexts.
we thus decided against investigating development historiesofexistingprojectsmanually.instead wearguethatreverseengineeringfeaturecontextsfor possiblechangestoproductlines isthe besttrade offfor our evaluation.the considered edit patterns might be incomplete regarding the evolution of variable software systems.
the history of marlin analysed by st nciulescu et al.
contains commits excluding merge commits that lead to 40k lines of code with more than featuresin187sourcefiles withoutfilesforarduino inthelastversionatcommit3cfe1dce1.furthermore somepatternswerealready identifiedinpreviouswork increasingourconfidence that the mostcommon andessentialpatterns are included.
related work featuretracerecordingisthefirststeptowardsourvisionforbridgingthegapbetweenclone and ownandsoftwareproductlines depicted in sec.
.
.
to this end we extend early ideas on our variantsyncframework withthefirststructuredandformalmethod forinferringfeaturetracesfromdevelopers edits.preliminaryresults and ideas on feature trace recording were presented in the firstauthor smaster s thesis .
featuretracerecording isinspiredbyjietal.
.inanempirical study theyshowed the benefits of recording traces in a line based annotative approach known as embedded annotations orfeaturetags .ji etal.
simulatedthedevelopment ofvariable software by manually inspecting the commits of the history of a clone and ownproject.foreachcommit thefirstauthorembeds line based feature traces into the source code via comments based on his understanding of the codebase and the change history p. .
thus ji et al.
discovered insights on the effectiveness of documenting feature traces during development by embedding annotations manually.
sul r et al.
report similar results when using javaannotations for manuallydocumenting concerns.
both studiesrequiredhighmanual effort.withfeaturetracerecording weintroduceastructuredandformalizedmethodologyreducing thismanualeffort.heidenreichetal.proposedfeaturemapper a tool for the specification of feature mappings in model based softwareproductlines.whileinrecordingmode featuremapper assignsapre definedfeatureexpressiontodeveloperedits.with featuretracerecording wedonotplainlyassignthefeaturecontext toedits and edited artefacts but derive formulasbased on existing feature mappings.
moreover featuremapper is a pure software product linetool whichdoesnotconsiderindividualvariantsas necessary tosupport clone and own.in contrast weexplicitlyinspect edits for information relevant to other variants e.g.
upon deletions moves andupdates .
feature location and recovery also known as variability mining retroactively recovers or recommends feature traces withstatic ordynamicanalyses through comparingsoftwarevariants miningsoftwarerepositories orbycombiningthesemethods .withfeaturetrace recording weunlocksoftwareevolutionasanewsourceforfeature location.onecommonapplicationoffeaturelocationand recovery is the migration to a software product line as exemplified in sec.
.
.
feature trace recovery tools require numerous developer decisions on existing code forwhichthenecessarydomainknowledgemaybelost.fullyautomatic migration techniques cannot yet retrieve featuretracesinsufficientquality .withfeaturetracerecording developerscandocumentfeaturetracesgraduallywhenever 1016feature trace recording esec fse august 23 28 athens greece they have the necessary knowledge.thus potentially less feature tracesmight have to be recovered when migrating asdiscussed in sec.
.
.
to this end we explicitly deal with the absence of domain knowledge.
recently michelon et al.
raised awareness to distinguish features and their revisions in feature location tasks .
while not modelled explicitly in this paper feature trace recording supportsrecordingfeaturerevisions wheneverasequenceofedits is performed under the same feature context we can increment the version of all features that occur in at least one positive literal inthecontext sconjunctivenormalform.moregenerally feature trace recording may serve as one of the building blocks for a better integrationandmanagementofsoftwareevolutioninbothspace andtime amajorchallengewhichhasrecentlygainedincreasing researchinterestacrossdifferentresearchcommunities .
inspired by the product line tool cide we employ disciplined annotations to preserve syntactical correctness of featuremappings.experimentsconductedondiscipline revealthebenefitsforsuchconstraintsinindustrialpractice.weimplemented disciplined annotations in terms of presence conditions andextendedthemtobeabletohandlemissingdomainknowledge by using the ternary logic by soboci ski .
classifying astnodes by the underlying grammar as optional mandatory or wrapper nodes see sec.
wasautomatedbyk stneretal.
.
variation control systems and filtered product lines deal with variability on the level of features but where softwareproductlinesaredevelopedbyediting partial variants.
variation control systems either simplify development of software productlines orenhanceclone and owndevelopment and usuallyimposeatransaction basedcheckout change commitworkflow.
in contrast feature trace recording is more general as it does not require but could be adopted in such a workflow.
thus variationcontrolsystemscanintegratefeaturetracerecordingwhen developersare submitting their changes to a partial variant back totherepository.inthisregard wedirectlysolveanissuest nciulescu et al.
stated as future work for their system how to handle the cases when an ambition is weaker than the projection?
p. where ambitionandprojection areuser specifiedpropositional formulas.withthe projection userscheckoutapartialvariantof aproduct line.whensubmittingchanges to theirsystem sprojectional editor the ambition describes which feature formula was edited.
st nciulescu et al.
argue that a weaker ambition could be desirable when an edit should not only affect the edited projection i.e.
variant but other variants as well forexample when fixing a bug .wedirectlyaddressthisquestionasinourscenario the feature context similar to ambition is always weaker than the configuration similar to the projection .
clone management in terms of clone detection elimination tracking or prevention typicallyconsiderscodeclonesasasmall scalephenomenon .
however we envision to enhance large scale clone and own development at any stage of development.
as we do not want to impairdevelopers habitsandworkflowssignificantly weaimto enhanceclone and owndevelopmentinsteadofpreventingit.recently mahmoodetal.proposedvirtualplatform amethodandtool for gradualvariabilitymanagementatdifferent stagesinthe spectrum between pure clone and own and software product lines .
justasvariationcontrolsystemsandmigrationmethods virtualplatformalsorequiresfeaturemappingswhichhavetobespecified manually by developers with the mapassettofeature operator.
feature trace recording could be a possible implementation for mapassettofeature .
conclusion tracingfeaturestotheirimplementationisoneofthemostcommon tasks for developers and an essential prerequisite for variability management solutions.
if feature traces are not documented proactively as in software product lines they have to be recovered retroactivelywhichisofteninaccurateornotpossibleforalltraces.
inturn productlinescomewithahighup frontinvestmentthat maynot pay off when introducing just asinglenewvariant.
for this reason we propose to record feature traces during softwaredevelopment.
featuretracerecording infersfeaturetracesupon sourcecodeeditsfromafeaturecontext auser specifiedformula.
while product line techniques and variation control systems require complete feature traces and migration techniques fail to completelyrecoverthem featuretracerecordingaccountsforabsent knowledge inboth editedandexisting sourcecode.
inthefuture weplantoemployrecordedfeaturetracesforvariantsynchronisationinclone and ownasillustratedinbob spart of ourmotivating examplein sec.
.
.
tothis end we aim atbroadcastingeditsandfeaturetracestoallrelevantcodelocationsacross clonedvariantssimilartocherry picking.variantsmight evenbecome reconfigurable when a certain degree of feature traces is accumulated.foralltheseideas thefirstandforemostrequirement isthe automatedrecording of feature traces.
acknowledgment we thank our reviewers for their constructive feedback.
we also thankducanhvu alexanderboll helgewrede andkatharina juhnke for proof reading tobias he and pascal kohlhepp for their help withthe artefact tobias pett andina schaefer for early feedback and larissa f rster susana castillo alejandre marc kassubeck moritzkappel jann olehenningson saschafricke and jan philipp tauscher.
this work has been partially supported by thegermanresearchfoundationwithintheproject variantsync th andke .