summary based symbolic evaluation for smart contracts yu feng yufeng cs.ucsb.edu university of california santa barbaraemina torlak emina cs.washington.edu university of washingtonrastislav bodik bodik cs.washington.edu university of washington abstract this paper presents solar a system for automatic synthesis of adversarialcontractsthat exploitvulnerabilitiesina victimsmart contract.
to make the synthesis tractable we introduce a query language as well as summary based symbolic evaluation which significantlyreducesthenumberof instructionsthatoursynthesizer needs to evaluate symbolically without compromising the precisionofthevulnerabilityquery.weencodedcommonvulnerabilities of smart contracts and evaluated solar on the entire data set from etherscan.ourexperimentsdemonstratethebenefitsofsummarybased symbolic evaluation and show that solar outperforms stateof the art smart contracts analyzers teether mythril and contractfuzzer in terms of running time and precision.
acm reference format yufeng eminatorlak andrastislavbodik.
.summary basedsymbolic evaluation for smart contracts.
in 35th ieee acm international conference onautomatedsoftwareengineering ase september21 virtual event australia.
acm new york ny usa pages.
.
introduction smart contracts are programs running on top of blockchain platformssuchasbitcoin andethereum .theyinteractwith each other to perform effective financial transactions in a distributed system without the intervention from trusted third parties e.g.
banks .asmartcontractiswritteninahigh levelprogramming language e.g.
solidity and it is typically comprisedof a unique address persistent storage holding a certain amount of cryptocurrency i.e.
etherinethereum andasetoffunctionsthat manipulate the persistent storage to fulfill credible transactions without trusted parties.
for contract to contract interaction some functions are public and callable by other contracts.
thanks to the expressiveness afforded by thehigh level programming languages and the security guarantees from the underlying consensus protocol smartcontractshaveshownmanyattractiveusecases andtheir numberhasskyrocketed withover45million instancescovering financial products online gaming real estate shipping and logistics .
because all smart contracts deployed on a blockchain are freely accessible through their public methods any functional bugs or vulnerabilities inside the contracts can lead to disastrous losses ase september virtual event australia copyright held by the owner author s .
acm isbn .
demonstrated by recent attacks .
for instance the code simplified in figure illustrates the notorious reentrancy attack .
when the victim program issues a money transaction to the attacker it implicitly triggers the attacker s callback method which invokes the victim s method i.e.
withdraw again to make another transaction withoutupdating thevictim s balance.
the attack maliciously extracted tokens from the victim and led toafinanciallossof 150min2016.tomakethingsworse smart contracts are immutable once they are deployed fixing their bugs is extremely difficult due to the design of the consensus protocol.
improving robustness of smart contracts is thus a pressing practicalproblem.unsurprisingly acomplexvulnerabilitylikereentrancy typically involves interactions between multiple contracts which requires an analyzer to model the inter contracts communication and reason about the execution in a preciseandscalable way.
but existing tools either aggressively overapproximate the execution a smart contract and report warnings that do not correspond to feasible paths and therefore cannot be exploited ortheypreciselyenumerate concretetraces ofasmart contract so cannot scale to large programs with many paths.
thispaperpresentssolar anewpointinthedesignspaceof smart contract analysis tools that achieves an effective trade off amongexpressiveness precision andscalability.solarprovides thesecurityanalystwithaquerylanguageforexpressing vulnerability patterns that can be exploited in an attack as well as an automatic engine for synthesizing an attack program if one exists that exploits the given vulnerability.
our key insight is based on the observation that an attacker typically exploits the vulnerability bymakingasequenceoftransitions callsoverpublicmethodsof thevictim inwhichstoragestatesarepreservedacrossdifferent transitions.
because most types of vulnerabilities can be overapproximated through assertions over storage variables section .
thisinsightmotivatesaneffectivesummary basedsymbolicevaluationtechniquewherethesummaryofamethodsoundlymodelsits side effectoverstoragevariables whichdramaticallyreducesthe number of instructions that solar has to re evaluate symbolically.
asaresult solarisabletoscalereasoningwithbetterprecision to large contracts that are out of reach of existing symbolic execution andfuzzing tools.furthermore previoussummarization techniques rely on symbolic execution and can thereforeleadtosummariesthatareexponentialinprogramsize.
ourtechnique relieson rosette a hybridsymbolic evaluator thatcombinessymbolicexecutionandboundedmodelchecking to compute compact i.e.
polynomially sized and precise i.e.
encodingallfeasibleboundedpaths summariesattheprocedurelevel.
using these summaries solar can perform precise all paths analysis of a given contract while symbolically executing significantly fewer paths than rosette alone.
35th ieee acm international conference on automated software engineering ase this work is licensed under a creative commons attribution international .
license.
figure sample contracts to show the reentrancy attack.
touseourtool asecurityanalystexpressesatargetvulnerability query e.g.
the reentrancy vulnerability as a declarative specification.
solar then synthesizes an attack program that exploits the victim spublicinterfacetosatisfythevulnerabilityquery.given this problem a naive approach is to enumerate all possible candidate programs and then symbolically evaluate each of them tocheck if it satisfies the query.
while precise the naive approach fails to scale to realistic contracts.
evenwith summarization the searchspaceis stilltoo largefor brute force enumeration.
to address this issue we partition the searchspacebycasesplittingontherangeofsymbolicvariables whichallowsustosimultaneouslyexploremultipleattackprograms using rosette s smt based symbolic evaluation engine .
we have evaluated solar on the entire data set 25k from etherscan showing that our tool is expressive efficient and effective.solar squeryspecificationlanguageisexpressiveinthatit is rich enough to encode common vulnerabilities found in the lit erature suchasthereentrancyattack timemanipulation andmaliciousaccesscontrol securitybestpractices as well as the recent batchoverflow bug cve which allows the attacker to create an arbitrary amount of cryptocurrency.
solar is efficient on average it takes only seconds toanalyzeasmartcontractfrometherscan whichisfourtimesfaster thanteether andtwoordersofmagnitudefasterthancontractfuzzer .
solar is also effective in that it significantly outperforms state of the art smart contracts analyzers namely teether mythril andcontractfuzzer intermsoffalsepositiveandfalsenegativerates.theapproximatequeriesalsoenable solar to generate compact summaries and explore deeper vulnerabilities in exchange for a minor loss in precision.
in summary this paper makes the following contributions weformalizetheproblemofexploitgenerationasaprogramsynthesisproblemandprovideaquerylanguageforexpress ingcommonvulnerabilitiesinsmartcontractsasdeclarative specifications section .
.
weproposeanewsummary basedsymbolicevaluationtech niqueforsmartcontractsthatsignificantlyreducesthenumber of paths that solar has to execute symbolically section .
we develop an efficient attack synthesizer based on thesummary based symbolic evaluation which incorporates a novel combination of search space partitioning and parallelsymbolicexecutionbasedonthesemanticsofcandidate programs section .
.
weperformasystematicevaluationofsolarontheentire datasetfrometherscan.ourexperimentsdemonstratethe substantialbenefitsofourtechniqueandshowthatsolar outperformsthreestate of the artsmartcontractsanalyzers in terms of running time and precision.
section .
background we first review necessary background on smart contracts.
smart contract.
smart contracts are programs that are stored andexecutedontheblockchain.theyarecreatedthroughthetransaction system on the blockchain and are immutable once deployed.
each smart contract is associated with a unique bit address a private persistent storage a certain amount of cryptocurrency expressedasabalance i.e.
etherinethereum heldbythecontract andapieceofexecutablecodethatfulfillscomplexcomputationsto manipulatethestorageandbalance.thecodeistypicallywritten in a high level turing complete programming language such as serpent vyper andsolidity andthencompiledtothe 1142ethereum virtual machine evm bytecode a low level stackbasedlanguage.forinstance figure1showstwosmartcontracts written in the solidity programming language .
application binary interface.
in the ethereum ecosystem smart contracts communicate with each other using the contract application binary interface abi which defines the signatures of public functions provided by the hosted contract.
while abi offers aflexiblemechanismforcommunication italsocreatesanattack surface for exploits that use the abi of a given smart contract.
threat model.
to synthesize an adversarial contract we assume that the attacker can obtain the victim contract s bytecode andthe abi specifying its public methods.
to confirm an adversarial contract is indeed an exploit we must also be able to invoke publicmethodsbysubmittingtransactionsovertheethereumblockchain.
these requirements are easy to satisfy in practice.
overview inthissection wegiveanoverviewofourapproachwiththeaid of a motivating example.
.
smart contract vulnerabilities asecurityanalyst alice canspecifyvarioustypesofvulnerabilities that may appear in a smart contract.
for instance figure showsasimplifiedexampleofareentrancyattack.the withdraw function does two steps 1send a given amount of ether to the caller and 2updatethestoragestatetoreflectthenewbalance.at any point the total amount of balances of the victim and attacker should remain the same i.e.
bv ba c .
howeve r since1happensbeforeupdatingthestatein anattackercanre enterthe withdraw functionagainthroughtheanonymouscallbackfunction triggered by .
as a result the execution of the attack program canlead toaninconsistent state i.e.
b primev b primea c which enables the attacker to extract a large amount of ether from the victim.
to automatically generate exploits for the reentrancy vulnerability alicefirstspecifiesa querythatcharacterizes thesemantics of reentrancy.
as shown in the lower part of figure the attack canbesummarizedusingasequenceofkeystatementsbetweenthe victimandtheattacker i.e.
twoormore transfer2instructions followedbya storeoperation whichcanbeexpressedusingthe first order formula3in figure .
once alice expresses the reentrancy vulnerability the next stepistoconstructanattacktoconfirmthatthevulnerabilityindeed existsinthevictimcontract.alicecanleverageexistingsymbolic executiontools togenerateexploitsforsimplepropertiessuchasattack control inasinglecontract.butforcomplex vulnerabilities that require reasoning about interactions among multiplecontracts e.g.
attackerversusvictiminreentrancyorcallerversuscalleeinparitymultisig existingtoolsprovide either no support or very limited support that leads to high rates of false positives and negatives as shown in section .
.
yet alice can easily initialize the boilerplate code for basic interactions like the attack template on the left hand side of figure .
1ethereum s gas mechanism ensures that this callback loop terminates.
2we use transfer to denote the callinstruction in evm.
3solarconvertsaqueryintoitscorrespondingfolformulasthroughasyntax directed translation.
figure an example to show the batchoverflow attack.
what she needs is an efficient way to fill in the details of the attack program whichinvolvesexploringthespaceofallprogramsthat canbeobtainedbycompletingthetemplatewiththemethodsfrom the victim s interface.
.2solar solar helps automate this process by searching for attacks thatexploit a given vulnerability in a victim contract.
the tool takesas input a potential vulnerability vexpressed as a declarative specification.if vexistsinthevictimcontract solarautomatically synthesizesan attackprogram thatexploits v.anattackerinteracts withavulnerablecontractthroughitspublicmethodsdefinedin the abi.
therefore our goal is to construct an attack program that exploits the victim s abi and that contains at least one concrete trace where vholds.
to achieve this goal solar models the executions of a smart contractas statetransitions overregisters memory andstorage.the vulnerability visexpressedinracket asabooleanpredicate overthesestatetransitions.thetechnicalchallengeaddressedby solaristoefficientlysearchforanattackprogramwhere vholds.
toillustratethedifficultyofthistask considertheproblemof synthesizing an attack program that exploits the batchoverflow vulnerability cve in figure .
the attack program performs a complex three step interaction with the victimcontract.
first the attacker must set the storage variable flagto trueto pass the check at line .
next it needs to assign a large number to vthat leads to an overflow at line .
finally it specifies the attacker s address as the beneficiary of the transaction line .synthesizingthisattackprograminvolvesdiscoveringwhich methods to call in what order and with what arguments.
the naive approach to solving this problem is to generate all possibleconcreteprograms andexplorethespaceoftheir concrete traces.thisapproachsuffersfromtwosourcesofexponentialexplosion.
first there are o nk concrete programs of length kfor a victim contract with npublic methods.
second the number of concrete traces in each of these programs is exponential in the size of the program s global control flow graph obtained by inlining all method calls.
toaddressthetraceexplosionchallenge solaremploysanovel summary basedsymbolicevaluationtechniquepresentedinsec tion .
intuitively this technique enables solar to preserve only angbracketleftvar angbracketright def symid where boolean number angbracketleftpc angbracketright angbracketleftconst angbracketright angbracketleftvar angbracketright angbracketleftexpr angbracketright angbracketleftconst angbracketright angbracketleftvar angbracketright angbracketleftexpr angbracketright angbracketleftexpr angbracketright ... angbracketleftstmt angbracketright angbracketleftvar angbracketright angbracketleftexpr angbracketright angbracketleftvar angbracketright mload angbracketleftvar angbracketright mstore angbracketleftvar angbracketright angbracketleftvar angbracketright angbracketleftvar angbracketright sload angbracketleftvar angbracketright sstore angbracketleftvar angbracketright angbracketleftvar angbracketright angbracketleftvar angbracketright balance gas address angbracketleftstmts angbracketright angbracketleftstmt angbracketright angbracketleftstmt angbracketright angbracketleftstmts angbracketright sha3 angbracketleftvar angbracketright angbracketleftvar angbracketright jumpi angbracketleftpc angbracketright angbracketleftexpr angbracketright jump angbracketleftpc angbracketright no op transfer angbracketleftvar angbracketright angbracketleftvar angbracketright angbracketleft... angbracketright selfdestruct angbracketleftvar angbracketright angbracketleftparam angbracketright angbracketleftvar angbracketright angbracketleftparams angbracketright angbracketleftparam angbracketright angbracketleftparam angbracketright angbracketleftparams angbracketright angbracketleftprog angbracketright angbracketleftparams angbracketright.
angbracketleftstmts angbracketright figure intermediate language for smart contract thosestatetransitionsthatarepersistentacrossdifferenttransactions and are sufficient to answer the vulnerability query.
toaddresstheprogramexplosionchallenge section6introduces twoadditionaloptimizations.first insteadofexploringthespaceof concreteprograms weleveragerosette topartitionthisspace into a small set of symbolic programs section .
.
second instead of executing each symbolic program sequentially we partition the searchspacebycasesplittingontherangeofsymbolicvariables which enables solar to simultaneously explore multiple symbolic candidates section .
.
problem formulation this section formalizes the semantics of smart contracts shows howtoexpresssmartcontractvulnerabilitiesinsolar anddefinestheproblemofsynthesizinganattackcontractthatexploitsagiven vulnerability.
.
smart contract language figure3showsthecorefeaturesofourintermediatelanguagefor smartcontracts.
thislanguage isa supersetofthe evmlanguage.
itincludesstandardevmbytecodeinstructionssuchasassignment x e memory operations mstore mload storage operations sstore sload hash operation sha3 sequential composition s1 s2 conditional jumpi and unconditional jump jump .
it also includestheevminstructionsspecifictosmartcontracts transfer denotes all functions that send tokens between different addresses balance accesses the current account balance and selfdestruct terminatesacontractandtransfersitsbalancetoagivenaddress.
finally our language extends evm with features that facilitate symbolicevaluation including symbolicvariables introducedby def sym andsymbolic expressions obtained by operating on symbolic variables whose concrete values will be determined by an off the shelf smt solver .
wedefinetheoperationalsemanticsofeachstatementinfigure3 basedonthestandarddefinedbytheevmyellowpaper .the semantics is lifted to work on symbolic values in the standard way .
the meaning of a statement is given by a state transition rulethatspecifiesthestatement seffectonthe programstate.w e define states and transitions as follows.
definition4.
.
programstate theprogramstate consistsof astacke memory m persistentstorage s globalproperties e.g.
a solidity program require amount vesting.amount amount.sub transfer msg.
sender to vesting.amount uint256 v1 amount uint256 wei v1 uint t1 vesti ng.starttime emit vesttransfer msg.sender to wei t1 b symbolic evaluation assert amount r1 amount sstore vesting.amount amount transfer msg.sender to amount r2 amount r3 amount r4 sload vesting.starttime no op c summary extraction 1sstore vesting.amount s s 2transfer s s s s d summary interpretation if sstore vesting.amount if transfer figure from standard to summary based symbolic evaluation balance address timestamp of a smart contract and the program counter pc.w euseei mi and itodenotevariablesfromthestack memory and storage respectively.
aprogramstatealsoincludesamodelofthegassysteminevm but we omit this part of the semantics to simplify the presentation.
if a state maps a variable to a symbolic expression we call it a symbolic state.
definition4.
.
statetransitionoverstatement s astatetransitiontoverastatement sisdenotedbyajudgmentoftheform turnstilelefts prime v. the meaning of this judgment is the following assumingwesuccessfullyexecute sunderprogramstate itwillresult in valuevand the new state is prime.
example4.
.
figure4ashowsasmartcontractwritteninsolidity.
to analyze this contract solar first translates it to the program in figure 4b using the intermediate language in figure .
the resultingprogramisthenevaluatedsymbolicallyinanenvironment that binds amount to a fresh symbolic number.
for instance after executing line in figure 4b register r1holds a symbolic value represented by .
since solar does not model the event system in solidity we turn the corresponding instructions e.g.
line in figure 4b into no ops.
definition .
.
abstract execution trace an abstract execution trace rcontains a list of events i.e.
statements that are of interest.
each event has an event type representing the type of statement and a list of attributes.
.
smart contract vulnerabilities wenowdescribehowtoexpresssmartcontractvulnerabilitiesin solarandwhatitmeansforavulnerabilitytoappearinaprogram.
figure5showsourquerylanguageoverprogramtraces.aquery consists of three parts.
the usesblock declares typed variables whicharematchedagainstvariablesorstatementsappearinginthe program.
the matches block specifies a sequence of statements that are matched against the program trace.
the whereclause further refines the search criteria by imposing constraints over the matched statements.
queryvariables.
queryvariablesinthe usesblockcorrespond to variables or statements in the program trace.
common variables include statements storage variables arguments etc.
statements.
statements in the query language correspond to eventsintheexecutiontracediscussedinsection4.inparticular an event is of type record whose fields are properties of that event.
table lists the fields of some representative statements appearing in the query.
furthermore a seqstmt such as a bspecifies that the event ahappens before b. finally the exclusion operator i s used to prohibit an event from appearing in the trace.
conditionalclauses.
thecriteriaofaquerycanbefurtherrefined using the conditional clauses in thewhereblock.
in particular a conditionalclauseisabooleanexpressionwhosesub expressions are constants query variables fields of query variables or custom predicate like interfere which we introduce later.
angbracketleftquery angbracketright angbracketleftuses decllist angbracketright angbracketleftmatches seqstmt angbracketright angbracketleftwhere cond angbracketright angbracketleftdecllist angbracketright angbracketlefttypename id id angbracketright angbracketlefttypename angbracketright angbracketleftid angbracketright angbracketleftstmt angbracketright angbracketlefttransfer angbracketright angbracketleftsstore angbracketright angbracketleftjump angbracketright angbracketleftbinaryexp angbracketright angbracketleft stmt angbracketright... angbracketleftseqstmt angbracketright angbracketleftstmt angbracketright angbracketleftstmt stmt angbracketright angbracketleftcond angbracketright angbracketlefte angbracketright angbracketlefte angbracketright ... angbracketlefte angbracketright angbracketleftconst angbracketright angbracketleftvar angbracketright angbracketleftfieldaccess angbracketright interfere?
angbracketlefte angbracketright angbracketlefte angbracketright angbracketleftvar angbracketright angbracketleftlocal angbracketright angbracketleftargument angbracketright angbracketleftfieldaccess angbracketright angbracketleftid.id angbracketright angbracketleftid angbracketright angbracketlefta za z angbracketright figure query language for solar compilationofquery.
solarconvertsqueryintocorrespondingfolformulasthroughasyntax directedtranslation.forqueries thatcontainquantifiers weuseskolemizationtomakethemquantifierfree or reject them if they cannot be skolemized .
the rest of this section introduces a few representative vulnerabilities andshowshowtheyareencodedasformulasinsolar.but first weintroduceanauxiliaryfunction interfere?
whichwillbe used by several vulnerabilities.
definition4.
.
interference asymbolicvariable vinterferes withasymbolicexpression eiftheysatisfythefollowingconstraint v0 v1.e e v0 v1 fields of transfer statement sender sender s address recipient target s address loc program counter of the statement gas gas budget for the transfer amount amount of tokens ret return value of the statement fields of jump statement condvar condition variable of jump statement target target address fields of sstore statement name name of storage variable value new value that is used fields of binary statement lhs variable that is assigned opcode opcode of the binary statement oprand1 the first operand oprand2 the second operand table1 fieldsofcorestatementsappearinginthequerylanguage intuitively changing v svaluewillalsoaffect e soutput whichis denoted as interfere?
ve .
interference precisely captures the data andcontrol dependenciesbetweentwoexpressionsandturns out to be the necessary condition of many exploits.
section describes the batchoverflow vulnerability which enables an attacker to perform a multiplication that overflows and transfers a large amount of tokens on the attacker s behalf.
this vulnerability can be formalized as follows vulnerability .
batchoverflow uses transfer t1 binaryexp e argument a1 a2 matches e t1 where e.opcode interfere ?e.oprand 1t1.amount interfere ?a1t1.recipient interfere ?a2t1.amount thequeryspecifiesthatthevictimprogramcontainsa transfer instructionwhosebeneficiaryandvaluecanbecontrolledbythe attacker.
furthermore the transaction value is also influenced by a variable from an arithmetic operation that overflows.
anunchecked send vulnerability occurs when the programmer fails to check the return values of critical instructions such as delegatecall and call.
if these instructions result in runtime errors the programmer is responsible for manually checking their return values and restoring the program state.
failing to do so can lead to unexpected behavior .
we formalize the absence of this check as follows vulnerability .
unchecked send gasless send uses transfer t jump j matches t j where interfere ?t.ret j.condvar 1145here the return value of a transfer instruction does not interfere withtheconditionalvariablesofany conditionaljump statements.
in other words this return value is not checked.
the reentrancy vulnerability introduced in section occurs when anattacker s call is allowed to repeatedly makenew calls to the same victim contract without updating the victim s balance.
it can be overapproximated as follows vulnerability .
reentrancy uses transfer t1 t2 store s argument a matches t1 s t2 where t1.loc t2.loc t2.gas interfere ?at2.recipient in other words let trace rcontains a sequence instructions that includemultiple transfer statementsthatsharethesameprogram counter if there is no storestatement between the two transfer functions that has the minimum gas i.e.
then there may exist a reentrancy vulnerability.
.
attack synthesis givenavulnerabilityquery weareinterestedinsynthesizinganattackprogramthatcanexploitthisvulnerabilityinavictimcontract.
the basic building blocks of an attack program are called components and each component ccorresponds to a public method providedbythevictimcontract.weuse todenotetheunionof all publicly available methods.
definition .
.
component acomponent cfrom an abi configuration is a pair f where fisc s name and is the type signature of c. example4.
.
considertheabiconfigurationinfigure2.itsfirst element declares a component for the problematic batchtransfer method.
this component takes inputs as an array of address and a bit integer uint256 .
werepresentasetofcandidateattackprogramsasa symbolic program which is a sequence of holesto be filled with components from .thesynthesizerfillstheseholestoobtaina concreteprogram that exploits a given vulnerability.
definition4.
.
symbolicattackprogram givenasetofcomponents f1 1 ... fn n asymbolic attack program s for is a sequence of statement holes of the form choose f1 vecv 1 ... fn vecv n wherefi vecv i stands for the application of the i th component to fresh symbolic values of types specified by i. definition .
.
concrete attack program aconcrete attack programfor a symbolic program sreplaces each hole in swith one of the specified function calls and each symbolic argument to a function call is replaced with a concrete value.
example .
.
here is a symbolic program that captures the attack candidate in fig choose makeflag x1 batchtransfer y1 z1 choose makeflag x2 batchtransfer y2 z2 and here is a concrete attack program for this symbolic attack makeflag true batchtransfer define get summary s match s s figure procedure for summary generation.
thechooseconstructisanotationalshorthandforaconditional statement that guards the specified choices with fresh symbolicbooleans.
for example choose e1 e2 stands for the statement ifb1thene1elsee2 whereb1is afresh symbolicboolean value.
aconcreteattackprogramthereforesubstitutesconcretevaluesfor the implicit chooseguards and the explicit function arguments of a symbolic attack program.
the goal of attack synthesis is to find a concrete program pfor a given symbolic program ssuch that preaches a state satisfying a desired vulnerability query.
definition .
.
problem specification the specification for ourattack synthesis problem is a tuple 0 v s where sis a symbolic attack program for the set of components of a victim contract v. 0istheinitialstateofthesymbolicattackprogram obtained by executing the victim s initialization code.
vis a first order formula over the symbolic program state reachable from 0by the attack program s. definition4.
.
attacksynthesis givenaspecification 0 v s theattacksynthesisproblem istofinda concreteattackprogram pforssuch that 0 and v. in other words executing pfrom the initial state 0results in a program state that satisfies v. summary based symbolic evaluation solving the attack synthesis problem involves searching for a concrete program pin the space of candidate attacks defined by a symbolic program s. solar delegates this search to an off theshelfsmtsolver byusingsymbolicevaluationtoreducetheattack synthesis problem to a satisfiability query.
given a specification 0 v s solar evaluates son the state 0to obtain the state 0 andthenusesthesolvertocheckthesatisfiabilityoftheformula vecv.v 0 where vecvdenotesthesymbolicvariablesin s.a modelofthisformula ifitexists bindseveryvariablein vecvtoaconcretevalue andsorepresentsaconcreteattackprogram pforsthat triggers the vulnerability v. but computing 0is expensive asitreliesonsymbolicevaluation .inparticular evaluatinga choosestatement in sinvolves symbolically evaluating each function call in that statement.
so for a symbolic program of length k everypublicfunctioninthevictimcontractmustbesymbolically executedktimesondifferentsymbolicarguments.aswewillseein section7 thisdirectapproachtoevaluating sdoesnotscaletoreal contracts that contain a large number of complex public functions.
tomitigatethisissue weuseasummary basedsymbolicevaluation that performs symbolic execution of each public method only once.
1146ourapproachisbasedonthefollowinginsight.anattackprogramperformsasequenceoftransactions i.e.
methodinvocations thatmanipulatethevictim spersistentstorageandglobalproperties.
thetransactionsthatcompriseanattackexchangedataandinfluence each other s control flow exclusively through these two parts of the program state.
so if we can faithfully summarize the effects of a public method on the persistent storage and global properties evaluating this summary on the symbolic arguments passed to the method is equivalent to symbolically executing the method itself.
definition5.
.
asummary minoursystemisapair s where srepresents a statement that has a side effect on the persistent state i.e.
storage and global properties of a smart contract and denotes the path condition under which sis executed.
we generate such faithful method summaries in two steps.
first we evaluate the method on a program state sthat maps every state variable i.e.
persistent storage location global property etc.
toafreshsymbolicvariableoftherighttype.thisstepproducesa path condition and symbolic inputs for each instruction thatcapture every possible way to reach and execute the instruction withinthegivenmethod.next weusetheprocedureinfigure6 togeneratethemethodsummary.4givenastorage storeinstructionsstore x y and its path condition we generate a summary sstore statement i.e.
sstore thattakesasinputthenameofthe storage variable i.e.
x and the symbolic expression s held in the register y. similarly given a call gas addr value instruction and path condition we emit its summary call statement i.e.
call thattakesasinputthesymbolicexpressionsoftheinstruction s gasconsumption recipientaddress andamountofcryptocurrency respectively.
all other instructions are omitted from the summary sincetheyhavenoeffectonthepersistentstate.byconstruction oursummarythereforepreciselycapturesallofthemethod seffects on the persistent state and the summaries are polynomially sized as guaranteed by rosette s symbolic evaluator .
example5.
.
recallthatweintroducethefollowingcodesnippet in figure 4b assert amount 2r amount 3sstore vesting.amount amount 4transfer msg.sender to amount 5r amount 6r amount 7r sload vesting.starttime 8no op then using the rule in figure solar generates the following summary sstore vesting.amount s s transfer s s s s in particular our tool summarizes the side effects of the transfer andsstoreinstructionsatlines2and3infigure4b respectively.
the remaining instructions e.g.
statements from line to are omitted from the summary because they have no persistent side effects.
once solar generates the summary for each procedure we still need to adjust the symbolic evaluation engine to take advantage 4we omit the details of other side effecting instructions for simplicity.
define interpret summary s define s substitute s match s figure procedure for summary interpretation define solar v k define program for list apply choose define i pstate get initial state define o pstate interpret program i state define binding solve assert vo pstate evaluate program binding figure solarimplementation in rosette.
ofthesummaries.givenamethodsummaryandaprogramstate we use the procedure in figure to reproduce the effects of executing the method symbolically on as follows.
recall that we generatethesummarybyexecutingthemethodonafullysymbolic state s x1 v1 ... xn vn so every path condition and symbolic expression in the summary is given in terms of the symbolicvariables v1 ... vn.oursummaryinterpretationprocedure works by substituting each viin an instruction s path condition and inputs with its corresponding value in i.e.
.
the resulting instruction summary s is therefore expressed in terms of soapplyingitssideeffects s underthepathcondition is equivalent to executing the instruction sin the original method on the state .
since we interpret every instruction in the summary in thisway thecombinedeffectonthepersistentstateisequivalent to executing the original method symbolically on .
example .
.
figure 4d shows an example for interpreting the summaryinfigure4cbyapplyingtheprocedureinfigure7.specifically given an environment and the transfer summary at line in figure 4c we first generate an ifstatement guarded by the path condition in then in the body of the ifstatement we symbolically evaluate the transfer statement in the environment .
implementation this section discusses the design and implementation of solar as well as two key optimizations that enable our tool to efficiently solve the synthesis attack problem.
.
symbolic computation using rosette solarleveragesrosette tosymbolicallysearchforattackprograms.
rosette is a programming language that provides facilities forsymbolicevaluation.rosetteprogramsuseassertionsandsymbolicvaluestoformulatequeriesaboutprogrambehavior which are then solved with off the shelf smt solvers.
for example the solve expr querysearchesforabindingofsymbolicvariables to concrete values that satisfies the assertions encountered during the symbolic evaluation of the program expression expr.
solar uses the solvequery to search for a concrete attack program.
figure8showstheimplementationofsolarinrosette.thetool takesasinputavulnerabilityspecification v thecomponents ofa 1147victimprogram andabound konthelengthoftheattackprogram.
given these inputs line uses to construct a symbolic attack programoflength k.next lines3runsthevictim sinitialization codetoobtaintheinitialprogramstate i pstate fortheattack.
then line evaluates the symbolic attack programon the initial state to obtain a symbolic output state o pstate .
finally lines usethe solvequerytosearchforaconcreteattackprogramthat satisfies the vulnerability assertion.
the core of our tool is the interpreter for our smart contract language figure which implements the semantics from the evm yellow paper .
we use this interpreter to compute the symbolic summaries of the victim s public methods section and to evaluate symbolic attack programs.
the interpreter itself does not implement symbolic execution instead it uses rosette s symbolicevaluationenginetoexecuteprogramsinourlanguage on symbolic values.
another key component of solar is the translator that converts evmbytecodeintoourlanguage figure3 .thetranslatorleveragesthevandaldecompiler tosoundlyconvertthestack based evm bytecode into itscorresponding three addressformat inour language.
the jump targets are resolved through abstract interpretation .
we use the translator to convert victim contracts to the solar language for attack synthesis.
both the translator and theinterpretersupportalltheinstructionsdefinedintheethereum specification .
.
parallel synthesis using hoisting solarusessummary basedsymbolicevaluationtoefficientlyreduce attack synthesis problems to satisfiability queries.
but the resulting queries can still be too difficult to solve in practice especiallywhenthevictimcontracthasmanypublicmethods.tofurther improve performance solar exploits the structure of symbolic attackprograms definition4.
todecomposethesingle solvequery in figure into multiple smaller queries that can be solved quickly and in parallel without missing any concrete attacks.
the basic idea is as follows.
given a set of ncomponents and a boundkon the length of the attack line creates a symbolic attack program of the following form choose f1 vecv1 1 ... f n vecv1 n ... choose k f1 vecvk 1 ... f n vecvk n thissymbolicattackencodesasetofconcreteattacksthatcanalso beexpressedusing nksymbolicprogramsthatfixthechoiceofthe methodtocallateachline butleavetheargumentssymbolic.so wecanenumeratethese nkprogramsandsolvethevulnerability queryforeach ofthem insteadof solvingthesinglequery atline .
this approach essentially hoiststhe symbolic boolean guards outofthe choosestatementsintheoriginalquery andsolarexploresallpossiblevaluesfortheseguardsexplicitly ratherthanvia smt solving.5as we showin section hoistingthe guards leads to significantly faster synthesis both because it enables parallel solving of the smaller queries and because the smaller queries can be solved quickly.
5for practical efficiency our implementation hoists the guards to generate nk c symbolic programs where cis the number of available cores.
.
practical evm fragment in this section we briefly illustrate how solar handles other challenging features of evm.
loops.similarlytootheranalyzersbasedonsymbolicexecution solar unrolls all potentially unbounded loops ktimes.
we use k as the default bound for unrolling.
sha and storage access.
in the evm bytecode the address of an array or map element is determined by the following function a sha id a n i here sha id a stands for the sha hash of the array s identifier nisthesizeoftheelementsstoredinthearray and iisthe arrayindex.reasoningaboutthisfunctiondirectlyisintractable for solvers.
solar circumvents this problem by leveraging uninterpreted functions to soundly model both the sha hash and the address computation function.
that is two addresses are the same if they share the same array identifier index and element size.
gas consumption.
solar s program state tacks gas usage by accumulatingthecostofinstructionsduringsymbolicevaluation.ifatransactionrunsoutofgasinthemiddleoftheevaluation solar terminates it with an out of gas assertion failure.
evaluation we evaluated solar by conducting a set of experiments that are designed to answer the following questions rq1 effectiveness howdoessolarcompareagainststateof the art analyzers for smart contracts?
rq2 efficiency howmuchdoessummary basedsymbolic evaluation improve the performance of solar?
to answer these questions we perform a systematic evaluation by running solar on the entire set of smart contracts from etherscan .usingasnapshotfromfeb132019 weobtainedatotalof 983smartcontracts duplicatecontractswereremoved withpub liclyavailablesourcecode.solarstartsfromattackprogramsofsizeoneandgraduallyincreasesthesizeuntilfindingtheexploitorrun ningoutoftime.allexperimentsinthissectionareconductedona t3.2xlarge machineonamazonec2withanintelxeonplatinum 8000cpuand32gofmemory runningtheubuntu18.04operating system and using a timeout of minutes for each smart contract.
.
comparison with existing tools to show the advantages of our proposed approach we compare solaragainstthreestate of the artanalyzersforexploitsgener ation mythril and teether based on symbolic execution and contractfuzzer based on dynamic random testing.
comparisonwith mythril.
wefirstcomparewithmythril bygeneratingexploitsforthereentrancyvulnerability.mythril takesasinputasmartcontractandcheckswhetherthereareconcrete traces that match the tool s predefined security properties.
if so thetoolreturnsacounterexampleastheexploit.weevaluate 6since bothsolarandmythrilaregeneral purpose analyzersfor commonvulnerabilities in smart contracts for fair comparison we only enable the relevant queries in the evaluation.
1148fn fp010203040percentage solar mythril figure comparing solaragainstmythril mythril and solar on the etherscan data set and both systems use a timeout of minutes.
summary of results.
for contracts flagged as reentrancy vulnerablitybyatleastonetool wemanuallydeterminetheground truthandsummarizetheresultsinfigure9.thefalsenegative fn andfalse positive fp ratesof solarare7 and3 whilethe fn and fp rates of mythril are and .
performance.
mythriltakesanaverageof23secondstoanalyze a contract while solar takes an average of seconds for this data set.
discussion.
thehighfalsenegativerateinmythriliscausedby lowcoverageonthecorrespondingbenchmarks.inthepresence of large and complex methods mythril fails to generate tracesthat trigger the vulnerability.
moreover mythril does not support cross function re entrancy i.e.
re entrancy attacks that span multiple functions of the victim contract.
we also investigated the cause of false positives reported by solar.
it turns out that the false positives are caused by the imprecisionofourqueries.inparticular weuseaspecificpatternof traces to overapproximate the behavior of the reentrancy attack.
while effective and efficient in practice our query may generate spuriousexploitsthatareinfeasible.tomitigatethislimitation one compelling approach for developing secure smart contracts is toask the developers to provide invariants that the tool can use to rule out infeasible attacks.
comparison with teether.wenextcomparesolaragainst teether the most recent tool using dynamic symbolic executionforgeneratingexploitsthatwouldenabletheattackertocontrolthemoneytransactionsofavictimcontract.inparticular teether looks for so called critical instructions i.e.
call selfdestruct etc.
thatinclude recipients addresses whichcan bemanipulated by the attacker to withdraw tokens from a vulnerable contract.
summary of results.
in total there are contracts that are markedas attack control vulnerabilitybyatleastonetool.while solar covers allexploitsgenerated by teether solar also finds 21extraexploits that cannot be generated by teether.
performance.
teethertakesanaverageof31secondstoanalyze a contract in the etherscan data set while solar takes an average of seconds per contract.vulnerabilitysolar contractfuzzer no.fpfnno.fpfn timestamp gasless send bad random table comparing solaragainstcontractfuzzer discussion.
the missing exploits in teether are caused by low coverageonthecorrespondingbenchmarks.forthe21benchmarks withexploitsthatcannotbegeneratedbyteether 14involveattack programs with four method calls and each of the remaining benchmarks contains over lines of source code with complex controlflow.asaresult teetherfailstoexploresufficientlymany concrete traces to find the exploits even if we increase the timeout from minutes to hour.
comparisonwith contractfuzzer .wefurthercomparedsolaragainstcontractfuzzer arecentsmartcontractanalyzer based on dynamic fuzzing.
contractfuzzer takes as input the abiinterfacesofsmartcontractsand randomly generatesinputs invoking the public methods provided by the abi.
to verify the correctnessoftheexploits contractfuzzerimplementsoracles for different vulnerabilities by instrumenting the ethereum virtual machine evm with extra assertions.
we use the docker image provided by the author of contractfuzzer.theoriginalpaperdoesnotdiscusstheperformance of the tool but from our experience contractfuzzer is slow takingmorethan10minstofuzzasmartcontract.sinceitwould be time consuming to run contractfuzzer on the etherscandata set we evaluate both tools on the benchmarks from the contractfuzzerartifact plusanother67randomsamplesfrom etherscan for which we know the ground truth.
summary of results.
the results of our evaluation are summarized in table .
for the timestamp dependency contractfuzzer flags benchmarks as vulnerable.
however of them are falsealarms and contractfuzzer fails to detect vulnerable benchmarks.ontheotherhand solardetectsmostofthebenchmarks withonlyonefalsenegative whichiscausedbyatimeoutofthe vandal decompiler .
similarly for the gasless send vulnerability benchmarks are flagged by contractfuzzer.
however of them are false positives and6vulnerablebenchmarkscannotbedetectedwithin10 minutes.incontrast solarsuccessfullygeneratesexploitsforall the vulnerable benchmarks.
performance.
on average contractfuzzer takes mins to analyze a smart contract.
solar takes an average of seconds on this data set.
discussion.
the cause of false negatives in contractfuzzer is easy to understand as it is based on random rather than exhaustive exploration of an extremely large search space.
so if there are relativelyfewinputsinthisspacethatleadtoanattack contract fuzzerisunlikelytofindoneinreasonabletime.thefalsepositivesincontractfuzzerarecausedbythelimitedexpressivenessofits assertion language.for instance the time dependencyis defined 1149s means diamondmath mean of benchmarks timeout s s diamondmaths s diamondmaths diamondmath s 8s 35s table comparison between summary based s and nonsummary s diamondmath .s s diamondmath s s diamondmath ands diamondmath s representnumber ofbenchmarkstimeoutonboth s only and s diamondmathonly respectively.
as the following assertion in contractfuzzer timestampop sendcall ethertransfer the assertion raises a time dependency vulnerability if the smart contractcontainsthe timestamp andcallinstructions.itiseasy toraisefalsealarmswiththisassertionifthe callinstructiondoes not depend on timestamp.
result forrq1 solaroutperformsthreestate of the art analyzers in terms of running time false positives and false negatives.
.
impact of summary based symbolic evaluation to understand the impact of our summary based symbolic evaluationdescribedinsection5 weusethereentrancyvulnerabilityas the client and run solar on the etherscan data set with s and without s diamondmath computing the summary.
to speedup the evaluation for both settings we enable the parallel synthesis optimizations discussed in section .
figure shows the results of running solar with different settingsandatimelimitof10minutes.eachdotinthefigurerepresents the pairwise running time of a specific benchmark under different settings a dot near thediagonal indicates that the performance of two settings is similar.
our summary based symbolic evaluation significantlyoutperformsthebaseline i.e.
non summary inthe vast majority of benchmarks.
as shown in table if we exclude thebenchmarksthattimeoutin10minutes themeantimeofour summary basedsymbolicevaluationisonly8seconds whileittakes seconds without computing the summary.
furthermore benchmarkstimeoutforbothsettings andonly548benchmarks timeouton s butnoton s diamondmath.however withoutcomputingthesummary i.e.
.
benchmarks time out.
the result confirms thatthesummary basedtechniqueiskeytotheefficiencyofsolar.
result for rq2 our summary based technique is key to the efficiency of solar.
related work smartcontractsecurityhasbeenextensivelystudiedinrecentyears.
this section briefly discusses prior closely related work.
smart contract analysis.
many popular security analyzers for smart contracts are based on symbolic execution .
well known tools include oyente mythril and manticore .
their key idea is to find an execution path that satisfies a given property or assertion.
while solar also uses symbolic evaluation to search figure comparison of run times in seconds between non summary x axis and summary based y axis log scale .
for attack programs our system differs from these tools in two ways.first thepriortoolsadoptsymbolicexecutionfor bugfinding.
ourtoolcanbeusednotonlyforbugfindingbutalsofor exploit generation.
second while symbolic execution is a powerful andprecise technique for finding security vulnerabilities it does not guaranteetoexploreallpossiblepaths whichleadstofalsenegativeratesasshowninsection7.
.incontrast solaranalyzesall bounded pathsthroughacontractusingsummary basedsymbolic evaluation whichsignificantlyreducesthenumberofpathsthat theunderlyingrosetteenginehastoexecutesymbolicallywhile maintaining the same precision.
toaddressthescalabilityandpathexplosionproblemsinsymbolic execution researchers developed sound and scalable static analyzers .
both securify and madmax a r e basedonabstractinterpretation whichsoundlyoverapproximates and merges execution paths to avoid path explosion.
the zeus systemtakes thesource codeof asmart contractand a policyasinputs andthencompilesthemintollvmirsthatwill becheckedbyanoff the shelfverifier .theecf system is designed to detect the dao vulnerability.
similar to our tool securifyalsoprovidesaquerylanguagetospecifythepatternsof commonvulnerabilities.unlikeourtool noneofthesesystemscan generate exploits.
we could not directly compare solar with zeus asthetoolandbenchmarksarenotpubliclyavailable.however we note that our system is complementary to existing static analyzers such as securify in particular we can use securify to filter outsafe smart contracts and leverage solar to generate exploits for vulnerable ones.
somesystems forreasoningaboutsmartcontracts relyonformalverification.thesesystemsprovesecurityproperties ofsmartcontractsusingexistinginteractivetheoremprovers .
theytypicallyofferstrongguaranteesthatarecrucialtosmartcontracts.
however unlike our system all of them require significant 1150manual effort to encode the security properties and the semantics of smart contracts.
automatic exploitation.
our work is also closely related to automatic exploitation .
while prior systems rely on constraint solvers to generate counterexamples as potential ex ploits we note that there are additional challenges in automatic exploitationfor smartcontracts.first theexploitsin classicalvulnerabilities e.g.
buffer overflows sql injections are typically programinputsofaspecificdatatype e.g.
integer string whereastheexploitsinoursettingareadversarialsmartcontractsthatfaithfully model the execution environment storage gas etc.
of the evm.
second keccak hashis ubiquitousin smartcontract for accessingaddressesinmemoryorstorage.asshowninsection7.
basicsymbolicexecutionwillfailtoresolvethekeccak 256hash re sultinginpoorcoverage.toaddressthisproblem theteether system proposed a novel algorithm to infer the memory addresses encoded as keccak hash.
unlike teether our system directly synthesizes function calls that manipulate the memory and storage thus avoids expensive computation to resolve the hash values.
our evaluation in section .
shows that solar outperforms the teether tool in terms of both running time and false negatives.
similartosolar contractfuzzer alsogeneratesexploitsfor a limited class of vulnerabilities based on the abi specificationsofsmartcontracts.however asshowninsection7.
sincecontractfuzzerisbasedonrandominputgeneration itisanorderof magnitudeslowerthansolar resultinginmanymissedexploits compared to solar.
its assertion language is also less expressive than ours leading to false positives that solar avoids.
symbolic evaluation.
solar builds on the rosette symbolicevaluationenginewithanewsummary basedtechniquefor scaling symbolic evaluation to large programs in the domain ofsmart contracts.
as shown in section .
this technique is criti cal for performance.
the idea of computing summaries to speed up symbolic evaluation has also been explored in the context ofsymbolic execution see for a survey leading to three main approaches .
two of these approaches computesummariespath by path soafullsummarythatencodesall bounded paths through a program would be in the worst case exponential in program size.
prior tools therefore avoid comput ingfullsummaries insteadsummarizingasubsetofallpathsforthe purpose of test generation.
solar in contrast summarizesall bounded paths through a procedure and produces compact polynomially sized summaries by employing a symbolic evaluator that combines symbolic execution and bounded model checking.
another summarization approach uses a caching schemethatletstheunderlyingsymbolicexecutionengineterminate the exploration of a path as soon as it reaches a previouslyseen state.
the scheme does not compute explicit summaries of code instead it only stores enough information to soundly decide whenthesymbolicexecutionofapathreachesapreviouslyseen state.
in contrast our approach computes an explicit and precise summary of a procedure s semantics.
programsynthesis.
solarusessyntax guidedsynthesis to search for attack programs.
synthesizers of this kind see for a survey rely on either enumerative search which can be stochasticorexhaustive orsymbolicreasoningoracombinationofthetwo.
solar combines exhaustive enumeration with symbolic synthesis section6.
andextendsthiswithaparallelsymbolicevaluation technique section6.
forfastenumeration.bothoptimizationsare specializedtothedomainofsmartcontracts andtheyarecritical for performance disabling them renders the system unusable.
conclusion thispaperpresentedsolar atoolforautomaticsynthesisofadversarial contracts that exploit vulnerabilities in a victim smart contract.
to make synthesis tractable solar introduces summarybasedsymbolicevaluation whichenablesourtooltoperformprecise all paths analysis of large real world contracts while significantly reducing the number of paths that need to be executed symbolically.solaralsointroducesoptimizationstopartitionthesynthesis search space for parallel exploration.
evaluating solar on the entireetherscandataset wefindthatitsignificantlyoutperforms state of the art analyzers in terms of precision and execution time.