data oriented differential testing of object relational mapping systems thodoris sotiropoulos athens university of economics and business athens greece theosotr aueb.grstefanos chaliasos athens university of economics and business athens greece schaliasos aueb.grvaggelis atlidakis columbia university new york usa vatlidak cs.columbia.edu dimitris mitropoulos athens university of economics and business national infrastructures for research and technology grnet athens greeece dimitro aueb.grdiomidis spinellis athens university of economics and business athens greece dds aueb.gr abstract we introduce what is to the best of our knowledge the first approach for systematically testing object relational mapping orm systems.
our approach leverages differential testing to establish a test oracle for orm specific bugs.
specifically we first generate random relational database schemas set up the respective databases and then we query these databases using the apis of the orm systems under test.
to tackle the challenge that orms lack a common input language we generate queries written in an abstract query language.
these abstract queries are translated into concrete executable orm queries which are ultimately used to differentially test the correctness of target implementations.
the effectiveness of our method heavily relies on the data inserted to the underlying databases.
therefore we employ a solver based approach for producing targeted database records with respect to the constraints of the generated queries.
we implement our approach as a tool called cynthia which found bugs in five popular orm systems.
the vast majority of these bugs are confirmed more than half were fixed and three were marked as release blockers by the corresponding developers.
index terms object relational mapping differential testing automated testing i. i ntroduction object relational mapping orm is an established programming technique that has emerged as a solution to the object relational impedance mismatch problem .
orm provides an object oriented interface atop relational databases.
through that the objects of a program can be easily saved and retrieved from the secondary storage without requiring boilerplate code for mapping application data to database records.
orm not only boosts developer productivity and reduces maintenance costs but also promotes portability because it abstracts away differences of database management systems dbms .
currently there is a plethora of orm implementations through a simple github search one runs into more than orm frameworks written for almost every language.
indicative examples include django and sqlalchemy for python hibernate for java activerecord for ruby and sequelize forjavascript.
these systems are used by millions of applications and are adopted by many popular organizations such as dropbox gitlab and openstack .
despite their wide industrial adoption the automated testing of orm systems is an overlooked problem.
current testing efforts mainly use manually written test suites which as we demonstrate are often insufficient for ensuring the correctness of orm implementations.
yet orm implementations are complex typically consist of thousands lines of code and unfortunately involve a high density of bugs.
for example the orm implementation in the django web framework is the component that suffers from the most bugs of the reported bugs in django are related to the orm component and they are significantly more than the reported bugs associated with the secondly affected component .
such orm bugs lead to incorrect interactions with the underlying database and cause frustrating crashes wrong store and retrieval of data and even security vulnerabilities .
to detect bugs in orm implementations we propose a differential testing approach.
at a high level our approach exercises orm systems by constructing equivalent queries written in the target orm implementations and then compares query results for mismatches.
we begin by generating a random database schema used to set up databases across multiple dbmss.
we test the functionality of orms by querying the databases using each orm s api.
however since orm systems do not share a common input format we design an abstract query language which is close to orm apis.
this allows us to build expressive queries that exercise diverse functionality combinations across orm implementations.
finally we use orm specific translators to convert abstract queries into concrete ones which are executable in the corresponding orm implementations.
our differential testing approach is data oriented beyond queries it is the data inserted to the underlying databases that affect the effectiveness of the testing efforts.
we em15352021 ieee acm 43rd international conference on software engineering icse .
ieee 1from django.db import models 2class person models.model age models.integerfield name models.charfield max length ... 6p1 person age name john 7p1.save 8p2 person.objects.get age 9p2.delete fig.
example crud operations using the django orm.
ploy a solver based approach for generating targeted database records with respect to the constraints of the generated abstract queries.
this improves the effectiveness of differential testing because it minimizes the number of queries where orms return empty results.
our approach goes beyond the existing body of work in compiler and programming language testing and addresses several challenges specific to orm systems such as lack of a common input data generation database schema generation or dbms setup.
specifically we make the following contributions we introduce the first automatic data oriented differential testing approach for orm system implementations.
we implement cynthia an extensible open source framework for systematically testing well established orm implementations.
we provide experimental evidence showing that our solverbased approach is an effective technique to generate data that are useful for differential testing.
we use cynthia to test five popular orm systems on four widely used database engines and find 28unique bugs.
the vast majority of these bugs are confirmed more than half were fixed and three were marked as release blockers by the corresponding developers.
availability.
our system cynthia is available as opensource software under the gnu general public license v3.
at the research artifact is available at ii.
b ackground m otivation we provide a brief overview of object relational mapping and an illustrative example of bugs that our approach can detect in the related tools and frameworks.
then we briefly explain why we adopt differential testing for detecting these bugs.
finally we enumerate the main challenges associated with differential testing of object relational mapping systems.
a. object relational mapping systems object relational mapping provides an abstraction over relational data that enables programmers to interact with their databases through the object oriented programming paradigm.
in this context a database schema tables and their interrelationships is abstracted through classes called models and the associated database records are represented via objects of these classes.
orm systems then provide a rich api for basic create read update and delete crud operations on database records as well as more advanced features such as transaction management or query caching.1q1 t1.objects.using mysql 2q2 t2.objects.using mysql 3q3 t3.objects.using mysql programmingerror you have an error in your sql syntax 5q1.union q2 .union q3 generated sql select t1 .
id from t1 8union select t2 .
id from t2 union select t3 .
id from t3 fig.
django generates mysql query with invalid syntax.
figure shows an example of database interactions using the django orm system .
the code first declares a class that maps to a table and to its associated columns in the underlying database lines .
using this class the code then runs simple queries.
specifically the code creates a class object line and based on this object creates a new database record by calling the save method line .
then the code fetches a single record from the database matching certain criteria line and then deletes this record line .
orm system apis provide a higher level of abstraction that hides the mechanics of sql queries from the programmer.
for example the save method results in an sql insert statement which remains transparent to the programmer.
b. bugs in object relational mapping systems to motivate the design of our testing approach we discuss two indicative bugs found in well established orm systems.
bug in django.
consider the django query shown in figure lines .
this query first fetches the records of tables t1 t2 and t3 lines and it then performs a chain of unions line in order to combine the results of the individual queries.
when we run this django code on mysql version .
.
django produces and runs the sql query shown on lines .
this sql query is invalid on mysql and the django program crashes with adjango.db.utils.programmingerror error in sql syntax check the manual that corresponds to your mysql server version for the right syntax to use near union .
this bug was detected by our approach and was confirmed by the django developers.
when the django code shown in figure is run on another dbms such as sqlite or postgresql django produces a valid sql query.
such inconsistencies indicate that orm bugs may appear or not depending on the underlying dbms.
although dbmss share common functionality they differ significantly from each other .
therefore an orm needs to abstract away such differences and take care of running the same orm code on different dbmss reliably.
unfortunately this complicates the design of orms bugs may occur when an orm fails to produce a valid sql query with respect to a certain dbms.
bug in peewee.
figure shows another orm bug detected by our approach.
on lines the code creates a simple query using the peewee orm.
the query defines a simple 15361expr t.col 2squared expr expr 3t.select fn.sum expr fn.avg squared .all generated sql 5select sum t .
col avg t .
col t .
col 7from t as t fig.
logic error detected in peewee orm.
expression expr given by the addition of a table s column with line .
the code then forms a simple query that applies the function sum toexpr and avg to the square of expr lines .
the peewee orm translates this high level query into the incorrect sql query shown on lines .
in this sql query the expression passed to the aggregate function avg is not in the expected format because the sub expressions are not wrapped in parentheses peewee incorrectly produces avg col col instead of avg col col .
this bug was confirmed and fixed by the peewee developers immediately after our report.
unlike the django bug discussed earlier this peewee bug is more subtle although peewee generates a grammatically and semantically valid sql query this query produces incorrect results.
unlike crashes such subtle bugs cannot be detected through a naive fuzzing approach.
this explains our primary design choice to adopt differential testing.
c. differential testing of orm systems to find bugs similar to the ones discussed above we need to systematically determine whether the sql query generated by an orm system is correct or not.
to do so we need to define a test oracle.
nevertheless establishing a test oracle for orm specific bugs is not straightforward.
for example we are unable to decide whether the sql query generated by django figure is incorrect unless we have domain knowledge that nested unions are indeed supported by mysql and therefore it is a bug from django which failed to produce a grammatically correct sql query involving nested unions.
worse there is no an easy way to tell that the peewee bug of figure is buggy.
although this query runs successfully on all dbmss we cannot be sure that this query indeed fetches the expected results from the database.
to address the test oracle problem we employ differential testing a generally applicable method for testing equivalent implementations.
differential testing provides us with an oracle as follows.
we feed the same test input e.g.
query to two equivalent implementations e.g.
django and peewee and then compare their results.
a mismatch found in the results of the implementations under test indicates a potential bug in at least one of them.
for example through differential testing we run the query associated with nested unions figure on mysql this time using the api of peewee.
peewee executes the given query on mysql without errors.
this helps us to identify that there is a bug in django implementation.
similarly for the peewee query shown in figure we construct its counterpart written in django only to see that django and peewee produce different results.d.
challenges our approach is inspired by prior work on compiler and programming language testing a domain where differential testing has been successfully used in the past.
however applying differential testing on orm systems is not straightforward and it involves several new challenges.
challenge lack of a common specification and input language.
orm systems do not implement a common specification or standard.
therefore differences in orm results may be due to valid but inconsistent implementations and not due to actual bugs.
furthermore each orm offers its own apis and to make matters worse these apis may even be exposed through different programming languages.
as a result differential testing cannot be uniformly applied to test orm systems in a straightforward manner.
challenge non deterministic query results.
in some orm systems it is possible to write a query that leads to an sql statement that produces a non deterministic result i.e.
the result depends on the implementation of the underlying dbms.
an example of such query is when the results are not ordered.
in this case the dbms is free to return results in any order.
another example is when the resulting sql query has a columnaand an aggregate function in the select part but the query does not define a group by clause on the columna.
according to the sql standard selecting a column and an aggregate function without specifying a group by clause leads to an ambiguous query whose results are not deterministic.
to compare the results of the orm systems under test in a meaningful way we have to deal with this non determinism.
challenge dbms dependent results.
as shown previously figure there are orm bugs that are dbms specific i.e.
the bugs are triggered only when the orm code works on a certain dbms.
to effectively capture such bugs we need to differentially test the orm systems on multiple dbmss.
at the same time though differences between the underlying dbmss e.g.
two dbmss may have different semantics on arithmetic expressions must not affect the comparisons of orms.
finally for performing safe comparisons the orm code needs to run on a common reference i.e.
the orm queries need to run on the same database.
challenge data generation.
beyond orm queries we have to generate appropriate data to populate the databases so that orm systems produce non trivial results in response to given queries.
in this way we can reveal logic errors that cause orms to fetch the wrong data from the database.
for example it is impossible to detect the peewee bug of figure when the underlying database contains no records.
iii.
t esting approach our approach for testing orms is automated as shown in figure .
it takes as input the orm systems to test and the dbmss where the orm queries will run.
schema generation is an initial phase where we generate a number of relational database schemas.
during the setup phase we build 1537iterate per schemaiterate per abstract query bug detection setupschema generationschema1build database2generate orm models concretization of abstract queries4dbmodelsdbmodelsgenerate recordstranslate schemanabstract query generationabstract query3orm queryexecutecompare5bugabstract queryn1.
random generation of a specified number of schemas2.
building the databases e.g.
sqlite with an sql script based on scheman .then we generate corresponding models e.g.
django by introspecting the database3.
abstracting sql and orm specific details through our abstract query language aql .
populating the databases via a solver based approach and generating orm queries based on a specific abstract query abstract queryn .
executing orm queries and comparing the results per database to check for potential bugsfig.
overview of our approach for automatically testing orms.
the different databases one for each provided dbms with respect to the schema generated during the first step.
then we proceed to the abstract query generation phase which involves the generation of queries written in the abstract query language aql .
we design this language to abstract ormand sql specific details and provide a common reference for testing orms thus addressing challenge .
by design aql queries never lead to ambiguous orm queries challenge .
however aql queries may be unordered.
in this case we interpret query results as a set of rows rather than a sequence see also section iii d .
in the concretization of abstract query phase we use orm specific translators to translate each query into a concrete one.
to deal with challenge and minimize the number of cases where orms produce empty results we synthesize database records using a solver based approach.
in the last step i.e.
bug detection we execute the orm queries on diverse dbmss and compare their results.
a mismatch in the outputs indicates a potential bug in at least one orm.
notably testing the orm code across different dbmss enables us to find dbms dependent bugs challenge .
a. schema generation setup we generate a number of schemas that capture the structure of the databases on which each orm under test operates.
each schemasis a collection of tables and their associated columns.
each column has a type that can be a serial primary key of the table a number i.e.
integer orreal a string or foreignt which indicates a table s relationship with another table tof the schema.
we omit schema details such as indexes views or column constraints e.g.
unique as these constructs do not affect the querying and translation mechanisms of orms and therefore are beyond the scope of this paper.
our method randomly generates a user defined number of schemas.
for each table the schema generation algorithm creates a serial column named id that stands for the primary key of the table to guarantee that each record in the table is unique and that there is no ambiguity in the data inserted into the table.
the remaining fields of the table are randomly generated optionally based on a deterministic procedure .
we use the schemas generated in the previous step to set up and instantiate the respective dbmss and orms.
to set up dbmss we automatically construct an sql script containing allcreate table statements for creating the tables defined in a provided schema along with their columns.
then weq2query evalqsjqs jqs jfoldf l e gqs qs2queryset newtjapply qsjqs qs jqs qs 2func filterpjmapdjunique jsort asc jsort desc d2fielddecl l ejhiddenl ejd d p2pred ejp pjp pj p e2expr cj j eje eje eje eje e 2field t cjlj c 2aggrfunc countjsumjavgjmaxjmin binaryop j j j j jcontainsjstartswithjendswith fig.
the syntax of the abstract query language aql .
automatically generate the models for each orm under test by examining the structure of the newly created databases.
to this end we leverage tools used to ease orm porting to existing databases.
these tools make a connection to an existing database introspect its structure and automatically construct the respective orm model classes.
an example of such tool is the command manage.py inspectdb found in the django project .
b. abstract query generation following the schema generation setup phases we start a testing session for each individual schema.
a testing session involves the generation of multiple valid queries with respect to the provided schema that are likely to reveal bugs in the orms under test.
these queries are represented in theabstract query language aql which is close to the apis and the functionality of orms and provides a wide range of operations through a functional notation that are commonly supported by the querying mechanism of orms.
aql operations include filtering sorting aggregate functions creation of compound expressions field aliasing or union and intersection of queries.
by contrast raw sql dialect is too low level and many orms are not aware of sql constructs.
also the sql language is not rich enough to express and capture the different api calls of orms.
for example the same sql query can be produced by calling different combinations of orm s api methods.
since our focus is on detecting bugs in orms by exercising different combinations of their api calls we design aql.
abstract query language figure shows the syntax of aql.
a query in aql is the evaluation of a query set evalqs .
15381apply filter addcol apply map addcol t1.cola t1.t2.colb new t1 5select t2.cola t2.colb as addcol 6from t1 as t1 7join t2as t2 on t1.t2 id t2.id 8where t2.cola t2.colb fig.
example aql query and its equivalent sql query.
conceptually a query set evaluates to a set or to a sequence of records in case the query set is ordered .
operations such as indexing or slicing can be applied to the result of a query set while aql also supports folding.
the function foldaggregates the result of a query set into labeled scalar values by applying one or more aggregate functions.
the simplest form of a query set is newt which creates a new query set from the specified table t. when this query is evaluated it returns all records of the table t. then various operations can be applied to a query set through the apply construct.
in particular aql provides the filterpfunction that returns all records of the query set that satisfy the given predicatep.
the map function is used to create new compound fields using existing fields found in the given query set.
specifically map expects a sequence of field declarations of the forml e. this declaration creates a new field in the current query set by binding the expression eto the label l. optionally a field can be marked as hidden meaning that it is not part of the query set but it is used for creating other fields hidden fields are similar to temporary variables .
the function sort sorts the provided query set according to the field in an ascending or a descending order while theunique primitive removes duplicate records with respect to the provided field .
finally aql supports the combination of two query sets through the union and intersection operations.
a predicate consists of comparison operators i.e.
e which are used to compare the value of a field with the result of an expression e. a predicate may also contain the usual logical operators.
an expression can be a constant c a field reference an application of an aggregate function or an expression derived from the usual arithmetic operators.
finally a field 2field may be a reference to a column of a table i.e.
t c a labellcreated by the map function or a reference to a column of a table s relationship e.g.
t1 t2 c .
figure shows an example query written in aql and its equivalent query written in sql.
in this aql query we apply two functions.
first we apply map to the query set given bynew t1 lines in order to create a new field named addcol given by the addition between the t1.cola and t1.t2.colb columns.
notice that since the latter column refers to a column of the table t2 which has a relationship with the original table t1 in sql this is interpreted as a join between t1andt2 line .
finally we apply filter to get the records satisfying addcol line .
remark.
aql currently supports only read operations.
the implementations of orm api methods associated with read operations are much more complex than those related to writealgorithm generating abstract queries 1fungenqueryset min max stopcond min max randbool ifstopcond then else match choosefrom with case newnode t choosetable genqueryset min max case filternode p genpred min max genqueryset min max case ... 16fungenpred min max match choosefrom with case eqprednode 19f choossefield eq f genexpr min max case ... 23fungenexpr min max match choosefrom exprnodes with case fieldrefnode field choosefield case ... operations a write operation is straightforwardly translated intoinsert delete orupdate queries .
thus examining read operations for finding bugs is more promising.
note though that aql can be easily extended for supporting write queries.
also supporting write operations would not require to take into account schema properties that we are currently ignoring e.g.
column constraints because such properties affect the configuration of orm models and not the way an orm translates a write query into an sql statement.
generating aql queries algorithm shows how we generate random aql queries.
our algorithm generates queries that exercise all of the features supported by aql as well as different combinations of them.
the main component of algorithm is the genqueryset function lines .
this function generates an aql query set by recursively constructing a valid ast node based on the syntax of figure .
the algorithm ensures that the depth of the resulting query set ranges within specific limits specified by the user provided parameters minandmax see stopcond line .
the parameter keeps track of the state of the query set that is being generated.
the initial state contains the schema based on which the algorithm creates table and column