detecting atomicity violations in interrupt driven programs via interruption points selecting and delayed isr triggering bin yu school of computer science and technology xidian university xi an p.r.
chinacong tian school of computer science and technology xidian university xi an p.r.
chinahengrui xing school of computer science and technology xidian university xi an p.r.
china zuchao yang school of computer science and technology xidian university xi an p.r.
chinajie su school of computer science and technology xidian university xi an p.r.
chinaxu lu school of computer science and technology xidian university xi an p.r.
china jiyu yang school of computer science and technology xidian university xi an p.r.
chinaliang zhao school of computer science and technology xidian university xi an p.r.
chinaxiaofeng li beijing institute of control engineering beijing p.r.
china zhenhua duan school of computer science and technology xidian university xi an p.r.
china abstract interrupt driven programs have been widely used in safety critical areas such as aerospace and embedded systems.
however uncertain interleaving execution of interrupt service routines isrs usually causes concurrency bugs.
specifically when one or more isrs attempt to preempt a sequence of instructions which are expected to be atomic a kind of concurrency bugs namely atomicity violation may occur and it is challenging to find this kind of bugs precisely and efficiently.
in this paper we propose a static approach for detecting atomicity violations in interrupt driven programs.
first the program model is constructed with interruption points being selected to determine the possibly influenced isrs.
after that reachability computation is conducted to build up a whole abstract reachability tree and a delayed isr triggering strategy is employed to reduce the state space.
meanwhile unserializable interleaving patterns are recognized to achieve the goal of atomicity violation detection.
the approach has been implemented as a configurable tool namely cpa4av.
extensive experiments show that cpa4av is much more precise than the relative tools available with little extra time overhead.
in addition more complex situations can be dealt with cpa4av.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
concepts theory of computation verification by model checking .
keywords interrupt driven programs interrupt service routines atomicity violation static analysis concurrency bugs acm reference format bin yu cong tian hengrui xing zuchao yang jie su xu lu jiyu yang liang zhao xiaofeng li and zhenhua duan.
.
detecting atomicity violations in interrupt driven programs via interruption points selecting and delayed isr triggering.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
introduction interrupt driven programs are usually programmed with interrupt service routines isrs to interact with hardware and respond to external stimuli in a timely manner .
this kind of software is widely used in safety critical areas such as automotive electronics and aerospace .
nevertheless since isrs can preempt normal executions at any time non deterministically it is quite difficult for software developers to understand interrupt driven programs completely .
uncertain interleaving execution of isrs is regarded as a kind of concurrency bugs possibly leading to serious safety problems such as logic defects or even system crash.
although interrupt driven programs are usually tested before application isr related concurrency bugs are still one of the most challenging software vulnerabilities since they are quite sensitive to execution interleavings .
esec fse december san francisco ca usa yu tian xing yang su lu yang zhao li duan as a kind of hazardous concurrency bugs in interrupt driven programs atomicity violations occur if one or more isrs attempt to preempt a sequence of instructions which are ideally expected to be atomic .
as a matter of fact in an interrupt driven program a sequence of instructions which is atomic could be broken by an isr with higher priority.
for instance for an atomic sequence with two consecutive read accesses to a same variable in the main task or an isr either a main task or an isr is regarded as a task the variable could be written by another isr with higher priority between the two read accesses.
that is the atomic assumption of this sequence is broken which leads to a concurrency bug namely atomicity violation .
although several approaches have been proposed to detect atomicity violations in multi threaded programs they cannot be directly applied to interrupt driven programs due to the different synchronization mechanisms and preemption relationships .
currently state of the art approaches for detecting atomicity violations in interrupt driven programs include bounded model checking and staged static analysis.
as a representative of bounded model checking rchecker constructs local controlflow graphs of programs to perform flow sensitive analysis on top of the model checker cbmc to detect potential atomicity violations.
whereas false positives are inevitable due to the nature of path constraint solving in bounded model checking.
besides since no effective strategy is considered to reduce the explored state space during the detection it is challenging in scalability to deal with realworld interrupt driven programs.
in order to avoid the explicit state exploration a static analysis approach is proposed in intatom which employs a staged design for atomicity violation detection by first identifying all potential violations and then filtering out infeasible candidates.
however precise reachability analysis is still lacking for complicated situations caused by uncertain interleaving execution of the main task and isrs with different priorities.
in this paper we propose a static approach to precisely detect atomicity violations in interrupt driven c programs.
in our approach control flow graphs cfgs of the main task and isrs are constructed.
on this basis the program locations which may be influenced by an isr are selected as interruption points for triggering isrs.
further by unwinding the obtained cfgs and performing reachability computation a whole abstract reachability tree art is built up with the infeasible paths being pruned automatically.
throughout this process when an interruption point is reached the control flows of the enabled isrs are not introduced at once as in the model checking approaches available .
instead a delayed preemption strategy is proposed to allow an enabled isr to preempt as late as possible so that the size of the constructed art is reduced.
besides the initial and final locations of a task are also allowed to be preempted.
this is to take into account mutual influence of different tasks and potential atomicity violations occurring in two nested isrs which are not considered in the existing static analysis approaches .
to achieve the above goal when exploring an art a data access table is maintained dynamically to record the operation states of shared variables.
meanwhile specific access sequences are recognized to match the patterns of atomicity violations on the fly.
we have implemented the approach as a tool named cpa4av configurable program analysis for atomicity violation uponthe open source model checker cpachecker .
experimental experiments on benchmark racebench .
show that cpa4av is much more precise than the relative tools available with little extra time overhead.
further experiments on the extended version of racebench .
show that cpa4av can deal with more complex situations.
in addition experiments on the three packages in the concurrency track of sv comp benchmark suite indicate that the proposed interruption points selecting and delayed isr triggering strategies can reduce the explored state space and detection time by .
and .
respectively.
finally the empirical evaluation on real world embedded programs shows the scalability of cpa4av.
the main contributions of the paper are summarized as follows a model checking approach based on interruption points selecting and delayed isr triggering strategies is proposed to detect atomicity violations in interrupt driven programs precisely and efficiently.
an atomicity violation detection tool namely cpa4av is developed for interrupt driven c programs.
extensive experiments show that cpa4av is much more precise than the relative tools available with little extra time overhead.
in addition more complex situations can be dealt with cpa4av.
the remainder of the paper is organized as follows.
section gives the preliminaries and section presents a motivating example.
the proposed detecting approach is described in section and configurable strategies to increase the precision are addressed in section .
section presents the implementation and evaluation.
section discusses the soundness completeness and limitations of our approach and section reviews the related work.
finally the conclusion is drawn in section with a discussion of future work.
preliminaries this section briefly presents the preliminaries and useful notations involved in this paper.
.
interrupt driven programs as an essential design primitive for embedded softwares which interact closely with hardware interrupts are common in most computing platforms such as low power mobile systems and safetycritical embedded softwares.
the interrupt mechanism enables these platforms to timely respond to outside stimuli in a powerefficient way .
a program is regarded as interrupt driven if most of the key functions are initiated or processed through interrupts.
an interrupt driven program can be formally defined with a main task and a finite number of isrs that communicate by performing operations on shared variables p main isr.
here main is the main task and isr isr1 ... isrnrepresents the isrs.
for simplicity we call main and all the isrs in a program pas tasks denoted by task p main isr1 ... isrn .
note that the subscript ofisriindicates the priority number with a larger priority number indicating a higher priority.
for convenience we use the function pri to return the priority number.
note that pri main is defined to be zero i.e.
the lowest priority .
in the aspect of the preemption relationship isrs are allowed to preempt the main task and one isr with higher priority is able to preempt another isr with lower priority but not vice versa.
1154detecting atomicity violations in interrupt driven programs via interruption ... esec fse december san francisco ca usa that is the preemption relationship between isrs is asymmetric in interrupt driven programs.
it should also be noted that different from the execution of a thread in multi threaded programs an isr cannot be blocked once it begins to execute in interrupt driven programs.
besides an isr with lower priority will be suspended until the isrs with higher priority are completed which is considered as interrupt nesting.
.
atomicity violation in interrupt driven programs programmers often assume that some statements are atomic during the design process .
however in the actual execution environment this assumption cannot be guaranteed if these statements are interrupted in an unexpected way resulting in the occurrence of unintended program behaviors.
two local reads expect to get the same valuea local read expects to get the result of a localwritetemporary results between local writes are notaccessed by other interruptsthe local write relies on a value from thepreceding local readpattern r w r pattern w w r pattern r w w pattern w r w the interleaving writemakes the two readshave different valuesthe local read does not get the local result itexpectsthe interrupt write breaks the preconditionof the local writea temporary result which may be incomplete is readby an interruptpattern expectation problem...a1 r x a3 r x a2 w x ...a1 w x a3 r x a2 w x ...a1 r x a3 w x a2 w x ...a1 w x a3 w x a2 r x fig.
figure four unserializable interleaving patterns.
a sequence of statements is referred to as an atomicity if the values of variables in a concurrent execution have no difference from those in a serialized execution.
an atomicity violation is triggered when an unserializable interleaving pattern occurs .
formally an unserializable interleaving pattern is a triple a1 a2 a3 where each ofa1 a2anda3 r w r wdenotes the read write access to a shared variable .
in addition a1anda3are two consecutive accesses in a low priority task pi task p anda2is from an isr pj task p main pi with higher priority i.e.
j i. unserializable interleaving patterns can be summarized into four types as is shown in fig.
pattern r w r two local reads a1anda3expect to get the same value while the write a2makes the two reads have different values.
pattern w w r a3is expected to read the assignment result ofa1.
when the variable is modified by a2 a3reads an unintended value written by a2.
pattern r w w a3is a write access along a branch with a1 being the branch condition.
the write a2may make the precondition of a3unsatisfied.
pattern w r w the result between two writes a1anda3is possibly incomplete and not expected to be accessed while a2 just reads the temporary result.
we refer to the set of these four types of unserializable interleaving patterns as patterns .
inspired by the work of which presents the notion of unit of work atomicity can be confined within the boundary of such units of work.
besides the empirical research carried out in for interrupt driven programs shows that two consecutive accesses to a shared variable expected to be atomic usually occur in a same function.
with this basis the atomicity of a1anda3is confined in the same function in this paper.
.
control flow graph and abstract reachability tree for an interrupt program p main isrwith isr isr1 ... isrn the control flow graph cfg gp lp l0p tp ofpis the union of all the sub cfgs of the tasks in p i.e.
gmain gisr ... gisrn.
note that the sub cfg for each task piis also a triple gpi lpi l0pi tpi withlpidenoting the set of all locations l0pithe initial location and tpithe transitions in pi.
by unwinding a cfg gp an abstract reachability tree art can be obtained for reachability computation.
formally an art ap s e consists of a set sof abstract states and a set eof edges.
each states sis a triples ls cs bs wherels lprepresents the current location csis the call stack that models a sequence of return addresses and bsis a first order formula that confines the reachable region of the program variables.
each edge e eis also a triplee s t s wheresands are abstract states in s and t tpis a transition.
we use tfto represent the encoded formula according to the operation of the transition t. when exploring an art ap the reachability of the successor states of an edgee s t s can be determined according to the reachable region bsof the precursor state s. specifically the successors is unreachable if bs tf i.e.
bsdoes not model tf otherwise s is reachable and the reachable region bs is updated as follows bs bs tf ift l cond l v bs tfift l v exp l here cond represents a conditional branch and v expan assignment operation.
we point out that v bsremoves the variable vfrombs andtfre evaluates v. intuitively for an assignment operation the reachable region bs is obtained by replacing the assignment expression of variable vinbs.
motivating example in this section we use an example program exa.c shown in fig.
to illustrate atomicity violations in interrupt driven programs intuitively.
this example is also used throughout the paper to illustrate our approach.
in this program an atomicity violation is caused by nested isrs.
this program first initializes two shared variables yandzto be .
in the main task the local variables mandnare assigned as .
the isr isr 2is disabled by the main task and enabled by the isr isr 1. the priority of isr 2is higher than that of isr 1 and the main task has the lowest priority.
int y z 0l0 l1 disable isr 2 l2 int p q m r a n d n r a n d l3 l4 m n y l5 l6p m l10 l9q n !
m n y l7 l8s0 s1 s2 s3 s4 s5s9 s10 s11s13s15 isr 1 s8l13 l9s14int y z void main disable isr int p m n if m n y p m if m n y p n void isr 1 y z enable isr void isr 2 if z y z l6s6isr 2 return l6l6 l10 l9q nl7 l8s5s9 s10 s11s13isr 1 l9s14s8l13l6s6isr 2 return l6 m n y !
m n y figure program exa.c one atomicity violation caused by two nested isrs.
considering the statements in lines of the main task their execution will not be impacted by the preemption of isr 1orisr 2 since these statements have no operations on any shared variables.
then the condition statement m n y in line is satisfied.
1155esec fse december san francisco ca usa yu tian xing yang su lu yang zhao li duan source codeart y r w r ... reportcfg pattern dit reachability computing art constructingdelayed isr triggering uipm data access table maintainingdynamic pattern matching atomicity violation detectingips cfg constructing interruption point selectinginterruption points selecting delayed isr trigge ring unserializable interleaving patterns matching figure framework for detecting atomicity violations of interrupt driven programs.
however in the case that an isr changes the value of the variable yand preempts between lines and the conflicting condition m n y in line can also be satisfied.
besides it should be noted thatisr 1in this example does not change the value of y while isr 2does.
therefore only the preemption of isr 2can make the conditions in lines and both satisfied.
since isr 2is disabled in the main task by disable isr in line and only enabled in isr 1 byenable isr in line this example refers to the nested execution of two isrs.
for the shared variable y the consecutive accesses in lines and are considered to be atomic and the values at these two locations are expected to be the same.
however when the main task is preempted by isr 1and the latter is further preempted by isr 2 this expectation is violated.
this is an atomicity violation with three accesses to yfitting pattern r w r .
from this example we observe that in order to detect atomicity violations effectively two points should be addressed precise inter procedural analysis.
in each unserializable interleaving pattern the first and last items i.e.
a1anda3 come from a task with lower priority while the middle item i.e.
a2 comes from another task with higher priority.
considering the nondeterministic preemption and asymmetric relationship between different tasks it is necessary to perform precise inter procedural analysis for detecting atomicity violations effectively.
to achieve this a flexible reachability analysis based on model checking is performed in this paper.
effective state space reduction.
although isrs can preempt at any time only the representative interruption points are required to be checked.
thus the selection of representative interruption points can reduce the interaction frequency between different tasks.
further at each selected interruption point it is not necessary to trigger the enabled isrs at once.
instead under the precondition of the same influence these enabled isrs at each selected interruption point should be triggered as late as possible so as to reduce the explored state space during the reachability analysis.
to this end we propose the interruption points selection and delayed preemption strategies in this paper.
atomicity violation detection in this section we propose a framework to statically detect atomicity violations of interrupt driven programs.
as shown in fig.
there are three modules in this framework ips dit and uipm .
in the module ips section .
the sub cfgs of all tasks are constructed to build up the cfg of an interrupt driven program.
these sub cfgs are further utilized to select representative interruptionpoints which are locations possibly influenced by isrs with higher priority.
in the module dit section .
an art is generated by unwinding the cfg obtained in ips.
during the generation when reaching an interruption point the correspondingly enabled isrs are not triggered at once by introducing their control flows.
instead their triggering is postponed as much as possible by the proposed delayed isr triggering strategy.
along with dit the module uipm section .
maintains the data access table at each newly generated state in the art.
on this basis unserializable interleaving patterns are matched on the fly to detect atomicity violations.
.
interruption points selecting for an interrupt driven program p we first construct the sub cfg of each task.
as an example the sub cfgs gmain andgisrofexa.c in fig.
are depicted in fig.
.
different from concurrent programs which introduce control flows of tasks by creating threads explicitly interrupt driven programs do not create isrs.
instead a task is passively interrupted by an isr with higher priority.
thus it is insufficient to just construct the sub cfg of each task since independent sub cfgs cannot reflect the interactions between different tasks.
to solve this we introduce the control flow of each isr at specific program locations i.e.
treat isrs as special function calls .
in this way the triggering of an isr at a location can be simulated.
due to the reason that an isr can be triggered anytime almost all program locations are required to be considered during a naive detection approach.
however this will be prohibitively expensive even for a simple interrupt driven program.
in fact it is unnecessary to consider all the program locations since not all statements would influence or be influenced by other isrs.
for instance the isrs isr 1 andisr 2in fig.
do not have direct relation with the value of the local variable min the statement m line .
that is we do not need to introduce the control flows of isr 1andisr 2when the main task reaches the program location l3in fig.
.
based on the above analysis we observe that the control flows of isrs just need to be introduced at specific program locations which are referred to as interruption points .
definition interruption points .
letgp lp l0p tp be the cfg of an interrupt driven program p main isr1 ... isrn.
according to the operation in a transition t l l tpof a task pi task p the location l is an interruption point if may potentially have an influence on or be influenced by other isr tasks pj task p i j with higher priority.
that is the operation reads from or writes into a shared variable.
to determine whether a location in the cfg of an interruptdriven program pis an interruption point we further define a 1156detecting atomicity violations in interrupt driven programs via interruption ... esec fse december san francisco ca usa int y z 0l0 l1 disable isr 2 l2 int p m 1 n 1 l3 l4 l6 m n y p m p nl7 l9 m n y l5 l8 gmainl14 l15 l17 z 0 y 1 l18z 0l16 isr 2l10 y 0 l11 l12 l13z 1 enable isr 2 isr 1 gisrinterruption point common location figure the sub cfgs of program exa.c in fig.
.
functionm lp 2task p which maps a location l to a set of tasks.
intuitively the returned tasks are the isrs which may be triggered at the location l .
specifically each transition t l l tpiof a taskpi task p is considered to obtain the relevant isrs of all the locations inpi if there exists a task pj task p i j containing one or more shared variables with operation andpri pi pri pj then we includepjinm l .
if enable isr j is an isr enabling operation then we include isrpjwith pri pj jintom l .
as a result a location l lpis an interruption point if m l .
for convenience we call m l therelevant isrs at the interruption point l .
in the sub cfgs shown in fig.
for the example program exa.c we can obtain thatm l3 as the operation int p m n contains no shared variables.
similarly m l4 m l5 isr 1 isr 2 since the operation m n y reads the shared variable ywhich is written byisr 1andisr 2. forisr 1 we havem l11 m l12 isr 2 .
in addition by applying the second rule above we have m l13 isr 2 .
moreover there are no interruption points for isr 2since it has the highest priority in this program.
compared with the naive approach that requires to trigger each isr at almost all program locations we just need to consider program locations to trigger the relevant isrs.
.
delayed isr triggering after the cfg gpis built and interruption points are selected for an interrupt driven program p the possible behaviors of pcan be explored by constructing an art.
throughout this process the control flows of the relevant isrs are required to be introduced in conditionally for each reachable interruption point.
specifically for any state s sin an art in the case that ls is an interruption point the control flow of an isr pi m ls will be introduced in if piis enabled at the current state sand the priority ofpiis higher than that of the task in progress.
we call the statestrwhere the relevant isrs pi m ls are actually triggered when constructing an art the triggering state and assume that the corresponding program location is lstr.
then for each successor transitiont lstr l tpenabled atstr two different direct successor states will be generated s l cs bs meaning that the successor state s does not turn to the control flow of task piafter executing the transition t. s l0pi bstr meaning that the state s turns to the entry of the task pi.
in this transition no actual statement is executed and the reachable region keeps the same as the state str.
the call stack indicates that when pifinishes the controlflow of the whole program will turn back to the original location from which it is introduced in.
intuitively at the state strbefore the operation more than one branch can be explored.
one is the original execution without being preempted by any relevant isr while the others one or more are the executions preempted by different relevant isrs.
when the execution of each relevant isr finishes it turns back to the state strto resume the original execution.
it should be noted that a triggering state strcan be the same as or different from the state swith the interruption point ls.
concretely if the statestris justs it means that relevant isrs are triggered at once for the interruption point ls.
in this case the original and interrupted branches have no shared states from the interruption point.
on the other hand if the state stris different from s these states between sandstrcan be shared by the original and interrupted branches.
therefore without changing the mutual influence between different tasks m ls for the interruption state lsshould be triggered as late as possible i.e.
the triggering state strshould be as deep as possible in the explored art.
to achieve this for different kinds of operations on a shared variable vat a states we dynamically determine the triggering state straccording to the operation which follows s r v at the state s for a task picontaining v if there is a variable v withw v inpiandv also occurs in or disable isr i withpri pi i stris the triggering state wherepiis triggered.
w v at the states for a taskpicontainingv if there is a variable v inpiandv also occurs in or disable isr i withpri pi i stris the triggering state where piis triggered.
enable isr i at the state s if there exists r v or w v after the previous disable isr i refer to or respectively otherwise no relevant isrs will be triggered.
through the above delayed isr triggering strategy another positive effect can be achieved.
for the final interruption location l of a shared variable in one task there is no triggering state strto trigger relevant isrs since no operation exists before the current task finishes.
this is quite reasonable in the atomicity violation detection.
corresponding to the unserializable interleaving patterns shown in fig.
even if a relevant isr is triggered for the final interruption location lof a variable v the missing of a3makes it impossible to form an atomicity violation a1 a2 a3 .
fig.
shows the art of the example program exa.c .
the green nodes represent the interruption points while the yellow ones are the triggering states where relevant isrs are actually triggered.
to save space squares represent isrs with omitting internal states.
note that the control flow of isr 2is not introduced in at the state s5since it has already been disabled by the main task.
at the state s7 isr 2is triggered where one successor s8turns the control flow fromisr 1toisr 2 while the other returns to the main task.
1157esec fse december san francisco ca usa yu tian xing yang su lu yang zhao li duan int y z 0l0 disable isr 2 int p m 1 n 1 l3 l4 m n y m n y l5 !
m n y l6p m l10 l9p n !
m n y l7 l8s0 s3 s4 s6s5 s12 s13s14s16 isr 1 s8l14 l9s15void isr 1 y z enable isr void isr 2 if z y z l6s7isr 2 returnl13 s9l18 l6s10return m n y l6 l10 l9p n !
m n y l7 l8s18s17 s24 s25s26isr 1 s20l14 l9s27l6s19isr 2 returnl13 s21l18 l6s22returns11 s23interruption point isr triggering state isrs omitting internal states no isrs are triggeredno isrs are triggeredno isrs are triggeredno isrs are triggered figure the art for exa.c in fig.
with the interruption points selecting and delayed isr triggering strategies.
in fig.
we can see that although l4andl5are two interrupted points the corresponding triggering states are s5ands17 instead ofs4ands16 respectively.
in this way the transition l4 p m l can be shared by the original and interrupted branches.
besides since no triggering state exists for interruption locations l7andl8 no isr is actually triggered in the corresponding four branches which can greatly reduce the explored state space.
.
unserializable interleaving patterns matching when constructing an art unserializable interleaving patterns are matched at the same time.
to achieve this for each access to a shared variablevon an edge of the art a tuple o v f l a namely operation state is used to record the detailed access information.
here f task p is the task where olocates lis the line number of the corresponding statement and a r w is the access type forv.
we call a triple o1 o2 o3 as acandidate atomicity violation ifo1ando3are two consecutive operation states in a low priority taskpi task p ando2is from an isr pj task p main pi with priority higher than that of pi.
a candidate atomicity violation o1 o2 o3 is regarded as an atomicity violation if the corresponding access triple o1.a o .a o .a matches any unserializable interleaving pattern in patterns in fig.
.
to keep tracking operation states which may comprise a candidate atomicity violation during the art exploration a data access tabledv lov ov is defined as a basic structure to store relevant operation states for each shared variable v. specifically lovis the last operation state of vin a preempted task and ovis the set of partitions of operation states divided by different isrs.
here a partitionopof operation states is defined as op f seq in which f task p main andseqis a sequence of operation states sorted by the order they are obtained in task f .
during the detection lovandovare utilized to track o1ando2 respectively.
further each operation state acquired from the newly generated edge in the art is regarded as o3.
after that it can be determined whether the candidate atomicity violation o1 o2 o3 is an atomicity violation by checking whether o1.a o .a o .a patterns .
the above process is formally presented in algorithm where the newly obtained operation state o3is taken as the input and the set avset acting as the output is used to store all the detected atomicity violations.
when providing o3 the algorithm first acquires the corresponding data access table dvaccording to thealgorithm patternmatching o3 input a newly obtained operation state o3.
output the set avset of atomicity violations.
1begin getdv lov ov for variablevino3 patterns r w r w w r r w w w r w avset iflov null orov then lov o3 return avset end 9o1 lov foreachop ovdo foreacho op.seq do o2 o if o1.a o .a o .a patterns then avset.add o1 o2 o3 end end end 18lov o3 ov return avset 20end name ofvrecorded in o3 line and initializes the sets patterns andavset lines .
next the algorithm checks whether lovis null i.e.
whether there exists an o1that could lead to an atomicity violation.
also it checks whether ovis empty i.e.
whether there is ano2acting as the second item in a candidate atomicity violation to form an atomicity violation.
if lovisnull orovis empty there is no need to perform a further pattern matching.
in this case we updatelovtoo3 and return the set avset lines .
otherwise lovis assigned to o1 line and all the operation states otaken fromop.seq in eachop ovare iterated to act as the middle item o2of a candidate atomicity violation lines .
then with the newly obtained operation state o3 a candidate atomicity violation o1 o2 o3 is formed and whether o1.a o .a o .a patterns is further checked line .
if so an atomicity violation is found and o1 o2 o3 is added into avset line .
otherwise algorithm keeps traversing op.seq andov.
eventually the algorithm returns avset after updating lovandov lines .
for the example program exa.c one feasible path in the generated art in fig.
is shown in fig.
along which pattern matching is performed.
according to the triple o1 o2 o3 y main r y isr 2 w y main r one atomicity violation is detected for the variable y. s s l disable isr 2 int p m n m n y s l z s l s l z 0 y 11isr 2 s l isr 1 s l s l s l y z s s l int y z s l m n y p n s l enable isr 2 s l l l s l p m s l atomicity violation y r w r fig.
figure a feasible path in the generated art of exa.c with one atomicity violation.
1158detecting atomicity violations in interrupt driven programs via interruption ... esec fse december san francisco ca usa configurable strategies to increase precision although the proposed approach discussed in the previous section is able to deal with all the situations considered in the state ofthe art tools intatom and rchecker the cases that relevant isrs are triggered at the initial or final location have not been taken into account yet.
to address them we further put forward initial isr triggering and final isr triggering strategies as configurable options to handle more complex situations.
.
initial isr triggering since interruption points are selected after each operation which is related to shared variables the influence of tasks with higher priority on the task with lower priority at its initial location has not been considered.
thus atomicity violations occurring in the influenced branches will escape from being captured.
for example for the program exa i.c in fig.
which is a slight modification of the motivating example exa.c without the triggering of isr 1 before line the condition m n y in line cannot be satisfied leading to the non execution of the branch in line .
in this case the potential atomicity violation two reads of variable yin lines and are interrupted by the write in line cannot be found.
to solve this problem we propose an initial triggering strategy of relevant isrs.
specifically for each successor transition t lstr l tpenabled at a state str stris regarded as a triggering state according to the operation which follows it a variable voccurs in ifvalso occurs in piwhich has yet not been triggered stris the triggering state where piis triggered.
disable isr i ifpiwithpri pi ihas yet not been triggered stris the triggering state where piis triggered.
int y z void main int p m n if m n y p y void isr 1 y z void isr 2 if z y z 16int y z void main int p m n if m n y z m void isr 2 y z void isr 1 if z y z 6int y z void main int p m n if m n y p y void isr 1 y z void isr 2 if z y z 6initial triggering atomicity violation y r w r final triggering atomicity violation z r w w figure program exa i.c one atomicity violation detected by the initial isr triggering strategy.
with this strategy for program exa i.c shown in fig.
with the initial triggering of isr 1 the assignments of variables yandz make it possible for isr 2to preempt between lines in the main task.
thus an atomicity violation y r w r is detected.
.
final isr triggering with the delayed isr triggering strategy no isr is triggered for the final interruption location of each variable since it is impossible to form an atomicity violation without the existence of a3as shown in fig.
.
however the final operation a3has a possible influence on other tasks which may contain atomicity violations.
for example in program exa f.c shown in fig.
as another slight modification of the motivating example exa.c the shared variable zis assigned as a new value at the last statement of the main task.
coincidentally this new value has a direct impact on the executions of isrs isr 1 andisr 2 making that the write of variable zin line can preempt between lines and .
to handel this problem at the exit state of each task if there still exist un triggered relevant isrs pi m l for some previous interruption point l andpri pi is not the highest the exit state is regarded as the triggering state where piis triggered.
int y z void main int p m n if m n y p y void isr 1 y z void isr 2 if z y z 16int y z void main int p m n if m n y z m void isr 2 y z void isr 1 if z y z 6int y z void main int p m n if m n y p y void isr 1 y z void isr 2 if z y z 6initial triggering atomicity violation y r w r final triggering atomicity violation z r w w figure program exa f.c one atomicity violation detected by the final isr triggering strategy.
through this strategy for the program exa f.c shown in fig.
with the final triggering of isr 1before the main task returns the condition z in line can be satisfied.
thus when isr 2preempts between lines an atomicity violation z r w w is detected.
experiment and evaluation we have implemented the proposed approach as a configurable tool called cpa4av1 configurable program analysis for atomicity violation upon the open source model checker cpachecker which supports reachability computation based on binary decision diagram bdd .
cpachecker provides an efficient configurable analyzing framework for verifying c and java programs without isrs.
cpa4av extends it with additional modules for selecting interruption points triggering enabled isrs and detecting atomicity violations in interrupt driven c programs.
besides the internal library javabdd is invoked to compute the reachable region of each abstract state in an art.
all experiments are performed on a computer running the ubuntu .
lts system with an intel r xeon r e5 cpu and gb ram which is the same with that utilized to evaluate intatom .
our experiments are designed to answer the following research questions rq1 how efficient and precise is cpa4av compared with the state of the art tools such as intatom and rchecker ?
rq2 how much contribution on efficiency is made by the interruption points selecting and delayed isr triggering strategies?
rq3 how can the precision be improved with the configurable strategies?
rq4 how is the scalability of cpa4av for real world programs?
.
comparison with state of the art tools to examine the performance we compare cpa4av with the state ofthe art tools intatom and rchecker .
it should be noted that in this experiment cpa4av just contains the interruption points selecting and delayed isr triggering strategies without the initial isr triggering and final isr triggering strategies since this is sufficient to achieve the desired precision.
1159esec fse december san francisco ca usa yu tian xing yang su lu yang zhao li duan table comparing cpa4av with state of the art tools on racebench .
id loc isr sv viocpa4av intatom rchecker wn tp fp time ms wn tp fp time ms wn tp fp time ms ex3 ex4 ex5 ex6 ex15 ex16 ex17 ex21 ex22 ex23 ex26 ex27 ex28 ex30 total tp rate .
.
fp rate .
.
average time because neither intatom nor rchecker is openly available the experiments are conducted over the benchmark racebench .
which has been evaluated by both of the tools.
racebench .
consists of interrupt driven c programs with handmade atomicity violation bugs and takes into account different scenarios where atomicity violations may happen which helps in making a comprehensive evaluation over different tools.
considering the inherent weaknesses of cpachecker that the bdd based reachability computation does not support complex data types e.g.
struct pointer and array we select cases to ensure that each comparison tool could execute normally and output valid detection results.
table shows the overall experimental results in which id represents the index of each program in racebench .
loc indicates the lines of code isr denotes the number of isrs sv represents the number of shared variables vio is the number of true violations wn denotes the number of the reported violations tp fp is the number of true false positives and time is the time for detection.
besides we also evaluate the tp rate tp wn fp rate fp wn and average detection time of each tool.
it should be pointed that the preemption of an isr at one location may result in the detection of different unserializable interleaving patterns considered as different atomicity violations.
we observe that intatom and rchecker respectively report and atomicity violations but only of them are correct.
the fp rate and tp rate of intatom are respectively .
and .
while the fp rate and tp rate of rchecker are respectively .
and .
.
cpa4av reports violations and all of them are proved to be real i.e.
the fp rate and tp rate of our tool are respectively and .
obviously cpa4av achieves a higher accuracy than intatom and rchecker.
this is because we perform a more precise reachability analysis based on exploring arts while intatom adopts a coarser one based on analyzing cfgs and rchecker does not prune infeasible branches.
in terms of efficiency it takes a relatively longer time to finish the atomicity violation detection tasks with cpa4av ms than that with intatom ms .
this is reasonable and inevitable since a more accurate reachability analysis usually requires details about the original program which may cause an increase in the overhead.
compared with rchecker which is also a model checker but without effective optimization strategy cpa4av is much more efficient .
time cost with the proposed interruption points selecting and delayed isr triggering strategies.
.
contribution of the proposed strategies to further evaluate the effectiveness of the proposed interruption points selecting and delayed isr triggering strategies we implement two variants of cpa4av naive and naive ips interruption points selecting .
naive can be seen as a baseline approach which triggers enabled isrs after each statement without any strategy.
naive ips means relevant isrs are triggered immediately at each interruption point without the delayed isr triggering strategy.
in addition to racebench .
three benchmarks are chosen from the concurrency track of sv comp3.
we totally select programs in the packages ldv races goblint regression and pthread .
it is worth pointing out that these programs are originally multithreaded and need to be transformed into interrupt driven programs.
to achieve this we treat thread functions as different isrs and remove thread related statements e.g.
pthread create and pthread join in each program.
besides we also add the priority information for each obtained isr.
although the semantics of these programs are changed basic data and control flow structures maintain the same.
besides more randomness is introduced due to the preemption of different isrs.
in practice such randomness is helpful to evaluate our tool comprehensively.
as is shown in table totally programs are considered and cpa4av reports that of them have atomicity violations in total.
by further analysis we find out that all the reported programs indeed have the chance to trigger these violations.
more importantly we compare the explored state space and time cost of cpa4av with those of naive and naive ips on these benchmarks.
it can be seen that naive ips provides an average reduction of .
on state space and .
on time cost over naive.
further cpa4av is able to provide an average reduction of .
on state space and .
on time cost over naive.
as a result both of the proposed interruption points selecting and delayed isr triggering strategies are significantly effective in improving efficiency.
1160detecting atomicity violations in interrupt driven programs via interruption ... esec fse december san francisco ca usa table the state space and time cost of cpa4av compared with naive and naive ips packages files loc wnnaive naive ips cpa4av state number time ms state number reduction rate time ms reduction rate state number reduction rate time ms reduction rate racebench .
.
.
.
ldv races .
.
.
.
goblint regression .
.
.
.
pthread .
.
.
.
total .
.
.
.
table precision improvement with configurable strategies on racebench .
id loc isr sv viocpa4av cpa4av i cpa4av f cpa4av if wn state number time ms wn state number time ms wn state number time ms wn state number time ms ex3 i ex4 i ex5 i ex26 i ex27 i ex6 f ex15 f ex16 f ex23 f ex28 f total .
improvement with configurable strategies as section presents the initial or final isr triggering can act as two configurable strategies to deal with more complex situations.
to evaluate the effectiveness we implement three variants of cpa4av cpa4av i initial isr triggering cpa4av f final isr triggering and cpa4av if initial and final isr triggering .
since racebench .
is designed under the assumption that isrs are not triggered at the initial or final location of a task selected programs are modified slightly based on their original versions.
in this new benchmark named racebench .
one or more atomicity violations occur just as isrs are triggered at the initial or final location of a task.
it should be noted that although intatom and rchecker are not openly available neither of them is able to detect this kind of atomicity violations .
racebench .
is evaluated to show the precision improvement with different configurable strategies.
the experimental results are presented in table .
for the first programs more atomicity violations can be found with the initial isr triggering strategy while for the last programs more atomicity violations can be found with the final isr triggering strategy.
meanwhile in terms of efficiency we can see that the initial isr triggering strategy has an average increase of .9x on the state space and .8x on the time cost and the final isr triggering strategy has an average increase of .9x on the state space and .4x on the time cost.
in addition if these two strategies are employed at the same time the explored state space and time cost will increase by .5x and .2x respectively.
.
evaluation on real world programs cpa4av is further evaluated on packages including real world interrupt driven programs verified in .
specifically logger models parts of the firmware for a temperature logging device blink controls led lights connected to msp430 microcontrollers brake is generated from the simulink model of the embedded bbw system developed by volvo technology ab and i2c pca isa i8xx tco and wdt pci are from linux kernel drivers to support the hardware isa boards tco timer for i8xx chipsets and watch dog respectively.
table real world interrupt driven programs results packages loc isr svnaive cpa4av cpa4av if wn time s wn time s wn time s logger .
.
.
blink .
.
.
brake .
.
.
i2c pca isa .
.
.
i8xx tco .
.
.
wdt pci .
.
.
total .
.
.
for each program the atomicity violations are detected by naive cpa4av and cpa4av if respectively.
since the bdd structure cannot fully support complex data types e.g.
struct pointer and array explicit value analysis is invoked for the reachability computation.
this configuration is mainly to evaluate the scalability of our tool although the efficiency may be influenced.
the experiment is conducted on the same platform with previous experiments and timeout is set to s. when the detection time is larger than s it is recorded as s and the number of detected violations is regarded as .
the result for each package.
in total programs are reported as timeouts by naive and programs are reported as timeouts by cpa4av and cpa4av if.
since the reason of more timeouts in naive cpa4av is able to detect more violations than naive vs18 with less time .
s vs13504.
s and cpa4av if can further detect more violations than cpa4av vs82 .
int y z void main int p m n if m n y p y void isr 1 y z void isr 2 if z y z 16int y z void main int p m n if m n y z m void isr 2 y z void isr 1 if z y z 6int y z void main int p m n if m n y p y void isr 1 y z void isr 2 if z y z 6initial triggering atomicity violation y r w r final triggering atomicity violation z r w w int main ... closer3 return void closer1 isr ... wdtpci write buf v ...if wdtpci write buf !
v ... ... ... ... ... ... ... 984final triggeringatomicity violation wdtpci write buf w w r void closer2 isr ... wdtpci write buf w ... ... ... 1016nested interrupt figure one atomicity violation detected in wdt pci.
as an example fig.
shows one atomicity violation in package wdt pci.
since there is no shared variable in the main task with 1161esec fse december san francisco ca usa yu tian xing yang su lu yang zhao li duan the final isr triggering strategy closer 1 isris triggered before the main task returns.
further in the case that closer 2 isris triggered before line an atomicity violation is detected.
this detection is meaningful since the value change of wdtpci write bufcaused by the preemption of closer 2 isrmakes that the condition originally expected to be unsatisfied in line turns to be satisfied eventually.
from tables and we can see that more atomicity violations can be detected with the initial or final isr triggering strategy at the cost of relatively longer runtime.
this is understandable since more cases should be considered and larger state space need to be explored.
in practice we can initially refrain from utilizing these two strategies for efficient detection.
when no atomicity violation is detected we can further employ them for precise detection.
discussion .
soundness and completeness theoretically the reachability computation is supposed to be precise during the art generation for an interrupt driven program.
in addition considering most practical situations each isr is limited to be triggered at most once along one path.
based on these premises we illustrate that our detection approach is sound and complete.
fact .
for a given path of the constructed art of an interruptdriven program p the proposed delayed isr triggering strategy identifies exactly each kind of unserializable interleaving pattern.
proof.
during the exploration of a given path of the art the delayed isr triggering strategy is employed for each selected interruption point.
specially is utilized to recognize pattern r w r andpattern r w w while is utilized to recognize pattern w r w andpattern w w r as shown in fig.
.
with the delayed isr triggering strategy once an unserializable interleaving pattern is formed the algorithm patternmatching is invoked to detect the atomicity violation in time.
to deal with enable isr anddisable isr can be illustrated similarly and omitted here due to space consideration.
pattern r w r rule da1 r x a3 r x a2 w x fig.
9interruption pointtriggering state ...pattern r w w a1 r x a3 w x a2 w x interruption pointtriggering state ... rule dpattern w r w a1 w x a3 w x a2 r x interruption pointtriggering state ...pattern w w r a1 w x a3 r x a2 w x interruption pointtriggering state ... figure delayed isr triggering strategy for each unserializable interleaving pattern.
fact .
during the art construction the delayed isr triggering initial isr triggering and final isr triggering strategies can exactly cover all kinds of cases that may result in atomicity violations.
proof.
under the condition that each isr is triggered at most once in each path we consider the atomicity violation cases caused by two or three tasks pi pj andpk task p with pri pi pri pj pri pk .
the schematic illustration of the utilized strategy for each case is shown in fig.
.
for tasks piandpj there is only one case that may result in atomicity violations as shown in fig.
a .
for tasks pi pj andpk the following two cases may result in atomicity violations .
sequential interrupt.
piis interrupted bypj orpk before the first access of the shared variable.
after this first access piis again interrupted by pk orpj as shown in fig.
b .
other cases can be handled by the delayed isr triggering strategy.
.
nested interrupt.
piis interrupted by pj andpjis further interrupted by pk.
three possible cases are presented in fig.
c i piis interrupted by pjbefore the first access of the shared variable ii piis interrupted by pjafter the last access of the shared variable iii piis interrupted by pjbetween the first and final accesses of the shared variable.
these cases can be dealt with by the initial isr triggering the final isr triggering and the delayed isr triggering strategies respectively.
the cases for more tasks can be inferred in a similar way.
pia1 a3 a2 fig.
... pjpia3 pk pj...a1 ...pi a3 pkpja1delayed isr triggering delayed isr triggering initial isr triggering delayed isr triggering i if this state is the first access initial isr triggering ii if this state is the last access final isr triggering iii other cases delayed isr triggering a atomicity violation caused by two tasks b atomicity violation cause d by sequential interrupt of three tasks c atomicity violation caused by nested interrupt of three tasksa2 a2 figure each possible atomicity violation case and the corresponding strategy.
facts and respectively state that our approach is sound and complete to detect atomicity violations for each given path and cover all cases possibly containing atomicity violations in the constructed art.
with this basis on the premise of the precise reachability computation during the art construction it is straightforward to infer that our approach is sound and complete to detect atomicity violations for an interrupt driven program.
.
limitations in the above we illustrate the soundness and completeness of our approach under some prerequisites which are also the limitations possibly hindering the widespread application.
support for more complex isr triggering cases.
considering most practical situations each isr is limited to be triggered at most once along each path in our approach.
although cpa4av is able to find all pre set atomicity violations for the benchmark to deal with more complex isr triggering cases such as unlimited interrupt times or interrupt reentry effective strategies are required to reduce the possible huge state space in future work.
precise and efficient analysis for complex data types.
during the implementation cpa4av is developed upon cpachecker where the inherent reachability computation is based on bdd or explicit value analysis.
although bdd is more efficient complex data types e.g.
struct pointer and array are not fully supported currently making that programs in racebench .
except those shown in table cannot be detected.
on the contrary explicit value analysis ensures the scalability of our tool for real world embedded programs but it is not efficient enough resulting in timeouts in the experiment.
in the future reachability computation needs to be further improved to support complex data types both precisely and efficiently.
1162detecting atomicity violations in interrupt driven programs via interruption ... esec fse december san francisco ca usa related work as a kind of concurrency bugs atomicity violations usually occur in multi threaded and interrupt driven programs.
.
atomicity violation detection in multi threaded programs a considerable number of static and dynamic approaches have been put forward to detect atomicity violations in multi threaded programs.
among static approaches von praun et al.
develop a framework based on an abstract model of threads and data and dias et al.
present a algorithm by statically analyzing the dependency graph of program variables to detect atomicity violations.
combining the source code analysis and data mining techniques lu et al.
automatically infer variable access correlations and detect related atomicity violations.
flanagan et al.
and sasturkar et al.
present different type systems for specifying the atomicity of methods and uncovering atomicity violations for multithreaded java programs.
huang et al.
model the access anomaly prediction as a graph pattern search to predict possible atomicity violations.
model checking methods are also proposed to check atomicity.
for example with the partial order reduction strategy hatcliff et al.
utilize bogor to provide an effective means of checking atomicity violations.
also flanagan employs spin to explore non serial and serial executions simultaneously to detect atomicity violations for a number of irreducible procedures.
in terms of dynamic detection inspired from the lipton s theory of reduction and earlier dynamic race detectors flanagan et al.
present a dynamic analysis for detecting errors caused by unintended interactions between threads.
eslamimehr et al.
describe a technique that directly searches three access pattern instances in the dynamic analysis.
ma et al.
maintain a reduced set of increasing dependency sequences for each active transaction to detect all atomicity violations in a trace.
based on happensbefore relations among events in an execution trace chang et al.
identify pairs of events designed to be atomically processed and use predefined patterns to detect atomicity violations.
by combining static and dynamic analyses chen et al.
obtain summaries in the static analysis and instantiate them with runtime values.
using the coarse interleaving hypothesis kasikci et al.
develop a hybrid dynamic static interprocedural pointer and type analysis to diagnose the root causes of concurrency bugs.
due to the inevitable state space explosion problem incurred by possible interleaving of different threads the static approaches to detect atomicity violations in multi threaded programs progress much more slowly than dynamic approaches.
among these static approaches though some space reduction strategies such as partial order have been proposed the characteristics between the interleaving of different threads have not been captured effectively.
as a result there exist obstacles to conducting static analysis to detect atomicity violations for multi threaded programs.
compared with multi threaded programs interrupt driven programs have a relatively smaller state space which makes static analysis able to play a role for interrupt driven programs.
however interrupt driven programs differ from multi threaded programs in the synchronization mechanism and preemption relationship.
it is still challenging to apply the above approaches for multi threaded programs to interrupt driven programs directly.
.
concurrency bug detection in interrupt driven programs several approaches have been proposed to detect concurrency bugs mainly data races in interrupt driven programs.
for instance based on the disjoint blocks to define the synchronization with relation chopra et al.
propose lockset based analysis for race detection in interrupt driven kernels.
similarly tulsyanc et al.
introduce the occurs in between relation to capture the interplay of various synchronization mechanisms.
in dynamic approaches chen et al.
propose a runtime analysis approach to detect data races caused by inconsistent lock protection.
sun et al.
present a set of dynamic bug patterns to locate data races caused by buggy access to shared resources.
as a hybrid approach wang et al.
combine static analysis and symbolic execution to generate input data for exposing potential races.
bai et al.
utilize a static lockset analysis to detect data races based on the runtime results.
in recent years other kinds of severe concurrency bugs have begun to be concerned in interrupt driven programs.
among them atomicity violation is one of the most representatives.
du et al.
propose a static analyser rchecker on top of the bounded model checker cbmc to search atomicity violations.
however false positives are inevitable due to the nature of path constraint solving.
besides because of lacking effective strategies for pruning paths the extremely large state space makes it challenging in scalability.
in order to avoid the explicit state exploration intatom employs a staged design for atomicity violation detection.
it first identifies all potential atomicity violations based on the data flow analysis and then filters out those infeasible candidates.
in this method there are still false positives due to the imprecise reachability analysis.
in addition it can not deal with complex situations such as isrtriggering at the initial or final location of a task.
different from rchecker and intatom our approach first constructs the program model with the interruption points selected in cfgs.
then the reachability computation is performed to prune infeasible paths and build up a whole abstract reachability tree during which the delayed isr triggering strategy is employed to trigger enabled isrs as late as possible.
as a result the state space can be reduced significantly meanwhile the precision can be guaranteed.
conclusion and future work in this paper we focus on the problem of detecting whether there exist atomicity violations in interrupt driven programs.
with the interruption point selecting strategy of our approach redundant isr control flows can be avoided from being introduced.
in addition the explored state space of an art can be greatly reduced with the proposed delayed isr triggering strategy.
the approach is evaluated through extensive experiments.
in the near future we will consider more complex isr triggering cases such as unlimited interrupt times or interrupt reentry.
moreover we plan to extend our tool to support more complex data types for interrupt driven programs both precisely and efficiently.
acknowledgement this research is supported by the national natural science foundation of china with grant no.
and science and technology plan project of xi an with grant no.
2022jh ryfw .
cong tian is the corresponding author.
1163esec fse december san francisco ca usa yu tian xing yang su lu yang zhao li duan