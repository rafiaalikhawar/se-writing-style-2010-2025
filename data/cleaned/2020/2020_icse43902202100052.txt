how developers optimize virtual reality applications a study of optimization commits in open source unity projects fariha nusrat department of computer science university of texas at san antonio fariha.nusrat my.utsa.edufoyzul hassan department of computer and information science university of michigan dearborn foyzul umich.edu hao zhong department of computer science and engineering shanghai jiao tong university zhonghao sjtu.edu.cnxiaoyin wang department of computer science university of texas at san antonio xiaoyin.wang utsa.edu abstract virtual reality vr is an emerging technique that provides immersive experience for users.
due to the high computation cost of rendering real time animation twice for both eyes and the resource limitation of wearable devices vr applications often face performance bottlenecks and performance optimization plays an important role in vr software development.
performance optimizations of vr applications can be very different from those in traditional software as vr involves more elements such as graphics rendering and real time animation.
in this paper we present the first empirical study on realworld performance optimizations from vr software projects.
in particular we manually categorized the optimizations into categories and applied static analysis to identify how they affect different life cycle phases of vr applications.
furthermore we studied the complexity and design behavior effects of performance optimizations and how optimizations are different between large organizational software projects and smaller personal software projects.
our major findings include graphics simplification .
rendering optimization .
language api optimization .
heap avoidance .
and value caching .
are the most common categories of performance optimization in vr applications game logic updates .
and before scene initialization .
are the most common lifecycle phases affected by performance issues .
of the optimizations have behavior and design effects and .
of the optimizations are systematic changes the distributions of optimization classes are very different between organizational vr projects and personal vr projects.
index t erms empirical study virtual reality performance optimization i. i ntroduction virtual reality vr techniques have provided revolutionary user experience in various application scenarios e.g.
training education product architecture design gaming remote conference tour .
according to a report from mordor intelligence the market of virtual reality is valued at .
billion dollars in and is expected to grow by corresponding authors48.
per year.
while the majority of the vr market is still on hardware the market size of vr software is estimated to reach .
billion dollars in with thousands of apps being developed and uploaded to google play apple store and oculus market .
these apps having been downloaded by more than million users from all over the world .
compared with traditional gui based software applications vr software often consumes much more computation resources due to their complicated real time animations and the double rendering requirements i.e.
rendering twice for both eyes at the same time .
furthermore vr devices often have relatively limited computation resources due to their wearable nature and their performance downgrade often causes more severe consequences e.g.
dizziness and motion sickness caused by low frame rates and in continuous animations than traditional software applications .
as a result performance optimization plays a very important role in vr software development and performance defects are of high priority to be repaired as soon as possible .
while there have been many empirical studies on general mobile performance bugs and optimizations to understand their common patterns and give suggestions to developers researchers there are few studies on vr performance optimizations e.g.
and thus the understanding of them is very limited.
in particular factors affecting vr performance can be very different from those affecting traditional software performance because vr applications have rich real time animations extensive usage of gpu and high impacts of asset scene design besides source code on rendering costs.
to deepen the understanding on vr performance optimizations in this paper we present an exploratory study1on performance optimizing changes in actively maintained 1see our data set at ieee acm 43rd international conference on software engineering icse .
ieee open source vr projects from unitylist the largest online repository of open source vr software projects based on unity.
we believe this scope of subject selection is reasonable because unity dominates vr development with over market share according to multiple sources and unity itself open source nurtures a large vr community with thousands of open source projects i.e.
unitylist .
in our study we first applied a keyword search on the version history of all actively maintained software projects in unitylist which have at least code commits.
the keyword search found code commits as potential performance optimizations.
two of authors manually inspected each of the code commits independently to identify performance optimizations and further analyzed the code changes the type and the root cause of each performance optimization.
the following reconciliation among authors confirmed performance optimizing changes.
it should be noted that one code commit may contain multiple logic code changes each of which can be either performance optimizing change or not so one performance optimizing change may not cover all file revisions in its corresponding code commit and multiple performance optimizing changes may come from the same commit.
after that we further applied static call graph analysis and code asset dependency analysis to the performanceoptimizing changes to precisely answer our research questions.
our study mainly tries to answer the following six research questions and we briefly summarize our major findings below as their answers given by the study.
rq1 what are the major categories of performance optimizations in vr software projects?
motivation.
the answers will present an overview of vr performance optimizations.
answer.
our findings show that the top five categories of optimizations are graphics simplification .
rendering optimization .
language feature api optimization .
heap avoidance .
and value caching .
among which and are not reported in prior studies on general performance bugs and optimizations.
rq2 which life cycle phases of vr software are more affected by performance issues?
motivation.
the answer is useful on allocating resources for vr performance optimizations.
answer.
our findings show that game logic updates before scene initialization and game object initialization are mostly affected life cycle phases of vr scenes affected by .
.
and .
of the sourcecode revising optimizations respectively.
rq3 how complex are performance optimizations in vr software projects?
motivation.
the answers reveal the complexity of handling vr performance optimizations.
answer.
our findings show that .
of the performance optimizations involve asset file revisions but .
optimizations are simpler inner class code changes.
the average number of revised files is .
and the average number of revised source code lines is .
among source code revising optimizations .
rq4 do performance repairs have effect on other aspects of software quality?
motivation.
the answers reveal the side effects of vr performance optimizations.
answer.
our findings show that .
performance optimizations have potential effects on software design and behavior.
in particular of them have potential effect on program behavior user interface and the remaining have potential effect on software design coding style.
rq5 how many performance repairs are systematic changes which apply the same or similar code revisions to multiple code locations?
motivation.
the answers reveal the repetitions of vr performance optimizations and are important for the detection and repair of such issues.
answer.
our findings show that out of .
performance optimizations are systematic changes and certain categories of optimizations i.e.
heap avoidance api language optimization and graph simplifications contains large proportion of systematic changes.
rq6 do developers in organizational projects and personal projects behave differently in resolving vr performance optimizations?
motivation.
based on the answers we can understand the knowledge and habit difference between organizations and personal developers.
answer.
our findings show that the distributions of performance optimization categories are very different between organizational and personal projects.
in particular the top three categories of performance optimizations in organizational projects are heap avoidance of language features api optimizations of and graphics simplifications of while the top three categories of performance optimizations in personal projects are graphics simplifications of rendering optimizations of and value caching of .
to sum up our study makes the following contributions we construct a data set of vr performance optimizations that we used for our study.
the data set also forms a foundation for future research in this area.
we develop a taxonomy of performance optimizations in vr applications and it extends the taxonomies of general performance optimizations in the prior studies.
we answer six research questions on vr performance optimizations including their impact on vr scene phases their complexity their behavior design effects whether they are systematical changes and their different distribution in organizational and personal projects.
the remaining part of this paper is organized as follows.
after presenting background knowledge about vr and unity in section ii we will describe our experiment methodology in section iii.
section iv presents the results of our study 474and section v presents discussion of lessons learned.
related works and conclusion will be discussed in section vi and section vii respectively.
ii.
b ackground in this study we selected vr applications from unitylist and these applications are built upon unity framework which is the dominating framework in vr software development and integrates with almost all existing vr ar platforms including apple arkit android daydream cardboard google arcore steam vr windows mixed reality hololens etc.
in the remaining of our paper we refer to a series of vr concepts using unityspecific terms.
please note that these concepts are general and exist in all vr development frameworks as evidenced by the seamless integration of unity with a large variety of vr platforms.
we introduce these terms as follows.
scenes.
a vr scene refers to a space where a user immerses in and interacts with when using a vr application.
for examples a scene can be a virtual meeting room in a vr remote conference application.
a vr application usually consists of multiple scenes linked with each other through events triggered by users.
game objects.
game objects are core components of scenes and a game object represents a virtual object in a scene space.
for examples game objects can be tables chairs in a virtual meeting room.
game objects have very rich attributes to specify their appearance e.g.
color surface texture transparency physical properties e.g.
mass speed collision types runtime behaviors defined in a c sharp script attached to the object etc.
game objects can be compound hierarchically.
for example a game object can combine a sword with a scabbard.
in this sense game objects are similar with views controls in traditional gui based apps but largely enriched for run time animations.
prefabs.
since a vr application often contains multiple game objects of the same type e.g.
multiple chairs of the same type in one room and across multiple rooms .
in such cases the definition of the set of similar game objects can be abstracted to so called prefabs.
the relationship between game objects and prefabs are analogous to that between objects and classes in object oriented programming languages.
scripts and assets.
in a vr application scripts typically in c sharp are source code files and they are attached to game objects to define their logic behaviors.
besides scripts there are various asset files defining graphics behaviors e.g.
.3ds and.fbx files for 3d models .shader files for lighting effects .mat files for material textures and .unity files for scene settings .
in our study for simplicity we consider script files as source code files and all other files as asset files .
the life cycle model of game objects.
in the life cycle of a scene the unity framework will trigger a series of lifecycle callback methods on each of the game objects as implemented in the scripts attached to the objects in the scene.
figure presents a simplified life cycle model of game objects.
in particular the before scene phase methodsbefore scene awake onenable onlevelwasloaded object init start physics update fixedupdate onstatemachineenter exit onanimatormove onanimatorik ontrigger oncollision waitforfixedupdate input onmouse logic update update waitforseconds startcoroutine onstatemachineenter exit onanimatormove onanimatorik lateupdate render onwillrenderobject onprecull onbecamevisible onbecameinvisible onprerender onrenderobject onpostrender onrenderimage ondrawgizmos ongui ending onapplicationquit ondisable ondestroy every frame fig.
the life cycle model of game objects are executed before a scene is started the object init phase methods are executed before the first frame update of the scene or before the frame update immediately after a game object is added to the scene the methods in physics update input logic update and render phases are executed sequentially for each frame and the physics update phase may be executed multiple times within a frame if the frame rate is low.
finally the methods in the ending phase are executed after the last frame of the scene or after a game object is removed.
iii.
m ethodology our study has the following steps.
first we collected candidate performance related commits from the git repositories of the most recently updated vr projects.
second we manually inspected each of the code commits to identify performance optimizations and labelled them with category tags systematic change tags and behavior design rq1 rq4 rq5 and rq6 .
third we applied static analysis on the performance optimizations to understand they relations to other parts of the code rq2 and rq3 .
475commit msg keyword search using jgitunity project repo potential perf commitcount manual inspection of perf commitconfirmed optimizations revised linescount call graph analysismanual labelling commit analysisrq1 optimization taxonomy rq5 effects rq6 organizational vs. personal rq2 affected life cycle phases rq3 dependency analysis rq4 systematic changes fig.
the overview of our performance optimization study a. collection of candidate commits from unitylist we selected most recently updated vr software projects that have at least historical commits.
we chose the recently updated projects and used the commit threshold to ensure that the projects we considered are actively maintained.
we implement a tool upon jgit .
within these projects our tool searches commit messages of all their historical commits for performance related commits and the returned results are our candidate commits.
for the search we used performance speed up accelerate fast slow latency contention optimize and efficient as our search keywords in that a prior study used these keywords to collect performance related bug fixes.
we further used four keywords fps framerate frame rate and frame per second which are specific to vr ar software projects.
with this search strategy we identified candidate code commits.
b. manual inspection and reconciliation two of the authors independently inspected each of the candidate code commits.
for each code commit each inspector read its commit message and the revised files and reported the following information revised lines in the commit that represent one or multiple performance optimizations if there are any a category tag of the identified performance optimization to answer rq1 and rq6 whether the performance optimization has behavior design effect to the application such as affecting its functional features and design quality to answer rq5 .
in particular for identifying performance optimizations we consider only revisions directly related to performance optimization.
for example in method m when a local object instantiation ins is replaced by a field reference to avoid heap allocations some of m s parameters required by ins become unnecessary and thus can be removed.
all invocations ofmalso need to be updated to remove the corresponding arguments.
in this example the replacement of ins is directlyrelated to the performance optimizations so it is reported while the removal of parameters in m and updates of m s invocations do not need to be manually reported and we rely on static analysis in section iii c to further identify these related revisions.
for category tagging we refer to existing taxonomies in prior studies .
if a performance optimization falls into categories in existing taxonomies e.g.
api misuse redundant checking we add the corresponding category tag on it.
if an inspector cannot put the optimization in an existing category the inspector needs to invent a new term for the new category.
terms invented by different inspectors are merged in the later reconciliation phase.
for behavior and design effects we identify behavior effects on user interface from developers comments in commit messages and design effects by manually checking whether the code revision violates common design principles.
after the inspection we performed reconciliation to merge inspection results.
for identifying performance optimizations we went through each identified optimization to confirm reject inspection results.
we used the following rule to count performance optimizations.
within one commit if there are multiple performance optimizations but they are unrelated to each other we report them as different performance optimizations.
meanwhile even if they are unrelated we count them as one and label it as a systematic change in the case that they are instances of the same systematic change.
for example when developers find that api method m1is more efficient than the api method m2they are using they may replace all invocations of m2tom1.
although these replacements may not be related to each other they are instances of a same systematic change so we count all such replacements as one performance optimization.
for category tagging we first merged the category tags we invented to form a combined taxonomy and mapped category tags of performance optimizations given by each inspector to the combined taxonomy.
after the mapping if a performance optimization has incon476sistent category tags we discuss to decide its final category tag.
for design and behavior effects similar to category tagging we first merged the types of effects identified by inspectors and then identified performance optimizations with inconsistent results after mapping.
after that we discussed to make a final decision on the design and behavior effects of those optimizations.
we calculated the cohen s kappa value between two coders.
the score for optimization determination is .
.
for categorization after labeling we match the newly added categories to have unified names for categories and then cohen s kappa value on categorization is .
.
both values show substantial agreement above .
.
c. analysis of performance optimizations to answer rq2 through rq4 we need to identify code related to performance optimizations and relations between revisions in a commit.
in particular to answer rq2 we applied a call graph analysis to identify the life cycle methods as listed in figure that transitively invoked the revised methods within a performance optimization.
to answer rq3 we applied a code dependency analysis and code asset analysis to identify other revised lines that are related to the performance optimization.
to answer rq4 we applied code clone detection to identify potential systematic changes and manually confirmed the detected instances.
before we can apply static analysis to revised lines we precisely identified the revised code elements by comparing abstract syntax trees asts .
it should be noted that due to the challenge of automatically building the projects we chose to apply static analysis to the source code and perform partial code analysis .
in particular we used srcml to parse the c sharp source code and extracted ast level changes with the state of the art diff tool gumtree .
then we performed the call graph analysis code dependency analysis and code clone detection .
to identify dependencies between scripts and asset files we compared meta ids of scripts and asset files.
in particular all scripts and asset files in unity have a corresponding .meta file which contains a unique identifier of the script asset.
by tracking the ids in the definition of game objects in .prefab files and .unity files we can check whether a script and an asset are attached to the same game object.
if so we consider the revised lines in the script and the revised lines in the asset file are related to each other.
iv .
s tudy results a. rq1 categorization of vr performance optimizations in total our study identified categories of performance optimizations from our candidate commits.
the distribution of optimizations over categories is presented in figure .
for the type of optimizations that can be matched to those in earlier studies of traditional software optimizations we present the mapping to corresponding literature in table i. in column of the table we present our optimization types that can be mapped to earlier literature.
in column and of the table we present their corresponding name in literaturegraphics simplification 44rendering optimization api language optimization heap avoidance caching values conditionally avoid computation 16multithread 5move code out of frame update 4remove redundant check 3code simplification 2algorithm update fig.
categorization of vr performance optimizations and respectively.
we use to indicate that there is no matching category in the corresponding literature.
note that we use different names for our categories because we are describing optimization types instead of root cause types of performance issues and we need category names to be short enough to fit into chart legends.
figure shows that the most common types of optimizations are graphics simplifications rendering optimizations api language optimizations heap avoidance caching values and conditionally avoid computations.
the six categories cover of our total studied optimizations.
among the six categories three of them graphics simplifications rendering optimizations heap avoidance are new categories of optimizations and the prior studies did not observe such optimizations in general software projects.
the three categories cover .
optimizations.
finding we find three new categories of optimizations which are graphics simplifications rendering optimizations and heap avoidance.
they are not observed in prior studies and account for more than half of studied optimizations showing that the landscape of optimizations in vr software is very different from that of traditional software.
to better understand the characteristics and common patterns of new major categories of vr optimizations we present some representative examples of optimizations below.
c1 graphics simplification.
developers simplify graphics to achieve better performance.
this type of optimizations is similar to workarounds since simplifications sacrifice the quality of graphics display.
we found graphics simplifications from the studied optimizations.
the most common subcategories of graphics simplifications are shader simplifications out of which removes or simplifies runtime lighting effects of game objects and 3d model simplifications out of which replace the 3d model of a game object with a simpler 3d model with less polygons.
other 477table i mapping of optimization types optimization type root cause type root cause type api language optimization inefficient api usage api misunderstanding caching v alues repeated execution of the same operations conditionally avoid computation a computation can be simplified or avoided in special cases skippable functions multi thread synchronization issues remove redundant check repeated check of same condition graphics simplifications include downgrade resolutions out of and particle systems provided by unity framework to handle particle effects such as fog and fire simplification out of and directly removing game objects from a scene out of .
most of these optimizations affect only the visual experience of users but some extreme cases may have effect on software features.
for example in a shader simplification a85ab3ab6a0 from the moon motion project moonmotionproject moonmotion.git the developers largely reduced the visible lighted area to reduce rendering costs.
finding unlike in traditional software where performance optimizations usually do not affect external software behavior in vr software users visual experience and even some features can be sacrificed adapted for better performance.
revision wise graphics simplifications are typically related to revise the