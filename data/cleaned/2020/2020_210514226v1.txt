a longitudinal analysis of bloated java dependencies c sar soto valero kth royal institute of technology sweden cesarsv kth.sethomas durieux kth royal institute of technology sweden thomas durieux.mebenoit baudry kth royal institute of technology sweden baudry kth.se abstract we study the evolution and impact of bloated dependencies in a single software ecosystem java maven.
bloated dependencies are third party libraries that are packaged in the application binary but are not needed to run the application.
we analyze the history of435java projects.
this historical data includes 469distinct dependencies which we study across a total of 515versions of maven dependency trees.
bloated dependencies steadily increase over time and .
of the direct dependencies that are bloated remain bloated in all subsequent versions of the studied projects.
this empirical evidence suggests that developers can safely remove a bloated dependency.
we further report novel insights regarding the unnecessary maintenance efforts induced by bloat.
we find that of dependency updates performed by developers are made on bloated dependencies and that dependabot suggests a similar ratio of updates on bloated dependencies.
acm reference format c sar soto valero thomas durieux and benoit baudry.
.
a longitudinal analysis of bloated java dependencies.
in esec fse .
acm new york ny usa pages.
introduction software is bloated.
from single unix commands to web browsers most applications embed a part of code that is unnecessary to their correct operation.
several debloating tools have emerged in recent years to address the security and maintenance issues posed by excessive code at various granularity levels.
however these works do not analyze the evolution of bloat over time.
understanding software bloat in the perspective of software evolution is crucial to promote debloating tools towards software developers.
in particular developers when proposed to adapt a debloating tool wonder if a piece of bloated code might be needed in coming releases or what is the actual issue with bloat.
this work proposes the first longitudinal analysis of software bloat.
we focus on bloat among software dependencies in the java maven ecosystem.
bloated dependencies are software libraries that are unnecessarily part of software projects i.e.
when the dependency is removed from the project it still builds successfully.
in previous work we showed that the maven ecosystem is permeated with bloated dependencies and that they are present permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for third party components of this work must be honored.
for all other uses contact the owner author s .
esec fse august athens greece virtual event copyright held by the owner author s .
acm isbn nnnnnnn.nnnnnnn.
in well maintained java projects.
our study revealed that software developers are keen on removing bloated dependencies but that removing code is a complex socio technical decision which benefits from solid evidence about the actual benefits of debloating.
motivated by these observations about bloated dependencies we conduct a large scale empirical study about the evolution of these dependencies in java projects.
we analyze the emergence of bloat the evolution of the dependencies statuses and the impact of bloat on maintenance.
we have collected a unique dataset of versions of dependency trees from 435open source java projects.
each version of a tree is a snapshot of one project s dependencies for which we determine a status i.e.
bloated or used.
we rely on depclean the state of the art tool to detect bloated dependencies in maven projects.
we analyze the evolution of 469distinct dependencies per project and we observe that .
of them are bloated at one point in time in our dataset.
our longitudinal analysis of bloated java dependencies investigates both the evolution of bloat as well as the relation between bloat and regular maintenance activities such as dependency updates.
we present original quantitative results regarding the evolution of bloated dependencies.
we first show a clear increasing trend in the number of bloated dependencies.
next we investigate how the usage status of dependencies evolves over time.
this analysis is a key contribution of our work where we demonstrate that a dependency that is bloated is very likely to remain bloated over subsequent versions of a project.
we present the first observations about the impact of regular maintenance activities on software bloat.
besides we analyze the impact of dependabot a popular dependency management bot on these activities.
we show that developers regularly update bloated dependencies and that many of these updates are suggested by dependabot.
furthermore we systematically investigate the root of the bloat emergence and find that84.
of the bloated dependencies are bloated as soon as they are added in the dependency tree of a project.
to summarize the contributions of this paper are a longitudinal analysis of software dependencies usage in 515versions of maven dependency trees.
our results confirm the generalized presence of bloated dependencies and show their increase over time.
a quantitative analysis of the stability of bloated dependencies .
of direct dependencies remain bloated.
this is a concrete insight that motivates debloating dependencies.
a novel analysis of unnecessary updates on bloated dependencies made by a software bot.
we find that developers often accept dependabot s suggestions without considering if the dependency is actually used or not.
a qualitative manual analysis of the origin of bloated dependencies that reveals that adding dependencies is the principal reason that originates this type of software bloat.arxiv .14226v1 may 2021esec fse august athens greece virtual event c sar soto valero thomas durieux and benoit baudry .
.
.
dependencies dependency groupid org.d1 groupid artifactid d1 artifactid version .
.
version dependency dependency groupid org.d2 groupid artifactid d2 artifactid version .
.
version dependency dependency groupid org.d3 groupid artifactid d3 artifactid version .
.
version dependency dependencies .
.
.
figure dependency declaration.
p d1 d2 d3 d4 d5direct dependency d6transitive dependencydependency relationship figure dependency tree.
pd1d2d3d4d5d6bloated dependencyused dependencyusage relationshipapi members figure dependency usage.
background in this work we consider a software project as a collection of java source code files and configuration files organized to be build with maven.1in this section we present the key concepts for the analysis of a project pin the context of the set of its software dependencies denoted asd.
definition .
.
maven dependency a maven dependency defines a relationship between a project pand another compiled project d d .
dependencies are compiled jar files uniquely identified with a triplet g a v where gis the groupid ais the artifactid and vis the version .
dependencies are defined within a scope which determines at which phase of the maven build cycle the dependency is required e.g.
compile test runtime .
a maven project declares a set of direct dependencies in a specific configuration file known as pom.xml acronym for project object model located at the root of the project.
figure shows an excerpt of the dependency declaration in the pom.xml of a project p. in this example developers explicitly declare the usage of three dependencies d1 d2 and d3.
note that the pom.xml of a maven project is a configuration file subject to constant change and evolution developers usually commit changes to add remove or update the version of a dependency.
definition .
.
direct dependency the set of direct dependenciesddirect d of a project pis the set of dependencies declared in p spom.xml file.
direct dependencies are declared in the pom.xml by the developers who explicitly manifest the intention of using the dependency.
definition .
.
transitive dependency the set of transitive dependenciesdtransitive d of a project pis the set of dependencies obtained from the transitive closure of direct dependencies.
transitive dependencies are resolved automatically by maven which means that developers do not need to explicitly declare these dependencies.
definition .
.
dependency tree the dependency tree of a maven project pis a direct acyclic graph of the dependencies of p where pis the root node and the edges represent dependency relationships between pand the dependencies in d. to construct the dependency tree maven relies on its specific dependency resolution mechanism.2first maven determines the set declared dependencies based on the pom.xml file of the project.
then it fetches the jars of the dependencies that are not present locally from external repositories e.g.
maven central.
figure illustrates the dependency tree of the project p which pom.xml file is in figure .
the project has three direct dependencies as declared in its pom.xml and three transitive dependencies as a result of the maven dependency resolution mechanism.
d4and d5are induced transitively from d1 whereas the transitive dependency d6is induced from d3.
note that all the bytecode of these transitive dependencies is present in the classpath of project p and hence they will be packaged with it whether or not they are actually used by p. definition .
.
bloated dependency a dependency d d in a software project pis said to be bloated if there is no path in the dependency tree of p between pandd such that none of the elements in the api of dare used directly or indirectly by p. we introduced the concept of bloated dependencies in .
although they are present in the dependency tree of software projects bloated dependencies are useless and therefore developers can consider removing them.
definition .
.
dependency usage status the usage status of a dependency d d determines if disused orbloated w.r.t.
to p at a specific time of the development of p. figure shows an hypothetical example of the dependency usage tree of project p. suppose that pdirectly calls two sets of instructions in the direct dependency d1and the transitive dependency d6.
then the subset of instructions called in d1also calls instructions ind4.
in this case the dependencies d1 d4 and d6are used by p while dependencies d2 d3 and d5are bloated dependencies.
figures and illustrate the status of a project s dependencies at some point in time.
yet the pom.xml file the dependency tree and the status of dependencies are prone to change for several reasons.
for example a dependency that was used can become bloated after a dependency migration or after some refactoring activities that remove the usage link between the project and some of its dependencies.
it is also possible that developers add dependencies in the pom.xml file or that more transitive dependencies appear in the tree e.g.
when updating the direct dependencies.
this work investigates these software evolution changes and their impact on bloat and maintenance.
longitudinal analysis of bloated java dependencies esec fse august athens greece virtual event collect single module maven projects 1filter commits that modify the pom.xml 2analyzethe status of dependencies at each commit 3collect single module maven projects47 commits on the pom.xmlfiles31 dependency trees analyzedover timefilteranalyze ... java projects on github inputdataset ...time435 projects figure overview of our data collection pipeline.
from a set of 991java projects on github we analyze the usage status of the dependencies in 435maven projects over time to produce a dataset of 515dependency trees.
study design in this section we present the research protocols that we follow to conduct our empirical study including the research questions rqs the tooling utilized to detect bloated dependencies the data collection and our methodology to address each rq.
.
research questions in this paper we study four different aspects of bloated dependencies.
our analysis is guided by the following research questions.
rq1 .how does the amount of bloated dependencies evolve across releases?
with this first question we aim at consolidating the body of knowledge about software bloat.
several recent studies have shed light on the massive presence of bloat in different types of software projects .
the growth of bloat is an important motivation for these works.
yet this growth has never been assessed nor quantified.
our first research question addresses this lack analyzing the evolution of the amount of bloat over time.
rq2 .how does the usage status of each dependency evolve across time?
tools that remove bloated code are designed under the assumption that a piece of code that is bloated at some point in time will always be bloated hence it makes sense to remove it.
in this second research question we investigate whether this assumption holds true in the case of bloated java dependencies.
we analyze how the usage status of dependencies evolves over time from used to bloated or vice versa.
rq3 .do developers maintain dependencies that are bloated?
bloated dependencies needlessly waste time and resources e.g.
space on disk build time performance.
however one of the major issues related to this type of dependency is the unnecessary maintenance effort.
in this research question we investigate how often developers modify the pom.xml to update dependencies that are actually bloated.
rq4 .what development practices change the usage status of dependencies?
the emergence of bloat is due to various code maintenance activities e.g.
refactoring the code or modifying the pom.xml .
in this research question we expand the quantitative analysis of the status of each dependency and perform an in depth analysis of the causes of dependency bloat.
.
detection of bloated dependencies to analyze the status of dependencies of maven projects we rely on depclean .4this is an open source tool that implements a practical way of detecting bloated dependencies in the complete dependency tree of a java maven project.
depclean runs a static analysis at the bytecode level to detect the usage of direct and transitive dependencies.
to do so depclean constructs a static call graph of api members calls among the bytecode of the project and its dependencies.
then it determines which dependencies are referenced either directly by the project or indirectly via transitive dependencies.
if none of the api members of a dependency are referenced depclean reports the dependency as bloated i.e.
the dependency is not necessary to build the project.
depclean generates a report with the status of each dependency a list of api members that are used at least once for each used dependency.
the tool also generates a modified version of the pom.xml without bloated dependencies.
.
data collection the dataset used in our study consists of a collection of subsequent versions of maven dependency trees .
each dependency in these trees is analyzed in order to determine its status used or bloated.
figure summarizes the process we follow to collect this dataset.
rounded rectangles represent procedures non rounded rectangles represent intermediate data results.
collect.
our data collection pipeline starts from the list of java projects extracted from github by loriot et al.
.
the authors queried the github api on june 9th of and provide a list of github urls including all projects that use java as the primary programming language.
from this list we keep only projects with more than 5stars.
this initial dataset contains a total of java projects.
then we inspect the projects files and select those containing a single pom.xml file in the root of the repository to focus our longitudinal analysis on single module maven projects.
this first data collection step provides a set of 560java projects.
filter.
in this second step we check all the commits on the pom.xml file to determine the version of the project declared in thepom.xml .
each time the version of the project changes and it is not a snapshot or a beta version we consider that the commit represents a new release.
we sort the list of projects by the number of releases and then we select the first 500projects.
we focus on release commits since a release represents a stable version of the project which is a suitable moment to consider the presence august athens greece virtual event c sar soto valero thomas durieux and benoit baudry table descriptive statistics of the dependencies in the analyzed projects.
min 1st qu.
median avg.
3rd qu.
max months .
.
.
.
analyzed commits .
.
.
.
direct initial .
.
.
.
transitive initial .
.
.
.
direct final .
.
.
.
transitive final .
.
.
.
of bloated dependencies.
in addition to the project releases we collect the commits that have been created by dependabot 5a popular software bot that automatizes the update of dependencies on github .
the goal is to determine how many bloated dependencies have been updated as a result of a pull request not made by a human.
we identify 017dependabot commits for .
projects.
at the end of this step we have a total of 500projects as well as 293commits including 276release commits.
analyze.
the final and most complex step in our pipeline is to analyze the status of dependencies in the 293commits.
we perform the following tasks clone the repository and checkout the commit compile the project using maven if the project compiles then we execute depclean on the commit to obtain the dependency usage status.
we analyze dependencies that have a compile ortest scope.
the compilation task is the most crucial and difficult task because it involves downloading dependencies having the correct version of java and having a proper project state i.e.
the java code needs to be valid.
we mitigate those problems by compiling the projects with java and then with java .
by trying to compile with java when the project does not compile with java we increase the number of successful compilations by around .
we also use a proxy for maven that caches and looks for dependencies in five different repositories to increase the chances to resolve them.
in total the proxy cached dependencies and 165gbof data.
as side effects the proxy speeds up the resolution of dependencies and increases the reproducibility of the study i.e.
maven will always resolve the same dependencies even if we recompile the projects after several years.
this final step of our pipeline outputs the definitive dataset for our longitudinal study the dependency usage trees of .
commits collected from .
projects.
these trees capture the history of 469dependency relationships including direct dependencies and 442transitive dependencies.
among the commits .
are project releases and .
are dependabot commits.
we have kept only the projects for which we can successfully analyze at least two dependency tree versions.
the dataset consists of a json file per commit for each project containing the status of each dependency at every point in time.
the dataset and the scripts are available in our experiment repository.
table shows descriptive statistics of our dataset.
the projects have been active for periods ranging from five months to months years and months with most of them in the range .5months 1st qu.
to .5months 3rd qu.
.
the number of dependency trees analyzed for each project ranges from 2to819 median 1st qu.
3rd qu.
.
the table also reports number of direct dependencies in the oldest analyzed commit median 1st qu.
3rd qu.
and transitive dependencies median .
1st qu.
3rd qu.
.
the last two lines in the table give the number of direct dependencies in the most recent analyzed commit median 1st qu.
3rd qu.
and transitive dependencies median 1st qu.
.
3rd qu.
.
.
.
methodology for rq1 in rq1 we analyze the evolution of the number of bloated dependencies over time.
we start with a global analysis of the bloat trend in direct and transitive dependencies.
to do so we aggregate the total number of bloated dependencies in all projects on a monthly basis and compute the average values.
next we look at each project separately and assign a bloat evolution trend to each of them.
we represent the number of dependencies at each commit in a project as a time series.
let pbe a maven project bp b1 b2 ...bnrepresents a time series of length n. a time step in this series represents one commit that modifies the pom.xml ofp.
each biis the total number of bloated dependencies reported by depclean at the ith commit on the pom.xml .
we collect two series for each project for bloated direct and bloated transitive dependencies.
for each project p we determine the overall trend for the evolution of the number of bloated dependencies increase decrease or stable.
the following function over bpshows how we determine the trend for a project f bp inc ifslope lm bp bj bp bj bj dec ifslope lm bp bj bp bj bj stable if bi bp bi bi we notice that several projects do not have a monotonic trend in the number of bloated dependencies i.e.
the value increases and decreases at different time intervals .
to account for projects that have a non monotonic number of bloated dependencies we fit a simple linear regression model denoted as lm and determine the trend of the time series based on the sign of the slope of the regression line.
a project labelled as incis a project for which the sign of the slope is positive i.e.
the number of bloated dependencies increase over time.
a project labelled as decis a project for which the sign of the slope is negative i.e.
the number of bloated dependencies decreases over time.
if the number of bloated dependencies is the same across all the data points in the time series of a project we label it as stable .
.
methodology for rq2 in this research question we analyze the evolution of the usage status of the 469dependencies in our dataset.
given a dependency d d present in the dependency tree of a project p we collect the status of dat each analyzed commit see data collection section .
.
this provides a sequence of usage statuses for dand serves as the basis to determine the occurrence of transitional patterns between used and bloated statuses.
letvdbe a vector representing the history of usage statuses of dependency dacross the releases of a project where each release is ordered by its date.
we label the usage status of a dependency d asbif it is a bloated dependency or uif it is a used dependency.a longitudinal analysis of bloated java dependencies esec fse august athens greece virtual event .
.
.
.
.
.
.
.0usedbloated timedependency status figure example of a dependency analyzed over time.
it has a transition of usage status from used at version .
.
to bloated at .
.
rq2 .
the dependency has two subsequent updates after bloated at versions .
.
and .
.
rq3 .
figure illustrates a transition in the usage status of a dependency from used u to bloated b .
in this case the dependency is identified as used at the two first releases of the project then it becomes bloated at the third release and stays as such.
therefore the usage pattern for this dependency results in .
since we are interested in analyzing transitional patterns the consecutive elements of the same category in the vector can be compressed to a single status e.g.
the previous example is represented as .
in this research question we focus on analysing the occurrence of five transitional patterns and fluctuating .
in the cases where the usage status of a dependency flickers over time we consider the status of the dependency as fluctuating .
.
methodology for rq3 we conjecture that developers could save some maintenance efforts in the absence of bloated dependencies.
in this research question we investigate how many times developers update the version of dependencies that are in fact bloated.
this type of change in the pom.xml of a project is an unnecessary engineering effort that could be avoided.
we analyze two types of commits the commits where the developers update the version of the project to a new stable version e.g.
.
.
and the dependabot commits.
dependabot7 is a dependency management bot very active on github.
it creates pull requests that update the dependencies to remove known vulnerabilities.
dependabot was launched on may with support for ruby and javascript and now it is supporting more than ten languages including java since august .
we analyze dependabot commits because they only contain edits on the dependency versions in the pom.xml .
it provides a clean point of analysis to detect the impact of a dependency update.
and it allows us to study how many bloated dependencies are updated by developers as a result of the suggestion of automatic bots.
figure illustrates a typical case of a dependency that continues to be updated even after it becomes bloated.
the dependency is used by the project until version .
.
.
afterward the dependency is no longer used but it is still updated twice to version .
.
and then to version .
.
.
to answer this research question we consider the 230commits in our dataset that perform dependency updates in projects that have at least one dependabot commit.
we obtain the number of times a dependency is updated by a developer by dependabot and how many of those updates are performed on bloated dependencies.
for the dependency usage analysis we tag each dependency as used or bloated.
we count every time the version of a direct dependency is updated and we count separately the number of updates on bloated dependencies.
in the example of figure we count one update on a used dependency when the used dependency is updated to version .
.
and two updates on a bloated dependency when the bloated dependency is updated to version .
.
and version .
.
.
using this approach we can compare the ratio of updates made by developers and by dependabot.
.
methodology for rq4 in this research question we investigate the origins of bloated dependencies.
each time a bloated dependency appears for the first time in a project s history we first determine if it was used in the commit that immediately precedes the apparition of bloat.
if the dependency was used in the previous commits we determine in which class it was used.
by analyzing a dependency at the time it appears as bloated we can identify what causes the emergence of bloat.
we have identified four different situations new dependency nd the bloated dependency was not present in the previously analyzed commit.
it indicates that the dependency was introduced in the project but never used.
removed code rc the bloated dependency was present in the previously analyzed commit and all the classes where the dependency was used are removed.
updated code uc the bloated dependency was present in the previously analyzed commit yet at least one class where the dependency was used is still present in this commit.
it means that the code has been updated to remove the usage of the dependency but the pom.xml still contains the dependency.
new version nv the bloated dependency was present in the previously analyzed commit and the version of the dependency changed.
in the case of transitive dependency the parent dependency has been updated and the project does not use the transitive dependency anymore.
for each of the 515dependency trees we identify the bloated dependencies.
then we check the status of the dependency in the previous commit.
if the dependency is not present in the previous commit we consider the origin as nd.
otherwise we check in the previous commit in which classes the bloated dependency is used.
we then compare those classes with the new commit.
if all classes are removed we consider the origin of the bloat as rc.
if at least one of the classes is still present we consider the origin of the bloat as uc.
additionally we compare the version of the bloated dependency with the previous commit.
if the version changes and at least one class is still present we mark the origin as ucandnv since both reasons could be the origin of the bloat.
results in this section we answer the four rqs presented in section .
.
.
rq1.
bloat trend in this research question we analyze the evolution of the number of bloated dependencies over time.
we hypothesize that this number tends to grow.
following the protocol described in section .
we analyze the usage status of each dependencies in 515dependency trees along the history of 435projects as reported by depclean .
we assign bloat trend labels to each project according to the three categories defined in section .
.esec fse august athens greece virtual event c sar soto valero thomas durieux and benoit baudry figure shows the monthly evolution trend of the number of bloated direct and bloated transitive dependencies from january to november .
the y axis is the average number of bloated dependencies of the 435projects.
each data point represents the average of bloat measured each month.
the lines represent linear regression functions fitted to show the trend of bloated direct and bloated transitive dependencies at a confidence interval.
we observe that bloated transitive dependencies have a clear tendency to grow over time whereas bloated direct dependencies grow at significantly lower pace.
for example the number of bloatedtransitive dependencies in was and by the end this number grew up to increase .
the bloat is more pervasive and variable sd .
among transitive dependencies representing a larger share in comparison with direct dependencies that are less numerous and less variable sd .
.
we conclude that overall the amount of bloat increases being more notable for transitive dependencies.
date avg.
of bloated dependencies dependency bloated direct bloated transitive figure trend of the average number of bloated direct and bloated transitive dependencies per month.
figure shows an overall growing trend for the number of bloated dependencies.
now we look in more details at each project separately.
we count the number of projects that have different trend of bloated dependencies.
figure shows examples of time series of projects in our dataset for which the bloated direct dependencies are labelled according to each category increasing decreasing and stable .
the name of the projects correspond to the user repository on github.
the x axis is the date of the analyzed commits.
the y axis represents the number of bloated dependencies detected.
for instance the time series of the project zapr oss druidry has a total of 51commits on the pom.xml i.e.
data points in the time series and it is labelled as incw.r.t.
to both the direct and transitive dependencies because both series tend to continuously increase over time.
figure shows the distribution of the trend of bloated direct and bloated transitive dependencies.
the x axis indicates the number of projects with bloated direct dependencies in each specific evolution trend given on the y axis.
each bar in the plot is partitioned in three parts that correspond to the share of projects with a given trend for the number of bloated transitive dependencies.
for example the top bar of figure shows i that the number of bloated direct dependencies tends to increase for .
projects and ii among these 245projects 180also have a number of bloated transitive dependencies that tends to increases 59of these projects have a decreasing number of bloated transitive dependencies and 6projects have a stable number of bloated transitive dependencies.
the bar in zapr oss druidry sonian elasticsearch je y percy percy java selenium bloated direct trend inc dec stable date bloated transitivefigure example of projects in the three classes of bloat trend defined in section .
.
the middle of the figure indicates that the number of bloated direct dependencies tends to decrease for .
projects and the bottom bar shows that this type of bloat is stable for .
projects because no new bloated dependencies are introduced in thepom.xml .
looking at the partitions of each bar in figure we first observe that whatever the trend for the number of bloated direct dependencies the number of bloated transitive dependencies can evolve in any way.
yet the majority of projects have an increasing number of bloated dependencies among their transitive dependencies.
in total .
projects have an increasing number of bloatedtransitive whereas for .
projects this number decreases.
the number of projects with stable transitive dependencies .
is relatively low.
interestingly from the 84projects with a stable number of bloateddirect dependencies .
of the bloated transitive dependencies increase and .
decreases e.g.
as in the project percy percy java selenium in figure .
this result indicates that the usage status of dependencies change regardless of the modification of the pom.xml .
the transition from used to bloated in transitive dependencies becomes unnoticed.
in other words even if developers update only the version of direct dependencies without anything else then the bloat grows naturally due to the inflation of the rest of the dependency tree.
it happens for example stable dec inc projects bloated direct trend bloated transitive trend inc dec stable figure distribution of the number of projects with increasing decreasing and stable trend of bloated direct and bloated transitive dependencies.a longitudinal analysis of bloated java dependencies esec fse august athens greece virtual event in the project jpmml jpmml sparkml when a developer updates spark mllib 2. from version .
.
to .
.
introducing new transitives dependencies.
on the other hand we observe that for .
out of the projects with a decreasing number of bloated direct dependencies the number of bloated transitive increases.
it indicates that even in projects for which direct dependencies decreases the number of bloated transitive dependencies can increase and eventually lead to a global growth of bloated dependencies for the project.
answer to rq1 the number of bloated direct dependencies and bloated transitive dependencies increases over time for .
and65.
of the projects respectively.
this result suggests that bloated dependencies tend to naturally emerge and grow through software evolution and maintenance.
.
rq2.
usage patterns this research question addresses an essential concern when developers think about removing bloat is a piece of software identified as bloat at one point in time prone to usage in future revisions?
we answer this question through a post mortem analysis of the transitioning in the usage status of dependencies across the evolution of the studied projects.
our hypothesis is that dependencies do not change their usage status very frequently i.e.
a dependency that is used in one commit is used in future commits and similarly for bloated dependencies.
if our hypothesis holds then it indicates that developers can be more confident when removing bloated dependencies.
we analyzed the five usage patterns described in section .
.
?
?
shows one concrete example for each pattern.
the examples are taken from our dataset and the patterns are illustrated on the period january to december .
the y axis shows the name of the direct dependency with the pattern in square brackets.
for example we analyze the usage status of the direct dependency h2in the project dieselpoint norm from may to october .
as we can observe this dependency was always reported as bloated.
on the other hand the dependency json in project paxstore paxstoreopenapi java sdk was reported as bloated in first four analyzed commits september to november and then it was used in all the subsequent releases of the project.
figure shows the distribution of the five transitional usage patterns among the 987direct and 442transitive dependencies in our dataset.
the x axis represents the percentage of occurrence of each pattern with respect to the total.
the top bar of the plot indicates that .
of the direct dependencies are used through their whole lifespan whereas .
are always bloated.
this means that94.
of direct dependencies never change their status through the evolution of the software projects.
this also means that most bloated direct dependencies are bloated by the time they are added in the dependency tree and are likely to remain bloated forever.
we conjecture that this happens as a side effect of some development practices such as copy pasting of pom.xml files the use of maven archetypes or the deliberate addition of dependencies when setting up the development environment.
the bottom bar of the plot shows a similar stability for the status of transitive dependencies .
of transitive dependencies do not change their usage status over their lifespan.
a key difference hereis that most of the dependencies are always bloated .
of the transitive dependencies are bloated from the start whereas .
are always used.
we hypothesize that most transitive dependencies are unnoticed by the developers.
consequently they are not managed and stay in the dependency tree for no reason in most cases.
guava json h pmime h2 commons lang date dependency usage status u b figure example of direct dependencies with distinct usage patterns.
each dependency belongs to a different project the status of the dependency is analyzed at each commit that changes the pom.xml of the project.
a key motivation for this research question is to determine whether a dependency identified as bloated is likely to stay bloated.
we compute the percentage of dependencies bloated from the start b or that remain bloated after being used ub with respect to the total number of dependencies that are bloated at some point in the future i.e.
b ub b ub bu fluctuating .
we find that .
of bloated direct dependencies and .
of bloated transitive dependencies remain bloated over time.
.
.
.
.
.
.
transitive direct percentage of occurrence dependency type pa ern b u bu ub fluctuating figure percentage of occurrence of usage patterns of bloated direct and bloated transitive dependencies.
answer to rq2 the usage status is mostly constant over time .
of the direct and of .
of the transitive dependencies do not change status through their lifespan i.e.
they are either always used or always bloated.
when a dependency is detected as bloated it stays bloated in .
of the cases if it is direct and .
if is transitive.
this indicates that developers can confidently take a debloating action when detecting bloated dependencies.
.
rq3.
unnecessary updates in this research question we investigate how the update of dependencies a regular maintenance practice for all software projects more and more encouraged by automatic bots relates to bloatedesec fse august athens greece virtual event c sar soto valero thomas durieux and benoit baudry .
.
direct dependency updatesdevelopers updates on used dependencies developers updates on bloated dependencies figure number of updates made by developers on direct dependencies in projects that use dependabot.
.
.
direct dependency updatesdependabot updates on used dependencies dependabot updates on bloated dependencies figure number of updates made by dependabot on direct dependencies in projects that use dependabot.
dependencies.
we hypothesize that developers invest some effort in updating some of these dependencies while this is not required.
to verify this hypothesis we count how many times bloated direct dependencies are updated in the pom.xml and compare it to the number of updates of used direct dependencies.
the methodology for this count is described in section .
.
we analyze separately the updates performed manually by developers and the updates suggested by dependabot that are eventually accepted by a developer.
figures and present our main results for this research question.
those plots present the number of dependency updates on direct dependencies made by developers and by dependabot respectively.
we focus on the 143projects in our dataset that have at least one dependabot commit.
all the projects do not use dependabot since its java support is relatively recent august .
the total number of updates on direct dependencies in these projects is15 of which 062have been performed by humans and 168have been suggested by dependabot.
figure shows that over a total of 062updates on direct dependencies made by developers .
are preformed on used dependencies and .
are made on bloated dependencies.
these 659unnecessary updates represent a significant effort as updating dependencies is a non trivial maintenance task .
figure shows the number of updates on direct dependencies made by accepting a suggestion from dependabot.
from figure .
of dependabot updates are performed on non bloated dependencies and .
on bloated dependencies.
overall we observe that developers perform a significantly larger number of dependency updates than dependabot.
yet the most interesting fact is that developers and dependabot perform the same ratio of updates on bloated dependencies .
and22.
respectively.
the consequences of updating a bloated dependency are not only about the time and effort wasted by the developer.
we have observed that a possible side effect of these unnecessary updates is the increase of the total number of bloated dependencies in the project.
in rq1 we showed that the number of bloated dependenciesincreases over time with a strong trend for transitive dependencies.
in fact a portion of this increasing transitive bloat is introduced through the update of direct dependencies i.e.
the new version has more dependencies.
note that this scenario can happen even when updating a bloated direct dependency.
we have observed this phenomenon in our dataset.
the 091updates on bloateddirect dependencies have introduced 883new bloated transitive dependencies.
answer to rq3 .
of developer updates and .
of dependabot accepted updates are performed on bloated direct dependencies which represents a total of 091updates over 143projects.
this is novel evidence that software bloat artificially increases maintenance effort and that dependency bots need to be improved to detect bloated dependencies.
.
rq4.
bloat origin in this research question we investigate what type of maintenance activity is at the origin of bloat emergence.
in other words we perform an in depth analysis of the usage patterns bandubpresented in rq2 by categorizing the origin of the bloat in four possible activities new dependency nd removed code rc updated code uc and new version nv as described in section .
.
table summarizes the number of occurrences of activities that introduce bloat for direct and transitive dependencies.
in total we analyze the dependencies that become bloated at some point in time directs 442transitives and determine in what condition they become bloated.
this corresponds to 215and34 071transitions to bloat on direct and transitive dependencies respectively.
we observe that the primary origin of bloat is the addition of new dependencies nd with .
such additions that lead to more bloated direct dependencies and .
new dependencies that introduce more bloated transitive dependencies.
this result confirms our findings in rq2 where we observed that the status of most dependencies does not change over time which hinted to the fact that bloated dependencies are bloated as soon as they appear in the dependency tree.
additionally the larger number of ndthat grow the number bloated transitive dependencies is consistent with the results of rq1 where we showed a larger increase of bloated transitive dependencies than bloated direct ones.
this new result consolidates the finding with the root cause of the transitive bloat.
the second most frequent origin of bloated dependencies is different for direct and transitive dependencies.
the action of removing code rcis the second most frequent cause of the emergence of bloated direct dependencies with of the cases.
updating code ucis the second most important root cause for bloated transitive dependencies.
while these two actions are similar in nature evolve the code base we did not find a clear explanation for the difference between the types of bloated dependencies.
updating to a new version of a dependency nvis the least frequent cause of bloat emergence.
the rarity of this cause is explained by the fact that it can only happen in very specific conditions when the new version of the dependency changes drastically.
we now illustrate the different situations of bloat introduction with real world case studies observed in our dataset.
the mosta longitudinal analysis of bloated java dependencies esec fse august athens greece virtual event table number of occurrence for each origin of bloat.
the occurrences are separated between the new bloated direct and transitive dependencies.
origin bloated direct bloated transitive new dependency nd .
.
removed code rc .
.
updated code uc .
.
new version nv .
.
frequent cause of bloat introduction is a new transitive dependency in the dependency tree nd which is never used.
for example this happens in the project couchbase couchbase java client at the commit 47ac44 where the dependency jackson databind which is induced transitively when encryption .
.
has been added to the pom.xml .jackson databind is used in the class hashicorpvaultkeystoreprovider which is never used by the couchbase couchbase java client and therefore jackson databind is a bloated transitive dependency in this project.
this case occurs with direct dependencies as well.
for example the direct dependency jackson core is added as a direct dependency in the pom.xml of project jenkinsci elasticbox plugin at commit .
yet the dependency is never used in the code of the project.
one year and months later a pull request fixes the bloat issue by removing the dependency directly.
however at the time of writing this paper the pull request has not been merged.
projects are evolving adding and removing code is part of the life cycle of a project.
a consequence of code removal can be to eliminate the need for a dependency.
yet developers currently have no tool support to determine that a dependency can also be removed as part of their maintenance activities.
consequently the dependency is likely to become bloated rc .
for example we observed that scenario happens in the project apache commons lang.
the commit def3c4 introduces the dependency bcel which contains annotations to document thread safety.
however the commit 796b05 removes all classes where these annotations were used.
according to the commit more discussions were needed to design the annotation and the maintainers reverted partially the changes to release a new version.
a developer removed the bloated dependency after five months see commit 66226e .
a similar scenario occurs when developers update classes uc .
for example the commit 62aad3 introduces the annotation ignore jrerequirement on a method in the project jenkinsci remoting.
however this method is updated and deprecated in the commit 49c67e.
the annotation ignorejrerequirement is removed and the dependency animal sniffer annotation became bloated.
the project apache commons dbcp contains an interesting case of bloat introduced when a dependency is updated nv .
in the commit 3550ad the direct dependency geronimo transaction is detected as bloated.
however this dependency was not bloated in the previous commit d7aa66 when the project was using the version1.
beta ofgeronimo transaction .
the dependency was updated to version .
.
with commit 3550ad.
this new version brought major changes in the dependency and in .
.
all the classes used by the project had been move in a transitive dependency of geronimo transaction .
therefore the direct dependency towards geronimo transaction became bloated.answer to rq4 the addition of new dependencies is the root cause of the emergence of .
of the bloated direct dependencies.
still .
of the cases appear after code updates or removals.
this indicates that new dependencies should be carefully reviewed the first time they are added and we recommend developers to check the usage status of dependencies when removing code.
implications our findings provide practical empirically justified implications for improving dependency management .
the results of rq1 and rq2 show that bloated dependencies are likely to remain bloated in the future.
this is empirical evidence that can motivate developers and increase their confidence when they are faced with the opportunity to remove bloated dependencies.
motivation comes from the benefits associated with reducing the number of dependencies of the project and hence reduce associated maintenance activities.
confidence comes with the strong likelihood that the dependency that is removed will not be necessary in the future.
our results show that there exist many practical difficulties related to the way of handling software dependencies.
this can raise the awareness of developers about the importance of understanding what dependencies are more likely to become bloated and how their projects can reduce the size of dependency trees without breaking the build.
in particular the use of tools such as depclean to automatically detect and suggest changes in the build files can contribute to a better awareness of developers about the state of their dependencies.
for example we recommend to include a bloat analysis before release to ensure that no bloat is shipped and deployed.
this is for reducing the size of the released binary and for all projects that depend on it i.e.
the number of transitive dependencies will be reduced.
in rq3 we present original results of the negative impact of bloated dependencies on the maintenance of the projects.
in particular we shed a new light on the limitations of dependency bots such as dependabot and provide evidence that developers accept bots suggestions when updating dependencies without checking if the dependency is actually used.
bot creators should consider improving their tools to automatically detect bloat and suggest the removal of unused dependencies.
on the same line compilers and ides should also warn developers when dependencies are not used anymore and when a dependency is introduced without encountering its counterpart usage on code.
our dataset and our case studies on the origin of bloat provide valuable