a little goes a long way tuning configuration selection for continuous kernel fuzzing sanan hasanov university of central floridastefan nagy university of utahpaul gazzillo university of central florida abstract the linux kernel is actively developed and widelyused.
it supports billions of devices of all classes from highperformance computing to the internet of things in part because of its sophisticated configuration system which automatically tailors the source code according to thousands of user provided configuration options.
fuzzing has been highly successful at finding kernel bugs being among the top bug reporters.
since the kernel receives 100s of patches per day fuzzers run continuously stopping regularly to rebuild the kernel with the latest changes before restarting fuzzing.
but kernel fuzzers currently use predefined configuration settings that as we show exclude the majority of new patches from the kernel binary nullifying the benefits of continuous fuzzing.
unfortunately state of theart configuration testing techniques are generally ill suited to the needs of continuous fuzzing excluding necessary options or requiring too many configuration files to be tractable.
we distill down the needs of continuous testing into six properties with the most impact systematically analyze the space of configuration selection strategies and provide actionable recommendations.
through our analysis we discover that continuous fuzzers can improve configuration variety without sacrificing performance.
we empirically evaluate our discovery by modifying the configuration selection strategy for syzkaller the most popular linux kernel fuzzer which subsequently found more than twice as many new bugs vs. than with the original configuration file and 12x more vs. when considering only unique bugs with one security vulnerability being assigned a cve.
i. i ntroduction operating system kernels are among the most important layers of modern computing stacks and the linux kernel is one of the most actively developed and widely used kernels used for web servers internet of things devices mobile phones supercomputing servers and more .
linux supports so much variety because it is a highly configurable software product line .
it has over configuration options controlling architecture memory management scheduling file systems and much more.
users tailor the kernel to their needs by passing configuration options to its build system automatically customizing the kernel .
the linux kernel s position in the global computing stack makes it a high value target with vulnerabilities routinely selling for millions of dollars .
efforts to proactively find and fix kernel vulnerabilities have embraced fuzzing an automated software testing technique that uncovers software bugs through the generation of massive amounts of random test cases.
kernel fuzzers feed random inputs to various kernel interfaces such as system calls or device specific i o channels .
modern kernel fuzzers are fast precise and support many interfaces .google s syzkaller has found nearly vulnerabilities in the linux kernel alone and is consistently among the top reporters of kernel bugs .
the linux kernel receives hundreds of changes daily in the form of code patches .
to accommodate this rapid change the syzbot test robot runs syzkaller continuously during kernel development.
while fuzzing success depends on running for as long as possible to maximize test coverage syzbot must regularly stop fuzzing and update its kernel to incorporate the latest changes otherwise it risks missing new bugs introduced during development.
to balance this tradeoff syzbot aims to run syzkaller for hours before stopping to pull new changes and recompile the kernel .
yet the kernel is highly configurable so whether code changes are compiled in depends entirely on whether the configuration file chosen by syzbot includes them.
but current configuration file selection strategies for kernel fuzzers exclude most code changes .
for instance syzkaller uses a small number of pre selected configuration files builds each kernel variant and fuzzes the variants separately.
fuzzing only a few configuration files is a reasonable strategy since continuous fuzz testers already have limited time to run before developers commit new changes.
moreover fuzzers have specific requirements for configuration selection they need to enable the kernel bug detectors such as address sanitizers and they must enable options required for booting kernels for them to fuzz.
to set the thousands of other options testers use linux s default configuration file to provide a minimal bootable kernel as a starting point .
prior work however shows that linux s default configuration file excludes almost of code changes from the compiled binary nullifying the effectiveness of continuous fuzzing.
unfortunately state of the art configuration generation techniques are generally ill suited to the needs of continuous fuzzing.
random configuration files are rarely bootable iv leave up to of kernel source code unreachable for fuzzers and are unlikely to cover patches .
t wise sampling and combinatorial interaction testing ensure coverage of feature interactions but generate thousands of configuration files which would require fuzzers to continuously build and test thousands of kernel binaries simultaneously instead of just a few an unrealistic increase in resource requirements.
maximal configuration approaches attempt to build as many source lines as possible with a small number of configuration files but can be toolarge to boot may fail to build and require hours of build time wasting limited time for fuzzing.
configuration repair modifies existing configuration files to ensure patch coverage potentially helping continuous fuzzers avoid excluding recent changes.
but being relatively new configuration repair has only been applied to default configuration files for compile testing not continuous fuzzing.
the key challenge is that configuration selection for continuous fuzzing has two conflicting goals fuzzer performance and configuration variety .
for performance fuzzers want to use few configuration files so the fuzzer can test for as long as possible on the same binary.
but for variety they want to use many configuration files so that the fuzzer test can a larger variety of code in the kernel.
current kernel fuzzers emphasize fuzzer performance at the expense of configuration variety which leads to missed opportunities to test most recent code changes and alternative variations of the kernel.
to help mitigate the challenge of continuously fuzzing highly configurable software we survey the space of configuration testing techniques and systematically analyze their impacts on continuous fuzzing.
we identify six key properties of configuration testing strategies that impact a continuous fuzzer s performance resource utilization patch coverage and ability to boot and run on the kernel.
based on our analysis we create several recommendations for fuzz testers to select a configuration file based on their needs.
notably we show how continuous fuzzers can improve bug finding capabilities without sacrificing performance or increasing resource utilization by using configuration repair to modify the configuration files used to build the kernel all with no engineering changes to the fuzzer itself.
to the best of our knowledge no systematic analysis of configuration selection for continuous kernel fuzzers has been conducted previously and used to improve to their bug finding capabilities.
we empirically evaluate our discovery by modifying syzbot s configuration selection strategy to include configuration repair.
we emulate syzbot s test infrastructure and compare syzkaller s bug finding capability and performance with and without configuration repair.
our experiments show a substantial impact on the number of previously unreported bugs with no significant impact on performance.
with the modified configuration selection strategy syzkaller found more than twice as many previously unreported bugs vs. than with syzkaller s original configuration files although of these were found by both approaches.
when considering only unique bugs the new approach finds 12x more previously unreported bugs vs. .
we reported all new bugs found and are working with linux developers to fix them.
as of writing have been acknowledged have been patched.
one bug exposed a security vulnerability that was assigned a cve .
in this paper we make the following contributions we replicate prior patch coverage results on syzkaller s configuration selection tool and show it fails to build more than half of a sample of recent patches iii .
we study configuration selection strategies identify the key properties that impact continuous fuzzing and provide recommendations for testers iv .
we modify syzkaller s configuration generation to include configuration repair and compare its new bug finding and performance results with and without repair v .
we reported previously unreported kernel bugs to linux developers and one security vulnerability vi .
ii.
b ackground this section provides an overview of kernel fuzzing and kernel configurability.
a. coverage guided kernel fuzzing fuzzing is one of today s most successful software bug discovery techniques having found thousands of bugs and vulnerabilities in numerous applications kernels and other computing systems.
given a software target fuzzers operate by generating massive amounts of random test cases and executing each on the target leveraging lightweight program introspection to detect interesting test case induced program states e.g.
crashes time outs or invariant violations .
most fuzzers today are coverage guided instrumenting the target to report the code coverage of all test cases but saving and subsequently mutating only the minority that reveal new code coverage.
popular coverage guided application fuzzers include afl and libfuzzer .
with the success of application fuzzing many efforts are extending coverage guided fuzzing to os kernels.
like application fuzzers kernel fuzzers operate by feeding test cases to the kernel s various input vectors general purpose system calls driver specific i o control handlers or the hardware kernel memory boundary e.g.
memorymapped i o port i o direct memory access .
by far today s most popular kernel fuzzer is google s syzkaller which has found over bugs in numerous kernels such as linux freebsd openbsd and android.
many academic and industrial efforts are continuing to improve syzkaller to attain higher speed generate more precise inputs and find non trivial classes of bugs .
b. highly configurable os kernels table i recent operating system kernels and their configuration specification languages alongside their estimated total configurable features.
we compute each by searching for configuration option names in their respective configuration specification languages.
kernel config.
language approx.
configs android kconfig freebsd config linux kconfig netbsd config openbsd config xnu config modern os kernels are veritable software product lines codebases intentionally developed to be compilable as a multitude of unique variants .
for everyday kernels variants often take on the form of os specific distributions e.g.
ubuntu and debian which are derived from the linux kernel .
however the highly configurable nature of today s kernels enables fine grained control over virtually all build characteristics from toggling on specific features e.g.
tls ipv6 the desired target architecture e.g.
arm x86 security mechanisms e.g.
k aslr kasan and much more.
1config werror y always installed.
2config sysvipc n never installed.
3config audit m optional module.
listing an example synthetic k config feature configuration.
to enable modular configuration today s kernels are often equipped with feature modeling systems .
table i shows the feature modeling systems and approximate feature counts for various commodity kernels with the most popular being kconfig .
at a high level a k config configuration governs any number of kernel features with each represented as config feature y always installed n never installed m an optional loadable module .
listing displays a synthetic example of a k config kernel configuration.
while facilitating a seemingly endless number of configurations is important for maintaining broad deployment flexibility subtle interactions between kernel features often bear unforeseen consequences.
in many cases specific feature combinations create unbootable or otherwise unusable builds while others introduce obvious security flaws known as misconfiguration bugs .
the configurability of kernels complicates fuzzing because testers must first choose a configuration file to compile the kernel binary.
but the configuration file determines what source code is included in the binary.
with so many possible options ensuring the binary even has the desired code to test is non trivial much less ensuring the code is tested.
iii.
p atch coverage of fuzzer configuration files a study of configuration repair for patch coverage found that commonly used configuration files for testing exclude most patches to the kernel codebase .
configuration repair in this context refers to a technique that automatically modifies a configuration file to change what code the configuration file covers.
for instance krepair takes a linux kernel patchfile or any set of files and lines and a configuration file and automatically discovers and applies changes to the configuration file so that the code in the patchfile is covered when building the repaired configuration file.
since kernel configuration files are applied at build time any code not covered is excluded from the kernel binary.
for continuous fuzzers when a configuration file it uses to build a kernel excludes patched code no matter how much run time coverage the fuzzer is able to achieve it will never be able to cover the patches excluded during the build.
yet including large amounts of code results in unbootable or slow kernels .
prior work evaluating coverage limitations of configuration files used in testing only evaluated linux s default configuration defconfig .
but syzkaller and other fuzzers add syzkallerkafl defconfig020406080100patch coverage .
.
.
.
.
.
original repairedfig.
average patch coverage of syzkaller kafl and defconfig.
.
additional configuration options to defconfig potentially leading to more code included in the kernel binary than with defconfig .
to evaluate how much code kernel fuzzers include we replicate the prior configuration file patch coverage experiment by modifying its artifact .
instead of defconfig we evaluate the configuration files from two popular kernel fuzzers syzkaller and kafl to see how much patched code they omit.
our modified scripts are available in our publicly available artifact .
to compare to existing work we use an identical experimental setup.
as previously reported there are randomlyselected patches from a whole year of linux kernel development which provides a margin of error with a confidence level .
we use syzkaller s own configuration generation tool syz kconf on the committed version of the kernel for each patch.
kafl in contrast provides a fixed configuration file which we use for each committed version of the kernel.
figure shows the results of replicating the patch coverage experiments on syzkaller and kafl s configuration files in the first two bar groups.
the last bar group is patch coverage results for defconfig as taken from the original study.
the y axis is the average patch coverage across all patches.
for each bar group the first bar is the original configuration file s average patch coverage.
the second is the patch coverage after applying configuration repair with the krepair tool .
the error bars represent the confidence interval of the average.
prior work showed defconfig only covers .
of patched code on average while after applying krepair the resulting configuration file covered .
.
comparatively syzkaller s syz kconf covers more .
although it is still less than half of patched code.
kafl s configuration file however is similar to defconfig with .
patch coverage.
krepair increases patch coverage to .
for both syzkaller and kafl.
the error bars show the patch coverage averages of the sample demonstrate a statistically significant improvement to patch coverage the repaired configurations are over inall three cases with a very small margin of error.
although we evaluate syzkaller only in this paper given the improvements of patch coverage for both syzkaller and kafl we expect the results to apply to kafl and other kernel fuzzers.
summary popular kernel fuzzers select configurations that exclude the majority of patched code counteracting the benefits of continuously fuzzing updates to the kernel codebase.
iv.
c onfiguration selection strategies for continuous kernel fuzzing we first discuss existing configuration selection techniques and weigh their trade offs with respect to continuous kernel fuzzing.
next we distill the needs of configuration selection for continuous fuzzing into six properties and analyze each technique across these categories.
finally we provide recommendations for configuration selection strategies to guide designers of continuous fuzzing platforms for picking the best strategy or combinations of strategies for their goals.
a. configuration testing techniques there are many techniques for generating configuration files for testing each of which achieves specific testing goals.
we categorize them into seven groups of techniques.
hand selected configurations aim to customize kernels for unique deployments.
for instance syzkaller and kafl define hand selected configurations enabling options required for booting their respective test infrastructure .
as shown in iii these configurations exclude most patches making them insufficient for continuous testing of kernel changes.
default configurations are configurations shipped with the linux kernel and serve as the basis for building customized hand selected configuration files .
they are small enabling relatively few features.
minimal configurations disable as many features as possible.
minimal configurations can be used as a fast building sanity check recommended for instance in the linux patch submission guidelines .
maximal configurations enable as many features as possible to build as much code as possible though not necessarily all e.g.
linux s allyesconfig enables about of the codebase .
commonly used for build testing maximal configurations have also been used for static analysis and testing .
maximal configuration have little variety since the goal is maximizing coverage not feature interactions.
random configurations in contrast are created by randomly assigning options to be either enabled or disabled such as with the linux kernel s randconfig tool .
randomly generated configurations we find are not usually bootable but they are used for build testing and static analysis .
interaction testing approaches improve on random testing by maximizing coverage of feature interactions i.e.
combinations of configuration options.
many algorithms have been developed for this purpose including t wise sampling and combinatorial interaction testing .
these algorithms are effective at testing a wide variety of configurations but theyalso require testing a very large number of configuration files making them less suited to continuous fuzzing.
configuration repair is not a configuration generation technique per se but a technique to automatically modify existing configuration files.
configuration repair has only been applied to default configuration files to ensure patch coverage but the approach theoretically works to modify any configuration file.
repair can preserve most options from the original file giving it the potential for preserving a continuous fuzzer s required options for booting and testing a kernel.
b. considerations for continuous fuzzing prior configuration testing techniques have been applied to a range of software analyses including running tests build testing and static analysis.
to our knowledge prior work has not explicitly addressed the needs of continuous fuzzing which has several unique properties distinguishing it from other testing techniques.
bootable fuzz testers that rely on executing tests need the kernel to be bootable on the test infrastructure.
otherwise the kernel cannot be tested.
required options kernel fuzz testers rely on the kernel s own bug detectors to report certain warnings such as address sanitizers.
these bug detectors are enabled via configuration options .
if not present the fuzzer cannot identify bugs.
patch coverage as prior work and our replication study shows current continuous fuzzing approaches which use hand selected configuration files miss the majority of patched code contravening the core goal of testing continuously on new code changes.
fuzzers require at least configuration settings that include new code changes into the kernel binary for continuous testing.
few files fuzzing depends on high test execution throughput to cover as much of a codebase as possible so fuzzers are typically left to run for as long as feasible hours days or even weeks at a time.
this need complicates configuration testing because many prior techniques such as feature interaction testing depend on generating and testing thousands of configuration files for highly configurable software like linux each of which needs to be fuzzed individually for as long as possible.
therefore configuration testing strategies for continuous fuzzers are restricted to producing few configuration files in to preserve the resource utilization of the current practice of using a single hand selected configuration file.
variety while fuzzers may not be able to add much configuration variety to testing each new version of the kernel they can still add variety by altering the configuration file between runs on new versions.
as abal et al.
reveal modernday os kernels such as linux contain a significant number of security vulnerabilities dependent on multi feature interactions.
for example table ii showcases recent configurationdependent vulnerabilities in the linux kernel found in the cve database their assessed severity and their respective configuration features.
for example reaching vulnerabilities cve and cve require the exclusion of kernel features xen balloon memory hotplug andtable ii recent configuration dependent vulnerabilities and their relevant configuration features.
features in red were not present in any kernel configurations fuzzed by syzkaller at the time the vulnerability was reported.
cve severity kernel configuration features cve .
med vmap stack cve .
high ipvlan cve .
high tls xfrm espintcp cve .
high !module sig cve .
med !xen balloon memory hotplug xen unpopulated alloc cve .
high bpf bpf syscall cgroups cgroup bpf !hardened usercopy cve .
med crypto user cve .
high debug vmvmacache cve .
high vmap stack cve .
high strict devmem hardened usercopy respectively.
therefore kernel fuzzing if it hopes to uncover such configuration dependent bugs needs at least some variety in its configuration file selection.
fast build critical to a fuzzer s bug finding effectiveness is its ability to maintain a high test case throughput requiring each component of the fuzzing loop to be as optimized as possible.
application level fuzzers like afl and libfuzzer have long benefited from performance enhancements in their code coverage tracing and process execution steps which make up the two most timeconsuming components of application fuzzer designs .
unfortunately current kernel fuzzers have significantly more complex components relying on virtualized and or emulated environments to runthe kernel that cannot easily be decomposed and optimized for higher fuzzing speeds.
yet compared to application fuzzers kernel fuzzers aim to fuzz software that is substantially larger in size for example the linux v6.
kernel is upwards of over half of a gigabyte large.
larger kernel configurations create larger kernel builds placing higher resource strain on a fuzzer s virtualization and emulation infrastructure.
therefore kernels using smaller kernel binary have the potential for better performance and also require less time to build saving more time for fuzzing.
c. recommendations for configuration selection table iii summarizes the impact of configuration testing techniques on continuous fuzzing across the six properties identified above one per column.
each row marks which properties each technique has.
considering bootability in our tests allyesconfig fails to boot in syzkaller s qemu based virtualization setup which is not surprising given prior works conclusions that it can be too large to boot or may even fail to build .
allnoconfig also failed to boot in our tests.
additionally generating randconfig s resulted in no bootable kernels.
defconfig is bootable but lacks the options required by the fuzzer which is why syzkaller s syz kconf tool adds additional options to defconfig .
three techniques remain hand selection interaction testing and repair.
hand selection fails to include changes most of the time iii nullifying the benefits of fuzzing continuously and also adding no configuration variety.
interaction testingrequires generating so many configuration files that only increasing the compute resources considerably would make it feasible.
moreover not all generated configuration files will be bootable or cover patches requiring manual effort to filter out unusable configurations.
computational resource requirements can be computed by by multiplying the number of configurations used by the resources needed by one fuzzing run.
resources needed for interaction testing are proportional to the number of unique configuration files it generates as each one requires building and fuzzing a separate kernel binary.
in contrast configuration repair does achieve patch coverage even with only a single repaired configuration file.
this avoids the computational resource burden of interaction testing and as our evaluation v shows generally preserves build time and the required options needed for fuzzing.
as a trade off to preserving configuration settings however it only adds relatively small amounts of variety though our evaluation shows a substantial impact.
we make the following recommendations for adding configuration testing techniques to continuous fuzzing repair hand selected configuration files for continuous fuzzing.
continuous fuzzers should use hand selected configuration files that have been repaired since this will use the same compute resources as hand selected but add the benefits of patch coverage and configuration variety.
use interaction testing if adding compute resources is viable.
for platforms willing to add considerable compute resources to support fuzzing many configuration files in parallel interaction testing can provide more variety than repairing hand selected configuration files.
use hand selected configurations when only concerned with a specific device.
for fuzz testers who only need to test a specific configuration of the kernel e.g.
device manufacturers who are only concerned with specific kernel features variety is unnecessary and a hand selected configuration file suffices.
use interaction testing if only concerned with a specific kernel version.
for fuzz testers only concerned with a specific kernel version i.e.
a long term release version continuous testing is not necessary.
instead the tester can add variety with interaction testing or random testing.
v. e valuation we evaluate the effects of applying our recommendation to use configuration repair for syzkaller s current hand selected configuration file approach.
we emulate syzbot s test infrastructure that runs syzkaller but modify syzbot s configuration generation process to include additional variety using the krepair configuration repair tool .
besides configuration selection all other design decisions are left in place.
we compare syzkaller s performance and bug finding capabilities with and without adding configuration repair.
a. experimental setup we first selected a set of previous syzkaller runs since the configuration files used are recorded in bug reports ontable iii a comparison of configuration selection strategies for the needs of continuous fuzzing selection strategy techniques bootable required opts patch coverage few files variety fast build repair krepair hand selected syzkaller kafl interaction testing t wise combinatorial default defconfig maximal allyesconfig vampyr minimal allnoconfig random randconfig syzkaller s reporting dashboard .
we took a sample of such configuration files from these previous bug reports.
then to get linux versions close to those that syzkaller was testing at the time of the report we check out one or more commits from the linux development tree from the time period given in the bug report that provided the configuration file for a total of unique commits.
the set of linux commit ids1 configuration files2 and urls of the bug reports from the syzbot dashboard3can be found in the publicly available artifact .
for each combination of configuration file and linux commit we ran syzkaller with and without the krepair modified configuration file.
to repair the configuration files we checked out each linux commit and used krepair to modify the original configuration file feeding the patch file that updated the version to the commit id i.e.
with git show as input to krepair.
we configured built and ran syzkaller twice for each commit configuration combination on the same commit ids once with the original configuration and once with the modified configuration files.
for both sets of configuration files we run syzkaller using the same virtualization settings as described in its documentation qemu with 4gb ram and virtual cpus per run and for the same amount of fuzzing time hours as described by the syzkaller developers on their mailing list .
all experiments were run on a server with a .25ghz amd epyc and 512gb of ram running ubuntu .
.
lts.
our publicly available artifact contains the experiment scripts used to run the experiments .
b. research questions to evaluate the impact of modifying syzbot s configuration selection we ask the following research questions.
rq1 bug discovery how does configuration repair affect bug discovery?
rq2 performance impacts how does configuration repair affect performance?
rq3 configuration variety how much configuration variety is introduced by configuration repair?
c. rq1 bug discovery to evaluate bug finding capacity we measure the number of alarms found by syzkaller in all runs both with and without 1icse25 master data tables table of all crashes.xlsx 2icse25 master camera ready configuration files 3icse25 master links to syzbot bug reports.txt repairedoriginal a all bugs found.
repairedoriginal b previously unreported bugs found.
fig.
bugs found by syzkaller using krepaired configuration files compared to the original configuration files.
the krepair modified configuration file.
since the same bugs are reported multiple times in the same run and across runs we deduplicate and aggregate the bugs found.
after deduplication syzkaller found bugs with the original configuration files and with the krepaired configuration files.
even though the same set of kernel versions and the same amount of total fuzzing time was used there was surprisingly little overlap in the bugs found when comparing the two configuration file selection approaches as shown by the venn diagram in figure 2a.
there were only bugs that were found by both approaches.
this suggests that additional configuration variety affected which bugs the fuzzer was able to find in the same amount of time.
to find previously unreported bugs we search by hand syzbot s bug reporting history for the same bug.
while both approaches found a similar number of bugs most of the bugs had been previously reported.
when considering only new previously unreported bugs syzkaller with configuration repair found considerably more new bugs compared to only with the original configuration files as shown in figure 2b.
moreover since new bugs were found by both syzkaller with configuration repair found unique new bugs compared to only with the original configuration files a 12x increase.
vi lists all new bugs found.
we analyzed the types of all bugs found by syzkaller withstallsdeadlockinteger underflow overflownull pointer dereferenceout of boundsuse after freegeneral protection faultbug on warning .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
repaired originalfig.
comparison of the distribution of bugs found repaired and original configuration files.
both the krepaired and original configuration files.
figure shows the percentage of bugs per category for the krepaired configuration files which yielded bugs and the original which yielded .
warnings are bugs caused by violations of assertions written into code by developers.
such bugs are reported as warnings because developers prefer to trigger a warning and continue running rather than a kernel panic to e.g.
ease debugging and recovery of the kernel although users may opt to panic on assertion violations .
bug on bugs are assertion violations that developers decide should panic the kernel .
general protection faults uses after free out of bounds accesses and null pointer dereferences integer overflow underflow stalls and deadlock are from various kernel sanitizer and bug reporting tools whose output is recognized by syzkaller.
the types of bugs found both with and without the krepaired configuration file are comparable as shown.
overall we observe that the majority of bugs found using the krepaired configuration with syzkaller are memory safety bugs which are highly relevant to kernel security.
a total of .
are classified as temporal memory use after frees .
and null pointer dereferences .
.
other memory safety errors include out of bounds accesses .
generic protection faults .
and integer related errors .
.
we also see that .
of found bugs fall under stalls or deadlocks which are also commonly exploited bug classes .
rq1 modifying the configuration selection strategy helped the fuzzer identify different bugs and more previously unreported bugs compared to the original configuration files.
d. rq2 performance impacts we evaluate the performance impacts of repairing configuration files before fuzzing by rerunning the steps of the bugfinding experiments measuring configuration generationtable iv five point summaries of kernel configuration time in seconds.
original configurations repaired configurations min .
.
25th .
.
median .
.
75th .
.
max .
.
table v five point summaries of kernel build times in seconds.
original configurations repaired configurations min .
.
25th .
.
median .
.
75th .
.
max .
.
time kernel build time and fuzzer throughput and coverage.
we randomly selected linux commits which can be found in the artifact to perform the evaluation and used the same original and krepaired configuration files used in the bug finding evaluation.
configuration times table iv summarizes the distributions of configuration times for both the original and krepaired configuration files.
to configure the kernel with an existing configuration file the user runs make olddefconfig which imports an existing configuration file checking it for consistency.
this process typically takes only seconds as shown in the five point summary for the original configuration.
for the krepaired configuration files we first run krepair on the configuration file before importing it which can take several minutes.
although the krepair time was not included in the hour fuzzing time in the bug finding experiments krepair time is very small compared to the typical fuzzing times.
build times table v summarizes the distributions of build times for the original and krepaired configuration files.
once configured we build each kernel parallelized with make j measuring its time.
given the small configuration files and high core count of the experiment machine build times were less than minutes in all cases.
fuzzer performance to evaluate fuzzer performance we measure test case test case throughput and total code coverage which are recorded by syzkaller.
test case throughput is the number of test cases generated and executed over the hours.
high throughput is desirable for fuzzing because it can increase the opportunities to find bugs.
total code coverage is the total number of basic blocks reached by any test case.
code coverage is critical to fuzzers aim of testing as much of the codebase as possible.
for comparing throughput we follow the procedure of prior fuzzing literature and report the total test cases i.e.
system call sequences executed per trial and for code coverage we report the fuzzer logged counts of kernel basic blocks reached.
we discuss our results below.
test case throughput figure 4a compares test case throughput for syzkaller with and without configuration repair for each fuzzing trial.
we posit that including more kernel code likely causes fuzzing to execute more kernel code at the cost of some throughput.
on average we observe that fuzzing onfuzzer runs02 000throughput of system call sequences executed repaired original a syzkaller throughput with the original and krepaired configuration.
fuzzer runs025 000coverage of blocks repaired original b syzkaller coverage with both the original and krepaired configuration.
fig.
comparing syzkaller performance before and after using krepair.
krepaired configuration files results in average throughput that is .
higher.
in of trials however syzkaller achieves a higher throughput with its original configuration file.
the krepaired configuration files only have an average of kernel more features than the original.
given the small amount of change made to the configuration files the throughput results do not reveal a marked difference in throughput between the original and krepaired configuration file.
code coverage high fuzzing throughput alone is not necessarily better for fuzzing if it is caused by repeatedly covering the same fast executing code paths.
coverage is just as important for reaching bugs.
we therefore also compare the code coverage of syzkaller with and without repaired configuration files.
following standard practice in fuzzing we measure code coverage in basic blocks.
figure 4b shows the per trial block coverage of syzkaller before and after using krepair.
in of trials syzkaller achieves slightly higher code coverage with its original configuration file.
yet for the remaining of trials syzkaller coverage is higher with the repaired configuration files and by larger margins.
overall table vi number of configurations options changed by krepair.
min 25th median 75th 90th max coverage averages .
more basic blocks than with the original configuration file.
with a higher average code coverage and throughput we can conclude that using krepair to modifying the configuration selection strategy does not harm the performance of fuzzing.
indeed the increase configuration variety and build coverage of code changes is likely the source of improved bug finding since it opens new code paths to exploration and provides evidence for why there was discovery of previously unreported kernel bugs in v c. rq2 fuzzing with repaired kernel configurations upholds similar fuzzing performance to the original unmodified configurations.
e. rq3 configuration variety we measure how much configuration variety using krepair introduces when ensuring patch coverage by counting the number of options in the configuration file before and after repair.
table vi shows the distribution of the number of options changed as a five point summary i.e.
quartiles the minimum and the maximum plus the 90th percentile to show how the vast majority of cases behave.
in most cases 90th percentile there were or fewer changed options representing a very small change in the configuration file.
while the maximum was options the kernel has over options available in the linux kernel representing less than a change in the file.
while even this modest amount of configuration variety had a surprisingly large increase bug finding capabilities it also helps explain why fuzzing performance had little impact.
the kernel binaries produced were very similar to the original configuration file.
this similarity also ensured that the kernel was still bootable in syzbot s testing infrastructure.
rq3 variety in configurations improves bug finding capabilities of fuzzing while preserving the performance bootability and other configuration requirements of the fuzzer.
vi.
p reviously unreported bugs table vii lists all previously undiscovered bugs identified by syzkaller when using repaired configuration files.
the table shows the type of bug separated by dashed lines the function it was found in the commit id of the kernel whether we could reproduce the bug whether developers confirmed it and whether it has been patched.
all bugs have been reported to linux developers.
as of the time of writing have so far been confirmed and have been patched.
moreover we discovered an out of bounds access in fbcon set font that causes a local denial of service vulnerability that was assigned a cve with a medium severity score of .
.table vii all previously unreported bugs found by syzkaller when using the modified configuration selection strategy.
id type location kernel version reproducible confirmed patched use after free hci conn hash flush b7455b10da762f2d use after free sco sock timeout b7455b10da762f2d use after free f2fs iget 09e41676e35ab06e use after free difree 09e41676e35ab06e null ptr deref filemap fault b7455b10da762f2d null ptr deref ext4 update overhead b7455b10da762f2d out of bounds access extalloc b7455b10da762f2d out of bounds access fbcon set font a54df7622717a40d out of bounds access f2fs iget 509583475828c4fd out of bounds access f2fs iget 66eee64b235411d5 out of bounds access ntfs test inode a54df7622717a40d protection fault nl802154 trigger scan 4d6d7ce9baaf9e67 protection fault efivar lock 9fbee811e479aca2 protection fault floppy ready 9ce08dd7ea24253a protection fault blkg destroy all 09e41676e35ab06e protection fault reset interrupt b7455b10da762f2d unspecified bug page add anon rmap a54df7622717a40d unspecified bug rcu core 465461cf48465b8a unspecified bug smp call function b7455b10da762f2d unspecified bug ntfs perform write 4fafd96910add124 unspecified bug btrfs global root insert 509583475828c4fd unspecified bug jfs evict inode b7455b10da762f2d unspecified bug erofs iget b7455b10da762f2d unspecified bug dojournal end b7455b10da762f2d warning split vma a54df7622717a40d warning get floppy geometr 9ce08dd7ea24253a warning invalidate drive e2f86c02fdc96ca2 warning process fdrequest 4d6d7ce9baaf9e67 warning udf truncate extents b7455b10da762f2d warning vma merge 83e5775d7afda68f warning floppy read block 83e5775d7afda68f warning btrfs block rsv release b7455b10da762f2d warning send hsr supervision frame 80bd9028fecadae4 warning fdlocked ioctl e2f86c02fdc96ca2 stall ioring exit work 129af770823407ee total to help developers investigate a bug syzkaller attempts to generate a program that reproduces the bug.
but due to the limitations of syzkaller not all bugs produce a reproducer program.
of our new bugs syzkaller successfully generated reproducers for of them.
of these successfully triggered the bug.
unfortunately syzkaller s inability to produce functional reproducers is a known problem.
in consulting syzkaller s developers ourselves we anticipate that kernel nondeterminism is the most likely root cause of our unreproducible crashes.
the absence of reproducibility also makes bug reporting and developer side bug triage more difficult.
as the maintainer greg kroah hartman points out .
reproducer would be great thanks.
otherwise this goes on the thousands of other syzbot found bugs with no wayto reproduce pile that we have... we observe however that developers can occasionally diagnose and patch bugs without a reproducer.
for example one of the general protection faults we found in nl802154 trigger scan lacked a reproducer but was confirmed and patched by a kernel maintainer who inferred its cause from the bug report alone .
at the time of writing the remaining bugs are still pending confirmation with developers.
a. the effects of configuration variety for the bugs that are reproducible we investigated whether they only apply to the modified configuration fileor were applicable to syzkaller s original configuration file table viii .
if the bug were only present when little used options were enabled it may not be present in typical kernel builds.
of the reproducible bugs we found that only were specific to the repaired configuration file.
the remaining reproduce the bug in kernels built with both the repaired and original configuration file.
this indicates that adding configuration variety not only opens the fuzzer to code excluded by its original configuration file but it also helps alter coverage patterns sufficiently to identify bugs it had not otherwise covered when fuzzing kernels built with the original configuration file.
to further investigate the effects of configuration variety on fuzzing we traced the coverage of reproducers that triggered the same bug in both the repaired and original configuration files.
our reasoning is that if the same bug is triggered but follows a different path between the two kernels then the fuzzer must have taken a path to reach the bug that is not available with the original configuration file even though the bug is present in the latter s kernel.
to track coverage we ran the reproducers and collected coverage traces with kcov linux s built in coverage tracer.
retrieving kcov data is only feasible for bugs that do not crash the kernel since it is the kernel itself maintaining the coverage information.
but for of the bugs that do not crash the kernel they produce a warning instead we observed differences in the traces betweentable viii bugs that depended on configuration variety to be found.
id type location method use after free hci conn hash flush reproducer unspecified bug dojournal end reproducer warning udf truncate extends reproducer use after free f2fs iget reproducer unspecified bug page add anon rmap kcov oob access fbcon set font kcov protection fault efivar lock kcov warning fdlocked ioctl kcov warning vma merge kcov oob access f2fs iget call trace kernels built with modified and original configuration files while the remaining appeared unrelated to the repaired configuration file.
we quantify the differences between traces as the percentage of differing lines.
for the reproducers we traced these differences ranged from .
to .
for bugs that do crash the kernel we manually investigated the stack traces reported by syzkaller and to determine whether any functions in the trace were only present in kernels built with repaired configuration files.
our reasoning is that if a function in the stack trace is configuration specific then the repaired configuration file was necessary to identify the bug along that specific trace.
we found one crash that was indeed configuration specific and detail this bug in the next subsection.
summary we identify bugs table viii whose reachability isenhanced by configuration variety even though these bugs exist in kernels built with syzkaller s original configuration.
b. case study a configuration specific trace to better understand how configuration variety helps fuzzers find bugs we perform a case study of bug from table vii which we identified as covering code only available in our modified configuration file but resulting a bug that was reproducible with syzkaller s original configuration file.
its call trace shows the bug location to be function f2fs iget in source file fs f2fs inode.c with a previous call occurring to function f2fs fill super .
listing displays the relevant parts of the function including the ultimate call to the buggy function f2fs iget .
caller function f2fs fill super contains several ifdef conditional compilation directives which are controlled by the kernel configuration.
while relevant features config quota and config fsencryption exist in both the modified and configuration configuration file config fsverity is only enabled in the original configuration while our modified configuration file disables it leading to the omission of this source line in the kernel.
the sbdata structure is ultimately passed to the buggy function f2fs iget .
although the stack trace alone does not show direct involvement of the line omitted by config fsverity the trace illustrates how modifying the configuration file alters code paths at build time leading to different coverage patterns and different bugs.1static int f2fs fill super struct super block sb void data int silent code omitted for brevity ifdef config quota sb dqop f2fs quota operations sb sqcop f2fs quotactl ops sb squota types qtype mask usr qtype mask grp qtype mask prj if f2fs sbhas quota ino sbi for i i maxquotas i if f2fs qfino sbi sb i sbi nquota files endif sb sop f2fs sops ifdef config fsencryption sb scop f2fs cryptops endif krepair disables config fsverity ifdef config fsverity sb svop f2fs verityops endif code omitted for brevity call to f2fs iget containing the bug sbi node inode f2fs iget sb f2fs node ino sbi listing abridged code of fs f2fs super.c.
vii.
t hreats to validity a. internal validity our replication study produces patch coverage results similar to prior work suggesting some generality to the limitations of hand selected patches for continuous testing.
we evaluate two popular fuzzers syzkaller and kafl showing that both suffer similar limitations.
our evaluation is for the linux kernel which has especially high configurability.
while syzkaller supports other kernels krepair does not.
fuzzing uses randomization so multiple runs may exhibit different behavior.
as of paper acceptance there was no known way to replicate individual syzkaller runs as confirmed by developers .
snapshotting however has since been added to syzkaller .
while not yet evaluated as of writing this feature should help with replicability in the future.
we mitigated fuzzer randomness in our experiments by comparing the repaired and original configuration against many different patches which consistently exposed previously unreported bugs.
while not all bugs are confirmed yet by linux s developers at the time of writing we observe that most of our reported bugs have reproducing test cases proving their existence.
b. external validity the replication study uses a sample of patches from a single recent year.
while that year contains about patches and the sample is large enough to have a low margin of error it is possible that other years or other software would have different patching behavior.
a useful future study would be to mine a large number of software repositories and takes large samples of their change histories to evaluate how much configuration variety exists in new code changes.our results show that another kernel fuzzer kafl suffers the same configuration testing limitations but has no publiclyavailable continuous testing infrastructure.
syzkaller is the most popular kernel fuzzer and the only one to our knowledge that has an open source test robot.
additionally many applications also have high configurability including those using linux s configuration system kconfig.
our recommendations are specific to continuous fuzzing since fuzzing has specific needs separate from other testing approaches such as test suites and static analysis.
a similar systematic analysis however could be applied to those testing approaches to provide the appropriate recommendations.
our analysis of configuration selection strategies is based on the current state of the art.
future work could better integrate configuration testing and continuous kernel fuzz testing for further improvements in bug finding for instance by encoding multiple configurations in a single binary and fuzzing them together or incorporating configuration selection into existing mutation strategies .
viii.
r elated work a. configuration analysis research continues to examine the challenges of maintaining and securing configurable software.
melo et al.
show developers struggle to perform precise configuration analysis by hand particularly for complex code such as os kernels.
mordahl et al.
examine the effectiveness of applying configuration agnostic static analysis tools to the detection of configuration dependent application bugs.
ferreira et al.
formalize configuration complexity and study its influence on the occurrence of configuration dependent kernel vulnerabilities.
abal et al.
examine previously fixed configurationdependent kernel bugs to quantify and understand their configuration complexity.
we believe that these and other studies present further opportunities for applying configuration aware fuzzing for example to target pre identified code regions suspected of containing configuration dependent bugs.
prior research is also exploring static means of improving configuration based analysis tasks.
c reconfigurator hercules sugarc and maki demonstrate the feasibility of statically rewriting applications configurationdependent code to instead be invokable at runtime for example rewriting an ifdef wrapped code block to instead be guarded by an if statement.
although these techniques have yet to be applied beyond user space applications we envision the potential for future synergistic approaches combining configuration aware kernel fuzzing with additional static kernel analyses and transformations.
research is also exploring dynamic approaches for recognizing differences between program variants.
meinicke et al.
introduce the concept of variational traces a compact representation of the execution path differences among unique variants of the same program.
ferreira et al.
perform variational tracing at the call graph level.
kaoudis et al.
improve the power of variational trace collection at the control and data flow level by leveraging llvm based compiler instrumentation.
we anticipate that advancements in kernel level execution profiling will facilitate even faster and more effective configuration aware kernel fuzzing.
some prior work has explored continuous testing for software product lines albeit not for kernel fuzzing.
other prior work has looked at command line argument fuzzing for user space programs .
in our work however we use existing unmodified kernel fuzzing algorithms with configuration repair to improve configuration variety.
b. kernel fuzzing numerous kernel fuzzers have emerged over the years employing different architectures and techniques.
by far the most popular is google s syzkaller among the first kernel fuzzers to borrow successful principles from application fuzzers like afl e.g.
code coverage guidance random mutation and grammars.
intel s kafl adopts many of the same features but obtains far greater speed from its faster hypervisor accelerated vm snapshotting.
while the majority of today s kernel fuzzers target open source kernels such as linux kafl and ntfuzz are among the few available windows kernel fuzzers.
many industrial and academic enhancements are improving kernel fuzzing speed and effectiveness.
difuze syzdescribe and fuzzng extend the reach of syzkaller by automating generation of system call specific input specifications for its syzlang grammar format.
dr.fuzz drifuzz devfuzz and printfuzz combine static and dynamic analyses to synthesize virtual device models increasing coverage when fuzzing their associated device drivers.
agamotto and horus both accelerate kernel fuzzing via incremental process snapshotting and optimized host vm communication respectively.
as configuration aware fuzzing is orthogonal to the fuzzer used we expect that combining it with different fuzzing advancements will yield improved capabilities in finding configurationdependent kernel bugs.
ix.
c onclusion fuzzers have been very successful at finding kernel bugs but our replication study shows that the use of predefined configuration settings leads to missed patches when fuzzers stop to rebuild their kernel nullifying the benefits of continuous testing.
we systematically analyzed the challenges of configuration testing for continuous fuzzers and provided guidelines to configuration and fuzzing researchers demonstrating how fuzzers can improve both continuous and configuration testing without sacrificing performance.
our evaluation confirms a substantial increase in previously undiscovered bugs by modifying only the configuration selection strategy while preserving fuzzer performance.