an empirical study of proxy contracts at the ethereum ecosystem scale mengya zhang preksha shukla wuqi zhang zhuo zhang pranav agrawal zhiqiang lin xiangyu zhang xiaokuan zhang the ohio state university george mason university purdue university offside labs abstract the proxy design pattern separates data and code in smart contracts into proxy and logic contracts.
data resides in proxy contracts while code is sourced from logic contracts.
this pattern allows for flexible smart contract development enabling upgradeability extensibility and code reuse.
despite its popularity and importance there is currently no systematic study to understand the prevalence use scenarios and development pitfalls of proxies.
we present the first comprehensive study on ethereum proxies.
to gather a dataset of proxies we introduce proxy ex the first framework to detect proxies from bytecode achieving over accuracy.
using p roxy ex we collected a dataset of ethereum proxies and conducted the first large scale empirical study.
we analyzed proxy numbers and transaction traffic to understand their current status on ethereum.
we identified four proxy use patterns upgradeability extensibility code sharing and code hiding.
we also pinpointed three common issues proxy logic storage collision logic logic storage collision and uninitialized contracts creating checkers for these by replaying historical transactions.
our study reveals that upgradeability isn t the sole reason for proxy adoption in dapps and many proxies present issues like storage collisions and uninitialized contracts which enhances the understanding of proxies and guide future smart contract research on the development usage quality assurance and bug detection of proxies.
i. i ntroduction ethereum has emerged as one of the leading blockchain platforms with turing complete smart contracts allowing for greater flexibility and functionality in developing decentralized applications dapps .
as of february the total unique active wallets uaw on ethereum reached approximately .
million with a total value locked tvl across all ethereum dapps at around .
trillion .
data and code of ethereum smart contracts are closely coupled in the same address.
moreover the code of a contract is immutable it cannot be modified once deployed.
such characteristic hinders the flexibility of developing smart contracts and dapps introducing constraints including restricted code size constrained functionality expansion challenges in reusing code and obstacles in patching code etc .
the separation of code and data is deemed to be a preferred practice of software design to improve maintainability security understandability etc and resolve the aforementioned constraints of dapps.
fortunately to mitigate such limitations the community has proposed the proxy design pattern to achieve the separation of code and logic.
proxy pattern separates data and logic these authors contributed equally to this work.
invoke delegatecall a user b proxy contract storage layer c logic contract code layer fig.
workflow of the proxy pattern.
implementation into two different contracts namely proxy contract andlogic contract respectively.
users of the dapp interact and send transactions to the proxy contract which will use delegatecall a type of ethereum virtual machine evm opcode to execute the code of the logic contract on top of the data in the proxy contract as shown in fig.
.
with the proxy design pattern dapps may achieve upgradeability and code patching by replacing the delegatecall target i.e.
the address of the logic contract with a new one extensibility with unlimited code size by delegating the handling of some functionalities to other contracts codesharing by sharing the same logic contract among multiple proxies etc.
we investigate and discuss the use scenarios of proxy design pattern in iv b in detail.
proxies are prevalent on ethereum.
we find that over .
contracts on ethereum adopt the proxy design pattern.
the popular usage of proxies underscores the need to study how the proxy pattern fits in the requirement of dapps how developers implement proxies and what kinds of bugs and pitfalls may exist in proxies.
to the best of our knowledge such a study is still absent.
on the one hand bodell et al.
and salehi et al.
studied the upgradeable proxies on ethereum.
however they confine themselves to upgradeable proxies while we show that the proxy pattern has several other use scenarios.
on the other hand ruaro et al.
proposed techniques to detect a specific type of bug arising in proxies.
our study in contrast aims to facilitate an comprehensive understanding of the proxy design pattern including various use purposes and development pitfalls.
to facilitate our study we first propose a novel framework proxy ex to detect deployed proxies from bytecode at the ethereum ecosystem scale.
we use p roxy ex to collect a large scale dataset of proxies.
we manually evaluate p roxy ex on randomly selected contracts.
our evaluation shows that p roxy ex can achieve over proxy detection accuracy precision and over recall.
these evaluation results assure the quality of the dataset we collect for the study and consolidate the observations and findingswe make.
with the large scale dataset of proxies we conduct the first systematic study on proxies on ethereum aiming to answer the following research questions.
rq1 statistics how many proxies are there and how frequently are these proxies used on ethereum?
we measure the total number and the proportion of distinct proxies on ethereum as well as the transactions invoking these proxies to obtain an overview of the popularity usage and traffic of proxies.
rq2 purpose what are the major purposes of implementing proxy patterns for dapps?
we manually inspect a sample of proxies and propose a use purpose taxonomy of proxies.
we also propose automated methods to detect each type of proxy on a large scale from our dataset.
rq3 bugs and pitfalls what types of bugs and pitfalls can exist in proxies?
we summarize common pitfalls when implementing proxies and design several pitfall checkers leveraging historical transactions.
we use the checkers to detect bugs in all proxies in our dataset.
findings.
the major findings are as follows.
there are four different use purpose of proxies namely upgradeability extensibility code sharing and code hiding among which upgradeability proxies and code sharing proxies compose the majority.
over .
proxies are non upgradeable i.e.
their logic contract to which the code execution is delegated cannot be changed.
among the upgradeable proxies .
of them have never been upgraded in history.
the proxy contract and logic contracts should use the contract storage consistently with the same semantic interpretation otherwise severe bugs may occur.
developers often fail to initialize proxy or logic contracts within the same transaction where the contract is deployed exposing a non negligible attacking surface for proxies.
we have successfully identified a zero day vulnerability putting over 2m worth of assets at risk.
contributions.
our study makes the following contributions.
proxy detection and dataset we propose a novel framework p roxy ex to identify proxies.
we collect a largescale dataset of real world proxies on ethereum as well as their transactions.
systematic analysis we conduct an in depth and systematic analysis of proxies propose a taxonomy of proxies and the implementation pitfalls and make valuable observations and implications on our collected dataset.
bugs and pitfalls we identify three common pitfalls in proxies and conduct a semi automated detection for such pitfalls.
we found a high value zero day vulnerability affecting assets over 2m.
data availability.
we released the implementation of p roxyex and all data in .com osuseclab proxyex.ii.
p reliminaries a. ethereum basics each smart contract consists of code and data storage .
the code is immutable once deployed.
users invoke functions of the contract code which may load or modify data in the contract storage.
the storage is a low level data store comprised of a list of storage slots indexed with an integer between 0and .
each storage slot may store bytes of data.
solidity the most popular programming language of smart contracts allows developers to declare high level state variables of a contract which internally encodes and stores the value in the low level storage.
users interact with smart contracts by sending transactions.
each transaction may specify a function with an byte function signature hash to be called.
if the specified function is not found a special fallback function in the contract will be executed.
functions in one smart contract may call other smart contracts.
call and delegatecall are two different calls between contracts.
call invokes the code of another contract and execute in the context of the callee contract i.e.
modifying the callee s storage .
delegatecall fetches the code of another contract and execute in the context of the caller contract i.e.
modifying the caller s storage .
b. proxy patterns the proxy pattern involves a proxy contract interfacing with users and a logic contract holding the actual implementation code.
the proxy contract leverage the delegatecall opcode of ethereum virtual machine evm to delegate the code execution to the logic contract while the data are kept in the storage of the proxy contract.
by separating the proxy contract and the logic contract it enables applications such as upgradeability smart contract where the logic contract can later be upgraded to a new version and code sharing contracts where multiple proxy contracts are delegating the execution to the same logic contract.
we discuss more use scenarios of proxy patterns in iv b. eip proxy storage slots is a standard on ethereum to specify designated storage slots where specific information of proxies should be stored.
one example information in proxy is the address of the logic contract.
eip defines the storage slot for logic contract address as uint256 keccak256 eip1967.proxy.implementation which is ensured not allocated to any high level state variables of the contract thus preventing storage collsions.
we discuss storage collision pitfalls in detail in iv c. eip also specifies a standard storage slot for other proxy information such as the admin address.
eip facilitates proper extraction and display of proxy information by clients like block explorers e.g.
etherscan for end users while logic contracts can choose to utilize it optionally.
iii.
d ata collection a.proxy ex to facilitate data collection we design a system p roxy ex shown in fig.
to detect proxy contracts from bytecode 2function identifierlogic contract extractorproxy scanner ethereumbytecode traces function logicproxyfig.
the workflow of p roxy ex.
block 0x860x86jumpdest0x87callvalue0x88dup10x89iszero0x8apush2 0x920x8d jumpi a opcode sequence.
block 0x860x86 0x87 v87 callvalue 0x88 0x89 v89 iszero v870x8a v8a 0x92 0x8d jumpi v8a v89 b ir.
...block 0x860x86 0x87 v87 callvalue 0x88 0x89 v89 iszero v870x8a v8a 0x92 0x8d jumpi v8a v89block 0x8e0x8e v8e 0x00x90 0x91 revert v8e v8eblock 0x920x92 0x93 0x94 v94 0xd5 0x97 v97 0x4...0xa4 jumpi va1 va0... c gcfg with ir.
solid line fall through edge dotted line jump related edge.
fig.
illustration of the first three steps of function identifier .
and extract logic contract addresses from transactions.
it has three major components function identifier which extracts function based control flow graphs cfgs based on registerbased intermediate representation ir proxy scanner which detects proxy contracts based on bytecode analysis logic contract extractor which utilizes transaction level analysis to extract logic contracts.
function identifier given a smart contract bytecode function identifier identifies the function boundaries and extracts function based control flow and data flow graphs as follows.
this is necessary for detecting proxy contracts since we need to identify the fallback function which is a necessary condition for proxy contracts and analyze crossfunction calls as the fallback function may call another function to execute delegatecall .
step constructing basic blocks from opcodes .first function identifier disassembles the bytecode into a sequence ofopcodes .
after that function identifier divides the opcode sequence into basic blocks using control flow transfer opcodes as delimiters.
there are two types of control flow transfer opcodes jump related opcodes including jump jumpi jumpdest jump and jumpi indicate the end of a block while jumpdest denotes the beginning of a block.
stop related opcodes including stop return revert invalid and selfdestruct they all indicate the end of a block.
note that while call related opcodes such as call anddelegatecall are control flow transfer opcodes they are not used as delimiters for creating basic blocks since there is no callee information available from the bytecode.
one example is shown in fig.
3a.
step converting the opcode sequence into register based intermediate representation ir .
since evm opcodes are stack based operations extracting control flow and data flow information can be challenging.
to facilitate further analysis we build upon vandal a static program analysis framework for ethereum smart contract bytecode.
vandal decompiles evm bytecode into a register based ir that encodes the program s control flow graph.
we chose vandal due to its robustness and wide adoption by prior works such as txspector and madmax .
to be more specific we simulate the evm stack operations step by step with producing theglobal data flow.
we generate a new register for every new operand used by an opcode as well as the operation involving multiple operands e.g.
jumpi .
in this way every stack based operation will be converted into a register based operation as shown in fig.
3b.
for some opcodes e.g.
jumpdest they do not generate new values thus there is no corresponding register assigned for such opcodes e.g.
empty for 0x86 .
for opcodes that generate new values a register will be given to represent the value e.g.
v89foriszero .
step constructing the global control flow graph gcfg .
after the ir is generated function identifier will further construct the gcfg.
gcfgs are constructed based on specific opcodes implemented based on g igahorse .
gigahorse is a decompiler designed for evm bytecode transforming bytecode into a high level address code representation.
for example when the opcode jump is encountered it indicates a change in code execution from one place to another.
this allows us to split the execution flow into separate blocks whenever a jump is encountered.
in the gcfgs the nodes are the basic blocks and the edges are either fallthrough edges or jump related edges.
there are two types of edges fall through edges and jump related edges.
fallthrough edges can be easily added by connecting basic blocks according to the original order.
with the ir we can obtain the targets of jump related opcodes which are the values of thejumpdest .function identifier adds a gcfg edge between a basic block ending with jumpi orjump and the basic block address i.e.
a constant value held by the variable which is used to denote the jump target.
as shown in fig.
3c the solid lines represent fall through edges while the dotted lines represent the jump related edges.
for example block 0x86 jumps to 0x92 if the condition v89is satisfied which means the variable v87 is0 otherwise block 0x86 will go to the fall through edge and go to block 0x8e .
step recovering function based control flow graphs fcfgs .
the final step is to recover fcfgs from the gcfg by identifying function bodies and control data flows.
first function identifier locates function entries by analyzing the evm function dispatcher.
the dispatcher compares each 3contract function signature with the input .
if a match is found control jumps to the function s entry block otherwise it executes the fallback function or ends.
if function identifier finds a function without a signature at the end it is the fallback function.
proxy scanner proxy scanner aims to determine whether a given contract is a proxy contract based on the identified functions and fcfgs.
to identify the proxy from bytecode proxy scanner leverages the following detection rules based on our observations in supplementary material .
rule locating the delegatecall in the fallback function.
proxy scanner will iterate all the identified functions to find whether there exists a fallback function if yes proxy scanner further checks whether there is a delegatecall in this specific function.
rule ensuring the input for delegatecall is derived from the parameters of the fallback function.
before executing delegatecall it is necessary to execute a specific calldatacopy operation to fill the memory with the call data which represents the user input.
therefore proxy scanner checks whether calldatacopy is called before delegatecall to fill the memory used by delegatecall .
rule ensuring the returned success status of delegatecall is checked and the return data is handled case by case return when success and revert when fail .
after a delegatecall the contract either return status is or revert status is .
proxy scanner will fetch the variable of the status returned by thedelegatecall and check whether the variable is used by ajumpi .
if status is the contract will go to a stop return otherwise the contract will go to a revert .
logic contract extractor since the source code is not available it is hard to extract the logic contract address directly from the bytecode.
we can try to extract logic contracts from the parameters of delegatecall but this method is errorprone since we are not sure which delegatecall is really the one that delegates to the logic contract.
to tackle this we propose to use transaction information to assist our analysis.
after proxy scanner confirms that a smart contract is a proxy logic contract extractor will extract all the historical logic contracts used by this proxy via transaction level analysis.
logic contract extractor enforces rules to identify transactions where the proxy delegatecall s the logic contract from all proxy transactions.
we term these transactions as logicdelegating transactions .
extracting target addresses of such transactions yields the logic contracts.
we derive the following rules from our observations in supplementary material to identify logic delegating transactions .
rule checking whether the fallback function is called in a transaction.
logic contract extractor first extracts the list of function signatures byte string e.g.
0x12345678 from the bytecode.
this function list contains all functions that are defined in the proxy contract.
after that logic contract extractorchecks whether the function signature of the transaction is in the signature list the first bytes of the input if not thetransaction will execute the fallback function based on the execution logic of the evm ii .
rule checking the parameters from transaction traces.
logic contract extractor checks the first two transaction traces to see whether an eoa call s the proxy contract in the 1st trace the proxy contract delegatecall s another contract in the 2nd trace the input of 1st and 2nd traces are the same.
if a transaction matches the above rules it is a logic delegating transaction .
note that for the remaining transactions that are notlogic delegating transactions their functionalities are hard to determine.
for example a transaction may be used for performing an upgrade or updating the owner of the proxy contract.
in this paper we do not implement more rules to distinguish them since finding logic delegating transactions would be sufficient for extracting logic contracts.
extracting logic contract addresses.
after identifying all logic delegating transactions logic contract extractor extracts all target addresses of delegatecall s from every logicdelegating transaction and constructs the set of logic addresses after deduplication.
b. correctness of proxy ex we developed a prototype of p roxy ex.
to evaluate its effectiveness we randomly selected contracts split into proxies and non proxies to ensure an unbiased dataset.
with a confidence level the error margin is .
for proxies and .
for non proxies.
initially we manually inspected the source code to evaluate p roxy ex s accuracy.
however contracts lacked source code.
in these cases we inspected the decompiled code using the online solidity decompiler also used by other works .
we analyzed p roxy ex s detection results for contracts with a second timeout comparing them with our ground truth labels.
p roxy ex misclassified one proxy as non proxy due to a timeout caused by nested loops identifying data flow dependencies.
overall with only one false negative proxy ex achieved precision and over recall.
c. datasets data collection involves utilizing google bigquery apis which facilitate querying ethereum contracts and transactions.
for instance to gather transactions associated with all proxy contracts we develop sql code tailored for querying these specific datasets.
in total we have collected the following datasets proxy contracts.
we collect all the on chain smart contract bytecode as of september .
in total we have smart contracts.
we apply proxy ex on the smart contract bytecode there are proxy addresses in total .
.
the average detection time of proxy and non proxy contracts are .
seconds and .
seconds respectively.
transactions and traces.
we gather all the transaction traces associated with a delegatecall sent from the proxy contracts i.e.
logic delegating transactions as of september .
we collect a tuple fromaddr toaddr calltype for every trace which we count08001600240032004000proxy count .
.
.
.
.
cdffig.
bytecode duplication transaction count102103104105106proxy count .
.
.
.
.
cdf fig.
transaction count day101103105proxy count .
.
.
.
.
cdf fig.
lifespan upgrade frequency101103105proxy count .
.
.
.
.
cdf fig.
upgrade frequency subsequently aggregate into transactions.
in total we collect transactions for all proxy contracts.
iv.
e valuation results in this section we present our evaluation results based on the datasets to answer three research questions rq1 statistics rq2 purpose and rq3 bugs and pitfalls .
a. rq1 statistics bytecode duplication among proxy contracts only bytecodes are unique with .
being exclusive and unduplicated.
thus just .
of proxy contracts hold unique bytecode.
in total .
bytecodes are shared by or fewer contracts.
as shown in fig.
this includes .
bytecodes shared by over contracts.
the top three bytecodes are used by and proxy contracts respectively and they are standard proxy implementations.
for example the leading contract ownabledelegateproxy integrates ownerable and upgradeable features requiring the owner s authorization to upgrade its logic contract.
transaction count the proxy contracts are related to logic delegating transactions.
there are .
proxy contracts with less than transactions and their transaction count is shown in fig.
.
.
of them have less than transactions.
there are only proxy contracts having over a million transactions.
among the top addresses five are token contracts three are bridge contracts and two contracts are decentralized finance defi applications.
specifically the top proxy is the token contract usdc and it has the most transactions accounting for .
of the total transactions in our dataset.
lifespan we define the lifespan in days of a proxy as the duration between its initial delegatecall to a logic contract and its final delegatecall .
if a proxy never delegatecall s to a logic contract its lifespan is considered zero.
as shown in fig.
.
of the proxies have a lifespan less than days proxies have a lifespan of more than years.
the proxy with the longest lifespan is the eventshistory contract of ambisafe operations which has been active since july .
finding .
the majority of proxies exhibit identical bytecode .
involve fewer than associated delegatecalling transactions .
and maintain a short lifespan of less than days .
.1contract upgradeableproxy fallback external address storage .
delegatecall msg.data 5contract logic address logic function upgradeto address logic public onlyowner storage logic fig.
an example of upgradeable proxy.
b. rq2 purpose given the popularity of proxies it is vital to understand the use purpose of proxies on ethereum.
we conduct a manual inspection on a sample confidence and error margin of proxies and categorize the purpose of proxies into four types namely upgradeability extensibility code sharing and code hiding.
then we design automated classifiers to scalably categorize all proxies in our dataset.
we discuss each use purpose and present the results below.
upgradeability smart contracts on ethereum are immutable and their code cannot be modified once deployed.
this brings many difficulties for developers to maintain a dapp e.g.
upgrading the contract logic to new versions fixing bugs and vulnerabilities found after deployment etc.
the proxy pattern can be leveraged by developers to alleviate this issue.
in upgradeable proxies the proxy contract stores the data of the dapp while the code in the proxy contract simply delegates all invocations to a logic contract via delegatecall .
no business logic is implemented in the proxy contract and the code in the logic contract executes the business logic on top of the data in the proxy contract.
fig.
shows an example upgradeable proxy.
the address of the logic contract is stored in the storage slot 0x0a and all invocations to the proxy are delegated to the logic contract in the fallback function.
a function upgradeto is available to upgrade the logic by assigning a new address to the storage slot 0x0a .
note that both proxy and logic contracts share and operate on the storage data of the proxy contract.
classification.
the ethereum community has established several standards for implementing upgradeable proxies including transparent upgradeable proxy and universal upgradeable proxy standard uups .
we classify a proxy into to upgradeable proxy if there exists a function that can change the address of the logic contract.
result.
we successfully identified upgradeable proxies among all proxies in our dataset.
note that not all proxies are upgradeable e.g minimal proxies and 51contract tokenproxy mapping address uint balances function balanceof address a public returns uint return balances function transfer address to uint a public balances a balances a fallback external address storage .
delegatecall msg.data contract tokenextension istokenproxy function burn address a uint n public onlyowner balance n fig.
an example proxy to achieve extensibility .
delegatecall forwarders .
we found that a non negligible portion .
of proxies are not upgradeable.
we also measure the upgrade frequency of upgradeable proxies.
the upgrade frequency is the number of times a proxy upgrades its logic contract.
the upgrade frequency for every proxy is essentially the number of different logic contracts minus one.
note that here we only count the effective logic contracts i.e.
the logic contracts that have been used for at least once.
if an upgrade introduces a new logic contract but it is never used no logic delegating transaction it will not be included in our dataset.
fig.
presents the upgrade frequency.
we find that a majority over .
of the upgradeable proxies have never upgraded their logic contracts.
.
of them have upgraded at least once but less than times.
the proxy with the highest upgrade frequency has unique logic addresses i.e.
has been upgraded times.
finding .
most proxies are upgradeable while a nonnegligible portion .
are non upgradeable.
however a majority of upgradeable proxies .
have never been upgraded after deployment in history.
extensibility the immutability of smart contracts also limits the extensibility of dapps.
the ethereum community has many application standards for dapps to implement e.g.
erc fungible tokens erc nft etc.
however these standards only cover basic functionalities and dapps usually need to extend the standards with additional functionalities.
we observe that many contract developers leverage proxy patterns to gradually extend the functionalities of their dapps.
the standard basic functionalities are implemented in the proxy contract while all other nonstandard invocations are delegated to the logic contract which implements extended functionalities.
fig.
shows an erc contract with extended functionalities via proxy pattern.
the standard functionalities e.g.
transfer andbalanceof in erc are implemented in the proxy contract while any invocations calling non erc standard functions are forwarded to the logic contract tokenextension e.g.
burn in the fallback function of the proxy contract.
extensibility proxies are designed to balance the trustlessness and extensibility of the dapp.
ideally the smart contractcode should be immutable so that users do not need to trust the contract owners developers to be honest and not maliciously modify the logic .
otherwise contract users may be at risk of rug pull or other centralization risks .
by adopting an extensibility proxy pattern contract developers can keep a balance between trustlessness and extensibility where the core functionalities implemented in the proxy contracts e.g.
tokenproxy in fig.
are immutable while the extended functionalities in logic contracts e.g.
tokenextension are flexible to update as needed.
classification.
extensibility proxies may also update the address of the logic contract which contains the extended functionalities.
the key difference is that extensibility proxies implement part of the functionalities in the proxy contract.
therefore we classify a proxy to be an extensibility proxy if not all business logic invocations are forwarded to the logic contract i.e.
some invocations to the contract are handled by the proxy contract while some are forwarded to the logic contract.
to detect extensibility proxies our heuristic is that in extensibility proxies the code in the proxy contract and logic contract must share the data in the proxy.
we replay all historical transactions of each proxy and collect extensibility proxies whose proxy and logic contracts have ever accessed the same storage slot in history.
results.
we successfully identified proxies satisfying the aforementioned criteria.
we manually investigated each of them and found that of them are true extensibility proxies.
the other proxy is not an extensibility proxy but satisfies our classification criteria in that it is an implementation bug.
two different state variables in proxy and logic contracts accidentally use the same storage slot which they should not due to an implementation bug.
we will further discuss this kind of bug in iv c1.
finding .
the proxy pattern can be leveraged to achieve the extensibility of functionalities of smart contracts.
however implementing business logic in both proxy and logic contracts is error prone and requires careful design and correctness audit.
code sharing in dapps it is often the case that multiple smart contracts are deployed with the same code to operate on different data.
for example for decentralized token exchange dapps e.g.
uniswap developers need to deploy exchange contracts for each pair of exchangeable tokens.
deploying smart contracts induces non negligible costs for developers proportional to the size of the smart contract code with exactly the same logic.
proxy patterns can be leveraged to share code between smart contracts and save deployment costs for developers.
in code sharing proxies multiple proxy contracts may delegate their logic execution to the same logic contract.
the code is shared in the logic contract while the data that the shared logic operates are stored in individual proxy contracts.
users can continue to interact with the proxy contracts as if there is no code sharing.
fig.
61contract proxy1 fallback external address storage .
delegatecall msg.data 5contract proxy2 fallback external address storage .
delegatecall msg.data 9contract sharedlogic erc20 token0 token1 function swap amount x public swap x amount of token0 to token1 ... fig.
an example of code sharing using the proxy pattern.
shows an example of code sharing proxy.
both proxy1 and proxy2 delegate their logic to the sharedlogic contract which provides token exchange functionality.
the data of the two proxies are separate i.e.
proxy1 andproxy2 may have different values for variable token0 and token1 to swap different pairs of tokens.
classification.
the major characteristic of code sharing proxies is that multiple proxies share the same logic contract.
to identify code sharing proxies we enumerate all proxies in our dataset and check the addresses of their logic contracts.
if a logic contract is used by more than one proxy then those proxies are code sharing proxies.
results.
we have identified code sharing proxies in our dataset.
based on the logic contract they share the proxies can be separated into different clusters.
the size of each cluster is the number of proxies in the cluster each cluster has a size larger than or equal to .
there are in total code sharing proxy clusters.
.
clusters have a size larger than .
there are .
clusters whose size is larger than and .
clusters whose size is larger than .
the most shared logic contract named authenticatedproxy is shared by proxies.
finding .
proxies often share the logic contracts.
we identified code sharing proxies in our dataset.
the top shared logic contract is shared by proxies.
code hiding many blockchain explorers like etherscan utilize the eip standard to implement slots to identify and display the logic contracts.
users and security researchers rely on such explorers especially etherscan to check the source code and labels of on chain contracts .
to escape from scrutiny by users or other third parties malicious actors may hide their malicious logic behind a proxy and deceive blockchain explorers or monitoring tools so that it appears to be a legitimate logic contract .
such deception is possible in that auditors usually rely on eip which defines the specific storage slot where the address of the logic contract is stored to identify the logic contract of a proxy.
malicious proxies may store an address of a legitimate logic contract in the specific slot defined in eip but the actual execution is delegated to another logic contract which contains malicious logic at runtime.1contract codehidingproxy bytes32 eip1967slot keccak256 eip1967.proxy.
implementation fallback external storage address legitimate address malicious .
delegatecall msg.data 7contract legitimate ... 8contract malicious ... fig.
an example of using the proxy pattern to hide logic.
note that the developers of code hiding proxy contracts can be either malicious or benign it is hard to distinguish in reality due to the anonymity of contract developers.
however regardless of their intentions their misuse of certain eip standard implementation slots misleads users.
this would cause mis identification of logic in blockchain explorers and induce security risks such as honeypot attacks as the actual contract owner may deliberately hide malicious logic.
fig.
shows an example contract that hides its logic behind a proxy deceiving blockchain explorers with a fake logic contract address.
classification.
following the existing practice by forta network we identify malicious proxies by checking whether a proxy is delegating its execution to the logic contract whose address is different from what it claims in the storage slot defined by eip .
we replay all historical transactions of the proxy and compare the address of the actual logic contract being executed to the address stored in that specific storage slot.
if they are different we consider that the proxy is dishonestly hiding its implementation and may be a malicious proxy.
results.
we successfully identified proxies that delegate their execution to a logic contract other than the one claimed in the standard storage slot defined by eip .
since smart contracts deployed on the blockchain are anonymous we are not able to confirm the underlying purpose of these proxies hiding logic contracts.
nevertheless we do find that popular blockchain explorers like etherscan indicate false logic contracts for these proxies.
for instance for the proxy contract at address 0x9276635ec39c72866f3cf70298efe501eb5dcdf1 etherscan indicates its logic contract as 0xbcb7549e7af77bce0d1bca1a5ef679594e9f2a87 while the actual executed logic contract is 0x29e45aabc905056162f7521005c6a1919ae6a32c .
finding .
contracts hide their logic behind a proxy and deceive blockchain explorers with a fake logic address.
implication.
users are advised to carefully identify the actual logic contract by simulating the execution before sending transactions to proxy contracts.
c. rq3 bugs and pitfalls for rq3 we aim to investigate the common bugs in proxies.
we first summarize three kinds of common pitfalls in implementing proxies and then identify such bugs in proxies with semi automated processes.
our goal is to 71contract audiusadminupgradeabilityproxy address private proxyadmin function upgradeto address logic external require msg.sender proxyadmin error only admin upgradeto logic 7contract governance bool private initialized bool private initializing modifier initializer require initializing !initialized function initialize address registry address guardian initializer public ... fig.
a simplified version of the vulnerable proxy in audius .
reveal the prevalence of such bugs on ethereum and offer a comprehensive understanding of them in real world proxies.
proxy logic collision many proxies implement their business logic in both proxy contracts and logic contracts e.g.
extensibility proxies in iv b2 .
if the logic contract uses the same storage slot as the code in the proxy contract but with different semantic interpretations bugs occur.
the hack of audius on july was caused by such storage collision between proxy and logic contracts inducing over .1m of loss.
fig.
shows a simplified version of the vulnerable proxy in audius.
the contract audiusadminupgradeabilityproxy is the proxy contract which delegates its business logic to contract govercance logic contract .
the contracts have proxy logic storage collision between the variable proxyadmin in audiusadminupgradeabilityproxy and variables initialized initializing ingovernance .
note that the values of initialized and initializing are packed together in one storage slot each occupying one byte.
at runtime both proxyadmin and initialized initializing point to the storage slot 0x0of the proxy contract.
however the storage value is interpreted as different types and meanings in the proxy and logic contracts.
in the audius attack the governance contract has already been initialized by the developers and should not be initialized again.
however the variable initializing loads the second byte of storage slot 0x0as a boolean value which is 0xab the second byte of the proxyadmin address on the blockchain.
as a result thegovernance contract can always be initialized again and malicious users can exploit this to make profits.
detection.
similar to the classification of extensibility proxies we detect proxy logic collision by replaying all historical transactions of each proxy and checking whether the code in the proxy contract and the code in the logic contract may access the same storage slots in transaction execution.
note that if proxy and logic contracts do not have overlaps in storage slots accessed they will never collide.
we only consider the write access to the storage slots i.e.
write write conflict since the read access in either the proxy or logic contract does not influence the execution of other contracts.
after the automateddetection of write write conflicts we manually inspect the filtered proxies to check whether they are vulnerable i.e.
having proxy logic collisions.
evaluation.
to ensure the correctness of the detection of write write conflicts we manually evaluate the correctness of our detector by sampling transactions of proxies and manually check if the write access to storage slots in transactions is correctly captured by our detector or not.
we use phalcon a popular transaction trace explorer as the ground truth of storage access.
the manual check shows accuracy in storage access detection.
note that the write write conflict detector is only meant to automatically filter proxies that potentially have proxy logic collisions before we manually inspect the contract and identify bugs.
results.
we identified proxies that contain write write conflicts on storage between the proxy and logic contract.
after the manual check it turns out that only one proxy is truly vulnerable while all other proxies are benign ones.
those benign ones are extensibility proxies as we discussed in iv b2.
the reason behind a high false positive rate is that our detection does not check whether the proxy and logic contracts interpret the shared storage slot in the same way.
the write write conflict is only buggy if the interpretation of storage values is different like the audius contract otherwise it is benign.
we leave the more precise detection of storage collision problems for future work.
finding .
the proxy is buggy if the proxy and logic contracts use the same storage slots and the semantics of the usage are different.
implication.
proxy contract developers should avoid declaring state variables in proxies and only store data in special storage slots as suggested by eip which are collision free in proxy contract code.
for extensibility proxies the logic contract should always inherit the proxy contract so that the logic contract always uses values in storage slots in the same way as the proxy contract.
logic logic collision when proxies update the address of their logic contract the new logic contract may be incompatible with the old version .
in other words the new logic contract may interpret the storage data in a different way than the previous logic contract causing unexpected behaviors.
the attack on shata capital on february exploited the logic logic storage collision.
fig.
shows the code snippets that have storage collisions between the new and old versions of logic contracts.
shata capital upgraded the logic contract from oldefvault tonewefvault .
the new logic contract newefvault changes the declaration of state variables.
in smart contracts state variables are assigned storage slots according to their declaration order.
as a result the variable assetdecimal in the new logic contract newefvault reads the storage slot that previously stored the value for the variable maxdeposit in the oldefvault contract.
after the logic upgrade the variable assetdecimal contains 81contract oldefvault ... string public constant version .
uint256 public maxdeposit uint256 public maxwithdraw bool public paused ... 9contract newefvault ... string public constant version .
uint256 private assetdecimal uint256 public maxwithdraw uint256 public maxdeposit bool public paused ... fig.
a simplified version of the old and new logic contracts that have storage collision in shata capital .
an unexpected large value which is maxdeposit in the old logic causing a severe loss of .1m.
detection.
the key to detecting logic logic collision is to determine whether the new logic contracts are compatible with the previous version s logic in terms of storage access.
one straightforward approach to check the storage compatibility of two logic contracts is to compare the storage layout of two logics.
however many of the proxies in our dataset do not have source code available thus we cannot obtain their storage layouts.
therefore we propose to simulate historical transactions on newer logics and check if the storage access patterns of historical transactions remain the same.
if a transaction simulated on a newer logic no longer accesses the storage slots that were accessed on the original logic contract on which this transaction was executed in history it is highly likely that the new logic contract has incompatible storage layouts than the previous logic.
to further increase the precision of our detection we also infer the type of storage data in logic contracts by inspecting the values being written to the storage.
if one storage slot is inferred to be different types in two logic contracts there is highly likely to be a storage collision.
specifically given a transaction toriginally executed on the logic contract lnof proxy pin history we simulate t on proxy pwith a newer logic contract lm where m n are version numbers and m n .
we record the storage access ofton logic ln in blockchain history and lm in our simulation separately.
then we check if there exist a storage access that were performed on ln original logic but not onlm newer logic .
if so the newer logic is likely to be incompatible with the original logic.
to infer the type of each storage slot in logic contracts we by default consider each shared storage slot with a union type bool int address bytes32 and then gradually narrow down its type by inspecting the values written to this storage slot during transaction execution.
specifically we assume a common value range of different types as shown in table i and discard a type if a value out of the range is written to the storage slot.
for instance if we find that there exists a transaction writting value to storage slot 0x0 we will infer that this storage slot is not of type bool .
note that our assumed value range ofbool int address bytes32 table i assumed value range of inferred types for storage slots.
types are not the theoretical value range of the corresponding solidity type.
our assumed value range is aimed to capture the range of common value at runtime and approximate the high level types in smart contracts.
we infer types of each storage slot for different logic contracts separately.
if two logic contracts of the same proxy differs in some types of storage slots there is likely to be a storage collision.
evaluation.
note that the aforementioned transaction replay and type inference are meant to automatically filter out most logic contracts that are not vulnerable before we manually check the logic contracts to identify collision bugs.
we eventually use manual analysis to inspect the implementation details of two logic contracts of the same proxy and determine whether they interpret the same storage slot in different semantics i.e.
there are logic logic collision bugs.
as such it is necessary to evaluate and ensure that the filtering process does not exclude many truly problematic proxies.
we sample pairs of old and new logic contracts excluded by transaction replay and type inference and check for storage collisions using evm.storage .
we find only two pairs with conflicting storage layouts indicating precision in our automated filtering and a low probability of missing collisions.
results.
we first simulated all transactions proxies on new versions of logic contracts and found that there are proxies whose newer logic has different storage access pattern than then old logic.
we then infer storage slot types for each logic contract of these proxies and identified proxies whose old and new logic have different storage slot types.
we further manually checked each of these proxies and confirmed that of them contain true logic logic collision bugs.
finding .
proxies may suffer from logic logic storage collision if the newly upgraded logic contract is incompatible with the old version.
we identified proxies that have logic logic collision bugs in their upgrades.
implication.
developers should keep the storage layout unchanged when upgrading logic contracts.
developers may consider to always inherit the old version of logic contract when developing a new version to ensure the storage compatibility.
uninitialized proxy smart contracts usually initialize their state in the contract constructor e.g.
set the owner of the contract which is executed when the contract is deployed.
however proxies cannot initialize their state using the constructor since the data and code are separated into two contracts proxy contract and logic contract i.e.
the constructor of the logic contract cannot initialize the data in the proxy contract.
to mitigate this issue proxies usually implement an initialize function instead which needs to 91contract proxy function fallback external address logic .
delegatecall msg.data 5contract logic address owner bool private initialized function initialize address owner public require !initialized initialized true owner owner fig.
an example proxy with initialize function.
be called explicitly after deployment.
fig.
shows an example proxy with the initialize function.
the initialize function brings a new attack surface of front running.
if the initialize function is not called within the same transaction as the contract deployment attackers may frontrun the invocation of initialize function and initialize the contract for their own use e.g.
claim the ownership as in fig.
.
uninitialized proxies have been exploited many times in history including the hacks on parity aave teller keeperdao rivermen nft harvest finance and wormhole .
detection.
we detect the uninitialized proxies by trying to invoke initialize function right after the deployment transaction of the proxy in the history.
the function initialize can only be executed once so if the developer had already initialized the proxy in the deployment transaction our invocation would fail otherwise it indicates that this is an uninitialized proxy subject to front running attacks.
one challenge is that there is no fixed function signature for initialize function.
the initialize functions in different proxies may have different names and parameters.
without knowing the function signature we cannot craft valid call data to initialize the proxy.
to tackle this challenge we mine all possible initialize function signatures on all proxies in our dataset.
we assume that for most proxies the first invocation after the deployment should be calling the initialize function.
we inspect the transaction history of each proxy and collect a set of distinct invocations of initialize functions.
in the end we replay each initializing invocation on each proxy at the moment right after their deployment transaction and check if it is possible to initialize the proxy with an arbitrary user.
evaluation.
we conduct a manual evaluation of the initialize functions we inferred automatically to ensure that we do not miss many uninitialized proxies.
specifically we sample source available logic contracts from our proxy dataset manually identify the initialize function used by these proxies and check if they are included in our automatically extracted set of initialize functions.
results show that our automated technique identifies of the initialize functions.
note that many missed initialize functions are specific only in one logic contract and that contract is often never used after deployment.
nevertheless by replaying each possible initializing invocation we faithfully identify majority of different forms of initialize functions.results.
we successfully identified proxies that were not initialized in the same transaction as the deployment.
note that although these proxies were subject to front running attacks by the time of their deployment they are not necessarily exploitable on the latest state of ethereum since the proxy may have already been initialized by the developer at present.
hence we further investigate each of these proxies manually to check whether they are still exploitable at the latest state of ethereum january .
we found that out of proxies .
are still exploitable meaning that anyone can re initialize these proxies at present.
among exploitable proxies proxies have never been initialized in history.
the rest proxies although they have already been initialized by their developers can still be re initialized due to improper access control to the initialize function.
noteworthy we were able to identify a zero day vulnerability that is still exploitable and can induce severe consequences.
the affected total value locked tvl is over 2m.
we have reported to the developers who have started working on rescuing the affected assets at the time of writing.
finding .
a proxy may be subject to front running attacks if it is not initialized within the same transaction as its deployment.
we identified a zero day vulnerability confirmed by the developer which can cause over 2m loss.
implication.
developers should be aware of the frontrunning attack risk and initialize their proxies atomically in the deployment transaction and should not allow afterward re initialization under any circumstances.
v. d iscussion a. threats to validity we acknowledge several threats to the validity of the results and findings in our study.
first quality of the proxy dataset .
we collect a large scale dataset of proxies using p roxy ex.
contracts that are not proxies may be included and some true proxies may be missed by p roxy ex.
to mitigate this threat we conducted an evaluation in iii a2 to show that proxy ex achieve a high precision and recall .
second manual inspection .
we categorized the use purposes of proxies iv b manually which may induce incompleteness and bias.
to mitigate this threat two of the authors first individually inspected the sampled proxies and proposed their categories independently.
then the two authors together with an additional author discussed and merged their proxy categories and finalize the taxonomy of use purposes with a consensus.
third validity of detected bugs .
we designed three detectors in iv c and identified several bugs from our dataset.
the detected bugs may be false positives.
to mitigate this threat we invite an experienced solidity programmer with over years of experience to confirm our findings.
b. usefulness this study aims to provide valuable insights for researchers developers and users.
for researchers our study guides future 10research by highlighting the need to focus on various types of proxies not just upgradeable ones iv b .
different uses of proxies present new challenges in contract design bug detection and on chain security.
our findings can inspire research on design trade offs of trustlessness and flexibility features in dapps upgradeability and extensibility proxies iv b1 and iv b2 and serve as heuristics for contract testing and bug detection iv c .
for blockchain users we offer a comprehensive study to understand the usage and security risks in contract proxies iv b and iv c such as malicious codehiding proxies iv b4 .
for developers our study offers practical guidance by summarizing proxy use purposes and helping developers choose the right design patterns iv b .
it alerts developers to potential security issues iv c .
developers are advised to properly initialize contract state at deployment iv c3 and carefully avoid storage collisions between both proxy logic and logic logic contracts iv c1 and iv c2 to improve dapp quality.
vi.
r elated work prior works on proxy contracts.
to the best of our knowledge prior papers related to proxy contracts mainly focus on upgradeable proxies .
bodell et al.
proposes uschunt which is a static analysis framework for detecting upgradeable smart contracts based on smart contract source code.
u schunt performs upgradeable proxy detection on ethereum based blockchains for ethereum it detects upgradeable proxies from about 500k smart contract source code.
salehi et al.
defined six smart contract upgrade patterns and built a measurement framework to study smart contracts in those categories within a one year transaction dataset.
they replayed every transaction and utilized evm transaction traces for detecting transactions using delegatecall and extracted the bytecode of the toaddress of such transactions as proxy contracts.
recently ruaro et al.proposed crush a tool focusing on detecting storage collisions in proxy smart contracts.
similar to crush solely detects delegatecall inside transactions to identify proxy and logic contracts which is overly general according to the definition of proxy from openzeppelin .
we compare our work with existing works in table ii.
in summary our work has a broader scope with three key differences.
comprehensive coverage.
we cover all proxy contracts upgradeable and non upgradeable following openzeppelin s official proxy definition existing works only cover upgradeable ones.
as shown in iv b around .
of proxies are non upgradeable.
large scale study.
we conduct the first large scale and systematic study on all proxy contracts extracting insights from three aspects statistics purpose and bugs and pitfalls.
this provides a complete view of the proxy landscape unlike existing works that focus on a single security issue storage collision in .
methodology.
our proxy detection methodology significantly differs from existing works.
u schunt detects proxies from source code but their method is limited since about twothirds of ethereum contracts lack source code .
salehi etrequire source?matching oz s proxy def?support non uscs?dataset duration uschunt yes no no mar.
jan. salehi et al.
no no no sep. jul.
crush no no yes jul.
apr.
this paper no yes yes jul.
sep. table ii comparison of our paper and related works oz s proxy def the official proxy definition by openzeppelin non usc non upgradable smart contracts.
al.
and crush detect proxies based solely on the delegatecall action which is error prone and leads to many false positives.
for instance the erc contract is incorrectly classified as a proxy.
we introduce the first approach to precisely identify proxies from contract bytecode.
empirical analysis on ethereum.
many researches perform empirical analysis on different aspects of ethereum such as the transactions and interactions among different entities .
miner extractable value mev or block extractable value bev have also attracted much interest .
however none of these works focuses on proxy contracts.
bug detection on smart contracts.
to secure smart contracts before they are deployed many works study the vulnerabilities of smart contracts and attacks transactions on ethereum.
various works use static analysis approaches such as symbolic execution to uncover vulnerabilities and bugs in smart contracts.
some other works make use of fuzzing techniques to discover bugs in smart contracts.
due to the severity of smart contract vulnerabilities and defi attacks many researchers tried to present systematization of knowledge papers soks .
compared to these works our work focuses on proxy contracts.
vii.
c onclusion the proxy pattern is an important design pattern in ethereum smart contracts.
in this paper we present the first systematic empirical study on proxy contracts at the ethereum ecosystem scale.
we build the first framework for detecting proxy contracts from bytecode and collect a dataset of proxies as well as their transactions to perform empirical analysis.
we first study the basic statistics and find that code duplication is prevalent in proxies.
to study the purpose of proxies we propose a taxonomy to categorize proxies into four categories upgradeability extensibility code sharing and code hiding and perform analysis on each type.
we further summarize three types of common bugs in proxies and design checkers to detect them in our dataset.
this paper provides valuable insights into the current landscape of proxies which can facilitate future research on different aspects of proxies.
acknowledgement this work was supported in part by an ethereum foundation academic grant and a generous gift from the forta foundation.
the purdue authors were partially supported by an ethereum foundation small grant fy24 .
11references v .
buterin ethereum white paper a next generation smart contract decentralized application platform .
ethereum ethereum.org.
.org en .
dappradar dappradar ethereum.
.com chain ethereum?range cs all .
v .
buterin eip contract code size limit ethereum improvement proposals no.
.
.ethereum .org eips eip .
n. mudge eip diamonds multi facet proxy ethereum improvement proposals no.
.
.ethereum .org eips eip2535.
y .
kambayashi and h. ledgard the separation principle a programming paradigm ieee software vol.
no.
pp.
.
g. wood et al.
ethereum a secure decentralised generalised transaction ledger ethereum project yellow paper .
w. e. bodell iii s. meisami and y .
duan proxy hunting understanding and characterizing proxy based upgradeable smart contracts in blockchains in 32nd usenix security symposium .
m. salehi j. clark and m. mannan not so immutable upgradeability of smart contracts on ethereum arxiv preprint arxiv .
.
n. ruaro f. gritti r. mclaughlin i. grishchenko c. kruegel and g. vigna not your type!
detecting storage collision vulnerabilities in ethereum smart contracts e. i. proposals erc proxy storage slots.
https eips .ethereum .org eips eip .
etherscan etherscan.
.io .
l. brent a. jurisevic m. kong e. liu f. gauthier v .
gramoli r. holz and b. scholz vandal a scalable security analysis framework for smart contracts arxiv preprint arxiv .
.
m. zhang x. zhang y .
zhang and z. lin txspector uncovering attacks in ethereum from transactions in 29th usenix security symposium .
n. grech m. kong a. jurisevic l. brent b. scholz and y .
smaragdakis madmax surviving out of gas conditions in ethereum smart contracts proceedings of the acm on programming languages vol.
no.
oopsla pp.
.
n. grech l. brent b. scholz and y .
smaragdakis gigahorse thorough declarative decompilation of smart contracts in international conference on software engineering icse .
ethervm online solidity decompiler.
.io decompile .
n. grech s. lagouvardos i. tsatiris and y .
smaragdakis elipmoc advanced decompilation of ethereum smart contracts proceedings of the acm on programming languages vol.
no.
oopsla1 pp.
.
g. bigquery ethereum in bigquery a public dataset for smart contract analytics.
.google .com blog products data analytics ethereum bigquery public dataset smart contract analytics .
etherscan address.
.io address 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48 .
etherscan eventshistory contract address.
.io address 0x60bf91ac87fee5a78c28f7b67701fbcfa79c18ec .
openzeppelin the transparent proxy pattern.
https blog .openzeppelin .com the transparent proxy pattern .
g. barros and p. gallagher eip universal upgradeable proxy standard uups ethereum improvement proposals no.
.
.ethereum .org eips eip .
p. murray n. welch and j. messerman erc minimal proxy contract.
.ethereum .org eips eip .
v .
buterin delegatecall forwarders how to save contracts with the same code.
.reddit .com r ethereum comments 6c1jui delegatecall forwarders how to save 5098 on .
etherscan proxy contract address with the highest upgreade frequency.
.io address 0x3d71d79c224998e608d03c5ec9b405e7a38505f0 .
ethereum erc20 token.
.org en developers docs standards tokens erc .
etherscan address.
.io address 0x630d98424efe0ea27fb1b3ab7741907dffeaad78 .
f. cernera m. l. morgia a. mei and f. sassi token spammers rug pulls and sniper bots an analysis of the ecosystem of tokens in ethereum and in the binance smart chain bnb in 32nd usenixsecurity symposium usenix security anaheim ca pp.
usenix association aug. .
etherscan authenticatedproxy contract address.
.io address 0xf9e266af4bca5890e2781812cc6a6e89495a79f2 .
l. chen j. peng y .
liu j. li f. xie and z. zheng phishing scams detection in ethereum transaction network acm transactions on internet technology toit vol.
no.
pp.
.
s. li g. gou c. liu c. hou z. li and g. xiong ttagn temporal transaction aggregation graph network for ethereum phishing scams detection in proceedings of the acm web conference pp.
.
s. yang f. zhang k. huang x. chen y .
yang and f. zhu sok mev countermeasures theory and practice arxiv preprint arxiv .
.
f. community evasion techniques report on the continuous monitoring.
.com apehex web3 evasion techniques blob main report forta .pdf .
l. academy honeypot crypto scam meaning.. https www .ledger .com academy glossary honeypot crypto scam .
f. network evasion bounty fake standards.
.notion .site evasion bounty fake standards673a496a7684498a80ca4d07060fb160 .
audius audius governance takeover post mortem .
.audius .co article audius governance takeover post mortem7 .
blocksec phalcon explorer.
.com explorer .
peckshield it seemed shata capital s efvault suffered from an upgrade glitch.
.com peckshield status .
evm.storage blockchain search exploration.. https explorer .sim .io .
openzeppelin the parity wallet hack explained.
https blog .openzeppelin .com on the parity wallet multisig hack405a8c12e8f7 .
trailofbits breaking aave upgradeability.
.trailofbits .com breaking aave upgradeability .
immunefi teller bugfix review and bug bounty launch.
.com immunefi teller bug fix postmorten and bugbounty launch b3f67a65c5ac.
iosiro perma brick uups proxies with this one trick devs hate this!
.
.com blog openzeppelin uups proxy vulnerabilitydisclosure.
immunefi harvest finance uninitialized proxies bugfix review 200k bounty.
.com immunefi harvest finance uninitializedproxies bug fix postmortem ea5c0f7af96b.
immunefi wormhole uninitialized proxy bugfix review.
.com immunefi wormhole uninitialized proxy bugfixreview 90250c41a43a.
openzeppelin openzeppelin docs proxies.
https docs .openzeppelin .com contracts .x api proxy .
t. abdelaziz and a. hobor smart learning to find dumb contracts in32nd usenix security symposium usenix security pp.
.
e. i. proposals erc single contract multi delegatecall.. https eips .ethereum .org eips eip .
x. t. lee a. khan s. sen gupta y .
h. ong and x. liu measurements analyses and insights on the entire ethereum blockchain network in proceedings of the web conference .
t. chen z. li y .
zhu j. chen x. luo j. c. s. lui x. lin and x. zhang understanding ethereum via graph analysis acm transactions on internet technology toit .
l. zhao s. sengupta a. khan and r. luo temporal analysis of the entire ethereum blockchain network proceedings of the web conference .
q. bai c. zhang y .
xu x. chen and x. wang evolution of ethereum a temporal graph perspective .
a. said m. u. janjua s. u. hassan z. muzammal t. saleem t. thaipisutikul s. tuarob and r. nawaz detailed analysis of ethereum network on transaction behavior community structure and link prediction peerj computer science .
d. lin j. wu q. yuan and z. zheng modeling and understanding ethereum transaction records via a complex network approach ieee transactions on circuits and systems ii express briefs .
j. zanelatto gavi o mascarenhas a. ziviani k. wehmuth and a. b. vieira on the transaction dynamics of the ethereum based cryptocurrency journal of complex networks .
l. liu l. wei w. zhang m. wen y .
liu and s. c. cheung characterizing transaction reverting statements in ethereum smart contracts inproceedings of the 36th ieee acm international conference on automated software engineering ase p. ieee press .
p. daian s. goldfeder t. kell y .
li x. zhao i. bentov l. breidenbach and a. juels flash boys .
frontrunning transaction reordering and consensus instability in decentralized exchanges arxiv preprint arxiv .
.
k. qin l. zhou and a. gervais quantifying blockchain extractable value how dark is the forest?
arxiv preprint arxiv .
.
c. f. torres r. camino and r. state frontrunner jones and the raiders of the dark forest an empirical study of frontrunning on the ethereum blockchain arxiv preprint arxiv .
.
y .
wang y .
chen h. wu l. zhou s. deng and r. wattenhofer cyclic arbitrage in decentralized exchanges available at ssrn .
a. capponi r. jia and y .
wang the evolution of blockchain from lit to dark arxiv preprint arxiv .
.
j. piet j. fairoze and n. weaver extracting godl from the salt mines ethereum miners extracting value arxiv preprint arxiv .
.
b. weintraub c. f. torres c. nita rotaru and r. state a flash bot in the pan measuring maximal extractable value in private pools arxiv preprint arxiv .
.
x. lyu m. zhang x. zhang j. niu y .
zhang and z. lin an empirical study on ethereum private transactions and the security implications arxiv preprint arxiv .
.
w. zhang l. wei s. c. cheung y .
liu s. li l. liu and m. r. lyu combatting front running in smart contracts attack mining benchmark construction and vulnerability detector evaluation ieee transactions on software engineering vol.
no.
pp.
.
s. grossman i. abraham g. golan gueta y .
michalevsky n. rinetzky m. sagiv and y .
zohar online detection of effectively callback free objects with applications to smart contracts proceedings of the acm on programming languages .
l. luu d. h. chu h. olickel p. saxena and a. hobor making smart contracts smarter in proceedings of the acm sigsac conference on computer and communications security acm .
i. nikoli c a. kolluri i. sergey p. saxena and a. hobor finding the greedy prodigal and suicidal contracts at scale in proceedings of the 34th annual computer security applications conference acm .
p. tsankov a. dan d. drachsler cohen a. gervais f. buenzli and m. vechev securify practical security analysis of smart contracts in proceedings of the acm sigsac conference on computer and communications security acm .
j. krupp and c. rossow teether gnawing at ethereum to automatically exploit smart contracts in 27th usenix security symposium .
consensys mythril classic.
.com consensys mythrilclassic .
trailofbits manticore symbolic execution tool.
.com trailofbits manticore .
j. feist g. grieco and a. groce slither a static analysis framework for smart contracts in ieee acm 2nd international workshop on emerging trends in software engineering for blockchain wetseb ieee .
s. kalra s. goel m. dhawan and s. sharma zeus analyzing safety of smart contracts in proceedings of the 25th annual network and distributed system security symposium .
c. f. torres j. sch tte and r. state osiris hunting for integer bugs in ethereum smart contracts in proceedings of the 34th annual computer security applications conference .
j. frank c. aschermann and t. holz ethbmc a bounded model checker for smart contracts in 29th usenix security symposium .
s. tikhomirov e. v oskresenskaya i. ivanitskiy r. takhaviev e. marchenko and y .
alexandrov smartcheck static analysis of ethereum smart contracts in ieee acm 1st international workshop on emerging trends in software engineering for blockchain wetseb ieee .
p. bose d. das y .
chen y .
feng c. kruegel and g. vigna sailfish vetting smart contract state inconsistency bugs in seconds in ieee symposium on security and privacy sp ieee .
w. zhang z. zhang q. shi l. liu l. wei y .
liu x. zhang and s. c. cheung nyx detecting exploitable front running vulnerabilities in smart contracts in ieee symposium on security and privacy sp pp.
ieee computer society .
b. jiang y .
liu and w. chan contractfuzzer fuzzing smart contracts for vulnerability detection in 33rd ieee acm international conference on automated software engineering ase ieee .
g. grieco w. song a. cygan j. feist and a. groce echidna effective usable and fast fuzzing for smart contracts in proceedings of the 29th acm sigsoft international symposium on software testing and analysis .
v .
w stholz and m. christakis harvey a greybox fuzzer for smart contracts in proceedings of the 28th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering .
t. d. nguyen l. h. pham j. sun y .
lin and q. t. minh sfuzz an efficient adaptive fuzzer for solidity smart contracts in proceedings of the acm ieee 42nd international conference on software engineering .
j. choi d. kim s. kim g. grieco a. groce and s. k. cha smartian enhancing smart contract fuzzing with static and dynamic data flow analyses in 36th ieee acm international conference on automated software engineering ase ieee .
a. groce and g. grieco echidna parade a tool for diverse multicore smart contract fuzzing in proceedings of the 30th acm sigsoft international symposium on software testing and analysis .
j. he m. balunovi c n. ambroladze p. tsankov and m. vechev learning to fuzz from symbolic execution with application to smart contracts in proceedings of the acm sigsac conference on computer and communications security .
c. liu h. liu z. cao z. chen b. chen and b. roscoe reguard finding reentrancy bugs in smart contracts in ieee acm 40th international conference on software engineering companion icse companion ieee .
c. f. torres a. k. iannillo a. gervais and r. state confuzzius a data dependency aware hybrid fuzzer for smart contracts in ieee european symposium on security and privacy euros p ieee .
y .
fu m. ren f. ma h. shi x. yang y .
jiang h. li and x. shi evmfuzzer detect evm vulnerabilities via fuzz testing in proceedings of the 27th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering .
m. rodler d. paa en w. li l. bernhard t. holz g. karame and l. davi ef cf high performance smart contract fuzzing for exploit generation arxiv preprint arxiv .
.
n. atzei m. bartoletti and t. cimoli a survey of attacks on ethereum smart contracts sok in international conference on principles of security and trust springer .
l. zhou x. xiong j. ernstberger s. chaliasos z. wang y .
wang k. qin r. wattenhofer d. song and a. gervais sok decentralized finance defi incidents arxiv preprint arxiv .
.
s. m. werner d. perez l. gudgeon a. klages mundt d. harz and w. j. knottenbelt sok decentralized finance defi arxiv preprint arxiv .
.
l. heimbach and r. wattenhofer sok preventing transaction reordering manipulations in decentralized finance in 4th acm conference on advances in financial technologies aft .
s. eskandari s. moosavi and j. clark sok transparent dishonesty front running attacks on blockchain in financial cryptography and data security fc international workshops springer .
n. ivanov c. li q. yan z. sun z. cao and x. luo security threat mitigation for smart contracts a comprehensive survey acm computing surveys .
m. zhang x. zhang j. barbee y .
zhang and z. lin sok security of cross chain bridges attack surfaces defenses and open problems arxiv preprint arxiv .
.
z. zhang b. zhang w. xu and z. lin demystifying exploitable bugs in smart contracts in proceedings of the 45th international conference on software engineering .