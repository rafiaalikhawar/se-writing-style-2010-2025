efficiently finding higher order mutants chu pan wong carnegie mellon university usajens meinicke carnegie mellon university usaleo chen carnegie mellon university usa jo o p. diniz federal university of minas gerais brazilchristian k stner carnegie mellon university usaeduardo figueiredo federal university of minas gerais brazil abstract higher order mutation has the potential for improving major drawbacks of traditional first order mutation such as by simulating more realistic faults or improving test optimization techniques.
despite interest in studying promising higher order mutants such mutants are difficult to find due to the exponential search space of mutation combinations.
state of the art approaches rely on genetic search which is often incomplete and expensive due to its stochastic nature.
first we propose a novel way of finding a complete set of higherorder mutants by using variational execution a technique that can in many cases explore large search spaces completely and often efficiently.
second we use the identified complete set of higher order mutants to study their characteristics.
finally we use the identified characteristics to design and evaluate a new search strategy independent of variational execution that is highly effective at finding higher order mutants even in large codebases.
ccs concepts software and its engineering software testing and debugging search based software engineering .
keywords mutation analysis higher order mutant variational execution acm reference format chu pan wong jens meinicke leo chen jo o p. diniz christian k stner and eduardo figueiredo.
.
efficiently finding higher order mutants.
in pr oceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
introduction mutation analysis has been studied for decades in research and is increasingly adopted in industry .
mutation analysis has many applications including assessing and improving test suite quality generating or minimizing a test suite or as a proxy for evaluating other research techniques such as fault localization .
first three authors contributed equally to the paper esec fse november virtual event usa copyright held by the owner author s .
acm isbn .
original bool f int a int b if a return a b return a bmutation fom bool f int a int b if a !
return a b return a b mutation fom bool f int a int b if a return a b return a bboth hom bool f int a int b if a !
return a b return a btest orig.
mut.
mut.
both failure cond.
t1 assert f m1 m2 t2 assert !f m1 m2 t3 assert !f m1 m2 figure example of mutations with their test outcomes.
traditionally mutation analysis injects syntactic mutations into an existing program and runs the existing tests to assess whether the tests are sensitive enough to detect the mutations.
higher order mutation is the idea of combining multiple mutations to represent more subtle changes more complex changes or changes that better mirror human mistakes .
to that end jia and harman distinguish first order mutants consisting of a single change from higher order mutants that combine multiple changes cf.
fig.
.
while most research on mutation analysis has focused on first order mutants recent studies claim that higher order mutants are less likely to be equivalent mutants and that higher order mutants can reduce test effort .
in section we will discuss a specific use case with a motivating example.
a key challenge in adopting higher order mutation is identifying beneficial higher order mutants.
most higher order mutants are as easy to kill as their constituent first order mutants due to coupling.
jia and harman argue that only a subset of all possible combinations better simulate real faults and increase the subtlety of the seeded faults.
specifically jia and harman look for what they name a strongly subsuming higher order mutant sshom a particular kind of higher order mutant that is harder to detect than its constituent first order mutants as we will explain in section .
however sshoms are tricky to find among the vast quantity of possible combinations of first order mutants.
current approaches use genetic search techniques guided by a simple fitness function .
since sshoms are difficult to find little is known about them and their characteristics.
in this work we develop a technique that can find a complete set of sshoms for given first order mutations and tests onsmall to medium sized programs which enables us to study characteristics of sshoms.
based on the identified characteristics we then develop a new heuristic search technique that is lightweight scalable and practical.
overall we proceed in three steps 1165this work is licensed under a creative commons attribution international .
license.
esec fse november virtual event usa chu pan wong jens meinicke leo chen jo o p. diniz christian k stner and eduardo figueiredo variational search for the purpose of studying sshom in a controlled setting we develop a new search strategy search var that allows us to find a complete set of higher order mutants for a given test suite and given set of first order mutants in small to medium sized programs.
specifically we use variational execution a dynamic analysis technique that jointly explores many similar executions of a program.
conceptually our approach searches for all possible higher order mutants at the same time identifying with a propositional formula for each test case which mutants and combinations of mutants cause a test to fail.
from these formulas we then encode search as a boolean satisfiability problem to enumerate allsshoms.
an exploration of allpossible mutant combinations with variational execution is often feasible forsmall to medium sized programs because variational execution shares commonalities among repetitive executions.
though it does not scale to all programs analyzing a complete set of sshoms for smaller programs and their test suites allows us to study sshoms more systematically.
characteristics analysis we study the characteristics of the identified higher order mutants from step .
where previous approaches found only a few samples of higher order mutants we have a unique opportunity to study the characteristics of higherorder mutants on a much more complete set.
we analyze characteristics such as the typical number of mutants combined and their distance in the code.
this helps us better understand higher order mutants without the potential sampling bias from a search heuristic.
for example we found that most sshoms are composed of fewer than first order mutants and that constituent first order mutants tend to locate within the same method or the same class.
prioritized heuristic search finally we develop a second new search strategy search prithat prioritizes likely promising combinations of first order mutants based on the characteristics identified in step .
the search priis easy to implement and does not require the heavyweight variational analysis of search var.
although it does not provide any completeness guarantees it is highly efficient at finding higher order mutants fast and scales to much larger systems with thousands of first order mutants.
we evaluate the new search strategy using a different set of larger systems to avoid overfitting.
our results indicate that the identified characteristics indeed effectively guide the search.
for example we found sshoms among combinations of first order mutations where existing search approaches can barely find any.
we make the following contributions in this work we propose a novel way of using variational execution to find acomplete set of sshoms for a given set of first order mutations and tests by formalizing the search as a boolean satisfiability problem.
an evaluation of small to medium sized programs shows that we can achieve completeness and simultaneously increase efficiency section .
using the identified set of sshoms we make the first step in studying the basic characteristics of sshoms to inform future research section .
to show how useful the characteristics are we use them to design a new lightweight prioritized search strategy independent of variational execution.
we evaluate the prioritized search strategy on a fresh set of larger benchmarks showing that the new search is scalable and generalizable section .
higher order mutants mutation analysis introduces a set of syntactic changes to a software artifact and observes whether the previously passing test suite is sensitive enough to detect the changes termed to kill the mutant .
traditionally many simple small changes are explored in isolation one at a time several catalogs of mutation operators that perform small syntactic changes exist .
in its simplest form higher order mutants are combinations of two or more first order mutants .
the set of possible secondorder mutants grows quadratically with the size of the set of firstorder mutants from which they are combined if considering combining more than two first order mutants the set of possible higherorder mutants grows much faster.
many higher order mutants are of little value in practice because a test that would kill any constituent first order mutant will likely also kill the higher order mutant discussed as the coupling effect hypothesis .
however jia and harman argue that there exist several classes of higher order mutants that exhibit interesting behavior.
they specifically highlight strongly subsuming higherorder mutant sshom in which the constituent mutants interact in ways making the higher order mutant hard to kill as we will explain in detail in section .
.
.
usefulness of higher order mutants a recent survey of over papers on higher order mutation testing summarized a large number of different application scenarios for higher order mutants claimed in prior research including mutant reduction coupling effect analysis equivalent mutant reduction test data evaluation and test suite reduction .
in the following we illustrate a concrete example of how higher order mutations can be useful to softwareengineering researchers for creating synthetic but challenging faults to evaluate various software engineering tools.
the effectiveness of many approaches in software engineering research needs to be evaluated on faults in software systems.
for example fault localization tools need to evaluate how accurately they can localize the faults test suite generation tools need to evaluate how effective the generated tests are at finding bugs and program repair tools need to evaluate how many faults they can repair.
when evaluating their tools researchers often have the choice of running evaluations on a curated often small set of real bugs or running on large numbers of synthetically seeded bugs.
both approaches have known benefits and drawbacks seeded faults are convenient easy to create and providing a perfect ground truth they allow researchers to run experiments with very large numbers of faults on almost any system.
for example fault localization techniques were often evaluated on artificially seeded single edit faults such as those in the siemens test suite e.g.
.
researchers have been critical of this style of evaluation arguing that seeded single edit faults are not representative of most real faults which often require fixes in multiple locations and that fault localization techniques may not generalize as they are over optimized in finding such simple single edit faults .
in contrast if curated well datasets of real faults can be much more representative of realistic usage scenarios.
research on 1166efficiently finding higher order mutants esec fse november virtual event usa bool f int a int b if a !
return a b return a b a mutation 1bool f int a int b if a return a b return a b b mutation 2bool f int a int b if a !
return a b return a b c hom figure suspicious lines based on spectrum based fault localization .
the ranking is shown as the intensity of danger suspicious caution and safe .
automated program repair is almost exclusively evaluated on a few hundred real faults .
for example the widely used defects4j dataset curated faults from libraries.
creating high quality datasets of realistic and representative faults is challenging and typically requires significant human and engineering effort .
therefore while it is easy to seed millions of faults in almost any program only a few datasets of curated real faults are available often only with moderate numbers of faults in a small number of libraries or programs.
some researchers warn that overly focusing on a few shared datasets of faults leads to approaches that overfit the available faults .
in this tension between simple seeded faults and expensive to curate real faults higher order mutation may provide a compromise.
certain kinds of higher order mutants in particular sshoms that we study in this work are more subtle and harder to kill shown both theoretically and empirically .
they are more promising to simulate real faults than traditional first order mutants for example zhong and su and just et al .
found that more than of real faults are caused by faults in more than two locations.
just et al .
also found that of real faults are coupled to mutants while on average mutants are coupled to a single real fault.
that is certain kinds of higher order mutants may be more representative of real faults.
thus assuming we can find them efficiently which is the goal of this paper we can still automate their creation and seed thousands of these more challenging faults in almost any software system.
let us illustrate the potential of higher order mutation for fault localization in figure .
our example program from figure is mutated with two first order mutants which are later combined to form a higher order mutant note how this higher order mutant fails for fewer test cases than the constituent first order mutants.
in this simple setting the classic fault localization technique tarantula works quite well for the first order mutants highlighting the mutated lines as shown in figure but tarantula fails to report the two mutated lines of the higher order mutant instead highlighting the unchanged line.
this example shows how fault localization fails to locate the faulty lines of interacting mutations which as discussed may be expected for realistic faults .
as a further consequence a program repair technique based on spectrum based fault localization may not even attempt to fix the first return statement .
to realize the full potential of higher order mutants for these and other use cases it is critical to have an efficient way of finding interesting higher order mutants.
in this work we do not reevaluate the usefulness of homs for various use cases or how well they represent real faults which has been studied repeatedlyand comprehensively in prior work .
instead we focus on a technical problem that made sshoms too costly and impractical how to efficiently find sshoms .
.
strongly subsuming higher order mutants sshoms jia and harman classify higher order mutants into several kinds highlighting sshoms as useful.
for this reason our work targets sshoms though we expect that it can be generalized to other classes of higher order mutants.
specifically jia and harman define an sshom as a higher order mutant that can only be killed by a subset of test cases that kill all its constituent first order mutants.
more formally let hbe a higher order mutant composed of first order mutants f1 f2 .
.
.
fn ththe set of test cases that kill the higher order mutant h and tithe set of test cases that kill the first order mutant fi then his an sshom if and only if th th i .
.
.nti if we further restrict thto be a strict subset we get an even stronger type of sshom which we call strict strongly subsuming higher order mutant denoted as strict sshom .1in other words there must be at least one test case that kills one of the first order mutants but not the higher order mutant.
thus in a strict sshom multiple first order mutants interact such that they mask each other at least for some test cases making the strict sshom harder to kill than all the constituent first order mutants together.
our manually constructed sshom in figure illustrates this relation intuitively the first first order mutant replacing by !
forces the execution to go into an unexpected branch and the second replacing by inverts the return values.
the two changes in control and data flow are easy to detect separately i.e.
killed by two test cases each but the combination of them is more subtle and only detected by one test case.
.
finding sshoms sshom is defined in terms of test results of first order mutants .
all existing search strategies aim to find sshoms in terms of a given test suite and a given set of first order mutants.
the search space can be large due to the exponential combinatorial explosion of possible mutant combinations.
since only very few of the combinations are interesting and those are hard to find in a vast search space higherorder mutation testing has long been considered too expensive.
jia and harman explored several search techniques to find sshoms finding that genetic search performs best.
we will use their genetic search strategy together with a brute force strategy as baselines for our evaluations.
although the genetic search has been shown to successfully find sshoms it requires considerable resources to evaluate many candidates involves significant randomness and cannot enumerate all sshoms in the search space.
it is conceptually possible to define sshoms in terms of an idealized test suite that represents all possibly infinite possible 1sshoms have been defined inconsistently in the literature as subset and strict subset .
we inherit the definition of sshoms from harman et al .
as it is the most recent work.
as we will see in the evaluation the difference between subset and strict subset is significant so we make the distinction explicit introducing strict sshom as a distinct subclass and reporting results for both.
1167esec fse november virtual event usa chu pan wong jens meinicke leo chen jo o p. diniz christian k stner and eduardo figueiredo def findsshoms program p mutants m testsuite t failing conditions map merge all first order mutants into one meta program mutated p encode all mutants p m for test t variational execution returns under what combinations of mutants the given test fails compactly represented as a propositional formula.
ft variational execution mutated p mutated program test entry point of execution m symbols representing mutants failing conditions.add test ft search of sshoms as a satisfiability problem using equation constraint encodesat failing conditions t m allsat returns all solutions to the constraint each represented as a set of activated variables first order mutants found sshoms allsat constraint return foundsshoms figure using variational execution to find sshoms.
behaviors in the program.
in practice though all search strategies have to work with existing test suites and whether a combination of first order mutants is considered an sshom is evaluated in terms of a given test suite.
different test suites and different first order mutants may result in different sshoms sshoms found with a specific test suite could be interpreted as approximations of sshoms potentially found with an idealized test suite.
a specific test suite and set of first order mutants form a large but finite search space and it is possible to define and find a complete set of sshoms with regard to those given mutants and tests as we will discuss in section .
in this paper in line with prior work on finding sshoms we focus on finding sshoms with regard to a fixed test suite and fixed set first order mutants as would be useful in the fault localization and program repair scenarios discussed above.
although orthogonal to the goal of this work which is improving existing search strategies in appendix a we discuss the notion of sshoms in terms of a theoretical idealized test suite and the influence of test suite size on identifiable sshoms.
step complete search with variational execution search var in this step we develop search varto compute a complete set of sshoms with respect to given tests and first order mutants so that we can study their properties later.
figure shows the pseudo code of applying variational execution to find sshoms.
first given a program under analysis p we mutate it into p by applying our mutation operators exhaustively at every applicable location to generate all first order mutants upfront.
we represent each first order mutant as a boolean option and use a ternary conditional operator to encode the change.
mutations to the same expression are expressed as nested ternary conditional expressions.
for example we show below how we encode the two first order mutants from figure .
bool f int a int b if m1 ?
a !
a return m2 ?
a b a b return a b after encoding first order mutants we use variational execution as a black box technique to explore for each test case under what combinations of first order mutants the test would fail.
in a nutshell variational execution runs the program by dynamically tracking thedifferences in program state that are caused by mutations similar to executing the program symbolically with symbolic values for all mutations .
conceptually a single run of variational execution is equivalent to running all combinations of first order mutations in a brute force fashion but it is usually much faster due to the sharing of similar executions at runtime .
for each test execution variational execution will return a failing condition which is a propositional formula that represents exactly the combinations of mutations for which the test fails.
we show examples of failing conditions in our running example in figure last table column .
finally we collect all propositional failing conditions for all test cases and use them to search for sshoms by encoding the search as a boolean satisfiability problem.
using bdds or sat solvers we can then enumerate all solutions which correspond directly to all sshoms.
although the formulas can be large if we have many firstorder mutants and test cases and finding satisfiable assignments is np hard modern sat solving techniques are scalable enough.
our implementation and data are available on github com poosomooso sshom search.
.
mutant generation we generate first order mutants exhaustively and encode them all at once into a metaprogram which is later used for finding sshoms.
this compact encoding of mutations defines a finite search space which is critical for variational execution to be efficient .
similar encodings have been explored in different contexts such as speeding up mutation testing .
using this encoding we also ensure a fair comparison with baseline approaches by excluding compilation time and using the same metaprograms.
for our experiments we implemented mutation operators arithmetic operator replacement aor mutating relational operator replacement ror mutating !
and logical connector replacement lcr mutating and .
these comprise of most well studied mutation operators excluding two further based on recent insights absolute value insertion abs has been shown to be less useful in practice so we excluded it to avoid a meaninglessly large search space.
unary operator insertion uoi would add many more mutants most of which are likely equivalent to the ones generated from other mutation operators e.g.
mutating a btoa b using uoi is equivalent to a b using aor .
.
variational execution we use variational execution to determine which combinations of mutants fail a test case.
the novelty of using variational execution lies in the efficient and complete exploration of all mutants as opposed to one mutant at a time in traditional search based approaches.
for this work we use variational execution as a black box technique and so the technical details of how it works are not relevant.
we only provide intuition and refer the interested readers to the existing literature for a more in depth discussion .
conceptually variational execution is similar to symbolic execution in that it executes a program with symbolic boolean values representing mutants and concrete values for test inputs.
specifically variational execution performs computations with conditional 1168efficiently finding higher order mutants esec fse november virtual event usa values which may represent multiple alternative concrete values.
for example a conditional value indicates that it has the value 1under and 1otherwise.
conditional values can represent a finite number of alternative concrete values distinguished by propositional conditions over symbolic values representing mutations .
variational execution computes with conditional values and propagates them along data and control flow.
at control flow decisions both branches are explored under corresponding symbolic path conditions afterward state is merged again into conditional values to exploit sharing in subsequent statements.
in a nutshell variational execution can be considered as an extreme design choice among various forms of symbolic program evaluation for finite domains in which computations are maximally performed on concrete values but boolean symbolic values may distinguish between multiple concrete values in program state .
for our purposes we consider all boolean options representing first order mutants as symbolic options.
this way all state changes caused by mutants can be compactly tracked which enables us to explore all combinations of mutants at the same time.
as output we determine under which combinations of mutants a test case fails propositional formula over first order mutants as illustrated in fig.
by simply observing under which condition any asserted expression evaluates to false.
in theory mutant interactions can cause a combinatorial explosion in conditional values where exponentially many alternative values for different combinations of mutants need to be tracked for a single variable.
however in practice not all mutants affect each test and not all mutants interact enabling an often reasonably efficient exploration of all feasible combinations.
we defer the discussion of this scalability issue to section .
.
multiple implementations of variational execution exist for a number of programming languages .
for details on variational execution and how it differs from symbolic execution e.g.
finite symbolic domain efficient state sharing previous work describes implementations and provided formal semantics for a core calculus .
we use varexc a state of the art implementation of variational execution for java .
.
sshom search as a sat problem we use the output of variational execution propositional formulas indicating under which combinations of mutations each test fails to construct a single formula that is satisfiable exactly for those assignments that represent sshoms based on our definition of sshom in section .
.
this way the search for sshoms is transformed into a boolean satisfiability problem which we can solve with bdds or sat solvers.
to derive the formula we outline the criteria for identifying sshoms as defined by jia and harman see sec.
.
and construct a logical expression for each criterion.
lettbe the set of all tests mbe the set of all first order mutants andftbe the propositional formula over literals from mdescribing the mutant configurations in which test t tfails fis generated with variational execution see above .
as a shorthand let m t be the result of evaluating ftwith first order mutant massigned to trueand all other mutants assigned to false in other words whether testtfails for first order mutant m. to identify sshoms we encode three criteria first we ensure that a mutant combination is killed by at least one test encoding th in formula sec.
.
the sshom must fail at least one test i.e.
must not be an equivalent mutant t tft second if a given mutant combination i.e.
higher order mutant is killed by a test t the same test must kill each constituent firstorder mutant.
that is for all tests and first order mutants the first order mutant must either be killed by the test m t or not be part of the higher order mutant m .
this is the encoding of th i .
.
.ntiin equation sec.
.
every test that fails the sshom must fail each constituent first order mutant t t ft m m m m t in addition we can optimize for sshoms that are harder to kill than the constituent first order mutants excluding those that are equally difficult to kill .
as discussed in section .
we call these strict sshom and require a strict subset relation in equation i.e.
th i .
.
.ntirather than th i .
.
.nti which requires the additional encoded condition there exists a test that can kill all constituent first order mutants but cannot kill the strict sshom.
t t ft m m m m t to find sshoms and strict sshoms we take the conjunction of equations and respectively and use bdd or sat solver to iterate over all possible solutions.
for example if our approach returns a satisfiable assignment in which m1andm3are selected and all other mutants are deselected then the combination of m1 andm3is a valid strict sshom.
we use bdds to enumerate all satisfiable solutions by default.
while constructing bdds can be expensive getting a solution from a bdd is fast o n where nrepresents the number of boolean variables .
in some rare cases where we cannot construct a bdd due to insufficient memory we fall back to using a sat solver.
with a sat solver we ask for one possible solution then add the negation of that solution as an additional constraint before asking for the next solution repeating the process until all solutions are enumerated.
we can usually efficiently enumerate allpossible sshoms for the given set of first order mutants and the variational execution result of a given test suite.
.
limitations while variational execution and the sat encoding provide a new strategy to find sshoms this approach comes also with severe restrictions mostly regarding scalability and engineering limitations inherited from the tools we use which limits broad applicability in practice which we address with an alternative strategy in sec.
.
combinatorial explosion .
recent studies show that combinatorial explosion is uncommon for the types of highly configurable programs analyzed with variational execution in the past mainly because programs are usually written by human developers to have manageable interactions among options.
when applied to 1169esec fse november virtual event usa chu pan wong jens meinicke leo chen jo o p. diniz christian k stner and eduardo figueiredo higher order mutation testing we did observe some combinatorial explosion caused by random combinations of first order mutants.
for example we observed cases where interactions of first order mutants create more than alternative concrete values in one single local variable.
we argue that this is the essential complexity of the mutated program and it would be equally difficult for other approaches to exhaustively explore a complex search space like this.
however it is possible to find efficient search strategies when giving up the completeness goal as we will show in sec.
.
in the evaluation of search var we manually removed some problematic first order mutants and test cases that caused an excessive number of interactions see table .
for fairness we remove these mutants and test cases across all compared approaches.
environment barrier .
similar to symbolic execution variational execution needs to handle the environment barrier carefully when interacting with an external runtime environment that is not aware of conditional values or path conditions.
this barrier often manifests as i o or native method calls.
there are several common strategies to mitigate this issue such as creating models for these operations .
in our study only a few tests and mutants triggered problematic environment interactions.
while solvable with engineering effort we consider them noncritical for our goal and removed the problematic tests or mutants after manual inspection.
.
evaluation in addition to using search varto get a complete set of sshoms with regard to given tests and first order mutants we compare the efficiency and effectiveness of search varagainst the existing stateof the art genetic search search gen and a baseline brute force strategy search bf based on subject systems previously used in evaluating the genetic search strategy .
subject systems .
we replicate the setup of the largest previous study on higher order mutation testing .
while we cannot perform an exact replication since we could not obtain the original tools from the authors not all relevant details and parameters have been published and some engineering limitations discussed earlier we still select the same subject systems and reimplement search strategies in our own infrastructure.
that is our results cannot be compared directly against the numbers reported in prior work but we report comparable numbers within a consistent setup.
we use the same four small to medium sized java programs monopoly cli chess and validator all of which come with good quality test suites that are deemed complete by developers .
in addition we use the triangle program commonly used in mutation testing .
we report the statistics of our subject systems in table top which are comparable to those reported in prior work with slight differences likely caused by different mutation operators used and excluded tests as discussed in section .
.
baseline search strategies .
we compare our approach against the state of the art genetic algorithm and a naive bruteforce search.
the brute force search iterates over all valid higherorder mutants starting from all pairs then all triples and so on until a time limit is reached.
the brute force search serves as a reliable baseline as there is no randomness involved.
we reimplemented the genetic algorithm approach based on the description in jia et al.
s work .
as the exact setup wassshom strict sshomvalidator chess monopoly cli triangle search var search gen search bf search pri we cap the plot for validator since there are .
billion sshoms we could not enumerate all nonstrict sshoms for chess due to the difficulty of the sat problem and report only those found within the time limit figure strict sshoms found over time in each subject system averaged over executions.
note that time is plotted in log scale as most sshoms are found within the first hour.
not available or documented we leave undocumented parameters at default values.
the core of the genetic algorithm is a fitness function for candidate higher order mutants.
following existing work and using the notations in equation we calculate the fitness as th i .
.
.nti .2the intuition is that an sshom should fail only for a subset of test cases that kill all its constituent first order mutants.
thus we use it as a piece wise function a fitness of indicates an sshom and a strict sshom with lower fitness more preferable a fitness of and larger than indicate potential equivalent mutants and non sshoms respectively which are discarded between generations of the genetic algorithm.
measurements .
all experiments were performed on aws ec2 instances each of which has an intel core xeon cpu with 16gb of ram.
we ran benchmarks to confirm that the performance is stable enough for our measurements across different instances given that we often demonstrate order of magnitude differences in outcomes differences are unlikely explained by measurement noise.
for each search strategy i.e.
search gen search bf search var we measure each subject system three times and report the average like the three restarts in the work of harman et al .
.
we ran each trial of genetic algorithm and brute force for hours.
2the fitness function has been defined either using intersect of ti or union .
we use the former in our reimplementation as it more precisely captures our intuition of sshoms.
1170efficiently finding higher order mutants esec fse november virtual event usa table subjects and found strict sshoms the last three subjects and the pricolumn are discussed in section .
found sshom and strict sshom subject loc tests used lcov foms used mutscore var gen bf pri validator .
chess monopoly cli triangle ant math jfreechart loc represents lines of code excluding test code measured with sloccount .tests andfoms report the numbers of test cases and first order mutants we used in experiments with the percentages relative to the total numbers in parentheses.
lcov reports line coverage of the tests used in our experiments.
mutscore reports the mutation score of all used first order mutants and the score in parenthesis considers only foms that are covered by the tests.
var gen bf pridenote our approach step search var the genetic algorithm search gen brute force search bf and our prioritized search step search pri respectively.
incomplete results solutions found with sat solving within the hours budget.
results .
in table we report the number of strict sshoms found with all three search strategies within the hour time budget and in figure we plot the numbers of strict sshoms found over time.
note that by construction if search varterminates all cases except chess where solving the satisfiability problem takes considerable time it enumerates allsshoms thus provides an upper bound for other search strategies without search varthis upper bound would not be known.
these results show clear trends search varrequires a relatively long time to find the first sshom because variational execution must finish executing all tests for all combinations of first order mutants.
however once variational execution finishes it can enumerateallsshoms very quickly by solving the boolean satisfiability problem.
variational execution takes longer with more and longer test cases and with more first order mutants but still outperforms a brute force execution by far indicating significant sharing as found in prior analyses of highly configurable systems .
in contrast search genandsearch bfcan test many candidate sshoms before variational execution terminates and finds some actual sshoms early but both approaches take a long time to find a substantial number of sshoms and miss at least some sshoms in all subject system within the 12h time budget given.
in some systems with moderate numbers of first order mutants search bfis fairly effective as it systematically prioritizes pairwise combinations which are more common among sshoms than combinations of more than two mutants as we will discuss.
in summary for systems where variational execution scales search varcan find allsshoms whereas other approaches find only an often much smaller subset within a 12h time window.
whereas prior approaches often find their first sshoms faster search varneeds more time upfront for variational execution but can then enumerate sshoms very quickly.
to scale search varto more realistic programs more engineering is needed to overcome the limitations discussed in sec.
.
.
nevertheless search varis valuable to the research community as it provides a precise and efficient way of identifying all sshoms.
step sshom characteristics in this second step we study the characteristics of strict sshoms with the goal to inform subsequent heuristic search strategies step and future research in general.
using the complete set derived for the subject systems in the previous step rather than a potentially biased sample of sshoms we can study characteristics with higher confidence.
we explored the dataset in an iterative exploratory fashion focusing primarily on characteristics that may guide future search strategies such as specific composition patterns and proximity of constituent first order mutants for the set of all higher order mutants.
kurtz et al .
argue that mutation operators should be specialized for individual programs so we focus on high level characteristics that are largely independent of specific mutation operators to avoid overfitting.
we started by randomly sampling a large number of identified sshoms among the pool of all sshoms .
we manually inspected the sampled sshoms to pose hypotheses about common characteristics.
we then operationalized the hypothesized characteristics i.e.
develop measures to apply across all sshoms to quantitatively validate them.
we repeated the process until we could not identify additional hypotheses.
due to space constraints we only report characteristics for which we could quantitatively identify strong support.
mutation order .
sshoms and strict sshoms are typically composed of only very few first order mutants.
overall over of all sshoms and strict sshoms are composed of at most first order mutants indicating that subtle interactions are mostly caused by very few first order mutants.
although we found a few sshoms that are up to sixth order in chess and triangle such cases are rare especially for strict sshoms.
we plot the distribution of orders for both sshoms andstrict sshoms in table .
equivalent test failures .
in multiple subject systems many sshoms and strict sshoms are composed of first order mutants that are killed by the same set of test cases nonstrict sshoms are often killed by the same test cases whereas strict sshoms necessarily are killed by fewer .
in table we report how many of the 1171esec fse november virtual event usa chu pan wong jens meinicke leo chen jo o p. diniz christian k stner and eduardo figueiredo table characteristics of sshoms and strict sshoms found in our subject systems.
order equal fail rule n rule distribution subject sshom strict sshom sshom strict sshom sshom strict sshom sshom strict sshom validator chess monopoly cli triangle order counts the number of constituent first order mutants equal fail and n rule explained in text distribution all constituent first order mutants in the same method m multiple methods in the same class c two classes 2c or spread across more than two classes .
for validator and chess we omit statistics because we cannot enumerate all possible sshoms too many in validator and incomplete set in chess sshoms and strict sshoms in each project could be found when only combining first order mutants that are killed by the same test cases which we name equal fail sshoms .
containment relationships .
in addition we found a common containment pattern when a strict sshom is composed of more than two first order mutants it is very likely that a subset of these first order mutants also forms a strict sshom.
in other words an n rule combining a previously identified strict sshom with one further first order mutant is a promising strategy to identify more strict sshoms.
in table we report how many of the strict sshoms in each project with more than two constituent first order mutants could be generated with such a rule.
proximity .
finally for most sshoms all constituent first order mutants are in the same class and often even in the same method likely because first order mutants with close proximity have higher chances of data flow or control flow interactions.
the effect is even more pronounced for strict sshoms.
this stronger effect was previously conjectured though not validated .
we plot the distributions for all subject systems in table .
other .
we also explored other patterns that may inform search heuristics such as common combinations of mutation operators using frequent itemset mining but found no additional strong patterns.
while we believe a qualitative analysis of the mutants and their characteristics may reveal interesting insights about sshoms and whether they more closely mirror realistic human made faults such analysis goes beyond our scope of finding sshoms efficiently.
step characteristics based prioritized search search pri in a final third step we develop a new search strategy using heuristics based on characteristics found in step which will be an incomplete but practical alternative to our search varstrategy.
.
search strategy our new search strategy search priavoids the overhead of variational execution but instead again evaluates each candidate higherorder mutant by executing the corresponding test suite one candidate mutant at a time just like search bfandsearch gen. our key contribution is ordering how we explore candidate mutants to steer the search toward more likely candidates.
that is insteadof a naive enumeration of all combinations search bf or an exploration based on random seeds search gen we prioritize based on the previously identified typical characteristics of higher order mutants.
since characteristics for sshom and strict sshom do not differ strongly we develop only a single search strategy.
conceptually we calculate a penalty for every candidate higherorder mutant and prioritize those candidates with the lowest penalty.
we compute the weighted sum of three factors penalty 1 order 2 testdiff 3 isn1 first we assign penalties based on the number of constituent firstorder mutants order a candidate with a higher order receives a larger penalty than a lower order candidate thus prioritizing candidates with lower order that as our data shows are more likely to be sshoms.
second we penalize candidates constructed from first order mutants that do not get killed by the same test cases testdiff counting the number of test cases that can kill only a subset of all constituent first order mutants generalizing our equivalent test failures insight if all first order mutants are killed by the same test cases the candidate is likely to be an sshom and thus gets a penalty whereas mutants that are killed by different test cases are less likely to form an sshom and thus is deferred with a higher penalty.
finally we reduce the penalty of a candidate if the n rule applies isn1 returning 1or0 that is if a candidate can be constructed by adding one more first order mutant to a known sshom the candidate receives a boost and gets prioritized.
by default and for our evaluation we assign the weights 1 2 and 3 based on our experience with the subject systems in section .
unlike previously used genetic search strategies where the exploration order nondeterministically depends on random mutation and crossover in every generation search priexplores candidates in a deterministic order lexical order if two candidates have the same priority .
.
implementation since we cannot enumerate and sort all possible candidate higherorder mutants for large programs and even the execution of all first order mutants may take a long time we devise an algorithm forsearch prithat identifies likely candidates in batches shown in figure .
in each batch configurable by default one java package at a time we enumerate all candidate higher order mutants up to 1172efficiently finding higher order mutants esec fse november virtual event usa def findsshoms program p mutants m testsuite t maxorder maxdist budget foundsshoms explore the program one fragment at a time for batch fragments p identify reachable first order mutants in fragment mutants reachable m batch run tests on reachable first order mutants fomtestresults for m mutants evaluate t m enumerate candidate sshoms up to order and distance bounds candidates enumeratecandidates mutants maxorder maxdist compute priorities for each candidate priorities computepriorities candidates fomtestresults explore candidates in decreasing priority while candidates within budget candidate getnext candidates priorities candidates candidate homtestresult evaluate t candidate if issshom fomtestresults homtestresult foundsshoms candidate update priorities based on n rule priorities computepriorities candidates fomtestresults foundsshoms return foundsshoms figure characteristics based prioritized search algorithm.
a distance and order bound then sort these candidates by priority and finally explore these candidates in order until a time budget is reached for that batch.
batching and bounding the search is feasible since the order and distribution characteristics dominate the prioritization anyway and candidates beyond those bounds would be explored only very late.
if needed batches could be revisited later with larger bounds to explore more less likely candidates.
after batching our algorithm identifies all first order mutants defined within the given batch function reachable and runs the test suite for each of these first order mutants to identify which tests fail function evaluate .
subsequently the algorithm enumerates all candidates function enumeratecandidates up to a given order bound by default mutants composed of up to first order mutants and up to a given distance bound by default up to methods spread across at most classes .
we also discard candidates where constituent firstorder mutants have no common failing tests because they cannot form sshoms according to the definition.
having a manageable set of candidates in the given batch the algorithm computes priorities function computepriorities for all candidates using equation and then explores these candidates in order of decreasing priorities function getnext until either all candidates are explored or a time budget has been reached in that batch by default hour per batch .
for each candidate it runs the test suite and compares test results to determine whether a strict sshom has been found function issshom identified sshoms are collected and used to recompute priorities based on additional information for the n rule.
.
evaluation we evaluate how effective search priis at finding strict sshoms and additionally evaluate how it generalizes and scales to much larger systems than in prior studies on sshoms and used in sec.
.
subject systems .
we evaluate search priboth on the subjects previously used in section and on a fresh set of much larger subject systems.
the comparison against the previously used subject systems allows us to compare effectiveness against the groundsshom strict sshomant math jfreechart search gen search bf search pri figure strict sshoms found over time averaged over executions.
note that time is plotted in a linear scale as sshoms are found consistently over time due to batching.
truth derived from variational execution but the results may suffer from overfitting as we evaluate the search strategy on systems from which the insights that drive its design have been derived.
hence we use additional subjects listed in table bottom after finishing the design of our new search strategy.
the new systems are significantly larger allowing us to explore the different search strategies at a much larger and possibly more realistic scale.
to select the new subject systems we collected all research papers published in the last years at ase fse and icse that have the word mutation or mutant in the title.
we then selected the five largest java systems used discarding two for which we failed to reliably execute the tests.
we did not run search varon these systems but we still had to exclude some tests or mutants reported in table due to technical issues like hard to terminate infinite loops.
measurements .
we mirror our previous setup in section .
and count the number of strict sshoms found over time.
we collect measurements for search bf search gen and search pri.
experiments on the small subject systems were performed on the same aws ec2 instances section .
.
for the new systems we collected measurements on linux machines with .30ghz intel i5 cpu and 16gb memory.
when using search pri we used batching for the new larger subject systems one package at a time with a hour budget for each package all other parameters were left at their defaults described above .
for the new subject systems we ran each measurement for hours repeated search gen3 times.
all considered search strategies require executing the test suite repeatedly for each candidate sshom.
for the larger systems long test execution times severely limit the number of mutants we can explore.
to minimize the slowdown from test execution that affects all approaches equally we implement a standard regression test selection technique that only executes test cases that can reach the candidate mutant technically we instrument the program to record which test reaches the location of each first order mutant and only execute tests that reach at least one first order mutant of a candidate higher order mutant .
we apply this test optimization for all search strategies.
1173esec fse november virtual event usa chu pan wong jens meinicke leo chen jo o p. diniz christian k stner and eduardo figueiredo results .
on the small subject systems as shown in table and figure our new search strategy search priis often very effective performing at least as well as and usually significantly outperforming both search bfandsearch genin all subjects.
in a few cases it even outperforms search var inmonopoly it finds almost all higher order mutants before variational execution finishes running the tests and in chess it finds sshoms quickly not limited by the effort to solve large satisfiability problems.
for the new and larger systems our results in table and figure show that the baseline approaches perform very poorly at this scale.
without being informed by sshom characteristics the search in this vast space e.g.
billion candidate combinations of mutation pairs in math these approaches find rarely any sshoms even when run for a long time.
in contrast search prifinds a significant number of strict sshoms in each of these systems within hours it explores most batches of all packages and has a reasonable precision3for finding actual sshoms among the tested candidates .
inmath .
inant and .
injfreechart .
we conclude that search priis an effective search strategy that scales to large systems and generalizes beyond systems from which the characteristics have been collected.
while we cannot assess how many sshoms we are missing our strategy is effective at finding a very large number of them in a short amount of time.
threats to validity external validity might be limited by the specific programs mutation operators and test cases.
we used common mutation operators and selected subject systems from previous papers to avoid any own sampling bias.
from most subject systems we had to remove some tests or mutations due to technical problems either engineering limitations of variational execution or issues with memory leaks and infinite loops which might affect the results to some degree though we do not expect a systematic bias.
regarding internal validity like other studies our results might be affected by possible mistakes in our implementations or measurements and especially by we reimplemented the existing search gen approach.
to mitigate this issue we verified that the sshoms found bysearch genandsearch bfare a strict subset of the ones found bysearch var.
for sshoms found only by our approach we additionally verified a sample manually to ensure they are sshoms.
to reduce the impact of nondeterminism in performance measurements and genetic search we report averages across runs as in previous work .
most differences are large far exceeding the margins of error from nondeterminism or measurement noise.
related work in this section we focus our discussions on higher order mutation testing and refer interested readers to a detailed survey for recent advances in mutation testing in general .
approaches for finding sshoms .
early work has investigated different strategies to combine first order mutants into secondorder mutants .
jia and harman extended this effort to even higher orders using heuristic search looking for certain kinds of valuable higher order mutants specifically sshoms.
they compare a greedy a hill climbing and a genetic algorithm and 3we discuss precision with more data in the supplementary material.found that genetic search produces the best results for finding sshoms .
since then higher order mutation testing has been implemented in different mutation testing tools and frameworks for different languages usually using some form of heuristic search .
although this work specifically targets sshoms our approach can be generalized to other types of interesting mutants by updating the way we encode the search as a boolean satisfiability problem.
orthogonal to sshoms researchers have recently investigated an interesting type of hard to kill mutants called dominator mutants .
this line of work searches for the hardest to kill first order mutants among a given set by comparing executions with regard to a test suite.
dominator mutants have been shown to be an effective research tool to study existing mutation testing techniques for example for gauging mutation test completeness and evaluating selective mutation .
just et al .
show that program context can be used to approximate dominator mutants which might also be promising for future search strategies for sshoms.
characteristics of sshoms .
existing work on sshoms mostly discusses the quantity of sshoms and the difficulty of finding them .
for example harman et al .
discussed how sshoms relate to their constituent first order mutants but their discussion focuses mainly on test effectiveness and efficiency.
jia and harman discussed characteristics of a single sshom in the triangle program also used in our study but did not explore sshom characteristics further.
in our work we can find a complete set of sshoms with regard to used tests and first order mutants which provides us more data to study what they look like.
variational execution .
variational execution was originally developed for information flow analysis and configuration testing .
we previously suggested that variational execution may have additional application scenarios suggesting mutation testing as explored here as one promising direction .
with regard to using variational execution for mutation testing devroey et al .
are conceptually closest to our work in that they pursue a complete exploration strategy with similarities to lazy configuration exploration in splat .
however they explore only traces in state machines without any joining and thus forgo much possible sharing.
their analysis does not distinguish first order from higher order mutants and does not identify or analyze sshom.
orthogonal to our work researchers have also used various techniques to speed up traditional mutation testing such as sampling tests for mutant executions condensing mutations into a metaprogram and using advanced execution sharing techniques .
at a technical level wang et al .
are closest to our work in that they look for possible redundant mutant executions by inspecting program state but forgo potential joining after splitting mutant executions.
since our main goal of using variational execution is to explore the interactions of first order mutants rather than speed up mutation analysis we did not perform a performance comparison.
conclusions to efficiently find sshoms we proceed in three steps.
first we use variational execution to find allsshoms in small to mediumsized programs.
second we analyze the basic characteristics of the identified sshoms.
finally we derive a new prioritized search 1174efficiently finding higher order mutants esec fse november virtual event usa strategy based on the characteristics.
the prioritized search scales to large systems and is effective albeit not complete at finding sshoms and outperforms the existing state of the art strategy by far.
we hope that the insights and search strategies from this work can support future work in mutation testing.