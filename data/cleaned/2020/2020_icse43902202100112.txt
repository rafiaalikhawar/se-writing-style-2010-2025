evospex an evolutionary algorithm for learning postconditions facundo molina y pablo ponzio y nazareno aguirre y marcelo friasyz department of computer science fcefqyn university of r o cuarto argentina ynational council for scientific and technical research conicet argentina zdepartment of software engineering buenos aires institute of technology argentina abstract software reliability is a primary concern in the construction of software and thus a fundamental component in the definition of software quality.
analyzing software reliability requires a specification of the intended behavior of the software under analysis and at the source code level such specifications typically take the form of assertions.
unfortunately software many times lacks such specifications or only provides them for scenario specific behaviors as assertions accompanying tests.
this issue seriously diminishes the analyzability of software with respect to its reliability.
in this paper we tackle this problem by proposing a technique that given a java method automatically produces a specification of the method s current behavior in the form of postcondition assertions.
this mechanism is based on generating executions of the method under analysis to obtain valid pre post state pairs mutating these pairs to obtain allegedly invalid ones and then using a genetic algorithm to produce an assertion that is satisfied by the valid pre post pairs while leaving out the invalid ones.
the technique which targets in particular methods of referencebased class implementations is assessed on a benchmark of open source java projects showing that our genetic algorithm is able to generate post conditions that are stronger and more accurate than those generated by related automated approaches as evaluated by an automated oracle assessment tool.
moreover our technique is also able to infer an important part of manually written rich postconditions in verified classes and reproduce contracts for methods whose class implementations were automatically synthesized from specifications.
i. i ntroduction the quality of software systems is typically defined around various dimensions such as reliability usability efficiency etc.
among these reliability is in general considered a fundamental attribute of software quality and a primary concern in software development .
analyzing software reliability is strongly related to finding software defects i.e.
actual software behaviors that diverge from the expected behavior.
discovering such defects requires one to state what the expected behavior is in other words a specification of the software.
many times such specifications are either implicit or stated informally diminishing the possibility of exploiting specifications for automated reliability analysis.
software specifications can appear in different forms.
at the level of source code when present they generally manifest either as comments i.e.
informal descriptions of what the software is supposed to do or more formally as program assertions i.e.
usually executable statements that assert properties that the software must satisfy at certain pointsduring program executions.
the former are more common but cannot be straightforwardly used for automated reliability analysis.
the latter on the other hand are readily usable for program analysis especially when stated as contracts but they are seldom found accompanying source code.
moreover many times program assertions state scenario specific properties e.g.
statements that only express the expected software behavior for a test case as opposed to the more general and also significantly more useful assertions associated with contract elements such as invariants and pre post conditions.
due to the above described situation regarding specifications at the level of source code the specification inference problem a special case of the well known oracle problem i.e.
taking a program without a corresponding specification and attempting to automatically produce one that captures the program s current behavior is receiving increasing attention by the software engineering community.
automatically inferring specifications from source code is a relevant topic as it enables a number of applications including program comprehension software evolution and maintenance bug finding and specification improvement among others.
in this paper we tackle this problem by proposing a technique that given a java method automatically produces a specification of the method s current behavior in the form of postcondition assertions.
this mechanism is based on generating valid and invalid pre post state pairs i.e.
state pairs that represent and do not represent the method s current behavior respectively which guide a genetic algorithm to produce a jml like assertion characterizing the valid pre post pairs while leaving out the invalid ones.
the generation of valid pre post pairs is based on executing the method on a bounded exhaustive test set generated by exercising the method inputs apis using user defined ranges for basic datatypes and bounding their execution sequences.
the invalid pre post pairs on the other hand are obtained by mutating valid pairs i.e.
arbitrarily modifying the post states so that each resulting pair does not belong to the set of valid pairs.
this mutation based approach to generate invalid pairs is unsound in the sense that it may lead to valid pairs instead an issue that may affect the precision of the produced assertions.
as we describe later on the design of our genetic algorithm takes it into account.
because of the assertion language we consider that involves quantification object navigation and reachability expressions our approach is particularly well12232021 ieee acm 43rd international conference on software engineering icse .
ieee suited for reference based class implementations with implicit strong representation invariants such as heap allocated structural objects and complex custom types.
we assess our technique on a benchmark of open source java projects taken from featuring complex implementations of reference based classes.
in these case studies our genetic algorithm is able to generate post conditions that are stronger and more accurate than those generated by related specification inference approaches as evaluated by oasis an automated oracle assessment tool .
moreover our technique is also able to infer an important part of manually written rich postconditions strong contracts used for verification present in verified classes and reproduce contracts for methods whose class implementations were automatically synthesized from specifications .
ii.
b ackground a. assertions as program specifications the use of assertions as program specifications dates back to the works of hoare and floyd in the context of program verification and associated with the concept of program correctness.
technically an assertion is a statement predicating on program states that can be used to capture assumed properties as in the case of preconditions or intended properties as in the case of postconditions.
a program p accompanied by a precondition preand postcondition post is said to be partially correct with respect to this specification if every execution of pstarting in a state that satisfies pre if it terminates it does so in a state that satisfies post .
that is every valid terminating execution of p i.e.
every execution satisfying the requirements stated in the precondition must lead to a state satisfying the postcondition.
while program assertions originated in the context of program verification they soon permeated into programming languages constructs and informal programming methodologies.
more recently they have been central to the definition of methodologies for software design notably design by contract .
most modern imperative and object oriented programming languages support assertions either as built in constructions or through mature libraries such as code contracts and jml .
moreover libraries for unit testing make extensive use of assertions to automate checking the expected results of running a test case.
preconditions are more commonly seen in source code e.g.
within methods in the form of state and argument checks throwing appropriate exceptions when these are found invalid preventing normal execution.
postconditions on the other hand are less common.
post execution checks are commonly seen as part of test cases although they rarely capture postconditions in the sense of general properties that every execution must satisfy on termination post execution checks in tests generally state properties that should be satisfied for the specific test where they are stated.
the assertion language that we consider in this paper is from an expressiveness point of view a jml like contract language.
more precisely we follow the approach used in and use the alloy notation .
the language supports quantifiers navigation and reachability expressions including navigations through one or more field.
a sample specification generated by our technique is shown in figure .
most operators have a direct intuitive reading equality and inequalities boolean connectives etc.
all andsome are the universal and existential quantifiers respectively the dot operator .
is relational composition and captures navigation relational union and intersection are denoted by and respectively and can be applied to combine fields in navigations set relational cardinality is denoted by finally and are reflexivetransitive closure and transitive closure respectively.
closures allow the language to express reachability.
for instance the last sentence in figure expresses that for every node n reachable in zero or more steps from the root by traversing left andright i.e.
all nodes in the tree it is not the case thatnis included in the set of nodes reachable in one or more steps from nitself.
that is the left right structure from theroot is acyclic.
it is worth to mention that all assertions in this language can be checked at run time and thus we can use it to assert properties in program points.
we refer the reader to for further details regarding the language.
b. quality of assertions as described above program assertions are a way of capturing the expected software behavior via expressions that convey intended properties of program states in specific parts of a program.
such expected behavior can be captured with different degrees of precision leading to assertions of different quality.
the most typical issue with program assertions is the misclassification of invalid program states as valid.
this is essentially the effect of having weak assertions that are able to detect some but not all faulty situations.
it is rarely considered adefect in the assertion but an inherent issue associated with a balance between expressiveness and economy efficiency in the definition of assertions.
indeed it is even considered methodologically correct to express weak and efficiently checkable assertions .
following the terminology put forward in a real program execution leading to an invalid program state that a corresponding assertion is unable to detect is called a false negative .
a second issue with program assertions is the dual of the previous i.e.
the misclassification of valid program states as invalid.
this issue indicates that the assertion is wrong as it does not properly specify the intended behavior of the software.
such issues are typically considered to be specification defects.
this situation can also often arise as a consequence of software evolution when required changes in program behavior are correctly implemented but the accompanying assertions are not kept in synchrony with the evolved behavior .
a real program execution leading to a valid program state that a corresponding assertion classifies as an assertion violation is a false positive according to the terminology put forward in .
assessing the quality of assertions accompanying a program is a very challenging problem that is typically performed 1224manually.
a way of measuring the quality of assertions is by attempting to determine the number of false positives and false negatives that a given assertion has.
this idea has been exploited in where an automated mechanism for evaluating the quality of assertions based on evolutionary computation is proposed.
the approach presented therein executes an evolutionary test generation tool the well known tool evosuite that tries to find false positives and false negatives and when found produces witnessing test cases that can be used to manually improve the corresponding assertions.
it is worth remarking that for contracts specified in standard assertion languages it is hardly expected for a contract to fully capture the behavior of a program.
as explained in precisely capturing a program s intended semantics requires additional mechanisms such as the use of model classes that imply the manual definition of abstractions of the state space of the program being specified.
in terms of the above mentioned issues with program assertions it means that technically one can very often come up with false negatives i.e.
finding states that satisfy a given assertion but correspond to incorrect program behavior.
iii.
a nillustrating example as an illustrating example let us consider a java class implementing lists partially shown in figure .
this class implements list operations over balanced trees supporting insertion and deletion from the list in o logn as opposed to the classic array based and linked list based list implementations.
let us focus on method add that inserts an element in the list.
notice how the precondition of the method is captured in the source code checking the validity of the index for insertion and that the tree has not reached its maximum size.
the method postcondition on the other hand is not present in this implementation.
having the postcondition has multiple applications in particular as assertions for testing future improvements of this method and as a declarative description of what this method does how it operates on the data structure among many others.
writing the specification is however nontrivial and thus coming up with the right expression for the postcondition is an important problem.
a well known tool to assist the developer in this situation is daikon .
daikon performs run time invariant detection it runs the program on a set of test cases and observes which properties hold during these runs at particular program points such as after method invokations.
it then suggests as likely invariants those properties that were not falsified by any execution or equivalently that held true for all observed executions.
the quality of the obtained invariants strongly depends on the program executions considered by daikon i.e.
the set of tests that the user provides and the set of candidate expressions to be considered.
in particular for method add in figure daikon produces the postcondition shown in figure when fed with allvalid tree lists of size up to .
the shown postcondition is actually that produced by daikon 1this implementation is taken from public final class avltreelist e extends abstractlist e private node e root public void add intindex e val if index index size throw new indexoutofboundsexception if size integer.max value throw new illegalstateexception max size reached root root.insertat index val private static final class node e private e value private int height private int size private node e left private node e right publicnode e insertat intindex e obj assert index index size if this empty leaf return new node obj intleftsize left.size if index leftsize left left.insertat index obj else right right.insertat index leftsize obj recalculate returnbalance fig.
.
add method of class avltreelist but manually filtering out invalid expressions inducing false positives that could not be falsified by the suite.
still as it can be seen the postcondition generated in this case is relatively weak we would expect to have some further information about how node attributes get manipulated in this implementation of lists over trees.
the reason why daikon produces this very simple postcondition in this case has to do with the set of candidate expressions that daikon considers which are produced from the definition of the program and are restricted to relatively simple program properties e.g.
structural constraints membership checking etc.
are not considered .
our aim is to provide stronger postconditions in cases such as the above.
our approach is in essence similar to daikon s the method under analysis is run for different inputs and from information extracted from these runs we propose a postcondition for the method.
there are however multiple differences.
firstly our approach is based on generating runs for the method under analysis bounded exhaustively as opposed to daikon which requires tests to be provided in the above example the suite we provided daikon with was the one that our technique produces .
our technique for generating the bounded exhaustive test suite is based on exercising the api of the inputs of the program under analysis contrary to related approaches that require a specification .
secondly we consider both valid andinvalid program states although as height this.root.height old this.root.height this.root.height old this.root.left.height this.root.height old this.root.right.height size this.root.size old this.root.height this.root.size old this.root.left.height this.root.size old this.root.right.height left height this.root.left.height old this.root.height this.root.left.height old this.root.left.height this.root.left.height old this.root.right.height right height this.root.right.height old this.root.height this.root.right.height old this.root.left.height this.root.right.height old this.root.right.height fig.
.
postcondition generated by daikon for avltreelist.add int e root this.root !
null this.root.left !
null height all n this.root.
left right n.left !
null n.height n.left.height n.right !
null n.height n.right.height size old this.root.size this.root.size this.root.size this.root.
left right null all n this.root.
left right n.left !
null n.size n.left.size n.right !
null n.size n.right.size arguments index !
this.root.size val inthis.root.
left right .value structural all n this.root.
left right n !in n. left right fig.
.
postcondition generated by our tool for avltreelist.add int e we explain later on the approach to generate invalid states may unsoundly generate valid ones in attempting to determine a method s postcondition instead of only valid executions as is the case with daikon.
third our approach is based on evolving specifications instead of considering non falsified candidate properties.
the details of our technique are described in the next section.
let us just mention that for method addof class avltreelist our obtained postcondition is the one shown in figure .
notice how the size update referring to the relation between the pre and post states and the membership of the inserted element are captured as well as some structural properties of the representation.
iv.
e vospex we now present the details of our technique for inferring method postconditions.
an overview is shown in fig.
.
the technique is composed of two main phases state generation and learning.
during state generation we produce pre post program state pairs which are later on used in the learning phase to guide the search for suitable postcondition assertions.
two kinds of state pairs are generated valid ones which capture actual method behaviors that candidate assertions should satisfy and invalid ones which attempt to captureincorrect behaviors pre post pairs that do not correspond to the current method behavior that candidate assertions should not satisfy.
valid pre post pairs are generated by executing the target method using a test generation technique clearly these pairs correspond to the behavior of the method as they were generated from its execution.
invalid pre post pairs on the other hand are generated by mutating valid pairs going out of the set of valid pairs contrary to the case of valid pairs it is not guaranteed that our invalid pairs are indeed incorrect method behaviors i.e.
that they represent behaviors that are notexhibited by the method.
this may clearly affect the precision of the obtained assertions since the algorithm would be guided to avoid some allegedly invalid behaviors which are actually valid.
in these situations the obtained assertions would be stronger than necessary leading to a higher number of false positives when evaluating assertion quality.
we consider this issue in the design of our technique in the following way.
firstly the effectiveness in generating truly invalid pairs depends on the exhaustiveness of the set of valid pairs the more exhaustive the set of valid pairs the greater the chances that mutating out of this set leads to a truly incorrect method behavior.
secondly as the soundness of the mechanism for invalid state pair generation cannot be guaranteed one may risk favoring incorrect assertions based on wrong invalid state assumptions.
the former motivates the use of a bounded exhaustive test generation approach for valid state pairs.
the latter drives an asymmetric treatment of valid and invalid state pairs in the fitness function that gives the reliable information provided by valid pairs a greater relevance.
we further describe in this section how we handle these issues as well as other details of the genetic algorithm and in the next section we evaluate the technique including an evaluation of assertion precision.
a. generation of valid invalid method executions the learning phase of our algorithm depends on a set of valid invalid method executions which guide the search for postcondition assertions.
this is an important part of our algorithm.
the overall process starts by generating runs of the target method m collecting the pre post states hs s0iof each execution these are the valid execution pairs v. in order to generate invalid execution pairs i valid pairs are mutated for a valid pairhs s0i we mutate s0intos00 and check that hs s00idoes not belong to v to consider it part of i. of course the mutated pre post pair may actually correspond to a valid execution of mthat we had not generated in v. the effectiveness of this latter approach depends on how thorough vis although we may still generate unseen valid execution pairs via mutation motivating a bounded exhaustive approach for generating valid execution pairs.
the mechanism for generating valid execution pairs works as follows.
let c c c nbe classes and m the target method a method in cwith parameters of types c1 c n. the initial states for the execution of mwill be tuples hoc oc1 o cniof objects of types c c c n respectively.
we build the objects to form these tuples for each class 1226target method test generation test casesexecutionvalid pre post statesmutation invalid pre post statesevospexpostcondition assertions generation phaselearning phasefig.
.
an overview of the proposed approach bounded exhaustively in the following way.
let cibe a class and methods b1 b la set of builders forci i.e.
a set of manually identified methods that can be used to create objects of class ci.
for instance for a set collection builders would include constructors and insertion routines.
given a bound k maximum length for method sequences we build a set of objects of class ciusing a variant of randoop .
randoop randomly generates sequences of methods of ci s api of increasing length by iterating a process in which previously produced traces are randomly selected together with a method to generate a new trace that calls this method.
our variant incorporates two main modifications to this process the random selection of a method to extend a previously produced trace t test case implemented in is replaced by a mechanism to systematically select all methods in b1 b l leading to ldifferent extensions oft.
this is applied until the bound kis reached.
a state matching mechanism is implemented to reduce the number of method combinations when a newly produced trace leads to an object that matches a previously collected one the trace and the object are discarded.
the state matching approach borrows the canonical object representation put forward in .
besides the bound kon trace length the state matching mechanism also requires a maximum number of objects per type and a range for primitive types e.g.
..k for integers .
this is a k based scope as defined in finitization procedures in a standard issue in bounded exhaustive generation .
using the above mechanism we build the tuples of initial states to execute m. we execute min each of these tuples and collect the corresponding post states building in this way the set v ofvalid pre states and corresponding post states for m. the mutations applied to produce the invalid pre post state set i take a valid execution pair hs s0i and create hs s00i where s00mutates s0by selecting a random field in the receiving object or return value the constituents of s0 and replacing the value by a randomly generated value of the corresponding type within the above mentioned scope.
we check that the resulting pair is not in vbefore including it into the invalid state pair set i.b.
chromosomes representing candidate postconditions our representation of candidate assertions is based on the encoding used in where chromosomes represent conjunctions of assertions each gene in a chromosome represents an assertion .
that is given a chromosome c the candidate postcondition crepresented by cis defined as follows c hg1 g2 g ni c g1 g2 gn as opposed to what is most common in genetic algorithms chromosomes have varying lengths in this representation up to a maximum chromosome length and gene positions are disregarded by the genetic operators see below due to the associativity and commutativity of the conjunction.
genes need to encode complex assertions.
below we describe how genes are built mutated and combined.
c. initial population let us describe how we build the initial population to start our genetic algorithm.
in order to create individuals representing meaningful postconditions i.e.
assertions stating properties of objects that are reachable at the end of the method executions we take into account typing information as in .
we consider a type graph built automatically from the class under analysis nodes represent types and each field fof type bin class awill produce an arc in the graph going from the node representing ato the node representing b. for example if we consider the avltreelist class in figure the corresponding type graph would be the one shown in figure .
it is straightforward to see that by traversing the graph typed expressions can be built using the fields of the object from which the method was executed.
some examples are this.root this.root.left this.root.size this.root.value and so on.
moreover from loops in the graph expressions denoting sets such asthis.root.
left the set of nodes reachable from this.root vialeft traversals only this.root.
right andthis.root.
left right can be created as explained earlier we are using for reflexive transitive closure as in .
size one chromosomes are created using expressions denoting a single value evaluating these on a randomly selected subset of the valid resp.
invalid method executions in the following way if the result of evaluating an expression expr in a valid resp.
invalid tuple treturns a value v then we create the individual hexpr vi resp.hexpr !
vi .
in addition to these basic individuals we also create chromosomes containing comparisons of random expressions of the same type e.g.
this.root this.root.right chromosomes with quantified formulas considering expressions denoting sets e.g.
all n this.root.
left right null n n.right and individuals comparing integer expressions with the cardinality of expressions denoting sets e.g.
this.root.height this.root.
right .
finally since the method under analysis may have a return value or a set of arguments we also include in the set of initial candidates expressions comparing them against expressions of the same type e.g.
result this.f .
the expressions 1227avltreelist e nullthisenode e nullrootvalueleft rightintsizeheightfig.
.
type graph for avltreelist example.
used to compare with the result variable or the arguments as well as the operators are randomly chosen.
notice that allour initial chromosomes are size chromosomes.
the main reason for this design choice is to allow the genetic algorithm to progressively produce complex candidate postconditions by means of the genetic operators that we define later on in this section.
while this size one chromosomes for the initial population is non standard in genetic algorithms in our case it helps the algorithm to more quickly converge to better fitted individuals.
the replication package site contains the results of comparing the effectiveness of our sizeone chromosomes in the initial population with standard sizenchromosomes we do not include the comparison here due to space restrictions .
d. fitness function our fitness function assesses how good a candidate postcondition is by distinguishing between the set vof valid executions and the set iof invalid executions.
to do so before computing the fitness value of a given candidate c we obtain the postcondition cthatcrepresents and then compute the sets pandnof positive and negative counterexamples respectively.
these sets are defined as follows p fv2vj c v gn fi2ij c v g where cis the postcondition represented by the candidate c. basically the sets pandncontain those executions for which the postcondition cdoes not behave correctly.
recall that as opposed to the case of vwhich reliably represents actual execution information of m the set imay contain mutated executions that are considered invalid but correspond to actual executions of m. this motivates a definition of our fitness function that does not treat pandnsymmetrically.
the fitness function f c is computed as follows p !
max p i lc comp c mca c lc p !
max n lc comp c mca c lc this case based definition aims at considering the negative counterexamples only when no positive counterexamples are obtained.
in fact for arbitrary candidates c1andc2 ifc1 has no positive counterexample and c2has some positive counterexamples then fis guaranteed to produce worse fitness values for c2 no matter how many negative counterexamplesthese candidates have.
the rationale here is to make the reliable positive counterexample information more relevant.
the definition of the fitness function has three parts.
the first term reflects the most important aspect to minimize the number of counterexamples.
the fact that when the candidate postcondition chas positive counterexamples i.e.
it is falsified by a correct method execution the whole set iof invalid executions is considered as counterexamples too is what guarantees our above observation regarding the prioritization of candidates with no positive counterexamples.
more precisely the first term of the function subtracts iwhen p to ensure that the fitness value of such individual is lower that the fitness value of any other individual that only has negative counterexamples.
the second term of the fitness function acts as a penalty regarding two aspects the candidate length lcand the candidate complexity comp c. the candidate length is simply the number of conjuncts in the assertion and it is considered in order to guide the algorithm towards producing smaller assertions.
the candidate complexity is the sum of each conjunct complexity.
intuitively the complexity of an equality between two integer fields is lower than the complexity of an equality between an integer field with a set cardinality and both of these are lower than the complexity of a quantified formula and so on.
the last term of the function acts as a reward favoring those candidates with a greater number of method component assertions mcac i.e.
with a high number of conjuncts of the candidate postcondition that represent properties regarding the parameters the result or a relation between initial and final object states.
as described the penalty related to the candidate length and complexity as well as the reward prioritizing the method component assertions just contribute a fraction to the fitness value since we want the algorithm to focus on individuals whose number of counterexamples is approaching zero.
e. genetic operators during evolution the genetic operators allow the algorithm to explore the search space of candidate solutions by performing certain operations that produce individuals with new characteristics as well as combinations of existing ones.
in particular our algorithm implements two well known genetic operators namely the mutation andcrossover operators.
some of these genetic operators were inspired by similar ones introduced in while others are novel.
also a custom selection operator was implemented to keep in the population those candidates that are more suitable to be part of the real post condition.
each chromosome gene is selected for mutation with a probability of and the operation can perform a variety of modifications depending on the shape of the selected gene expression.
from a general point of view the set of considered mutations are the following gene deletion it can be applied to any gene and simply removes the gene expression from the chromosome.
negation it negates the gene expression and is applied to any gene except quantified assertions.
1228numeric addition subtraction it is only applied to genes that compare two expressions evaluating to a number and it adds subtracts a randomly selected numeric expression to the right hand side of the comparison.
expression replacement it applies to any gene and it replaces some part of the gene with a randomly selected expression of the same type.
expression extension it can be applied to any gene that involves a navigational expression and it extends this expression with a new field for example replacing this.root by this.root.left .
operator replacement it replaces an operator by an alternative one.
the operators vary depending on the current gene expression.
for instance for relational equalities the possible operators are f !
g for numeric comparisons the operators aref !
g and for quantified expressions the quantifiers are fall someg.
to produce combinations of individuals we use a crossover rate of .
given two randomly selected chromosomes c1andc2 our crossover operator simply produces a new individual that contains the union of the genes of c1andc2 and thus represents the candidate postcondition c1 c2.
an important detail in our crossover operator is that before selecting individuals for combination we filter the population keeping individuals which only have negative counterexamples i.e.
that represent formulas that are consistent with all valid method executions.
the main reason for this policy is that we want the algorithm to join chromosomes that are already consistent with the valid method executions.
finally to keep in the population the best candidates of each generation our selection operator is defined as follows given a number nto be used as constant population size our operator first sorts all the candidate postconditions in decreasing order and then the candidates to be moved to the next generation are the first n 2individuals plus the best n 2unary non valid individuals i.e.
size chromosomes whose only gene is a formula that still has positive counterexamples.
additionally our operator keeps all the unary valid candidates that is those that only have negative counterexamples.
this last policy in our selection operator allows us to keep in the population all the discovered valid properties that the algorithm can use in future crossover operations.
v. e valuation to evaluate our technique we performed experiments focused on the following research questions rq1 do the oracles learned by evospex have any deficiency compared to oracles produced by related tools?
rq2 are the assertions produced by the algorithm close to manually written contracts?
to evaluate rq1 we need to consider programs in our case java programs for which to infer method specifications.
as mentioned earlier in the paper and as it is clear from our candidate assertion state space and evolution operators wetarget classes and methods with reference based implementations in particular classes where the corresponding internal representation has strong implicit invariants.
as a source for our benchmark we considered sf1102 originally used in a collection of java projects random projects plus the most popular ones according to sourceforge that covers a wide variety of software representative of open source development.
our process of assessing postcondition assertions makes use of the oasis tool essentially to evaluate the quality of a postcondition assertion in terms of its associated number of false positives and false negatives.
the process of computing this number requires a manual process as described in to compute the false negatives one first needs to get rid of the false positives which implies having to manually refine the produced postconditions every time oasis reports the presence of a false positive .
therefore we are unable to consider the whole projects in the benchmark.
we randomly selected projects skipping cases in our selection that have a clear dependency on the environment our technique involves automated test generation and environment dependencies seriously affect these tools .
the projects can be found in table ii.
for each case study we selected various methods with different behaviors for analysis manually defined a set of builders and then generated the corresponding valid and invalid method executions with a relatively small scope for all cases .
then we executed our tool in the following way for each method mselected for analysis we executed the genetic algorithm to produce a postcondition for muntil it reached generations or a minutes timeout was fulfilled.
we repeated this execution times and then selected the postcondition assertion that repeated the most number of times from the produced by the algorithm.
additionally in order to compare our tool with related approaches we executed daikon to infer post conditions for each method m. it is important to remark that the test suites that we fed daikon with to produce postconditions for the methods under analysis were exactly the same test suites that were used to generate the valid method executions in our technique our valid bounded exhaustive suites .
both our tool and daikon can produce assertions leading to false positives see section for a comment on this issue as well as redundant assertions.
the results of this experiment are shown in tables i and ii.
table i presents the postconditions generated by the tools after removing the false positives and the redundant assertions with the aim of giving a clear glance of the complexity of the assertions that the techniques are able to generate.
we considered these assertions as the ones produced by the two techniques.
we then measured the quality of the corresponding assertions by automatically computing false positives and false negatives using the oasis tool.
table ii shows the results of this quality assessment.
specifically for each case study we report in table ii i lines of code loc of the evaluated project ii number of analyzed methods from the 1229table i postconditions inferred by evospex and daikon after removing false positives method evospex daikon jiprof com.mentorgen.tools.profile.runtime.classallocation getalloccount int result this.
count this.
count result result old this.
count incalloccount void this.
count old this count this.
count this.
count old this count jmca com.soops.cen4010.jmca.jparser.simplenode jjtsetparent node n void n this.parent this.parent old n this.children old this.children this.id old this.id this.parser old this.parser this.identifiers old this.identifiers bpmail ch.bluepenguin.email.client.service.impl.emailfacadestate setstate integer id boolean dirtyflag voidid inthis.states.keyset this.states old this.states byuic com.yahoo.platform.yui.compressor.javascriptidentifier preventmunging void this.mungedvalue old this.mungedvalue this.refcount old this.refcount all n this.declaredscope.
parentscope n !in n. parentscopethis.mungedvalue old this.mungedvalue this.reccount old this.refcount this.declaredscope old this.declaredscope this.markedformunging false dom4j org.dom4j.tree.lazylist add e element boolean old this.size this.size result true element in this.header.
next.elementthis.header old this.header this.size result true this.size old this.size corresponding project iii number of assertions produced as part of the postconditions iv amount and percentage of false positives present in all generated assertions and v number of methods for which false negatives were detected.
notice that as proposed in false negatives detection is performed once all the false positives have been removed from the postcondition hence the manual task that made us consider a subset of sf110 .
for both false positives detection and false negatives detection we executed oasis with a timeout of one minute.
problems with oasis prevented us from reporting the number of false negatives for each method and case study more precisely when the tool reported the existence of false negatives in some cases it was unable to produce the witnessing counterexamples test cases preventing us from measuring the number of false negatives identified by the tool in these cases.
this issue was discussed with the developers of the tool.
we therefore inform the number of methods for which oasis reported the existence of false negatives rather than the number of false negatives found as this information was not reliably produced by the tool for all cases.
for instance for projectimsmart out of the methods analyzed oasis found one of the corresponding assertions discovered by daikon to have false negatives and one of the assertions discovered by evospex to have a false negative too.
the evaluation of rq2 requires having classes with methods featuring manually written contracts.
moreover as discussed in section assertions for run time checking are typically weak efficiently checkable assertions that weakly capture the semantics of the corresponding classes and methods .
in order to compare with strong contracts we took a set of case studies with contracts written for the verification of object oriented programs.
more precisely these programs are written in eiffel and the accompanying contracts were used for verification using the autoproof tool a verifier for object oriented programs written in the eiffel programming language for eiffel programs.
a set of case studies for which a data representation andmethod implementations are automatically synthesized from a higher level specification.
more precisely the synthesized implementations are taken from are generated by the cozy tool and are guaranteed to be correct with respect to higher level specifications which serve as method contracts.
from we specifically considered various methods and their corresponding postconditions from the following cases composite a tree with a consistency constraint between parent and children nodes.
each node stores a collection of its children and a reference to its parent the client is allowed to modify any intermediate node.
a value in each node should be the maximum of all children s values.
doublylinkedlistnode node in a circular doublylinked list with a structural invariant enforcing that its left and right links are consistent with its neighbors.
map k v generic map abstract datatype implementation based on two lists that contain the keys and values and with operations that perform linear searches on the lists.
ringbugger g bounded queue implemented over a circular array.
since our tool is for java and these implementations are in eiffel we had to manually translate the whole classes into java for analysis with our tool this also prevented us from considering more sophisticated case studies in this evaluation .
while the translation was manual we made an effort in making it systematic preserving the structure of the original code and taking into account the semantics of