the impact of generic data structures decoding the role of lists in the linux kernel nic volanschi inria bordeaux sud ouest talence france eugene.volanschi inria.frjulia lawall inria paris paris france julia.lawall inria.fr abstract the increasing adoption of the linux kernel has been sustained by a large and constant maintenance effort performed by a wide and heterogeneousbaseofcontributors.oneimportantproblemthat maintainersfaceinanycodebaseistherapidunderstandingofcomplex data structures.
the linux kernel is written in the c language whichenablesthedefinitionofarbitrarilyuninformativedatatypes via the use of casts and pointer arithmetic of which doubly linked lists are a prominent example.
in this paper we explore the advantages and disadvantages of such lists for expressivity for code understanding and for code reliability.
based on our observations wehave developeda toolsetthat includesinference of descriptive listtypesandatoolforlistvisualization.ourtoolsidentifymore than list fields and variables in recent linux kernel releases andsucceedsintyping90 .weshowhowthesetoolscouldhave been used to detect previously fixed bugs and identify new ones.
ccs concepts software and its engineering automated static analysis data types and structures software maintenance tools software reverse engineering maintaining software .
keywords linux kernel data types genericity acm reference format nicvolanschiandjulialawall.
.theimpactofgenericdatastructures decodingtheroleoflistsinthelinuxkernel.in 35th ieee acm international conference on automated software engineering ase september virtual event australia.
acm newyork ny usa 12pages.
introduction the linux kernel is today a form of critical infrastructure supportingbillionsofandroidsmartphones allofthetop500supercomputers andmanycomputingdomainsinbetween.thelinuxkernel alsohasaverylargedeveloperbase withover1000commitauthorscontributingtotherecentreleaselinuxv5.
march2020 .thesedevelopershaveawiderangeofexperience withfullyaquarter permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
no previouscommit to the linux kernel.
atthe same time the linux kernel is self contained relying on no external libraries meaning that developers cannot apply their previous experience to understanding its abstractions and data types.
indeed the linux kerneldefinesits ownlibrariesofdatatypesthat meettheunique needs of an os kernel in terms of efficiency e.g.
cache locality flexibility synchronization and ease of use in typical os kernel usage contexts.
one linux kernel data type is that of a doubly linked list.
such lists are used for collecting all kinds of information waiting processes availabledevices messages andsoon.theyareverywidelyusedinthelinuxkernel appearinginover6400files andalsoserveasabasisformorecomplexdatastructuressuchastrees.linuxlistsfurthermorehavesomefeaturesthatobscuretheirpurposeandmay surprisedevelopers.theyareimplementedbyasingledatatype list head thatisusedtorepresentboththeheadofthelistandto connectallofthelistelements.this list head typefurthermore offersonly prevandnextfields forreferringtothepreviousand next list head s respectively but no field pointing to the element value.
instead the element must be implemented as a structure that embeds a list head structure which serves as a connector totherestofthelist.asaconsequence a list head structureis associated with no type information about the list elements.
the features of linux lists provide conciseness efficiency and flexibility.thereisonlyonelistdatatypeandonlyonesetoflistop erators regardless of the number of types of elements.
some of the operatorsarefurthermorecarefullydesignedtoprovideatomicity guarantees thus potentiallypreventingsome hard to understand concurrency bugs.
the fact that the list head structures are embedded in list elements may allow the connector to be in the same cachelineassomeelementvalues improvingperformance.interms of flexibility any list head structure can be placed at the head of orasanelementconnectorinanylist.asingle list head variable can be used to store lists of different element types at different placesinthecode.a list head structurecanchangerole frombeingalistheadtoconnectinglistelements.still whilethesefeatures maybeveryconvenientforexperiencedlinuxkerneldevelopers theymaymakeitverydifficultfordevelopershavinglessexperi encewiththelinuxkernelcodetounderstandtherole listhead or list element connector of list head typed variables and structurefields orfromalistheadtoknowwhattypeofelementsthe referenced list contains.
in this paper we propose a type system and a toolset liliput linux lists program understanding toolset to automatically infer the role and element type associated with linux kernel list head structures.
our approach relies on examination of how a given list head structure is used by the various operators of the linux 35th ieee acm international conference on automated software engineering ase listapithatdifferentiatebetweenlistheadsandlistelementconnectors and imply relationships between them.
we have used liliput to identify the roles list head or list element connector and list element types of of the list head type variables and structuresinlinuxkernelversionsv3.
july21 tov5.
march29 demonstrating the versatility of the approach.
the collected information furthermore permits detecting bugs where list head structuresareusedaccordingtothewrongrole whichcanresult inlossofdata.specifically liliputwouldhaveenableddetecting previous bugs in linux list usage and detects new ones.
ourpatches for the latter have mostly been approved by the linux kernel maintainers.
our main contributions are weshedlightontheproblemofunderstandinglinuxlists whichmayconstituteanobstacletosmoothmaintenance indeed weshowthatlinuxlistsarewidelyusedandpowerful but poorly documented.
as a solution to this problem we propose a toolset called liliput for inferring the types of linux lists and for quickly achieving a global view of the involved data structures thus facilitating maintenance.
we validate our solution by demonstrating its effectiveness roughly and further illustrating several possible uses of these types including discovering list programming techniques and bugs.
therestofthispaperisstructuredasfollows.section2briefly introducestherichworldoflinuxlists andquantifiesthelackof documentationabouttheiruses.section3presentsoursolutionfor facilitatingtheunderstandingoflistusesandsection4describes its prototype implementation.
section presents the validation of our solution by showing itsresults onseveral linux versionsand severalpossibleusesoftheresults.section6situatesthisworkwith respect to other approaches and section concludes and discusses future work.
linux lists in this section we first give an overview of the linux list api then present the history of this api in the linux kernel and finally highlight some advantages and disadvantages of its design.
.
api thelinuxlistapicomprisesthe list head structuretypeanda large set of list related operators.
the list head type is defined ininclude linux types.h and is shown in figure .1it contains prevandnextfields pointingtothepreviousandnextlistelements thus implementing adoubly linked list.
it containsno field for the list element.
instead an element is also represented as a structure of sometype andembeds a list head structure amongits fields.
the list operators are defined in include linux list.h .ar e p resentative subset of these operators is shown in table .
these operatorsallowtraversinglists lines1 accessinglistelements lines testing list elements line adding elements to lists lines9 andnumerousotherfunctionalitiesthatarenotshown.
1all code examples are taken from linux v5.
unless stated otherwise and can be obtained from list head struct list head next prev figure list head structure type 1struct hiddev int minor ... struct list head list spinlock t list lock ... 9struct hiddev list struct hiddev usage ref b uffer ... struct list head node ... figure hiddevstructure type a typical use of the linux list api is found in the hiddevdevice library.thisdevicelibraryprovidesanapifordescribinghuman interface devices a category of usb devices.2the list involves two kindsofstructures definedinfigure2.theheadofthelist i.e.
a list head structurepointingtothelist sfirstandlastelements is embedded in a hiddevstructure lines in the listfield.
the elementsofthelistarerepresentedbystructuresofanothertype hiddev list lines9 .thelattertypealsoembedsa list head structure in the nodefield connecting the element to the previous and subsequent ones.
we say that hiddev.list is the list head hiddev list isthetypeofthe list element and hiddev list.node isthe list connector.notethatwhileinthisexample theheadofthe list isalso embedded ina structure that isnot the onlypossibility.
a list head can also be a simple variable of type list head .
for instance the file system infrastructure fsdirectory maintains a list of block devices in the global variable all bdevs of type list head declared in fs block dev.c.
inpractice itischallengingtounderstandtherelationshipbetweenthevariousstructuretypesinvolvedinalist.inthecaseof thehiddevlist the structure types are defined in different files i.e.
include linux hiddev.h forhiddevanddrivers hid usbhid hiddev.c forhiddev list .therearenocommentsinornear these definitions indicating which structure type represents the list head or the list elements or connecting the one structure type to the other.
some information can however be inferred fromthe use of the various standard list operators on the list head typed fields hiddev.list andhiddev list.node .
for instance thelist add tail operatorisusedtoadda hiddev list.node elementtoa hiddev.list head.the hiddev list elementsinthis list are traversed using a list for each entry and so on.
based on the information obtained from this manual inspection of the 104table a representative subset of standard list operators defined in the c header file include linux list.h .
operator meaning list for each entry c l f traverses a list headed at lcontaining elements of structure type s linked via their field s.fof type list head the traversal uses a cursor c of type s as the current list element list for each entry safe c c l f like list for each entry but allows modifying the list e.g.
by removing elements without losing the cursor c by using an extra cursor variable c prime list for each c l traverses a list headed at lcontaining elements of any type of structures the traversal uses a generic cursor c of type list head offers an untyped traversal with respect to the operators above list for each safe c c l like list for each but allows modifying the list by using an extra cursor variable c prime list first entry l s f returns the first last element of a list headed at lcontaining elements of type s linked using the field s.fof type list headlist last entry l s f list entry p s f returns the list element or head of type s given a pointer pto its field s.fof type list head list is first e l list is last e l tests whether e a pointer to a list head is the first last element of the list headed at l list add e l list add tail l l adds a new first last element eto the list headed at l list splice l l splices the list headed at lat the beginning end of the list headed at l prime this consists in adding all the elements in l but not the head list splice tail l l code we can infer that figure illustrates an example of a typicalhiddevlist.
nevertheless the relevant information is widely dispersed in the source code.
next prevhiddev list head list nextprevhiddev list list head node nextprevhiddev list list head node figure a typical list headed at hidlist.list and containing hiddev list elements connected by their node field.
.
history the current linux list api was first introduced into the linux kernelinlinux2.
.
releasedinjuly1997.theapiwasoriginally onlyusedinthreefilesrelatedtofilesystems.itreplacedanother implementationofdoublylinkedlistsbasedentirelyonmacrosthat generatedlistoperationsforspecificdatatypes accordingtothe types and field names mentioned in the macro arguments.
the apiintroducedinlinux2.
.45includedthe list head type macrosfor declaringandinitializing list head variables andthefunctions or macros list add list del list empty list splice and list entry.
figure illustrates the use of lists over time from their introductionuptothecurrentreleaseatthetimeofwriting v5.
.we have focused on the number of calls to the two operators for list insertion list add andlist add tail astomakealistitisnecessary to add elements to it.
over time many of the new uses of theselistoperatorshavebeenincodethataddsnewfunctionalities but there are also instances where uses of other ad hoc forms of lists have been converted to use the standard api.3as can be seen 3examples 68a2d76cea423 cdcdbe0b179a df0933dcb027 5b1a960d180e availableat git git.kernel.org pub scm linux kernel git torvalds linux.git 000callslist add tail list add figure list usage in linux versions v2.
.
v5.
therehasbeenasteadyincreaseintheuseofthestandardlinux list api and this is likely to continue in the future.
therefore a techniqueforhelpingmaintainerstounderstandlistsmayprove more and more useful.
.
documentation of list head structures asillustratedbythe hidddevstructureconsideredinsection2.
fields of type list head are frequently not documented by appropriatecomments makingitnecessarytocollectinformationfrom the code to understand what kinds of data structures they represent.
to gain a more precise estimate of how often documentation is missing we have builta code search tool finding all list head structure fields and their associated comments.
the search tool has been implemented with coccinelle more details about coccinelle will be given in section .
it searches for comments on a field before after and in the middle of the field declaration as well as summary kerneldoc comments before the entire structure declaration.
byapplyingthistooltothewholelinuxkernel wefoundatotal of list head fields in linux v5.
among which have at least one comment amounting to .
this number has heldsteady since linux v3.
july remaining between and despite the number of such fields almost doubling in this time period.
moreover by manually inspecting a small sample of the commentsfoundadjacenttostructurefielddeclarations 4wefound that less than of these comments provide the complete list information while the other provide only partial information lackingeithertheroleofthefield listheadorlistelement orthe related list head field in the other structure.
consequently we 4included in the supplementary material file manualinspectioncomments.xlsx.
105estimate that less than of the list related fields are thoroughly documented by comments at the point where they are declared.
thislackofdocumentationhasseveralconsequencesforcode maintenance.firstly itmakesithardtogainaglobalviewofthe data structures used when these structures are involved in lists.
this difficulty is exacerbated in structures or sets of structures that heavily use lists such as a task descriptor task struct containing list head typed fields.
in linux v5.
there are indeed structure types that contain more than list head typed fields.
secondly missing documentation increases the risks of errors during development and increases the difficulty of spotting the correspondingbugsduringmaintenance.wehypothesizethatvarious errors related to the list api may be favoured by missing or incomplete list information including for instance using a list head as a listelement orviceversa andextracting accessing orinsertingthe wrongtypeofelementsfrom intoalist.ourevaluationinsection5 will test this hypothesis.
inferring list types giventhe challengesinunderstandingthe usesoflinux lists our aimistoassistthisunderstandingwithanautomatedtool inorder to simplify the development and maintenance of code using this data structure.
when maintainers examine a non documented structure field declaredtohavetype list head theyfacetwoquestionsattwo different levels roleis this field used as the head of a list or as a list element?
typingdepending on the role of the field for a list head this list contains what type s of elements?
for a list element from what list heads is it reachable?
similarquestionsariseforvariablesoftype list head .while variablestypicallyserveinthelistheadrole astheydonotcontain anyotherdatatorepresentalistelement wewillseethatthereare caseswheretheyareinsertedaselementsintootherlists.moreover even when the role of a variable is clearly a list head the question aboutthetypeofitselementsremains.therefore wewillusethe generic term of list name to describe either a structure field or a variable of type list head .
moreover list names also include structurefieldsoftypepointerto list head andstructurefieldsor variablesoftypearrayof list head .inthelattercase weattribute the same type to all the elements in the array.
wenowintroducethefollowingnotations.weusetheletter sfor astructuretype thenameofa structtype theletter fforastructure field name the letter vfor a local or global variable name the letterxfor any c expression and the letter lfor a list name of any kind including a structure field name of the form s.for a variable namevof type list head .
using these conventions we will note l l primethe statement list name lis the head of a list whose elements are list names l prime .
for example s.f s prime.f primemeans that structure scontains via its list head fields.f a list of structures s prime connected via their own list head fields prime.f prime.
thus the type of the list in figure can be noted as hiddev.list hiddev list.node .
.
typing rules ourtypingrulesarebasedonthesemanticsofhowthestandardlistoperators use list head s and related values.
note that developers v3.
v4.0v5.
v5.
000list headsall typed used but untyped unused figure overview of typing results cancircumventthestandardlistoperators byaccessingthe prev andnextfields of a list head structure directly.
we choose to build our typing rules by only taking into account standard list operators because they constitute a finite set of code patterns and are thus amenable to automation.
they are also very frequently used.
still this limitation may result in failing to type some list names.section5 specifically figure5 willexaminetowhatextent this strategy is an issue in practice.
table shows the typing rules corresponding to some uses of standard list operators.
the first column defines code patterns representing specific uses.
some patterns may impose a condition on the pattern variables specified in a where clause.
the second column strict typing shows the typing information that can beinferred based on the use pattern.
the third column will be described in section .
.
note that the table is defined in terms of the notation defined above.
for example a reference to s.fmeans a reference to the ffield of an sstructure regardless of how that referenceisexpressedinthesourcecode.suchinformationcould beobtainedbysomecombinationoftypeinferenceanddataflow analysis but our typing rules are independent of the means by which this information is obtained.
thefirstfoursectionsintable2concernvariouslisttraversaloperators.
traversals use a cursor variable pointing either to a whole elementstructure sections ortoonly the list head connectorembeddedinthatstructure sections3 .theformerstyleof traversal givescomplete typeinformation aboutthe traversedlist including its head the type of its elements and the specific field within those elements that connects them together.
for instance thetraversal list for each entry s l f indicatesnotonly thatlisalisthead butalsothatthislistcontainselementsoftype s the type of structure pointed to by the cursor variable connected throughtheirfield s.f thefieldnamespecifiedasthethirdargument .thelatterstyleoftraversaloperators sections3 doesnot independentlybringanyusefultypinginformation astheoperatorsuseonlyageneric list head cursor.however eveninsuch generic traversals it is common to access the element via a call to list entry ontheloopcursor inthebodyoftheloop.inthiscase we can recover the same information as in the first two sections.
sections in the table concern access operators on list elements from the list head and from the list connector respec tively.
an access from the list head such as via list first entry offers complete type information.
an access from a list connector to the surrounding list element via list entry o nt h e other hand provides no type information since it does not involve both the list head and the list element.
however a call of the form list entry s .f .next s f revealsthetypesoftwoneighbourelements.iftheaccessedfieldsaredifferent hencethe where 106table typing rules based on list operator usage patterns.
code pattern strict typing permissive typing .
list for each entry s l f l s.f l lwhere s.f llist for each entry continue s l f list for each entry reverse s l f list for each entry continue reverse s l f list for each entry from s l f list for each entry from reverse s l f .
list for each entry safe s s l f l s.f l lwhere s.f llist for each entry safe from s s l f list for each entry safe continue s s l f list for each entry safe reverse s s l f .
list for each v l ... list entry v s f ... l s.f l lwhere s.f llist for each prev v l ... list entry v s f ... .
list for each safe v v l ... list entry v s f ... l s.f l lwhere s.f llist for each prev safe v v l ... list entry v s f ... .
list first entry l s f l s.f l lwhere s.f l list first entry or null l s f list last entry l s f .
list entry s .f .next s f wheres .f nequals.f s .f s.f s .f l wheres.f llist entry s .f .prev s f .
list is first s.f l list is last s.f l l s.f l lwhere s.f l .
list add l l list add tail l l l l l l where s.f l list move l l list move tail l l list add rcu l l list add tail rcu l l .
list splice l l list splice tail l l l l l l l l where l prime llist splice init l l list splice tail init l l condition we have a list head and a list element providing a complete list type.
on the other hand when s .f is the same as s.f the developer may simply be getting the next list element starting from its predecessor element.
therefore we cannot infer any type information in this case.
section in the table concerns functions where one argument is a list connector and another is a list head.
in this case we can infer typeinformationifthelistconnectorcanbedescribedas s.f based on any available type and dataflow analyses.
if the list connector isjustdescribedasanarbitraryexpressionofthe list head thenno information can be inferred.
note that the operators of this section are different from those in section where the structure type s and the field name fare separate arguments to the operator thus always providing typing information.
sections in table handle operators inserting elements into a list.
section concerns operators inserting individual list connectors eitherexternaltothelistormovedwithinthelist.these operators involve both a list connector and a list head so if the list connector and the list head can be described as a list name they providecompletetypeinformation.section9concernsoperators splicing a whole list headed at linto a list headed at l prime.
this operatordoesnotprovideinformationaboutthetypesoftheelements in either list.
however the lists should normally have the same elementtypes becausethe list head traversaloperatorsdonot supportpolymorphiclists.therefore weaddanequality constraint between the two types.
as soon as some other operator uses allow typing one of the lists the other list will become typed too.
.
experience with the strict typing rules when we applied the above typing rules to the whole linux kernel linux v5.
we obtained typing errors where different types wererequiredtobeunifiedtorepresentalistelementtype.most oftheseerrors ho wever are notprogrammingerrors butratherfit into one of the following categories.first thereare ab usesofsomeoperatorsthatdonotcorrespond totheirdocumentation butthatworkfine.forinstance theoperator list first entry l s f thatisdocumentedtoreturn the first element of a list is actually just a macro that expands tolist entry l.next s f .
consequently this operator may alsobeappliedtoalistelementtogetthefollowingelement.when used this way our type inference rule will wrongly try to type s.f bothasalistheadandasalistelement.anotherexampleistheuseof list add tail whosesecondargumentisnormallyalisthead butthatcanalsobeusedtoinsertanelementbeforeanotherone e.g.
to maintain a sorted list.
in fact most of the list operators can be used in non standard ways by inspecting their implementation.
secondly many functions define local list variables lthat are used to collect e.g.a list of elements of some type s that are consumed in a loop and then the same list variable is reused for alist containing another type of elements s prime.
this is the case for instance offunction scsih remove unresponding devices whichfillsalocalvariable headwith sas device structures then deletesthemall andthendoesthesamewith pcie device structures.
this kind of situation results in a type conflict between two possible types l s.fandl s prime.f prime.
thirdly there are cases where the elements of the list may be different structures depending on the actual managed device firmware that is used etc.
for example this is the case in the qualcommatherosdriverforwirelessconnectivitydefinedindirectory driver net wireless ath ath10k .here dependingon whether the device version is greater than .
or not the structure ath10k fw stats contains in its field vdevsa list of either ath10k fw stats vdev orath10k fw stats vdev extd structures linkedbytheirfield list .thechoiceisdonedynamically based on flags such as wmi 10 4 stat peer extd.
finally for a list stored in a structure field there may be several instances of this structure where each instance contains the same type of elements but different instances contain different types 107of elements.
the different instances are sometimes managed by different functions in the code specific to device version numbers.
all of these situations manifest as errors in our type system.
.
permissive typing rules asthestricttypingrulesproducetoomanytypeerrorsthatturn out to be false positives we redesigned the typing rules so as to infertypesthatcoveralltheexistingusesoflistsinthecode.for instance when encountering a list operator adding some structure oftypestoalisthead lwithelementsthatarestructuresoftype s prime we relax the type of lto allow elements of both types sands prime.
we model the cases where a list name is used for containing different types of list names using a disjunctive type l prime l1 ... ln.
wewillnotewithletter lsuchadisjunction.thecorresponding relaxed typing rules are given in last column of table .
each strict rule inferring type information of the form l prime lhas a relaxed counterpartthatinfers l prime lwherel l.similarly aruleinferring a type equality constraint l l prime such as the rules at the bottom of the table has a relaxed counterpart inferring a type inclusion constraint l l l prime l primewherel prime l. asopposedtothestricttyping therelaxedtypingrulesnever leadtotypingerrors.indeed anyfinitesetoftypeinclusionconstraintshasatleastonesolution forexample typingeachlistname toadisjunctionofalllistnames includingitself.moreover ithas a leastsolution withrespect tothe type inclusionrelation which can be computed as a fixed point.
thus the relaxed typing rules compute for each list the least type permitting all of its uses.
the fact of never generating type errors is compatible with our primary goal that is understanding the role and type of lists.
the only risk is that of resulting in types that are too general to be useful.
in the evaluation section we find that computing the least permissivetypesdoesnotpreventoursystemfrombeingusefulfor indicating potential programming errors.
indeed a developer may have the intuition that a certain list head should refer to lists with only one type of element in which case inferring a disjunctive type for it might help spot a potential problem.
implementation we have implemented the permissive typing rules presented above inaprogram understandingtoolsetforlinuxlistscalledliliput.
liliput consists in two main tools whose goals are respectively list detection afirsttoolfindsusesoflists declarations structure fields and scalar variables and operations standard list functions and user defined list functions .
this tool outputs a list usage report.
type inference a secondtool inferstypes forthe listsbased on their usage starting from the list usage report.
it outputs a typing report.
each tool provides a textual report that can be easily read inspected and amended if necessary by developers.
moreover we show that these reports may also be exploited automatically by other program understanding tools for data structure visualisation or interactive list usage inspection.
the list usage report containsasectionforeachlistname containing the list name followed by information about each use ofan operator that has an expression represented by the list nameamong its arguments.
arguments not related to lists or whose list name could not be uniquely determined are abbreviated as ?
.
for instance thefollowingsectiondescribestheusesofalocalvariable deadof type list head declared in the function exit notify dead exit notify forget original parent ?
dead exit notify kernel exit.c list add task struct.ptrace entry dead exit notify kernel exit.c list for each entry safe task struct ?
dead exit notify ptrace entry kernel exit.c thefirstcallistoauser definedlistoperator andthenexttwocalls are to standard list operators.
thetyping report containsthetypeforeachlistnamewhosetype could be inferred as a disjunctive type of the form l l1 l2 ...ln.
forinstance thefollowingexcerptgivesthetypeinferredforthe local variable above dead exit notify task struct.ptrace entry thefollowingexcerptgivesthetypeofthelocalvariablealready mentioned in section .
used to contain first sas device structures and then pcie device structures.
head scsih remove unresponding devices pcie device.list sas device.list wepresentthetwomaintoolsbelow andthenbrieflypresent two other program understanding tools that we have developed based on the collected information.
.
list detection wecollectinformationaboutthedeclarationandusageoflistsusing thetoolcoccinelle .coccinelleisaprogrammatchingand transformationtoolforccodethathasbeenextensivelyusedon the linux kernel.coccinelle allowssearching forpatterns ofcodeexpressedasfragmentsofccodeparameterizedby metavariables.
itdoesnotrequiremacroexpansion butinsteadreliesonheuristics to parse the c code in the presence of macros and ifdefs.
it isthus independent of the chosen configuration options ifdefs of whichtherearemanyinthelinuxkernel .thisfeatureenables covering over of the .
million linesof c source code found in linux v5.
.
the use of coccinelle also allows rapid prototyping of complex code search rules.
nevertheless there is a risk of some omissions either because the rule set is not complete or because the parsing heuristics failed on some code.
nevertheless for linux v5.
the list detection tool finds information about list typed structurefields 545list typedvariables and68 541functionoriterator calls having list typed arguments and thus we believe that our coccinelle scripts cover a very large percentage of the list structures and operations found in the linux kernel.
collectionoftheinformationproceedsintwophases.thefirst phasecollectsinformationaboutstructurefieldsoftype list head pointerto list head orarrayof list head aswellasglobalvariablesof anyof thesetypes and localvariablesof type list head and array of list head .
we omit local variables of type pointer to list head becausethesetypicallycorrespondtotemporarypointers to elements of an existing list.
the linux kernel may declare multiplestructuretypeswiththesamename whichmayhavesomefieldsofthesamename.asaheuristic wekeepsuchfieldswhenalldefinitions of the structure have the same set of list typed fields as 108this often corresponds to different variants of a structure for different variants of a device or different hardware architectures.
on the other hand when two definitions of the same structure name have a list typed field that appears in both definitions but the complete set of list typed fields defined by the two structures is different we discard the common list typed field as being ambiguous on theassumption thatthefieldmay havedifferent rolesinthe two structures.
for linux v5.
we discard information about variables andstructurefields dueto ambiguity.the secondphase thencollectsinformationabouttheargumentsoffunctionsanditerators that refer to the fields that were identified in the first phase.
the collection is implemented in lines of coccinelle code.
most of the code is due to the many variations in nested unions structures etc.
and is not challenging to write.
thecollectionoffunctionsanditeratorsthathavelistarguments does no dataflow analysis neither across function calls nor within functiondefinitions.thisreducestheinformationavailableabout lessthan2 offunctioncallsanditerators linuxv5.
.itshould be possible to reimplement the information collection phase ina dedicated program analysis framework such as llvm to takesuchinformationintoaccount althoughwiththeinconvenience that such tools are sensitive to preprocessor configuration options.
for this work we favored the rapid prototyping and high coverageadvantagesofcoccinelle aslinuxkernelcodemoretypicallyrefers to lists explicitly.
our list detection tool misses nameless struct declarations in typedefs namelessstructdeclarationsinvariabledeclarations and3 somestructurefieldsthataredeeplynestedinotherstructures and unions.
list head structure fields out of are overlooked in linux v5.
due to these limitations.
our tool runs on linux v5.
in around hours on a core machine with intel xeon2.20ghzcpusand251gbmemory withthekernelsourcecodein a memory backed file system to eliminate the cost of disk accesses.
.
type inference the type inference tool takes as input the list usage report and outputs the typing report.
as both these reports are textual we chose tocodethistoolinascriptinglanguageofferingrichpossibilities of text processing namely perl.
the implementation consists of 300linesofperl andisstraightforward.itmaintainsamapfrom list names to sets of list names representing disjunctive types.
the map is computed as the fixed point of the constraints generatedby each permissive typing rule in table .
as a complement to the typing report it prints statistics about list usage including the total number of list names the number of list heads list elements untyped list names etc.
.
other tools the information computed in our reports can be exploited beyond retro documentingthelistdeclarations.toillustratethisfact we have prototyped two extra tools in our toolset.
firstly avisualisationtooltakesthelisttypingreportasinput and produces graphs of all the list data structures.
this allows maintainerstohaveaglobalviewoflistusageinagivenmodule where lists are used extensively or to form particular patterns.
indeed we identified many instances of complex data structuresimplementedwithseverallists suchassimplyanddoublylinked trees of fixed or variable height.
we also found header files and or structurescontainingmanylistfields.forinstance theheavilyused header file include net devlink.h included in c and header files contains list fields among which are defined in a single central structure called devlink.
secondly a list usage exploration tool takes the list usage report asinput andbuildsahypertext basedlistingcontainingasubsetof thedetectedlistusagescorrespondingtoafilteringcriterion.for instance onefilterthatprovedtobeusefulduringthedevelopmentofthelistusagereporttoolselectedallthelistoperatoruseswheresomelistargumentscouldnotbeuniquelydeterminedaslistnames abbreviated as ?
in the report .
this helped us to manually inspect complex list usage patterns and discover some stereotypical programmingtechniquesthatcouldberecognizedandleveraged forimprovingthelistusagereports.onesuchtechniquewasthe complexpatternforgenericlisttraversalusing list for each describedinthethirdsectionoftable2 wherethetypinginformation could be reconstituted from several related sub patterns.
moreover this exploration tool could be extended to take as additional input the typing report.
this would allow performing more complex searches such as selecting all the list initializations using operator init list head acting on a list element instead of a list head.
beyond our own use for tuning our analyses the list usageexplorationtoolmightbeusefulformaintainers forexample after fixing one bug to search for similar list misuses to fix.
evaluation the primary goal of our evaluation is exploratory to see what we canlearnaboutlistusagefromtheinformationinferredbyourtype system.wealsoassesstheaccuracyoftheproducedinformation.
to meet these goals we consider the following research questions rq1 to what extent is our type inference system effective are the identified types the correct ones and do all lists receive types?
rq2 to what extent does our type inference system provide added value going beyond the information already available in the comments and source code?
rq3 what programming techniques for the use of lists are revealed by the inferred type information?
rq4 whatkindsofbugscanbedetectedusingtheinferredtype information andhowhelpfularethetoolsprovidedwithliliput in finding such bugs?
.
effectiveness to obtain a broad view of the effectiveness of liliput rq1 we applied it to all of the linux kernel releases from v3.
march tov5.
march2020 .figure5presentsanoverviewoftheresults.
liliputfound5747listnamesinv3.
andtheirnumberincreasedtoover10 000inv5.
.liliputcouldtypebetween87 and91 of these list names in each kernel version.
therearetwocasesinwhichalistnamedoesnotreceiveatype.
onecaseiswhereliliputfindsalistdeclarationbutfindsnolist operator whetherstandardorspecial purpose thatisappliedtothe list name.
in this case liliput reports that the list name is unused.
this is the case for list names depending on the version 109table inferred list types experiment typed head element head total only only element v4.
.
.
.
v5.
.
.
.
and2.
ofthelistnamesfoundinlinuxv5.
.however liliput could wrongly flag a list name as unused if the list name is used outsideoffunctioncalls.wemanuallyinspectedasmallsample5 of cases involving list variables local to a file which cover roughly one third of the cases in v5.
because it is easy to find all uses for such cases.
in this sample we found a few false positives where thelistsaremanipulatedwithoutusinganylistoperator suchas assigning them from or comparing them to other list variables.
in thesample of the listnames reportedas unusedwere true positives that is the lists are indeed never used.
this information about unusedlists canbe usefulfor kernel developersin cleaning up the code base.
therearealsobetween6.
and9.
oflistnames .
inlinux v5.
that are used with list operators but could not be typed as theydonotsatisfyanyofthelistoperatorpatternsinourtyping rules .
this can occur when the list name is used by list operatorswherenolistnamecanbeidentifiedforsomeoftheotherargumentsusedbythetypingrule e.g.
whentheseotherarguments are represented by local variables or function parameters.
the kerneldevelopermayneverthelessbenefitfromhavinginformation about the uses of the list name summarized in the list usage report.
on this basis some relationships not taken into account by thetype inference system but known to the developer of a specificsubsystem mayhelpthedeveloperidentifythepropertiesofthe list structure.
wefocusnowontworecentversions linuxv4.
october2018 and linux v5.
march to give more detailed results.
table3detailsthetypedlistnamesfoundinv4.19andv5.6by presentingthedifferentkindsoftypesthathavebeeninferredfor them.ascanbeseen abitlessthan60 oftheselistnamesplay the role of list head while a bit more than play the role of list elements.thus whilethereisalotofvariationinpractice onaverage a given type of list element is found in several lists about .
.
thistypicallycorrespondstothelocalvariablesthattemporarily store elements which are permanently stored elsewhere either in a heap data structure or in a global variable.
apart from these simple cases where a list name is either a head or an element around .
of the list names are both used as alist head and as an element in one or more lists.
table further subdivides this special case by reproducing the head element columnintable3 isolatingtwofrequentsub patternsofsuchlists self lists and mutual pairs.
self lists are list names containing only themselves l l. mutual pairs are pairs of lists containing each other and nothing else l l prime l prime l. these particular cases are worth investigating and are described later.
the few remaining cases under are more complex typing patterns in which a list name is used as a head but also as an element in several lists.
5included in the supplementary material file manualinspectionunused.xlsx.table4 usesoflistnamesthatservebothasalistheadand as list elements experiment hd elm self mutual other total lists pairs cases v4.
.
.
.
v5.
.
.
.
.
added value inthe absenceofour typesystem developers canobtaininformation about lists from the documentation typically comments in the code and from any naming conventions used in the code itself.
we thus next consider the degree to which our approach provides added value rq2 i.e.
information that is not easily accessible to the developer already.
in section .
we have already shown that lists are rarely documented.basedonasampleof22linuxv5.
list head structures6 thatareassociatedwithsomecomments wehavealsofoundthat whentheyaredocumented thedocumentationisoftenincomplete.
foronedocumentedfield liliputinferrednoinformation andforanotherfield theamountofinformationinferredbyliliputisthesameastheamountofinformationintheassociatedcomment.
in all of the remaining cases i.e.
out of the informationinferredbyliliputwasconsistentwiththeexistingcomments andwasmorecomplete.forexample struct vpe definedinfile arch mips include asm vpe.h containsafieldnamed tcoftype list head whose comment is tc s associated with this vpe .
this suggests that vpe.tcis a list head containing structures of type tc but does not indicate which is the connector field within tc.
asstruct tc contains two list head fields the information in thecommentisincomplete itcouldberepresentedas vpe.tc tc.?.
liliput infers the complete type information vpe.tc tc.tc.
based on the information inferred by liliput we can furthermore check the correspondence between list names and the inferred types.
we studied the most frequent names of list fields and found that the name list is by far the most common one covering roughly of the list fields.
our typing results show that structure fields named list usually serve as list connectors .
this leaves however a non negligible fraction that are used as list heads.overall thenamingconventionisnotfullyreliablefordistinguishing the role of list fields.
on the other hand the second most frequent list field name is node of the list fields .
our types show that this name is always used for identifying list connectors.
however asonly5 ofthelistconnectorsfollowthisconvention the information inferred by liliput is overall still useful.
these results show that our type inference provides informationnotalreadyeasilyavailabletokerneldevelopers.ourtyping results can be used to improve the documentation about specificlist typed variables and structure fields and to retro document naming conventions.
.
programming techniques studyingthecollectedtypeinformationrevealssomeinteresting programming techniques used in manipulating lists rq3 .
we 6included in the supplementary material file manualinspectioncomments.xlsx 110have seen in section .
that some list heads are associated with more than one list element type out of list heads .
inlinuxv5.
andintable3thatsomelistheadsarealsousedas listelements .
ofalltyped list head structuresinv5.
.allof these cases result in liliput inferring disjunctive types.
these type smells analogous to code smells do not necessarily indicate bugs.
however their uncommon nature may convey specific information whichmightbeworthinvestigating.indeed bystudying samplesofeachofthesetypesmells wewereabletouncoversome list programming techniques.
a number of the disjunctive types out of in v5.
contain a local variableamong theelements.
thereare several listprogramming techniques that involve adding a local list head variable to a list located in a structure field.
a first technique motivated byconcurrency consists inatomicallymovingalltheelementsin the list towards a local list variable in bounded time while holding a lock and then liberating this lock and processing the elementsoutside of the critical section.
this technique is illustrated in the function gfs2 jindex free whoselocalvariable listisinvolved in the following disjunctive type gfs2 sbd.sd jindex list list gfs2 jindex free gfs2 jdesc.jd list this function clears all the journal index information contained in the gfs2 jdesc elements by first adding variable listin the originallist andthenremovingandemptyingtheoriginallisthead using the operator list del init this operator is normally used forremovinglistelements notlistheads .thesequenceofthese two operators is protected by a lock.
after the lock is released the elements in the local variable listare consumed.
a secondtechnique involving localvariables is relatedto a particularkindoflists.whilemostlistscompriseadistinctlistheadfol lowedbyaseriesoflistelements insomelists allofthe list head structuresareembeddedinstructuresofthesametypeandareused in the same way.
this results in a list type of the form s.f s.f wherethelistheadandtheelementconnectorarethesamestructure field amounting to a self loop.
we refer to such a list as aring.
as the list traversal operators assume the existence of a list head whichshouldnotbetraversed theseoperatorscannotbeused with rings.
to enable traversing a ring a common programming technique is to temporarily add a local variable of type list head withinthering.thisvariable usuallycalled head isusedtotraversealltheelementsinthering andisthenremoved.thistechnique results in a disjunctive list type such as the following which results from applying the technique in two different functions lpfc bsg ct unsol event andlpfc ct unsol event both of which use a local variable named head.
lpfc iocbq.list head lpfc bsg ct unsol event head lpfc ct unsol event lpfc iocbq.list head lpfc bsg ct unsol event lpfc iocbq.list head lpfc ct unsol event lpfc iocbq.list a ring can also be used to implement a doubly linked tree of height one which we refer to as an umbrella.
an example of an umbrellaisthewidelyusedkernelrepresentationofaperformanceevent implementedinstructure perf event whosecomputedtype is circular a self list perf event.child list perf event.child listthis structure contains a list of other performance events that are considered its children.
for implementing this list the samefield child list is used in the parent as a list head and in the childrenasaconnector.unlikeinasimplering eachchildinthe umbrella points back to its parent using a different field parent inperf event while the parent points to itself.
we found umbrellas in linux v5.
by inspecting instances of self loop types.
listsarealsousedtoimplementtreesofarbitrarydepthofsome structure s.suchtreesusetwodifferentfieldsof s onealwaysbeing alisthead andtheotherbeingtheconnectorbetweenthechildren.
an example of a tree is found for instance in a central data structure of the file system infrastructure called dentry representing a directory entry whose computed type is dentry.d subdirs dentry.d child thus any dentrycontainsinfield d subdirs apossiblyemptylist of children and is part itself of a list via the distinct field d child.
thereare47such tree s typesinlinuxv5.
i.e.
typesoftheform s.f s.f primewheref prime nequalf.
theirnumber hasvaried between33 in v3.
and in v4.
.
finally by studying several examples of mutual pairs we found another list programming technique.
for example the marvell wireless lan device driver contains two mutual pairs mwifiex ra list tbl.list mwifiex tid tbl.ra list mwifiex tid tbl.ra list mwifiex ra list tbl.list mwifiex bss prio node.list mwifiex bss prio tbl.bss prio head mwifiex bss prio tbl.bss prio head mwifiex bss prio node.list in fact it is the second type of each pair that gives the correcttype in both cases the listfield is used as a connector.
the reverse type is due to a list programming technique used in function mwifiex rotate priolists that implements a round robin algorithm.
namely after a packet is successfully transmitted both listsarerotatedsothepacketnexttotheonetransmittedwillcome first in the list.
this is done by moving the list head right after the transmittedpacket usingoperator list move .basedonthisusage notconformingtothedocumentation ourtypingtoolinfersthat the list head is an element of the list headed by its real element.
.
bugs in list usage while we have seen that some disjunctive types correspond to useful programming techniques others do correspondto bugs rq4 .
forinstance wemanuallyinspectedthecodecausingthefollowing type spu gang.aff list head spu.aff list spu context.aff list theinspectionrevealedthattheonlycorrectelementtypeisthe second one.
the first element type spu.aff list is only due to a traversalofthelistheadwithacursorvariablethatisincorrectly declaredtohavethetype spu insteadof spu context .incidentally thetraversalisonlycountingtheelements sothisbugcurrently hasnoconsequences butitisalatentsourceoferrorsifsomeother processing is added within the traversal body.
a common source of mutual pairs is a call to list add or list add tail withtheargumentsinthewrongorder.indeed bothargumentstothesefunctionshavetype list head andthedeveloper has to remember that the first argument should be a list connector and the second argument should be a list head.
not respecting this 111ordercanleadtoinformationlossandmemoryleaks iftheargument provided as a list connector is actually a list head pointing to a non empty list.
one such case is the following mutual pair in the driver for the phyter precision time protocol transceiver dp83640 clock.list phyter clocks phyter clocks dp83640 clock.list here the correct type is the second one phyter clocks is a global variablecontainingstructuresoftype dp83640 clock .theother typeisduetoauseofthe list add operatorinwhichthearguments arereversed introducingtheglobalvariableasanelementinthelist headed within thestructure while the intention wasthe opposite.
overall we identified bugs in linux v5.
based on type smells.
we have submitted patches for of them.
four of these patches have been approved by the linux kernel maintainers.
the fifth has received no response so far.
indeed the code contained two errors and the patch was incomplete as it was not clear how to fix one oftheerrors.intheremainingcase wehaveinformedthekernel developersoftheissue butwedonotknowhowtofixitandarethusunabletoproposeapatch.nevertheless allofourapprovedpatches received quick responses suggesting that inconsistencies in the useoflistsisanissuethatlinuxkerneldevelopersareconcerned about.
to further evaluate the potential utility of our type information we searched for past patches to the linux kernel that changed the arguments ofthe list add and list add tail operators.
thegoal was both to see whether this is a recurring bug pattern thereby potentially benefitting from a tooled approach and whether ourtype information could have helped to find them.
we found such patches using the patch query tool prequel .
this seems to confirmthatsuchbugsarerecurrent.10ofthe11patchesswaptheargumentsandtheremainingonechangesthetargetlisthead.for8patchesoutofthe11 wehavecheckedthetypesinferredforthere leaseofthelinuxkernelpriortothepatchandfoundthatthetypescontainamutualpair asillustratedinthephyterexamplediscussed above.thus thetypeinformationcouldbehelpfulinthesecases.
for other patches we do not have any type information becausethe relevant code was not present in the release prior to the patch andwehaveonlyrunliliputonkernelreleases.for1patch we werenotabletoobtaintherelevantversionusing git describe andthusitwasnotpossibletofindtheassociatedtypeinformation.
summarizing we have evidence that a large majority of the previous bug fixes of argument inversion for list insertion could have been spotted by our typing tool.
by putting together the previously fixed bugs and the new bugs we identified we can validate the hypothesis formulated in section .
that missing or incomplete list information may favourerrors such as confusing heads and elements or inserting using wrongtypeofelements .indeed bugsinvertingtheargumentsof alist add operatorare instancesofthehead element confusion and have the effect of inserting a wrong kind of element into a list andusingacursorvariableofawrongtypemaycauseerroneous element extractions and accesses.
.
visualisation example weconcludebyconsideringhowthetoolsprovidedwithliliput canhelpunderstandlistsandfindlistusagebugs rq4 .figure6dp83640 private dp83640.crxts dp83640.c dp83640 clock dp83640.c var dp83640.crxts rxpoollist list phylist list phyter clocks figure visualization of the structures involved in thephyter precision time protocol transceiver example shows the result of the visualization for the structures involvedin the phyter precision time protocol transceiver bug.
each box representsavariableorastructuretype.ovalsintheboxrepresent thevariableorthestructurefields respectively.blueovalsareat leastlistheads possiblyalsolistelementconnectors whileblack ovalsareonlylistelementconnectors.inthiscase wecaneasily see the mutual pair related to the bug discussed above.
tofacilitatestudyingsuchuncommoncases thevisualization toolcanbeconfiguredtogenerateonlygraphsthatcontainself lists and only graphs where a list head has another list head as a list element as is the case of a mutual pair.
it is also possible to specify thenameofastructureorfieldthatmustappearinthegraph to focus on a single example.
related work templatesinc andjavagenerics whichwereintroduced in enable defining an api that is parameterized over some types.
these features make it possible to define a list type that can beusedwithdifferenttypesofelements suchthattypechecking ensuresthatallelementshavethesametype.inthecontextofjava anautomaticrefectoringwasmadeavailabletousesuchtypesin eclipse3.
releasedinjune2005 .still astudyof20widelyused java projects in showed that the adoption of generics intheseprojectswasspotty oftenrelyingonthemotivationofa single developer and often addressing a limited set of types e.g.
listsofstrings.asubsequentstudyin2014 considering31kjava projects from sourceforge found that of the projects instan tiated existing generic types but less than of the total set of files from the 31k projects did so again suggesting some reticence in using these features.
the linux developers have aggressively adoptedalistimplementationthatdoesnotincorporatetheelement type.
however linux lists also include the notion of a list head which brings some extra expressivity as noted in section .
as compared to simply parametrizing a list by a type.
as a large and critical code base the linux kernel has been the subject of numerous efforts to mineproperties of the source code.
engleretal.
initiatedthefieldof protocol mining inthelinux kernel by finding commonly occurring sequences of function calls and thenidentifyingas bugssequences offunction callsthat only partiallymatchedthesepatterns.subsequentworkimprovedthe 112accuracy of the approach and extended it beyond function calls .
saha et al.
eliminated the requirement that identified sequences of function calls occur commonly enabling finding bugs in subsystem specific function protocols.
lu et al.
mine correlatedvariables suchasavariablecontainingastringandanother variable storing its length and detect bugs where the variables are notupdatedconsistently andraceconditionswhenthevariables areupdatedwithoutholdinglocks.lawallandlo mineuses ofnamesdeclaredwith define useclusteringtogrouptheminto types and then use the types to identify names used in invalid contexts.
we are not aware of any mining based type inference approaches that have been applied on the linux kernel to generic structures such as lists.
our type inference system complements the c type list head withadditionalannotations describingtheiruseaslistelementsor heads.
this is similar to the approach of type qualifier inference.
type qualifiers complement programming language types with extra attributes typically from a finite set.
they were initially illustrated by inferring constannotations in the c language.
other applications concerned ownership or security properties amongothers.fromstandalonetypingtools theyevolved into compiler plugins through the notion of pluggable types as in the checker framework for the java language .
more recently thesebatch orientedtoolswerecriticizedasbeinginflexible bynot allowing the user to modify the code to fix qualifier conflicts an interactivetoolwasproposedasasolution .inourproposal the complementary typing information is not derived from a fixed set butratherinthenamespaceofctypes orsubsetsthereof.ourtool isimplementedasabatchtool buttheaccesstotheintermediate reports enables maintainers to actively participate in the typing process for instance by filtering or modifying the computed types accordingtotheirdomainexpertise.intheimplementation weuse a combination of typing rules dataflow analyses and heuristicsto reverse engineer the complementary typing information.
it isan interesting question whether the implementation of our analysescouldbesimplifiedbyleveraginganexistingframeworkfor pluggable types.
a different approach to type inference for program understandingwas pioneered bythetoollackwit also targetingccode.
lackwitinferstypesthatdescribehowvaluesflowbetweenvariables i.e.
itgivestwovariablesthesametypeifvaluescanbepassed betweenthem.liliputfocusesonlyonlistvariables concerning theirroleinlistdatastructures.itrevealsconnectionsbetweendata structures rather than how values flow.
conclusion and perspectives we have presented a toolset for retro documenting linux kernel listswithtypeannotations.annotationsaresuccessfullyinferred for of the total list structures defined.
the information provided by the inferred types can help understanding data structures and build graphical representations of complex data structures.
by studying uncommon typing patterns type smells the provided informationcanalsohelpspotpossiblebugsoridentifycomplex programming techniques involving lists.
oneperspectiveforcontinuingthisapproachwouldbetouse ourstricttypingrulestoenforceamoredisciplineduseoflists.thiswouldrequiredeveloperstoduplicatesomelocallistheadvariables to account for list elements of different types at different times and create some dummy structures around local list head variables temporarily used as list elements.
a necessary pre requisite would be to investigate whether kernel developers would be interestedin a solution requiring more typing discipline but offering more runtime guarantees.
on the other hand there are several possible generalizations of our type inference technique and its applications.
onedirectextensionofourtypeinferencesystemwouldbeto useourtypingresultsasabaseforinferringhigher leveltypes that wouldconveyricherinformationformaintainers.suchhigher level types could include rin s tree s andumbrella s respectively for rings doubly linked trees and umbrellas of some structure s as defined in section .
.
recognizing such types would need some new inference rules e.g.
for identifying the up links in trees or umbrellas.
another direct extension of this work would be to consider other kinds of lists defined in the kernel libraries covering morespecialized needs.
examples include lru lists for implementingcaches defined in file list lru.h and bl lists used in scalable hash tables defined in list bl.h .
furthermore data structures other than lists could be considered suchasred blacktrees definedin rb tree.h .7likelinux lists red blacktreesareformedbyembeddingaconnectorstructure called rb nodewithin someother datastructures forming a sorted balanced tree.
unlike linux lists however there is a second connector data structure called rb rootthat represents the tree root.red blacktreeconnectorsareembeddedin70differentdata structuresinthekernel.inferencerulescouldsupplementlacking documentation indicating which type of elements correspond to a rootandviceversa andenablecheckingwhetheronlytheright kind of structures are inserted or searched for in a given tree.
one way of going further with the generalization is to focus on the idea of generic structure embedded in various other structures whichabstractsthenotionofconnectorsinlinuxlists.apromising indicatorforsuchpatternsistheuseofthe container of macro if used for retrieving different container structures starting froma generic structure.
examples of such generic structures include callback head kobject kref rcu head etc.usingsomesimple rulesincoccinelle wefound454 genericstructuresthatareused withtheoperator container of forretrievingatleasttwodifferent containertypes.thisseemstoindicateagreatpotentialforcases where type inference techniques could be useful.
finally the approach could be explored for other os kernels.
for example the use of connectors embedded in data structures for improving the cache locality of linked structures is a recurring design pattern in highly optimized system software.
availability.
the supplementary material available both as an evolving git repository and as a specific version for reproducibility purposes on software heritage contains the list detectionandtypeinferencetools thetypeinferenceresults the manually inspected samples and the visualization of selflists andof list names that are both list heads and list elements v5.
.
113references robert dyer hridesh rajan hoan anh nguyen and tien n. nguyen.
.
miningbillionsofastnodestostudyactualandpotentialusageofjavalanguage features.
in icse.
.
dawson r. engler david yu chen and andy chou.
.
bugs as deviant behavior ageneralapproachtoinferringerrorsinsystemscode.in sosp.
.
jeffrey s foster manuel f hndrich and alexander aiken.
.
a theory of type qualifiers.in acm sigplan conference on programming language design and implementation.
.
m. fowler.
.
refactoring improving the design of existing code.
addisonwesley.
robert m. fuhrer frank tip adam kiezun julian dolby and markus keller.
.
efficiently refactoring java applications to use generic libraries.
in ecoop.
.
weihuang wernerdietl anamilanova andmichaeldernst.
.
inference and checking of object ownership.
in european conference on object oriented programming.
springer .
tedkremenek paultwohey godmarback andrewy.ng anddawsonr.engler.
.
fromuncertaintytobelief inferringthespecificationwithin.in osdi.
.
julia lawall and gilles muller.
.
coccinelle years of automated evolution in the linux kernel.
in usenix atc.
.
julia lawall derek palinski lukas gnirke and gilles muller.
.
fast and preciseretrievalofforwardandbackportinginformationforlinuxdevicedrivers.
inusenix atc.
.
julia l. lawall and david lo.
.
an automated approach for finding variableconstant pairing bugs.
in ase.
.
zhenmin li and yuanyuan zhou.
.
pr miner automatically extracting implicitprogrammingrulesanddetectingviolationsinlargesoftwarecode.in esec fse.
.
shan lu soyeon park chongfeng hu xiao ma weihang jiang zhenmin li ralucaa.popa andyuanyuanzhou.
.
muvi automaticallyinferringmultivariableaccesscorrelationsanddetectingrelatedsemanticandconcurrencybugs.
insosp.
.
roberto callahananddanieljackson.
.
lackwit aprogramunderstanding tool based on type inference.
in proceedings of the 19th international conference on software engineering.
ieee computer society .
yoannpadioleau julial.lawall ren rydhofhansen andgillesmuller.
.
documentingandautomatingcollateralevolutionsinlinuxdevicedrivers.in eurosys.
.
matthew m papi mahmood ali telmo luis correa jr jeff h perkins andmichael d ernst.
.
practical pluggable types for java.
in proceedings of the international symposium on software testing and analysis.
.
chrisparnin christianbird andemersonr.
murphy hill.
.
javagenerics adoption how new features are introduced championed or ignored.
in msr.
.
sumansaha jean pierrelozi ga lthomas julial.lawall andgillesmuller.
.
hector detecting resource release omission faults in error handling code for systems software.
in dsn.
.
umeshshankar kunaltalwar jeffreysfoster anddavidawagner.
.
detecting format string vulnerabilities with type qualifiers.. in usenix security symposium.
.
bjarnestroustrup.
.
parameterizedtypesforc .
j. object oriented program.
jan. .
mohsen vakilian amarin phaosawasdi michael d ernst and ralph e johnson.
.
cascade a universal programmer assisted type qualifier inference tool.
in ieee acm 37th ieee international conference on software engineering vol.
.
ieee .
nic volanschi and julia lawall.
.
supplementary material as git repository.
.
nicvolanschiandjulialawall.
.
supplementarymaterialassoftwareheritagepermalink specificversionforreproducibilitypurposes .
softwareheritage.org swh rev a303a19397a995a2bc4d8a2a2156f7409c39afef origin .
alexandervonrhein j rgliebig andreasjanker christiank stner andsven apel.
.
variability aware static analysis at scale an empirical study.
acm transactions on software engineering and methodology articleno.
.
konstantinweitz genekim siwakornsrisakaokul andmichaeldernst.
.
atypesystemforformatstrings.in proceedings of the international symposium on software testing and analysis.
.