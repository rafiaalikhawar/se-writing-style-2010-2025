understanding bounding functions in safety critical ua v software xiaozhou liang john henry burns joseph sanchez karthik dantuy lukasz ziarekyand yu david liu suny binghamton binghamton new york email fxliang24 jburns11 jsanch49 davidlg binghamton.edu ysuny buffalo buffalo new york email fkdantu lziarekg buffalo.edu abstract unmanned aerial vehicles ua vs are an emerging computation platform known for their safety critical need.
in this paper we conduct an empirical study on a widely used open source ua v software framework paparazzi with the goal of understanding the safety critical concerns of ua v software from a bottom up developer in the field perspective.
we set our focus on the use of bounding functions bfs the runtime checks injected by paparazzi developers on the range of variables.
through an in depth analysis on bfs in the paparazzi autopilot software we found a large number of them instances are used to bound safety critical variables essential to the cyberphysical nature of the ua v such as its thrust its speed and its sensor values.
the novel contributions of this study are two fold.
first we take a static approach to classify all bf instances presenting a novel datatype based category taxonomy with finegrained insight on the role of bfs in ensuring the safety of ua v systems.
second we dynamically evaluate the impact of the bf uses through a differential approach establishing the ua v behavioral difference with and without bfs.
the two pronged static and dynamic approach together illuminates a rarely studied design space of safety critical ua v software systems.
index terms unmanned aerial vehicles bounding functions safety i. i ntroduction unmanned aerial vehicles ua vs are an emerging platform with promising applications such as infrastructure inspection precision agriculture disaster search and rescue and merchandise delivery.
traditionally designed as a robotics and embedded system with minimal software support the software stack of ua vs in recent years has been significantly enriched making them a flying computer system in the genuine sense.
beyond the excitement the main hurdle against the broader adoption of this promising technology is their stringent requirement on safety any crash of the ua v is not only a computer safety problem but also a public safety hazard.
even though the safety critical nature of ua vs is universally recognized there is no universal definition of what safety really means for ua vs. broadly any behavior that deviates from the intended behavior is a safety violation.
existing research generally takes a top down approach an expert may provide a specification of the intended behavior either through domain knowledge or through the wisdom from the broader domains of cyber physical systems cps or robotics.
once the specification is given whether in the form of invariants constraints pre post conditions or logic the safety of a ua v system can be verified monitored or enforced.
a. an empirical perspective on uav software safety in this paper we take a bottom up approach to empirically study the safety of ua v software.
in a nutshell we choose to listen to the ua v software developers in the field and reverse engineer what they believe the most safety critical software components are.
despite early ua v systems often being developed in a proprietary fashion recent trends in opensource development for ua v systems present an opportunity.
for example the software framework that serves as the focus of our empirical study paparazzi1 is a popular open software and hardware ecosystem with more than a decade of development and numerous active contributors.
it provides unified software support from autopilot to ground station with diverse support for multi copters fixed wing helicopters and hybrid aircraft.
if domain experts are the best source for understanding the intended behavior what can we learn about ua v safety from ua v software developers themselves?
we focus on how bounding functions bf are used in the paparazzi autopilot software arguably the most safety critical components of the ua v software.
a bf is a dynamic check inserted by programmers to ensure a variable which we call a bounded variable bv stays within a prescribed range.
for example variable gv z ref in paparazzi s navigation guidance module is frequently bounded by a bf within the range .
here the bounded variable gv z ref represents the altitude the ua v is guided to for the next time interval variable cur z represents the current altitude of the ua v andgc max z diff is a constant.
intuitively this bf instance says that the ua v should not alter its altitude by gc max z diff or more within a time interval.
this is aligned with our high level understanding on ua v safety that an excessive change in altitude may jeopardize the stability of the ua v .
the premise of our approach is that the use of bfs is aligned with a ua v specific safety concern.
after all the semantics of bounding a variable is akin to introducing an invariant over ieee acm 43rd international conference on software engineering icse .
ieee the variable the application of the bounding function is a noop if the variable is already in the range or an assignment to the variable with the bound value otherwise.
if we take the programmer s perspective the need to bound a variable is aligned with her concern that an out of range variable may cause errors in the program.
we take a two pronged approach in validating our premise.
statically we identify all bf instances in the source code and provide a detailed datatype based taxonomy of the bf uses.
we find a large number of bf uses indeed reflecting the safety critical concerns of ua v systems x iii .
dynamically we perform a differential simulation to illustrate the impact of bf uses on ua v behavior.
we find bf uses and their lack of use do have impact on the dynamic trace of safety critical values of the ua v from trajectory to pose and hence cyberphysical behavior of the ua v x iv .
we now elaborate these two contributions in more detail.
b. a datatype based taxonomy a novelty of our empirical study is that we classify the use of bfs based on the datatype of the bvs they intend to bound.
in ua v software a large number of values have primitive types such as int orfloat.
a key insight gained in our exploration is that the bvs fall into a small set of wellknown ua v parameters reflecting their cyber physical nature which we call physical variables.
for example we find a large number of float type variables representing the pose parameters that define the orientation of a ua v the pitch the roll and the yaw.
in other words these variables carry higher level semantics more than a floating point number.
this insight recalls the classic programming abstraction of abstract data type adt the float value above indeed logically encapsulates the floating number and a specification on what a pitch or roll or yaw parameter of a ua v should conform to.
in this study we classify our bf instances based on the logical datatypes of their corresponding bvs as follows trajectory management tm bf instances that provide safe navigation to the ua v mainly bounding physical variables such as position distance and heading.
sensor management sm bf instances that provide valid sensor readings bounding physical variables directly related to sensor values.
speed and acceleration management sam bf instances that ensure safe speed andacceleration to engine bounding these two physical variables.
engine management em bf instances that provide safety to the engine by bounding physical variables thethrust andthrottle of the engine.
pose management pm bf instances that maintain safety for ua v orientation.
these bf instances mainly bound physical variables pitch roll yaw of the ua v .
within each class we perform an in depth analysis on how bfs are used in paparazzi defined as use scenarios.
taken the view of adts each use scenario can be viewed as a specification in the form of a bf of that datatype.
overall our novel datatype based taxonomy can be summarized as notall floating point values or integers are created equal.
by refining them into datatypes their logical role in ua v software starts to emerge.
as it turns out except bf instances used for defining generic algorithms such as control and geometry the remaining bf instances allfall into the categories above.
in other words despite the large code base of ua v software and despite the numerous instances of bfs ua v developers concentrate their efforts of performing dynamic checks on a small set of physical variables.
this cannot be accidental it is a conscious reminder that this small set of physical variables are likely to play a pivotal role in defining what being safetycritical means for ua v systems.
c. a differential simulation to cross validate whether our discovered bfs indeed have an impact on the correctness of ua v behavior we perform a fine grained simulation on the impact of bfs.
we adopt a differential approach for each instance of bf use we perform one simulation over the original paparazzi program and the other over the same program except that the bf is removed.
at its core our approach can be viewed as a form of a b testing.
the interesting design question lies in how difference is defined.
our approach relies on analyzing the difference over the traces of physical variables such as position traces trajectories pose traces and speed traces.
this approach black box in essence is aligned with our intuition on the safety of ua v systems if the ua v behaviors with the bf and without the bf are observably different through the lens of physics then the bf is likely impacting the safety of the ua v .
d. research questions and results in this paper we report the first empirical study on the bounding function uses in ua v software.
it complements existing top down approaches with a bottom up perspective focusing on answering two research questions rq1 can the bf instances be classified to logically reflect the use of safety critical physical variables?
rq2 do bfs have impact on the dynamic cyber physical behavior of ua v software?
we identified bf instances through analyzing paparazzi s source files in autopilot software modules.
we grouped instances related to physical variables into the categories described earlier most relevant to the safety of ua vs. our dynamic differential analysis reveals that numerous bfs have observable impact on the trace of physical variables.
more specifically out of simulatable cases show difference in flight trajectory pose etc.
this provides experimental justification for our bf based approach the use of bfs coincides with safety critical behavior of ua vs. while conducting the trace based analysis we also uncovered a bug in paparazzi whose fix has been accepted.
broadly and philosophically our study is a quest for answers on what makes ua v software safety critical.
the top down approach taken by verification frameworks and tools defines safety as a priori properties or invariants.
to do so one needs 1312to resort to domain experts to come up with the definitions of these properties or invariants first.
our bottom up developerin the field approach identifies the use of bfs with a call for attention from developers and the deviation in the dynamic traces of physical variables with a cause of safety concern as the developer s program says so.
overall our approach and the existing approach complement each other our approach discovers candidate invariants related to safety but some may be deemed not by an oracle domain expert whereas the existing approach focuses on invariants agreed upon a priori but they may be incomplete in the eyes of the oracle domain expert .
the two approaches together converge on revealing the elusive essence of safety in ua v software.
overall this paper makes the following contributions the first developer in the field empirical study on the safety critical components of ua v software based on bounding functions a datatype based taxonomy on bounding function uses focusing on physical variables a systematical differential analysis on the impact of bfs in ua v behavior through comparing and aligning traces of physical variables a tool pbf detector paparazzi bounding function detector for automatically identifying bf instances in a real world code base with complex compilation schemes decentralized compilation with makefiles mixed with pre processing code generation ii.
a p rimer on uav f light control the most widely known ua vs fall into two categories fixed wing aircraft and rotary wing aircraft.
fixed wing aircraft are featured with special shaped wings that can make use of forward airspeed to generate lift while rotarywing aircraft also referred to as rotorcraft use rotating wings called blades to fly .
a. engine and pose the driving force produced by the engine is commonly referred to as thrust orthrottle.
engine management is directly associated with the speed and the acceleration of the ua v .
ua vs are rigid bodies operating in d space.
therefore their position can be represented by three numbers x y z in a d coordinate system.
similarly their pose orientation is represented by three angles also known as euler angles in the d coordinate system.
these angles are roll pitch and yaw.
the pose is also referred as the attitude.
an illustration of the three angles can be found in figure .
fixed wing aircraft vary their attitude by utilizing flight control surfaces.
rotorcraft vary the attitude by varying the rotational speeds of the motors spinning in opposite directions.
b. navigation navigating a ua v is usually split into two steps path planning and trajectory planning.
path planning is the step of taking the objectives of a fight task.
path planning is usually fig.
a visualization of ua v control left attitude angles center their application on a fixed wing aircraft right their application on a quadrotor application dependent written in the form of flight plans in paparazzi.
for example a typical flight plan may include a stepby step description of take off a circle navigation task and then landing.
the flight plan is translated into a trajectory.
the trajectory is defined through a series of waypoints positions in the d space with the z axis representing altitude.
trajectory planning takes the next waypoint to be visited and plans a thrust and pose to set the ua v to reach that waypoint.
given the required thrust and pose the flight controller controls the actuators such as engines to achieve that thrust and pose.
while in motion the ua v points to a direction which is called heading.
a related concept is the course the direction that the ua v moves toward.
due to conditions such as wind heading and course are not always the same.
c. paparazzi flight controller software paparazzi ua v software suite is a collection of modules capable of flying on a variety of ua vs. it is highly configurable with various airframes large suite of sensors several controller algorithms as well as the ability to use the controller software in simulation and on real hardware.
the autopilot software is capable of integrating with several sensors such as gps inertial measurement unit imu sonar and barometer.
sensor values are fed into the inertial navigation system ins that estimates position speed and acceleration of the ua v .
similarly the attitude and heading reference system ahrs performs attitude estimation.
together the ins and the ahrs help the flight controller keep an estimate of the state of the ua v .
this state is then used to control the ua v through the guidance and stabilization modules.
as is the case for all aerodynamic systems control theoretic algorithms are widely used to provide feedback control in ua vs stability management and autonomous control.
two popular algorithms used by paparazzi are proportional integral derivative pid control and incremental nonlinear dynamic inversion indi .
iii.
u nderstanding bounding functions statically in this section we describe our effort in understanding bf uses in paparazzi through a detailed analysis on the source code providing answers to rq1.
the centerpiece of this study is a taxonomy that classifies bf uses based on the physical variables they are applied to in xiii c. before we detail this 1313table i bounding functions in paparazzi bound forms function names double ended bounds bound boundinverted boundwrapped vect3 bound cube vect3 bound box eulers bound cube rates bound cube rates bound box clip absolute bounds boundabs rates bound box abs deadband clipabs upper bounds boundupper normalization float angle normalize int32 angle normalize int32 course normalize normradangle special bounds saturate speed trim accel result we start with a description of our taxonomy rationale inxiii a and methodology in xiii b. a. the rationale of classification ua vs are cyber physical systems that interact with the physical world.
their safety is defined with respect to this interaction i.e.
their behavior in the physical world.
our classification of bfs is based on this observation and thus derived from the datatypes of physical variables associated with the bfs.
our five category taxonomy corresponds to the main functionalities of the ua v that define or impact interaction with the physical world.
by organizing bf uses in this manner we believe that this study will be useful for future ua v control software as they will still need to fundamentally interact with the physical world in the same manner they will need to navigate trajectory control their navigation speed and acceleration understand their surroundings sensors understand their orientation with respect to their surroundings pose and manage their locomotion motors .
as our study shows the vast majority of bfs in paparazzi revolve around these five types of physical variables.
this cannot be accidental these five types of cyber physical interactions are essential to the nature of ua v software.
b. methodology a bf identification we have developed a compiler pass implemented as a clang plugin2 to identify bf instances in the paparazzi code base.
our plugin defines a baseline framework pbf detector for future research with advanced program analysis and optimization.
our analysis focuses on paparazzi s autopilot software modules in the sw airborne directory version v5.
.0stable.
for our goal of identifying bfs paparazzi presents a unique advantage a set of pre defined bfs in the forms of c macros used by paparazzi developers.
our study focuses on the use of these macros in total as listed in table i. these macros are manually identified by inspecting all .h files and a macro qualifies if it bounds a variable within a given range.
some bfs are general such as bound while others are more specific.
our clang plugin parses c files to identify the forms of bfs in the ast.
one technical hurdle is that macros are expanded in clang before the ast is generated.
to address this we have redefined corresponding c functions to the macros in table i. the paparazzi source remains unchanged with a small number of exceptions that we documented at our project website see url in xvii .
b makefile aware identification a significant engineering challenge in analyzing paparazzi s code base results from the complex compilation process inherent in paparazzi.
unlike high level applications where the compilation process is often a one off process that reaches all files in all folders embedded system software like paparazzi must consider diverse configurations with complex customization and platformdependent cross compilation.
paparazzi adopts a hierarchical compilation with c makefiles distributed at various levels of the paparazzi directories and the dependencies between makefile targets are complex.
to further complicate the matter many programs are generated on the fly during the compilation process with generators written in ocaml and python.
our compiler pass is makefile aware we modified the decentralized makefiles and as a result pbf detector can faithfully follow the same dependencies as in compilation.
this not only allows us to reach all source code that can be reached by paparazzi compilation but also reach it in a semantic aware manner every name on the ast of every reachable file must have been defined because the program compiles!
.
the pbf detector modification to handle hierarchical makefiles in our compiler analysis was labor intensive but it is rewarding for building a toolchain for paparazzi to integrate with clang llvm.
c bf selection in total we identified instances of bfs from autopilot program modules spanning files in 331k loc of paparazzi source code.
we further crossvalidated the number of instances through a text based search.
among them our study excludes instances not directly related to the safety of ua v software which fall into categories a bf instances in core control algorithms pid indi .
these bf instances are part of the algorithm design such as pid and indi they are generic in nature and do not vary from a ua v implementation to a non ua v implementation.
as a standard robotics problem bounding and tuning generic control parameters is an independent and well studied problem .
it should be made clear that we only leave out generic control algorithm bf uses here if a physical variable say the roll value of the ua v relies on the pid control and is bounded while interacting with the pid it isincluded in our study.
b bf instances used for geometric transformation.
these bfs occur as parts of the trigonometry based algorithms solely related to geometry.
for example a common use is to normalize an angle within the range of .
c bf instances in vision image processing algorithms and instance used for the remote control switch.
for instance bfs frequently occur for managing auto white balance image refinement sub pixel resolution and auto exposure.
for any vision bf instances that impact control algorithms e.g.
opticflow based landing we have included them into our study.
overall our guiding principle here is to conservatively leave out bf instances unrelated to the safety critical nature of ua v software and when in doubt an instance is included in our study.
we have documented every bf instance for cross reference including those we left out in the study on our project website.
there are two take away messages from our bf selection process.
on one hand it shows some bf instances are not aligned with our intuition of safety critical concerns.
in that sense these instances are the false positives to the premise of our empirical study.
on the other hand the more striking observation is that once the well carved categories of a b c bf instances are removed every remaining instance fits nicely with one of categories intimately linked to the safety of ua vs as we shall see next.
c. a taxonomy of bounding function uses for the remaining bf instances we conducted an indepth manual inspection understanding the functionality of the program fragment each appears and the purpose of each bf.
as it turns out all fit nicely into the category taxonomy which we present in table ii.
in this table observe that we further refine each category into a number of use scenarios.
if each category is intuitively viewed as an adt each use scenario serves as a specified behavior of that adt.
in the rest of this section we focus on trajectory management and sensor management as examples to demonstrate our approach.
a description of all categories with the same level of detail can be found in a technical report at our project website.
trajectory management to follow a trajectory the ua v needs to follow waypoints including turning occasionally in the horizontal direction and changing altitude in the vertical direction .
the physical variables related to trajectory management are distance andheading change .
we identified instances of bfs applied for trajectory management which we divided into use scenarios.
a safe homing a use context after performing the flight task the ua v should go back to the ground station.
b datatype distance x and y axis .
c the need for bfs to avoid catastrophic consequences due to battery drain a ua v generally should not fly too far way from the ground station.
d example in this code snippet the distance between the ua v waypoint and the home waypoint is computed and bounded by variable max dist from home the maximum distance between them.
e occurrence instances.
b safe altitude change a use context ua v systems fly in a d space altitude change is a basic task.
b datatype distance z axis .
c the need for bfs a drastic change in altitude may affect the stability of the ua v .
d example intable ii classification of bounding function uses categoryuse scenario datatype occurrence tm safe leg distance in guidancedistance x and y axis safe heading change heading change safe homing distance x and y axis safe altitude change distance z axis sm safe sensor fusion weight for sensor fusion6 safe sensor reading intervaltime interval safe sensor readings sensor reading sam safe acceleration request as engine inputacceleration safe acceleration for navigationacceleration safe remote user speed inputspeed safe wind speed speed em safe motor mixing thrust throttle safe landing thrust throttle safe motor speed changerpm collision avoidance thrust throttle pm safe pose change ratepitch roll yaw safe pose maintenance pitch roll yaw safe pose change time intervalpitch roll yaw change time interval2 safe turn coordination roll fig.
carrot based guidance for heading change this code snippet the altitude change between two iterations of the control loop is bounded by gv max z diff the maximum distance between the previous waypoint and the current waypoint on the z axis.
e occurrence instance.
c safe heading change in guidance a use context paparazzi follows the widely used carrot based approach for trajectory management a virtual continuously updated waypoint not far from the current position of the ua v to guide the next leg of movement of the ua v similar to using a carrot to attract a mule to move forward.
as shown in figure the carrot based guidance implemented by paparazzi for circle navigation assumes a constant distance between the current position of the ua v and the carrot as carrot dist.
by 1315adjusting the carrot angle the ua v may change its heading.
b datatype heading change .
c the need for bfs a drastic change in heading may affect the stability of the ua v and affects the correctness of the circle trajectory.
d example in listing which concerns circle navigation thecarrot angle is bounded to the range of .
the rest of the variables are illustrated in figure .
e occurrence instances.
1void nav circle struct enucoor i wp center int32 t radius ... direction of rotation int8 t sign radius radius ?
absolute radius int32 t abs radius abs radius carrot angle int32 t carrot angle carrot dist int32 angle frac abs radius bound carrot angle int32 angle pi int32 angle pi 4 carrot angle nav circle qdr sign radius carrot angle ... listing safe heading change in guidance d safe leg distance in guidance a use context for linear trajectories that do not involve heading change paparazzi also uses carrot based guidance.
in this setting the distance between the starting point of the leg and the carrot which is called leg distance is dynamically adjusted.
b datatype distance x and y axis .
c the need for bfs if the leg distance is set too long the ua v may go past the waypoint of the target point.
deviating from the planned trajectory is a correctness concern.
d example in this code snippet which concerns route i.e.
linear navigation thenav leg progress is bounded to guarantee that the next leg of flight does not surpass the target waypoint.
e occurrence instances.
sensor management as important components of a ua v sensors play an irreplaceable role in ua v s state estimation e.g.
ua v s current attitude pitch roll yaw .
an accurate estimation based on sensor data is also critical for ua v safety.
the physical variables related to sensor management aresensor readings the time interval among readings and theweight when multiple sensor readings are weighted.
we identified instances of bfs applied for sensor management which we divide into use scenarios.
a safe sensor readings a use context the raw sensing data may be unreliable either because the sensor is faulty or because the reading may only reflect a transient state.
b datatype sensor reading.
c the need for bfs the need for bounding is sensor specific.
take the current sensor for example.
due to overflow on high current spikes fast electrical transients in current the reading may be magnitudes higher than normal readings.
this would impact battery estimation crucial for estimating the remaining flight time.
d example in this code snippet the current sensor keeps its readingsinelectrical.current which is in turn bounded to a safe range .
e occurrence instance.
b safe sensor reading interval a use context in ua vs sensors are continuously reading.
in some scenarios the time interval between different readings plays a crucial role in physical estimation.
for example as an application of kalman filter the ua v can use data from gps and barometer at different time intervals to estimate its vertical position and velocity.
b datatype time interval.
c the need for bfs if there is a significant delay between two intervals the estimation may be inaccurate which in turn severely impacts the decision making process of the ua v .
d example in this code snippet the variable dtrepresents the time interval between two gps readings.
it is bounded into the range seconds.
the variable is used by kalman filter alt kalman for the estimation of the ua v s altitude and vertical speed.
e occurrence instance.
c safe sensor fusion a use context complementary filter combines sensor readings from the accelerometer and the gyroscope to estimate ua v attitude pitch roll yaw .
b datatype weight for sensor fusion c the need for bfs to ensure that data collected from both sensors are considered adequately their proportions in attitude estimation need bounding in order to reach a balance between these two components.
d example in listing ahrs fc.weight computed at line reflects the role of accelerometer plays in attitude estimation which is influenced by fabs .
g meas norm the deviation between the measured gravitational acceleration and 1g.
in the case of vibrations large deviations from 1g may cause a decrement of the weight for the accelerometer data if bound is not introduced ultimately causing the attitude estimate to drift .
attitude estimation is critical for the safety of ua vs. in the aviation history a catastrophe with the same root cause is lion air flight which was caused by incorrect angle of attack sensing and consequent activation of the anti stall software to repeatedly pitch the plane downward .
e occurrence instances.
1void ahrs fc update accel struct floatvect3 accel float dt ... compute ratio between measured gravitational acceleration and the standard value const float g meas norm float vect3 norm filtered gravity measurement .
compute the weight of accelerometer in attitude estimation ahrs fc.weight .
ahrs fc.gravity heuristic factor fabs .
g meas norm .
bound ahrs fc.weight .
.
... listing an example of sensor fusion 1316iv.
u nderstanding bounding functions dynamically in this section we experimentally evaluate the impact of bfs on ua v behavior answering rq2.
we start with a description of our rationale in xiv a and on experiment setup inxiv b and the core results from differential simulation will be described in the rest of the section with a summary and several more detailed case studies.
a. the rationale of differential simulation as we stated earlier ua vs are cyber physical systems that interact with the physical world.
in ua v software the traces of ua v physical properties pitch roll yaw trajectory or altitude as time series are essential for capturing their observable behavior.
when the removal of bfs leads to observable difference in the trace of these physical variables it should be a concern for attention.
our differential simulation aims at achieving two goals.
first it helps confirm that the bf instances indeed impact the dynamic physical behavior of ua vs. a premise with the developer in the field approach is that we trust the experience and wisdom of the developers.
from the perspective the dynamic approach here serves as the trust but verify step we would like to confirm bfs do make a difference in defining the physical behavior of ua vs. with that answers to rq2 serve as an evidence of the significance of our taxonomy proposed for rq1.
second the dynamic approach also serves as a quantitative study of the safety critical impact of bfs.
it complements the qualitative study of our static taxonomy approach by answering how much impact bfs have on the safety of ua v software.
b. experiment setup we use paparazzi s built in simulator for recording flight trajectories.
we further use paparazzi s log plotter to generate traces on real time physical variables such as speed altitude and roll pitch yaw values.
the two complement each other with the former useful for elucidating macro level navigation patterns and the latter useful for characterizing micro level time dependent physical behavior.
among the bf instances we are able to conduct simulation for of them.
some programs with bf instances require manual radio control rc inputs.
we have developed a script to ensure rc inputs are programmably given so that for repetitions of the same experiment identical rc commands with identical timing are inputed.
the not simulatable cases fall into two categories.
first the compilation and execution of some program fragments are hardware dependent such as requiring camera or sensor support.
the paparazzi simulator does support physical simulation but it does not include features such as optical flow for cameras and some low level sensors.
second some code fragments where bfs occur are experimental features that cannot be built with any compatible aircraft.
for example no existing aircraft in paparazzi is compatible with the module stabilization float euler so we cannot simulate any bf instances in that module.table iii simulation result summary s diff single bf simulation different results m diff multi bf simulation different results same no difference in results non sim not simulatable category s diff m diff same non sim total tm sm sam em pm table iv selected differential analysis bf instances label file name bf line number a ahrs float cmpl b common nav c nav gls d nav gls e nav smooth f attitude refsaturate naive multi bf g guidance href multi bf for each simulatable bf instance we perform two experiments a simulation of the autopilot with a pre defined flight plan seexii b where the code with the bf instance is called a simulation with the same flight plan with the bf is removed.
we compute whether the traces from the two experiments are different where difference is defined as the relative error in the trace values of physical variables roll pitch yaw thrust etc.
from the two simulations above.
we repeat each pair of simulations times.
the data across the runs are averaged out with respect to timestamps.
it is noteworthy that when there is more than one bf instance in the same function removing one may have no impact on the trajectory or physical variable traces but removing multiple can.
from now on we refer to the experiments that involve the removal of multiple bfs in the same function at the same time as multi bf differential simulation and refer to the one bf a time experiments as single bf differential simulation.
multi bf differential simulation is performed when single bf differential simulation for each bf in a function does not show any difference.
c. result summary the results from the experiments fall into categories which we summarize in table iii.
if our simulation shows difference in a single bf differential simulation we classify the involved instance as s diff .
otherwise if difference is shown in a multi bf differential simulation we classify the involved instances as m diff .
the rest of simulatable instances are classified as same and non simulatable instances are classified as non sim .
there is no overlap between the categories.
for repeated experiments we only mark an instance as different when repeated experiments all show a difference exists in physical simulation small variations a b c d e f g h fig.
relative errors in differential analysis each sub figure represents a distinct physical variable.
each bar represents a bf case whose height is the mean and the range line is the standard deviation.
the label to the left of each bar indicates a bf instance whose details are described in table iv.
data is presented in log scale where implies relative error.
a b c d e f g h fig.
pearson s correlation coefficients pccs in differential analysis each sub figure represents a distinct physical variable.
each bar represents a bf case whose height is the pcc.
the label at the bottom indicates a bf instance whose details are described in table iv.
a pcc value over .
empirically indicates strong correlation.
are common so we wish to be conservative to make sure all repeated experiments agree.
as we can see in the s diff and m diff columns nearly half of the instances we can simulate produce different results when comparing executions with or without bfs.
in other words the bfs indeed play an important role in safeguarding the correctness of programs and consequently the safety of ua vs. in our differential analysis we compute the averaged relative error between the measured physical variable value of the program with the bf and the one without.
we elide yawdata for brevity.
figure shows the result for a subset of bf instances whose details can be found in table iv.
the complete results are included in the repository.
three concrete observations can be made.
first bfs have non equal impacts on physical variables.
for example we can observe that bf cases a b and ghave large impacts on the majority of physical variables whereas bf case ehas a minor impact on nearly all variables.
second the same bf instance may have different impacts on different physical variables.
for example bf case ahas a larger impact on the z axis of positioning altitude see fig.
3c than the y axis see fig.
3b .
as another example the relative error of bf case gstands out in trajectory related physical variables see fig.
3d for example than speed related variables.
third the same physical variable may be impacted by different bf instances in different degrees.
for example speed is significantly impacted by bf cases a andb but not others see fig.
3g .
to gain a finer grained analysis we further computed the similarity of the two traces in a timestamp wise manner.
figure shows the pearson s correlation coefficients pccs of the with bf and without bf traces.
the most important observation is that pcc is rarely over .
the golden standard for strong correlation.
in other words without bfs a program would cause noticeable behavioral change to the ua v in a large number of bf instances as manifested through location or pose or speed.
take bf case efor example.
recall that in the earlier relative error figure this bf has a small relative error the pcc results however tell a different story a timestampwise alignment of traces is poor for the majority of physical variables especially altitude pitch row and speed on the x y dimensions.
in this example the bf is used to bound the physical variable of ground speed.
with its removal the ua v not only has significant ground speed fluctuation but also leads to functuations in other physical variables.
the difference between relative error and pcc as metrics is that the latter is time dependent.
as a result pcc can capture behavior differences in the presence of time dependent fluctuation despite the mean remains stable a goal the relative error cannot achieve.
together these experiments show that bfs do significantly impact ua v behavior.
as physical variables play a pivotal role in safety critical ua v behavior from trajectory management to pose management and so on our experiments demonstrate the importance of bfs in safety critical ua v software.
in the rest of this section we highlight bf instances and their impact on preserving the ua v behavior.
d. case study turning angles inxiii c1c we discussed the bounded variable carrot angle bounded within the range in function nav circle which is used by paparazzi to perform a circle task.
with the safeguard of the bounding function the ua v circles around normally as is shown in figure 5a where the red actual trajectory fits nicely with the green desired trajectory.
however if we remove the bounding function as is shown in figure 5b the trajectory is irregular at the beginning and later follows a stable oval orbit.
this deviation stems from the drastic angle variation carrot angle.
e. case study takeoff speed as an example of multi bf differential simulation listing shows a code snippet where removing only one bf does not make a difference while removing both does.
in this example sprepresents the vertical speed setpoint computed by the pid algorithm and incr represents its deviation from the a b fig.
a case study on turning angles a with bf trajectory b without bf trajectory fig.
multi bf differential simulation on takeoff speed current speed setpoint v ctl climb setpoint.
incr is added to v ctl climb setpoint in the end.
if we only remove the bf on line the excessive value would be bounded on line .
similarly if we remove the latter since the former has already bounded sp the following incr is thus not likely to be excessive.
however when we remove both v ctl climb setpoint can grow by a sharp increment.
1void v ctl altitude loop void ... float sp v ctl altitude pgain v ctl altitude error v ctl altitude pre climb boundabs sp v ctl max climb float incr sp v ctl climb setpoint boundabs incr dt navigation v ctl climb setpoint incr listing a multi bf simulation example figure shows the ua v speed when taking off based on the ua v s flight logs.
the solid lines show the speed when both bfs are kept while the dashed line show the speed when both are removed.
in the first seconds the without bf runs named as abnormal in the figure reach a higher speed during take off observe that the dashed lines show a higher speed than those of the solid lines.
this agrees with our source code inspection above.
f .
case study navigation progress inxiii c1d we discussed another bounded variable nav leg progress in function nav route and this 1319variable reflects the navigation progress which is bounded within the range .
as is shown in figure 7a an oval trajectory consists of two straight lines and two semicircles.
the function nav route is called in the navigation task on both straight lines.
if we remove the bf from variable nav leg progress the ua v may flee and move in the opposite direction when approaching the waypoint where the straight routine begins as is shown in figure 7b.
the more intriguing question is why the ua v would change its behavior as radically as this.
let us have a close look at the source code on how nav leg progress is computed nav leg progress pos diff.x wp diff.x pos diff.y wp diff.y nav leg length here wp diff andpos diff are two dimensional variables representing the horizontal distance between two waypoints p1andp2 as shown in the figure and between the ua v and the start waypoint p1respectively.
the types of their members xandyare both signed integers.
however since nav leg length is an unsigned integer the result computed within the parentheses must be implicitly converted to unsigned integer before divided by nav leg length.
when the ua v is approaching the waypoint p1 the result computed within the parentheses happens to be a negative value whose most significant bit is set to and thus it is interpreted as a large value after conversion to the unsigned integer.
after being divided by nav leg length the most significant bit becomes and therefore when the final result is converted back to the signed integer and assigned tonav leg progress it is still a large positive value which goes far beyond the range .
it further impacts the computation of the position of navigation target and consequently the ua v flees eccentrically.
with a bf in place nav leg progress is at least bounded within a range so that a radically unexpected trajectory such as figure 7b does not occur.
however note that always adjusting its value to the upper bound prog 2 is not reasonable either the variable should not have shown a completed progress before straight navigation begins.
in other words the program contains a bug.
to help fix this bug we added an explicit type conversion for nav leg length nav leg progress pos diff.x wp diff.x pos diff.y wp diff.y int32 t nav leg length after this bug fix we repeated our simulation without the bf.
as is shown in figure 7c the oval trajectory is preserved.
however as is analyzed in our discussion in xiii c1d the carrot namely the navigation target denoted as a yellow inverted triangle in the figure exceeds the intended trajectory without the bf.
this case study is interesting for two reasons.
first the use of the bf indeed reflects the developer s concern that an unbounded variable may significantly alter the ua v behavior.second the developer appears to be unaware of the latent bug the bf use somewhat masks the severity of the bug.
observe however it is the use of the bf that led our attention to this code snippet and it is the simulation of bf removal that helps us uncover the bug.
we reported this bug to paparazzi and our bug fix has been accepted.
the updated code has now been merged into paparazzi s github repository.
v. t hreats to validity our analysis is empirical in nature.
we based our analysis on the bfs injected by the paparazzi developers.
we assume the correct amount of functions is leveraged to achieve safetycriticality.
in this sense a fundamental limitation of our approach is that it may only be as good as the programming skills of the developers.
in reality developers may miss bfs and may make mistakes.
incompleteness in enumerating all safety critical scenarios is inherent to our approach.
ua vs and embedded systems in general are real time systems driven by their onboard sensors.
as such achieving simulations that faithfully cover all flight scenarios is challenging.
our simulation environment can replay navigation commands and replay at a specific rate.
however due to timing of the control software perfect reproducibility is impossible.
paparazzi is an influential ua v framework but not the only one.
we believe the taxonomy of safety critical use scenarios and the methodology of our differential analysis may transcend the specifics of paparazzi but the concrete findings of our study such as the number of use scenarios within each caregory and the dynamic impact of individual cases may not be representative for all ua v frameworks.
vi.
r elated work verification for safety critical software is a well established area and perhaps the best example of the top down approach for studying safety of ua v systems.
blanchet et al.
propose a static analyzer based on abstract interpretation to verify a large class of properties in safety critical software.
miller et al.
apply nusmv a symbolic model checker to the verification of a flight control system.
kloetzer and belta provide a fully automated framework to develop feedback controllers for a linear system given its linear temporal logic over a set of linear predicates in its state variables.
kressgazit et al.
propose a linear temporal logic ltl based framework to automatically generate a hybrid controller that guarantees correct robot function given a high level task specification as well as a class of admissible environments.
yoo et al.
introduce a formal methods based process that supports development verification and safety analysis for the nuclear power plant s reactor protection system and develop computer aided software engineering case tools for nuclear engineers to apply formal methods to safety verification.
similarly runtime verification of ua v software is also an actively researched topic.
moosbrugger et al.
develop a real time realizable responsible unobtrusive unit r2u2 to monitor security properties and diagnose security threats of unmanned aerial systems uas during run time.
its a b c fig.
a case study on navigation progress a with bf trajectory original b without bf trajectory original ua v flees c without bf trajectory fixed carrot off supervision scope covers the on board components as well as inputs from the ground control station.
software engineering for self adaptive cyber physical systems is an active research direction where ua vs are often cited as a compelling use scenario .
testing cyber physical systems e.g.
and development tools e.g.
is well explored.
another family of selfadaptive systems that have received attention in recent years is autonomous self driving vehicles with results on bug characterization e.g.
and testing e.g.
.
programming languages are proposed for supporting energy awareness of ua vs and context adaptation for ua vs .
copilot is a stream based dataflow language to perform hard real time monitoring over safety critical control systems by sampling variables in programs and computing properties over the sampled values.
safetyscrum is a software development methodology that relies on a notion of safety debt to incrementally track the safety status of safety critical ua v systems in agile software development and maintenance.
broadly speaking our datatype based classification can be related to programming language efforts that refine primitive types.
for example dimension types are designed so that value can either mean one meter or one kilometer and misuse among them can be eliminated by the type system.
as another example osprey is a constraint based type inference to automatically detect misuse of measurement units.
fundamental to the growth of ua vs is their ability to fly autonomously and not require human control at all times.
most modern ua vs from high end fixed wing aircraft to hobby quadcopters come equipped with flight controllers such as in pixhawk .
these systems use well studied algorithms such as extended kalman filter estimation to fuse the sensor values into a pose and well studied controllers to achieve the set commands.
vii.
c oncluding remarks this paper describes a novel empirical study on the use of bounding functions in ua v autopilot software.
our study shows that the use of bounding functions coincides with use scenarios where safety concerns of ua vs are addressed by ua v software developers.
our differential simulation further shows that bounding functions play an important role inpreserving the physical behavior of ua vs. to the best of our knowledge this is the first systematic empirical in field study on open source ua v software frameworks.
beneficiaries we envision our empirical study will be beneficial in the following ways.
for uav software developers our empirical study may serve as a reference point for systematically addressing safety concerns in future ua v development.
ua vs are well known for their diverse hardware platforms but the key safety critical datatypes identified by this paper are likely to transcend the specifics of diverse platforms of ua vs. we show that despite the large code base the bf instances revolve around a small set of physical variables which future developers should pay particular attention to.
for framework and language designers our datatype based taxonomy may inspire new abstractions to generalize modularize and reason about ua v software systems with the identified datatypes and their associated use scenarios serving as motivations for new language based designs such as automated bf placement and enforcement.
for researchers interested in automated analysis for ua v software e.g.
through testing debugging and verification our identified bfs and their differential simulation serve as a source for identifying new invariants and as a litmus test on validating the coverage of their approaches.
in addition pbf detector can serve as a base system to facilitate clang llvm based development.
artifacts in the repository3 we provide the following artifacts a the source code of pbf detector together with modified paparazzi source makefiles b a detailed documentation on each bf use c all data of the simulation results including log data simulation screenshots along with aircraft and flight plan files as test cases d scripts for statistical analysis and for reproducing the results e a report of the complete bf taxonomy.