co dependenceawarefuzzing for dataflow basedbigdata analytics ahmad humayun ahmad35 vt.edu virginia tech blacksburg virginia usamiryungkim miryung cs.ucla.edu university ofcalifornia losangeles losangeles california usamuhammad ali gulzar gulzar cs.vt.edu virginia tech blacksburg virginia usa abstract data intensive scalable computing hasbecomepopular due tothe increasing demands of analyzing big data.
for example apache spark and hadoop allow developers to write dataflow based applications with user defined functions to process data with custom logic.testingsuchapplicationsisdifficult.
theseapplications often take multiple datasets as input.
unlike in sql there is no explicit schema for these datasets and each unstructured or semi structured dataset is segmented and parsed at runtime.
dataflow operators e.g.
join create implicit co dependence constraints between the fields of multiple datasets.
an efficient and effective testing technique must analyze co dependence among differentregionsofmultipledatasetsatthelevelofrowsandcolumns andorchestrate inputmutationsjointly on co dependent regions.
wepropose depfuzz toincreasetheeffectivenessandefficiency offuzztestingdataflow basedbigdataapplications.thekeyinsight behinddepfuzz is twofold.
it keeps track of which code segments operate on which datasets which rows and which columns.
by analyzingtheuseofdataflowoperators e.g.
joinandgroupbykey intandemwiththesemanticsofudfs depfuzz generatestestdata that subsequentlyreachhard to reachregionsof the application code.
in real world big data applications depfuzz finds .
more faults achieving29 morestatementcoverageinhalfthetimeas jazzer s a state of the art commercial fuzzer forjava bytecode.
it outperforms prior disctestingby exposingdeepersemantic faults beyondsimplerinputformattingerrors especiallywhenmultiple datasets have complex interactionsthroughdataflowoperators.
ccsconcepts softwareanditsengineering softwaretestinganddebugging.
keywords testing fuzzing dataanalytics provenance taint analysis acm reference format ahmad humayun miryung kim and muhammad ali gulzar.
.
codependence aware fuzzing for dataflow based big data analytics.
in proceedings of the 31st acm joint european software engineering conference andsymposiumonthefoundationsofsoftwareengineering esec fse esec fse december san francisco ca usa copyright heldby theowner author s .
acm isbn .
san francisco ca usa.
acm new york ny usa 12pages.
introduction data intensive scalable computing disc applications have becomeaprevalentwaytoprocesslarge scaledata.discframeworks likehadoopmapreduce andapachespark offerapisthat contain dataflow operators such as map join andgroupbykey for parallel data processing across thousands of machines.
a typical disc application builds on a series of dataflow operators in conjunction with user defined functions udfs that are passed as argumentstothedataflowoperators.despitethewidespreadusage of disc applications testing remains difficult due to their large inputsize andthe applications complex interactions with data.
fuzzing is an effective software testing approach for many complex programs .
fuzzers make small perturbations mutations to inputs to increase the likelihood of exercising uncovered application logic.
such traditional fuzzing maytakealongtimetogeneratemeaningfulinputsfordiscapplications because a large input data has too many locations to mutate.
therefore it is necessary to identify which rows and columns areworthwhiletomutatewhenafuzzerattemptstoreachanew codelocation.naivemutationscannotsatisfycomplexinputconstraintsfrommixingdataflowoperatorsanduser definedfunctions.
forinstance joinconcatenatesrowsfromtwodatasetsthathave matching values in designated keycolumns.
this introduces an implicit equality constraint between the fields of multiple datasets.
consequently to exercise code inside the udf func1ofmapin the code snippet dataset1.join dataset2 .map func1 input mutationsmustsimultaneouslyoperateonbothdatasets dataset1 anddataset2 toobservetheco dependenceconstraint i.e.
there mustexistarowin dataset1 withthesamekeyasthe dataset2 s firstcolumninorderfor jointoproduceanydataonwhich mapcan applyfunc1.mutationsusedinfuzztestingtodayfailtoaccount for suchco dependence and thus may not exercise application logic beyondjoin.this problemis furtherexacerbatedbecause unlike sql there is no explicitly defined schema to identify columns and the inputs for disc applications are usually parsedon the fly.
wepropose depfuzz afuzzerthatperforms co dependenceaware rowselectionandcolumnmutationwhileensuringthatconstraints amongmultipledatasets areobserved.
depfuzz combinesrow level andcolumn leveldatatrackingviataintanalysis.inotherwords it identifieswhichrowsandwhichcolumnsfromwhichdatasetare operatedbyindividuallinesofapplicationcode.thisknowledgeof row levelprovenancehelpsreducedatasizeforsubsequentfuzzing iterations as depfuzz retainsonlyselectedrowsandmutatesthem thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse december3 san francisco ca usa ahmad humayun miryungkim andmuhammadaligulzar map map join map map join map join mapvalairports and coords airports .map .
.
.
valaflights and coords flights .map .
.
.
.join airports and coords .map .
.
.
valflights and distances flights .map .
.
.
.join airports and coords .map .
.
.
.join aflights and coords .map .
.
.
.collect defdist dep tuple arr tuple float .
.
.
fault should be a instead of .
a valc math.atan2 math.sqrt a math.sqrt .
a .
c .
.tofloat32556 pg0371 kro dme arrived pg0240 hma dme arrived pg0338 arh dme arrived dme domodedovo airport .
.
moscow arh talagi airport .
.
moscow hma khanty airport .
.
yekaterinburg kro kurgan airport .
.
yekaterinburg kro hma arh dme .
.
arh .
.
hma .
.
kro .
.
dme dme dme dme .
.
dme .
.
dme .
.
kro .
.
hma .
.
arh .
.
dme .
.
dme .
.
dme .
.
kro .
.
hma .
.
arh .
.
kro .
.
dme .
.
hma .
.
dme .
.
arh .
.
dme .
.
kro dme .
hma dme .
arh dme .
a disc application in spark b directed acyclic graph c data processingflights.csv airports.csv figure a disc application with a fault in the udf of step map a code in scala.
b the corresponding dataflow graph and c an illustration of data manipulation in steps.
blue and red colored texts are co dependent regions identified by depfuzz .
as opposed to the entire dataset during mutational fuzzing without sacrificing code coverage.
by inferring co dependence relations among different columns from multiple datasets it increases the chanceofgeneratingmeaningfulunstructuredinputsthatcanreach thelaterstagesoftheapplicationafteroperationssuchas joinand co group are used.
depfuzz instruments the program under test by overriding dataflow operators and udf components to capture row level column level and dataset level provenance.
this is done by implementingdynamictainttrackingforudfsanddataflowoperators.
by leveraging co dependence aware row selection and column mutations itgeneratesinputsthatcanreachdeeperregions i.e.
udfs inthe laterstagesofdataflowoperators .
to evaluate depfuzz we use disc applications and measure statementcoverage faultdetectioncapability and fuzzing speed up.
to assess fault detection capability we inject faults at differentdepthsintermsoftheprogram sjointdataflowandcontrol flow graph.
we evaluate depfuzz against two baseline techniques jazzer a coverage guided greybox fuzzer for java bytecode based on libfuzzer andbigfuzz a greybox fuzzer for disc applications.
comparison against jazzerandbigfuzzserves toassesstheoverallbenefitintermsoffaultdetectionandspeedup when orchestrating input mutations across multiple datasets byidentifyingco dependenceconstraints.
depfuzz achieves87 statementcoverage whichis29 and13 morethan jazzerand bigfuzz.
it also obtains coverage .
and1.
faster than jazzer andbigfuzz respectively.sincefaultsappearinginearlierstages tendtobeeasiertofind e.g.
duetoill formattedinputs thanthose faults appearing in later processing stages we evenly distributeinjectedfaultsinalldataflowoperatorsforfairness.theaverage depthofafaultfoundby depfuzz is3.7operatorsdeepcomparedto .
and .
by jazzerandbigfuzz respectively.
our contributions are as follows wepresent anewfuzz testingapproachthatleverages rich provenance information to increase mutational fuzzing s effectivenessandefficiencyfordiscapplications.thisisthe firsttestgenerationapproachthatextractsco dependence constraints at the level of rows columns and datasets fully automatically withoutrequiringanexplicitschemafroma user.
our evaluation includes an extensive comparison against two baselines on different benchmark programs for hours each.
the results show depfuzz reaches previously uncoveredcodefaster findsfaultsfaster andreachesdeeper code locations oflaterstagesthanexisting fuzzers.
depfuzz is built on extended dynamic taint tracking and analysisofdataflowoperators.ithascomprehensivesupport for apachespark based disc applicationswrittenin scala anditskeyideageneralizestootherdataflow basedbigdata applicationssuchasgoogle smapreduceorapachehadoop.
depfuzz is publicly available at motivating example this section motivates depfuzz with a concrete example.
suppose a data analyst computes the distance traveled by airplanes for each flightin2017fromtwoinputdatasets flightscontainsmillions 1051co dependence aware fuzzing fordataflow basedbig dataanalytics esec fse december3 san francisco ca usa flights dataset int string string string string string string pg0320 mrv pee airports dataset string string string float float string tof bogashevo airport tomsk .
.
krasnoyarsk duration 24h figure a sample configuration file required by bigfuzz.
the file contains schemas and seed inputs for the flights andairports dataset and a user specified time cut off for thefuzzingcampaign.
of flights flown worldwide in and airports contains the geographiclocationofairports.thetoptwoboxesinfigure c show samplerowsfromeachdataset.the flights datasethasaflightid thedepartureandlandingtimes thedepartureandarrivalairport codes and the flight status all separated by commas.
the airport dataset maps airport codes to their airport name longitude and latitude coordinates and the corresponding city.
figure a shows a discapplicationwritteninspark.itconsistsofdataflowoperators suchasmapandjoin wheresomedataflowoperators suchas map takeauser definedfunction udf asanargument.forexample the9maptakesaudfthatcomputesdistanceusingthehaversine formula showninthe expandedtextbox.
in1 theanalystextractstheairportcodeandlongitudeandlatitudevaluesfrom airport.fromflights sheselectsthedeparture andarrivalairportcodesandtheflightid asthefirstcolumnand the second column in 2and3 respectively.
she uses joinin4 and5tojointhearrivalanddepartureairportswiththeirlongitude andlatitudecoordinates.
8joinsthetwodatastreamsusingaflight id.9applies the distfunction onthe pairsof latitude longitude tuples to compute the haversine distance.
while writing the haversine formula she mistakenly writes sqrt .
a instead of sqrt a text box for 9in figure a .
this errorishard to spot andsubtleandcauses nanexceptions.
limitations of existing fuzzers.
to reveal such errors suppose thatsherunsacommerciallyused coverage guidedgreyboxfuzzer jazzer .
after a hour fuzzing campaign even with coverage guidance jazzer cannot produce an input to reach code beyond custom parsing logic at where it persistently triggers the samearrayoutofboundsexception .jazzerachieves a maximum statement coverage of .
due to a lack of schema and a lack of awareness of co dependent regions it continues to generate random strings for the two datasets that cannot pass beyond the parsingstage i.e.
mapat2 .
similarly bigfuzz requires an input schema as shown in figure to apply schema aware mutations such as changing thenumericalvalue changingintegerstofloat adding removing columns or changing the delimiter.
these mutations help bigfuzz avoid some trivial parsing errors.
although bigfuzzachieves statement coverage in hours it is still unable to trigger the faultin becausetopassbeyond joinat8 thethreecolumns column0of airports andcolumns4and5of flights musthave thesame value to satisfy co dependence constraintsto exercise the udf ofmapat9.
sincejazzerandbigfuzzmutate all columns independently of each other this three way constraint is highly unlikely to be satisfiedbytheirmutations.flights dataset p 4gjn50 0k0g zu cso.
d n d n a i e pg04 o0 gc k7 zq j01 d n d n zted airports dataset d n syhkutkl irp7rs gap ns4 .64e9 .30e9 jusg3sk figure a test case generated by depfuzz that causes a nan exceptionintheprogram infigure benefitsof depfuzz .supposethatthedataanalystuses depfuzz togeneratenewtestinputs.shedoesnotneedtoprovideanexplicit schema and simply provides the current dataset to depfuzz.
at the end of hours depfuzz generates new inputs as shown in figure3 leadingtoa nanerror reachingthefaultylineinsidethe corresponding udf of mapat9.
depfuzz detects the two sets of co dependent regions highlighted in blue and red in figure and mutates them such that theycanstillsatisfytheimplicitconstraintsimposedbythethree joinoperators and .therowsinblue i.e.
must beequalsince 8performsaself join.theredcells i.e.
d n are co dependentbyequalityduetojoin 4and5.closeinspection of the applicationexecution on this input shows that variable cis faultyat 9infigure b .thedeveloperspotsthiserroronthesecondlastlineandreplaces sqrt .
a tosqrt a inaccordance withthe haversine formula.
depfuzz dataset dataset dataset disc app.
operator col row dataset join4 join4 join5 join5 disc app.
taint analysis co dependence monitors high quality concise seed input co dependency between input regionsphase iphase ii phase iii d0 col row d1 col row d0 col row d1 col row test result i1 i2 x ... ...inputs output phase iv fuzzing campaign figure workflow of depfuzz .
approach thekeycontributionof depfuzz istodetectco dependentregions across multiple datasets and orchestrate input mutations on the codependentregionsaccordingly.inthissection weformally define co dependenceandprovidedetailsofhow depfuzz detectsthem.
depfuzz consists of four phases as shown in figure .
phase i automatically instruments a given disc application to enable finegrainedtaintanalysisatthelevelofrows columns anddatasetids.
this allows it to track data provenance through dataflow operators andudfstocaptureco dependencerelationships.phaseiiexecutes this instrumented program on the entire dataset to capture codependence constraints among multiple input datasets.
phase iii leverages this provenance tracking capability to select a precise subset of rows from each dataset to use as seeds for subsequent fuzzing iterations.
phase iv then initiates a fuzzing campaign with the selected rows from phase iii and applies co dependenceaware mutations to expose deeper faults.
after reaching a user specified time limit depfuzz outputs asetof test inputs.
formalizing inputco dependence.
co dependenceisadependencycreatedbetweenmultipleinputregionsbyanoperation e.g.
a dataflow operator or a binary operation that affects control flow in udfs that operates on such input regions.
an input region is 1052esec fse december3 san francisco ca usa ahmad humayun miryungkim andmuhammadaligulzar data.filter row if row.t depart.time.after return true else return false .join ... .map ... .reducebykey ... .map ... f id t depart t land from to kro dme hma dme arh dme lhe iad a the first three rows shown in red are dropped by the filter condition shown in green and therefore do not influence any code beyond the filter operation b co dependence monitors are attached to each branch in the jdu graph.data.monitoredfilter row if monitoredpredicate row.t depart.time.after return true else return false .monitoredjoin ... .map ... .monitoredreducebykey ... .map ... figure the red color rows do not participate in the join operationsincethe filteroperationremovedthemearlier.
acontiguoussequenceofbytesinaninputdataset.weformalize co dependenceasfollows.givena discapplication we defineits dataflow graph dfg with two types of vertices operators and datanodes similar to the traditional dfg representation .
in thecaseofdiscapplications operators arefunctionsinaprogram thatoperateondata e.g.
join dataflowoperatoror inudfs .
a comprehensive list of trackable operators is shown in table .
datanodes representdatathatpropagatefromone operatortoanother i.e.
inputandoutputofanoperator .thus wedefineadisc application s dfg u1d43a as u1d43a u1d442 u1d441 u1d438 where u1d442 u1d45c1 u1d45c2 ... u1d45c u1d45b isasetofoperators u1d441 u1d45b1 u1d45b2 ... u1d45b u1d45a is a set of datanodes.
u1d438 u1d442 u1d441 u1d441 u1d442 is a set of directed edges connecting operators with datanodes.
an atomic unit of this dfg has three nodes and two edges i.e.
an operator with an incoming edge from an input datanode and an outgoing edge to an output datanode.
furthermore a datanode u1d45bholds data in the form of a byte sequence u1d44f1 u1d44f2... u1d44f u1d458.
let u1d437 u1d45b be the set of all possible subsequences of the byte sequence in a datanode u1d45b i.e.
u1d44f1 u1d44f2 ... u1d44f1 u1d44f2 ... u1d44f1... u1d44f u1d458 .
input datasets of disc applications are defined as u1d446 a set of initial datanodes which are external inputs to the dfg.
we combine regions in input datasets in u1d446 a union of u1d437 u1d45b acrossallinputdatanodes.
u1d446 uniondisplay.
u1d45b u1d446 u1d437 u1d45b 1case class taintedstring value string t taints a tainted string class 3defconcat other string taintedstring 4return new taintedstring value.concat other t 6defconcat other taintedstring taintedstring 7return new taintedstring value.concat x.value union t x.t ... more overloaded operators figure taint analysis enabled string type inscala finally wecharacterizeco dependencyamonginputregionsasa setoftuples u1d436 u1d436 u1d45c u1d445 u1d445 u1d446 u1d45c u1d442 thefirstelement u1d45c isanoperatorinthedataflowgraph andthe secondelement u1d445 isasubsetoftheregionsintheinputdatasets that are co dependent due to operator u1d45c.
let u1d43c u1d45c be the incoming datatoanoperator u1d45c.sinceco dependencecanonlyoccurbetween regionsoftheoriginaldatasets wemustextract u1d445from u1d43c u1d45c which can be any arbitrary byte sequence in the incoming datanode of operator u1d45c.
to extract such information we define monitors that are concretely explainedinsection .
.
u1d440 u1d45c u1d43c u1d45c p u1d446 wherep u1d446 isthepowersetof u1d446 .amonitor u1d440 u1d45c isanoperatorspecific function that takes u1d43c u1d45c as input and outputs a set of byte sequences i.e.
input regions from the original input datasets consideredco dependent w.r.t.givenoperator.thepreciselogicbehind this mapping depends on the semantics of the operators which we capture using dynamic tainting in depfuzz.
take for example a operationin a.substr b.substr .themonitor u1d440 shouldyield a.substr b.substr resulting inaco dependencetuple a.substr b.substr .table1listsconcreteexamplesofoperators theirmonitors u1d440 andthe respective mutation strategies.
.
phasei enabling fine grainedtaint analysis phase i instruments a given input program to enable taint analysis andto capture co dependence information.
enablingtaintanalysisvia instrumentation.
depfuzz usestaint analysis to identify precise columns and rows in the input datasets contributing towardsa specificintermediateoutput or a finaloutput.depfuzz first replaces primitive data types with equivalent taintedtypes.thetainteddatatypeisatupleofanoriginaltypeand a list of offsets representing taints value list .
depfuzz overrides all apis of the original data type with taintenabled equivalent versions to propagate their taints.
for example concatintstr1.concat tstr2 concatenatestwotaintedstrings tstr1andtstr2 andattachesanewtaintwiththeuniononthe two corresponding taints.
figure 6shows the implementation of concatintaintedstring .depfuzz providesaninstrumentedversion of data loading apis that read the input datasets in tainted types instead of primitive types.
similarly we instrument apis for int float doubleandboolean.
apache spark s textfile api 1053co dependence aware fuzzing fordataflow basedbig dataanalytics esec fse december3 san francisco ca usa valdataset1 filewithtaint classes valdataset2 filewithtaint rooms dataset1 .map s s.split regex .map code title name section valkey code.concat s section return key title dataset2 .map s s.split .join dataset1 datataint dataset id column row cs365 algorithms john smith s1 cs365 algorithms jane doe s2 cs563 advanced os jack joe s1 data taint cs365 s1 room cs365 s2 room cs563 s1 room data taint data taint data taint data taint cs365 algorithms john smith s1 cs365 algorithms jane doe s2 cs563 advanced os jack joe s1 data taint data taint cs365 s1 algorithms cs365 s2 algorithms cs563 s1 advanced os data taint data taint cs365 s1 room cs365 s2 room cs563 s1 room data taint data taint cs365 s1 room cs365 s2 room cs563 s1 room dataset1 dataset2 figure taint propagation through a simple dataflow program.
yellow colored highlighted text is the provenance of red colored textat thebottomleft table.
reads each row as a string while the taint analysis equivalent version reads each row as a taintedstring with a row offset and adataset id.
taintpropagationatthelevelofrows columns anddatasets.
randomlymutatingtheentirerowwilllikelymutatenon participating regions in the input.
in figure the second third fourth and seventh columns in the first dataset are never used by the application code.depfuzz implementsanextendedtaintanalysisatthelevel of a dataset id a column offset and a row offset i.e.
value list .
for example in figure7 cs363 advanced os jack joe s1 hasataint meaning the data is from the first dataset the first column and the third row.
to reduce the storage overhead of attaching a tainted object depfuzz encodesthethreeoffsetsintoasingle32 bitinteger.
co dependence monitors.
in order to associatetaints at thelevel ofbranchesanddataflowoperators depfuzz injectsco dependence monitorsateachdataflowoperatorandateachbranchpredicate within udfs as shown in figure .
for example this process replacesa dataflowoperator joinwithmonitoredjoin andreplaces if p withif monitoredpredicate p within udfs.
this codependencemonitorinjectionenables depfuzz toidentifywhich rowsandcolumnsfromwhichdatasetsdirectlyinfluenceindividual branching decisions.
branches in a disc application include both an explicit control predicate from an ifstatement or a for loop in user defined functions and implicit branches from dataflow operators e.g.
joinandfilter .
.
phaseii fine grainedtaint tracking depfuzz runs the instrumented taint analysis enabled version fromphaseiontheoriginaldatasets.figure 7showshowdatais trackedthroughthe executionofataint enabledprogram.
co dependence detection.
dataflow operators and udfs pose implicit and explicit co dependence constraints.
for instance join enforcesan implicitconstraint that for eachoutput row the keys of the two joining datasets must be equal.
similarly if airporta airportb imposes an explicit constraint that the airporta andairportb derived from specific rows and columns of input datasets areequal.co dependencealsoarisesbetweentherowsof the same dataset.
for example aggregation operators such as reducebykey andgroupbykey result in co dependence where one or more rows must have the same key to have an output row with the same key.
our insight is that while random mutations are unlikely tosatisfy co dependence constraints by chance coordinatedmutationstospecificrowandcolumnoffsetsthatrespect co dependency constraintsare likely to reachdeeper code.
exactly how taints are transformed into co dependence constraints depends on the monitored dataflow operator type.
for example for join the key columns of the two participating datasets must be the same equality .
for an ifcondition if column0 column5 the co dependence isa greater than relationship.
oncetheinstrumentedapplication sexecutionontheoriginal datasets completes depfuzz consolidates co dependence information documentingeachmonitor srelativepositionintermsof dataflow operatordepth andthelistoftaintscontainingoffsetsat thelevelofrows columns anddatasetids.forexample infigure join 4hasadepthoftwoandformsaco dependencebetweencolumn5of flights andcolumn0of airports whichactasthekeys forthejoin.notethat depfuzz candetecttransitiveco dependence when there are overlappingconstraints acrossmultipleoperators.
for example figure 1has a three way co dependence among three inputregionssince airports column 0overlaps with join .
.
phaseiii rowselectionfordata size reduction tospeedupfuzzing depfuzz identifiesasmallsubsetofdatarows thatretainthesamebranchcoverageastheoriginaldataset.this reduces large scale datasets to a set of seed inputs that are small enoughforiterativefuzzing.becausetheoriginalinputdatamay beverylargewithmillionsofrows thisstepsignificantlyreduce thescopeofpotentiallocationstomutate increasingefficiency.for eachbranch depfuzz reducestheoriginalinputdatasetstoasubset of rows reaching that particular branch.
it then consolidates the correspondingrowsforallbranches.figure a showsanexample of how row selection creates a smaller effective seed.
a filter operatorremoves allflights departingbefore 00onagivenday.
therefore the rows highlighted in red will not influence any code 1054esec fse december3 san francisco ca usa ahmad humayun miryungkim andmuhammadaligulzar table1 summaryofhoweachclassofoperatorsproducesco dependentregionsintheinputdataset.forsimplicity weuse row .col as ahuman readablerepresentation ofinput byte region u1d44f u1d456 ... u1d44f u1d457 where0 u1d456 u1d457 u1d460 u1d456 u1d467 u1d452 u1d451 u1d44e u1d461 u1d44e u1d460 u1d452 u1d461 operatorclass sample operators example of identified constraint mutationstrategy fusionsdata1.join data2 data1.intersection data2 data1.cogroup data2 u1d440 u1d457 u1d45c u1d456 u1d45b u1d451 u1d44e u1d461 u1d44e1 u1d451 u1d44e u1d461 u1d44e2 .
possible outputof u1d440 u1d457 u1d45c u1d456 u1d45b data1.row .col data2.row .col data1.row .col data2.row .col co dependencetuples data1.row .col data2.row .col data1.row .col data2.row .col anymutationapplied to data1.row .col must alsobeapplied to data2.row .col .
ifno rows with matchingkeysexists selecta rowfrom data1andcopy data1.col to data2.col .
aggregationsdata.aggregatebykey udf data.reducebykey udf data.groupbykey data.countbykey u1d440 u1d45f u1d452 u1d451 u1d462 u1d450 u1d452 u1d435 u1d466.alt u1d43e u1d452 u1d466.alt u1d451 u1d44e u1d461 u1d44e .
possible outputof u1d440 u1d45f u1d452 u1d451 u1d462 u1d450 u1d452 u1d435 u1d466.alt u1d43e u1d452 u1d466.alt data.row .col data.row .col data.row .col co dependencetuple data.row .col data.row .col data.row .col anymutationapplied to data must alsobeapplied to data .
duplicate rows andapply same mutationto key columnsofduplicates.
filters data.filter col0 col5 u1d440 u1d453 u1d456 u1d459 u1d461 u1d452 u1d45f u1d451 u1d44e u1d461 u1d44e .
possible outputof u1d440 u1d453 u1d456 u1d459 u1d461 u1d452 u1d45f data.row .col data2.row .col data.row .col data2.row .col co dependencetuples data1.row .col data2.row .col data1.row .col data2.row .col anymutationapplied to data.col and data.col must ensurethat thereis a true andfalserowfor thepredicate.
udf operatorsif a.contains b if a !
b if a b u1d440 u1d450 u1d45c u1d45b u1d461 u1d44e u1d456 u1d45b u1d460 u1d44e u1d44f .
possible outputof u1d440 u1d450 u1d45c u1d45b u1d461 u1d44e u1d456 u1d45b u1d460 data.row .col data2.row .col co dependencetuples u1d450 u1d45c u1d45b u1d461 u1d44e u1d456 u1d45b u1d460 data1.row .col data2.row .col anymutationapplied to data.col and data.col must ensurethat string a containsbfor some mutations.
itmust also ensureitoccasionallycreates inputs that violate this.
beyond the first filter.depfuzz thus retains only the green row inthe seedinputfor subsequent fuzzingiterations.
.
phaseiv co dependence awaremutation phase iv performs a grey box fuzzing campaign by designing new mutations that target various co dependence types.
the output of depfuzz isalistoferrorsandtestinputsrevealingthoseerrors.differentfromstandardgrey boxfuzzing depfuzz prioritizes where to apply input mutations based on fine grained taint tracking at thelevelofrows columns anddatasets.
depfuzz designsanovel inputmutationstrategythatmaintainsco dependency.basedon the co dependent constraints we categorize dataflow operators intofourclasses fusions aggregations filters andudfoperators .
table1summarizes mutation strategies for eachclass ofoperator.
forfusion operators likejoin depfuzz applies the same set of mutations on the key columns of the two joining datasets toensureequality.infigure c when depfuzzmutateskro inrow0ofthe flightsdataset itappliesthesamemutations tokroinrow3of airports ensuring anon empty output forjoin.
foraggregation operators likereducebykey depfuzz duplicatesarowandappliesthesamesetofmutationsonthekey columnofthoserows ensuringatleast2rowsineachoutput group.
suppose if reducebykey is applied on the fourth column of flightsin figure .depfuzz duplicates a row times and applies the same mutation on the key of the originalandduplicatedrows.
forfilter operators likefilter depfuzz applies mutation on the columns used in the filtering predicate.
in case of filter data.col data.col depfuzz can create at least one row where this predicate can be true or at leastone rowwhere this predicate isfalse.
forudf operators likemapandflatmap that take udfs asarguments depfuzz handlescontrolpredicatesinuserdefinedfunctionssimilarto filter.forexample inthecase ofa.contains b depfuzz identifiestheprovenanceofthe stringsaandbasdata.col anddata.col respectively.depfuzz thenenforcesthetruepathforthiscondition byembedding binaduringthe mutation process.
evaluation results weevaluate depfuzz onfourcriteria codecoverage faultdetection faultdepth andtestingspeed transcribedintotheresearch questionsbelow.
rq1 whatisdepfuzz stestcoveragecomparedtobaselinefuzzers?
rq2 howmanyerrorscan depfuzz detectcomparedtobaselines?
rq3 candepfuzz detecterrorslocatedin deepercode regions?
rq4 how much overhead does depfuzz s instrumentation incur?
rq5 doesdepfuzz achieve code coveragefaster thanbaselines?
benchmarks.
existing dataflow benchmarks like tpc ds or big data benchmark are purely performance benchmarks writteninsqlandthereforedonotcontainudfsandnon relational dataflow operators.in contrast the subjectprograms introduced by prior work on fuzzing in disc only operate on a single dataset omitting an entire class of operators related to real world multiple 1055co dependence aware fuzzing fordataflow basedbig dataanalytics esec fse december3 san francisco ca usa table2 subjectprogramsusedin depfuzz sevaluation.allprogramsrepresentreal worlddiscusecasesandareadopted frompriorwork.
the data andcodecharacteristics ofbenchmarkprograms are alsoshown.
idprogram description datasets of opt.max depthtotal rowsoperatorsused p1webpagesegmentation findoverlapping ui components ona webpage 1m map groupbykey join filter p2customer rewards findthetop customers w.r.t purchase history 2m map groupbykey join filter sortby p3flight distance computedistance travelledbya givenflight 500kmap join p4busdelays identify busroutesthataredelayedfrequently 2m flatmap join reducebykey filter p5commutetype identify thetransportation typeusedona trip 1m map mapvaluesaggregatebykey p6wordcount findthefrequency ofwords 1m map flatmap reducebykey p7delivery faults identify vendor sets leading tofaulty deliveries 1m map groupbykey filter p8externalcall findthefrequency ofwords 1m map flatmap reducebykey filter p9findsalary totalincomeofindividualsearning 300weekly 1m map filter reduce p10studentgrade list ofclasseswith morethan failingstudents 1m map reducebykey filter p11movierating total numberofmovieswith rating 1m map reducebykey filter p12insidecircle check whetherthepoint x y isina circle 1m map filter p13mapstring string mapping 1m map p14numberseries findthenumbers whose 3n series length is25 1m map filter p15ageanalysis total numberofpeople with different age ranges 1m map filter p16incomeaggregation averageincomeperage range ina district 1m map mapvaluesfilter reducebykey p17loantype the countofloantypewithin a region 1m map dataset analytics.
therefore we evaluate depfuzz on unique big data applications accumulated from nearly all publicly available prior work on disc testing disc debugging and real world disc use cases .
collectively our benchmark programs comprise a variety of dataflow operators transformation flatmap map fusion join and aggregation reduce group operators udfs which are integral to disc applications and bothsingleandmultipleinputdatasets which are criticalfor practical data analysis.
thecompletelistofsubjectprogramsisshownintable .forexample p7 identifiesthetypeoftransportationusedtoperform thedailycommutes i.e.
bus car orwalk.itconsolidatesinformation on trips from two datasets to find the starting and destination zip codes the distance traveled for the trip and the time it took to coverthisdistance.anotherprogramp2isinspiredbyacommercial case study of apache spark .
it analyzes customer purchase history and rewards eligible customers more than three instances of spending in the current year with coupons valued proportionally to spending.
this is a multi dataset program that joins the customerinformationtablewiththepurchasehistorytable.overall thebenchmarkprograms sizeiscomparabletoreal worldindustry disc applications which are in the order of hundreds of loc but closed sourced.
baselines.
wecompare depfuzz againsttwobaselines astateof art schema aware disc application fuzzer bigfuzz and themostadvancedcommercial gradecoverageguidedfuzzerfor the jvm jazzer developed in part by google.
we compare againstthesebaselinesbecausetheyarethestate of the artfuzzers fordiscapplicationsandjvm basedapplications respectively.we usescoverage to monitor scala statement coverage of the applications.
we provide bigfuzzwith a seed input constructed by randomly sampling a row fromthe dataset along with a schema of thedatasetasintheoriginalpaper.for jazzer wewriteinterfacing code that converts the random byte stream generated by jazzer intoformatteddatasets expectedbythe disc application.evaluation environment.
we run each tool for up to hours whichisastandardexperimentalsettingforfuzzingbenchmarks and measure statement coverage cumulative error detection and error depth of operators in the dataflow graph of the benchmark programs.
we perform these experiments on a node clustercomputingenvironmentwith112coresat3.10ghz 52tb storage and832gbmemory.werunourexperimentsonapache spark .
andhdfs .
.
.
testcoverage against baseline figure8showshowcumulativestatementcoverageincreasesthroughout the hour fuzzing campaign with depfuzz and the two baselines.y axisrepresentsthepercentageofstatementcoverage achieved and the x axis represents the time elapsed in seconds.
depfuzz significantlyoutperformsbaselinesforprogramsingestingmultipleinputdatasetsandcontainingfusion aggregation and filter operators such as p1 p5.
for programs that ingest only a singledataset i.e.
p6 p17 depfuzz showsslightlybetterperformance onaverageinterms ofcoverage.
program p1 s seventh operator is join where each dataset s key is a concatenation of three columns.
since there are six codependentcolumnsrelatedbythisequalityandbothbaselinefuzzers mutateeachofthesixcolumnsindependentlyoftheothers they fail to generate even a single input with matching keys to pass thisjoin.
even with its schema aware mutations bigfuzzonly achieves28 coverage.similarly jazzerstruggles topush beyond coveragewithitsbyte levelmutations.
depfuzz managesto capturetheco dependencebetweensixcolumnscreatedby join.it immediately satisfies the constraints early in the fuzzing campaign through tailored mutations for fusion operators.
depfuzz achieves coveragewithin hours of fuzzing.
in p7 we observe a drastic increase in statement coverage in the first iteration of depfuzz compared to the baselines.
this program uses an aggregation operator groupbykey followed by filterthat requires a minimum number of rows with the same key to exercise the code after filter.
mutations that randomly 1056esec fse december3 san francisco ca usa ahmad humayun miryungkim andmuhammadaligulzar 100102104020406080100statementcoverage p1 100102104020406080100p2 100102104020406080100p3 100102104020406080100p4 100102104020406080100p5 100102104020406080100p6 100102104020406080100statementcoverage p7 100102104020406080100p8 100102104020406080100p9 100102104020406080100p10 100102104020406080100p11 100102104020406080100p12 time s statementcoverage p13 time s p14 time s p15 time s p16 time s p17depfuzz bigfuzz jazzer figure statement coverage ofthree tools on 17benchmarkprograms during24hours duplicate any row are unaware of the aggregation s key column.
thus baseline fuzzers do not generate the required rows to pass throughfilter.depfuzz identifies the groupbykey along with theinputcolumnthatinfluencesthekey.itthenduplicatesinput rowstosatisfythejointconstraintimposedby aggregation and filter.depfuzz ssuperiorperformanceinp2 p4canbeattributed to similar reasons.
depfuzz also performs better for single dataset applications p6p17thatdonothaveanyfusionoperators duetoonlyoneinput dataset andtheiraveragedataflowoperatordepthisonlythree.
depfuzz performs140kfewerbutmoreeffectivefuzzingiterations thanbaselinesonaverageduetothehigheralgorithmiccomplexity ofapplyingco dependentmutations.thebaseline jazzerperforms better in p16 because some statements in the program are only reachable on one specific input value.
the chances of reaching such statements e.g.
stmt1 in if x stmt1 are purely random.
thus the technique with a higher number of iterations is more likely to reach these statements.
in p16 jazzerperforms twice as many iterations as depfuzz which increases its likelihood of arbitrarily changing the input row from to90024 achieving additional statement coverage.
in a hour fuzzing campaign depfuzz achieves higher coverage thanjazzerand13 higher coveragethan bigfuzz.
to answer rq5 we evaluate how quickly depfuzz achieves coverage compare to baselines by performing curve fitting with u1d466.alt u1d45a u1d465astheobjectivefunctiononthecumulativecoveragegraphs since the gradientofthis line representsthe average rate of gain of coverage over the course of the entire campaign.
we find that depfuzz is1.
fasterthan bigfuzzand2.
fasterthan jazzer interms ofthe coverageincreaserate.
.
faultdetection we measure the fault detection capability of depfuzz compared tothebaselines.forthisexperiment ineachsubjectprogram we injectone fault ateachdepth ofa dataflow graphand then record the number of faults.
we define a fault s depth as the number of dataflow operators an input row has to go through before reaching a faulty statement.
for example if a fault is seeded in a udf u1d453 where u1d453isanargumentto u1d45b u1d461hdataflowoperator thefaultisseeded at depth u1d45b.
for example the fault in figure1has a depth of five becausetherearefivedataflowoperatorsbeforethefaultycode.we count only the faults triggered from correctly formatted inputs as jazzergenerates a massive number of ill formatted inputs that all lead to parsing errors such as arrayindexoutofbound exception fromsplit due to missing k u1d461hcolumn in input data.
parsing errors are caused by processing ill formatted inputs in a program.
these errors normally appear in the first operation of a disc application that takes a raw unstructured input and parsesitintoindividualdatafieldsandtheirtypes e.g.
keysand 1057co dependence aware fuzzing fordataflow basedbig dataanalytics esec fse december3 san francisco ca usa 100101102103104020406080100faultsdetected c totalaverage time s b single datasetaverage a multidataset averagedepfuzz jazzer bigfuzz figure cumulative number of faults detected during hours averaged across programs.
b shows the average for p5 p17 which ingest asingledataset and c showsaverage forp1 p4which takemultiple datasetsas input.
time s dataflowdepthdepfuzz bigfuzz jazzer offaults figure10 depthvstimefor allfaultsdetectedby depfuzz andbaselines.
circlemultiplytext.1denotescentroidsofeachtool.
depfuzz has more points near the top left corner which means it detects deeperfaultsfasterthanbaselines.
depfuzz findsmorefaults than baselines.
values similar to the first mapapplied on dataset1 anddataset2 in figure .
these errors do not appear if the input data format conformstotheprogram sparsinglogic.weevaluatefaultdetection on two levels the total number ofunique faults detected and the depth within the dataflow graph at which a fault is detected.
notethat eachdataflowoperator takes audf as an argument.
fault injection.
we manually inject faults into the subject programsbyrandomlyreplacingarithmeticoperators binaryoperators andconstants .forexample sqrt a becomessqrt .
a afterinjectingafault whichcanleadto nanerror.similarly replacingoperatorslike with willinjectadivision by zeroerror.prior work on apache spark recognizes the presence of such faults in real worlddiscapplications .wealsoaddfaultsbyemploying a range check that throws runtimeexception if a particular column value falls within a narrow range.
for example a faulty program throws an exception if a string value in a column starts with .
faultinjectioniswidelyusedinpracticetoevaluatenewtesting techniques.
automated fault injection tools such as lava and apocalypse devise a set of principles that mimic properties of real world faults.
when injecting faults we also follow these principles whichare as follows.
rare theinjectedfaultsmanifestforonlyasmallfraction of possible inputs.
we inject a fault that is triggered if thefirst column starts with the characters .
the number of inputs that can trigger this fault is .
assuming all inputsareequallylikely theprobabilityofrandommutations triggeringthisfaultis .
assumingtherowlength of ascii characters.
note that this is an overestimate since dependingonwherethefaultisinjected severalother control flow and data flow criteria will need to be met for theexecutiontoreachtheinjectedfault further restricting the spaceofinputsthat can trigger this fault.
uncorrelated findingoneinjectedfaultneitherincreasesnor decreasesthe likelihoodof findingany otherfaults.
reproducible thefaultsaredeterministicandreproducible inthat asingleinputcan prove the existenceof afault.
fair the faults are injected in locations that can be feasibly reachedbyanautomatedtechnique.forexample nofault is guarded by a branch that requires solving an infeasible mathematicalproblem suchasfactoringalargeintegerinto its constituent primes.
intotal weinject45faultsacross17benchmarkprograms.sincethe locationofafaultmayfavorcertaintechniques weensurefairness infaultinjectionbyinjectingafaultateachdataprocessingstep inevery program.
fault detection.
figure9shows the cumulative average number offaultsdetectedonthesubjectprograms.wereportasummaryof all detected program faults in table .
in figure the y axis representsthepercentageofcumulativefaultsdetected andthex axis representsthefuzzingduration.
depfuzzoutperformsbaselinetechniques in terms of fault detection.
for example the majority of the inputsproducedby jazzerhaveaninsufficientnumberofcolumns whichleadstodataparsingerrors i.e.
arrayindexoutofbound exception afterthe splitoperation.similarly inp1 bigfuzzspends over of its iterations triggering the same four parsing faults in the first udf causing only numberformatexception .
table3 lists the total faults detected by depfuzz bigfuzz andjazzer.
onaverage depfuzz finds3.
morefaultsthan jazzerand84 morefaultsthan bigfuzzduetoco dependenceawaremutations.
depfuzz s strengths in fault detection are noticeable inp1 p4 and p7 whereco dependenceawaremutationshelp depfuzz gopast the fusionoperators andreachdeeper dataflowoperators.
detecting deeper program faults.
we stratify the injected faults bytheirdataflowoperatordepth.figure 10showsascatterplotthat 1058esec fse december3 san francisco ca usa ahmad humayun miryungkim andmuhammadaligulzar table3 runningtimeoftheoriginalsubjectprogramand the instrumented program with taint analysis along with total errors detected by eachtool.
program application executiontime faults detected original instrumented overhead depfuzz bigfuzz jazzer p1 .
.
.
p2 .
.
.
p3 .
.
.
p4 .
.
.
p5 .
.
.
p6 .
.
.
p7 .
.
.
p8 .
.
.
p9 .
.
.
p10 .
.
.
p11 .
.
.
p12 .
.
.
p13 .
.
.
p14 .
.
.
p15 .
.
.
p16 .
.
.
p17 .
.
.
totalfaultsdetected visualizesthedepthofthefaultsacross17programs.thetopofthe plot represents deeper hard to reach faults whereas the bottom represents faultsinthe initialphasesofthe application.
the scatter plot shows that overall depfuzz finds faults that reside at a deeper dataflow depth.
in p1 for instance depfuzz findsatotalof7faultsacrossthreedifferentdataflowdepths and whereas both bigfuzzandjazzerare unable to find any.
theplotalsoshowsthat depfuzz isconsistentlyfasteratfinding deepfaultsthanbaselines.forexample inp3 thedeepestbugis triggeredby bigfuzzalittleoveranhourintothefuzzingcampaign whereasdepfuzz findsitwithinthefirstminute.althoughthetime difference is smaller for single dataset programs p6 p17 a similar pattern can be observed.
for example in p14 depfuzz finds the deepestbugwithinthefirsttwominutes whereas bigfuzztakes over13minutes.figure 10alsoshowsthecentroidswith circlemultiplytext.1foreach tool.
the size of circlemultiplytext.1represents the number of detected faults.
note thatthegapsbetweenthecentroidsarelargerthantheyappeardue to the log scaled x axis.
on average the deepest faults detected by depfuzz are .1operatorsdeeperthan bigfuzzand0.9operators deeper comparedto jazzer.
.3depfuzz sinstrumentationoverhead depfuzz enables dynamic taint analysis in a trial execution i.e.
running an instrumented program on the original input data to identifyco dependencerelationships.notethatthisisa one time overheadforthefirstrun andisnotarecurringoverheadforeach fuzzing iteration because its goal is to infer co dependence constraints from existing data.
table3shows the time difference between an instrumented run andanuninstrumentedrunontheoriginalinputdatasets.forinstance inprogramp1 thetrialexecutionfordynamictaintanalysis takes .
seconds whereas the original program takes .
seconds to process the same amount of data.
this overhead is higher inprograms with multiple datasets aggregator operators and fusion operators p1 p5 astheyintroducecomplexdependenciesamong columns and rows.
these co dependences are represented in dense taint objects i.e.
roaringbitmaps .
across the programs the first instrumented run s overhead is .
to of the first uninstrumented run.
note that this overhead is a one time upfront costandtherestofthefuzzingloopdoesnotrequirerunningan instrumented version with taint monitors therefore in the long run the cost of using depfuzz becomes negligible compared to many hours of fuzz testing.
depfuzz s runtime overhead is on par withothertaint analysisapproachesondisc applications .
related work fuzzinghasgainedpopularityinindustryandacademiarecently duetoitsblack boxnatureandeaseofadoption .acommon challengeinfuzzingisgeneratingstructurallyvalidinputs.zest attempts to generate valid inputs using parametric generators.
bigfuzz usesframeworkabstractiontoreducefuzztestinglatency.
however bigfuzz is a simple random fuzzer and cannot identify co dependent regions in the input.
symbolic execution techniques exist for testing disc applications.
however theycannoteasilygenerateconstraintsthatrespectco dependence relationshipswithinmultipledatasets createdbythecomplexinteractionbetweendataflowoperatorsandudfs.randomtesting bears similarity to fuzz testing .
randoop and evosuite generate test suites for the program under test to cause program crashes.
the closest line of work to ours is taint based fuzzing.
at a high level all taint analysis techniques attempt to isolate regions within aninputcriticaltomutate.forexample bekrar et.al.
propose taint based fuzzing that identifies input regions to focus mutations.
taintscope andbuzzfuzz isolateregionsoftheinputinside asensitivelibraryandsystemcalls.pata performspath aware taint analysis to mitigate the problems of over tainting and undertaintingbyemployingpathinformation.althoughthesetechniques isolate critical input regions none target disc applications and nonecandiscoverunderlyingco dependencerelationsbyanalyzing dataflow operators and udfs.
the inputs to disc applications are verylargeandconsistofmultipledatasets soexistingtainttracking atabyte levelisalsoinefficient.
depfuzz addressestheseproblems by handling multiple datasets and by tracking taints at the level of dataset ids columns androwsfrom unstructuredinputs.
the idea of triggering hard to reach regions ofthe programhas been seen frequently in the literature.
fairfuzz is a targeted mutationstrategythatavoidsmutatinginputregionsthattrigger rarebranches similartohow depfuzz analyzestheuseoffusion operators to co mutate certain regions.
however fairfuzz uses coveragefeedbackandasimplemaskingstrategytofreezecontiguousinputregions.aflfast prioritizesinputsthattriggerrare pathsin the code.
aflfast instruments program binary and performruntimecoverageanalysis.bothfairfuzzandaflfastarenot suitablefordiscapplicationsbecausetheydonotanalyzedataflow operator usages and internal udf semantics to infer co dependent input regions in large datasets.
neither perform provenance aware duplication to resolve aggregations which are extremely common 1059co dependence aware fuzzing fordataflow basedbig dataanalytics esec fse december3 san francisco ca usa indiscapplications.driller switchestousingsymbolicexecutiontoresolveadifficultbranchthataflfailstopass causingitto inherit the limitations of symbolic execution.
steelix attempts to produce a single input passing a difficult to hit branch in the codeandemployssource levelinstrumentationsimilarto depfuzz.
steelixisnotsuitablefordiscapplicationswithlargeinputsdue to alackoffine graineddata tracking.
taintstream implements cell levelprovenancefor apache spark in the context of policy enforcement.
depfuzz also tracks provenance at the cell level.
however taintstream requires extending the original dataset with tags whereas depfuzz s cell level tracking is fully automatic and does not require converting theoriginaldataset.
depfuzz staintanalysisissimilartothatof flowdebug as they both instrument primitive data types and application code and do not require any modifications to the originaldatasetstoenabletaintanalysis.however flowdebugconcerns taint analysis only and does not generate test data nor does it identifyco dependencyconstraintsamonginputdatasets.furthermore existing dataprovenance techniques performtaint analysis only at the row level support only a single dataset and do not support tracking at the column cell level.
spark specific dataprovenancesolutionsalsoexist suchastitian butitis limitedtorow leveldataprovenanceforonlyasingleinputdataset.
bigsift isanextensionofdeltadebuggingfordiscapplications but its isolation works at the level of rows not the level of dataset ids rows andcolumns unlike depfuzz.
conclusion traditional fuzzing is ineffective for disc applications due to requirements to handle unstructured inputs a lack of schema the inabilitytohandlemultipledatasets andtheirlargeinputsize.in thiswork weintroduce depfuzz atechniquethatusesfine grained provenancetrackingtoinfercomplexco dependenceconstraints created by dataflow operators and user defined functions.
the key insightbehind depfuzz istoorchestrateco dependenceawaremutations on multiple input datasets in concert.
depfuzz increases code coverage fast finds more defects and finds defects that are hardto find higher statement coverage .
faster and triggeringfaults thatare .9operators deeper thanthe onesfound by the state ofthe art commercialfuzzerfor jvm.