towards bidirectional live programmingfor incomplete programsxing zhang zhenjiang hu key laboratory of high con!dence software technologies moeschool of computer science peking universityzhangstar stu.pku.edu.cn huzj pku.edu.cnabstractbidirectional live programming not only allows software develop ers to see continuous feedback on the output as they write theprogram but also allows them to modify the program by directlymanipulating the output so that the modi!ed program can getthe output that was directly manipulated.
despite the appealingof existing bidirectional live programming systems there is a biglimitation they cannot deal with incomplete programs where codeblanks exist in the source programs.in this paper we propose a framework to support bidirectionallive programming for incomplete programs by extending the out put value structure introducing hole binding and formally de!n ing bidirectional evaluators that are well behaved.
to illustratethe usefulness of the framework we realize the core bidirectionalevaluations of incomplete programs in a tool called bidirectionalpreview.
our experimental results show that our extended back ward evaluation for incomplete programs is as e cient as that forcomplete programs in that it is only u1d45a u1d460slower on a program with10 holes than that on its full program and our extended forwardevaluation makes no difference.
furthermore we usequick sortandstudent grades two nontrivial examples of incomplete programs to demonstrate its usefulness in algorithm teaching and programdebugging.keywordslive programming bidirectional evaluation direct manipulation hole bindings hole closuresacm reference format xing zhang zhenjiang hu .
.
towards bidirectional live program ming for incomplete programs.
in44th international conference on softwareengineering icse may pittsburgh pa usa.acm newyork ny usa pages.
to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor pro!t or commercial advantage and that copies bear this notice and the full citationon the!rst page.
copyrights for components of this work owned by others than acmmust be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci!c permission and or afee.
request permissions from permissions acm.org.icse may pittsburgh pa usa association for computing machinery.acm isbn .
.
.
.
introductionsoftware developers have psychological expectations1on the out put when programming in many scenarios particularly in the de sign of systems such as dynamic web pages graphical user inter faces guis slide based presentations and data visualizations.
tocombine the intuitiveness of direct manipulation on the outputwith the abstractness and repeatability of text based programming researchers have developed many useful bidirectional live program ming systems such as sketch n sketch capstudio andcarbide alpha which can not only allow developers to seecontinuous feedback on the output when they write programs butalso allow them to modify the program by directly manipulatingthe output so that the modi!ed program can get the output thatwas directly manipulated.despite the appeal of the existing bidirectional live programmingsystems there is a big limitation they cannot deal with incompleteprograms where code blanks exist in the source programs .
inpractice software developers tend to program in a way where theyskip some parts by leaving some code blank here and there in theprogram during programming.
therefore it would be practicallyuseful if even when the program is incomplete developers couldstill directly manipulate the output and automatically synchronizethe program with the updated output.fortunately omar et al.
have made a nice progress in thisdirection showing that it is possible to do unidirectional live pro gramming for incomplete programs.
they model incomplete pro grams as expressions with holes which denote missing expressions.rather than aborting the evaluation when a hole is encountered they track the evaluation state also known as closure i.e.
vari ables with their bindings that can be accessed by the hole instances allowing developers to observe this information in editor services.with the technique of live programming for incomplete pro grams what we need to do is to make this technique bidirectionalto achieve the goal of bidirectional live programming for incom plete programs.
different from complete programs the output ofincomplete programs may consist of the output value and closuresof holes both of which should allow direct manipulation modi!ca tion .to this end we are facing three challenges in forward eval uation since the output of incomplete programs is more complexthan that of complete programs and it needs to be re ected backlater the output value structure needs to be carefully designed in backward evaluation holes in the program are special and1psychological expectations refer to users expectations of what the output looks likeand what content the output displays.
for example in web development developersoften design prototypes in advance and have expectations about what componentsare included and where they are located.
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pi t tsburgh pa usaxing zhang zhenjiang hu figure an incomplete program written in bidirectional preview generates an incomplete html table of classmate namesand their date of birth.
the language used is de f ined in figure .should not simply be treated as an undetermined value becauseone hole may be referred many times in the forward evaluationand thus each hole may be associated with multiple values toguarantee the stability of bidirectional evaluation for incompleteprograms it is important to securely concatenate upstream anddownstream backward evaluations that are hole partitioned andsatisfy the round tripping properties.to address challenge we extend the de!nition of values withthree types of holes including instantiations of the source holeexpressions temporary holes generated when evaluation cannotcontinue and sub holes generated after holes decomposition.
toaddress challenge we propose the notion of hole bindings whichrecord the value of a hole under a certain evaluation state.
as partof the forward evaluation input it will be updated in backwardevaluation.
to address challenge we carefully design a pair offorward and backward evaluations and prove that they satisfy theround tripping property.
this implies that the local consistencycan guarantee global consistency.in this paper we propose a new framework for bidirectional liveprogramming for incomplete programs.
the framework supportsdevelopers not only to write incomplete programs and observe theoutput with hole closures in editor services but also to directlymanipulate them to synchronize the program with the output.
ourmain technical contributions can be summarized as follows we design a programming framework to support bidirec tional live programming for incomplete programs so thatdevelopers can directly manipulate the output to synchro nize the program with the updated output even when theprogram is not!nished section .
as far as we are aware this is the!rst framework that can support bidirectional liveprogramming for incomplete programs.
we formalize a bidirectional evaluation for incomplete pro grams section which successfully solves the three chal lenges of de!ning operable output values for incompleteprograms updating holes with constants and updating pro grams with hole values.
besides the round tripping proper ties can be guaranteed section .
.
we give an e cient implementation of the bidirectional liveprogramming framework as a concrete tool called bidirec tional preview which is available at the public repository1.we use two nontrivial examples section to demonstratepractical usefulness of our system in algorithm teachingand program debugging.
besides our experimental resultsshow that compared to bidirectional evaluation for completeprograms our backward evaluation is only u1d45a u1d460slower onan incomplete program with holes than on its completeprogram and the forward evaluation is almost no different section .
overviewin this section we shall demonstrate how developers go throughbidirectional live programming forward text based programmingand backward direct manipulation to accomplish a web develop ment task.
consider the task of implementing an html table thatdisplays each of your classmates along with their date of birth.note that the html example is adapted from the baseline workon the complete program in sketch n sketch .
with our toolbidirectional preview the developer may start with an incompleteprogram that generates an incomplete prototype.
.
initial incomplete programfigure shows a screenshot of the system which consists of anincomplete program the auxiliary functions are omitted on the leftand the incomplete table it generates on the right.
lines through46 de!ne the classmate data each element is a three element list licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards bidirectional live programmingfor incomplete programsicse may pi t tsburgh pa usa figure when modifying james to jack in the f irst lineof the context the classmate data in line of the sourceprogram changes correspondingly.
figure when modifying hole 2in the f irst line of thehtml table to sept. 5th the output value is propagatedto the source program and uni210e1is inferred to be .consisting of the name the month and day of birth and the year ofbirth for now the data is missing .the main program consists of two parts lines through 53de!ne the data process using aspacerto connect two parts ofthe date and lines through de!ne the html rendering oftable headers and content.
the program contains three holes rednumbers the!rst one uni210e1is the expression assigned to variablespacer the second one uni210e2is an uninitialized string type constant inlistcolors and the last one uni210e3is the body of data rendering functiondrawrow.due to the missing code indrawrow the output html table hasits header but lacks content.
on the top of the output window the four purple boxes denote four unknown html elements.
holevalues are indicated by the hole name written in curly braces.
inparticular holes 3 9 through 3 12 are four instantiations of uni210e3 and their closures free variables and their values can be switchedvia the selector in the context window.
the current contextwindow shows a partial closure of hole 3 9 includingrowbeing ibeing etc where stands for a temporaryhole value generated by string concatenation with uni210e1.
.
direct manipulation on contextalthough the program is un!nished the developer can performdirect manipulation on the output and the context.
the modi!cationincludes updating a value to another value and updating a hole toa value or vice versa.figure shows that when modifying the!rst element of u1d45f u1d45c u1d464from james to jack in the!rst line of the context the classmatedata in line of the program is updated correspondingly.
htmlvalues are presented as html strings in the context likeheaderrowin figure and can also be modi!ed.
.
direct manipulation on outputthe functionality of the missing code at uni210e3is to color the even numbered lines of the table lightblue and the odd numbered lines figure fill in the missing code in uni210e3.
figure when using dom inspector to initialize the uncer tain color of the cell with linda on it lightyellow is prop agated to uni210e2and insert a new piece of record to hole bindings.the missing color at uni210e2.
after the developer!lls in uni210e3as shown infigure the shape of the table is complete but the date of birth column is still incomplete because of uni210e1 where holes and display in purple boxes.
.
.
modify text in output.as shown in the right of figure the developer updates hole in the!rst row to sept. 5th whichis in his her expected date format.
the modi!ed html table ispropagated to the source program and the system infers that thevalue of uni210e1is .without replacing uni210e1locally a new piece of record is added tothe hole bindings as shown in the left of figure which means uni210e1should be evaluated to under the context not shown in full including u1d450 u1d459 u1d44e u1d460 u1d460 u1d45a u1d44e u1d452 u1d460and so on.
.
.
modify output using dom inspector.besides directly mod ify the text in output developers can conveniently modify theoutput using developer tools e.g.
dom inspector in the browser.as shown in figure when the developer is not sure of the desiredcolor he she set the!rst element in u1d450 u1d45c u1d459 u1d45c u1d45f u1d460to uni210e1.
after the forwardevaluation due to the uninitialized color for odd numbered linesof the html the background color is default white.
then the de veloper uses the dom inspector to select the cell linda in thethird row of the table and sets its background color property to lightyellow in the styles box.
through backward evaluation thecolor value is propagated to uni210e2and a new piece of record about uni210e2is added to hole bindings as shown in the bottom of figure .2156authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pi t tsburgh pa usaxing zhang zhenjiang hu figure system frameworksummaryafter the above series of manipulations the developer accomplishedthe task of!nishing the program with uni210e1being and uni210e2being lightyellow and uni210e3being de!ned in figure which runs to get theexpected html table.
in summary our tool is a direct manipulationsystem of incomplete programs with friendly interactions beingeffective and productive.
system designour framework for supporting bidirectional live programming forincomplete programs is shown in figure .
the down arrows repre sent the forward process of normal live programming and the uparrows represent the backward process of modifying the programby directly manipulating the output.
we use four colors to markthe four parts of the input output intermediate results and thecore implementation respectively.the user input is a source program which is written in a simplefunctional language used in with the hole extension.
thelanguage used in our system is de!ned in figure .
the outputthat developers can direct manipulate consists of two parts one isthe visual object designed by the developer we use html pagesas an example but it can also be slide based presentations datavisualizations etc.
the other is the closures related to hole values invisual objects also known as the context in bidirectional preview.developers can modify the value of each variable in a hole closurein the context and if the value is a hole value they can jump to itsclosure and modify it.
the intermediate results in the system arethe internal representation of the program abstract syntax tree ast and the internal representation of the output values.the core part of the system is the content in white boxes includ ing three bidirectional transformations denoted with red dottedboxes.
the front end bidirectional transformation maintains theconsistency between the program and its ast including the parserwhich parses the program to the ast and the printer which printsthe updated ast back to the program in the original format withthe same white spaces.
the back end transformation maintains the figure quick sort figure student gradesconsistency between the output value and the html pages withhole closures including the html printer which prints the htmlpages and collects the hole closures and the html parser whichparses the html pages with hole closures to the output values.the core bidirectional transformation is the most critical bidirec tional evaluators including the forward evaluation and backwardevaluation.
the forward evaluation takes the ast and hole bindingsas input and returns the output values.
the backward evaluationtakes the updated output values and the original ast with holebindings as input and returns the updated ast with hole bindings.the core bidirectional transformation maintains the consistencybetween the ast with hole bindings and the output values.it should be noted that the parser and printer in the front endand back end bidirectional transformations are not special.
theframework has been implemented in bidirectional preview ba sically following the structure of sketch n sketch .
the mostimportant contribution of this paper is the crucial bidirectionalevaluation part which will be explained in detail in section .
the core bidirectional evaluatorsin this section we show how to tackle the most challenging partof the framework.
as discussed in the introduction we need to ad dress three issues de!ning operable output values for incompleteprograms updating holes with constants and updating programswith hole values.
in the following we shall address these issues by explaining the source programs to be developed and de!n ing evaluation rules for the forward evaluator and the backwardevaluator in the framework of bidirectional live programming forincomplete programs.
.
source programthe source program is written in a simple functional language almost the same as that in sketch n sketch with additionalholes.
it is a functional language with holes to denote blank codes.2157authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards bidirectional live programmingfor incomplete programsicse may pi t tsburgh pa usaexpressions e u1d462 u1d450 u1d465 .
u1d45d.
u1d452 u1d4521 u1d4522 u1d4521 u1d4522 u1d4521 u1d4522 let p e1e2 letrec p e1e2 if e1e2e3 case e p1 e1 constants c u1d45b u1d44f u1d460 u1d45b u1d45c pa erns p u1d450 u1d465 u1d45d1 u1d45d2 u1d45d1 u1d45d2 environment e u1d438 u1d465 uni21a6.endl u1d463values v ue dvdeterminate values dv c e .p.e v1 v2 v1 v2 hole name u n n u n u.nfigure syntaxfigure gives the syntax of the language.
in particular we de!nethe output of an incomplete program suitable for manipulation which addresses the!rst issue i.e.
the de!nition of operable outputvalues we mentioned.in our language expressions i.e.
programs include hole expres sions u1d462 u1d462is the hole name constants u1d450 variable u1d465 function ap plication u1d4521 u1d4522 apply function u1d4521to arguments u1d4522 list construction u1d4521 u1d4522 append the list u1d4522with the head element u1d4521 tuple u1d4521 u1d4522 let bindingslet u1d45d u1d4521 u1d4522 letrec bindingsletrec u1d45d u1d4521 u1d4522 conditionalsif u1d4521 u1d4522 u1d4523 and case expressionscase u1d452 u1d45d1 u1d4521 .
the de!nitionof constant includes numbers u1d45b booleans u1d44f strings u1d460 the emptylist and primitive operators.simply put a source program is an expression that has let bindings combined.
each expression can only access variables de !ned in the outer let bindings.
we have seen an example in theoverview and there are two more example programs i.e.quick sortshown in figure andstudent gradesshown in figure .
.
forward evaluatorthe forward evaluator computes the value of an expression whichexplains how the output we de!ned in the previous subsectionis obtained.
figure de!nes the evaluation rules whose namesare pre!xed with e of the forward evaluator which is standardand similar to that in sketch n sketch except for the evalua tion rules involving holes.
in this section we mainly explain theevaluation of holes in hole expressions function calls primitive op erations conditionals etc where the three different types of holesare generated.
the forward evaluation judgment uni03a3 u1d438 turnstileleft u1d452 u1d463states that the expression e evaluates to v under the environment u1d438and the hole bindings uni03a3.
.
.
two bindings.there are two bindings environment u1d438andhole bindings uni03a3 used in the forward evaluator.
as shown in figure9 environment u1d438is a variable value mapping that denotes the eval uation state.
u1d438 u1d465 uni21a6.endl u1d463denotes inserting the binding of u1d465with u1d463to u1d438.
hole bindings uni03a3maps pairs of hole names u1d462and environments u1d438to determinate values and its notation is the same as environments.example .
.consider the expressionx 1under the envi ronment u1d465 uni21a6.endl u1d438 and the hole bindings u1d465 uni21a6.endl uni21a6.endl uni03a3 .
the variable u1d465evaluates to according to u1d438and 1under u1d438evaluates to according to uni03a3.
squarein addition supplementary de!nitions of values and hole namesare as follows.
values v include determinate values u1d451 u1d463and holevalues u1d462 u1d438where u1d462means the hole name and u1d438means the closure.the de!nition of hole closures is the same as the environment which is a variable value mapping.
determinate values includeconstants u1d450 function closure u1d438 .
u1d45d.
u1d452 where u1d438binds free variablesin the body of the function.p.e list values u1d4631 u1d4632 and tuples u1d4631 u1d4632 .
hole names u1d462includes numbers u1d45brepresenting source holeexpressions numbers beginning with an asterisk u1d45brepresentingintermediate temporary hole values numbers joined with an un derscore u1d462 u1d45brepresenting hole instantiations and numbers joinedwith a dot u1d462.
u1d45brepresenting sub holes.
.
.
hole instantiations.the hole instantiations are generatedwhen evaluating the source hole expressions.
e hole is the sameas the evaluation rule of hole expressions de!ned by omar et al.
.
it says that when the pair consisting of u1d462and u1d438is not foundas a key in hole bindings uni03a3 the hole expression u1d462evaluates to ahole instantiation u1d462 u1d45b u1d438 where u1d45bmeans the nth instantiation ofthe hole expression u1d462and the environment u1d438as a closure attachesto it.
there is no hole binding when the developer has just!nishedthe initial incomplete program so all hole expressions evaluate tohole instantiations.e hole is different from the rule in previous work .
it saysthat if hole expression name u1d462binds a determinate value u1d451 u1d463inhole bindings uni03a3under the environment u1d438 it will evaluate to u1d451 u1d463.for example figure shows that uni210e1binds the value under theenvironment containing u1d450 u1d459 u1d44e u1d460 u1d460 u1d45a u1d44e u1d452 u1d460 etc .
therefore uni210e1assignedto u1d460 u1d45d u1d44e u1d450 u1d452 u1d45fevaluates to and the date of birth of kim evaluates to jan. 16th rather than the hole value .
.
.
sub holes.sub holes are new in our evaluation and theyare generated when hole values do pattern matching.
before adetailed explanation of that we show an example!rst where ahole decomposes to a list construction and matches with a listpattern to produce two sub holes.example .
.consider the function call .x .
the ar gument 1evaluates to 1 1 which decomposes to 1 1.
1 1. .
in particular 1 1. and 1 1. are sub holes of andmatch with i.e.
u1d465 to returns u1d465 uni21a6.endl 1 1. according tom cons explained later .
therefore the!nal result is 1 1. .
squarepattern matching is the process of matching values with struc tural patterns and binding values with corresponding variables inthe pattern.
the two key axioms in matching rules are de!ned asfollows.
the matching judgement u1d45a u1d44e u1d450 uni210e u1d45d u1d463 u1d438states that value u1d463matches with pattern u1d45dand the result is the matched bindings u1d438.
the rule m const says that a hole value u1d462 u1d438matches with anyconstant pattern u1d450and no binding is generated.
the rule m consis used when the value u1d463matches with the list pattern u1d45d1 u1d45d2.
ifthe decomposition of u1d463is u1d4631 u1d4632 u1d4631matches with u1d45d1to produce u1d4381and u1d4632matches with u1d45d2to produce u1d4382 r e s p e c t i v e l y .t h em a t c h e dbindings are the concatenation of u1d4381and u1d4382.2158authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pi t tsburgh pa usaxing zhang zhenjiang hu e const uni03a3 u1d438 turnstileleft u1d450 u1d450e var u1d438 u1d465 u1d463 uni03a3 u1d438 turnstileleft u1d465 u1d463e hole uni03a3 u1d462 u1d438 u1d451 u1d463 uni03a3 u1d438 turnstileleft u1d462 u1d451 u1d463e hole u1d462 u1d438 uni2209 u1d451 u1d45c u1d45a uni03a3 u1d45b u1d456 u1d460 u1d453 u1d45f u1d452 u1d460 uni210e uni03a3 u1d438 turnstileleft u1d462 u1d462 u1d45b u1d438e fun uni03a3 u1d438 turnstileleft.
u1d45d.
u1d452 u1d438 .
u1d45d.
u1d452 e app uni03a3 u1d438 turnstileleft u1d4521 u1d438 u1d453 .
u1d45d.
u1d452 u1d453 uni03a3 u1d438 turnstileleft u1d4522 u1d4632 u1d438 u1d45a u1d45a u1d44e u1d450 uni210e u1d45d u1d4632 uni03a3 u1d438 u1d45a u1d438 u1d453 turnstileleft u1d452 u1d453 u1d463 uni03a3 u1d438 turnstileleft u1d4521 u1d4522 u1d463e case uni03a3 u1d438 turnstileleft u1d465 u1d462 u1d438 u1d45b u1d456 u1d460 u1d453 u1d45f u1d452 u1d460 uni210e uni03a3 u1d438 turnstileleft u1d450 u1d44e u1d460 u1d452 u1d465 u1d45d u1d456 u1d452 u1d456 u1d456 .. u1d45b u1d45b u1d438e case uni03a3 u1d438 turnstileleft u1d465 u1d451 u1d463 u1d457.
u1d438 u1d45a u1d45a u1d44e u1d450 uni210e u1d45d u1d457 u1d451 u1d463 uni03a3 u1d438 u1d45a u1d438 turnstileleft u1d452 u1d457 u1d463 uni03a3 u1d438 turnstileleft u1d450 u1d44e u1d460 u1d452 u1d465 u1d45d u1d456 u1d452 u1d456 u1d456 .. u1d45b u1d463e fix uni03a3 u1d438 turnstileleft u1d452 u1d453 u1d456 u1d465 u1d452 u1d463 uni03a3 u1d438 turnstileleft u1d453 u1d456 u1d465 u1d452 u1d463e plus uni03a3 u1d438 turnstileleft u1d4521 u1d4621 u1d438 u1d45c u1d45f uni03a3 u1d438 turnstileleft u1d4522 u1d4622 u1d438 u1d45b u1d456 u1d460 u1d453 u1d45f u1d452 u1d460 uni210e uni03a3 u1d438 turnstileleft u1d4521 u1d4522 u1d45b u1d438figure evaluation rules of forward evaluatorm const u1d45a u1d44e u1d450 uni210e u1d450 u1d462 u1d438 m cons u1d463 trianglerightsld u1d4631 u1d4632 u1d45a u1d44e u1d450 uni210e u1d45d1 u1d4631 u1d4381 u1d45a u1d44e u1d450 uni210e u1d45d2 u1d4632 u1d4382 u1d45a u1d44e u1d450 uni210e u1d45d1 u1d45d2 u1d463 u1d4381 u1d4382the decomposition relation is de!ned using symbol trianglerightsld and u1d4631 trianglerightsld u1d4632states that u1d4631decomposes to u1d4632.
the determinate val ues decompose to themselves such as trianglerightsld .
the holevalue decomposes to a list construction with two sub holes writtenas u1d462 u1d438 trianglerightsld u1d462.
u1d438 u1d462.
u1d438.
.
.
temporary holes.to make the forward evaluator continuethe subsequent evaluation when it s stuck because of holes we usetemporary holes as result rather than proceeding around holes .in particular temporary holes are generated in the evaluation ofcase expressions e case and primitive expressions e plus .
it isimportant to note that guard expressions in case expressions onlyconsider the situation of a single variable more complex situationscan be achieved through syntactic sugar of function calls.the rule e case says that the case expression evaluates to atemporary hole value u1d45b u1d438when u1d465evaluates to a hole value.
theclosure of the temporary hole value is the environment u1d438 and u1d45bdoes not con ict with the names of the source hole expressions.the rule e plus is similar to e case which stops the forwardevaluation and returns a temporary hole value when encountersthat u1d4521or u1d4522evaluates to a hole value.
.
backward evaluatorin this subsection we explain how to address the second and thirdissues we mentioned at the beginning of this section i.e.
how toupdate hole expressions and how to update incomplete programswith hole values in the backward evaluator.the backward evaluator is the most important part of our ap proach.
it takes the original internal representation ast of theprogram with the hole bindings and the updated output valuesas the input and returns the updated ast and hole bindings.
thebackward evaluation judgment uni03a3 u1d438 turnstileleft u1d452 u1d463 prime leadsto uni03a3 prime u1d438 prime turnstileleft u1d452 primestatesthat when the output value updates to u1d463 prime t h ep r o g r a m u1d452updatesto u1d452 prime the environment u1d438updates to u1d438 prime and the hole bindings uni03a3updates to uni03a3 prime .the evaluation rules whose names are pre!xed with u of thebackward evaluator are de!ned in figure .
the backward evalu ation rules come in three categories replacement rules overwritevalues base constants function closures in the program with newones and update bindings of hole expressions propagation rules as the opposite of their corresponding forward rules propagate theupdated output to the whole evaluation process through variables applications conditionals etc primitive rules de!ne how to updateoperations on values and the evaluation policies are heuristic andcan be customized by domain experts.
.
.
replacement rules.replacement rules de!ne what can beoverwritten in the source program and how to update the holebindings.
there are three axioms for holes constants and functionclosures respectively.hole expressions.the rule u hole de!nes how a determinatevalue updates the hole expression like example .
.example .
.consider the programlet a in .
whenthe output value 1 1 u1d44e uni21a6.endl updates to rather than rewriting theprogram tolet a in the hole binding which binds pair u1d44e uni21a6.endl with is added to the hole bindings while the program re mains unchanged.
the hole binding means that the hole expression 1evaluates to when variable u1d44eevaluates to .
in the forwardevaluation with the updated hole bindings the program evaluatesto .
squarethe rule u hole says that if a determinate value u1d451 u1d463updates ahole expression u1d462 then the binding of pair u1d462 u1d438 with u1d451 u1d463is insertedinto the hole bindings or the original binding of u1d462 u1d438 is updated while the program remains unchanged.
the rule u hole de!neshow a hole value updates the hole expression like example .4example .
.consider the program in example .
.
if the outputvalue is a hole value 1 1 u1d44e uni21a6.endl the updated hole closure u1d44e uni21a6.endl willpropagate to the variable u1d44ethrough u fun.
therefore the programupdates tolet a in .
squarethe rule u hole says that if the output value is a hole value u1d462 prime u1d438 prime the domain of the updated hole closure is checked to see if2159authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards bidirectional live programmingfor incomplete programsicse may pi t tsburgh pa usau hole uni03a3 prime uni03a3 u1d462 u1d438 uni21a6.endl u1d451 u1d463 uni03a3 u1d438 turnstileleft u1d462 u1d451 u1d463 leadsto uni03a3 prime u1d438 turnstileleft u1d462u hole u1d451 u1d45c u1d45a u1d438 u1d451 u1d45c u1d45a u1d438 prime uni03a3 u1d438 turnstileleft u1d462 u1d462 prime u1d438 prime leadsto uni03a3 u1d438 prime turnstileleft u1d462u const uni03a3 u1d438 turnstileleft u1d450 u1d450 prime leadsto uni03a3 u1d438 turnstileleft u1d450 primeu const u1d451 u1d45c u1d45a u1d438 u1d451 u1d45c u1d45a u1d438 prime u1d4622 u1d456 u1d460 u1d453 u1d45f u1d452 u1d460 uni210e uni03a3 u1d438 turnstileleft u1d450 u1d4621 u1d438 prime leadsto uni03a3 u1d438 turnstileleft u1d4622u plus uni03a3 u1d438 turnstileleft u1d4521 u1d462 u1d438 uni03a3 u1d438 turnstileleft u1d4522 u1d451 u1d4632 uni03a3 u1d438 turnstileleft u1d4521 u1d451 u1d463 prime u1d451 u1d4632 leadsto uni03a31 u1d4381 turnstileleft u1d452 prime1 uni03a3 u1d438 turnstileleft u1d4521 u1d4522 u1d451 u1d463 prime leadsto uni03a31 u1d4381 turnstileleft u1d452 prime1 u1d4522u plus u1d451 u1d45c u1d45a u1d438 u1d451 u1d45c u1d45a u1d438 prime uni03a3 u1d438 turnstileleft u1d4521 u1d4621 u1d438 u1d45c u1d45f uni03a3 u1d438 turnstileleft u1d4522 u1d4622 u1d438 uni03a3 u1d438 turnstileleft u1d4521 u1d4522 u1d462 u1d438 prime leadsto uni03a3 u1d438 prime turnstileleft u1d4521 u1d4522u cons u1d463 prime trianglerightsld u1d463 prime1 u1d463 prime2 uni03a3 u1d438 turnstileleft u1d4521 u1d463 prime1 leadsto uni03a31 u1d4381 turnstileleft u1d452 prime1 u1d438 prime u1d4381 u1d438 u1d4382 uni03a3 u1d438 turnstileleft u1d4522 u1d463 prime2 leadsto uni03a32 u1d4382 turnstileleft u1d452 prime2 uni03a3 prime uni03a31 uni03a3 uni03a32 uni03a3 u1d438 turnstileleft u1d4521 u1d4522 u1d463 prime leadsto uni03a3 prime u1d438 prime turnstileleft u1d452 prime1 u1d452 prime2u fix uni03a3 u1d438 turnstileleft u1d452 u1d453 u1d456 u1d465 u1d452 u1d463 prime leadsto uni03a3 prime u1d438 prime turnstileleft u1d4521 u1d453 u1d456 u1d465 u1d4522 u1d452 prime u1d4521 u1d452 u1d4522 uni03a3 u1d438 turnstileleft u1d453 u1d456 u1d465 u1d452 u1d463 prime leadsto uni03a3 prime u1d438 prime turnstileleft u1d453 u1d456 u1d465 u1d452 primeu case uni03a3 u1d438 turnstileleft u1d465 u1d462 u1d438 u1d457.
u1d438 u1d45a u1d45a u1d44e u1d450 uni210e u1d45d u1d457 u1d462 u1d438 uni03a3 u1d438 u1d45a u1d438 turnstileleft u1d452 u1d457 u1d463 prime leadsto uni03a3 prime u1d438 prime u1d45a u1d438 prime turnstileleft u1d452 prime u1d457 u1d438 prime u1d45a turnstileleft u1d45d u1d457 u1d463 u1d457 u1d438 prime prime u1d438 prime u1d465 uni21a6.endl u1d463 u1d457 uni03a3 u1d438 turnstileleft u1d450 u1d44e u1d460 u1d452 u1d465 u1d45d u1d456 u1d452 u1d456 u1d456 .. u1d45b u1d463 prime leadsto uni03a3 prime u1d438 prime prime turnstileleft u1d450 u1d44e u1d460 u1d452 u1d465 u1d45d u1d456 u1d452 u1d456 u1d456 uni2260 u1d457 u1d45d u1d457 u1d452 prime u1d457 u app uni03a3 u1d438 turnstileleft u1d4521 u1d438 u1d453 .
u1d45d.
u1d452 u1d453 uni03a3 u1d438 turnstileleft u1d4522 u1d4632 u1d438 u1d45a u1d45a u1d44e u1d450 uni210e u1d45d u1d4632 uni03a3 u1d438 u1d45a u1d438 u1d453 turnstileleft u1d452 u1d453 u1d463 prime leadsto uni03a3 u1d453 u1d438 prime u1d45a u1d438 prime u1d453 turnstileleft u1d452 prime u1d453 uni03a3 u1d438 turnstileleft u1d4521 u1d438 prime u1d453 .
u1d45d.
u1d452 prime u1d453 leadsto uni03a3 u1d4381 turnstileleft u1d452 prime1 u1d438 prime u1d45a turnstileleft u1d45d u1d463 prime2 uni03a3 u1d438 turnstileleft u1d4522 u1d463 prime2 leadsto uni03a32 u1d4382 turnstileleft u1d452 prime2 u1d438 prime u1d4381 u1d438 u1d4382 uni03a3 prime uni03a32 uni03a3 u1d453 uni03a3 u1d438 turnstileleft u1d4521 u1d4522 u1d463 prime leadsto uni03a3 prime u1d438 prime turnstileleft u1d452 prime1 u1d452 prime2figure evaluation rules of backward evaluatorit s equal to the domain of the environment u1d438.
if the domains areequal u hole replaces u1d438with u1d438 primedirectly.
this is a key step forthe updated hole closure to affect updating the source program.as shown in example .
the updated hole closure has the samedomain as that of the original closure which is u1d44e .
in fact domainconsistency is an overly strict condition.
if the domain of e coverse there is no bad effect on backward evaluation.
however if thevariables in u1d438are missing in u1d438 prime it will cause a breakdown in back ward evaluation.
to simplify the problem in bidirectional preview there is no interface for adding or deleting bindings in context sothe domain of the environment is always consistent.constants.the backward evaluation rules of constants need toconsider the types of output values.
the rule u const says that when the output value u1d450updates to u1d450 prime the expression u1d450also updatesto u1d450 prime.
for example when the output of the expression updates to2 the expression updates to .
the rule u const de!nes how ahole value updates the constant expression like example .
.example .
.consider the programlet a in a. if theoutput value updates to a hole value 1 1 the program willupdate tolet a 1in a. squarethe rule u const says that when a hole value u1d4621 u1d438 primeupdatesthe constant expression u1d450 u1d450will be replaced with a hole expression u1d4622while the environment u1d438remains unchanged.
the hole name u1d4621and hole closure u1d438 primeare ignored because the hole value is generatedin the output without de!ning a closure.
u1d4622is a fresh hole namefor the new hole expression which is different from the names ofexisting holes.
the rule u const is the only way to add new holeexpressions to the program by modifying the output.
when a holevalue updates the determinate value in the output the hole valuewill ow through the entire evaluation process and only changethe!nal constant in the program like example .
.function closures.the function rule u fun not shown saysthat when the output value u1d438 prime .
u1d45d.
u1d452 prime updates the expression.
u1d45d.
u1d452under u1d438and uni03a3 .
u1d45d.
u1d452updates to.
u1d45d.
u1d452 primeand u1d438updates to u1d438 primewhile uni03a3remains unchanged.
u fun is important to propagate the changesin the environment to sub derivations.
.
.
propagation rules.propagation rules de!ne how the outputchanges ow throughout the whole derivation.
there are threeaxioms for variables function calls and conditionals respectively.function calls.the rule u app de!nes how to update functioncalls which follows the main idea in sketch n sketch exceptfor the hole bindings.there are four steps in u app u1d4521evaluates to the functionclosure u1d438 u1d453 .
u1d45d.
u1d452 u1d453 while u1d4522evaluates to u1d4632 then the pattern match ing between u1d4632and u1d45dreturns the matched bindings u1d438 u1d45a theoutput value u1d463 primeupdates the function body expression u1d452 u1d453under theconcatenation of u1d438 u1d45aand u1d438 u1d453with the original hole bindings uni03a3 then u1d452 u1d453updates to u1d452 prime u1d453 uni03a3updates to uni03a3 u1d453 and u1d438 u1d45a u1d438 u1d453updates to u1d438 prime u1d45a u1d438 prime u1d453 the function closure u1d438 prime u1d453 .
u1d45d.
u1d452 prime u1d453 updates u1d4521under u1d438and uni03a3 then u1d4521updates to u1d452 prime1 u1d438updates to u1d4381 and uni03a3remains unchanged whilethe updated output value u1d463 prime2updates u1d4522and the result is that u1d4522updates to u1d452 prime2 u1d438updates to u1d4382and uni03a3updates to uni03a32 merging u1d4381and u1d4382returns u1d438 prime while merging uni03a32and uni03a3 u1d453returns uni03a3 prime.
example4.
shows the four steps in practice.example .
.consider the function call x. awiththe environment u1d44e uni21a6.endl and the hole bindings .
its output is and then updates to .
in step u1d4521evaluates to u1d44e uni21a6.endl .
u1d465.
while u1d4522evaluates to and u1d438 u1d45ais u1d465 uni21a6.endl .
in step u1d452 prime u1d453is the same as u1d452 u1d453 i.e.
.
u1d438 prime u1d45a u1d438 prime u1d453is u1d465 uni21a6.endl u1d44e uni21a6.endl and uni03a3 u1d453is empty.
in step u1d4521remains unchanged.
the outputvalue updates uni03a3 u1d438 turnstileleft u1d4522to u1d44e uni21a6.endl turnstileleft u1d44e.s t e p r e c o n c i l e s u1d43812160authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pi t tsburgh pa usaxing zhang zhenjiang hu u1d44e uni21a6.endl and u1d4382 u1d44e uni21a6.endl with the original u1d438 u1d44e uni21a6.endl andreturns u1d44e uni21a6.endl because u1d44ein u1d4382is different with the one in u1d438.
squareenvironments merge and hole bindings merge are two key stepsto reconcile con icts between two sub derivations of u1d4521and u1d4522.a sfor environments merge if a variable appears free in both expres sions the traditional two way merge requires that it is updatedwith the same new value in both environments.
since two waymerge is too restrictive to make the backward evaluation work inmost scenarios we adapt the three way merge instead which isexplained in detail in sketch n sketch .
the three way mergeis able to handle con icts between u1d4381and u1d4382smoothly because itselects the value of the variable from u1d4381or u1d4382that is different fromthat in u1d438like the environments merge in example .
.
abstractly the three way merge implies that the updated value has a higherpriority to be used than the original value.as for hole bindings merge it simply unions two hole bindingsdirectly as shown in example .
.
the reason is that the updatedor inserted hole bindings in uni03a32and uni03a3 u1d453must be different becauseclosures of holes in u1d4522and u1d452 u1d453must be different.
the updated closuresof holes in u1d452 u1d453have the same domain as that of u1d438 u1d45a u1d438 u1d453 h o w e v e r i n u1d4522the updated closures of holes have the same domain as that of u1d438.example .
.consider the function call x.
.its output is and then updates to .
instep u1d438 prime u1d45a u1d438 prime u1d453is u1d465 uni21a6.endl and uni03a3 u1d453is u1d465 uni21a6.endl 2 1 uni21a6.endl .
instep uni03a32is uni21a6.endl .
according to the hole bindings merge uni03a3 primeis the union of uni03a3 u1d453and uni03a32.
squarecase expressions.the rule u case de!nes how to update a caseexpression of which the guard expression evaluates to a hole value like example .
.example .
.consider the expressioncase a of 2under the environment u1d44e uni21a6.endl 1 1 .
its output is through e case and then updates to .
at!rst u1d44eevaluates to 1 1 and triesto match with the!rst branch i.e.
.
then the output value 3successfully updates the branch expression to through u const .
finally the expression updates tocase a of 2with the environment and hole bindings unchanged.
otherwise if the output value fails to update the!rst branch the backwardevaluator will try the second branch .
squarethe rule u case says that when u1d465evaluates to a hole value thehole value tries to match with each pattern and the output valuetries to update the corresponding branch.
if the update success theupdated value u1d463 u1d457replaces the original binding of u1d465in u1d438 prime prime and theupdated branch expression u1d452 prime u1d457replaces u1d452 u1d457.variables.the rule u var is omitted and it just replaces theoriginal binding in the environment with the output value andthe expression remains unchanged.
for example when the outputvalue updates to u1d465 uni21a6.endl turnstileleft u1d465updates to u1d465 uni21a6.endl turnstileleft u1d465.
.
.
primitive rules.there are many strategies to update prim itive operations which can be tailored to different domains andproblems.
suppose the strategy is that the effect of backward eval uation on the source program is as small as possible.
here we useplus operation and list construction as examples.plus.in the rule u plus instead of updating u1d4522that originallyevaluates to a determinate value u1d451 u1d4632 the difference u1d451 u1d463 prime u1d451 u1d4632as theoutput value updates u1d4521 which originally evaluates to a hole value.example .
.consider the plus expression .
its outputvalue is through e plus and then updates to .
according tou plus u1d4522remains unchanged and the difference updates u1d4521.
through u hole the backward evaluator returns uni21a6.endl turnstileleft .
squarethe rule u plus says that when the output value is a hole value u1d462 u1d438 primeand u1d4521or u1d4522evaluates to a hole the environment u1d438is replacedby the hole closure u1d438 prime.there are many backward evaluation rules for other situations such as both u1d4521and u1d4522evaluate to hole values and the updatestrategies are somehow subjective so they are omitted.
in our im plementation each situation is handled only by a unique backwardevaluation rule so there is only a unique solution for the wholebackward evaluation and no ambiguity.
it is a better choice to pro vide multiple options like sketch n sketch however since thisis not what we focus on we didn t implement it in our tool.list construction.the rule u cons de!nes how to update alist construction like example .
.example .
.consider the expression under the envi ronment u1d44e uni21a6.endl 1 1 and the hole bindings uni21a6.endl .
itsoutput is through e hole and then updates to .
thehead of the output value updates the head of the list construc tion u1d44eto uni21a6.endl u1d44e uni21a6.endl 1 1 turnstileleft u1d44e.
the tail of the outputvalue updates the tail of the list construction to uni21a6.endl u1d44e uni21a6.endl 1 1 turnstileleft .
according to the three way merge the holebindings update to uni21a6.endl .
squarethe rule u cons says that the output value u1d463 primeshould decom pose to two sub values which update the head expression and tailexpression respectively.
the environments merge is the same asthat in u app while the hole bindings merge is different.
this isbecause there may be con icts in uni03a31and uni03a32.
we also adopt theprinciple that the updated value has a higher priority so the ruleu cons apply three way merge on hole bindings.
the values boundto holes in uni03a31or uni03a32that is different from that in uni03a3is selected to beinserted into the updated hole bindings uni03a3 prime.
.
.
recursion.since recursion is not discussed in sketch n sketch here is an explanation of our approach.
although recursionis not relevant with holes it is essential to the expressiveness of alanguage.the u fix rule propagates the output value u1d463 primeto the expandedexpression u1d452 u1d453 u1d456 u1d465 u1d452 which updates to u1d4521 u1d453 u1d456 u1d465 u1d4522 .
if u1d4521is differentfrom u1d452 then u1d4521is selected otherwise u1d4522is selected.
.
round tripping propertiesthe forward evaluation and the backward evaluation form a lens to maintain consistency betweensource ast of programs withhole bindings andview output with hole closures .
to ensurethe stability of the system the relationship of the forward evalu ation and the backward evaluation should satisfy round trippingproperties i.e.
getputand weakputget de!ned as follows.2161authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards bidirectional live programmingfor incomplete programsicse may pi t tsburgh pa usa figure the student modi f ies u1d45f u1d460 u1d45a u1d44e u1d459 u1d459 u1d452 u1d45fin hole 3to and u1d45f u1d460 u1d45a u1d44e u1d459 u1d459 u1d452 u1d45fin hole 5closure to .l m.sc m.sc .
getput .
if uni03a3 u1d438 turnstileleft u1d452 u1d463and uni03a3 u1d438 turnstileleft u1d452 u1d463 leadsto uni03a3 prime u1d438 turnstileleft u1d452 then uni03a3 prime u1d438 turnstileleft u1d452 u1d463and uni03a3 uni03a3 prime.l m.sc m.sc .
weakputget .
if uni03a3 u1d438 turnstileleft u1d452 u1d463 prime leadsto uni03a3 prime u1d438 prime turnstileleft u1d452 primeand uni03a3 prime u1d438 prime turnstileleft u1d452 prime u1d463 prime prime then uni03a3 u1d438 turnstileleft u1d452 u1d463 prime prime leadsto uni03a3 prime u1d438 prime turnstileleft u1d452 prime.the getputlemma requires that whenever the output has notbeen updated the same program and hole bindings as the originalone are obtained by backward evaluation.
however things are alittle different for the bidirectional evaluators in our approach.
ahole with a data structure decomposes to sub holes when it doespattern matching in the forward evaluation and it binds with thedata structure in hole bindings in the backward evaluation.
there fore uni03a3is a sub set of the updated hole bindings uni03a3 prime.
for example when hole u1d462 u1d438matches with u1d465 u1d465 u1d460 the binding of u1d462 u1d438with u1d462.
u1d438 u1d462.
u1d438is inserted into hole bindings.
it s easy to prove thatthe inserted hole bindings does not affect the forward evaluation i.e.
expression u1d452under u1d438and uni03a3 primestill evaluates to v.the weakputgetlemma requires that the output value u1d463 primeupdates the source program uni03a3 u1d438 turnstileleft u1d452to uni03a3 prime u1d438 prime turnstileleft u1d452 prime u1d452 primeunder u1d438 primeand uni03a3 primeevaluates to u1d463 prime prime u1d463 prime primeupdates uni03a3 u1d438 turnstileleft u1d452to the sameupdated program uni03a3 prime u1d438 prime turnstileleft u1d452 prime.
this property is important because itensures that u1d463 primeand u1d463 prime primeupdate the program to get the same result.we prove that the bidirectional evaluations with the three waymerge satis!es weakputgetwhen considering that there are noprimitive rules and the control ow remains unchanged in thebackward evaluation.
two applicationsin this section we usequick sortandstudent grades two nontrivialexamples to illustrate the usefulness of our system in algorithmteaching and program debugging.
.
quick sortsuppose that we are teaching the quick sort algorithm.
an incom plete program is given in figure where we de!ne a recursivefunction u1d45e u1d460 u1d45c u1d45f the auxiliary function u1d45d u1d44e u1d45f u1d456 u1d456 u1d45c u1d45bis used to screenout u1d460 u1d45a u1d44e u1d459 u1d459 u1d452 u1d45fand u1d44f u1d456 u1d454 u1d454 u1d452 u1d45fwith pivot as the boundary and u1d45e u1d460 u1d45c u1d45f isrecursively applied to u1d460 u1d45a u1d44e u1d459 u1d459 u1d452 u1d45fand u1d44f u1d456 u1d454 u1d454 u1d452 u1d45fand get u1d45f u1d460 u1d45a u1d44e u1d459 u1d459 u1d452 u1d45fand u1d44f u1d460 u1d45a u1d44e u1d459 u1d459 u1d452 u1d45f respectively.
now assume that we are not sure how toproduce the!nal result and we add a hole in line .
figure the bindings of hole1in quick sort.our system provides two convenient ways for students to un derstand the behavior of programs.
first they can see .
studentscan observe the context of each recursive call of quick sort throughthe context window.
second they can edit .
students can edit the context changing the unknown value to the one they expect.for example when students tell the system that sorting the list should yield which is initially unknown then the system willshow what the value should be for the hole in the context whichhelps them to guess what to!ll in the hole.suppose the student runs the incomplete quick sort program andgets the context table on the right in figure .
students may wishto view the nested hole e.g.
of the outer hole e.g.
so theycould click the subitem and jump to its context.
at this time thecontext table displays the content on the left in figure .
whichis the output in ui shows the click path r smaller .note that the selector in the context header is designed to showthe hole names in the output of the program so both table headersin figure show .
next it is easy for students to understandthat the function u1d45e u1d460 u1d45c u1d45f applied to u1d460 u1d45a u1d44e u1d459 u1d459 u1d452 u1d45flist results in so he she modi!es u1d45f u1d460 u1d45a u1d44e u1d459 u1d459 u1d452 u1d45fto in the context like figure .in the same way back to the closure of the outermost hole students know that u1d45f u1d460 u1d45a u1d44e u1d459 u1d459 u1d452 u1d45fshould be and modify thecontext again like the right context in figure .after students!ll in the hole in the context with the results theyexpected the hole bindings in figure are generated throughbackward evaluation.
with the second hole binding students knowthat when u1d45d u1d456 u1d463 u1d45c is and u1d45f u1d460 u1d45a u1d44e u1d459 u1d459 u1d452 u1d45fis the value of hole ex pression should be .
through observing the context of thesecond hole binding he she might have reasoned that the holeshould actually be the connection of and u1d45f u1d44f u1d456 u1d454 u1d454 u1d452 u1d45f.it is remarked that for a hole in the program our system providesdevelopers only with the value of the hole and its context as partof the output for one to modify it does not infer the code for thehole though developers may bene!t from the value and its contextto guess a possible code shape.
.
student gradesconsider that a teacher computes the students !nal grades at theend of the semester.
suppose there are only three students andthe teacher wants to score according to the weighted average ofhomework midterm and!nal.
he she writes the program in figure8 where the function u1d464 u1d452 u1d456 u1d454 uni210e u1d452 u1d451 u1d44e u1d463 u1d452 u1d45f u1d44e u1d454 u1d452applies to each student sscore in line .suppose that the program runs to get an incorrect output say .
the teacher does not know which part ofthe expression in line was wrong and he she doubts the valueat uni210e u1d464 u1d45f uni210e u1d464.
therefore he she changes the expression in line 19to u1d45a u1d456 u1d451 u1d45f u1d45a u1d456 u1d451 u1d452 u1d45f u1d45a u1d453 u1d456 u1d45b u1d45f u1d453 u1d456 u1d45b u1d44e u1d459and propagates the wrong2162authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pi t tsburgh pa usaxing zhang zhenjiang hu figure hole bindings of using to up date the program with a hole expressionoutput through backward evaluation to get the records in the holebindings window as shown in figure .
it is easy to know thatthe value and of the hole expression which is uni210e u1d464 u1d45f uni210e u1d464originally is wrong.
then the teacher observes the valueof uni210e u1d464 u1d45fand uni210e u1d464in the context of hole bindings and!nds that thevalue of uni210e u1d464 u1d45fshould be .
rather than .note that the purpose of turning a suspected expression intoa hole is to observe its context and value to be sure that they arewhat we want for this expression.
the example just shows themechanism of using our work for debugging in fact the teachermay choose to convert any expression into a hole not just uni210e u1d464 u1d45f uni210e u1d464.summary.these two examples and the example in section 2demonstrate the potential of our work in three areas web develop ment classic algorithms and program debugging.
these examplesare nontrivial and cover su cient language constructs such asconditionals function calls and recursions similar to loops .
efficiencywe have implemented the core bidirectional evaluators based onthe framework of bidirectional live programming for incompleteprograms in our tool bidirectional preview.
our implementationis written mostly in elm a functional language with about 000lines of code.to evaluate whether our framework is effective enough to givethe developers quick feedback after directly manipulating the out put we measured the running time in milliseconds of the variousparts of the framework on the nontrivial example table of states used in sketch n sketch .
the selected program has linesof codes written in the language we de!ned.
note that in practice an incomplete program is usually not long particularly in the liveprogramming setting.
we ve instrumented a timing mechanismin our implementation which can record running times for eachpart of our implementation such as times for parsing forward andbackward evaluations when our system is running.we use different numbers of hole expressions to indicate thedegree of incompleteness of the same program.
the more holesthere are the more incomplete the program is.
the holes wereintroduced into some entries of the input table for the selectedprogram which can be propagated to various places of the programduring evaluation.
the experiments include four settings with and holes.
we test up to holes because there are generallynot many holes in an incomplete program at one time in practicalprogramming.table shows a summary of our results averaged over trials.we con!rm that the uctuation range of most of the results is within5 .
the hn column shows the number of hole expressions inthe initial program.
the env merge column shows the runningtime of the environment merges while the hb merge columnshows the running time of the hole bindings merges.
env merge and hb merge are parts of backward evaluator and they areexplained in section .
.
.in table as the number of holes in the program increase from 1to the time difference of forward evaluation is within u1d45a u1d460 almostthe same as that of the complete program.
and it takes around thesame amount of time to parse and print code.
however with theincrease of holes the time difference of backward evaluation isgreater and the difference is up to u1d45a u1d460when there are holes.this is an acceptable increase compared to the time it takes to parsecode and html.
the time to parse html code has also increasedslightly and this is due to hole elements in the html page whichtake up some time.there is a difference between the complete program and theincomplete program in backward evaluation and the differenceincreases with the increase in the number of holes.
this is becausethe time of environments merge and hole bindings merge increasesand accounts for most of the running time of the backward evalua tion as can be seen from table .
in both merges values need tobe compared.
after adding holes into the de!nition of values thecomparison becomes more complicated because a hole value is car ried with a closure which can have nested hole values.
therefore the recursive comparison process is very time consuming.
related workour work on bidirectional live programming is much related tothe work on program sketching direct manipulation programmingsystem live programming and program debugging.program sketching.program sketching is a useful technique wheredevelopers express their high level insights using an incompleteprogram as a sketch and leave the low details to the computer tosynthesize .
justin et al.
propose abidirectional evaluationto propagate input output examples through partially evaluatedsketches.
it is a bidirectional evaluation of incomplete programs but there is a sharp difference from ours it propagates input outputexample constraints to the holes whereas our method propagatesoutput values back to the program.
in particular as our intentionis to directly manipulate the output of incomplete programs bothholes and their closures are editable in our method but not editablein .direct manipulation programming system.our approach is builtupon the bidirectional evaluation in sketch n sketch with asigni!cant extension from complete programs to incomplete pro grams.
in fact our framework is the!rst to perform direct manipu lation on incomplete programs which is in sharp contrast to thetraditional direct manipulation systems such as whichcan work on only complete programs.2163authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
towards bidirectional live programmingfor incomplete programsicse may pi t tsburgh pa usatable running time of bidirectional evaluationshnparse codeforward evalparse htmlbackward evalprintenv mergehb merge036.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.53hn number of holes in program env merge environment merge hb merge hole bindings mergeparse code refers to the parser in figure forward eval refers to the forward evaluator described in section .
parse htmlrefers to html parser backward eval refers to backward evaluato described in section .
print refers to printer in figure .live programming.live programming allows developers to editthe code of a running program and immediately see the effect ofthe code changes .
to deal with incomplete programs omaret al.
proposed to model incomplete functional programs asexpressions with holes.
inspired by this work we extend it from unidirectional to bidirectional .recently omar et al.
import hole expressions to de!ne atyped livelit calculus and the system continuously gathers closuresassociated with the hole that the livelit is!lling.
livelit helps de velopers with some special editing tools including colors tabulardata and diagrams through user de!ned guis to!ll holes in theprogram online.
essentially this approach is still unidirectional.although our work is also to!ll in the hole expressions we do itby editing the output and propagating it back to the program.program debugging.program debugging is related to backwardevaluationbecause when the output of the wrong test case is known backward evaluation can help to locate the wrong code fragments.for instance faddegon and chitil present an approach to algo rithmic debugging that builds a computation tree from the runtimevalue observations by adding annotations to suspected modules ofwhich the aim is to limit the scope of debugging.
as demonstratedin the paper our framework can be used for debugging where thesuspicious expression can be set as a hole and the observation inhole bindings and hole closures helps with decision making.
as ourfuture work we are interested in looking into the deep relationshipbetween algorithmic debugging and backward transformation ofincomplete programs.
conclusionwe present the!rst framework to support bidirectional live pro gramming for incomplete programs.
essentially it can be consid ered either as bidirectionalization of the technique of live program ming for incomplete programs or as an extension of the frameworkof bidirectional live programming from complete programs to in complete programs.
the challenge lies in the richer output ofincomplete programs which makes backward evaluation di cult.in particular the holes need much attention because they can beinstantiated many times and decomposed into sub holes duringevaluation.
we carefully design the algorithms for e cient bidirec tional evaluation and implement the tool bidirectional preview thatis shown to be useful to develop various html applications inter actively.
in addition we highlight the usefulness of bidirectionallive programming of incomplete programs in algorithm teachingand program debugging.
it is worth noting that although only func tional programs are considered in this paper the framework can beadapted to other programs such as imperative programs.