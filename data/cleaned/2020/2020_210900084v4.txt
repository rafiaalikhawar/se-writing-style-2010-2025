program merge conflict resolution via neural transformers alexey svyatkovskiy microsoft redmond wa usasarah fakhoury washington state university pullman wa usanegar ghorbani uc irvine irvine ca usa todd mytkowicz microsoft research redmond wa usaelizabeth dinella university of pennsylvania philadelphia pa usachristian bird microsoft research redmond wa usa jinu jang microsoft redmond wa usaneel sundaresan microsoft redmond wa usashuvendu k. lahiri microsoft research redmond wa usa abstract collaborative software development is an integral part of the modern software development life cycle essential to the success of largescale software projects.
when multiple developers make concurrent changes around the same lines of code a merge conflict may occur.
such conflicts stall pull requests and continuous integration pipelines for hours to several days seriously hurting developer productivity.
to address this problem we introduce mergebert a novel neural program merge framework based on token level three way differencing and a transformer encoder model.
by exploiting the restricted nature of merge conflict resolutions we reformulate the task of generating the resolution sequence as a classification task over a set of primitive merge patterns extracted from real world merge commit data.
our model achieves accuracy for merge resolution synthesis yielding nearly a performance improvement over existing semi structured and improvement over neural program merge tools.
finally we demonstrate that mergebert is sufficiently flexible to work with source code files in java javascript typescript and c programming languages.
to measure the practical use of mergebert we conduct a user study to evaluate mergebert suggestions with developers from large oss projects on real world conflicts they encountered.
results suggest that in practice mergebert resolutions would be accepted at a higher rate than estimated by automatic metrics for precision and accuracy.
additionally we use participant feedback to identify future avenues for improvement of mergebert.
ccs concepts software and its engineering software version control automatic programming .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
software evolution program merge ml4code acm reference format alexey svyatkovskiy sarah fakhoury negar ghorbani todd mytkowicz elizabeth dinella christian bird jinu jang neel sundaresan and shuvendu k. lahiri.
.
program merge conflict resolution via neural transformers.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
introduction collaborative software development relies on version control systems such as git to manage and track changes across a codebase.
in most projects developers work primarily in a branch of a software repository periodically synchronizing their code changes with themain branch via merges and pull requests .
when multiple developers make concurrent changes to the same line of code a merge conflict may occur.
merge commits occur frequently almost of all commits are related to a merge and up to of those commits result in conflicts.
resolving merge conflicts is a time consuming complicated and error prone activity .
to resolve a conflict developers must stop their workflow understand conflicting changes and identify a correct resolution.
the ideal way to resolve a conflict is not always clear and may require referring to project specification documentation or communicating with their peers about changes .
modern version control systems such as git utilize the diff3 algorithm for performing unstructured line based three way merge of input files .
thus it is the de facto tool for merging and identifying merge conflicts in software development.
this algorithm aligns the two way diffs of two versions of the code aandb with the common base o into a sequence of diff slots .
at each slot a change from either aorbis selected.
in cases where both aand bcontain changes relative to o in the same slot e.g.
on the same line there is a merge conflict.
standard merge algorithms cannot automatically determine the correct way to merge these conflicting changes.
in these cases developers must manually intervene in order to correctly resolve the conflicting code and complete the merge.arxiv .00084v4 nov 2022esec fse november singapore singapore svyatkovskiy fakhoury ghorbani mytkowicz dinella bird jang sundaresan lahiri over the past decade several approaches have been proposed to improve the detection and automatic resolution of merge conflicts .
some approaches use the abstract syntax trees asts or other representations of the source code to improve conflict resolution others use a data driven approach which uses deep learning to predict the correct merge .
researchers have also developed tools to help developers visualize and navigate the merge conflict resolution process and identified key needs of the developer community for effective tool support .
the sheer body of research dedicated to this problem represents a significant amount of time and effort.
despite these advancements none of these approaches have been widely adopted into practice and the git textual based detection algorithm remains one of the most commonly used merging approaches .
in an effort to address this we introduce mergebert a neural program merge framework based on token level three way differencing and a multi input variant of the bidirectional transformer encoder bert model .
we formulate the task of generating a merge conflict resolution sequence as a classification task over a set of primitive merge patterns extracted from real world merge commit data.
mergebert encodes all inputs that a standard diff3 algorithm takes two two way diffs of input programs as well as the edit sequence information then aggregates them for learning.
we train and then evaluate mergebert on and respectively real world historical merge conflicts and their associated manual resolutions from github repositories in javascript typescript java and c and find that it performs quite well with precision and accuracy always over over if the top three suggestions are considered .
further we compare mergebert to existing state of the art structured and semi structured merge approaches which are necessarily language specific and show that mergebert is able to provide resolution suggestions for more merge conflicts and the suggestions are correct i.e.
match the historical user manual resolution more often.
to better evaluate the resolutions generated by mergebert from users perspective in practice we also conduct a user study with developers from large oss projects.
we ask participants to evaluate if mergebert resolution suggestions are acceptable on a set of of their own real world conflicts.
results show that mergebert merge resolutions would be accepted in practice despite not always being syntactically identical to the historical user resolutions and we identify potential ways to improve mergebert and the merge conflict oracles used to evaluate neural program merge approaches.
we make the following contributions in this paper we introduce mergebert a novel transformer based program merge framework that leverages token level three way differencing and formulates the task of generating the resolution sequence as a classification task.
we evaluate mergebert against structured and semi structured program merge tools like jsfstm erge andjdime as well as neural program merge models .
we demonstrate that mergebert outperforms the state of the art achieving higher accuracy on merge resolution.
we present an empirical evaluation of the perceptions of mergebert resolutions with developers from large oss projects contributing the first user study in which developersuse and evaluate an automatic merge conflict resolution tool on their own real world conflicts.
we make available an online data package containing the test dataset of conflicts and user resolutions as well as the questions and responses gathered from our user study.
we also provide an online appendix with supplementary details and figures also uploaded with this submission .
motiv ating example we use a number of terms concepts and ideas throughout this paper.
to provide an intuition around how our approach works and concretely define terms and concepts we begin with a motivating example of a small but realistic merge conflict.
fig.
provides an example merge conflict in javascript which shows the result of merging two concurrent changes to the same javascript file.
fig.
a on the left shows the standard diff3 markers a.js o.js and b.js which demarcate the conflicting regions introduced by programs a baseo andbrespectively.
here orepresents the lowest common ancestor of programs aandbin the version control history.
we denote the program text of diff3 conflicting regions as a b o. the program text outside the conflicting regions prefix and suffix is common to all three programs versions.
normally conflicts files have the same name in different branches but to avoid confusion we name the original file in our example o.js and the two concurrently edited versions of this file a.js andb.js .a.js changes var x to let x and the to11 while b.js changes the 10to11and also adds an argument z. mergebert attempts to automatically resolve merge conflicts in two phases.
first mergebert represents each line level merge conflict instance at the token level which localizes conflicting regions.
intuitively mergebert converts the three line structured source texts into three sequences of tokens including space and line delimiters applies the standard diff3 algorithm to these token sequences and then reconstructs the merged document at line level.
fig.
b shows the result of applying this token level merge on fig.
a .
as a result of token level merge the whole let x max y string is cleanly merged becoming a part of the program prefix and is prepended to the program suffix.
second mergebert invokes an underlying neural model to suggest a resolution via classification for each token level conflicting region and replaces the conflict region with the suggestion from the model fig.
c .
observe that the resolution does not consist of any single line from eitheraorbsince both edits modify a common line in the base.
hence earlier neural approaches such as deepmerge that are restricted to picking entire lines from the conflict region would not be able to provide the resolution.
on the other hand structured merge techniques such as jsfstm erge by cannot resolve the conflict soundly as the conflict appears on a program statement which leads to side effects e.g.
syntactically incorrect code .
a token level merge can interleave edits within lines i.e.
tokens in which one edit does not conflict with another are trivially merged .
considera s edit of the var tolet keyword.
such non conflicting edits suffice to demonstrate the above.
token level diff3 is a syntactic merge algorithm and therefore cannot guarantee semantic orprogram merge conflict resolution via neural transformers esec fse november singapore singapore y 9z a.jslet x max y o.jsvar x max y var x max y z b.jsconsole.log x prefix suffix a line level conflict y 9z 0let x max y a.js11 o.js10 z b.js console.log x b token level conflict y 9z 0let x max y z console.log x c resolved merge figure example merge conflict represented through standard diff3 left and token level diff3 center and the user resolution right .
the merge conflict resolution takes the token level edit b. even syntactic correctness of the merged program.
however we observed that in practice syntactic correctness is preserved the majority of the time over .
likewise consider the token level conflict for the max function s arguments an appropriate model trained on javascript should easily deduce that taking the edit from b i.e.
z captures the behavior ofa s edit as well.
the suggested resolution gives an intuitive demonstration of how mergebert turns a complex line level resolution into a simpler token level classification problem.
background data driven merge dinella et al .
introduced the data driven program merge problem as a supervised machine learning problem.
a program merge consists of a tuple of programs a b o m where the base program ois the lowest common ancestor in the version history for programs aandb diff3 produces an unstructured line level conflict when applied to a b o and mis the merged program with the developer resolution incorporating changes made in aandb.
a merge may have multiple unstructured conflicts we define a merge tuple a b o m wherea b o correspond to the conflicting regions in a b ando respectively and mdenotes the resolution region.
given a set of merge tuples ai bi oi mi i ...n the goal of a data driven merge algorithm is to learn a function merge that maximizespn i 0merge ai bi oi mi.
throughout the text we will use notations a b o m to refer to the token level merge tuples.
dinella et al .
also provide an algorithm for extracting the exact resolution regions for each merge tuple and define a dataset that corresponds to non trivial resolutions resolutions where the developer does not drop the changes from one side of the merge.
further they provide a sequence to sequence encoder decoder based architecture where a bi directional gated recurrent unit gru is used for encoding the merge inputs comprising of a b o segments of a merge tuple and a pointer mechanism is used to restrict the output to only choose from line segments present in the input.
theirpaper suffers from two limitations.
first given the restriction on copying only lines from inputs their dataset did not consider merges where the resolution required token level interleaving such as the conflict in figure .
second their dataset consists of merge conflicts in a single language namely javascript.
our approach addresses both of these limitations.
merge conflict resolution as a classification task in this work we demonstrate how to exploit the restricted nature of merge conflict resolutions compared to an arbitrary program repair to leverage discriminative models to synthesize the merge resolution sequence.
we have empirically observed that the application of diff3 at token granularity enjoys two useful properties over its line level counterpart i it helps localize the merge conflicts to small program segments effectively reducing the size of conflicting regions and ii most resolutions of merge conflicts produced by token diff3 consist entirely of changes from aorboroor a sequential composition of afollowed by bor vice versa.
here and throughout the paper we will use lower case notations to refer to attributes of token level differencing e.g.
a b andoare conflict regions produced by diff3 at token granularity .
on the flip side a token level merge can introduce many small conflicts.
to balance the trade off we start with the line level conflicts as produced by the standard diff3 and perform a token level merge of only the segments present in the line level conflict.
there are several potential outcomes for such a two level merge at the line level a conflict free token level merge for example the edit from aabout let is merged since bdoes not edit that slot as shown in fig.
b .
a single localized token level merge conflict for example the edit from both aandbfor the arguments of max yields a single conflict as shown in fig.
b .
multiple token level conflicts such a case not illustrated above can result in several token level conflicts.esec fse november singapore singapore svyatkovskiy fakhoury ghorbani mytkowicz dinella bird jang sundaresan lahiri let x max y branch a branch o z branch b classification encoder aggregation embedding token x max y xmax y xmax y10 x max y z resolution decoding aeditlet x max y z o bencoder encoder encoderposition embedding token edit position embedding token edit position embedding token edit position figure an overview of the mergebert architecture.
from left to right given conflicting programs a bandotoken level differencing is performed first next programs are tokenized and the corresponding sequences are aligned a oando a b o ando b .
we extract edit steps for each pair of token sequences aoand bo .
four aligned token sequences are fed to the multi input encoder neural network while edit sequences are consumed as edit type embeddings.
finally encoded token sequences are aggregated into a hidden state which serves as input to classification layer.
token level diff3 applied to a tuple of programs a b o m would usually result in a set of localized merge tuples aj bj oj mj .
we empirically observe that of such resolutions mjare comprised of i exactly the tokens in ajor ii exactly the tokens in bj.
another .
of the resolutions are iii just the tokens in oj.
in addition of the resolutions are the result of concatenating iv ajandbjor v bjandaj.
finally .
comprise another four variants obtained by taking i ii ivandvabove and removing the tokens that also occur in the base oj.
in total this provides nine primitive merge resolution patterns see online appendix for more details about the primitive merge patterns .
we therefore treat the problem of constructing merge conflict resolutionsmjas a classification task to predict between these possibilities.
it is important to note that although we are predicting simple resolution strategies at the token level they may translate to complex resolutions at the line level.
in addition not all conflicts are resolved by breaking that conflict into tokens and applying these patterns some resolutions such as those introducing new tokens or reordering tokens are not expressible as a choice at the token level.
mergebert neural program merge framework mergebert is a textual program merge model based on the bidirectional transformer encoder bert model .
we refer the reader to codebert for a discussion on applying transformers to code.
a transformer like a recurrent neural network maps a sequence of text into a high dimensional representation which can later be decoded to solve downstream tasks.
while not originally designed for code transformers have found many applications in software engineering mergebert approaches merge conflict resolution as a sequence classification task given conflicting regions extracted with tokenlevel differencing and surrounding code as context.
the key technicalinnovation in mergebert lies in how it breaks program text into an input representation amenable to learning with a transformer encoder and how it aggregates various input encodings for classification.
in the standard sequence learning setting there is a single input and single output sequence.
in the merge conflict resolution task there are multiple conflicting input programs and one resolution.
to facilitate learning in this setting we construct mergebert as a multi input encoder neural network which first encodes token sequences of conflicting programs then aggregates them into a single hidden summarization state.
an overview of the mergebert model architecture is shown in fig.
.
given conflicting programs a bandowe first perform tokenization and then repeat the three way differencing at token granularity.
if a conflict still exists in this token level three way differencing we collect the token sequences corresponding to conflicting regions a b ando and compute pair wise alignments of a andbwith respect to the base o. finally for each pair of aligned token sequences we extract an edit sequence that represents how to turn the second sequence into the first.
the resulting aligned token sequences are fed to the multi input encoder neural network while the corresponding edit sequences are consumed as type embeddings.
finally the encoded token sequences are summarized into a hidden state which serves as input to the classification layer.
given a tuple of programs a b o m which contains tokenlevel merge tuples aj bj oj mj j ...n mergebert models the following conditional probability distribution p mj aj bj oj and consequently for entire programs p m a b o ny j 1p mj aj bj oj program merge conflict resolution via neural transformers esec fse november singapore singapore x max y x max y z figure an example edit sequence extracted between a pair of token sequences.
top row is o b bottom isb o and middle is bo.
padding symbols are introduced for alignment.
in this case the target token sequence is obtained by swapping a token and inserting two tokens.
independence of token level conflicts is a simplifying assumption.
however we observe that in our data set only of merge conflicts result in more than token level conflict per line level conflict.
.
context encoding for a merge tuple a b o m mergebert calculates two pair wise alignments between the sequences of tokens of conflicting regions a respectively b with respect to that of the original program o a o o a b o ando b. for each pair of aligned token sequences we compute an edit sequence.
these edit sequences aoand bo are comprised of the following editing actions kinds of edits represents equivalent tokens represents insertions represents deletions represents a replacement and is used as a padding token.
overall this produces four token sequences and two edit sequences a o o a and ao and b o o b and bo .
fig.
provides an example of an edit sequence.
each token sequence covers the corresponding conflicting region and potentially surrounding code tokens.
we make use of byte pair encoding bpe unsupervised tokenization to avoid a blowup in the vocabulary size given the sparse nature of code identifiers .
to help the model learn to recognize editing steps we introduce an edit type embedding.
we combine it with the standard token and position embeddings utilized in bert model architecture via addition.
.
merge tuple aggregation we utilize transformer encoder model eto independently encode each of the four token sequences of token level conflicting regions a o o a b o ando b passing corresponding edit sequences ao and boas type embeddings.
finally mergebert aggregates the resulting encodings into a single hidden summarization state h h x a o o a b o o b x e x x wheree x x are the encoded tensors for each of the sequences x a o o a b o o b and xare learnable weights.
after aggregation a linear classification layer with softmax is applied p mj aj bj oj softmax w h b the resulting line level resolution region is obtained by concatenating the prefix predicted token level resolution mj and the suffix.
finally in the case of a one to many correspondence between the original line level and the token level conflicts see appendix formore details and a pseudocode mergebert uses a standard beamsearch to decode the most promising predictions.
.
implementation details we utilize a pretrained codebert1model with encoder layers attention heads and a hidden state size of .
the vocabulary is constructed using byte pair encoding and the vocabulary size is .
we transfer the weights of the pretrained transformer encoder into the mergebert multi input neural network and attach a randomly initialized linear layer with softmax.
we then finetune the resulting neural network in a supervised setting for the sequence classification task.
input sequences for finetuning training cover conflicting regions and surrounding code i.e.
fragments of prefix and suffix of a conflicting region up to a maximum length of bpe tokens.
the backbone of our implementation is huggingface s2 robertamodel and robertaforsequenceclassification classes in pytorch which are modified to turn the model into a multi input architecture shown in fig.
.
we finetune mergebert with adam stochastic optimizer with weight decay fix using a learning rate of 5e batch size and backward passes per allreduce .
the finetuning training was performed on nvidia tesla v100 gpus with 16gb memory for hours.
in the inference phase the model prediction for each line level conflict consists of one or more token level predictions.
given the token level predictions and the contents of the merged file mergebert generates the code corresponding to the resolution region.
the contents of the merged file include the conflict in question and its surrounding regions.
afterward mergebert checks the syntax of the generated code with a tree sitter3parser and outputs it as the candidate merge conflict resolution only if it is syntactically correct.
research questions we pose the following research questions to evaluate the effectiveness of utility of mergebert.
rq how effective is mergebert in producing merge conflict resolutions?
we evaluate mergebert s performance of producting resolutions in terms of precision and accuracy of matching the actual user resolution extracted from real world merge resolutions.
we also provide a comparison mergebert to baseline approaches at both the line and token level and state of the art merge resolution approaches.
rq how well does mergebert perform across different languages?
one of our primary goals is to be able to work on multiple languages with minimal effort.
the core approach of mergebert is fundamentally language agnostic though a parser and tokenizer is required for each additional language .
we evaluate performance of mergebert across four languages and also compare the results of using four language specific models each trained on just one language to using one multi lingual model trained on the data from all four languages.
november singapore singapore svyatkovskiy fakhoury ghorbani mytkowicz dinella bird jang sundaresan lahiri rq how do different choices of context encoding impact performance of mergebert?
we conduct an ablation study of the edit type embedding to understand and evaluate the impact of our novel edit aware encoding on model performance.
rq how do users perceive mergebert resolutions?
we conduct a user study involving a survey of real world conflicts recently encountered by developers from large oss projects.
to understand how developers would use mergebert in practice we provide them with an interface to explore mergebert s conflict resolution suggestions in relation to their original conflicting code ask them evaluate suggestions and explain why they do or do not correctly resolve the merge conflict.
dataset the finetuning dataset is mined from over open source software repositories in multiple programming languages with merge conflicts.
it contains commits from git histories with exactly two parents which resulted in a merge conflict.
we replay git merge on the two parents to see if it generates any conflicts.
otherwise we ignore the merge from our dataset.
we use the approach introduced by dinella et al .
to extract resolution regions however we do not restrict ourselves to conflicts with less than lines only.
lastly we extract token level conflicts and conflict resolution classification labels introduced in section from line level conflicts and resolutions.
tab.
provides a summary of the finetuning dataset.
table number of merge conflicts in the dataset.
programming language development set test set c javascript typescript java the finetuning dataset is split into development and test sets in the proportion at random at the file level.
the development set is further split into training and validation sets in proportion at the merge conflict level.
ev aluation .
evaluation metrics we evaluate mergebert s performance of resolution synthesis in terms of precision and accuracy of string match modulo whitespaces or indentation to the user resolution extracted from real world historical merge resolutions.
this approach is rather restrictive as a suggested resolution might differ from the actual user resolution by for instance only the order of statements being semantically equivalent otherwise.
as such this evaluation approach gives a lower bound of performance.
we evaluate mergebert and compare it to baselines and existing approaches using two metrics precision at top k and accuracy at top k. since mergebert is a neural approach it may provide more than one suggestion which we rank according to the associated prediction probabilities.
in addition because we filter out resolutionsuggestions that are not syntactically valid it may provide no suggestions in rare cases.
accuracy at top indicates the percentage of total conflicts for which mergebert produces the correct resolution as its top suggestion.
precision at top indicates how often as a percentage the top suggestion is correct when the mergebert provides any suggestions at all.
as a concrete example if a tool produces a resolution suggestion for out of conflicts and of the suggestions matched the actual historical user resolution then the precision would be but the accuracy would be .
precision at top k indicates how often the correct resolution is found in the top k suggestions and accuracy at top k is analogous.
when top k is omitted from the metric name e.g.
just precision then k is .
.
baseline models .
.
language model baseline.
neural language models lms have shown great performance in natural language generation and have been successfully applied to the domain of source code .
we consider the generative pretrained transformer language model for code gpt c and appeal to the naturalness of software to construct our baseline approach for the merge resolution synthesis task.
we establish the following baseline given an unstructured line level conflict produced by diff3 we take the common source code prefix acting as user intent for program merge.
we attempt to generate an entire resolution region token by token using beam search.
as an ablation experiment we repeat this for the conflicts produced with the token level differencing algorithm fig.
shows details about prefix and conflicting regions .
.
.
deepmerge neural model for interleavings.
next we consider deepmerge a sequence to sequence model based on the bidirectional gru summarized in section .
it learns to generate a resolution region by choosing from line segments present in the input line interleavings with a pointer mechanism.
we retrain the deepmerge model on our typescript dataset.
.
.
jdime.
looking for a stronger baseline we consider jdime a java specific merge tool that automatically tunes the merging process by switching between structured and unstructured merge algorithms .
structured merge is abstract syntax tree ast aware and leverages syntactic information to improve matching precision of conflicting nodes.
we use the publicly available implementation and run jdime in semi structured mode.
.
.
jsfstmerge.
trindade tavares et al .
implemented jsfstm erge by adapting an off the shelf grammar for javascript to address shortcomings of fstm erge and modify its algorithm.
jsfstm erge allows for certain types of nodes to maintain their relative order e.g.
statements while others may be order independent e.g.
function declarations even when sharing the same parent node.
for cases where jsfstm erge produces a resolution not matching the user resolution we manually inspect the output for semantic equivalence e.g.
reordered import statements .
.
results rq how effective is mergebert in producing merge conflict resolutions?program merge conflict resolution via neural transformers esec fse november singapore singapore to evaluate mergebert we first compare it to other neural approaches and to diff3 .
to be comprehensive we evaluate at both the token level and the line level.
we then compare mergebert to existing state of the art structured and semi structured merge language specific merge approaches.
table evaluation results for mergebert and various neural baselines calculated for merge conflicts in typescript programming language test set.
the table shows top precision and accuracy metrics.
approach granularity precision accuracy lm line .
.
deepmerge line .
.
diff3 token .
.
lm token .
.
deepmerge token .
.
mergebert token .
.
as seen in tab.
language model baselines performance on merge resolution synthesis is relatively low suggesting that the naturalness hypothesis is insufficient to capture the developer intent when merging programs.
this is perhaps not surprising given the notion of precision that does not tolerate even a single token mismatch.
mergebert is based on two core components token level diff3 and a multi input neural transformer model.
the token level differencing algorithm alone gives a high top precision of .
with a relatively low accuracy of only .
i.e.
it doesn t always generate a resolution suggestion but when it does it is very often correct .
combined with the neural transformer model the accuracy is increased to a total of .
.
note as a deterministic algorithm token level diff3 can only provide a single suggestion.
deepmerge precision of merge resolution synthesis is quite admirable showing .
top precision.
however it fails to generate predictions for merge conflicts which are not representable as a line interleaving.
this type of merge conflict comprises only roughly one third of the test set resulting in an accuracy of only .
which is significantly lower than mergebert.
as an experiment we also evaluate the deepmerge model in combination with the token level diff3 .
this enables deepmerge to overcome the limitation of providing only resolutions comprised of interleavings of lines from the conflict region by interleaving tokens instead.
as seen in tab.
deepmerge with token granularity overall accuracy improves from .
to .
.
however this still falls short of mergebert with precision that is less .
vs. .
and accuracy that is less .
vs .
.
we also compared mergebert to state of the art structured and semi structured merge tools.
since both jdimeand jsfstm erge are language specific to compare against mergebert we use our dataset s corresponding language specific subset of conflicts leading to slightly different results for mergebert on java and javascript .
as can be seen from tab.
jsfstm erge only produces a resolution for .
of conflicts and when a resolution is produced by jsfstm erge it is only correct .
of the time yielding a total accuracy of .
.
this is in line with the conclusions of the creators ofjsfstm erge that semi structured merge approaches may not betable comparison of mergebert to jd ime and jsfstmerge semi structured merge tools.
the table shows the percentage of conflicts in which the tool produces a resolution the top precision of produced resolutions and the overall top accuracy of merge resolution synthesis.
jd ime evaluation is on a java data set and jsfstm erge is on a javascript data set.
approach language conf.
w res.
precision accuracy jdime java .
.
.
mergebert java .
.
.
jsfstm erge javascript .
.
.
mergebert javascript .
.
.
as advantageous for dynamic scripting languages .
because jsfstm erge may produce reformatted code we manually examined cases where a resolution was produced but did not match the user resolution our oracle .
if the produced resolution was semantically equivalent to the user resolution we classified it as correct.
to compare the accuracy of jdime to that of mergebert we use the java test data set introduced previously and complete the following evaluation steps jdimedoes not merge all conflicts and generates a resolution for .
of conflicts.
this is in line with related work reporting that as much as of files cannot be merged .
therefore first we identify the set of merge conflict scenarios where diff3 reports a conflict and jdime produces a non conflicted merge.
when comparing the jdimeoutput to the actual historical user performed merge conflict resolution we do not use a simple syntactic match.
as a result of its ast matching approach code generated by jdimeis reformatted and the original order of statements and other constructs are not always preserved.
in an effort to accurately and fairly identify semantically equivalent merges we use gumtree an ast differencing tool to identify and ignore semantically equivalent differences between jdimeoutput and the user resolution such as reordered method declarations.
when jdimeproduces a resolution it generates a semantically equivalent match .
of the time with an accuracy of .
.
rq how well does mergebert perform across different languages?
one goal of our approach is to be able to handle multiple languages with minimal effort.
for mergebert to be able to provide merge resolution suggestions for conflicts in a particular language it needs three things.
first a tokenizer in that language which allows us to split the source text into tokens for processing.
second a parser in that language which allows us to filter out syntactically incorrect merge resolution suggestions.
third a data set of merge conflicts and their user resolutions to train mergebert.
fortunately tokenizers and parsers for nearly any language are readily available e.g.
we use github s tree sitter for this and repositories that use a particular language can be easily identified e.g.
on github and mined for conflicts and resolutions.
we incorporated tokenizers and parsers into mergebert for javascript typescript java and c and gathered merge conflict data for these languages as described previously.
note that both comments and strings in these languages are represented as single tokens and can be quite long.
therefore we further split these tokens on whitespace.
tab.
shows the detailed evaluation results of mergebert broken down by language.
the top section of resultsesec fse november singapore singapore svyatkovskiy fakhoury ghorbani mytkowicz dinella bird jang sundaresan lahiri table detailed evaluation results for top monolingual javascript typescript java and c models and bottom multilingual mergebert model trained on all four programming languages.
the table shows precision and accuracy of merge resolution synthesis.
test train languages precision accuracy top top top top javascript js .
.
.
.
typescript ts .
.
.
.
java java .
.
.
.
c c .
.
.
.
javascript js ts c java .
.
.
.
typescript js ts c java .
.
.
.
java js ts c java .
.
.
.
c js ts c java .
.
.
.
shows performance when mergebert is trained on data for that specific language.
the bottom section shows performance for each language when mergebert is trained on a data set comprising data for all languages we term this the multilingual model .
note that for the language specific models performance is fairly consistent across all four languages with top precision ranging from .
to .
and top accuracy ranging from .
to .
.
we also find that over of mergebert suggestions are syntactically correct across all programming languages.
we had no a priori expectations of the performance of the multilingual model as it is trained on more data which could lead to improvement but it is not language specific which could lead to poorer results.
overall the multilingual variant of the model generates results that are just slightly below the monolingual versions.
thus performance on one language isn t improved by adding more data in other languages.
thus from a pragmatic perspective if one chooses to simplify their use of mergebert by training just one model instead of one model per language then the performance takes only a negligible hit.
rq how do different choices of context encoding impact performance of mergebert?
we conduct an ablation study on the edit type embedding to understand the impact of edit awareness of encoding on the model performance.
as shown in tab.
use of the edit type embedding improves mergebert from to .
table evaluation results for mergebert and the model variant without edit type embedding for merge conflicts in typescript programming language test set.
the table shows top precision and accuracy metrics.
approach precision accuracy w o edit type embeddings .
.
mergebert w edit type embeddings .
.
figure methodology to identify candidate conflicts for the user study.
table summary of projects in user study total number of conflicts per project number of conflicts evaluated in the study and the survey participants.
language project conflicts survey participants conflicts javaazure cosmosdb p1 azure sdk p2 applicationinsights p5 tsmakecode p7 vscode p9 c aspnetcore p18 efcore p20 roslyn p22 total projects user ev aluation .
user study design to better understand how mergebert performs in practice we ask developers about conflicts that mergebert is unable to correctly resolve.
since mergebert s resolution suggestions are evaluated against user resolutions using a verbatim string match modulo whitespace asking study participants to confirm identical resolutions predicted by mergebert is not informative.
therefore we extract conflicts where mergebert suggestions are not a direct match to the user resolution to determine what the limitations of the suggestions are and how they might be perceived in practice.
to build an oracle of merge conflicts and resolutions we identify open source projects hosted on github.
the selected projects are active with multiple contributors and contain a large number of conflict scenarios in one of the languages supported by mergebert.
tab.
contains a list of projects chosen.
for each project we follow the same steps outlined in section to extract candidate conflicts and user resolutions to use in the survey.
fig.
explains the methodology used to identify candidate merge conflicts.
we identify the set of conflicts mergebert is unable to correctly merge within the top suggestions .
from this set of conflicts we identify candidate conflicts to use as part of the user study.
we filter candidate files with the following criteria conflicts should have been recently resolved i.e.
at most within the past months.
participants may not retain the context needed to evaluate suggestions for older conflicts.program merge conflict resolution via neural transformers esec fse november singapore singapore files must have at most conflicts.
participants evaluate up to suggestions per conflict.
more conflicts may be too complex to evaluate within the interview time slot.
conflicts should be non trivial.
trivial conflicts such as those that only involve formatting changes or renames are manually excluded.
the determination of if a conflict was non trivial was manual and subjective informed by our belief that more substantive conflicts would lead to more insights in the user study.
for each candidate conflict identified we use the github api to identify authors for each of the conflicting branches and the resolved file.
authors with at least candidate merge conflicts are identified as potential survey participants.
our final pool of candidate participants consists of unique authors.
we recruit participants via email using contact information on github.
out of the contacted developers agreed to participate in the study.
all participants were professional software developers with at least years of experience working at large technology companies.
we asked participants to evaluate mergebert resolution suggestions for their own merge conflicts.
tab.
contains the final number of participants and conflicts evaluated in our study.
conflicts were evaluated c conflicts java and typescript.
.
.
mergebert interface.
we designed an online interface where participants can view their own conflicts and explore mergebert s resolution suggestions.
participants are asked to evaluate their own recently resolved merge conflicts and the corresponding generated resolution suggestions by mergebert.
the interface is customized based on the signed in participant and displays a list of their recently encountered merge conflicts.
participants can click through different resolution suggestions to evaluate if they are acceptable ways to resolve the merge conflict.
they can view their original resolution on the same page and if needed participants can navigate to the conflicting commit on github using a link if they need additional context.
they can also view a diff between the conflict file and any of the selected options resolution suggestion or user resolution .
participants use this interface to select one or more of the suggested resolutions indicate if the suggested resolution is acceptable and explain the reasons why or why not.
our online data package and appendix contain the questions images of the interface and participant responses.
.
.
protocol.
the user study was conducted as minute interviews remotely over microsoft teams using the interface we built.
first participants watched a video explaining mergebert and how to navigate conflicts and evaluate resolution suggestions using the interface.
then the participants evaluated a set of conflicts and submitted their responses.
one of the authors was on the teams call to help participants navigate the interface and ask any clarifying questions based on their evaluation of the mergebert resolution suggestions.
questions were iteratively developed based on two pilot interviews.
each interview was recorded for transcription and analysis.
.
user study results rq how do users perceive mergebert resolutions?using the interface participants evaluate the conflict resolution suggestions generated by mergebert and indicate if any of the suggestions were acceptable and explain why or why not.
there were no noticeable differences in the participants responses across different languages or projects so we do not break down our results by those dimensions.
participant s evaluations of the merge suggestions generally fall into three categories the merge suggestion is correct and would be used to resolve the conflict the merge is incorrect but the correct resolution would require an understanding of external context and the merge is incorrect and no external context is needed.
.
.
acceptable merge suggestions.
surprisingly of the conflicts included in the study participants indicated that at least one of the suggestions generated by mergebert was correct for of the examples.
by design the suggestions presented in the study are not syntactically equivalent to the participant s original resolution however they still indicated that the suggestion was a correct merge.
using participant responses we identify a few reasons why merge suggestions may be acceptable to a developer even if it is not syntactically equivalent to their original resolution semantically equivalent resolution of conflicts semantically equivalent resolutions include scenarios where the statements are re ordered equivalent changes made to naming or documentation and unneeded import statements or commented out code is preserved or removed.
one example in the study of conflicting changes that are both equally acceptable and one is arbitrarily accepted by the resolving author is when authors of conflicting branches renamed the same variable with a slight variation span target attribute name and span target app id attribute name .
in these cases either version selected by the merging algorithm might still be acceptable to the developer.
merge bertgenerated a suggestion to keep the variable name span target attribute name whereas the user resolution originally kept the other.
participant p5 marked this resolution as acceptable and semantically equivalent explaining that in this scenario they had no preference as to which one is better .
takeaway evaluating the performance of mergebert using strict syntactic approaches estimates a lower bound of performance.
survey results show almost of mergebert suggestions are acceptable merges that are semantically equivalent to the participant s original resolution.
mergebert s performance could be improved by considering semantic information for example to identify how changes related to naming or documentation should be merged.
tangled code changes in oracle resolutions for of the conflicts contained additional tangled changes that were unrelated to the resolution.
examples include renaming a method and adding a variable in the conflict region that is then used later outside the conflict region.
in all instances merge bertgenerates a suggestion that does not include the additional tangled code but is acceptable to the participant as a resolution of the conflict.
participants indicated that if they hadesec fse november singapore singapore svyatkovskiy fakhoury ghorbani mytkowicz dinella bird jang sundaresan lahiri access to the merge bertsuggestions they would select the correct resolution and then manually add the additional code.
takeaway when committing merged code developers may introduce changes unrelated to the conflict which are inadvertently included in conflict resolution oracles.
these changes can negatively impact model performance estimated with automatic metrics.
.
.
merge requires external context.
merge bertdid not generate an acceptable suggestion for of examples shown to survey participants.
participants were asked to indicate whether they resolved these examples using external context that cannot be inferred from the conflicting code regions and to explain what the external context was.
results indicate that of conflicts in the survey sample require external information not found in either conflicting file in order to be correctly resolved.
one example of external context is knowledge of linter rules enabled at a project level.
projects often require linter checks before code can be committed to the repository as a step towards improving the quality and maintainability of the source code.
one example is a merge conflict from roslyn where the correct resolution was to remove a null check from the code.
participant p23 explained the decision to remove the check the previousresults parameter is non nullable because c nullability checking is now enabled at the project level.
the null check is unnecessary .
in this scenario without specific knowledge of linter checks an automatic approach is unable to predict an accurate merge.
another example of external context is updates to languages rules that have cascading effects on existing code.
participant p22 from the roslyn project explained one such conflict changes were due to updates in using rules for the c language .
language updates in c version .
introduced an alternative syntax for the using statement and p22 s team had made to adopt this syntax.
p22 therefore updated this code involved in the conflict during the merge.
other examples of external context identified through the survey include removal of global dependencies from non conflicting files within a project rolling back features that shouldn t be included in a release branch and project level decisions to remove final modifiers for variables.
takeaway the local view of a conflict is sufficient to merge a majority of conflicts.
around of the conflicts require external information to correctly resolve.
one direction to improve mergebert is to consider external context as an additional information source for resolving conflicts.
.
.
unacceptable merge suggestions.
survey results show thatmerge bertsuggestions were incorrect for of the conflicts.
participants indicated that none of the conflicts required external context to be resolved.
we manually analyze the conflicts looking to identify patterns that may explain the incorrect merges for example affected language construct and type of conflict but do not identify any consistent patterns.
in summary existing automatic evaluation strategies estimate a lower bound of approach performance mergebert suggestions are correct for of conflicts included in our sample despite not being syntacticallyequivalent to the user resolution.
further suggestions from mergebert helped two participants find bugs in their own recent merge conflict resolutions!
this is in addition to those resolutions where mergebert does provide an exact match.
this finding suggests that automatic evaluation techniques that rely on a strict syntactic comparison between the user resolution and merge suggestion might be estimating a much lower bound of performance.
this highlights a discrepancy between how approaches are typically automatically evaluated and how developers may evaluate an approach in practice.
researchers should consider conducting user studies to more accurately evaluate approaches when feasible.
tools like mergebert can reduce effort and bug proneness involved in manually merging conflicts.
future studies should investigate these potential benefits.
.
related work there have been multiple attempts to improve merge algorithms by restricting them to a particular programming language or a specific type of applications .
typically such attempts result in algorithms that do not scale well or have low coverage.
syntactic merge algorithms improve upon diff3 by verifying the syntactic correctness of the merged programs.
several syntactic program merge techniques have been proposed which are based on parse trees or asts and graphs.
apel et al.
noted that structured and unstructured merge each has strengths and weaknesses.
they developed fstm erge a semistructured merge that alternates between approaches .
tavares et al.
implemented jsfstm erge by adapting an off the shelf grammar for javascript to address shortcomings of fstm erge and also modifying the fstm erge algorithm itself .
cavalcanti et al.
performed a large scale retrospective evaluation of semi structure merge on over merges and found that it can still suffer from false negatives cases where there is actually a semantic conflict but the merge approach produces a incorrect resolution .
they improve fstm erge by adding handlers that check for common false negative cases e.g.renames added