irfuzzer specialized fuzzing for llvm backend code generation yuyang rong peterrong96 gmail.comzhanghan yu hnryu ucdavis.eduzhenkai weng zweng ucdavis.edustephen neuendorffer stephen.neuendorffer amd.comhao chen chen ucdavis.edu advanced micro devices inc. university of california davis abstract modern compilers such as llvm are complex.
due to their complexity manual testing is unlikely to suffice yet formal verification is difficult to scale.
end to end fuzzing can be used but it has difficulties in discovering llvm backend problems for two reasons.
first frontend preprocessing and middle optimization shield the backend from seeing diverse inputs.
second branch coverage cannot provide effective feedback as llvm backend contains much reusable code.
in this paper we implement irfuzzer to investigate the need of specialized fuzzing of the llvm compiler backend.
we focus on two approaches to improve the fuzzer guaranteed input validity using constrained mutations to improve input diversity and new metrics to improve feedback quality.
the mutator in irfuzzer can generate a wide range of llvm ir inputs including structured control flow vector types and function definitions.
the system instruments coding patterns in the compiler to monitor the execution status of instruction selection.
the instrumentation not only provides new coverage feedback on the matcher table but also guides the mutator on architecture specific intrinsics.
we ran irfuzzer on mature llvm backend targets.
irfuzzer discovered new confirmed bugs in llvm upstream none of which existing fuzzers could discover.
this demonstrates that irfuzzer is far more effective than existing fuzzers.
upon receiving our bug report the developers have fixed bugs and back ported five fixes to llvm which shows that specialized fuzzing provides actionable insights to llvm developers.
index terms fuzzing llvm software analysis i. i ntroduction modern compilers such as llvm are complex software.
for example llvm consists of over seven million lines of c c code contributed by more than developers.
given the size of this codebase and its importance in the computing ecosystem an effective scalable verification method is critical.
despite extensive testing latent bugs remain and their impact on users can be quite significant given the widespread distribution and long lifetime of compilers.
to reduce latent bugs various techniques have been used to automate the verification of compilers such as partial model checking fuzzing and differential testing .
although end to end formal verification of compilers has been applied these techniques have not yet scaled to practical compilers such as llvm which supports a wide range of architectures programming languages and use models.
in the specific case of llvm another factor making verification difficult is that the interface between compiler optimization and machine code generation is widely used butnot completely specified.
as a result it can be difficult for backend developers to understand whether they have completely implemented the wide range of possible inputs.
in addition backends often differ greatly in their relative code maturity including some targets that are relatively mature and other targets for new devices that are in active development.
we find that the state of the art fuzzers failed to find new bugs of a compiler backend for various reasons.
generalpurpose fuzzing techniques such as afl often do not consider input validity and struggle to explore control paths in the compiler backend since most binary strings are invalid compiler inputs.
in order to test the compiler backend more effectively we aim to generate llvm intermediate representation llvm ir that complies with the language reference.
llvm includes llvm opt fuzzer and llvm isel fuzzer which generate valid ir for middle end and backend fuzzing respectively .
both of them are based on the library fuzzmutate for valid ir mutation.
however fuzzmutate can t construct complex control flows and only generates a few instructions with scalar types.
on the other hand end to end fuzzing tools such as csmith and grayc test the whole pipeline of the compiler but they cannot explore control paths in the compiler backend efficiently.
csmith does not take any feedback from the compiler which contributes to its ineffectiveness.
a more fundamental reason is that front end parser and middle end optimizations may limit the set of features seen by the compiler backend.
high level languages such as c may not exercise all backend features in llvm.
therefore even if grayc used branch coverage feedback from libfuzzer it missed many backend bugs introduced before llvm which were found by us.
as a result when a new language such as rust is introduced new backend bugs may still arise .
generating valid ir is challenging with three major difficulties.
in order to generate a complex control flow graph cfg we have to maintain all data dependencies to avoid use before definition situations.
a valid cfg can be easily invalidated by a jump as shown in figure .
this challenge does not exist in c generation as long as one does not generate goto statements.
besides modelling the instructions missing in fuzzmutate isn t trivial.
we must make sure that the types of the operands in each ir instruction match but enumerating the large numbers of natively supported vectorarxiv .05256v2 jul 2025types is infeasible.
finally it is difficult to model intrinsic functions for all architectures as intrinsics are often poorly documented and vary from architecture to architecture.
we also observe that afl s feedback mechanism performed poorly when testing the backend.
it uses branch coverage as feedback which runs into severe branch collision problems when fuzzing large code bases such as llvm.
naively increasing the branch counting table size introduces huge overhead .
a more fundamental reason is that much code generation logic in the llvm backend is implemented using table driven state machines.
a matcher table encapsulates all possible states as a constant byte array meaning that branch counting can t observe this logic during fuzzing.
the fuzzer needs a better feedback on whether the seed is interesting or not.
if the seed is not interesting the feedback should also inform the mutator what type of input is desired.
to address these issues we design a specialized fuzzer irfuzzer for fuzzing the llvm compiler backend.
figure shows the overall structure of irfuzzer.
we first design a mutator that generates valid ir section iii a .
we maintain the domination relation in a cfg during mutation by inserting subgraphs scfg into the existing cfg as shown in figure 2c.
we also use a descriptive language to list the requirements of each instruction type.
this approach ensures that inputs to the compiler backend are always valid increasing the efficiency of fuzzing.
our work expands fuzzmutate to include special handling by compiler backends such as multiple basic blocks with complex control flow function calls intrinsic functions and vector types.
using irfuzzer we are able to generate a wider range of instructions and explore control paths in the compiler backends more efficiently.
then we introduce a new coverage metric section iii b by instrumenting the table driven state machines in llvm enabling the design space to be more efficiently explored.
new entries covered in the matcher table indicate that new features are executed.
working together with branch coverage they provide better feedback on whether a seed is interesting.
furthermore the matcher table contains all the information about the instructions and intrinsics in one architecture.
as a result we use the matcher table to determine which instructions and intrinsics haven t been fuzzed.
we design a feedback loop from the matcher table coverage to our mutator.
irfuzzer periodically sends to the mutator a coverage report containing the states that haven t been executed to guide mutations.
this allows irfuzzer to test on different backends with no prior knowledge of the architecture.
we evaluated irfuzzer on mature backend architectures in llvm section v .
our results show that irfuzzer is more effective than the state of the art fuzzers afl and grayc.
irfuzzer generated inputs code with better branch coverage and matcher table coverage on all llvm backends.
leveraging these techniques we were able to find and report new bugs in llvm of which all have been confirmed have been fixed and five have been back ported to llvm .
this demonstrates the high impact on improving the correctness of llvm backend targets.this paper uses llvm to demonstrate the importance of having a specialized fuzzer for the compiler backend.
since modern compilers have similar intermediate representations we expect that our approach can apply to other compilers without requiring heavy engineering efforts.
we made the following contributions in this paper we designed and implemented irfuzzer.
to the best of our knowledge irfuzzer is the first backend fuzzer that uses matcher table coverage feedback to guide mutation.
we compared irfuzzer with other state of the art fuzzers on llvm upstream and found it to be the most effective on matcher table coverage.
we carefully analyzed and categorized the bugs we found during our testing.
in total we discovered confirmed new bugs in llvm of which have been fixed and five have been back ported to llvm .
ii.
b ackground a. llvm llvm is a mature compiler framework consisting of many components that can be targeted to different architectures.
at its core lies the llvm intermediate representation llvm ir which serves as a target independent abstraction separating the concerns of high level programming languages from the low level details of particular architectures.
llvm can be roughly partitioned into three layers.
the frontend such asclang translates programming languages to llvm ir including lexer parser ast transformation etc.
the middleend called opt processes llvm ir and performs code analysis and many common target independent optimizations.
the backend called llc converts llvm ir to a targetspecific machine code representation and eventually assembly code for the target architecture.
the llvm backend supports multiple target architectures through a plug in abstraction and the code to support a target architecture typically involves the implementation of api functions to describe common aspects along with target specific code to implement more unusual concepts.
the llvm ir describes a static single assignment ssa form with a fixed set of instructions.
instructions are strongly typed and the type of each value must match between its definition and all uses.
a wide range of types are supported including integers with arbitrary bitwidth floating point values pointers vectors and other aggregate types.
as with most high level languages llvm ir allows the definition of functions and the control flow between functions is implemented using the call instruction.
architecture specific intrinsics have no corresponding ir instructions but are represented as function calls at ir level.
control flow within a function in llvm ir is represented using basic blocks and branch instructions.
special phi instructions allow instructions in a basic block to refer to values defined in other basic blocks.
therefore phi instructions must respect control flow constraints and may only refer to values defined in predecessor blocks.
this domination constraint fig.
overview of irfuzzer.
green shaded components are the contributions of this paper orange shaded components are afl and blue shaded components are from llvm.
we created an llvm ir mutator that guarantees the correctness of the generated input section iii a .
we introduced a new coverage metric to track the backend code generation while guiding the mutation module section iii b .
b1 b2 b3 a original cfg b1 b2 b3 b incorrect mutation randomly adding an edgeb1 b2entry scfg b2exit b3 c correct mutation splitting node and adding scfg fig.
examples of incorrect and correct cfg mutations.
figure 2a is the original linear cfg.
figure 2b naively adds an edge from b1 to b3.
after that b2 no longer dominates b3 so every value defined in b2 and used in b3 may cause use beforedefinition error.
figure 2c breaks b2 into an entry and an exit node and inserts an scfg between them.
this guarantees that b2 still dominates b3.
means that techniques used in high level language generation cannot be easily adapted to llvm ir.
the process of instruction selection in the llvm backend replaces target independent llvm ir instructions with target specific machine code instructions.
llvm provides two different frameworks to implement instruction selection that may be leveraged by the target backend plug in.
selectiondag is the more mature instruction selection framework and is leveraged by all targets.
in selectiondag the code in each basic block is converted into a directed acyclic graph dag representing the data dependency between instructions and instruction selection is performed on the dag.
since selectiondag processes each basic block independently it can miss opportunities for optimization across basic blocks.
globalisel is a newer framework that is only leveraged by some targets.
globalisel preserves the basic block structure within a function during instruction selection enabling more optimization opportunities.
b. coverage guided fuzzing american fuzzy lop afl an open source fuzzing framework implements coverage guided fuzzing.
it instruments the program under test put with the ability to track control flow coverage.
when an input increases code coverage afl stores it in a seed cache and mutates it to generate new inputs.
this strategy allows afl to explore different controlflow paths of the put efficiently.many variations of coverage guided fuzzing have been developed with the goal of finding bugs more efficiently by exploring a wider range of program behaviors with future executions of the put .
there are studies on the impact of different feedback algorithms .
different methods are proposed to prioritize seeds to improve the performance of fuzzing.
.
some fuzzers target specific bugs and libraries .
more advanced mutation strategies also show better fuzzing performance compared with random mutation .
many improvements have been implemented in afl making it a good framework for further development.
fuzzing not only finds bugs but also helps program understanding .
llvm also introduces its own coverage guided fuzzing framework libfuzzer coupled with fuzzmutate it can be used to fuzz llvm backend.
however fuzzmutate only generates a limited type of code and is not under active development.
still the framework provides us with helpful insights into how should we mutate llvm ir.
iii.
d esign we design irfuzzer with two new components.
figure shows the new components of irfuzzer.
during the mutation stage we first generate a function if there isn t one section iii a1 .
then we change the control flow graph cfg to create more control flows section iii a2 .
finally we generate new ir instructions and mutate them section iii a3 .
af 1define i64 f i32 zeroext i x i32 v noinline 2entry ret p alloc i64 ret load i64 ptr ret p ret i64 ret listing a piece of llvm ir program generated by function generation section iii a1 .
the function returns a bit integer so we allocate a stack memory and load from it to return.
we will fill the memory in later mutations.
1define i64 f i32 zeroext i x i32 v noinline 2entrysrc ret p alloc i64 switch i32 i label scfg default i32 label scfg 1 6scfg default br label entrysink 7scfg 1 br label entrysink 8entrysink ret load i64 ptr ret p ret i64 ret listing ir program mutated from listing .
line to are introduced by scfg insertion section iii a2 .
we insert scfg by splitting the entry block into two and generating a switch instruction.
1define i64 f i32 zeroext i x i32 v noinline 2entrysrc ret p alloc i64 switch i32 i label scfg default i32 label scfg 1 6scfg default i64 zext i32 i i64 br label entrysink 8scfg 1 i1 add i32 i j64 call f i32 i1 x i32 v br label entrysink entrysink phi phi i64 store i64 phi ret p ret load i64 ptr ret p ret i64 ret listing ir program mutated from listing .
instruction insertion section iii a3 generates line and .
the placeholder memory is also used by phi to avoid undefined behavior line .
fig.
an example of how irfuzzer mutates a module using different strategies.
ter the mutation stage we create a new method to measure the coverage of the program section iii b .
although irfuzzer borrows from fuzzmutate and other tools all the components described in this section are novel unless otherwise noted.
a. llvm ir mutation to generate a wide variety of input while avoiding invalid inputs we adopt a mutation based strategy.
this strategy starts with small valid seed inputs and modifies the seed inputs in ways that should also generate valid inputs.
by randomly selecting between a number of small well defined mutations we expect to eventually generate a broad class of valid inputs while avoiding invalid inputs.
figure shows an example of our mutator in practice.
we first generate an empty function if none is present listing .
then we mutate the control flow byscfg insertion listing .
finally we modify or insert instructions in basic blocks listing .
function generation the llvm backend has many target specific code related to function calls.
as a result it is important to generate a wide range of function definitions and function calls with different arguments and return types.
irfuzzer implements a mutation strategy capable of generating new function definitions with arbitrary arguments and return types.
one important constraint is that the return type of the function signature matches the type of each return instruction in the function definition.
to ensure this irfuzzer synthesizes a load instruction of an appropriate type as the operand for a return instruction.
although the value returned from the load may be uninitialized later mutations may store values to the memory validating the return value.
irfuzzer also implements a mutation strategy to generate newcall instructions that refer to specific function declarations.
the mutator is free to select from any declared functions and generate compatible arguments and return values for the call as with any other primitive instruction.
intrinsic functions are target specific operations that correspond to complicated machine instructions so generating them will increase the code we can test.
yet they are treated as functions at middle end.
in particular this mutation strategy will also select intrinsic functions to call.
function attributes can impact backend behavior.
these attributes are often set by the compiler frontend and middle end to optimize the code.
for example noinline can change how a function is treated during code generation.
llvm categorizes attributes into function attributes argument attributes and return value attributes.
to demonstrate irfuzzer s potential we include attributes in irfuzzer.
most attributes do not affect the validity of the program.
however we need to model the contradicting ones to ensure that they do not appear at the same time such as optforfuzzing and optimizeforsize .
cfg mutation generating diverse cfgs is necessary to test llvm backends.
many machine code optimizations restructure control flow.
in addition certain compiler optimizations may select specific jump instructions but this optimization can only be performed after instruction selection when the code size and alignment are known.
for instance a common compiler optimization is to first select jump instructions in a short form with a limited offset range and then only replace the short form with a long jump instruction if a larger offset is required.
a challenge in mutating cfgs is how to preserve the dominator constraints.
naively inserting and removing arbitrary edges in a cfg may violate dominator constraints between basic blocks which may cause use before definition.
for example starting from the cfg in figure 2a after we add an edge b2no longer dominates b3in figure 2b.
if b3uses any value defined in b2 the program will cause a use before definition error if it follows the new edge.
to overcome this problem irfuzzer inserts sub control flow graphs scfg as shown in figure 2c to maintain dominator constraints.definition .
a sub control graph scfg is a cfg with a single entry block and a single exit block.
the exit block must have a single outgoing edge and all the other blocks must either branch to another block in this scfg or return .
definition .
a block sdominates a block tifsprecedes ton all the reachable paths ending in t. theorem .
let block sdominate block t. letbbe a block andcbe an scfg.
then after we split bintobentry and bexitand insert cbetween them sstill dominates t. proof.
before we insert c since sdominates t sprecedes t on every reachable path ending in t. letp s t be such a path.
after we insert c if no block in cis inserted between sandtonp then pdoes not violate the property that sdominates t. if some blocks in care inserted between sand tonp then pbecomes one or more new paths p s bentry centry c cexit bexit t where c represents a sequence of blocks in c. if no block in c contains a return then sstill precedes tonp .
on the other hand if any block in c contains a return thentis not reachable on p .
in both these cases p does not violate the property that sdominates t. theorem guarantees that splitting a block and inserting an scfg between them preserves dominator constraints.
based on this property irfuzzer mutates cfg in the following steps.
irfuzzer selects a block and a non terminating instruction inside it as the split point.
irfuzzer splits the block into an entry block containing all the instructions before the split point and an exit block containing all the remaining instructions.
then it randomly generates a branch orswitch instruction as the entry block s new terminating instruction.
irfuzzer creates empty blocks as the destinations of thebranch orswitch instruction created in the previously step.
for each empty block irfuzzer randomly selects branch switch orreturn as its terminator.
if irfuzzer selects branch orswitch it either routes the control flow to the exitblock or creates a self loop.
instruction modeling and generation a key aspect of the llvm backend is to convert the wide range of llvm ir types to the usually small set of types natively implemented by each target architecture.
therefore to exercise all the features of code generation it is necessary to generate ir instructions with as many data types as possible.
much of the compiler backend handles ir instructions with vector types but fuzzmutate modelled only scalar types.
to overcome fuzzmutate s limitations we rewrite its modelling as shown in table i. we not only include vectors as allowed types but also model vector operations and casting operations.
these definitions are reflected in the code as declarations expressing both restrictions on the types of operands and constraints between the types of different operands.
forexample the anyintorvecint constraint restricts the valid types for a particular operand to be any integer type or vector of integer type.
this allows us to model vector operations such as extractelement insertelement and shufflevector which were unsupported by fuzzmutate.
in addition store andload memory operations are structured differently enough from other operations that modeling them declaratively is unnecessary.
some other instructions have constraints which are too complex so we resort to custom generators.
for instance instructions representing phi nodes must be created with a number of operands equal to the number of predecessor blocks and must occur at the start of their basic block.
similarly call instructions are handled manually since we must select a function declaration and find values that exactly match the operand types of the declaration.
when generating a new instruction we first randomly select an opcode and use the declarations to randomly select values that exist in the code with a compatible type.
to ensure that values are defined before they are used the mutator searches for values defined in the following locations global variables function arguments values in dominators and values defined by previous instructions in the same basic block.
if no value with a compatible type exists then the mutator can either generate a poison or generate a load from a pointer if one exists.
when generating instructions the mutator may allocate new stack memories as placeholders.
to avoid undefined behaviors the mutator will again attempt to replace loads from these placeholders with other values of a compatible type.
if no such value exists then the mutator will store a value into the placeholder location.
we model no intrinsic functions as they vary from architecture to architecture potentially consuming much time with little outcome.
instead we rely on the feedback from matcher table coverage section iii b2 which shows the intrinsics that haven t been generated yet.
the mutator will then randomly generate callinstructions to those intrinsics.
instruction shuffling changing instruction orders inside a basic block will change how the backend schedules instructions.
when shuffling instructions we must carefully handle instruction orders otherwise a use before definition may arise.
we use topological sort to ensure that for each define use relation define precedes use after instruction shuffling.
b. matcher table feedback matcher table instrumentation llvm uses patterns to describe rewrite rules applied during instruction selection.
some simple patterns replace a single llvm ir instruction with a single machine instruction.
more complex patterns may replace multiple llvm ir instructions or generate multiple machine instructions.
patterns may also apply in specific situations by including complex predicates.
for example a pattern may only apply when a particular operand is a constant or a certain hardware feature is enabled.
most patterns are described declaratively in an llvmspecific language called tablegen .
to optimize the ap table i extended instruction modeling for ir instructions.
note that fuzzmutate only implements binary and bitwise operations with no vector support.
operation type opcode argument descriptions unary operation fneg anyfloatpointorvectorfloatpoint binary operationsadd sub mul s u div rem anyintorvecint sameasfirst fadd fsub fmul fdiv frem anyfporvecfp sameasfirst bitwise operations shl lshr ashr and or xor anyintorvecint sameasfirst vector operationsextractelement anyvector anyint insertelement anyvector matchscalaroffirst anyint shufflevector anyvector matchlengthoffirst vecofconsti32 aggregate operationsextractvalue anyaggregateorarray anyconstint insertvalue anyaggregateorarray matchscalaroffirst anyconstint memory operation getelementptr anysized pointeroffirst anyint casting operationstrunc anynonboolintorvecint anyintorvecintwithlowerprecision zext sext anyintorvecint anyintorvecintwithhigherprecision fptrunc anynonhalffporvecfp andfporvecfpwhigherprecision fptoui fptosi anyfporvecfp matchlengthoffirstwithint uitofp sitofp anyintorvecint matchlengthoffirstwithfp ptrtoint anyptrorvecptr matchlengthoffirstwithint ptrtoint anyintorvecint matchlengthoffirstwithptr bitcast anytype anytypewithsamebitwidth other operationsicmp anyintorvecint sameasfirst fcmp anyfporvecfp sameasfirst select anyboolorvecbool matchlengthoffirst sameassecond plication of patterns tablegen represents patterns in a statemachine and implements it as a large byte array known as the matcher table .
during compilation the state machine determines the best pattern to apply to each ir instruction.
listing is a c code snippet for evaluating the matcher table in selectiondag.
sdnode is a data structure that represents an ir instruction.
the while loop iteratively reads a command from the matcher table based on the current state represented by the idx variable evaluates the command and selects the next state to be evaluated.
for example opc checkopcode will check if the opcode of a given sdnode representing an instruction in the selectiondag graph matches a particular opcode.
the result will be used in future iterations depending on the next entry in the matcher table.
the compiler continues to evaluate the matcher table until it selects a single pattern or reaches a state where no pattern applies.
since the program in listing evaluates all the patterns using the same set of conditional branches in the switch statement its control flow coverage does not reflect what patterns have been exercised.
to overcome this we track the usage of the matcher table directly.
similar to how afl tracks branch coverage we allocate a table matcher table coverage table for tracking the coverage of the matcher table.
each entry in this table corresponds to an entry in the matcher table and records if the latter has been accessed.
the instrumented compiler dumps matcher table coverage after every execution.
if either the branch coverage table and or the matcher table coverage table shows new coverage then the fuzzer considers the input as new.
tracking matcher table coverage incurs memory overhead which may reduce fuzzing throughput .
the second and1void selectcodecommon sdnode n char matchertable bool result true unsigned opc while true if !result break switch matchertable case opc checkopcode uint16 t opc matchertable opc unsigned short matchertable result opc n getopcode ... case opc movechild0 unsigned childno opc opc movechild0 if childno n.getnumoperands break match fails if out of range child .
n n.getoperand childno nodestack.push back n continue void aarch64selectiondag selectcode sdnode n define target val x x unsigned x static const unsigned char matchertable ... opc checkopcode target val isd add opc movechild0 opc checkopcode target val aarch64isd umull opc movechild0 ... selectcodecommon n matchertable sizeof matchertable listing selectiondag in llvm that consumes a matcher table to do instruction selection.
we also show aarch64 s matcher table from index to .
switch case opc movechild0 can be executed with different opc rendering branch coverage ineffective to track the behavior of this code.
therefore we also track individual entries of the matcher table.table ii the number of entries in the matcher tables used by selectiondag in mature architectures llvm commit 860e439f .
to track the coverage of the matcher table we use one bit to track each entry in the matcher table.
arch of entries arch of entries aarch64 powerpc amdgpu risc v arm systemz hexagon ve mips wasm nvptx x86 fourth column of table ii show the size of the matcher table in different mature architectures.
the matcher tables for mainstream architectures such as x86 and aarch64 have several hundred thousand entries whereas risc v has about two million entries.
since the entries in the matcher table represent different features to determine which features have been covered we can individually track whether each entry has been accessed because the order of access is irrelavent.
to reduce memory footprint we use one byte to track eight entries in the matcher table.
for example the largest matcher table of the risc v architecture has entries.
tracking its coverage takes bytes or kb.
ir mutation feedback the mutator needs to know which patterns in the matcher table have been executed so that it can generate more diverse inputs.
however when llvm prepares the matcher table it hides which pattern each entry in the matcher table represents.
to recover this information we generate a look up table to map each matcher table entry to its corresponding machine instruction pattern.
compiler developers program different patterns into tablegen and the compiler translates those patterns into the matcher table.
we modify tablegen to reverse that process to create the look up table.
prior to fuzzing we create this look up table for each architecture.
during fuzzing we use the matcher table coverage table and the look up table to determine which patterns haven t been generated.
finally we send this report to the mutator to encourage it to generate those patterns which is done every ten minutes to avoid excessive runtime overhead.
iv.
i mplementation our implementation is based on prior work fuzzmutate and afl .
compared with fuzzmutate we added the following new mutation strategies which have been incorporated into the upstream llvm s repository a new function template generator with the ability to modify function attributes.
a new control flow graph mutation strategy scfg insertion strategy which modifies the control flow while preserving domination relations.
extended modelling of ir instructions including phi nodes memory operations vector operations and support for non scalar types.compared with afl we measure the coverage of the matcher table which not only helps determine if a new input is interesting but also guides mutation.
this feedback allows our mutator to generate architecture specific intrinsics without any prior knowledge of the architecture.
v. e valuation we evaluated irfuzzer by fuzzing llvm with different settings and tools to answer the following research questions rq1 how does irfuzzer compare with state of the art backend fuzzers?
rq2 how does irfuzzer compare with end to end fuzzers like csmith and grayc?
rq3 do mutator and matcher table feedback individually contribute to irfuzzer?
rq4 can irfuzzer find new bugs in llvm?
the upstream llvm repository commit 860e439f currently supports architectures.
we only tested on mature architectures that had a matcher table size larger than as shown in table ii.
in addition each architecture may provide different features that can be enabled on different hardware.
for simplicity we selected the backends of some popular microchips which had a predefined set of features.
these backends were widely used from user product to server applications justifying the variety of our choice.
all the architectures that we tested were under active development.
as a result we selected target cpus1across architectures.
we used two baseline fuzzers afl with no modification and afl whose mutation module was replaced with fuzzmutate referred to as fuzzmutate thereafter.
all fuzzers used afl s default scheduling.
for fairness we collected the seeds generated by each fuzzer and measured their branch coverage and matcher table coverage.
afl reported branch coverage using classical instrumentation and a default kb table.
we prepared two versions of irfuzzer irfuzzer has all the mechanisms described in section iii.
irfuzzer bareexcludes the feedback mechanism described in section iii b. its performance reveals the contribution of our mutator when compared with fuzzmutate and of the feedback mechanism when compared with irfuzzer.
each fuzzer process ran exclusively on a single processor core on an x86 server.
each fuzzing process ran for one day to allow adequate exploration .
we repeated each experiment five times to average the results to reduce random effects.
to demonstrate irfuzzer s ability to mutate ir modules and to provide a fair comparison with afl we initialized each fuzzer process with seeds.
we randomly selected the seeds from llvm s unit tests.
each seed was smaller than bytes to increase the throughput.
we anonymously published the seeds in the artifact .
target cpu was used in llvm to label a backend corresponding to a microchip.
it can also refer to gpu dsp or virtual targets like webassembly.a.
baseline comparison we compared our mutation strategy with two baseline implementations afl and the upstream llvm implementation of fuzzmutate.
afl lacks an llvm ir aware mutator whereas fuzzmutate has a limited llvm ir aware mutator.
table iii shows the branch and matcher table coverages which we calculated by dividing the number of non empty entries in the coverage table by the size of the table.
the seeds columns show the coverage brought by the initial seeds.
on each target cpu target cpu irfuzzer and irfuzzer bare achieved more coverage than the baseline fuzzers and the difference is statistically significant p .
.
irfuzzer achieved the highest branch coverage on all the target cpus.
it may seem counterintuitive that afl has higher branch coverage than fuzzmutate on most target cpus.
our investigation revealed that afl s high branch coverage mostly comes from error handling code since it can hardly generate valid input.
this is further demonstrated by afl s low matcher table coverage which indicates that most executions did not reach the instruction selection stage before the compiler terminated.
it is insufficient to compare only branch coverage .
more significantly irfuzzer achieved the best matcher table coverage on all cpus indicating significantly better coverage of instruction selection patterns.
comparison between fuzzmutate and afl also cast insights on which fuzzer is better to fuzz the backend compiler.
fuzzmutate can generate valid input to reach deeply nested code more easily as demonstrated by its higher matcher table coverage in table iii compared with afl .
on the other hand afl s high branch coverage and low matcher table coverage show that most inputs didn t reach the instruction selection stage before the compiler terminated.
therefore afl is useful mainly for testing error handling and the frontend.
in summary irfuzzer achieved higher branch coverage and matcher table coverage on all target cpus compared with afl and fuzzmutate.
to answer rq1 irfuzzer is better in coverage when fuzzing llvm code generation compared with state of the art fuzzers.
b. comparison with end to end fuzzers to better understand the benefits of targeted fuzzing over end to end fuzzing we evaluated csmith and grayc .
unlike irfuzzer end to end fuzzers generate c code which must be processed by the compiler frontend and middleend before reaching the backend.
as a result they exercise the entire compilation pipeline rather than focusing on just the backend.
note that although csmith generates random syntactically correct c code it does not implement any instrumentation and lacks feedback to guide the generation process.
while grayc relies on branch coverage feedback it does not have feedback that is customized for the backends of the compilers.
besides to test end to end fuzzers we had to cross compile c to different architectures which was difficult andtime comsuming.
therefore we tested on three most widely used architectures using generic backend.
csmith generates c files with no initial seed.
to make the comparison fair we also ran irfuzzer with noinitial seed since irfuzzer is capable of generating llvm ir from scratch.
grayc relies on deprecated apis in llvm and cannot instrument the latest llvm.
so we download the artifact provided by grayc .
the artifact consists of c programs across ten trials.
we ran csmith for hours and repeated it eight times generating a total of c programs.
we cross compiled these c programs to different architectures.
after compilation we measured the resulting branch and matcher table coverage in the compiler backend using the same instrumentation as irfuzzer.
we only tested on o2 ando3 aso0ando1are often subsets of o2.
the results are shown in table iv.
irfuzzer achieved the highest matcher table and branch coverage on all the architectures and all the optimizations.
even with branch coverage feedback grayc was unable to generate c inputs with more matcher table coverage which demonstrating the need for specialized backend fuzzing.
we looked into the code generated by end to end fuzzers and found that their low matcher table coverage was mainly because they could not handle vector data types.
vector instructions are generated only when the front end and middleend decide that a vector instruction will speed up a particular piece of code which is uncommon in random c programs generated by end to end fuzzers.
in comparison since irfuzzer operates directly on ir instructions it can generate vector operations easily.
to answers rq2 irfuzzer achieved higher matcher table coverage than state of the art end to end fuzzers.
this shows that compiler backend testing should not solely rely on end toend fuzzing and that specialized fuzzing can improve matcher table coverage significantly.
c. individual contributions to evaluate how each component of irfuzzer helps we stripped all the feedbacks in irfuzzer to get irfuzzer bare.
table iii shows that irfuzzer barealways reached higher branch coverage and matcher table coverage than fuzzmutate indicating that our mutator was able to generate more diverse inputs.
although fuzzmutate is also a structured mutator it lacks many advanced features that we designed in section iii a. the sifive x280 cpu best demonstrates this improvement where irfuzzer barecovered .
of the matcher table while fuzzmutate covered only .
.
the last two columns of table iii show that irfuzzer is able to cover more matcher table in out of target cpus compared with irfuzzer bare.
this demonstrates that our matcher table feedback can help the mutator during fuzzing trials.
this effect can be best observed on nvptx where irfuzzer barecovered only .
of the matcher table while irfuzzer covered .
.table iii branch table coverage and matcher table coverage on target cpus across targets in selectiondag.
statistics are the arithmetic mean over five trials.
bold entries are the best among baseline fuzzers.
fm means afl coupled with fuzzmutate irf means irfuzzer irf baremeans irfuzzer without matcher table feedback.
arch target cpubranch coverage matcher table coverage seeds afl fm irf bare irf seeds afl fm irf bare irf aarch64apple a16 .
.
.
.
.
.
.
.
.
.
apple m2 .
.
.
.
.
.
.
.
.
.
cortex a715 .
.
.
.
.
.
.
.
.
.
cortex r82 .
.
.
.
.
.
.
.
.
.
cortex x3 .
.
.
.
.
.
.
.
.
.
exynos m5 .
.
.
.
.
.
.
.
.
.
tsv110 .
.
.
.
.
.
.
.
.
.
amdgpugfx1036 .
.
.
.
.
.
.
.
.
.
gfx1100 .
.
.
.
.
.
.
.
.
.
arm generic .
.
.
.
.
.
.
.
.
.
hexagonhexagonv71t .
.
.
.
.
.
.
.
.
.
hexagonv73 .
.
.
.
.
.
.
.
.
.
mips mips64r6 .
.
.
.
.
.
.
.
.
.
nvptx sm .
.
.
.
.
.
.
.
.
.
powerpc pwr9 .
.
.
.
.
.
.
.
.
.
risc vrocket rv64 .
.
.
.
.
.
.
.
.
.
sifive u74 .
.
.
.
.
.
.
.
.
.
sifive x280 .
.
.
.
.
.
.
.
.
.
systemzz15 .
.
.
.
.
.
.
.
.
.
z16 .
.
.
.
.
.
.
.
.
.
ve generic .
.
.
.
.
.
.
.
.
.
wasmbleeding edge .
.
.
.
.
.
.
.
.
.
generic .
.
.
.
.
.
.
.
.
.
x86alderlake .
.
.
.
.
.
.
.
.
.
emeraldrapids .
.
.
.
.
.
.
.
.
.
raptorlake .
.
.
.
.
.
.
.
.
.
sapphirerapids .
.
.
.
.
.
.
.
.
.
znver3 .
.
.
.
.
.
.
.
.
.
znver4 .
.
.
.
.
.
.
.
.
.
table iv average branch table coverage and matcher table coverage of csmith cs grayc and irfuzzer irf .
o2 ando3are different optimization levels.
bold entries are the winners.
archbranch table coverage matcher table coverage cs grayc irf cs grayc irf o2aarch64 .
.
.
.
.
.
arm .
.
.
.
.
.
x86 .
.
.
.
.
.
o3aarch64 .
.
.
.
.
.
arm .
.
.
.
.
.
x86 .
.
.
.
.
.
in rare cases irfuzzer has lower branch coverage than irfuzzer bare.
this is because the feedback mechanism incurs a tradeoff.
calculating matcher table coverage and sending it to the mutator reduce the throughput which lowers branch coverage.
on the other hand this feedback is valuable for generating more diverse inputs which contributes to higher matcher table coverage.
among all the target cpus irfuzzer had lower branch coverage than irfuzzer bareon only target cpus so we believe that the tradeoff is acceptable and justified.
besides both irfuzzer and irfuzzer bareout performed baseline fuzzers on all the target cpus.
we can answer rq3 confidently that both the mutator and feedback mechanism contributed to improved matcher table coverage.
d. bug categories and analysis we collected all the crashes found in section v a and section v b. we also fuzzed other architectures with no features to extend our scope.
since globalisel also uses matcher table design we can apply irfuzzer on it with little modification.
this demonstrates that our approach can be generalized to other frameworks with little effort.
in the process we found hundreds of crashes in the llvm compiler.
even though these crashes all have unique stack traces they do not necessarily indicate different bugs because some crashes have different paths but the same root cause.
therefore we manually analyzed all of them and reported the ones that we believe are bugs.
in this section we only report the bugs that have been confirmed .
in total irfuzzer found confirmed bugs.
we manually verified that these bugs are found only by irfuzzer and published the details anonymously .
these bugs are distributed in different places in the llvm codebase.
figure 4a shows the distribution of these bugs acrossx86 aarch64 codegenamdgpunvptx hexagonwasm risc varmbpfve xcorepowerpc051015 of bugsconfirmed fixed a bugs categorized by locations .
codegen refers to the code shared by all architectures so these bugs may affect all architectures.
assertion pattern logic memory hang other0102046 of bugs b bugs categorized by causes .
most of the severe bugs are compiler hangs memory errors and assertion failures.
fig.
distributions of bugs found by irfuzzer.
irfuzzer has found 78new bugs out of which 57have been fixed.
1bool irtranslator translateextractelement 2const user u machineirbuilder mirbuilder register idx const llt ty llt scalar preferredvecidxwidth idx mirbuilder.build sext ortrunc ty idx .getreg listing a snippet of code in llvm where the index of a vector is treated as a signed value.
llvm.
codegen is the library shared between architectures meaning that a bug in codegen may affect all architectures.
bugs found by baseline fuzzers our evaluation of the baseline fuzzer afl fuzzmutate csmith and grayc shows that none of them found any backend bugs.
all the confirmed bugs were found exclusively by irfuzzer.
afl found many crashes in the llc lexer and module verifier.
however all of them were caused by a malformed input and are not considered bugs.
fuzzmutate did not find any crashes because its mutator is very limited and only covers common use cases of the compiler backend.
distribution of bugs we categorize these bugs into six categories hang memory errors assertion failures logic errors missing patterns and other bugs.
hang memory errors and assertion failures are the most severe because they stall compilation.
a missing pattern bug occurs when a certain machine instruction is permitted by the hardware specification but no matching instruction selection pattern exists.
logic errors and missing patterns do not stall compilation but may generate ineffective or even wrong machine instructions.
figure 4b shows the number of bugs in each category.
assertion bugs are the most common.
they arise from the developers false assumption that some properties hold during compilation which our fuzzer disapproved.
we demonstrate two bugs found by irfuzzer.
listing shows a bug in ir translator.
when translating the ir instruction extractelement the bug extends the index asbb1 bb2 bb3 x x 2x a original cfgbb1 bb2 bb3 x x 3x b optimized cfg fig.
a piece of code generated by irfuzzer simplified to cfg only.
turnswitchrangeintoicmp transforms figure 5a into figure 5b and foldvaluecomparisonintopredecessors will undo the transformation causing an infinite loop.
a signed integer e.g.
translating char into .
this bug generates incorrect machine instructions and affects the llvm backend for seven architectures.
introduced in llvm nine years ago the bug was never noticed for several reasons.
first it is less common for compiler frontends to generate vector operations as we have seen in section v b and is even rarer to use an index that is large enough to wrap around to a negative integer.
however irfuzzer can generate such a test case easily because it directly mutates on ir instruction.
more importantly the documentation was ambiguous with respect to the desirable behavior.
the documentation states the index may be a variable of any integer type without giving details on how it should be interpreted.
therefore when this bug was introduced it complied with the incomplete documentation at the time.
this exemplifies how complex software interfaces can be incompletely specified which further justifies our specialized fuzzing.
in this case we fixed the bug and updated the documentation to reflect the intended interpretation of the index as an unsigned integer.
irfuzzer also found compile hangs.
figure shows a simplified cfg corresponding to the code generated by irfuzzer.
this cfg will cause a compiler hang due to the interaction between two optimization passes.
bb2 in figure 5a consists of a switch statement with two self loop edges.
the turnswitchrangeintoicmp optimization attempts to rewrite the condition as a branch predicate because x x can be optimized using bit operations rewriting figure 5a into figure 5b.
however thefoldvaluecomparisonintopredecessors optimization converts this code back into a switch statement to reduce the number of comparison operations turning the cfg back to figure 5a.
as a result a fixed point is never reached creating an infinite loop.
this bug is hard to trigger since the bug can only be triggered when the switch in figure 5b has exactly two destinations bb2 and bb3 and the switch conditions are consecutive enabling the turnswitchrangeintoicmp optimization.
this combination is unlikely to be created during manual testing and can only happen through the interaction of two largely unrelated pieces of code.
yet we are able to discover this catastrophic combination through our cfg mutation strategy in a time frame amenable to run fuzzing on every nightly build with little human intervention.we are working closely with the llvm community to fix the bugs discovered by irfuzzer.
bugs were fixed five of which were back ported to llvm as security patches.
the developers confirmed that all the bugs that we reported and they fixed had been introduced prior to llvm .
despite heaving testing they remained in llvm until irfuzzer discovered them.
this demonstrates that specialized fuzzing for compiler backend is necessary and it provides actionable insight to developers.
accuracy irfuzzer guarantees to generate valid llvm ir.
since ir is the input to backends a robust backend should take any valid ir without crashing so any crash indicates either a bug or an incomplete feature in the backend.
irfuzzer found bugs all of which we confirmed and reported to the developers.
of these bugs have been fixed and five bugs were back ported as security patches.
this shows that the developers agree that these are true bugs regardless of whether c programs corresponding to the ir exist.
we can answer rq4 now.
in total irfuzzer found new bugs.
all have been confirmed have been fixed and five have been back ported to llvm as security patches.
all these bugs were found only by irfuzzer and not by any of the baseline fuzzers.
these bugs contain six compiler hangs ten memory errors and assertion failures.
we also found logic errors and missing patterns in the matcher table.
vi.
r elated work prior work has focused on compiler testing .
one popular approach is to generate inputs for compilers to compile.
purdom generates program based on context free grammar.
superion and nautilus also relies on context free grammar for fuzzing.
however context free grammar based methods cannot generate semantically meaningful programs.
these efforts are effective in testing frontend parsers but cannot reach the backends effectively.
while many fuzzers are testing the frontend of the compiler using grammar based method some work also tests the correctness of middle end .
to the best of our knowledge irfuzzer is the first one to verify the compiler backend using an architecture independent approach.
some work does end to end tests using high level programming languages.
csmith yarpgen and grayc generate c and c programs.
ai has also been used for program generate for the purpose of compiler testing .
however end to end testing implies that there is a need to create a generator for every language like javascript rust and java .
polyglot introduced a language free ir and mutator based on it.
most fuzzers have no feedback from the compiler.
even though grayc introduced branch coverage feedback it was unable to trigger backend bugs due to language limitations and compiler optimizations.
instead of directly generating a program equivalence modulo inputs mutates an existing c program to preserve its semantics.
therefore the program before and after mutation should have the same behavior.
combining csmith and emi lidbury et al.
mutate program to test openclcompiler .
however the language limits these work since the generator cannot help when the language frontend cannot exercise a feature in the compiler.
formal verification is another valuable part of compiler verification .
verasco is a formally verified c analyzer.
compcert is a compiler for a subset of c that is formally verified.
there is work that verifies other languages like rust and lustre .
however formal verification cannot scale to large compilers like llvm therefore it has a limited impact in the community.
there is also work that considered generating a valid intermediate representation for testing purposes.
fuzzmutate directly generates llvm ir .
however fuzzmutate has no feedback unless combined with fuzzers like afl or libfuzzer .
some work focus on testing of a specific compiler .
tzer focuses on ir mutation in the context of a tensor compiler .
however tzer relies on llvm s coverage sanitizer that only tracks code coverage.
similar to irfuzzer s approach classming directly mutates on java byte code .
neither tzer nor classming designed a feedback approach except for branch coverage.
however as we demonstrate in section v c a customized feedback metric can greatly help the fuzzer to reach deeper into the code base.
with the development of large language models llm it has been used more and more in fuzzing and code generation .
however llm doesn t guarantee the correctness of input like irfuzzer does.
vii.
c onclusion we described irfuzzer a fuzzer specializing in fuzzing llvm instruction selection.
to generate semantically and syntactically correct inputs we identified the challenges in ir generation that did not exist in high level language generation.
we created a mutator that maintained semantic correctness by splitting blocks and inserting a scfg in between.
then we ensured that the ir instructions that we inserted were syntactically correct using a descriptive language to model all ir instructions.
therefore the ir program that irfuzzer generated could always be compiled by the backend.
we proposed a new metric to track the coverage of the matcher table and decoded the coverage table to guide mutation.
our evaluation shows that irfuzzer outperformed existing backend and end to end state of the art fuzzers.
irfuzzer achieved higher matcher table coverage on all the llvm backend architectures.
irfuzzer is also efficient enough to become part of the development process.
irfuzzer identified new confirmed bugs in upstream llvm code.
upon receiving our bug report the developers have fixed bugs and back ported five fixes to llvm .
this demonstrates that irfuzzer is effective in finding bugs in llvm backend and provides useful actionable insights to llvm developers.
our experience shows that there are fertile opportunities for specialized fuzzing despite popular end toend compiler testing.
acknowlegement this work is partially supported by uc noyce initiative.