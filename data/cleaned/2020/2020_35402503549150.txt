dejitleak eliminating jit induced timing side channel leaks qiqin qinqi shanghaitech.edu.cn shanghaitechuniversity shanghai chinajulianandres jiyang jlandres shanghaitech.edu.cn shanghaitechuniversity shanghai chinafu song songfu shanghaitech.edu.cn shanghaitechuniversity shanghai china taolue chen t.chen bbk.ac.uk birkbeck university oflondon london ukxinyuxing xinyu.xing northwestern.edu northwesternuniversity evanston illinois usa abstract timingside channelscanbeexploitedtoinfersecretinformation when the execution time of a program is correlated with secrets.
recent work has shown that just in time jit compilation can introducenewtimingside channelsinprogramseveniftheyare time balanced at the source code level.
in this paper we propose a novelapproachtoeliminatejit inducedleaks.wefirstformalise timingside channelsecurityunderjitcompilationviathenotionof time balancing layingthefoundationforreasoningaboutprograms with jit compilation.
we then propose to eliminate jit induced leaks via a fine grained jit compilation.
to this end we provide an automated approach to generate compilation policies and a novel type system to guarantee itssoundness.we develop a tool dejitleak for real world java and implement the fine grained jitcompilationinhotspotjvm.experimentalresultsshowthat dejitleak can effectively and efficiently eliminate jit induced leaks on three widely adopted benchmarks in the setting of sidechanneldetection.
ccsconcepts softwareanditsengineering formalsoftwareverification theoryofcomputation programanalysis security and privacy formal security models logic and verification.
keywords jit compilation timing side channel formal semantics type inference detection mitigation acm reference format qi qin julianandresjiyang fu song taolue chen and xinyu xing.
.
dejitleak eliminating jit induced timing side channel leaks.
in proceedingsofthe30thacmjointeuropeansoftwareengineeringconference andsymposiumonthefoundationsofsoftwareengineering esec fse november 14 18 singapore singapore.
acm new york ny usa 13pages.
corresponding author esec fse november 14 18 singapore singapore copyright heldby theowner author s .
acm isbn .
introduction timing side channel vulnerabilities in programs arise when the executiontimeofaprogramiscorrelatedwithsecrets thuspose a serious threat to secure systems.
one notorious example is the lucky attack that can remotely recover plaintext from the cbcmodeencryptionintlsduetoanunbalancedbranchstatement .
constant time and time balancing are two programming principles to mitigate timing side channel vulnerabilities .
the former ensuresthatsecretsdonotinfluencecontrol flowpaths memory access patterns etc.
thus requires significant changes to programs e.g.
complicated bitwise operations .
the latter ensures that each secret branching statement has balanced execution time and is mucheasierto achieve inpractice.developing constant timeand time balanced programs is not easy.
even worse in practice theymaystillbevulnerableiftheruntimeenvironmentisnotfully captured by constant time or time balancing models.
for instance static compilation from programs to low level counterparts can compromise constant time security constant time executable programs are vulnerable in modern processors due to e.g.
speculative or out of order execution just in time jit compilation may undermine time balanced programs .
in this work we focus on jit compilation induced leaks jitinduced leaks which could be exploited remotely in real world applications butcurrentlynorigorousapproachcaneliminate themotherthan tuningoff jit compilation .
we first lay the foundations for timing side channel security underjitcompilationbypresentingaformaloperationalsemantics.
with this we present the first formalism of timing side channel securityunderjitcompilationviathenotionoftime balancing.to be generic we donot model concrete jit compilation asin whichaimedtoprovethecorrectnessofjitcompilation.instead we leavejitcompilationabstractinourmodel whichisformalizedvia compilationdirectivesandallowstoconsiderpowerfulattackers who have control over jit compilation.
this approach can also enable reasoning about bytecode running with jit compilation anduncoverhowcodecanleaksecretsduetojitcompilationin a principled way.
we then propose to prevent jit induced leaks via a fine grained jit compilation and present a type system for staticallyinferringeffective compilation policies.
basedontheseresults wepresent dejitleak apracticaltool for generating compilation policies of java programs that can be proven to completely eliminate jit induced leaks while still benefitingfromtheperformancegainsofjitcompilation inaddition thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse november14 18 singapore singapore qi qin julianandresjiyang fusong taoluechen xinyu xing a lightweight variant of dejitleak dejitleak light can eliminate most of the leaks with a low overhead for more performanceconsciousapplicationsandisstillsoundifmethodsinvokedinboth sides of each secret branching statement are the same.
we also implementthefine grained jitcompilationinhotspotjvmfrom openjdk.
we conduct extensive experiments on three widely used datasetsinrecentside channeldetection blazer themis coco channel diffuzz and jvmfuzz .
experimental results show that dejitleak significantly outperformsthe strategiesproposedin .wereportinterestingcasestudieswhichshed light onfurther research.
in summary our contributionsare aformaltreatmentofjit inducedleaksincludinganoperational semantics andatime balancingnotionunderjit compilation a protection mechanism against jit induced leaks via a finegrained jit compilation and an efficient approach to generate jit compilation policies for fine grained jit compilation with security guarantees a practical tool that implements our approach and extensive experiments to demonstratethe efficacy ofour approach.
structure.
section2brieflyintroducesjit inducedleaksandpresents an overview of our approach.
section 3formalises timing sidechannel security under jit compilation.
in section we propose a protection mechanism and a type system to guarantee its soundness.
section 5presents an implementation of our approach for real worldjava.section 6reportsan extensiveevaluation.
wediscuss related work in section 7and conclude this work in section .
overview in this section we first give a brief introduction of jit induced leaks .
we will exemplify these leaks usingthe hotspot jvm hotspotforshort onopenjdk1.
.wethengiveanoverviewof our approach to identifyandeliminatethe jit inducedleaks.
.
jit inducedleaks jit induced leaks could be caused by at least the following three jitcompilation techniques .
optimistic compilation topti .optimistic compilation is a typeofspeculationoptimizations .duringthejitcompilation ofamethod thecompilerspeculatesonthemostlikelyexecuted branches by pruning rarely executed branches.
as a result it reduces the amount of time required to compile methods at runtime and space to store the native code.
however there might be a subsequent execution where the speculation fails and the execution must fall back to bytecode in the interpreted mode.
to handle this issue adeoptimizationpoint a.k.a.uncommontrap isaddedtothe nativecodeand whenencountered deoptimizationisperformed which recovers the program state and resumes execution using bytecode.
clearly executing the native code after compilation is muchmoreefficientifnodeoptimizationoccurs.however when deoptimizationoccurs itwilltakelongertimetodeoptimizeand rollbackto thebytecode.
this differenceinexecutiontimeinduces atiming side channel even if branches are balancedinbytecode.
as an example consider the pwdeqmethod shown in figure 1a whichisextractedandsimplifiedfromthedarpaspace timeanalysisforcybersecurity stac engagementprogram gabfeed 1 .
it takes the strings aandbwith length 8as inputs denoting theuser entered and correct passwords respectively.
it checks if the twostringsareidentical theforloop .theflag equalisassignedby falseiftwocharsmismatch.tobalanceexecutiontime thedummy flagshmequal isintroduced.
thepwdeqmethodismarkedassafeinstacandwouldbeverified as safe by the timing side channel verification tools blazer and themis which do not consider jit compilation.
however indeeditisvulnerableto topti.totrigger topti weexecute pwdeq 000timesusingtwostrings password and password .after that the else branchisreplacedbythecorrespondinguncommon trap sothecostlydeoptimizationwillperformlater.totriggerthis we use two strings xandywith length such that x is p y is not p and the rest is the same.
we collect the execution time of pwdeqwithinputs x password and y password respectively.
the distribution of the execution time is shown in figure 1b.
in comparison figure 1cshowsthedistributionofexecutiontimewith jit compilation disabled.
we can observe that the difference in the executiontimebetweentwobranchesismuchlargerwhenjitcompilation isenabled allowinganattacker toinferif thefirstcharis correctlyguessed.ourapproachpreventsthisleakbydisablingthe optimisticcompilationoptimizationoftheconditionalstatement inpwdeqratherthandisablingjitcompilation.theeffectiveness isjustifiedbytheexecutiontimedepictedinfigure 1d.itismore efficient than natively disabling jit compilation e.g.
figure 1cvs.
figure1d .
branch prediction tbran .branch prediction is a conservative optimizationofconditionalstatements.insteadofpruningrarely executed branches branch prediction generates native code by reorderingthebasicblockstoavoidjumpsoverfrequentlyexecuted branchesandthusimprovesthespatiallocalityofinstructioncache.
however thereorderingofbasicblocksunbalancestheexecution timeofbranchesevenifitisbalancedinbytecode.althoughthe difference in the execution time between branches via tbranis small for a single conditional statement it may be amplified by repeatedexecutions e.g.
enclosedinaloop .
method compilation tmeth .the most fundamental feature ofjitcompilationismethod compilation whichcanbe triggered if a method is frequently invoked or some backward jumps are frequentlyperformed.meanwhile duringcompilationfrequently invokedsmallmethodscouldbeinlinedtospeedupexecution.ifan attacker can enforce some methods in a branch to be frequently invokedinadvancesothatthosemethodsare re compiledorinlined the execution time of this branch may be shortened.
this difference in execution time between branches would induce a timing side channel.
concrete demonstrationsof tbranandtmethrefer to .
.
eliminating jit inducedleaks assuming that a program in bytecode is time balanced our goal is toautomaticallypreventitfromthejit inducedleaks.onepossible way is to adopt constant time programming principle e.g.
.
however there are two limitations i significantchangeshavetobemade e.g.
complicatedbitwise operations makingreasoningaboutfunctional correctnessharder.forinstance openssl applied a loc patch to perform constant time cipherblock chaining cbc decoding the complexityof which led 873dejitleak eliminating jit inducedtiming side channel leaks esec fse november14 18 singapore singapore boolean pwdeq char a char b boolean equal true boolean shmequal true for int i i i if a !
b equal false else shmequal false return equal a thepwdeqmethod x p y !
p 010000200003000040000execution time ns b jit enabled x p y !
p 15002000250030003500execution time ns c jit disabled x p y !
p 0100020003000execution time ns d mitigated figure the pwdeqmethod andits execution timewith jitenabled and disabled under topti to subsequent issues .
to the best of our knowledge no tool canautomaticallyrewriteajavaprogramtoaconstant timeone.
ii different from programs written in static programming languages for which constant time written is done once for eachprogram forprogramsthatcanbe jit compiled ascompilationmaydestructconstant timesecurity constant time security should be enforced during each jit compilation incurring large overheadto jitcomplication.
another straightforward way to prevent jit induced leaks is to simply disable jit compilation completely or jit compilation of the chosen methods.
indeed proposed three compilation strategies nojit disablec2 and mexclude.
i the nojit strategy directlydisablesjitcompilation e.g.
boththec1andc2compilers in hotspot so no method will be jit compiled.
this strategy is effective and convenient to deploy but could lead to significant performance loss.
ii the disablec2 strategy only disables the c2 compilerinstead ofthe entire jitcompilation by whichtheleaks induced by the c2 compiler e.g.
topti can be prevented but not fortbranortmeth.
this strategy also sacrifices the more aggressivec2optimizationandhencemay sufferfromperformance loss.
iii the mexclude strategy disables jit compilation for the user chosen methods instead of the entire program.
its main shortcoming is that non chosen methods may be still vulnerable and it isalsounclearhowtochoosemethodstodisable.in mexclude isappliedtothemethodsthatcontainsecretbrancheswhichcan preventtbranandtoptileaks but not tmethleaks.
in summary thesecompilationstrategieseitherincurahighperformancecost orfail to preventallthe knownjit inducedleaks.
inthiswork wefirstlaythefoundationsfortimingside channel securityunderjitcompilation by presentinga formal operational semanticsanddefininganotionoftime balancingforafragment of the jvm under jit compilation.
it allows us to reason about timingside channelsecurityofbytecodeprogramsrunningwith jitcompilationinaprincipledway.basedonourformalism we observe that secret information can only be leaked when there is a conditional statement whose condition relies on secret data and at leastone ofthe following casesoccurs namely tmethleaks a method invoked in a branch is jit compiled or inlined tbranleaks the conditional statement is optimized with the branchprediction optimization toptileaks theconditionalstatementisoptimizedwiththe optimistic optimization therefore disabling jit compilationat the method level is indeed unnecessary for preventing jit induced leaks instead we only need to ensure that secret information will not be leaked when the methodsare jit compiledorinlined.
basedontheaboveobservation weproposeanovelapproach dejitleak to automatically eliminate jit induced leaks.
to the bestofourknowledge thisisthefirstworktopreventalltheabove jit inducedleakswithoutdisablinganycompilerinhotspot which is in a sharp contrast with the existing compilation strategies .
in a nutshell dejitleak automatically locates secret branch points programpointswithconditionalstatementswhoseconditionsrelyonsecretdata byaflow object andcontext sensitive information flow analysis of java bytecode .
the conditional statementsatthosesecretbranchpointsshouldnotbeoptimized viabranchpredictionoroptimisticcompilations.itthenextractsall themethodsinvokedinthoseconditionalstatementsandidentifies thosemethodsthatshouldnotbejitcompiledorinlined.basedon these we put forward a fine grained jit compilation and present a type systemto prove the soundness of the fine grained jit compilation i.e.
atime balanced program remains time balanced under ourfine grainedjitcompilationiftheprogramiswell typedunder ourtypesystem.notethatourapproachdoesnotguaranteethat alltheidentifiedbranchpointsormethodsarenecessary butthe precision ofour approach isassured by the advanced information flowanalysisandisindeedvalidatedbyexperiments insection .
finally thefine grainedjitcompilationisimplementedbymodifyinghotspot.ourexperimentalresultsshowthatourapproach issignificantlymoreeffectivethandisablec2andmexclude and issignificantly more efficient thannojit.
formalismofsecurity inthissection wepresentafragmentofjvmandformalizetiming side channel security viathe notionof time balancing.
.
the jvmsubmachine wedefineafragmentjvm jitofjvmwithconditionalandunconditional jumps operations to manipulate the operand stack and methodcalls.forthesakeofpresentation bothbytecodeandnative codearepresentedinjvm jit.notethatourmethodologyisgeneric andcouldbeadaptedtorealinstructionsetsofbytecodeandnative code.
syntax.letlvar resp.gvar bethefinitesetoflocal resp.global variables valbe the set of values mbe a finite set of methods.
a program pcomprises a set of methods and each method is a 874esec fse november14 18 singapore singapore qi qin julianandresjiyang fusong taoluechen xinyu xing m pushv pc m os leadsto pc m v os m pop pc m v os leadsto pc os m binopop v v1op v2 pc m v v2 os leadsto pc m v os m ifeqjpc v ?j pc pc m v os leadsto pc m os m ifneqjpc v ?j pc pc m v os leadsto pc m os m swap pc m v v2 os leadsto pc v2 v1 os m storex x dom pc m v os leadsto pc m os m loadx pc m os leadsto pc m x os m gotoj pc m os leadsto j m os s leadstos ch h s cs ch h s cs m puty y dom s pc m os ch h pc m v os cs ch h s cs m gety s pc m h y os ch h pc m os cs ch h s cs m return s pc m v os ch h pc m v os pc m os cs ch h s cs m deoptmdvm 0o ch h pc m os cs md h s cs ch h pc m os cs ch h s cs cs m return ch h pc m v os h v m invokem argv m x0 xkd d s ch m ch h pc m v k v0 os cs d ch h s pc m os cs m invokem argv m x0 xkd dmd d m d m v m vm ch h pc m v k v0 os cs d ch h m pc m os cs figure operational semanticsofjvm jit wheredom denotes thedomainofthe partialfunction inst binopopbinary operation ontheoperandstack pushvpushvaluevontop of theoperandstack pop popvalue from top of theoperandstack swap swapthetop twooperandstackvalues loadxloadvalue of xontotheoperandstack storexpopand storetop of theoperandstackin x getyloadvalue of yontotheoperandstack putypopand storetop of theoperandstackin y ifeqjconditionaljump ifneqjconditionaljump gotojunconditional jump invokeminvokethemethod m m return return thetop value of theoperandstack deoptmddeoptimizewithmeta data md figure3 instructionsetofjvm jit wherex lvarisalocal variable and y gvarisaglobalvariable list of instructions taken from the instruction set in figure .
all theseinstructionsarestandardexceptfor deoptmdwhichmodels uncommontraps cf.section .
foreachmethod m m denotestheinstructionattheprogram pointiandargv m denotes the formal arguments of m. when a method is invoked the execution starts with the first instructionm .
we also denote by m forj ithe sequence of instructions m m m .
compilationdirective.
tomodelmethodcompilationwithprocedure inline branch prediction and optimistic compilation optimizations weuse compilation directiveswhichspecifyhowthe method should be re compiled and optimized at runtime.
let dm bethesetofdirectivesofthemethod m andd m themethodafter jitcompilationaccordingtothedirective d.inparticular weuse d dmto denote no re compilation.
the formal definition of directives isgiven inthe following subsection.
in general a method in bytecode is compiled into native code which may be iteratively recompiled later.
hence we assign to each method ma version number vm where the bytecode has the versionnumber andvmax 0isthe highestversionnumber.
a directived dmisvalidifm d m andvm vm otherwise d isaninvaliddirective.intuitively theversionnumber vmindicates theoptimizedlevelofthemethod m.jitrecompilationonlyusesincreasinglyaggressive optimizationtechniques and rolls backto the bytecode versionotherwise.
state.astateis a tuple pc m os wherepc nis the program counter pointing to the next instruction m mis the current executingmethod lvar valisapartialfunctionfromlocal variables to values and os val isthe operand stack.
we denote bystatesthe set of states.
for each function f x v variable x xand valuev v letf be the function where f x f x ifx x andf x votherwise.
for two operand stacks os1 os2 val letos1 os2denote their concatenation.
the emptyoperand stack isdenotedby .
configuration.
aconfiguration isoftheform ch h s cs or h v wherechis a code heap storing the latest version of methods h gvar valis a data heap i.e.
a partial function from global variables to values s statesis the current state cs states is the call stack and v valis a value.
configurations of the form h v are final configurations reached after the return of the entry point.aconfiguration ch h pc m os cs isinitialifpc m is the entry point of the program and os cs .confdenotes thesetofconfigurations cs1 cs2denotestheconcatenationoftwo callstacks cs1andcs2 denotesthe emptycallstack.
operationalsemantics.
thesmall stepoperationalsemanticsof jvmjitis givenin figure 2as arelation conf conf where leadsto states statesis anauxiliary relation.
note that the directive dapplies to methodinvocations only.
instruction pushv pushesthevalue vontopoftheoperandstack.
instruction pop just pops the top of the operand stack.
instruction binopoppops the top two operands from the operand stack and pushestheresult ofthebinary operation opusing theseoperands.
instruction ifeqj resp.ifneqj pops the top vof the operand stack and transfers of control to the program point jifv resp.
v otherwise to the next instruction i.e.
the program point j .
instruction swap swaps the top two values of the operand stack.
instruction storex resp.puty pops the topofthe operand stack and stores it in the local variable x resp.
global variable y .
instruction loadx resp.gety pushesthevalueofthelocalvariable x resp.
global variable y on top of the operand stack.
instruction gotojunconditionallyjumpsto program point j.
875dejitleak eliminating jit inducedtiming side channel leaks esec fse november14 18 singapore singapore ... i ifeq j i ... j goto j j ... j inst ...j method m bf btmethod m ... i ifeq m j j m j j ...i ... j inst ...j btbf branch prediction optimization to i ifeq j j inst m inst m m goto j figure branch prediction optimization instruction returnendstheexecutionofthecurrentmethodand returns the top value vof the current operand stack.
if the current methodisnottheentrypoint vispushedasthetopoftheoperand stack of the caller and the caller is resumed from the return site otherwise thefinalconfiguration h v isreached.weassumethat eachmethodhasaunique returninstructionwhichdoesnotappear inconditionalstatements asearlyreturnoftenintroducestiming side channel leakseven withoutjitcompilation.
instruction deoptmddeoptimizes the current executing method androllsbacktothebytecodeintheinterpretedmode.thisinstruction is only used in native code and inserted by jit compilers.
our semantics does not directly model a deoptimization implementation.
instead we assumethere isa deoptimization oracle owhich takes the current configuration and the meta data mdas inputs and reconstructs the configuration i.e.
heap h statesand the call stack cs .
furthermore the bytecode version base version m of the method mis restored into the code heap ch.
the oracle o results in the same heap h statesand call stack cs csas if the methodmwere not jitcompiled.
thesemanticsof invokem dependsonthedirective d.ifd d theversionof m inthecodeheap chremainsthesame.if disvalid i.e.
the version number vm of the optimized version m d m is larger than that of the current one vm m is stored in the code heapch.afterthat itpopsupthetop argv m valuesfromthe currentoperandstack passesthemastheformalargumentsto m pushes the calling context on top of the call stack and starts to executem inthe code heap.
to define a jit execution we introduce the notion of schedules.
avalid schedule d for a configuration cis a sequence of valid directivessuchthattheprogramwillnotgetstuckwhenstarting fromcandfollowing d formethodinvocations.
avalidschedule d yields ajit execution c0 d cnthat is a sequence c0c1 cn ofconfigurationssuchthat c0isaninitialconfiguration cnisthe final configuration and for every i n eitherci ci orci dici .
we require that d is equal to the sequence of directives along the jit execution i.e.
the concatenation of di s. a jit free execution is thus a jit execution c0 d cn.
in this work we only considerprograms that alwaysterminate.
.
jitoptimization ofjvm jit we first define branch predictionand optimisticcompilation then definemethodcompilation as well as compilation directives.method m ... i ifeq m j j m j j i ... j inst ...j bf to if branch of i ifeq j uncommon trap method m ... i ifneq m j i m j i i ... j j i inst ...j j i bt uncommon trap to else branch of i ifeq j figure optimisticcompilation optimization branch prediction.
fix a method mand an instruction m ifeqj.
ifneqis handled accordingly.
let bt resp.bf be the instructionsappearingintheif resp.else branchof m andthe lastinstruction m ofbfisgotoj .thefirstandlastinstructions ofbfarem andm respectively.
iftheprofilingdatashowthattheprogramfavorstheelse branch thebranchpredictionoptimizationtransformsthemethod mintoa newmethod m1form ifeqj cf.figure .theformaldefinition andan illustrating example are given inthe technical report .
if the profiling data show that the program favors the if branch thebranchpredictionoptimizationtransformsthemethod minto a new method m2 similar to m1 except that the conditional instruction ifeqjis replaced by ifneq m j i 1which is immediately followed by the if branch bt the else branch bfis movedtotheendofthemethodstartingatthepoint m j i and the target point of the last instruction gotoj is revised to j j i .
wedenoteby tbp m i else b andtbp m i if b themethods m1 andm2respectively.obviously thebranchpredictionoptimization transformsthe originalprogram to asemantically equivalentone.
optimistic compilation.
again consider the conditional instructionm ifeqjwith the if branch btand else branch bf.
ifneq can be dealt withaccordingly.
iftheprofilingdatashowthattheif branchrarelygetsexecuted the optimistic compilation optimization transforms the method m intoanewmethod m1inasimilarwayto tbp m i else b except thattheif branch btisreplacedbyanuncommontrap asshown in figure left part .
the method m2is defined similarly if the else branch rarely gets executed as shown in figure right part .
we denoteby toc m i else b andtoc m i if b the newmethodsm1andm2after transformation.
it is easy to see that the optimisticcompilationoptimizationisanequivalentprogramtransformationundertheinputsthatdoesnottriggeranyuncommon traps.
method compilation.
at runtime frequently executed small methods may be inlined to reduce the time required for method invocations.
after that both branch prediction and optimistic compilation optimizations could be performed.
thus a compilation directive of a method should take into account procedure inline branchprediction andoptimistic compilation optimizations.
we define a compilation directive dof a method mas a pair t wheretisalabeledtreespecifyingthemethodinvocations 876esec fse november14 18 singapore singapore qi qin julianandresjiyang fusong taoluechen xinyu xing tobeinlined and isasequencespecifyingtheoptimizationsof branches.formally thelabeledtree tisatuple v e l wherevis afinitesetofnodessuchthateachnode n vislabeledbyamethod l n and the root is labeled by m eis a set of edges of the form n1 i n2 denotingthatthemethod l n2 isinvokedatthecallsite iofthemethod l n1 .wedenoteby t m thenewmethodobtained frommby iteratively inlining method invocations in t. we assume the operand stack of each inlined method is balanced otherwise theadditionalpopinstructionsareinserted.thesequence isof the form t1 i1 b1 tk ik bk where for every j k tj tbp toc denotestheoptimizationtobeappliedtothebranch pointijin the method t m with the branch preference bj.
we assume that an index ijoccurs at most once in as at most one optimization can be appliedto one branchpoint.
.
consistencyandtime balancing asusual weassumethateachprogramisannotatedwithasetof publicinputvariables whiletheotherinputsareregardedassecret inputvariables.wedenoteby c0 pubc 0iftwoconfigurations c0 andc 0agree on the public input variables and denote by c0 chc ifc0andc 0have the same code heap.
consistency .
it is easy to deduce the following theorem which ensurestheequivalenceofthefinalmemorystoreandreturnvalue from the jit free executionandjit execution.
theorem3.
.
foreachinitialconfiguration c0oftheprogram p and each valid schedule d forc0 wehave c0 d ciffc0 d c .
if the output variables are partitioned into public and secret we denotebyc pubc thattwoconfigurations candc agreeonthe publicoutputvariables.
theorem3.
.
foreachpairofinitialconfigurations c0 c ofthe programpwithc0 pubc 0andeachpairofvalidschedules d 1and d 2forc0andc 0respectively wehave c0 c c c andc pubc iffc0 d 1c c d 2c andc pubc .
thetheoremstatesthatobservingpublicoutputvariablescannot distinguish secret inputs without jit compilation iff observing public output variables cannot distinguish secret inputs with jit compilation.
time balancing.
to model execution time we define cost functions for bytecode and native code.
let cfbcandcfncbe the cost functions for instructions from the bytecode and native code respectively.
we denote by cf inst the cost of the instruction inst which is cfbc inst if it is running in bytecode mode otherwise cfnc inst .
we lift the function cfto states and configurations as usual e.g.
cf pc m os cf m .
the cost cf c0 d cn of ajit execution c0 d cnisthesumofallthecostsoftheexecuted instructions i.e.
summationtext.1n i 0cf ci .
definition3.
.
aprogrampistime balanced withoutjitcompilation ifforeachpairofinitialconfigurations c0 c ofpsuchthat c0 pubc 0and the code heaps of c0andc 0have the same bytecode instructions we have cf c0 d c cf c d c .
intuitively thetime balancingrequiresthattwojit freeexecutions have the same cost if their public inputs are the same andcodeheapshavethesamebytecodeinstructions thuspreventing timing side channel leakswhen jit compilation isdisabled.
jit time balancing.
to define time balancing under jit compilation calledjit time balancing we firstintroduce somenotations.
consider a jit execution c0 d cnand a method m. we denote byprojm c0 d cn the projection of the sequence of executed instructionsin c0 d cnontothepairs i m eachofwhichconsists ofaprogrampoint iandaversion m ofthemethod m.aproper prefix ofprojm c0 d cn canbeseenastheprofilingdataofthe methodmafterexecutingtheseinstructions whichdeterminesa uniquecompilationdirectiveofthemethod mafterexecuted .we leaveruntimeprofilingabstractinordertomodelalargevarietyof jitcompilationsanduse hatwide todenotetheprofilingdataof mafter executedinstructions ofmorits compiledversions.
fixaprofiler pfthatprovidesonecompilationdirective pfm hatwide of amethodmusingtheprofilingdata hatwide .theschedule d iscalleda pfscheduleif foreachmethod mandproperprefix ofprojm c0 d cn the nextcompilation directive of mind after ispfm hatwide .
lemma3.
.
foreachpairofinitialconfigurations c0 c ofpwith c0 chc andeachpairofvalid pf schedules d 1andd 2forc0and c 0respectively we have for every method m every pair 1 2 of properprefixesof projm c0 d 1c andprojm c d 2c respectively if 1 2thenpfm hatwide 1 pfm hatwide 2 .
thelemmaensuresthatthecompilationdirectivesofeachmethod injit executionsare the same underthe same profiling data.
we assume that for each time balanced branching statement in bytecode the corresponding branching statement in native code is stilltime balancedifnojitoptimizationisapplied.thisassumption isreasonableinpractice asbothsidesofatime balancedbranching statement in bytecode tend to have similar functionality and instruction sequences thus time balanced branches are often nearly balancedaftercompilationifnojitoptimizationisapplied.remark thatourformalismisgeneralinprinciple assuitablecostfunctions could be adoptedif one prefers to modelthemprecisely.
definition3.
.
aprogrampisjit time balanced if foreverypair of initial configurations c0 c ofpwithc0 pubc 0andc0 chc everypairofvalid pf schedules d 1andd 2forc0andc 0respectively satisfiescf c0 d 1c cf c d 2c .
intuitively thejit time balancingensuresthattwojit executions havethesamecostiftheirpublicinputsandinitialcodeheapare the same and the valid schedules have the same profiler pffor jit compilation so it prevents jit induced leaks even if the jit compilation is enabled.
remark that our definition considers powerful attackers who can control executing instructions with chosen inputs before launching attacks so that the code heaps in c0and c 0maybemixedwithbytecodeandnativecodeandcompilation directives are controlled during attacking which is common in the study of detection and mitigation.
in practice the feasibility of compilation directives depends on various parameters in vm e.g.
whetheramethodinvocationshouldbeinlineddependsonitscode size invocation frequency methodmodifier etc.
protectmechanismand type system in this section based on the above formalism we first propose a two level protection mechanism to prevent jit induced leaks and 877dejitleak eliminating jit inducedtiming side channel leaks esec fse november14 18 singapore singapore m pushvst pt st m i pt ht lt st pt ht lt st t pushm binopopst 1 2 pt st m i pt ht lt 1 2 st pt ht lt st t bopm storexlt lt m i pt ht lt st pt ht lt st t str m popst st m i pt ht lt st pt ht lt st t popm swap 1 pt 2 pt m i pt ht lt 1 2 st pt ht lt st t swapm loadxst lt x pt st m i pt ht lt st pt ht lt st t load m putyht ht m i pt ht lt st pt ht lt st t putm ifeqjpt ptpt h i pm2 m m i pt ht lt st pt ht lt st t ifm gotoj m i pt ht lt st pt ht lt st t goto m getyst ht x pt st m i pt ht lt st pt ht lt st t getm ifneqjpt ptpt h i pm2 m m i pt ht lt st pt ht lt st t ifnm return ht sigp m m i pt ht lt st ht t ret m invokem argv m x0 xk pt1 ht1 lt1 m ht2 pt pt1ht ht1 0 lt1 x0 k lt1 xk pt m i pt ht lt k 0 st pt ht2 lt st t call figure typing rules thenpresentaninformation flowtypesystemforprovingjit timebalancing underour protectedjitcompilation.
.
protectionmechanism thefirstlevelofourprotectionmechanismistodisablejitcompilation and inlining of methods which potentially induce leaks.
wedenoteby pm1thesetofmethodsthatcannotbejitcompiled or inlined while methods m m pm1can be jit compiled or inlined.the secondlevelisto disablejit optimization ofbranch points in methods m pm1 whose optimization will potentially induceleaks.we denote by pm2themappingfrom m pm1to sets ofbranchpointsthatcannotbejitoptimized.whenthemethod misjitcompiled pm2 m willbe updatedaccordingly.
fromtheperspectiveofjvm jitsemantics thecompilationdirectiveofanymethodfrom pm1islimitedto d andthecompilation directivesofanymethod m m pm1canneitherinlineamethod frompm1noroptimize the branchat aprogram pointin pm2 m .
acompilationpolicy ofaprogram pisgivenbyapair pm1 pm2 .
apf schedule d thatiscomplianttothecompilationpolicy pm1 pm2 iscalleda pm1 pm2 schedule.
.
typesystemandinference weproposeaninformation flowtypesystemforprovingthattimebalancedprogramsare jit time balancedundera fine grainedjit compilation withacompilation policy pm1 pm2 .
latticeforsecuritylevels.
weconsideralatticeofsecuritylevels l h l withl l l h h handh nsubsetsqequall.
initially all the public inputs have the low security level land the other inputs havethehighsecuritylevel h.wedenoteby 1 2theleastupper bound of two security levels 1 2 l namely h h h for landl l l. typingjudgments.
ourtypesystemsupportsprogramswhose control flow depends on secrets.
thus the typing rules for instructions rely on its path context pt which indicates whether an instruction is contained in a secret branch.
we use functions ht gvar landlt lvar lwhich map global and local variables to security levels.
we also use a stack type i.e.
a stack of security levels stfor typing operand stack.
the order is lifted to the functions and the stack type as usual e.g.
ht1 ht2if ht1 y ht2 y for eachy gvar.
atyping judgment for non return instructions is of the form m i pt1 ht1 lt1 st1 pt2 ht2 lt2 st2 wheremisthemethod under typing iis a program point in m. this judgment states that given the typing context pt1 ht1 lt1 st1 the instruction m yieldsanewtypingcontext pt2 ht2 lt2 st2 .atypingjudgment of thereturnisoftheform m i pt ht lt st ht wherehtis the security levels of the global variables and is the security level ofthe return value.
asecurityenvironment semofamethod misafunctionwhere for every program point iofm sem i is a typing context ht if m isareturn instruction and pt ht lt st otherwise.
method signature.
a security signature of a method mis of the form pt ht1 lt1 m ht2 which states that given the typing context pt ht1 lt1 eachglobalvariable y gvarhasthesecurity levelht2 y and the return value of the method mhas the security level .eachinvocationof mshouldrespectthesignatureof m.the signature of the program p denoted by sigp is a mapping from themethodsoftheprogram ptotheirsignatures.sinceamethod invoked in any secret branch cannot be jit compiled or inlined we require that forany m m m pm1if the path context ptin sigp m isthe high security level h. typingrules.
thetypingrulesareshowninfigure wherethe key premises are highlighted and ht sigp m means that ht ht and forsigp m pt ht1 lt1 m ht .
thetypesystemonlychecksbytecodeprograms thusthereis notypingruleforthedeoptimizationinstruction deoptmd.rules t push t pop t bop and t swap track the flow of the secret data via the operand stack.
rules t str t load t put and tget track the flow of the secret data via local and global variables.
rule t goto does not changethe typing context.
rules t if and t ifn require that the path context pt of each branch has a security level no less than the current path context andthesecuritylevelofthebranchingconditionontopofthestack.
this allowsustotrackimplicitflowsduring typing.furthermore thebranchpoint ishouldnotbeoptimizedbyrequiring i pm2 m ifpt has the high security level h otherwise the branches may become unbalanced resultinginjit inducedleaks.
rule t ret requires ht sigp m that avoids the security levels of the global variables in htand the security level of the returnvaluearegreaterthantheseinthemethodsignature sigp m .
rule t call ensures that the context of invokem meets the signature sigp m pt1 ht1 lt1 m ht2 e.g.
pt pt1 avoidingthatthecurrentpathcontext pthasasecuritylevelgreater thantheexceptedone pt1 and 0 lt1 x0 k lt1 xk avoidingthatactualargumentshavethesecuritylevelsgreaterthanthat offormalarguments.
878esec fse november14 18 singapore singapore qi qin julianandresjiyang fusong taoluechen xinyu xing typablemethods.
thejit time balancingisverifiedbytypeinference.toformalize this we firstintroduce somenotations .
letusfixamethod m.foreachprogrampoint i letnxtm i bethe setofsuccessorsof iw.r.t.thecontrolflow.formally nxtm i j ifm isgotoj nxtm i i j ifm isifeqjorifneqj nxtm i ifm isreturn andnxtm i i otherwise.
foreachbranchpoint i letjunc i denoteitsjunctionpoint i.e.
theimmediatepost dominatorof i. recallthatwe assumedthere is no early return in branches thus junc i is well defined.
we denoteby region i thesetofprogrampoints jthatcanbereached from the branch point iand are post dominated by junc i .
we denoteby maxbp j thesetofbranchpoints isuchthatj junc i andregion i region i for anyi maxbp j .
intuitively maxbp j contains the branch points iwith the junction point jandregion i is not contained by region i of any other branch pointi with the same junction point j namely nested branch pointsi ofthe branchpoint iare excluded.
the method mistypablew.r.t.sigpand pm1 pm2 denoted by pm1 pm2 sigp m ifthereexistsasecurityenvironment semsuch thatsem pt ht lt forsigp m pt ht lt m ht andoneofthefollowingconditionsholdsforeachprogrampoint i ifiisnotajunctionpoint then m j sem j sem i forthe program point jsuch that nxtm j i ifiisajunctionpoint suppose sem i pt ht lt st thenthe following twoconditions hold there exists some j maxbp i withpt ptandsem j pt ht lt st ht ht lt lt andst st fornxt j iandsem j pt ht lt st .
intuitively pm1 pm2 sigp mrequires that i secret branches areforbidden tobeoptimizedby pm2and ii methods m invoked inregion i of any secret branches m are forbidden to be jit compiled and inlined.
recall that we have assumed m pm1if the pathcontext ptinsigp m has the high security level h. a program pistypablew.r.t.sigpand pm1 pm2 denoted by pm1 pm2 sigp p if i the signature sigmof the entry point mis l ht lt m ht such that ht y handlt x hfor any secretinputs x y and ii pm1 pm2 sigp mfor everym m. theorem4.
.
ifprogrampistime balancedand pm1 pm2 sigp p thenpis jit time balanced under pm1 pm2 schedules.
the proof is provided in the technical report .
note that the native code in the code heap of each initial configuration can only be compliedfrom bytecode following the policy pm1 pm2 .
implementation forpracticaljava wehaveimplementedourapproachasatool dejitleak forrealworldjavabytecode jarpackages .
dejitleak consistsoftwomain components type inference for computing a signature sigpand apolicy pm1 pm2 suchthat pm1 pm2 sigp p andaprotection mechanisminhotspot from openjdk .
.
typeinference ourtypeinferenceisbuiltonjoana asound flow context andobject sensitiveinformationflowframeworkbasedonprogram dependence graphs pdgs .
given a program pannotated withpublic inputs we first identify secret inputs and then leverage joana to compute a security environment semand a signature sigp m for each method mvia solving flow equations.
we then locate all the branch points in each method mwhose path context orbranchingconditionhasthehighsecuritylevel h namely allthe secret branches.
these branch points are added in pm2 m as they can potentially induce toptiandtbranleaks when jit optimized.
fromthebranchpoints pm2 m weidentifyandextractallthe methods invoked within region i for all the branch points i pm2 m .
these methods can potentially induce tmethleaks when jit compiled or inlined thus are added in pm1.
according to our typesystemandthesoundnessofjoana theprogram pistypable w.r.t.sigpand pm1 pm2 i.e.
pm1 pm2 sigp pholds.
.
protectionmechanism in hotspot to enforce a compilation policy pm1 pm2 during jit compilation we modify hotspot to demonstrate our approach.
to prevent a methodm pm1from being compiled and inlined we use the optioncompilecommand supportedbyhotspot namely xx compilecommand exclude signature of the method xx compilecommand dontinline signature of the method where theoption excludedisables jitcompilation ofthemethod signature of the method anddontinline preventsthemethod signature of the method from procedure inline.
unfortunately hotspot does not provide any option that can beusedtospecifybranchpointswherebranchpredictionand or optimistic compilation can be disabled.
therefore we modified hotspot to support an additional command dontprune that allows us to specify branch points.
the command dontprune is used similar toexclude but with an additional list of branch points for the specifiedmethod.
duringjit compilation bothbranchprediction and optimistic compilation are prohibited for all these branch points even if the methodisrecompiled.
.3dejitleak light toreduceperformanceoverhead wealso proposeand implement analternativeprotectionmechanism dejitleak light.itonlydisables the inlining of the methods m pm1whereas dejitleak disables both jit compilation and inlining of the methods m pm1.
thisweakerprotectionmechanismisstillsoundundertheassumption that the methods invoked on both sides of each secret branch point are the same.
this assumption is reasonable in practice as it isastraightforwardfordeveloperstoimplementatime balanced program by invoking same methods in both sides of each secret branchpoint.remarkthatinliningmethodshouldbedisabledeven ifamethodisinvokedonbothsidesofasecretbranchpoint asthe methodmaybe inlinedonly inone branch inducingleaks.
evaluation we first evaluate the efficiency of the type inference and then compare our approach with other strategies nojit disablec2 andmexclude cf.
section .
.
accordingto weonlydisable jit compilation of the methods that contain some secret branch pointsfor mexclude.finally we conduct acasestudy.
experimentsetup .
we evaluate dejitleak anddejitleak light onthebenchmarksusedinrecentside channeldetection blazer 879dejitleak eliminating jit inducedtiming side channel leaks esec fse november14 18 singapore singapore themis coco channel diffuzz and jvmfuzz including real world programs from well known java applications such as apache ftpserver micro benchmarks from darpa stac and classic examples from the literature .
recall that we target time balanced java bytecode.
thus we only consider the safe versions i.e.
programs that are leakage free or only have slight leaks under their leakage models without jit compilation.
we also exclude the benchmarks tomcat pac4j andtourplanner from themis as tomcatandpac4jhave significant leakages whiletourplanner istime consuming .5hourperexecutionandwe shall runeach benchmark timesperbranch .
the remaining benchmarks are shown in table where loc shows the number of lines in the java source code counted by cloc .
note that for the purpose of experiments k96 modpow1 andmodpow2 are patchedversionsof k96 modpow1 andmodpow2 andunixlogin is apatchedversionbydiffuzztoresolvethenullpointerexception errorinits originalversionfrom blazer.
allexperimentsareconductedonanintelnucrunningubuntu .
with intel core i5 8259u cpu .30ghz and 16gb of memory.
to be practical we do not disable cpu level and other jit optimizations when jitcompilation isenabled.
insummary theresultsshowthat dejitleak ismoreeffective thandisablec2andmexcludeonalmostallthebenchmarks and dejitleak lightisabletoachievecomparableeffectivenessas dejitleak andinducessignificantly less performance loss.
.
results oftypeinference table1showstheresults wherecolumns nodeand edgeshow thenumberofnodesandedgesinthecorrespondingpdgonwhich type inference is performed column ttaint ms shows the execution time of type inference column ttotal s gives the overall execution time and column mem mb gives the overall memory consumption.
we observe that these benchmarks can be solved efficiently.ittakes1.99secondsonaverage upto5.52seconds and 254mbforonebenchmark.notethattheoveralltimeandmemory consumption does not necessarily correlate with loc e.g.
on gpt14vs.k96 because we only counted the number of lines in the java source code but excluded the code of invoked methods from libraries which were also analyzed during type inference.
we notethatthetimeandmemoryofanalyzingahelloworldprogram withouttaint sourceis0.93secondsand161mb.
.
effectiveness andefficiency weevaluatetheeffectivenessbyquantifyingtheamountofleakages in practice using mutual information a widely used metric for side channel analysis .
the mutual information of a program containing a vulnerable conditional statement with the secret condition kand execution time tis defined as i k t h k h k t whereh k isclassicalshannonentropy measuringuncertaintyabout k andh k t istheconditionalshannonentropyof kgivent.i k t measurestheuncertaintyabout k afteranattackerhaslearnedtheexecutiontime t.wecreateattacks to explore the maximum amount of leakages according to .
to discretize the execution time t we split it into a bins.
note that the closer the mutual information value is to the stronger the relationship between the branch condition kand execution time t.table results oftype inference name loc node edgettaint ms ttotal s mem mb clear .
.
md5 .
.
salted .
.
stringutils .
.
244diffuzz authmreloaded .
.
array .
.
gpt14 .
.
k96 .
.
login .
.
loopbranch .
.
modpow1 .
.
modpow2 .
.
passwordeq .
.
sanity .
.
straightline .
.
163blazer unixlogin .
.
bootauth .
.
jdk .
.
jetty .
.
orientdb .
.
picketbox .
.
238themis spring .
.
the results are reported in table 2in the average of experiments for eachbenchmark where the bestresults among different methods are in bold face .
the second and third columns show the leakageandexecutiontimewithoutanydefense.theothercolumns showtheleakagewiththecorrespondingdefenseandtheoverhead calculated as the ratio execution time with the defense execution time withoutdefense inducedbythe defense.
effectiveness .
overall we can observe that all these safe programs are vulnerable i.e.
nonnegligible leakage due to jit compilation disablingjitcompilation nojit caneffectively reduce jit induced leakages for most programs except for array login loopbranch straightline andunixlogin dejitleak and dejitleak lightperformsignificantlybetterthandisablec2and mexculde even better than nojit on some benchmarks e.g.
md5 array login loopbranch sanityjdk andjetty dejitleak and dejitleak lightare almostcomparable.
efficiency .wemeasuretheefficiencyofrespectiveapproachby the times the execution time is increased.
in general nojit incursthe highestperformancecost disablec2and mexclude leadtonearly2 7timesruntimeoverhead dejitleak incurs moreoverheadthandisablec2andmexclude butstilloutperforms disablec2andmexcludeonmanybenchmarks dejitleak light bringsthe leastruntimeoverhead upto .82times .
on some benchmarks e.g.
authmreloaded array login loopbranch sanityandjdk dejitleak performsbetterthandisablec2.
itisbecausedisablec2completelydisablesc2modecompilation forallthemethods whereas dejitleak disablesjitcompilation and procedure inline of methods invoked in secret branches.
thus dejitleak performsbetterthandisablec2whenmanymethods canbecompiledinthec2modeatruntime.wenotethatmexclude allowsjitcompilationandinliningofmethodsinvokedinsecret branches thus outperforms dejitleak in general.
when many methods contain secret branches but few methods are invoked therein dejitleak performs betterthanmexclude.
880esec fse november14 18 singapore singapore qi qin julianandresjiyang fusong taoluechen xinyu xing table evaluationresults of dejitleak anddejitleak light benchmark nojit disablec2 mexclude dejitleak dejitleak light name leakage time s leakage overhead leakage overhead leakage overhead leakage overhead leakage overhead clear .
.
.
.
.
.
.
.
.
.
.
.
md5 .
.
.
.
.
.
.
.
.
.
.
.
salted .
.
.
.
.
.
.
.
.
.
.
.
stringutils .
.
.
.
.
.
.
.
.
.
.
.
authmreloaded .
.
.
.
.
.
.
.
.
.
.
.00diffuzz average .
.
.
.
.
.
.
.
.
.
.
.
array .
.
.
.
.
.
.
.
.
.
.
.
gpt14 .
.
.
.
.
.
.
.
.
.
.
.
k96 .
.
.
.
.
.
.
.
.
.
.
.
k96 .
.
.
.
.
.
.
.
.
.
.
.
login .
.
.
.
.
.
.
.
.
.
.
.
loopbranch .
.
.
.
.
.
.
.
.
.
.
.
modpow1 .
.
.
.
.
.
.
.
.
.
.
.
modpow1 .
.
.
.
.
.
.
.
.
.
.
.
modpow2 .
.
.
.
.
.
.
.
.
.
.
.
modpow2 .
.
.
.
.
.
.
.
.
.
.
.
passwordeq .
.
.
.
.
.
.
.
.
.
.
.
sanity .
.
.
.
.
.
.
.
.
.
.
.
straightline .
.
.
.
.
.
.
.
.
.
.
.
unixlogin .
.
.
.
.
.
.
.
.
.
.
.37blazer average .
.
.
.
.
.
.
.
.
.
.
.
bootauth .
.
.
.
.
.
.
.
.
.
.
.
jdk .
.
.
.
.
.
.
.
.
.
.
.
jetty .
.
.
.
.
.
.
.
.
.
.
.
orientdb .
.
.
.
.
.
.
.
.
.
.
.
picketbox .
.
.
.
.
.
.
.
.
.
.
.
spring .
.
.
.
.
.
.
.
.
.
.
.06themis average .
.
.
.
.
.
.
.
.
.
.
.
.
casestudy we discuss someinterestingcasestudiesbelow.
array login loopbranch straightline unixlogin resultsshow that their leakages are significant in practice although they are safe benchmarkswithoutjitcompilation .wefoundthat array login loopbranch andstraightline have balanced branches in terms of the number of instructions at the source code level.
however a branch with a balanced number of instructions does notnecessarilyhavebalancedexecutiontimeevenifjitisdisabled.
thisindicatesthatmodelingtime balancingusingthenumberof instructions may not be precise.
interestingly both dejitleak anddejitleak lightare able to significantly reduce the leakage ofarray login loopbranch andstraightline .
this is because the percentage of timing difference is fixed the program speeds up withthejitcompilation i.e.
loweroverhead makingsidechannelunstable and difficult to observe due to the fixed noise.
the case forunixlogin is slightly different.
recall that unixlogin is a patched version by diffuzz to resolve the nullpointerexception error in its originalversion fromblazer.however thispatch introduceda leakage whichisalwayssignificantly observable.
stringutils we observe that only nojit effectively reduces the jit inducedleakageof stringutils .wefoundthat stringutils evaluates a method in apache ftpserver that pads a string to a specified length whereaninsecureversionwouldleakinformationaboutthe originalstring slength.
dejitleak anddejitleak lightsuccessfully eliminated the jit induced leak in this method guaranteeing the balance of secret branches in the native code.
however due tocpu leveloptimizations e.g.
speculativeexecution theexecution time ofdifferentbranches varieswithsecretinputs.
k96 modpow1 modpow2 similar to stringutils we observe that onlynojiteffectivelyreducestheirjit inducedleakages.these programs implement various components of the rsa cryptosystem smodularexponentiationusingtheclassicsquare and multiply algorithm thus their leakages would result in key recovery attacks .dejitleak anddejitleak lightindeed canguarantee that no leaks are induced by jit compilation in the native code.
however due to cpu level optimizations the execution time of the branches varies with secret inputs.
to reduce such noise we createdpatchedversions k96 modpow1 andmodpow2 bymoving thetime consumingoperationsfrombranchestooutsideoftheir branching point.
after patching most defense solutions are able to reduce the jit inducedleakages.
bootauth dejitleak isnoteffectiveon bootauth duetoanunbalanced branching statement in bytecode.
according to our policy we need to disable jit compilation for methods i.e.
fromjson gettimeandgetexpires invoked in secret dependent branches but other methods can be jit complied including the c2 mode compilation.butthisunfortunatelyamplifiesthetimingdifferenceof the existing leak compared over the entire execution time.
remark that our approach is designed for programs that are time balanced at the bytecode level.
.
discussion limitations.
first the execution of jvm profiling jit compilationandgarbagecollectionthatmayaffecttheoverallexecution 881dejitleak eliminating jit inducedtiming side channel leaks esec fse november14 18 singapore singapore time.wedidnotformalizethem astheyareoftenexecutedasynchronously in different threads and are difficult to be exploited.
to our knowledge no attack leverages them.
second we did not formalismcpu level suchasspeculativeexecutionandcache and other jit optimizations e.g.
constant propagation loop unfolding anddeadelimination thatmayinducetimingside channelleaks.
such leaks have been considered for statically compiled binary code .
to our knowledge no existing attack leverages those optimizationsfor javaprograms.
jit inducedleaksare significant to be exploited remotely in real world applications thus for the sake of separating concerns we do not consider other leakages.
to detectandmitigatetimingside channelleaksinducedbycpu level optimizations onemaycombineourapproachwithexistingones e.g.
.
this is a future work to be explored.
threats.
the first main threat to our evaluation is the noise of execution time introduced by the compiler e.g.
jvm profiling jit compilation and garbage collection and hardware e.g.
cpu level optimizations .tomitigatethethreat weruneachbenchmark1 times per branch in real world jvm hotspot without disabling cpu level and other jit optimizations.
the second main threat to our evaluation is the small benchmarks and non interference from other users.
in this setting the attacks are more powerful namely the adversaryisable tomeasureand prime accurately and thus are more difficult to defeat.
we do not impose a bound on the attacker sability thereforeprovidetheoreticsecurityguarantees.in practice the timing measurement would be lessundistinguishable andtheprimewouldbemoredifficultduetosignificantinterference from other users or the jit itself on large programs.
therefore the evaluation results insuch asettingshould be validatedinfuture.
related work timing side channel attacks have attracted many attentions with a significant amount of work devoted to its detection verification and mitigation which vary in targeted programs leakage models techniques efficiency andprecision etc.
morerecentworkfocusesonothersourcesoftimingside channels inducedbymicro architecturalfeatures e.g.
spectre andmeltdown orcompilation e.g.
jit inducedleaks whereprovablyleakage freeprograms orwithslightleakages maybecome vulnerablewhentheyaretakenintoaccount.ourworkiswithin this category.
micro architecturalfeaturesallownewtimingside channelattacks such as spectre meltdown and variants thereof .thisproblemhasbeenrecentlystudied 37 39 67 69 wherespeculativeexecutionsemantics notionsof constant timeunder thenewsemantics detection andmitigation approaches etc have been proposed.
among them blade is theclosesttoourwork whichaimstoensurethatconstant time programsareleakage freeunderspeculativeandout of orderexecution.ourworkissimilarinspirit butastheleaksinducedby jitcompilationandmicro architecturefeaturesaredifferent the concretetechnology e.g.
securitynotions detectionandmitigationapproaches inthispaperisnew.moreover asdiscussedinour experiments native code compiled from bytecode may suffer from leakages induced by micro architectural features.
such leakagescouldpotentiallybeeliminatedbyintegratingexistingmitigation approaches e.g.
blade intojit compilation.
besides jit compilation static compilation can also introduce timingleakages.toaddressthisproblem constant timepreserving compilationhasbeenstudied andsubsequentlyimplementedin theverifiedcompilercompcert .however theydisallowsecret branches increasingthedifficultyofimplementingconstant time programs.follow upworkincludesconstant resourcepreserving compilation andtimingside channelsecurityanalysisofbinary code .however noneofthemconsideredjitcompilationwhich isfarmore complex thanthe staticcompilation.
theworkonjit inducedtimingchanneliscurrentlyverylimited.theworkclosetooursis .thejit inducedleaks proposedin demonstratedhowjitcompilationcanbeleveragedtomounttimingside channelattacks.afuzzingapproachwas proposedtodetectjit inducedleaks .however itmayreport false negatives and cannot mitigate jit induced leaks.
the three strategies i.e.
nojit disablec2andmexclude proposedin have been discussedandcomparedinsection .2andsection .
.
inadditiontodetectingandmitigatingtimingside channelattacks there are techniques for detecting and mitigating power side channel attacks and attacks against securemulti partycomputation wheretheadversaryisable to observe all the public information during computation.
each type of attack has unique characteristics in general these existing techniques are orthogonalto our work.
conclusion in this paper we formalized time balancing under jit compilation based on which we proposed an automated approach to eliminate jit induced leaks.
our approach systematically detects potential leaks via a precise information flow analysis and eliminates potentialleaksvia afine grainedjit compilation.we implementedour approach in the tool dejitleak for real world java programs.
the evaluationshowed that dejitleak ismore effective thanexisting solutions and provides a trade off between security and performance.
the lightweight variant dejitleak lightofdejitleak further reduces the overheadbut withcomparable effectiveness.
in future we plan to improve our approach by taking into account other jit optimizations and cpu level optimizations that alsointroduce timing side channels inpractice.
data availabilitystatement to foster further research benchmarks experimental data and the prototypingtoolare releasedat .