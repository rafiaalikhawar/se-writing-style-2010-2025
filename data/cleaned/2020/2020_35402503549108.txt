classifying edits tovariabilityin source code paul maximilianbittner paul.bittner uni ulm.de university ofulm ulm germanychristoftinnes christof.tinnes siemens.com siemens ag m nchen germanyalexander schulthei alexander.schultheiss hu berlin.de humboldtuniversity ofberlin berlin germany s ren viegener soeren.viegener uni ulm.de university ofulm ulm germanytimo kehrer timo.kehrer inf.unibe.ch university ofbern bern switzerlandthomasth m thomas.thuem uni ulm.de university ofulm ulm germany abstract forhighlyconfigurablesoftwaresystems suchasthelinuxkernel maintaining and evolving variability information along changes to source code poses a major challenge.
while source code itself maybeedited alsofeature to codemappingsmaybeintroduced removed or changed.
in practice such edits are often conducted ad hoc and without proper documentation.
to support the maintenance and evolution of variability it is desirable to understand the impactofeacheditonthevariability.weproposethefirstcomplete andunambiguousclassificationofeditstovariabilityinsourcecode by means of a catalog of edit classes.
this catalog is based on a schemethatcanbeusedtobuildclassificationsthatarecomplete andunambiguousbyconstruction.tothisend weintroduceacomplete and sound model for edits to variability.
in about .5msper commit wevalidatethecorrectnessandsuitabilityofourclassificationbyclassifyingeacheditin1.7millioncommitsinthechange historiesof44open sourcesoftwaresystemsautomatically.weare abletoclassifyalleditswithsyntacticallycorrect feature to code mappings andfindthat alloureditclasses occurin practice.
ccsconcepts software and its engineering software configuration managementandversioncontrol systems softwareevolution .
keywords softwareevolution softwarevariability featuretraceability software product lines miningversion histories acm reference format paul maximilian bittner christof tinnes alexander schulthei s ren viegener timo kehrer and thomas th m. .
classifying edits to variabilityinsourcecode.
in proceedingsofthe30thacmjointeuropeansoftware engineering conference and symposium on the foundations of software engineering esec fse november 14 18 singapore singapore.
acm newyork ny usa 13pages.
esec fse november 14 18 singapore singapore copyright heldby theowner author s .
acm isbn .
introduction in configurable software systems such as the linux kernel certain code should only be present in certain variantsof the software.
for instance parts of the code base may be platform dependent or a featureshouldonlybeavailabletoasubsetofcustomers.maintainingandevolvingvariabilityinformationalongchangestosource codeposesamajorchallengefordevelopers .oneaspect thereofiskeepingtrackofchangestovariablepartsofthecodebase that implement different featuresor feature interactions of the configurable software.
while source code itself may be edited featureto codemappings may alsobe introduced removed orchanged.
awarenessofeditstovariabilityiscrucialinthedevelopment of configurable software.
for instance edits to software product linesmightintroducetypeerrorsincertainvariants oralter thesetofavailablevariantsinanunintendedway .
inclone and owndevelopment whereeachvariantofasoftware is developed as a separate copy ofthe software e.g.
using branching or forking changes to variants have to be tracked to update other variants accordingly .
variation control systems and managed clone and own methods inspect edits paired with information on edited features to recover knowledge about variability incrementally or to reintegrateedits toahidden unifiedcode base .
in practice however the variability of the code base is often editedad hocandwithoutproperdocumentation.whilechanges aretechnicallycapturedintermsofcommitstoaversioncontrol system theirimpactonthevariabilityisnotexplicitlyaccountedfor and mostly opaque to developers and tools .
instead of dealing withpurelysyntacticalchangesonthegranularitylevelofcommits it is desirable to describe the difference between two versions of the code base as edits for which the effect on the variability is known.
for example one important class of edits to variability are refactorings whichchangethestructurebutnotthesemanticsof variabilityinformation.knowingsucheffectsisusefulasfurther maintenanceandevolutiontaskscanbesimplified such asadaptingthetestsuiteofasoftwareproductline orthe propagation of changes between cloned variants or forks .
although the literature has recognized the need for characterizing variability evolution a complete unambiguous and automated classificationofeditsdoesnotyetexist.studiesonsoftwareproduct lines focus on specific scenarios such as variability aware mutation testing or safe evolution or cover only edits tovariabilitymodels orconfigurationsofvariants .
thisworkislicensedunderacreativecommonsattribution sharealike4.
internationallicense.
esec fse november14 18 singapore singapore p. m. bittner c.tinnes a.schulthei s.viegener t. kehrer t. th m classifications of co evolution of variability models and source code make no claims on completeness i.e.
there may be edits that cannot be classified and require a manual identification of edits .similarly classificationsofeditsinmanagedcloneand owneitherrequireamanualeditinvestigation orsuffer from ambiguity andincompleteness .
tothisend wepresentacomplete unambiguous andautomatic classificationofeditstovariabilityinsourcecode.wefirstintroduce variation trees as a formalization for variability in source code.
we thenintroduce variationdiffs asaformalizationforeditstovariation trees thus describingedits to variability in source code.
we prove that variation diffs are complete and sound regarding variation trees meaningthatanypossibleedittoavariationtreeisdescribed byavariationdiffandthateveryvariationdiffrepresentsanactual edittovariationtrees.byclassifyingallstructureswithinvariation diffs weareabletoclassifyalleditstovariabilityinsourcecode.
we present a set of edit classes which we prove to be complete and unambiguousonvariationdiffs.insummary ourcontributionsare formalization we present variation trees and variation diffs as formalizationsforvariabilityinsourcecodeandeditstoit.we prove that variation diffsare sound andcomplete.
classification wepresentacatalogofclassesforeditstovariability in source code and prove its completeness and unambiguity.
automation we present diffdetective a tool to automatically classify edits in histories of software in which variability is implementedwiththe c preprocessor.
validation we validate that our concepts and classes are suitable to describe andclassifyeditsto variability insourcecode.
variabilityinsourcecode in this section we first give an intuitive answer to what variability insourcecodeis.second weproposeaformalizationforvariability insourcecode whichwe use toclassifyeditstovariability inthis work.
third we discuss the suitabilityofour formalization.
.
whatisvariabilityin sourcecode?
variabilityinsourcecodemeansthatcertaincodeshouldonlybe presentincertain variantsofthesoftware.yet specifyingvariability of source code by listing the respective set of variants for each source code fragment is usually infeasible for tools and developers because configurable software may induce millions of variants .instead distinguishingvariants in termsof featuresproved to be successful in software product line engineering andclonemanagement afeaturebeinginformally defined as a variable characteristic of the software.
each variant of asoftwaresystemisthenspecifiedbyafeatureselection usually referredtoas configuration statingwhichfeaturesthevariant implements.eachsourcecodefragmentinturn isassociatedtothe featuresitimplements.ascommonintheliterature we refer to this association as the presence condition ofthecode.sourcecodeisthusincludedinexactlythosevariants whose configurationssatisfy the code spresencecondition.
in practice conditional compilation is a widely adopted strategy toinducepresenceconditions.prominentexamplesarethelinux kernel busybox and vim that use the c preprocessor.
source code canbemappedtoanypropositionalformulaoverfeatureswiththe4202 ifdef feat gui if gui.in use gui mch set foreground else ifdef mswin win32 set foreground endif endif listing variabilityspecified withconditional compilation insrc evalfunc.c invim at commit ab4cece.
cpreprocessordirectives if ifdef and ifndef where ifdef and ifndef checkwhetheracertainmacronameisdefinedornot defined respectively.hence ifdefand ifndefcanbeusedto checkwhetherafeatureisselectedordeselected while ifcantest complexconditions.
listing1 showsanexcerptofgraphicaluser interfacecodefromvimwithpreprocessorannotations.ifvimis compiledwiththefeature feat gui selected lines4203and4204 areincludedinthecompiledvariant.ifthefeature feat gui isnot selectedandvimiscompiledforthewindowsoperatingsystem i.e.
mswinisselected line4207isincludedinstead.inthiscodesnippet lines and thus share the presence condition feat gui but line has the presence condition feat gui mswin.
yet listing is just an excerpt that is again surrounded by further preprocessorannotations notshownhere.consequently theactual presenceconditions are even more complex.
as illustrated in this example there is a difference between the presenceconditionofacodechunkanditsdirectannotation which werefertoasthecode s featuremapping .inparticular thepresence condition may be composed of one or more feature mappings arising from nesting.
as shown in listing line is only mapped tomswinwhile its presence condition is also determined by the selection of feat gui .
a presence condition thus is a conjunction offeature mappings.
in essence feature mappings and presence conditions are a means to describe variability in source code because they allow to defineanysubsetofvariantsastargetforeachimplementationartifact.byinspectingfeaturemappingsandeditstofeaturemappings we can thus observe editsto variability insourcecode.
.
formalizationas variationtrees to inspect possible edits to feature mappings we define feature mappingsandpresenceconditionsformally.wefirstdefinewhat can be mapped to features and how elements can be mapped to featuresandfeatureinteractions.wethenintroducevariationtrees as aformalizationto represent nestinghierarchies.
apartfromsourcecode variabilitymightalsoaffectotherimplementationartifacts e.g.
documentation buildfiles modelelements .
even the granularity of implementation artifacts mayvary indifferentcontexts.forinstance one might interpret sourcecodeaslinesoftextorasanabstractsyntaxtree version control systems such as git usually regard source code as linesoftextwhiledevelopersandcompilersareawareofthecode s structure.
for our tooling and empirical validation we focus on 197classifying edits to variabilityin source code esec fse november14 18 singapore singapore linesofsourcecodeandpreprocessor basedvariability.nevertheless wedesignourconceptstocoveramultitudeofimplementation artifacts andimplementationtechniques for feature mappings definition .
implementation artifact .
an implementation artifact is an identifiable unit of any granularity within a software project e.g.
tokens linesofcode modelelements orentire files .
mappinganartifacttothefeaturesitimplementscanbedonein several ways.forexample eachartifact can be mappedto exactly one feature a set of features or to exactly one propositional formula over the set of features .
in this work we map artifacts to propositional formulas also covering mappings to single features as formulas consisting of a single variable or sets offeatures asconjunctionsofvariables .anartifactmappedtoa formulafisthenincludedinexactlythosevariantsunderwhose configuration fevaluates to true.
as illustrated in the previous section .
an artifact s presence conditiondependsontheartifact slocationwithinanestinghierarchyoffeaturemappings whichexhibitsatreestructure.wethus introduce variation trees as a formal model for nesting hierarchies definition2.
variationtree .
avariationtree v e r l isa treewithnodes v edgese v v androotnode r v.eachedge x y econnectsa child node xwithits parentnode y denoted byp x y. the node type v artifact mapping else identifiesanode v veitherasrepresentinganimplementation artifact a feature mapping or an else branch.
the label l v is a propositional formula if v mapping a reference to an implementation artifact if v artifact or empty if v else.
the rootrhas type r mapping and label l r true.
anelse nodecanonlybeplaceddirectlybelowanon root mappingnode andamappingnode has at mostone childoftype else.
nodesinavariationtreeeitherrepresentimplementationartifactsorfeaturemappingsonallitschildren.theroot rissynthetic togroupallartifactsandmappings andmayrepresentanentirefile for example.
it sformula truedenotes that it ispart of all variants justas an annotation iftrue does.
as an example figure 1shows the variation tree induced by the annotations in listing .
each node is labeled with its line numberfrom listing1 aswellasitscodeorformula respectively.
annotationsaredrawnwithablueborder whilenodesreferencing linesofcodearedrawnwithablackborder.consecutivelinesof code within the same annotation are grouped as a single node and labeled with the first line s number in particular lines and are grouped.
note that endifdirectives are part of their corresponding mapping nodes by determining which nodes are children andwhichnodes are siblings ofthe respective mapping.
to model preprocessor based variability more accurately and because of our running example we treat elsestatements as firstclasscitizensinvariationtrees.notallkindsofannotationsdohave anelseconstructthough inwhichcase elsenodescan simplybeomitted.inourappendix 1weshowthatwecaninfact parameterize a variationtree in theset of its node types such that variation trees can support further language constructs for specifyingvariability suchassyntacticsugarlike elif.infact weconsider if feat gui if gui.in use else4206 if mswin4207 win32 set foreground figure variationtree of listing .
elifdirectivesexplicitlyinourvalidationin section5.yet such extensionsarecosmeticanddonotimpactthevalidityofourresults aselseandelifnodes can also be expressed as mappingnodes e.g.
lines and in listing actually describe an elif .
thesetofnodetypesmustatleastcontain artifact andmapping andmightbe extendedbyfurther types to increasegranularity.
variationtreesfacilitatenestingnodesbelow artifact nodes.
while such nesting never occurs for annotating lines of code as lines cannot be nested in lines other artifacts such as abstract syntaxtrees ormodels mayexhibitnesting.forexample when annotatingacstructandit sfieldsinanabstractsyntaxtree the fields mappingnodeswouldbeplacedbelowthe artifact nodeof thestruct.yet inourexamplesandourvalidation artifact nodes are line based sonodes willnever occur below artifact nodes.
variationtreesdirectlyreflectthenestinghierarchyemployed by developers and thus also reflect any individual feature mapping e.g.
ifannotations that is assigned to a group of artifacts.
from avariationtree wecancomputethefeaturemappingofanartifact given its corresponding node n f n f p n n artifact l n n mapping f p n n else.
first the feature mapping of an artifact node is given by the annotationaboveit.second a mappingnoderepresentsafeature mappingandhasitsformulastoredinitslabelthatisobtainedby l. finally for elsebranches we have to negate the feature mapping ofthe corresponding mapping.
basedonvariationtrees wecanalsodefinepresenceconditions.
asforfeaturemappings thepresenceconditionofanimplementationartifactcanbecomputedfromitscorrespondingnode nin thevariationtree.computingthepresenceconditionofanodeis similartocomputingitsfeaturemapping exceptthatwehaveto inspecteveryancestorabovethenode insteadofjustthenearest mapping node.
given a variation tree with root r we define the presencecondition ofanode nrecursivelyas pc n pc p n n artifact f n pc p n n mapping n r f n pc p p n n else f n n r. first as the feature mapping of an artifact nodenis given by itsparent alsoitspresenceconditionisdeterminedbyitsparent p n .
second the presence condition of a mappingnode is given by its own formula in conjunction with the presence condition of its parent because any feature mapping may itself be nested 198esec fse november14 18 singapore singapore p. m. bittner c.tinnes a.schulthei s.viegener t. kehrer t. th m withinfurther mappings.
third alsothepresence conditionof an elsenodeisgivenbyitsownfeaturemappinginconjunctionwith the presence condition of any outer nodes.
however to access the outernodesofan else wehavetoretrievetheparent p p n of itscorresponding mappingnodep n .fourth the root spresence condition is solely determined by its own formula f r l r truebecause the root is not nested.
note that trueacts neutral on conjunctions and thus the synthetic root has no effect on computing presenceconditions.
.
discussion ofcompletenessandsoundness the key property of variation trees isto distinguish presenceconditionsfromfeaturemappings.variationtreesdirectlyreflectthe nestinghierarchyemployedbydevelopersandthusalsoreflectany individualfeaturemappingthatis assignedtoagroupofartifacts.
inthissection wediscuss ourdesigndecisionsfor definingvariationtreesandwhyweconsidervariationtreestobeanadequate modelfor variability insourcecode.
completeness .
we first discuss design decisions regarding the completenessofvariationtrees.thatis theirsuitabilityforexpressing feature mappings and presence conditions independent of the underlying implementationstrategyfor variability.
variationtreesaredirectlyinspiredbyannotativeapproaches in particular preprocessor directives.
yet ingeneral feature mappings are specified either by annotating source code as shown in our example orby composition ofmodules .in annotation based strategies sourcecodeisannotatedwiththefeaturesitimplements for example with comments external metadata or conditional compilation as shown in listing .
these strategies annotatesourcecodewithfeaturesorfeatureformulasandbecause ourformalizationdoesnotmentionanyconcretemacros weargue thatmappingnodesaregeneralenoughtocoveranykindofconditionalannotation.moreover whenentire filesor directoriesare annotated e.g.
withbuildsystems alsothedirectorystructure withitsannotationcanbedescribedwithcorresponding artifact andmappingnodesabovetheactualfilecontents.compositional strategies group artifacts in modules e.g.
plugins or packages and inturnmapmodulesto features.compositionalstrategiesusually do not exhibitnestinghierarchies so presenceconditionsare usuallyequaltofeaturemappings.nevertheless wearguethatvariation trees are general enough to also reflect compositional feature mappings in particular by representing a module massigned to featurefby a node vwith type v mapping and label l v f andgroupingtheimplementationartifactsof mincorresponding childnodes.inconclusion whileimplementationstrategiesforvariabilitydiffervastlyintheirtechnicalrealization allofthemyield thesameconceptualresult aspecificationoffeaturemappingsand presence conditions to determine which code fragments should be present inwhichvariants the key purpose ofvariation trees.
with variation trees we map artifacts to propositional formulas.
in practice though artifacts might also be mapped to formulas including non boolean expressions e.g.
arithmetics such as ifx .
indeed our concepts also support more sophisticated theories than propositional logic e.g.
higher orderlogic because we only require the propositional operators conjunction and1 ifdef feat gui 2if gui.in use 4gui mch set foreground else ifdef mswin return endif if defined mswin !defined feat gui defined vimdll win32 set foreground endif endif listing edits made to listing in commit afde13b in vim.
negation aswellastheatom truewiththeirusualsemanticsand do not impose any otherrestrictionsonthe logic.
to the best of our knowledge we thus believe that variation trees are general enough to cover all strategies known to us for specifying feature mappings andpresenceconditions.
soundness .
we now discuss design decisions regarding the soundnessofvariationtrees meaningthatvariationtreesindeed describe feature mappings andpresenceconditions.
ourdefinition2.
ofvariationtrees ensures thatfeature mappingsandpresenceconditionsarealwaysdefined.eachnodehas exactly one parent except for the root because variation trees are trees.hence theparent pisalwaysdeterminedintherespective casesoffandpc.bydefinition every elsehasacorresponding non root mapping nodeasitsparent hence thefeaturemapping fofanelseisindeedthenegationofitscorresponding mapping node and also the grandparent p p n exists for each else node which is accessed for computing the presence condition.
further trees and thus variation trees contain no cycles meaning that anyrecursivecomputationof feature mapping forpresenceconditionspceventuallyendsattherootandthusterminates.therefore bothfeaturemapping fandpresencecondition pccanalwaysbe computed meaning that variation trees are always a description of variability inimplementationartifacts andthus sound.
conclusion .
having laid the formal foundations for variability in source code we inspect how the variability may be edited in the remainderof this paper.what kinds ofedits couldbe made to listing1?howwouldsucheditsaffectthecorrespondingvariation tree shownin figure ?
edits to variabilityinsourcecode whilesourcecodeitselfmaybeedited alsothesetofvariantsof one or more code fragments may be altered .
this means edits may introduce remove or change the feature mapping or presence condition of code fragments.
for example it might be necessarytoaddnewcodetoafeaturetoextendit ortoremove parts of a feature mapping s formula when the formula was wrong.
2variationtreesmaystilldescribeillegalvariantswithrespecttotheannotatedlanguage.
for example annotated code in listing could be syntactically incorrect yieldinginvalidcprogramsforsomeconfigurations.whilecorrectnessmaybeobtainedby making annotations aware of the annotated language e.g.
regarding syntax ortype correctness the variability specified by variation treesis sound.
199classifying edits to variabilityin source code esec fse november14 18 singapore singapore r1 if feat gui5 else66 if mswin1111 win32 set foreground if mswin feat gui vimdll if gui.in use gui mch set foreground return figure variationdiff ofedits madein listing .
listing2 showschangesthatweremadetovim scodein listing 1in commit afde13b.
the edit is displayed in the universal diffformat knownfromversioncontrolsystems addedlinesare markedgreenandprecededby removedlinesaremarkedorange andprecededby .in thisedit sourcecode wasinserted lines3 and annotationsgotdeleted lines and and replaced lines and .
while the existing line remains untouched its annotation was replaced.
in particular line had the presence condition feat gui mswinbefore the edit but is assigned mswin feat gui vimdll afterwards.
the set of variants including line thus grows as feat gui does not necessarily have tobedeselectedforline11tobeincludedinavariantanymore.
in this section we propose a formalism for representing such edits to variability which we use in section to classify edits to variability.
.
formalizationas variationdiffs toclassifychangestovariabilityinsourcecode wemayinspect changestosourcecodeanditsfeaturemappings asexplainedin section .
to inspect changes we need a model that captures whichelements were edited howelements were edited and how the variability of each element changed.
while universal diffs asshownin listing2 arewidelyadoptedforexpressing whichand howelements got edited they do not reflect changesto variability well.
in particular to classify edits to variability developers and toolshavetoknowhowfeaturemappingsaswellasentirepresence conditions changed.
basedonourvariationtrees wethuspropose variationdiffs asa modeltodescribeeditstofeaturemappings.analogoustouniversal diffs which describe which lines of text were inserted or removed variationdiffsdescribewhichnodesgotaddedtoorremovedfroma variationtree.thus avariationdiffdescribesexactlytwovariation treesatonce onebeingvalidbeforetheeditandonebeingvalid aftertheedit.thekeyideaofvariationdiffsistomodeleditstothe hierarchy of feature mappings agnostic of the actual underlying implementationartifacts.
as an example figure shows the variation diff of the edit fromlisting2.thevariationdiffrepresentstheeditsmadetothe variationtreeshownin figure1correspondingtotheeditedsource codefrom listing1.analogousasforvariationtrees wecollapse continuouslinesofsourcecodewiththesametypeofchangeintoa singleartifact node e.g.
lines7and8 .greennodesareinserted into the variation tree orange nodes with a dashed border are removed and gray nodes remain unchanged.
orange edges are present before the edit and green edges exist after the edit.
forexample line on the right in figure is nested below the annotations at lines and before the edit but is placed within the newannotation at line10 after the edit.
as variation diffsdescribe edits to variationtrees we formalize variation diffs as an extension i.e.
a generalization of variation trees to graphs inwhichnodes andedges mayalsobe edited definition .
variation diffs .
a variation diff is a rooted directed connected acyclic graph d v e r l with nodes v edgese v v root node r v node types node labels l and a function v e that defines if a node or edge was added removed or unchanged such that project d t is a variation tree for alltimes t b a .
we refer to the variation trees before and after the edit induced by a variation diff as the projections of the variation diff.
to reason aboutprojections we usethe time values b before and a after .
wemayobtaintheprojectionofavariationdiff v e r l at timet b a byincludingonlythosenodesandedgesthatexist at timet project v e r l t v v exists t v e e exists t e r l .
a node or edge exists before b the edit if it was not added and existsafter a theeditifitwasnotremoved.formally anodeor edgex v ewithdiff type d x exists at time t b a if exists t d t b d t a d .
we can obtain the feature mapping and presence condition of a node in avariation diffbefore or after the editfrom the respective projection.foravariationdiff d werefertothefeaturemapping f n of a node nin the projection project d t at timet b a asft n .
analogously we abbreviate the presence condition of the nodeninthe respective projection as pct n .
anexampleforaprojectioncanbefoundin figure1whichis theprojectionofthevariationdifffrom figure2beforetheedit i.e.
figure project figure b .thevariationtreecontainsexactly theunchanged andremoved nodesandedgesfromthediff.
inserted nodes andedges are only present after the edit.
.
completenessandsoundness we prove that variation diffs are complete and sound with respect to possible editsto variation trees.
completeness.
weprovethatvariationdiffsare complete meaningthattheycandescribeanyedittoanyvariationtree.everyedit toavariationtreetransformsitfromanoldstatetoanewstate.by considering the old state to be removed entirely and the new state to be inserted any edit can be expressed solely using insertions and deletions.
variation diffs allow to mark any subset of nodes andedgestobeaddedorremovedvia .naively wecandifftwo variation trees by defining o for all nodes and edges oof the old variation tree and n for all nodes and edges nof the new variation tree.
therefore variation diffs are complete with respecttovariationtrees.formally wealsohavetoprovethatwhen buildingavariationdiffthisway theprojectionsofthevariation diff yield exactly the original two variation trees.
this proof is part ofour appendix inour replication package.
200esec fse november14 18 singapore singapore p. m. bittner c.tinnes a.schulthei s.viegener t. kehrer t. th m soundness.
variation diffs are soundby construction meaning thatanyvariationdiffdescribesanactualedittoavariationtree.by definition wecanobtainbothprojectionsfromavariationdiffto ensure that the diff holds enough information to actually represent alldifferencesbetweentwovariationtrees.thus anyvariationdiff describes an editto avariation tree.
conclusion.
we proposed variation diffs as a complete and sound model for edits to variability of implementation artifacts.
whilevariationtreesmodelnestinghierarchiesemployedbydevelopersortoolstostructurefeaturemappings variationdiffsidentify changes to individual feature mappings within the nesting hierarchies.
to this end variation diffs do not only cover changes to source code but also to feature mappings.
in thefollowing we use variation diffsto classifyedits.
classifyingedits to variability our main goal is to classify every edit to variability in source code.
withvariationdiffsasacompletemodel classifyingeditstovariabilityreducestoinspectingpossiblestructuresinvariationdiffs.
the key observation is that we can classify the edit made to the variability of an artifact by inspecting its diff type and the location of its corresponding node in the variation diff.
hence edits made to an artifact can be described locally.
to classify edits we proposenineeditclassesthatinspectthevariationdifflocally from theperspectiveofan artifact node.weprovethatourclassesare complete i.e.
every node is in at least one class and unambiguous i.e.
every node isinat mostone class .
avariationdiffmaydescribechangestomanyartifactssimultaneously suchasin figure2.acompositionofinstancesofedit classesinturn mayemergeintoamoremeaningfulchange that we refer to as composite edit.
we show that our class definitions areindeedbasicbuildingblockstodescribemorecomplexchanges.
key to our classification is its customizability.
while we propose a catalog of classes based on use cases from variation controlsystems managed clone and own and variability aware mutationtesting otherclassificationsmightsuitotherusecases.
we show that our classification scheme easily allows to define alternative classifications that remain complete and unambiguous.
.
catalogofeditclasses our definition of edit classes is inspired by the edit patterns by st nciulescu et al .
that are designed to reflect relevant edits for variation control systems .
their patterns are regular expressions over c preprocessor annotated code which we found to be incomplete i.e.
some edits cannot be classified and ambiguous i.e.
someeditsmatchmore thanone pattern .
wedescribeeachclassasapropositionalpredicateon artifact nodes within a variation diff.
the formalization as propositional predicates has the benefits that it is easily reproducible e.g.
no sophisticatedgraph matchingisrequired satisfiabilitysolvers areveryeffectivereasoningenginesandpartofmanyanalysistools already and completeness and unambiguitycan be ensured by construction.notethattheclassesonlyclassify artifact nodesas theserepresentactualimplementationartifactsofwhichwewant to observe howtheirvariability has changed.we distinguish edit classes for added removed andunchanged artifacts.whileanartifactitselfmightbeunchanged itsvariability might have changed described by its ancestors in the corresponding variation diff.
for further use we define three predicatesadded v v removed v v and unchanged v v that each evaluate to trueif a given nodevhas the corresponding diff type.
we present the formal definition of each edit class as well as an example edit to preprocessor based source code and a sketch of itscorrespondingvariationdiffin table1.theshowntext based diff and variation diff serve as examples and are not part of a class definition.in the following we discuss eachclass.
addwithmapping and addtopc.
our first two classes cover theinsertionofsourcecode.dependingonwhetherthecodewas insertedwithorwithoutanewfeaturemapping weidentifythe edit as an instance of the addwithmapping oraddtopc class respectively.
distinguishing insertion with orwithout a new feature mappingisrelevantforvariationcontrolsystemsinwhichanewly introducedfeaturemappingisusedtointegratetheeditedsource code into an internal representation of the code base .addwithmapping classifiesan artifact nodecthatwasinsertedtogether with a new mapping nodema c where the function mt c returns the node that defines the feature mapping of an artifact nodecat timet i.e.
mt c mt pt c iff c artifact and otherwise mt c c .wehavetouse mtbecauseartifact nodes may benestedbelow artifact nodesandthusjustinspecting parent nodes is insufficient.
in conditional compilation addwithmappingcorresponds to inserting code with preprocessor annotations.
foraddtopc inserted code is not associated with a new feature mapping but isplacedbelowan already existing mapping ma c .
remwithmapping and remfrompc.
our classes for deletionsofsourcecodearedualtoourclassesforaddition forremoved code we also distinguish whether thecode s feature mapping was removed or not.
dual to addwithmapping the class remwithmappingcontainsremoved artifact nodescwhosefeaturemapping mb c wasalsoremoved.dualto addtopc theclass remfrompc containsplaindeletionsofsourcecodewithoutmodificationtoa node sfeature mapping.
generalizationandspecialization.
forunchangedcode we investigate if and how its variability changed.
in particular unchanged code has a presence condition pcbbefore the edit and apresencecondition pcaaftertheedit.dependingonhowthese presence conditions relate the set of variants of the source code might have changed in different ways.
for example node 11in figure 2is unchanged but its presence condition changed from feat gui mswintomswin feat gui vimdll .thus the set ofvariants of node 11grew because feat gui does not necessarilyhavetobedeselectedanymore.werefertosuchanedit as ageneralization .formally thesetofvariantsofthenode cgrows iff its set of variants before the edit is a subset of the variants after theeditandnotviceversa.thesetofvariantsof cbeforetheedit is a subset of the variants after the edit if and only if pcb c pca c is a tautology which we write as pcb c pca c .
we can check whether this formula is a tautology with a sat solver via sat pcb c pca c .the intuitionbehind requiring a tautology is that cshould remain in allvariants it was previously included in.
when instead the set of variants of an unchanged 201classifying edits to variabilityin source code esec fse november14 18 singapore singapore table editclassification.
editclassdefinition example diff example var.
diff editclassdefinition example diff example var.
diff editclassdefinition example diff example var.
diff addwithmapping c added c added ma c ifm c endif ifm caddtopc c added c added ma c ifm c endif ifm cspecialization c unchanged c pcb c pca c pca c pcb c ifm c endifr c ifm remwithmapping c removed c removed mb c ifm c endififm ifm cremfrompc c removed c removed mb c ifm c endif ifm cgeneralization c unchanged c pcb c pca c pca c pcb c ifm c endifr c ifm reconfiguration c unchanged c pcb c pca c pca c pcb c ifm ifm c endifr c ifm ifmrefactoring c unchanged c pcb c pca c pca c pcb c pathb c patha c if a b !a if a b c endifr c ifm ifmuntouched c unchanged c pcb c pca c pca c pcb c pathb c patha c r c artifact nodecshrinks we refer to the change as a specialization.aspecialization occurs whenthepresenceconditionbecomes more restrictive.
a simple example in conditional compilation is the insertion of a non superfluous3directive whose condition m hastobesatisfiedforthecode ctobeincluded.inthevariationdiff thisexamplecorrespondstotheinsertionofanew mappingnode somewhere above the artifact nodec.
reconfiguration.
incasethesetofvariantsisinnosubsetrelation wespeakofa reconfiguration asthesetofvariantschangedin anarbitraryway.thishappensforexample whenanon superfluous conditionisreplacedbyadifferentnon superfluouscondition or when different directives are added or removed simultaneously such thatthesetof variantsafter theeditisneitherasubsetnor a superset ofthe previous setofvariants.
refactoring.
besides thesetofvariantsmightnothavechanged atall.inthis case thepresence conditionsmighthavebeenrefactored e.g.
an annotation a b a was simplified to a b or notchangedatall.incasethepresenceconditionwasrefactored it remained semantically equivalent but its ancestors in the variation diffhavechanged.iftheancestorschanged thepaths pathb c and patha c from a node cto the root before and after the edit are different where patht c describes the path from the node cto the root of the variation diff at time t b a i.e.
patht c ciffcis the root and patht c c patht pt c otherwise .
untouched.
the variability of a piece of source code might neither be changed semantically nor syntactically.
this means the presenceconditionremainedequivalentregarding andthepaths before and after the edit from a node to the root did not change e.g.
line1in listing2 isuntouched .whilenoeditoccurredfor anartifact inthis case we include untouched to be complete.
.
completenessandunambiguity our edit classes are complete i.e.
every artifact node is in at least one class and unambiguous i.e.
every artifact node is in at most one class .
our classes are unambiguous as they are 3a superfluous condition does not influence the variability such as if true .mutually exclusive and they are complete as at least one predicate evaluates to truefor eachpossibleevaluation i.e.
thedisjunction of the predicates is a tautology .
we prove the completeness and unambiguityofour classesinour appendix.
giventhatourclassesarecompleteonvariationdiffsandthat variationdiffsarecompletewithrespecttopossibleeditstovariation trees cf.
section .
we conclude that our classes are a completeclassification of edits to variationtrees.
in section .
we discussed our design decision for variation trees to be as complete as possible in representing variability in particular of source code.
thus assuming that variation trees are complete our classes are a completeclassificationofeditstovariabilityinsourcecode.further whenevera class occurs inavariation diff that occurrenceindeed classifies an edit to variability because variation diffs and variation trees are sound.
.
definingotherclassifications a key benefit of classifying edits via predicates over artifact nodes in variation diffs is that we can build other classifications while proving completeness and unambiguity requires only minor adaptions to existing proofs.
we constructed our catalog of classes basedonusecasesinsomevariationalsystems butother classifications maybe requiredto serve otheruse cases.
in particular classifying edits based on predicates gives rise to infinitelymanypossibleclassifications eachbasedonanotherset of predicates.
we can always split a class defined by a predicate c intotwonewclasses 1 c c c and 2 c c c byaddinganewclause thatdistinguishesafurthercase.
such a predicate always exists because there are infinitely many variation diffs and each predicate may inspect another property of the diff.
as an example we could split the refactoring class to also inspectwhetherthetwopresenceconditionsaresyntacticallyequal to see whether only the presence condition s distribution across feature mappings waschangedorif the formula wasaltered.
in our appendix we first describe a proof scheme for proving the completeness or unambiguity of any given classification that is 202esec fse november14 18 singapore singapore p. m. bittner c.tinnes a.schulthei s.viegener t. kehrer t. th m basedonasetofpredicates.wethenapplytheseschemestoour catalog of edit classes to prove it to be complete and unambiguous.
thus for anewclassification the schemescanbe reusedtoprove the respective properties while the proofsfor our catalog serve as examplesonhowto apply the schemes.
.
discussion whileourclassesareunambiguousfor artifact nodesinvariation diffs diffsingeneralareambiguousastheycanbeconstructedin multipleways.forexample itmighthavebeenmoreintuitiveto showtheremovedlines5and6aftertheinsertionoflines9and10 to group related changes in listing .
we identified two sources of ambiguity propositional formulas andthe specification ofdiffs.
ambiguityin feature mappings.
aconjunction a boftwo featuremappingscanbestoredinasingle mapping nodewithlabel a bor in two nested nodes labeled with aandb respectively.
this ambiguityis subject tothe developer schoice.
forexample in conditionalcompilationdevelopers are free to annotate a piece of code with if defined a defined b or with two nested annotations ifdef a and ifdef b .yet thisambiguityisnota limitationbutakeyquality ofvariation diffs.
in fact we designed variation diffs to reflect hierarchies of annotations to retain the ontologicalinformationgivenbydeveloperstobetterunderstand howvariability isdescribedinpractice.
ambiguityindiffing.
while variationdiffs are complete and sound regarding variation trees they remain ambiguous.
for example as discussed in section .
one could describe an edit to a variation tree as a variation diff in which all nodes and edges of the old tree are removed and all new nodes and edges are inserted.
such a description of an edit is rarely useful though and so nodesand edges beingpresentbeforeand aftertheeditshould be consideredunchanged.however detectingwhetheranodeisunchangedisnotunambiguouslydetermined e.g.
whenlinesofcode aremoved .infact ambiguityinexpressingeditstoimplementation artifacts is a limitation of any differencing technique in general sometimes requiring advanced matching heuristics .
we thussharethislimitationwithexistingresearchondifferencingand edit classification.
yet we can control this ambiguity by employing a deterministic diffing technique that yields the same variation diff for the same two input revisions of a source code file.
we have implemented a deterministic parser for constructing variation diffs from aunixdiff for our validation in section .
.
composite edits althoughourclassificationiscomplete variabilityinsourcecode mightwitnessmorecomplexchanges.forinstance st nciulescu et al.
observed that when adding code with a feature mapping developers sometimes simultaneously add code to variants not including the feature with an elsebranch called addifdefelse .
while such an edit is classified by our catalog as a simultaneous application of two addwithmapping edits this classification loses theirconnectioninthegraphstructure.inparticular earlierstudies observe or investigate different kinds of complex patternsto increase the accuracy when evaluating research .
however existing studies face overlaps i.e.
an edit might be matched by more thanone pattern leadingto ambiguity.variation diffs enable us to systematically derive complex patterns by interpreting them as a composition of class definitions.
wethusrefertosuchcomplexpatternsas composite editpatterns.
whilecompositepatternsmightoverlap theoverlapisexplicitly accountedfor bytheircomposition of classesthat do not overlap.
as our classes are complete unambiguous and fine grained we argue that they indeed serve as a set of building blocks for complexpatterns.inour appendix weshowthatall editpatterns reported in previous studies are either a composite edit patternorequivalenttooneofourclasses.1acatalogofcomposite editpatterns can be useful but isoutof scope of this paper.
validation in thissection we validatethat ourtheoreticalresults can betransferred to practice.
therefore we classify the edits made in the development histories of real world software product lines.
our theory is based on the assumptions that variation trees are complete andsound cf.
section .
and feature mappings are syntactically correct.
to determine whether these assumptions are valid in practice we validate the completeness of variation diffs byverifyingthateverypatchwithsyntacticallycorrectmappings can be parsed to a variation diff and by inspecting how often mappings are syntactically correct rg1 .
we validate the proofs for completenessandunambiguityofourclassification byverifying thateacheditedlineofsourcecodeisinexactlyoneeditclass rg2 .
moreover weinspecttherelevanceofeachclassbyobservingits occurrenceinpractice rg3 .finally wevalidatethatourclassification can be automated andscales such that variation diffs could be parsed and our classes could be detected by future variability managementtools rg4 .
in summary our research goalsare rg1validatethecompletenessofvariationdiffsasarepresentationfor editsto variability insourcecode.
rg2validate that our edit classes are complete and unambiguous.
rg3validatethatoureditclassesarerelevant i.e.
allclassesoccur inpractice .
rg4validatethat editclassification canbeautomated andscales.
.
subject systems for our validation we analyze open source software product lines from different domains.
we include all software product lines whose variability was analyzed by liebig et al .
regardingtheircomplexity granularityandtypesofextensionsapplied by preprocessor directives.
fortunately all systems are still publicly available and we provide updated links in our replication package.
while these systems already cover a wide spectrum of domains including but not limited to webservers operating systems database systems antivirus media players and editors we decided to also include four other systems to further increaseexternalvalidity busybox acollectionoftoolsforembedded systems that is widely studied in research on configurable software marlin a 3d printer firmware from which edit patterns were retrieved semi automatically by st nciulescu et al .
cf.section libssh an ssh library also studiedinthecontextofconfigurablesystems andthegame engine godot as a new domain.
in table we present an overview of the four subject systems with the longest revision history as 203classifying edits to variabilityin source code esec fse november14 18 singapore singapore table overview andresults ofthefour largest andfour new subjectsystemsofthe 44analyzed systems.
name domain total commits processedcommits diffs artifactnodesaddtopc addwithmapping remfrompc remwithmapping specialization generalization reconfiguration refactoring runtimeavg.
run timeperprocessedcommitmedian runtimeperprocessedcommit linux operating system .
.
.
.
.
.
.
.
.9s .2ms 6ms freebsd operating system .
.
.
.
.
.
.
.
.2s .6ms 5ms gcc compiler framework .
.
.
.
.
.
.
.
.5s .4ms 21ms emacs text editor .
.
.
.
.
.
.
.
.1s .0ms 14ms ...36other systems... godot gameengine .
.
.
.
.
.
.
.
.2s .8ms 7ms marlin 3dprinting .
.
.
.
.
.
.
.
.0s .4ms 10ms busybox embeddedsystems .
.
.
.
.
.
.
.
.8s .8ms 6ms libssh network .
.
.
.
.
.
.
.
.3s .8ms 3ms total .
.
.
.
.
.
.
.
.1s .5ms 7ms well as the four new subject systems we omit the remaining systems for brevity .
the full results for all systems are part of our appendix.1notably weanalyzetheentirerevisionhistoryofthe linux kernel which to the best of our knowledge has the largest history in the domain of configurable systems with more than one millioncommits.allsubjectsystemsaremanagedwiththeversion controlsystemgit.
.
experiment setup topursueourresearchgoals webuilt diffdetective 4alibrary and command line tool to retrieve variation diffs from git histories ofpreprocessor basedproductlines.eachcommitinagitrepository consists of a set of patches where each patch comprises all edits made to exactly one file as shown in listing .diffdetective extractsallpatchesthatarevalidforourvalidation.apatchisvalid if it modified a source code file .c .cpp .h or.hpp with at least one non whitespace change and stems from a non merge commit because merge commits do not have a single parent.
each valid patchisthen parsedtoavariationdiff.
we thereforeconvertlocal patchestofullpatches i.e.
weusetheentirefileascontextandnot justthechangedfractionasshownin listing2 toaccountforannotationsthatsurroundedits.topursuerg1 diffdetective reports thecausewheneverapatchcannotbeparsed.inthe processed commits column of table we show how many commits contain atleastonevalidpatchthatcouldbeparsed about1.7millionin total.ineachparsedvariationdiff wethenremoveallnon edited subtreesasthesesubtreesdonotrepresentedits.
diffdetective then determines the edit class of each artifact node of each variationdifftovalidatethateverynodeisinexactlyoneclass rg2 and counts their occurrences rg3 .
for rg4 we measure the time ittakes to processeachcommit andrepository.
diffdetective uses the featureide library to reason on propositional formulas paired with the sat4j sat solver to classify edits.
we implemented the tseytin transformation for larger sat queries.
to interact with git we use the jgit library.
diffdetective s parser forpatches tovariation diffsisexplained inabachelor sthesis .
we perform our validation on an ubuntu .
.
lts system with64 bitarchitectureandanintel xeon cpue5 260v3with .40ghzclockrate.thesystemhas32threadsthatweusetoprocess 4github of each history in parallel but a single commit is always processedinasinglethread.toreducetheimpactofotherprocesses the machine wasnot inuse for othertasksinparallel.
.
results anddiscussion wesummarizeourresultsin table2.intotal weprocessedabout .
millioncommits containing about4.
million variation diffs in about10.4hwith a speed of .5msper commit on average and 7msas median.
because of multithreading we had an effective runtimeofabout 70minyieldinganeffectiveaverageruntimeof about2.4msper commit.
we classified about million edits to source code i.e.
artifact nodes in variation diffs .
for each edit class we listits relative share of the artifact nodes.
rg1 variation diff validity.
whenever diffdetective cannot parse a patch to a variation diff it reports an error and its reason.
we found the only reported errors to be syntax errors in preprocessor annotations.
in particular we found patches in which an endifwas missing patches with conditional directives without an expression patches with an endif without an if patches with an elseor elifwithout a corresponding if patches with an elsefollowing another else and7patcheswithsyntax errorsinthe definitionof multiline macros.
in total .
of all patches were syntactically invalid.
uponamanualinvestigationofsomeofthesefailures wefound thatthepreprocessordirectiveswereindeedinvalidandwereoften fixed in the following commit.
thus we find that we canparse all syntax correctpatchesto variation diffs.
rg2 validityofeditclasses.
diffdetective determinesthe edit class for each line of code in the parsed variation diffs.
in case anartifact node is an instance of no or more than one class diffdetective crashes by design and reports that node.
yet no crash occurred for any of the input repositories thus validating our proofs for completeness and unambiguity in section .
and the correctness ofour implementation.
rg3 relevance of edit classes.
we report the occurrence counts for each class in table .
we omit untouched as it never occurred.
this is expected because we removed non edited subtrees from all variation diffs and desired because we aim to inspect edits to variability and untouched describes an artifact that experiencesnochanges.
addtopc andremfrompc arebyfarthe most frequent edit classes with .
and .
of edits respectively.
here it is important that we collapse subsequent lines of 204esec fse november14 18 singapore singapore p. m. bittner c.tinnes a.schulthei s.viegener t. kehrer t. th m sourcecodewith thesamedifftypeto asingle artifact node cf.
section3.
toconsiderthelineeditsasasingleedit ratherthan oneeditperline.inlinewithpreviousresearch wethus find that edits to source code are much more frequent than edits toannotations.theremainingeditclassesmakeupforonly5.
of the edits which are still .
million edits.
insertion and deletion ofcodewithafeaturemapping addwithmapping andremwithmapping are morefrequentthaneditstothefeature mappingsof existing source code.
edits to the variability of existing code are about equally distributed with refactoring being the least common.
whilearefactoring istherarestedititstill occurs 91k times.
we conclude that alleditclassesare relevantinpractice.
rg4 automation and scalability.
diffdetective runs fully automaticallyandtookabout .4htoprocessallcommitsbutonly 70minin total because of multithreading.
classifying all edits in a commitrequires .5msonaverageand 7msasmedian.wefind that99.
ofcommitswereprocessedinlessthanasecond.all remainingcommits apartfromthreeoutliers wereprocessedinless than one minute.
the three outliers stem from godot and required and27min respectively.
the longest to process commit was 8c1731b.
we found a single of its patches to be responsible thegeneratedfile tools editor doc data compressed.h with about 100k lines of code experienced changes according to github.thesamefilewaseditedintheothertwocommits.such filescouldbeexcludedfromanalysesandwesupposealongprocess time for huge changes to be reasonable.
we thus conclude that classifying editscan be automatedandscaleswell.
.
threatsto validity ourtooldiffdetective couldhavebugsthatimpactourresults.
wetestedallcrucialfunctionalitywithunittestsandstructuredour development alongissuesandmergerequests.tovalidatethecorrectness of our variation diff parser we performed manual testing and implemented a consistency check that is performed on each parseddiff.
this checkreportednoinconsistencies.
our approach to measure relevance by counting class occurrencescouldbeinsufficient.yet wefindthateachsystemwithat least108processedcommitscontainsallofourclasses.onlyinfive systemssomeclassesareabsent threeofwhichhadsmallhistories total125commits withoutany valid patches.
we parseconditions to booleanlogicalthoughalso non boolean formulas occur cf.
section .
which would require more sophisticatedreasoningenginesthansatsolvers e.g.
smtsolvers which mayimpactourperformanceresults.uponparsing wereplacenonbooleansub expressionsbyuniquevariables atechniqueknown asbooleanabstraction employed insmtsolving andstate ofthe artwhen analyzing variability at alarge scale .
ourparserdoesnotexpandmacroinvocationsandincludedirectiveswhichmightimpairthesoundnessofourresults.yet sophisticatedvariability awareparsingmaytakeseveralminutesand uptomultiplehoursforasingleversion andrequiresto tree differencetwoparsedversions whichalsoisnotyetvariabilityaware cf.
section .
as in existing research we thus abstract macro invocationsas constantvalues e.g.
wetreat foo as a constant foo 3 4 .
we found parsing unix diffs to variation diffs to be the besttrade offbetween scalability andaccuracy.oursubjectsystemsmaynotberepresentativefortheevolution of variability in source code.
in particular all subjects are opensourcec c repositories.toaddressthisthreat wechosesystems thatwere previouslystudied and extendedthemby fournew systems to cover a wide spectrum of about different domains.
moreover ourvalidationfocusedonpreprocessor basedvariability bydesignwhichisinherently mostly usedinc c software.
related work ourworkisinspiredbytheworkofst nciulescuetal .
who empirically and semi automatically extracted a set of edit patterns from the history of two software product lines to evaluate their model of a variation control system.
when inspecting the patterns wefoundthemtobe ambiguousastheylackaformaldescription or tooling incomplete because some patterns miss their inverse operation and overlapping i.e.
an edit may belong to multiple patterns .
to address ambiguity and incompleteness we refined and extended their patterns with formal definitions in terms of classes.
to address the overlap we distinguish between classes and compositeeditpatterns.moreover weprovideopen sourcetooling toautomaticallyclassifyeditsandourvalidationcovers44systems instead oftwo.
complete and unambiguous classifications of edits to variabilityareonlyavailableforthe problemspace sofar e.g.
forfeature modelsdefiningthesetofvalidconfigurations butnotthesolution space i.e.
source code and feature mappings .
th m et al .
introduce four groups of edits to feature models.
interestingly our classesspecialization generalization reconfiguration andrefactoringacting on source code correspond to these groups.
this is not surprising because feature models and feature mappings both describe a set of valid configurations but for the entire product line oracertainimplementationartifact respectively.inspiredbythis analogy wedecidedtopartlyadoptthenamingschemeof th m et al.for the above mentioned classes.
b rdek et al .
extend the work by th m etal .with concreteeditoperations.analogous to our work b rdek et al .distinguish between elementary edits andcomplex compositeedits.thus theclassificationby b rdek etal.canbeseenasthecounterpartforfeaturemodelstoourwork on source code.
patterns for refactorings and generalizations or specializations tofeaturemodelsdo not classifyedits.
the complete and unambiguous classifications for edits to feature modelsserveasinspirationforourworkbutcannotbeusedforeditsto sourcecode andfeature mappings.
automatic analyses of edits to source code do not facilitate acompleteclassification.withanautomaticanalysiswhetheredits inlinuxaffectthefeaturemodel featuremappings orsourcecode kr heretal .
inspectthatbutnothowvariabilityinformation was edited.
dintzner et al .
present fever which parses the historyofproductlinesautomatically.whilefeverretrievesextensive data and metadata for co evolution of variability it does notprovideaclassificationofedits.basedontherefinementtheory safe evolution templates describe possible scenarioshowfeaturemodel featuremappings andsourcecode canbechangedwithoutalteringthesetofvalidproducts.whilethe refinement theorycanmodelanyedit tovariability thedescribed templates are incomplete by design because they target partial 205classifying edits to variabilityin source code esec fse november14 18 singapore singapore refactorings.moreover thereisnodistinctionbetweenfeaturemappingsandpresenceconditions.niekeetal .
extendthenotionof refinements to guide the adaption of configurations upon complex edit scenarios such as feature merges.
nieke et al .identify three exemplary i.e.
incomplete evolution templates.
further analyses oftheevolutionofproductlines donotclassifyedits.opposed to the state of the art we performed a large scale validation by classifying million edits from .
million commits in systems.
wecouldclassifyalleditsandprovedthatourclassesarecomplete.
semi automatic analyses of edits to source code do not facilitateacompleteclassification.withamanualanalysisof657 commits passosetal .
extractededitpatternsfromtheevolution oflinux butremainincompleteastheyreporteditsthatdidnot match any pattern.
seidl et al .
propose evolution operators for model based product lines that have to be employed manually duringdevelopmentandmakenoargumentsoncompleteness.due to the fact that our analysis is fully automated we could classify farmore commits andsystemsfrom differentdomains.
editspecificationsforotherpurposes thanaclassification of edits are incomplete or ambiguous.
to evaluate the benefits of recording feature mappings ji et al .
provide an extensive catalog including macroscopic edits such as cloning whole code bases.
yet their patterns are given in natural language and thus matchingpatternscannotdirectlybeautomated.whiledesignedfor testing the mutation operators by al hajjaji et al .
exhibit some similarity with our classes.
yet the operators remain incomplete e.g.
addwithmapping andtherebyatruesubsetofeditsismissing .
further work on refactorings presents proactive evolution operators similar to seidl et al .
but without classifying edits.
potentially our classescan alsobe usedfor the above purposes.
the choice calculus is a formal language for variation andcloselyrelated toourvariationtrees.whilechoicesmodelalternative variation i.e.
exactly one of a set of alternatives must bechosen variationtreesmodeloptionalvariation i.e.
subtrees can be in or excluded .
while choice calculus was applied in practice itwasneverappliedtoevolutionandwefound optional variation to model preprocessor based variability more naturally.inthefuture weaimtostudytherelationshipbetween choicecalculus andvariation trees.
differencing techniques describe changes to data such as source code in concrete or abstract syntax but are unaware of variability.
our theory and our tool diffdetective makediffsvariability awarebyparsingageneric diff e.g.
unix diffs into a variation diff which explicitly models edited variability.
thus any diff tool may be used to obtain a generic intermediate diff in diffdetective .
semantic differencing reliesonoperationalsemantics e.g.
controlflow ofsingle variantsystemsandisoblivioustovariability.
variability awareparsing forconditionalcompilationyields a singleabstract syntax tree withvariability information butdoes not consider edits.
medeiros et al .
semi automatically apply variability aware parsing to the versions of eight systems across 51k commits but do not inspect edits to variability.
to inspect edits treediffingcould be employedbutisnotyetvariability aware.
moreover whilemedeirosetal .
reportnotimingresults itis known thatparsingasingleversionoflinuxtakesmorethan ten hours while we extract all relevant information from a singlecommit in .5msonaverage.
usecases.
ourvariationtreesanddiffsserveasaunified formallanguagetoexpress communicate andreasonaboutvariability and edits to it.
research and tools on evolution of variation basedonourclassificationareguaranteedtobecompleteregarding edits.
for instance our catalog increases the applicability of variability aware mutation testing by completing their existing setofmutationoperators.forvariation controlsystems andmanagedclone and own whichinspectandoperate primarily on edits our classes can serve as a design reference and evaluation dataset .
methods for synchronizing variants inmanagedclone and own areguaranteed to be able to deal with any input edit from users when based on our complete variation diffs and classes.
moreover software developerscanobservetheeffectoftheireditsonvariabilityto for example validatethataneditwasarefactoringorspecialization such thatno further testcaseshave tobeintroduced.as alibrary diffdetective enables researchers and practitioners to study the evolution of variability in source code by retrieving variation diffs anddetecting editclassesautomatically.
conclusion we propose a classification of edits to variability in source code thatweprovetobecomplete i.e.
everyeditisclassifiedbyatleast one class and unambiguous i.e.
every edit is classified by at most oneclass .weintroducevariationtrees aformalmodeltodescribe variability in source code and variation diffs a formal model to describechangestovariationtrees whichweprovetobecomplete andwhichissound byconstruction.
to validate the suitability and potential for automation of our concepts andclassification we classifiedabout45millioneditsto sourcecodefullyautomatically.ineffectively 70min weprocessed about .
million commits from the histories of open source softwaresystems.
.
oftheconsideredcommitswereprocessed in less than a second making our method feasible in practical scenarios such as continuous integration.
we found that .
of thepatchessubmittedbydeveloperscontainsyntacticallyincorrect preprocessorannotations.allother editswere classifiedand each ofour editclassesoccurs inpractice.
oureditclassescanbeusedtogaininsightsintotheevolutionof configurablesoftwaresystemsandtheeffectsofeditsonvariability.
in the future we plan to derive composite edit patterns from frequent compositions of instances of our edit classes which serve as buildingblocksto describe more complex changes.