assetharvester a static analysis tool for detecting secret asset pairs in software artifacts setu kumar basak k. virgil english ken ogura vitesh kambara bradley reaves and laurie williams north carolina state university usa sbasak4 ncsu.edu kvenglis ncsu.edu kogura ncsu.edu vkkambar ncsu.edu bgreaves ncsu.edu lawilli3 ncsu.edu abstract gitguardian monitored secrets exposure in public github repositories and reported that developers leaked over million secrets database and other credentials in indicating a surge from .
despite the availability of secret detection tools developers ignore the tools reported warnings because of false positives .
however each secret protects assets of different values accessible through asset identifiers a dns name and a public or private ip address .
the asset information for a secret can aid developers in filtering false positives and prioritizing secret removal from the source code.
however existing secret detection tools do not provide the asset information thus presenting difficulty to developers in filtering secrets only by looking at the secret value or finding the assets manually for each reported secret.
the goal of our study is to aid software practitioners in prioritizing secrets removal by providing the assets information protected by the secrets through our novel static analysis tool.
we present assetharvester a static analysis tool to detect secret asset pairs in a repository.
since the location of the asset can be distant from where the secret is defined we investigated secret asset co location patterns and found four patterns.
to identify the secret asset pairs of the four patterns we utilized three approaches pattern matching data flow analysis and fast approximation heuristics .
we curated a benchmark of secret asset pairs of four database types extracted from public github repositories to evaluate the performance of assetharvester.
assetharvester demonstrates precision of recall and f1 score in detecting secret asset pairs.
our findings indicate that data flow analysis employed in assetharvester detects secret asset pairs with false positives and aids in improving the recall of secret detection tools.
additionally assetharvester shows increase in precision for database secret detection compared to existing detection tools through the detection of assets thus reducing developer s alert fatigue.
i. i ntroduction in march gitguardian reported a surge in developers leaking over million secrets in public github repositories in compared to .
they found that .
million authors leaked secrets out of .
million who pushed code to github in .
secrets such as database credentials and api keys are essential for integrating with external services such as customer databases and payment systems.
however developers keep hard coded secrets in application packages and version control systems vcs exposing sensitive information to attackers .
for example an attacker leveraged hard coded credentials present in uber s powershell script and launched an account takeover of their internal tools and productivity applications in september .
a a public ip address protected by a secret b a localhost protected by a secret fig.
a secret can protect both real and non sensitive assets such as a public ip address real and localhost non sensitive .
at present many open source and proprietary secret detection tools such as trufflehog and ggshield are available to prevent leaking secrets.
however basak et al.
investigated five open source and four proprietary secret detection tools and found that five of these nine tools demonstrate a precision of less than .
the tool with the highest precision among the nine tools misses many secrets having only recall.
thus developers may develop alert fatigue and start to ignore the warnings reported by the tools.
a secret in a software artifact protects an asset a database or an api service accessible through asset identifiers a url a dns name or an ip address .
however a secret may look like a false positive that protects a real asset.
for example figure 1a shows a customer database with a public ip address .
.
.
protected by the password .
on the contrary a secret may look like a true positive but protects a non sensitive asset.
for example figure 1b shows the password 332315yuan protects a test database of a localhost that is typically not vulnerable to outside attackers.
however existing secret detection tools do not provide the asset information corresponding to a secret.
as a result developers manually filter alerts based on the secret value without the asset information and may ignore a secret protecting a valuable asset.
in addition developers may lose their development time while manually identifying the asset for each secret reported by the tools.
thus programmatically identifying the assetsarxiv .19072v2 nov 2024protected by the secrets can aid in reducing the manual effort of developers to filter false positives and identify secrets that protect valuable assets.
additionally developers can prioritize efforts to remove secrets based on the asset context.
the goal of our study is to aid software practitioners in prioritizing secrets removal by providing the assets information protected by the secrets through our novel static analysis tool.
however identifying the assets protected by the secrets is not straightforward since the asset identifiers can have multiple parts defined separately in the source code.
for example a database server address contains a host port and database name.
in addition multiple assets can be present in the same file such as a configuration file .
additionally the asset can be distant from where the secret is defined in the source code.
for example a secret is disclosed in one file and the corresponding asset is disclosed in another file of the repository.
thus even if we identify the asset mapping the asset to the correct secret is challenging.
in this study we investigate how we can programmatically identify both the secret and the asset protected by the secret and provide answers to our research questions rq1 what are the secret asset co location patterns present in software artifacts?
section iv rq2 what performance can be achieved in detecting assets protected by secrets via static analysis in terms of precision recall and f1 score?
section vi we curated assetbench a benchmark of secret asset pairs of four database types extracted from public github repositories.
to answer rq1 we investigated and categorized the secret asset co location patterns in the source code.
to answer rq2 we constructed assetharvester a static analysis tool to identify the database secret asset pairs.
in constructing assetharvester we utilized pattern matching data flow analysis and fast approximation heuristics to detect the secret asset pairs.
we evaluated the performance of assetharvester against assetbench in terms of precision recall and f1 score.
we provide a summary of our contributions as follows we constructed assetharvester a static analysis tool to detect the assets protected by secrets to aid developers in prioritizing secrets removal.
additionally assetharvester has shown and increase in precision and recall respectively for database secret detection compared to existing detection tools through the detection of assets.
we have made the implementation of assetharvester publicly available .
additionally we provided assetbench a dataset of secret asset pairs that can be extended and utilized by researchers and tool developers for future research and tool development.
the rest of our paper is structured as follows section ii introduces the selection process of asset types followed by the benchmark dataset curation and the secret asset colocation patterns.
we discuss the assetharvester construction and evaluation results of assetharvester against assetbench in sections v and vi followed by the implications of our work.
we discuss the ethics and limitations of our study in fig.
the database asset identifier has three parts host port and database name that are defined separately in the same line in separate lines or together in the same string.
sections viii and ix respectively.
we discuss the related work in section x and conclude in section xi.
ii.
a sset type selection a software artifact may contain different types of assets such as database server addresses and api urls which are protected by secrets.
however the gitguardian report reveals that out of million exposed secrets in github the top secret type is database providers.
additionally database assets can be challenging to detect due to multiple asset identifier formats among other asset types.
for example figure shows a database asset identifier can have multiple parts host port and database name defined separately in the same line line or different lines lines .
the database asset can also be in the same string line .
thus we selected database secret asset pairs to be detected in this study.
since multiple database providers are present we need to narrow our scope to maintain our study s feasibility.
we observed that the top five databases developers use are postgresql mysql sqlite mongodb and sql server according to the stack overflow developer survey .
however we excluded sqlite from our study since sqlite is a filebased database requiring no authentication.
finally we selected these four databases for our study.
iii.
a sset bench to create a dataset of secret asset pairs we started with secretbench a publicly available benchmark dataset of software secrets.
we accessed the dataset through google cloud storage bucket name secretbench and google bigquery dataset id dev range .secretbench.secrets .
the authors curated repositories from the september snapshot of google bigquery public dataset of github dataset id bigquery public data.github repos .
the repositories in the dataset comprise source codes of programming languages.
the secrets present in the repositories are extracted using two open source secret detection tools trufflehog and gitleaks .
the dataset contains labeled plaintext secrets manually labeled as true or false by two authorstable i count of secret asset pairs for four databases database type secret asset pair of pair mysql .
postgresql .
mongodb .
sql server .
of the secretbench.
in addition the dataset provides additional metadata such as repository name commit id file path and line number where the secrets have been found.
however the dataset does not provide information regarding the assets protected by the secrets.
hence we extended the dataset as assetbench by identifying assets for each secret in our study.
filtering dataset before identifying assets we applied the following selection criteria to filter secretbench.
criteria programming language the gitguardian report indicates that developers most frequently leaked secrets in repositories written in python programming language .
additionally we observed that python is third among programming languages containing secrets in secretbench.
thus we chose repositories containing python source code for our study.
we selected repositories from repositories and secrets from secrets of secretbench.
criteria database type a repository can contain different types of secrets such as api keys and database credentials.
we filtered the secrets of the selected four databases section ii and selected secrets from secrets.
identifying assets next the first and third authors manually inspected each secret independently using the repository name commit id file path and line number provided by the dataset and identified the asset protected by the secret.
however the asset may not be present in the same file where the secret is located.
in such cases both authors inspected the candidate asset containing files in the repository.
the asset s value for each secret with additional metadata the file path and line number where the asset is found is collected.
we observed the agreement of finding the secret asset pairs with a cohen s kappa score of .
between two authors which indicates a near perfect agreement according to landis and koch s interpretation .
the disagreements were resolved after a discussion between the two authors.
however neither author found corresponding assets for secrets.
we removed those secrets and selected secret asset pairs.
in table i we presented the database type and the number of secret asset pairs with percentages for each type.
assetbench contains secret asset pairs for sql server representing .
of the total pairs.
the relatively lower percentage might stem from sql server s proprietary nature leading to lesser adoption in open source projects than available open source databases.
developer survey to evaluate whether the committer of the secret agrees with our identified asset for the secret we conducted a developer survey.
first to avoid recall bias we selected secret asset pairs committed between and and identified secret asset pairs.next we filtered out secret asset pairs that have a noreply xxx users.noreply.github.com or github actions bot action github.com commit email address and selected secret asset pairs.
next we randomly selected secret asset pairs to avoid selection bias and emailed the developers to know their agreement with our labeling and the reason for any disagreements.
in the email we provided the secret asset pair information with a screenshot of the code where the secret asset pair is found.
we received responses out of and all respondents agreed with our label.
dataset storage our curated dataset assetbench is stored in google bigquery dataset id dev range .assetben ch.assets as a relational structured data.
users can access the dataset through sql queries.
however due to the sensitive nature of the dataset we will provide access to the dataset to only selected researchers and tool developers.
those who require access need to contact us through email.
iv.
s ecret asset co location patterns to answer rq1 the first and second authors independently inspected a random sample of secret asset pairs from the assetbench.
both authors observed the location pattern of a secret and the corresponding asset and identified four mutually exclusive secret asset co location patterns.
we utilized the colocation patterns for programmatically identifying secret asset pairs in the construction of assetharvester as described in section v. we now describe the four secret asset co location patterns.
the number in parenthesis denotes the occurrences of each pattern found out of secret asset pairs.
pattern same string same line same file the secret and the corresponding asset identifier can be present in the same string and the same line of a file such as in a database connection string.
for example figure 3a shows a mongodb connection string mongodb root s123 .
.
.
defined in line where root and s123 are the username and password of the database and .
.
.
is the database server address.
pattern separate strings same line same file the secret and the corresponding asset identifier can be present in the same line of the file but defined separately in multiple strings.
for example the database server address .
.
.
the username test and the password test are defined and passed as separate arguments to db.connect method in line as shown in figure 3b.
pattern separate strings separate lines same file the secret and the corresponding asset identifier can be present in the same file of the repository but defined in separate strings and separate lines.
for example as shown in figure 3c the username root and password root are defined in lines and respectively whereas the database server address .
.
.
is defined in line of the same file.
pattern separate strings separate lines separate files the secret and the corresponding asset identifier can be present in separate files of the repository.
for example as shown in figure 3d the username root and password of the database are defined in lines and of a pattern same string same line same file b pattern separate strings same line same file c pattern separate strings separate lines same file d pattern separate strings separate lines separate files fig.
we identified four types of secret asset co location patterns in the source code.
common.py file respectively.
the values of the common.py file are imported in line of the pattern4.py file where the database server address wrpxdb.bioch.edu is defined in line .
however the secret and the asset may not always be present in the same file types.
for example both the files in figure 3d have .py extension.
however the secret or asset can be defined in configuration files such as config.yml file that can be read in a .py file.
v. a sset harvester we utilized the identified secret asset co location patterns section iv and constructed assetharvester using pattern matching step data flow analysis step and fastapproximation heuristic step .
we now discuss the threestep process of constructing assetharvester.
step asset finding using pattern matching we observed from pattern in section iv that the secret and the corresponding database asset are present in a database connection string.
since a database connection string follows a specific format we can formulate regular expressions regex to identify the secret and the corresponding asset.
we now discuss our approach to formulating the regex and identifying the assets protected by the corresponding secrets.
step .
formulating regex in this step we manually inspected the documentation for each database type and identified the database connection string format.
then we categorized the connection string formats into three groups and formulated the regex for each group as shown in table ii.
we now discuss how we categorized the database connection string formats and formulated regex for each group.
group mysql postgresql mongodb we observed that according to mysql postgresql andmongodb documentations these three database types have similar connection string formats.
the common format is host .
the scheme refers to the transport protocol user password refers to the credentials host port refers to the server address and dbis the database name in the connection.
we observed that only the scheme type differs in the three database connection strings.
for example mysql uses mysql or mysqlx whereas postgresql uses postgresql or postgres as the scheme types.
hence we formulated a common regex with the different scheme types for group .
group odbc ole db the open database connectivity odbc and the object linking and embedding database ole db are two standard apis that provide support for accessing and interacting with different databases.
odbc and ole db support the selected four databases in our study.
we noticed that odbc and ole db have similar connection string formats consisting of key value pairs separated by semicolons.
for example the connection string format for odbc is driver driver name server address database dbname uid username pwd password .
the keydriver refers to the odbc database driver to be used such as sql server .
the key server refers to the address of the database server and keys uid andpwd refer to the credentials in the connection.
however for ole db the key for the database server is data source instead of server .
hence we formulated a common regex with all the odbc and ole db key value pairs for group .
group jdbc similar to odbc and ole db java database connectivity jdbc is a standard api that allows java applications to interact with different databases.
intable ii list of regexes categorized into three groups for identifying database connection string type connection string format example regexgroup 1mysql host mysql root root .
.
.
test ?p dbms mysql mysqlx mysql srv postgresql postgres mongodb mongodb srv ?p credentials ?
?
?
?p server postgresql host postgresql test test localhost mydb mongodb host mongodb root test .
.
.
27017group 2odbcdriver driver name server address database dbname uid username pwd password driver sql server server .
.
.
database test db uid sa pwd sa ?
provider driver ?
?
data source server ?p server ?
?
initial catalog database ?
p database ?
?
?
user id uid ?p user ?
?
?
password pwd ?p password ?
ole dbprovider provider name data source address initial catalog dbname user id username password password provider sql server data source .
.
.
initial catalog test db user id sa password sagroup 3jdbcjdbc host jdbc sqlserver root root localhost ?p dbms mysql postgresql mongodb sqlserver ?
p credentials ?
?
?
?p server ?
s ?user ?p user ?
amp ?
?
?
password ?p password ?jdbc host ?user usr password passjdbc sqlserver localhost?user root password root our study though we selected repositories containing python programming language repositories can have java source code containing jdbc connection strings.
in addition packages such as jaydebeapi are available that allow the connection of a database using the jdbc connection string from the python source code.
as shown in table ii the jdbc connection string starts with jdbc prefix followed by the scheme type server address and database name.
we observed that the username and password can be present in two forms either before the server address or separately in the query parameters.
we combined the two forms and formulated a common regex for group .
to separate the secret and asset from the database connection string we used the capturing group feature of regex.
the capturing group allows us to capture a specific part of the match.
for example as shown in table ii we implemented three capturing groups in the mysql regex.
the capturing group dbms captures the database type credentials captures the username and password and server captures the server address of the database.
step .
identifying secret asset pairs using regex in this step we executed the regexes formulated in step .
to identify the database connection strings.
we used the re library of python to execute the regexes.
since the database connection strings can be present in the git commit history of a repository we used gitpython a python library for traversing the commit history.
in addition to the commit id file path and line number of a match we extracted the secret and the corresponding database asset from the connection string using the capturing group of regex.
step asset finding using data flow analysis among the four patterns described in section iv except pattern we observed that the secret and the corresponding database asset are not present in the same string.
instead the secret and the corresponding database asset are defined separately and passed into a database driver function defined in the same or separate source file from where the secret and asset are present.
for example as shown in figure 3c pattern the database username password and the server address present in lines and respectively are passed into mysql.connect driver function defined in line .
for assetharvester we utilized data flow analysis todetect the flow of secrets and assets into the database driver functions.
previous research has used data flow analysis for security weakness propagation in the source code such as the use of weak cryptographic algorithms.
in a data flow analysis the data flow among program elements of the entire source code is modeled through a data flow graph dfg .
a dfg is a directed graph that consists of a set of nodes and a set of edges.
the nodes in the dfg represent the semantic elements that carry values at runtime whereas edges represent the way data flows between program elements.
in a program a node representing the origin of data is called thesource whereas a node representing the destination of the data is called the sink .
in our study a database secret and the corresponding asset are the sources and the database driver functions are the sinks.
we now describe the process of identifying the python database drivers for our study.
additionally we discuss the ways sources can flow into the database driver sinks and the process of identifying the secret asset pairs from the sources and sinks.
step .
identifying database drivers to identify the python database drivers we constructed a set of search strings mysql or postgresql or mongodb or sql server and driver for python .
we selected the top results from google search engine for each search string.
the stopping criteria for choosing the top results are based on the grey literature search guideline in prior studies .
from the search result we identified database drivers grouped in categories which are presented in table iii.
we observed that in addition to identifying database drivers for the four databases odbc and jdbc we identified two drivers peewee and sqlalchemy for the object relational mapper orm framework .
orm is different than other drivers since orm abstracts the database access with objects instead of directly managing the database access with sql queries.
the identified drivers have a function such as connect orcreate pool to connect with the database.
we observe that a driver function can have two different argument types positional and keyword which act as the sinks for database username password and server address.
the columns positional argument and keyword argument of table iii indicate which argument type each driver supports.
we now discuss the two argument types astable iii list of python database drivers with their supported arguments for secret asset pairs category driver namepositional argumentkeyword argument mysqlaiomysql mysql connector pymysql postgresqlaiopg asyncpg psycopg2 mongodb pymongo sql server pymssql odbc pyodbc jdbc jaydebeapi ormpeewee sqlalchemy fig.
the database credentials and server address are passed in a specific order in the database driver function.
sinks for database secrets and assets.
.positional argument a positional argument is passed to a function based on the position in the argument list without explicitly specifying the parameter name.
since the order of the position of the arguments is fixed we know which positions will act as the database credentials username and password and asset host port and database name sinks.
for example as shown in figure the username password database name and host address of the database are passed in a specific order in the connect function of asyncpg .
hence we identified the sources that flow into each ordered position of the driver function for the database secrets and assets.
.keyword argument a keyword argument also called named argument is passed to a function by specifying the parameter name with the corresponding value.
unlike positional argument the order of keyword argument is not fixed in a function.
we observe that keyword arguments can be passed in separate parameter names and dictionary objects.
as shown in figure 5a the username password database name and host address of the database are passed in separate named arguments without fixed order whereas defined in a dictionary object and passed in the function as shown in figure 5b.
since we know the argument names we can identify the sources flowing into the relevant arguments of the driver function for the database secrets and assets.
step .
identifying secret asset pairs using codeql for data flow analysis we used version .
.
of codeql an open source source code analysis framework developed by github.
codeql treats source code as data and creates databases containing a hierarchical representation of the code such as the abstract syntax tree the data flow graph and the control flow graph.
developers can query the database a keyword arguments passed as separate parameters b keyword arguments defined in a dictionary fig.
the database credentials and server address are passed as keyword arguments in the database driver functions.
using ql a query language optimized for efficiently analyzing databases representing software artifacts .
first we queried the abstract syntax tree to identify the database driver sinks functions and respective arguments .
next we queried the data flow graph to find the sources that fall into the identified sinks and find the value of the secretasset pairs for the corresponding sources using the abstract syntax tree.
finally we queried the control flow graph to find the location file path and line number of secret asset pairs.
since the database drivers are external libraries we utilized the api graphs of codeql to compute the data flow graph.
api graphs are a uniform interface for referring to functions classes and methods defined in external libraries.
in our study we used the semmle.python.apigraphs module for accessing the external library functions.
step .
identifying secret asset pairs using codeql and file parsing we observed that the database secret and the corresponding asset can be present in a configuration config file such as yaml json and xml files.
the config file is read as a dictionary object and the values of the dictionary object are accessed in the driver function.
for example as shown in figure the secret and the corresponding asset of mysql database are present in the config.yml file which is read in a dictionary object cfg of the main.py file lines and .
the values of dictionary object cfg are accessed in the aiomysql.connect driver function lines using key names such as dbhost anddbuser .
however codeql does not support data flow analysis of source codes across multiple programming languages.
as a result the flow of secrets and assets from the config.yml file into the driver function of themain.py file can not be captured.
however we observed that by utilizing the data flow analysis of codeql we can find the config file name and the key names that flow into the driver function.
since we identified the config file name and associated the key names we parsed the config file and retrieved the values for each key name.
for retrieving the values from the yaml json and xml files table iv statistics of the presence of database assets in the neighboring lines of the secrets of the same file in assetbench secretabsolute difference between secret and asset line number number of secret asset pairs database password .
.
.
.
.
fig.
the config.yml file contains the database secret asset pair that is read in the main.py file.
the secret asset values are accessed by the key names and passed to the driver function.
we used the pyyaml json and xmltodict packages of python respectively.
step asset finding using fast approximation heuristic we observed that developers may have accidentally or intentionally kept the secret and the corresponding asset as commented lines in the source code.
however commented lines are ignored during data flow analysis.
additionally capturing the data flow may not always be possible if the source code has dynamic behavior such as extensive use of reflection.
thus we can not identify the assets protected by secrets in those cases using data flow analysis.
however when the secret asset pair is present in the same file we observed from assetbench that the database asset may be present in the neighbor lines of the corresponding secret.
as shown in table iv the percentage of database assets present within three neighboring lines of the corresponding database password in the same file is .
.
thus we can check the neighboring lines of the secret line to identify the corresponding asset.
in our study we define three neighboring lines as three lines above and three lines below the secret line.
for example if a secret is present in line the asset can be present between line and line .
we now discuss the approach of identifying the secret asset pairs using neighboring lines.
step .
identifying and filtering secrets first we identified the secrets in the repositories using two open source secret detection tools trufflehog and gitleaks .
the fig.
multiple or zero corresponding assets can be present in the neighboring lines of a secret.
authors of secretbench have used the same two tools to curate the benchmark dataset as discussed in section iii.
since the two tools can overlap outputting the same database secret in a repository we merged the unique secrets.
next we filtered the unique secrets for which we already found assets using regex step and data flow analysis step .
step .
identifying secret asset pairs using neighboring lines in this step to identify the neighboring lines for each secret we used the linecache library of python that provides random access to source code lines.
we observe that a database asset identifier can be present as an ip address .
.
.
or a dns name wrpxdb .bioch.edu as shown in pattern and respectively.
hence we formulated regexes for capturing the ip addresses b ?
d .
d b and dns names b .
d b in the neighboring lines.
however the neighboring lines may contain multiple ip addresses and dns names.
among those assets one asset can be the corresponding asset for a secret.
for example as shown in figure a file server and a mysql database address are present in lines and respectively.
the correct asset for the mysql database username and password present in lines and is the mysql database address.
in addition the asset protected by the secret may not be present in the source code.
for example a dns name for an email server is present in line .
however the email server is not the asset protected by the mongodb database username and password present in lines and respectively.
we observe that a specific group s secret and corresponding asset can have the same prefix in the variable or key names.
for example as shown in figure the key names of username mysql user password mysql password and server address mysql host of mysql database have the same prefix mysql .
however the key name of the file server does not start with the same prefix as the key names of the mysql database.
hence we can apply a string matching algorithm to calculate similarity scores between the secret linetable v precision recall and f1 score of assetharvester for each database type database typeprecision tp fp recall tp fn f1 score mysql .
.
.
postgresql .
.
.
mongodb .
.
.
sql server .
.
.
overall .
.
.
and the candidate asset lines and choose the asset with the highest similarity score.
in addition we discard the asset if the similarity score with the secret line is less than a threshold.
to calculate the similarity score we used jaro winkler similarity a string matching algorithm that uses a prefix scale by giving a high similarity score to strings that match from the beginning.
the jaro winkler algorithm provides a similarity score between and and we chose .
as the threshold similarity score.
we utilized the jaro winkler similarity function from the jellyfish package in python to compute the similarity score and identify the secret asset pairs.
vi.
p erformance of asset harvester in this section we answer rq2 by evaluating the performance of assetharvester against assetbench.
precision recall and f1 score table v presents the precision recall and f1 score of assetharvester for each database type.
the column precision tp fp denotes the precision for each database type.
the number in parenthesis denotes the number of true positive and false positive secretasset pairs outputted by assetharvester.
the column recall tp fn denotes the recall for each database type.
the number in parenthesis denotes the number of true positive and false negative secret asset pairs outputted by assetharvester.
the column f1 score denotes each database type s f1 score the harmonic mean of precision and recall .
we now discuss our observations related to precision recall and f1 score.
we observed that assetharvester demonstrated overall precision indicating high precise detection of assets protected by secrets with low false positives.
the count of false positives indicates that the tool incorrectly outputted assets out of secret asset pairs.
the overall recall score of assetharvester is indicating a strong ability to identify instances of assets for secrets supported by an f1 score of .
the count of false negatives indicates that the tool failed to detect instances of secret asset pairs.
among the four database types the recall score of sql server is low though the precision score is .
the tool could not detect instances of sql server assets out of secret asset pairs.
we discussed the reason for false negatives later in this section.
performance of pattern matching data flow analysis and fast approximation heuristic figure depicts that assetharvester detected unique secret asset pairs using the fig.
the number of unique secret asset pairs found by pattern matching data flow analysis and fast approximation heuristic approaches.
three approaches thus indicating the importance of the three approaches.
out of secret asset pairs using pattern matching regex and data flow analysis codeql we found and unique secret asset pairs respectively.
in addition we found unique secret asset pairs using the fast approximation heuristic neighboring lines .
however we observed that instances of secret asset pairs were detected by both pattern matching and data flow analysis.
the overlap happened because of dsn keyword argument of driver functions which takes a connection string that is also matched by the regex of database types.
however the overlap is low since all the connection strings found by the regex are not passed to python database driver functions.
instead the connection strings are either passed to non python such as java or .net database driver functions or not passed to any functions.
thus those connection strings could not be captured by data flow analysis.
additionally we observed that among the three approaches assetharvester incorrectly detected and secret asset pairs out of false positives using pattern matching and fast approximation heuristics respectively.
however assetharvester did not detect any false positives using data flow analysis since we used specific sinks for database secret asset pairs from the documentation compared to generic sinks implemented by github codeql .
additionally we filtered sources flowing into sinks that do not point to primitive values string or integer .
we also filtered values with only colons or slashes that flowed into the sinks as part of the asset url from string concatenation to avoid false positives.
we now discuss our observations on the rules triggering the false positives and false negatives.
analysis offalse positives we observed that the false positives are mostly triggered by the neighboring lines rule .
of the false positives reported by assetharvester .
we noticed that the key names of the secret and corresponding asset do not always follow the specific pattern of having similar prefixes step .
section v .
for example url and password are the key names of a database server address and password but do not have the same prefixes.
as a result when multiple ip addresses or dns names were present in theneighboring lines and the similarity score met the threshold assetharvester could not detect the correct asset for a secret.
analysis offalse negatives we observed that assetharvester failed to detect secret asset pairs when the asset is not present within three neighboring lines of the secret.
as shown in table iv .
instances of secret asset pairs in assetbench do not fall within three neighboring lines.
in our study the repositories also contain non python source codes such as java and .net where the secret asset pairs are passed to java and .net database driver functions.
however assetharvester did not detect those secret asset pairs since we only executed data flow analysis for python source codes in our study.
thus assetharvester shows a lower recall for sql server among other database types since the sql server assets are typically passed to .net driver functions.
additionally assetharvester could not detect assets present as variables in the connection strings not passed to python driver functions.
for example the connection string jdbc post gresql databaseserver contains the variable databaseserver defined separately with the actual value.
comparison with baseline secret detection tools existing secret detection tools do not detect the assets protected by secrets.
thus we could only compare assetharvester s performance on secret detection with the existing tools.
basak et al.
compared five open source and four proprietary secret detection tools against secretbench.
we selected these nine baseline tools and evaluated them against repositories containing secrets of four databases as curated in section iii.
table vi presents each tool s precision and recall.
we observed that the nine baseline tools show lower precision less than and recall less than scores than assetharvester precision and recall .
additionally we noticed that github scanner did not output any database secrets since the supported secret patterns lack database secret patterns .
however github introduced generic secret scanning for unstructured secrets such as database passwords which we could not compare since the tool is in the beta phase and restricted to enterprise accounts only .
we observed that the lower precision of the tools is due to employing generic regex.
for example trufflehog detects the database connection string but does not check if the connection string contains a password thus outputting the connection string without a password as a secret.
we resolved these false positives using the capturing group of regex for assetharvester step .
section v .
additionally the lower recall is due to employing insufficient rulesets and ineffective entropy calculation.
for example tools reject a secret based on entropy score.
however we found instances of secrets having lower entropy scores protecting real assets.
we improved recall by identifying secrets flowing into the respective database driver functions using data flow analysis without considering the entropy score for assetharvester step section v .
in addition we identified secrets that are not present in secretbench using data flow analysis.
as discussed in section iii the authors of secretbench used two opensource tools trufflehog and gitleaks to curate the benchmarktable vi comparison of assetharvester with baseline secret detection tools on secret detection toolprecision tp fp recall tp fn git secrets .
.
gitleaks .
.
repo supervisor .
.
trufflehog .
.
whispers .
.
commercial x .
.
ggshield .
.
github scanner .
.
spectralops .
.
assetharvester .
.
dataset.
these tools leverage regex and entropy scores to identify secrets.
thus secrets that are not matched by the regex and entropy scores are missed.
developer survey since we leveraged a random sample of the dataset to construct assetharvester assetharvester s evaluation against assetbench is susceptible to bias.
however no other publicly available benchmark dataset containing secret asset pairs is present.
basak et al.
initially curated candidate github repositories for secretbench.
since identifying and manually labeling secrets from repositories was impractical they finally selected repositories using a multiset multicover algorithm .
to mitigate bias we selected a random sample of repositories from candidate repositories excluding repositories of secretbench after applying criteria and criteria as discussed in section iii.
we identified secret asset pairs unique secret asset pairs present in repositories commit history using assetharvester.
then we conducted a developer survey with the committer of secret asset pairs to evaluate assetharvester s performance and responses were received.
fifteen respondents agreed with our identified secret asset pairs and three respondents termed the secret asset pairs as false positives.
assetharvester s effectiveness beyond benchmark we identified the secret asset co location patterns from a random sample of assetbench containing database secret asset pairs section iv .
however we selected a random sample of secret asset pairs for each of non database secret types such as api keys tokens and private keys from secretbench .
we found that the co location of all the selected secretasset pairs matches our identified four co location patterns thus indicating the generality of the identified patterns.
for example as depicted in pattern same string same line same file the secret asset pair can be present in the same string in a url.
thus we can identify the api key and corresponding server endpoint from the api url similar to a database connection string.
additionally we did not limit assetharvester to the database drivers found in the random sample.
instead we identified the database drivers from the database provider documentation.
we found instances of only database drivers in the random sample.
however we con structed assetharvester with database drivers and detected secret asset pairs from database drivers in assetbench.
we also identified secret asset pairs from one new database driver while evaluating assetharvester s performance with new repositories section vi .
vii.
d iscussion in this section we discuss the implications of assetharvester from the findings of our study.
data flow analysis aids in detecting all parts of a credential and the corresponding asset as one group.
a credential can have multiple parts required to access the protected asset.
for example an access key id and a secret access key are required to access an aws resource whereas for accessing a database both a username and a password are required.
similar to credentials assets can have multiple parts as well.
for example a database asset consists of a host port and database name.
however existing secret detection tools can not detect all parts of a credential if present separately in the source code.
in addition the tools output each part of a credential in separate alerts instead of outputting as one group.
thus developers need to manually identify the related alerts out of all the alerts reported by the tools.
however assetharvester leverages data flow analysis to detect all parts of a credential and the asset and output as one alert to the developers.
in our study we detected the database credential username and password and asset host port database name flowing into the same database driver functions using data flow analysis.
additionally we provided the information on the call location as an additional context for the developers to prioritize secret and asset eradication from the source code.
assetharvester can be extended to detect secret asset pairs in other programming languages and non database secret types.
in our study we detected secret asset pairs of four database providers in python programming language.
however the found secret asset co location patterns are generic and can be applied to other programming languages and non database secret asset pairs section vi .
we now discuss the effort needed and challenges to extend assetharvester for other programming languages and secret types.
programming languages among the three techniques pattern matching data flow analysis and fast approximation heuristics we leveraged pattern matching and fast approximation heuristics are programming language agnostic.
hence these two techniques can be applied to find secret asset pairs in other programming languages without additional effort.
on the contrary the data flow analysis is dependent on the programming language.
however the abstract syntax tree control flow and data flow graph of the source code for each language in a repository can be computed separately which codeql supports.
then the queries to identify secretasset pairs can be run on each of the computed graphs thus extending for each programming language with minimal effort.
non database secret types we observed a random sample of secrets for seven secret types such as private key api key and authentication token from secretbench .
next wecategorized the secret asset pairs into two categories.
we now describe how we can extend assetharvester to detect secretasset pairs except for the database provider.
.
cloud providers for authentication and authorization with cloud providers such as google cloud api keys and tokens are used that can be present in an api url or separately passed to a function.
since each cloud provider follows a specific format for api urls a regex can be formulated for each api and added to the regex list step .
section v .
additionally when the secret is not present in the api url the secret and the api url can be detected by data flow analysis since these values are passed in a common http request client get andpost methods .
we observed that cloud secrets are the second most exposed secrets on github according to the gitguardian report .
additionally they found a fold increase in leaked openai api keys since driven by the rising use of large language models llms .
we will prioritize extending assetharvester to identify cloud provider secrets for future work.
.
non database servers a secret can protect nondatabase servers such as mail and ftp servers.
similar to database servers group table ii non database servers have specific formats containing a scheme type scheme us er password host port .
for example the smtp or pop3 are the mail server s scheme types whereas ftp is the scheme type for the ftp server.
we can add the scheme types in group of the regex list to capture the non database server secret asset pairs.
in addition the secret and the corresponding server url are used by functions such as login and smtp functions of smtplib module of python for sending email.
web and mail servers also use private keys to enable secure connections.
these keys are stored in a file separately from the asset location and read from another function in the source code.
thus we can leverage data flow analysis to retrieve the file name from the function and parse the file to identify the private key as shown in step .
of section v. our list of regexes and sinks for assetharvester is configurable and requires no source code change to detect nondatabase secret types.
though identifying the regex and sinks for each secret type from the documentation requires manual effort the process can be automated in the future.
for example llms can aid in identifying regex and sinks from source code patterns and vendor documentation for each secret type.
we can leverage the knowledge gained from the manual analysis of our study and generate prompts for llms.
viii.
e thics and data protection since our dataset contains sensitive information we will distribute the dataset selectively.
researchers and tool developers who want to use our dataset will sign a data protection agreement with us to ensure ethical use.
in addition we did not attempt to use the secret asset pairs to verify their validity.
we only contacted the developers who committed the secret asset pairs to validate our labeling.
additionally we are notifying every developer in our dataset to remove the secret asset pairs from their vcs.ix.
t hreats to validity in this section we discuss the limitations of our paper.
manual analysis manual analysis can introduce bias due to the multiple interpretations and oversights.
for example identifying the assets protected by secrets while curating assetbench is susceptible to bias.
we mitigated the bias by cross checking the identified secret asset pairs with two raters.
benchmark dataset our selection of benchmark dataset for secrets is susceptible to bias.
basak et al.
utilized two open source tools trufflehog and gitleaks and curated secretbench which we extended as assetbench by identifying the protected asset for each secret.
however we observed that assetharvester identified secrets not present in secretbench section vi .
thus secretbench may have more missing secrets impacting the results discussed in section vi.
developer survey for the developer survey of assetbench we selected the secret asset pairs committed between and .
however the developer s responses could have recall bias.
to mitigate the bias we provided screenshots of the secret and asset containing source code with metadata commit id file path and line number to the developers.
data flow analysis in our study we used codeql for data flow analysis in the latest snapshot of the repositories.
codeql can only model the data flow with the provided snapshot of the source code.
however developers can push secret asset pairs in one commit and remove them in another commit.
secretasset pairs can still be present in the old snapshot that can not be detected by executing data flow analysis on the latest snapshot.
however we can compute data flow analysis for each repository snapshot to identify the secret asset pairs from git history which will be impractical and time consuming.
neighboring lines our selection of three neighboring lines for identifying the assets for a corresponding secret poses a threat to internal validity since the three line range is selected from assetbench containing only database secret asset pairs.
however we selected a random sample of non database secrets from secretbench and identified the corresponding assets.
we found that the percentage of assets present within three neighboring lines of the corresponding secret is .
thus indicating the rule s generalizability to other secret types.
x. r elated work previous studies have investigated the underlying causes of the exposure of secrets in software artifacts.
researchers have found that keeping hard coded secrets in software artifacts is the most prevalent insecure practice that developers adopt causing secret leakage.
in meli et al.
found over 100k hard coded secrets by studying a snapshot of public github repositories.
rahman et al.
investigated infrastructure as code iac scripts extracted from open source repositories and observed security smells .
among the security smells hard coded secrets were found to be the most frequent with occurrences.
within github gists which developers use for sharing code snippets rayhanur et al.
found instances of hard coded secrets by investigating python gists in github.
these previousworks indicate that hard coded secrets have been leaking in various forms within software artifacts.
researchers have recommended that developers follow secure practices for secret management to avoid exposure of secrets in software artifacts.
in basak et al.
identified developer and organization practices by conducting a grey literature review of internet artifacts such as blog posts.
to avoid the accidental commit of secrets they suggested using vcs scan tools.
in another study basak et al.
investigated the challenges developers face for checked in secrets in stack exchange se and the solutions se users suggest to mitigate the challenge.
they found that to avoid accidentally committing secrets se users also suggested using vcs scan tools.
however basak et al.
compared open source and proprietary vcs scan tools against secretbench and observed that tools output a lot of false positives.
in addition tools failed to detect all the secrets present in a repository.
recent research has employed machine learning ml algorithms to reduce the false positives.
however among the vcs scan tools investigated by basak et al.
two tools commercial x anonymized and spectralops employed ml algorithms to detect secrets showed lower precision scores of and respectively.
rayhanur et al.
conducted a developer survey in an xtech company anonymized and found that developers ignore secrets due to many secrets outputted by vcs scan tools and time pressure.
however if the information about the asset protected by the secret was provided developers could have prioritized secret eradication.
however existing vcs scan tools do not provide the asset information for a secret.
in this study we concentrated our research efforts on identifying the assets protected by secrets to aid developers in prioritizing secrets removal efforts.
xi.
c onclusion we constructed assetharvester a static analysis tool to detect the assets protected by the corresponding secrets in a repository by investigating the secret asset co location patterns.
we utilized pattern matching data flow analysis and fast approximation heuristics to construct assetharvester.
to evaluate assetharvester we curated assetbench a benchmark dataset of secret asset pairs comprising four database types.
the secret asset pairs are extracted from public github repositories.
we found that assetharvester demonstrates precision of recall and f1 score in detecting secret asset pairs.
our findings indicate that data flow analysis employed in assetharvester detects secret asset pairs with false positives and also aids in improving the recall of secret detection tools.
in addition though fast approximation heuristics introduce relatively more false positives this approach improves recall by detecting assets that cannot be detected using other approaches.
acknowledgment this work was supported by the national science foundation grant.