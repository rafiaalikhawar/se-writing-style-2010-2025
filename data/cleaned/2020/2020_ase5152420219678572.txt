a compositional deadlock detector for android java james brotherston paul brunet nikos gorogiannis and max kanovich dept.
of computer science university college london uk facebook uk email j.brotherston ucl.ac.uk nikos.gorogiannis gmail.com paul brunet zamansky.fr m.kanovich ucl.ac.uk abstract we develop a static deadlock analysis for commercial android java applications of sizes in the tens of millions of loc under active development at facebook.
the analysis runsprimarily at code review time on only the modified code andits dependents we aim at reporting to developers in under 15minutes.
to detect deadlocks in this setting we first model the real language as an abstract language with balanced re entrant locks nondeterministic iteration and branching and non recursiveprocedure calls.
we show that the existence of a deadlock in thisabstract language is equivalent to a certain condition over thesets of critical pairs of each program thread these record for all possible executions of the thread which locks are currently heldat the point when a fresh lock is acquired.
since the critical pairsof any program thread is finite and computable the deadlockdetection problem for our language is decidable and in np.
we then leverage these results to develop an open source implementation of our analysis adapted to deal with real javacode.
the core of the implementation is an algorithm whichcomputes critical pairs in a compositional abstract interpretationstyle running in quasi exponential time.
our analyser is built inthe i nfer verification framework and has been in industrial deployment for over two years it has seen over two hundredfixed deadlock reports with a report fix rate of .
index t erms deadlocks concurrency program analysis i. i ntroduction the avoidance and detection of deadlocks in a system is one of the most fundamental problems in concurrency.
deadlocking is classically exemplified by dijkstra s fivedining philosophers five philosophers sit around atable with a fork between each pair of philosophers and a bowlof a very difficult kind of spaghetti in the centre so that eachphilosopher requires both their left and right forks in order toeat.
without any communication between the philosophers they will generally enter a deadlocked situation in which it isimpossible for any of them to eat for example if each of themimmediately takes the fork to their left .
more generally in aconcurrent program a deadlock describes a situation in which for some subset of that program s threads it is impossible thatany thread can eventually execute its next command.
in this paper we attack the problem of detecting deadlocks in android java applications under continuous developmentat facebook.
these applications are typically in the tens ofmillions of loc and undergo thousands of revisions per day.our main aim is to assist the developers in finding bugsintroduced by their code revisions and thus there are twoprincipal desiderata of our deadlock analysis.
the first is that itmust return reports to developers relatively quickly the targetbeing under minutes.
it is impossible to analyse whole large programs in their entirety within such a timeframe whichmeans that we need a method that works compositionally enabling us to focus only on the changed files and theirdependents.
the second is that reports from our analysis mustactually be useful to developers meaning that we focus on minimising the number of false positive reports as opposedto providing cast iron guarantees of deadlock absence.
our first step is to model the real programming language as an abstract programming language in which we can decide thepresence of deadlocks within a reasonable complexity bound.the abstract programming language we use is based on scoped a.k.a.
nested re entrant locks nondeterministic iterationand branching and nonrecursive procedure calls it can beseen as an overapproximate model of java with all informationabout variable and memory assignment abstracted away.
we show that the existence of a deadlock in our abstract programs can be precisely characterised as a condition on thecritical pairs of their sequential threads.
roughly speaking a critical pair of a thread is a pair x lscript such that some execution of the thread acquires an unheld lock lscriptwhile already holding the set of locks x. for the case of two threads we establish that c c2deadlocks if and only if there are critical pairs x1 lscript1 and x2 lscript2 ofc1andc2respectively such that lscript1 x2and lscript2 x1 withx1 x2 this condition can be generalised to the case of arbitrarily many threads cf.
theorem .
.
similar to other deadlock conditions in theliterature for communicating pushdown automata its correctness is crucially dependent on the fact that lockingisbalanced in our language in that any thread must release locks in the reverse of the order in which they are acquired i.e.
last in first out .
this is true of real programming languageswhenever scoped locking constructs are used such as java ssynchronized keyword or c s std lock guard.
since the set of critical pairs of any thread in our languageis in fact finite and computable the existence of deadlocks inour abstract programs becomes decidable and in np.
example .
.
consider a two threaded program c c2 wherec1andc2are sequential programs acquiring locks 36th ieee acm international conference on automated software engineering ase work licensed under creative commons attribution .
license.
36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
acq and releasing them rel in reverse order c1 acq x acq y skip rel y rel x c2 acq y acq x skip rel x rel y c1has two critical pairs x and x y and similarly c2has two critical pairs y and y x .
by taking x1 lscript1 x y and x2 lscript2 y x we can see that the condition above is met and indeed c1 c2deadlocks because there is an execution in which simultaneously c1 holdsxwhile waiting for y andc2holdsywhile waiting forx.
now consider the modified program c prime c prime where c prime acq z c1 rel z andc prime acq z c2 rel z .c prime now has three critical pairs z z x and z x y andc prime 2has critical pairs z z y and z y x .i n this case the condition above is not met and indeed c prime c prime does not deadlock because zacts as a guard lock preventing xandyfrom being accessed by c prime 1andc prime 2simultaneously.
we then leverage these theoretical results to design an automatic deadlock analyser geared specifically towards code changes in android java applications in section vi b weoutline the android specific features of the analysis .
thecore of our implementation is a context insensitive programanalysis that computes critical pairs in abstract interpretationstyle running in quasi exponential time in the syntactic sizeof the program.
crucially this analysis is compositional in that the critical pairs of a procedure call depend only onthe current state of the caller and the critical pairs of theprocedure itself which can be computed in advance.
thismeans that when analysing a code revision we do not need tore analyse the unchanged procedures in the program i.e.
theoverwhelming majority .
these properties enable our analysisto detect deadlocks in programs ranging in the tens of millionsof loc two orders of magnitude larger than the largestprograms handled by state of the art static deadlock detectors.
we provide an open source implementation of our analyser named starvation and included as part of the i nfer static analysis framework and describe its deploymentand impact at facebook where it has analysed many hundredsof thousands of code revisions and seen over two hundreddeadlock reports fixed in the last two years.
important note.
contrary to what many readers may well expect we do not undertake an experimental comparisonof our tool with others in the literature due to two majordivergences between our tool and others.
the first and mostimportant point of divergence is that most if not all of the tools in the literature require the whole program in order to run.
since the programs we target are so large these analysers might take hours or days to return a result or simply run out of memory.
in contrast our tool can runrelatively quickly on these programs because it only analysescode changes relying on compositionality of the analysis withrespect to the unchanged portions of the program.
the second less important divergence is that since our priority is to avoidwasting developers time we prioritise actionability of thetool s deadlock reports which means that we generally preferto admit false negative than false positive deadlock reports.
incontrast most tools that we know of do just the opposite.
the remainder of this paper is structured as follows.
section ii introduces our abstract concurrent programs.
insection iii we develop the key connections between sequentialprogram executions and their traces of lock acquisitions and releases .
then in section iv we establish the soundness andcompleteness of our deadlock condition based on critical pairs.in section v we show that the critical pairs of any sequentialprogram are computable and so establish upper complexitybounds on the deadlock problem.
section vi describes ourimplementation of the deadlock analysis for android java andits deployment impact at facebook.
section vii surveys therelated work and section viii concludes.
for space reasons the proofs of our theoretical results are only sketched in the present paper.
however the entiredevelopment has also been fully formalised in the coq proofassistant in roughly .7k lines of code.
ii.
p rogram synt ax and semantics syntax.
we let locks be a finite set of global lock names and procs a set of procedure names.
we define statements cas follows where lscriptranges over locks andpover procs c skip p acq lscript rel lscript c c if thencelsec while doc we assume there is a function body procs stmt that sends every procedure name to a statement its body.a function computing the callees of a statement callees stmt p procs can be easily defined.
we forbid recursion in statements i.e.
for all p procs p callees body p .
a statement is called balanced if it is generated by the following grammar which ensures that acq lscript andrel lscript only appear in balanced pairs c skip p acq lscript c rel lscript c c if thencelsec while doc moreover balanced statements must call only balanced pro cedures if cis balanced and p callees c then body p must be balanced as well.
we note that our balanced state ments are similar to those produced by compiling scope basedconstructs like java s synchronized keyword or c s std lock guard.
we will frequently need to reason by structural induction over balanced statements.
to account for procedure calls insuch proofs we employ an extended notion of substructure for statements given as the reflexive transitive closure of thefollowing condition any sub statement of c according to the grammar above is a substructure of c and body p is a substructure of p .
since our procedures are non recursive this ordering is still well founded.
finally a parallel program is ann tuple of balanced statements written c ... cn.
semantics.
as our programs employ only lock guards and non deterministic control our program states record only 956information about locks.
we treat locks as re entrant in that a thread already holding a lock can re acquire it without deadlock.
alock state is a function l locks n recording how many times each lock has been acquired.
we use the notation l for lscript locks l lscript .i fl 1andl2are lock states then we write l1 l2to mean that l1 l2 .w e write for the lock state sending all locks to .
we write l andl for the lock states defined as l except thatl lscript l lscript andl lscript l lscript .
aconfiguration is a pair angbracketleftc l angbracketright wherecis a statement andlis a lock state.
a concurrent configuration is then a pair of the form angbracketleftc1 ... cn l1 ... l n angbracketright where c1 ... cnis a parallel program and l1 ... l nare lock states.
we may also write concurrent configurations as angbracketleftc l1 angbracketright ... angbracketleftc n ln angbracketright or using a like notation as i n angbracketleftci li angbracketright.
we write angbracketleftci li angbracketright angbracketleftcj lj angbracketrightto mean that li ljand ifxis a set of lock states l xto mean thatl l primefor alll prime x. in figure we define the operational semantics of our programs by giving the small step relations for statementson ordinary configurations and for parallel programs on concurrent configurations squiggleright.a n execution of statement c is then as usual a possibly infinite sequence of configurations i i with 0 angbracketleftc angbracketright such that i i for alli .aconcurrent execution is defined analogously to an execution by substituting concurrent configurations forconfigurations and squigglerightfor .
we often represent executions i i 0as 0 n where is the reflexive transitive closure of and similarly using squiggleright for concurrent executions.
remark .
.
f or any concurrent execution 1 ... n squiggleright prime ... prime nthere exist standard executions i prime ifor each1 i n. furthermore if i j then prime i prime j i.e.
no two threads can acquire the same lock simultaneously.
we define deadlock of a program to mean that at least two of its threads are deadlocked.
for this we introduce anotation for projecting a concurrent configuration onto a subsetof its threads.
if angbracketleftc ... cn l1 ... l n angbracketrightis a concurrent configuration and i i1 ... im ... n is a set of thread indices we write ito mean the concurrent configuration angbracketleftci1 li1 angbracketright ...... angbracketleftcim lim angbracketright.
definition .
deadlock .
a concurrent configuration say angbracketleftc1 ... cn l1 ... l n angbracketright i s deadlocked if there is a sequential transition angbracketleftci li angbracketright angbracketleftc prime i l prime i angbracketrightfor each thread i.e.
for all i n but there is no concurrent transition squiggleright prime.
a parallel program c1 ... cnis said to deadlock if we have that angbracketleftc1 ... cn ... angbracketright squiggleright and iis deadlocked for some i ... n .
an immediate consequence is that if c1 ... cmdeadlocks and m n thenc1 ... cnalso deadlocks.proposition .
.
let angbracketleftc1 ... cn l1 ... l n angbracketrightbe a concurrent configuration such that li ljfor alli negationslash j. the configuration is deadlocked iff there are statements d1 ... d nand locks lscript1 ... lscript nsuch that for all i n angbracketleftci li angbracketright angbracketleftdi li angbracketright and lscripti uniontext j negationslash i lj .
proof.
follows from the operational semantics.
iii.
e xecutions and traces in this section we develop a key technical idea any execution of a statement in an arbitrary lock state can be viewed simply as a sequence of lock acquisitions lscriptand releases lscript which we call the execution s trace.
thus for example the two possible executions of the statement acq lscript if then acq j skip rel j else acq k skip rel k rel lscript have respective traces lscriptjj lscriptand lscriptkk lscript depending on which branch of the if statement is chosen.
traces preserve the essential information about executions in that the effect of an execution on any given initial lockstate can be computed from its trace.
moreover executionsofbalanced statements have traces that are essentially wellparenthesized strings of lock acquisitions and releases in factthey are dyck words in formal language theory .
definition .
.
the lock alphabet is defined as the union of two disjoint copies of locks lscript lscript locks lscript lscript locks .
aquasi lock state is a function in locks z. we lift the notations and from lock states to quasi lock states in the obvious way and write on quasi lock states to denote the pointwise sum of functions i.e.
f g x f x g x .
we define the function angbracketleft angbracketrightfrom words to quasi lock states inductively as follows angbracketleft angbracketright angbracketleftu lscript angbracketright angbracketleftu angbracketright angbracketleftu lscript angbracketright angbracketleftu angbracketright .
lemma .
.
f or allu v we have angbracketleftuv angbracketright angbracketleftu angbracketright angbracketleftv angbracketright.
proof.
by structural induction on v. in any sequential execution step angbracketleftc l angbracketright angbracketleftc prime l prime angbracketrightwe have l prime l o rl prime l orl prime l for some lock lscript.
this justifies the following definition.
definition .
.
given a transition angbracketleftc l angbracketright angbracketleftc prime l prime angbracketright w e define its traceu as follows u ifl prime l lscriptifl prime l lscriptifl prime l .
the trace of an execution is then defined as the concatenation of the traces of its individual transitions.
we often writetransitions and executions with their trace above the arrow as in angbracketleftc l angbracketright u angbracketleftc prime l prime angbracketrightand angbracketleftc l angbracketrightu angbracketleftc prime l prime angbracketright.
angbracketleftskip c l angbracketright angbracketleftc l angbracketright skip angbracketleftif thencaelsecb l angbracketright angbracketleftca l angbracketright if1 angbracketleftp l angbracketright angbracketleft body p l angbracketright proc angbracketleftif thencaelsecb l angbracketright angbracketleftcb l angbracketright if2 angbracketleftacq lscript l angbracketright angbracketleft skip l angbracketright acq angbracketleftwhile doc l angbracketright angbracketleft skip l angbracketright while1 angbracketleftrel lscript l angbracketright angbracketleft skip l angbracketright l lscript rel angbracketleftwhile doc l angbracketright angbracketleftc while doc l angbracketright while2 angbracketleftc1 l angbracketright angbracketleftc prime l prime angbracketright angbracketleftc1 c2 l angbracketright angbracketleftc prime c2 l prime angbracketright seq angbracketleftci li angbracketright angbracketleftc prime i l prime i angbracketrightl primei lj j negationslash i angbracketleftc1 ... cn l1 ... l n angbracketright squiggleright angbracketleftc1 ... c prime i ... cn l1 ... l primei ... l n angbracketright pari fig.
.
small step semantics for statements and parallel programs squiggleright .
proposition .
.
f or any execution angbracketleftc0 l0 angbracketrightu angbracketleftcn ln angbracketright and statement c we can obtain an execution angbracketleftc0 c l angbracketrightu angbracketleftcn c ln angbracketrightwith the same trace.
proof.
by inductively applying the semantic rule seq .
we define the language of a statement roughly speaking as the set of traces of its possible executions.
subsequent technical results will make this correspondence precise.
definition .
.
the language l c of a statement cis defined inductively as follows l skip l p l body p l acq lscript lscript l rel lscript lscript l c1 c2 l c1 l c2 l if thenc1elsec2 l c1 l c2 l while doc l c remark .
.
l c is in fact a regular language over .
our next lemma establishes that the effect of an execution is essentially determined by its trace.lemma .
.
f or any execution angbracketleftc l angbracketright u angbracketleftc prime l prime angbracketrightwe havel prime l angbracketleftu angbracketrightandu l c prime l c .
proof.
we first prove the lemma for a single step by rule induction on the semantics.
the general result then follows by reflexive transitive induction on .
next we recall the notion of dyck words over our lock alphabet essentially the well parenthesized words of opening and closing parentheses lscriptand lscript and relate them to executions of balanced statements.
definition .
.
the language dof dyck words over is generated by the following grammar d dd lscriptd lscript.
the following lemmas establish basic properties of our dyck words and their relation to our mapping angbracketleft angbracketright and are all proven by structural induction using lemma .
.
lemma .
.
ifcis a balanced statement l c d .
lemma .
.
f or anyu lscriptv d there exist words u1 andu2 d such that u u1 lscriptu2.
lemma .
.
f or anyu d we have angbracketleftu angbracketright .lemma .
.
f or anyuv d we have angbracketleftu angbracketright locks n. we now establish an analogue of lemma .
for executions of balanced statements which will be essential later for disentangling concurrent executions see lemma .
.
lemma .
.
letcbe a balanced statement.
f or any execution of the form angbracketleftc angbracketright angbracketleftc0 l0 angbracketright angbracketleftcn ln angbracketright angbracketleftcn ln angbracketright there exists j n such that lj ln andlj ln.
proof.
follows from lemmas .
.
.
.
and .
.
the final main result in this section is a kind of converse to lemma .
albeit for balanced statements only.lemma .
.
letcbe a balanced statement and let uv l c .
f or any lock state l there is a statement dand an execution angbracketleftc l angbracketright u angbracketleftd l angbracketleftu angbracketright angbracketright such that v l d .
ifv then this statement also holds when d skip.
proof.
by structural induction on c making use of earlier results.
the main idea is to analyse the trace uv l c in order to inductively build an execution of cwith trace u. note that lemma .
does not hold for non balanced statements.
e.g.
lscript l rel lscript but there are no executions of angbracketleftrel lscript angbracketright.
corollary .
.
f or any balanced statement c we have l c u angbracketleftc angbracketrightu angbracketleftskip angbracketright .
proof.
the inclusion follows from lemma .
and the inclusion from lemma .
with v .
example .
.
letcbe the statement from the beginning of this section acq lscript if then acq j skip rel j else acq k skip rel k rel lscript from definition .
we have l c lscriptjj lscript lscriptkk lscript and there are exactly two possible executions of cfrom the empty lock state we omit the intermediate commands and the skip steps angbracketleftc angbracketright lscript angbracketleft lscript angbracketright angbracketleft lscript angbracketrightj angbracketleft lscript j angbracketrightj angbracketleft lscript angbracketright lscript angbracketleft skip angbracketright angbracketleftc angbracketright lscript angbracketleft lscript angbracketright angbracketleft lscript angbracketrightk angbracketleft lscript k angbracketrightk angbracketleft lscript angbracketright lscript angbracketleftskip angbracketright 958the first execution has trace lscriptjj lscript and the second has trace lscriptkk lscript.
thus indeed l c u angbracketleftc angbracketrightu angbracketleftskip angbracketright .
remark .
.
statements can be viewed as string accepters on words where cacceptsuiff angbracketleftc angbracketrightu angbracketleftskip angbracketright.i f cis balanced then by corollary .
it accepts exactly l c .
sincel c is a regular language this means that balanced statements can be viewed as finite automata.
iv .
c haracterisa tion of deadlock existence here we obtain our main theoretical result the existence of a deadlock in a parallel program amounts to the existence of a certain kind of conflict between individual summaries of its threads called their sets of critical pairs.
roughly speaking a critical pair of a statement cis a pair x lscript such that some execution of cacquires the lock lscriptwhile holding the set of locks x which cannot already include lscript .
our main correctness result is stated as theorem .
.
definition .
.
the set crit c ofcritical pairs of a statement cis defined as crit c angbracketleftu angbracketright lscript v.u lscriptv l c and lscript angbracketleftu angbracketright .
the reason for our language based definition of crit c as opposed to an execution based one is that it turns out to be easy to compute see section v .
the following lemma givesan equivalent formulation in terms of executions.
lemma .
.
letcbe a balanced statement.
we have that x lscript crit c iff there exist statements c prime c prime primeand a lock statelsuch that angbracketleftc angbracketright angbracketleftc prime l angbracketright angbracketleftc prime prime l angbracketright with x l and lscript x. proof.
the direction follows from lemma .
and the direction from lemma .
.
our final and most crucial lemma shows essentially that for balanced statements considerations of reachability on the concurrent transition relation squigglerightcan be reduced to reachability on the sequential relation .
lemma .
.
supposec1 ... cndoes not deadlock.
then angbracketleftc1 ... cn ... angbracketright squiggleright 1 ... niff for each i n we have angbracketleftci angbracketright iwith i j j negationslash i .
proof.
sketch the direction is immediate from remark .
.
for the direction we write i j angbracketleftci j li j angbracketright for thejth configuration in the execution i angbracketleftci angbracketright i. an arbitrary concurrent configuration given by an interleavingfrom these nexecutions is given by i n i ji.
we call such a configuration compatible when i ji k jkfor all k negationslash i and reachable when angbracketleftc1 ... cn ... angbracketright squiggleright i n i ji.
it then suffices to show that if i n i jiis compatible then it is also reachable.
we proceed by induction on j i nji.
the casej is trivial.
otherwise j 0and we consider the compatibility of the preceding configurations k jk i n i negationslash k i ji where k n.w et h e n consider two main subcases.the first subcase is that some k jk i n i negationslash k i jiis compatible.
in that case using the induction hypothesis andthe assumption that i n i jiis compatible we have that i n i jibecomes reachable by applying pari .
the remaining subcase is then that noconfiguration of the form k jk i n i negationslash k i jiis compatible we can assume without loss of generality that these configurations are definedfor the first m 2threads and undefined otherwise.
now letting1 k m we must have l k jk lk jk for some lock lscriptk by the subcase assumption.
by lemma .
we can find hk jksuch that lk hk lk jkandlk hk lk jk .
it follows that k m k hk m i n i ji is also compatible.
thus by the induction hypothesis that k m k hk m i n i jiis reachable.
to conclude the proof we show that k m k hkis deadlocked and thusc1 ... cndeadlocks a contradiction.
if not then k m k hk squiggleright for some via an application of the rule pari .
in that case we can deduce from the lock state information that ci himust begin with the command acq lscripti and soli hi li ji .
thus li ji lk hk k negationslash i .
since lk hk lk jkfor each k this means that i ji k m k negationslash i i jiis compatible which contradicts the subcase assumption and so completesthe proof.
we are now finally in a position to characterise deadlock existence as a conflict condition on the critical pairs of itssequential components.
theorem .
deadlock characterisation .
a parallel program c ... cndeadlocks iff for some i ... n with cardinality there are critical pairs xi lscripti for eachi i such that xi uniontext j negationslash ixj and lscripti uniontext j negationslash ixj.
proof.
case suppose c1 ... cndeadlocks meaning that angbracketleftc1 ... cn ... angbracketright squiggleright and iis deadlocked for some index set i without loss of generality we assume that i ... m and thus i angbracketleftd1 ... dm l1 ... l m angbracketright.
by remark .
we have for each1 i ma sequential execution angbracketleftci angbracketright angbracketleftdi li angbracketright withli lj j negationslash i .
since iis deadlocked and li ljfor alli negationslash j we have angbracketleftdi li angbracketright angbracketleftd prime i li angbracketright with lscripti uniontext j negationslash i lj for all1 i m by proposition .
.
thus we have executions angbracketleftci angbracketright angbracketleftdi li angbracketright angbracketleftd prime i li angbracketright with lscripti li because lscripti uniontext j negationslash i lj andli lj j negationslash i .
by lemma .
we obtain li lscripti crit ci .
taking xi li for eachi all required conditions are satisfied.
case we assume w.l.o.g.
that i ... m where m .
let1 i m using xi lscripti crit ci we have by lemma .
that angbracketleftci angbracketright angbracketleftc prime i li angbracketright angbracketleftc prime prime i li angbracketright and xi li and lscripti xi.
moreover since xi uniontext j negationslash ixj we haveli lj j negationslash i .
now suppose that c1 ... cmdoes not deadlock.
in that case lemma .
yields angbracketleftc1 ... cm ... angbracketright squiggleright angbracketleftc prime ... c prime m l1 ... l m angbracketright and hence the latter configuration cannot be deadlocked.
but because angbracketleftc prime i li angbracketright angbracketleftc prime prime i li angbracketright and lscripti uniontext j negationslash i lj for each i using the assumption that lscripti uniontext j negationslash ixj this configuration actually isdeadlocked by proposition .
.
thus c1 ... cm deadlocks after all a contradiction.
the following example illustrates our deadlock condition.
example .
.
define statements c1 ... c nas follows c1 acq lscript2 acq lscript1 skip rel lscript1 rel lscript2 c2 acq lscript3 acq lscript2 skip rel lscript2 rel lscript3 ... cn acq lscriptn acq lscriptn skip rel lscriptn rel lscriptn cn acq lscript1 acq lscriptn skip rel lscriptn rel lscript1 we have lscript i mod n lscripti crit ci for each1 i n. these critical pairs satisfy the deadlock condition of theorem .
and indeed c1 ... cndeadlocks by executing the first acq command in each thread.
conversely any smaller subset of these threads e.g.
c1 ... cn does not satisfy the deadlock condition and indeed we can observethatc ... cn 1does not deadlock.
v. c omputing critical pairs having established that the existence of a deadlock in a parallel program reduces to a condition over the critical pairsof its threads theorem .
our next order of business is toshow that crit c is in fact computable for any balanced statement c something that is perhaps not immediately obvious from definition .
.
here we establish a set of usefulidentities enabling us to compute crit c inductively with the consequence that the deadlock problem for our languageis decidable and in np theorem .
.
proposition .
.
the following identities hold for all balanced statements c c primeand locks lscript crit skip c1 crit p crit body p c2 crit if thencelsec prime crit c crit c prime c3 crit c c prime crit c crit c prime c4 crit while doc crit c c5 crit acq lscript c rel lscript lscript x lscript lscript prime x lscript prime crit c and lscript negationslash lscript prime c6 proof.
we show each identity directly from definition .
making use of auxiliary lemmas from section iii.
example .
.
we continue example .
where cis the statement acq lscript if then acq j skip rel j else acq k skip rel k rel lscript .
first using equations c1 and c6 we get crit acq j skip rel j j and crit acq k skip rel k k .thus writing c acq lscript c prime rel lscript equation c3 gives us crit c prime j k .
finally applying c6 once again and observing that j k negationslash lscript w eg e t crit c crit acq lscript c prime rel lscript lscript lscript j lscript k lscript lscript j lscript k .
next we undertake a brief complexity analysis.
we write x for the cardinality of a finite set x. definition .
.
f or any statement c define its size bardblc bardblby bardblc bardbl c summationtext p callees c body p where c is defined inductively as follows skip acq lscript rel lscript p if thenc1elsec2 c1 c2 c1 c2 while doc c proposition .
.
crit c is finite and computable for any balanced statement c with crit c bardblc bardbl1 callees c and x bardblc bardblfor all x lscript crit c .i fc does not contain any procedure calls then crit c c .
proof.
by structural induction on c using prop.
.
.
to precisely state complexity bounds on the deadlock problem we define the size of a parallel program as the sum ofthe sizes of its threads bardblc ... cn bardbl summationtext i n bardblci bardbl.
theorem .
.
whether a given parallel program deadlocks or not is decidable and in np.
proof.
we just need to show how to check the deadlock condition of theorem .
in nondeterministic polynomial time.thenp procedure runs in three stages i nondeterministically select an index set i ... n of size ii nondeterministically compute a critical pair x i lscripti for eachi i b y recursing on the structure of ciand using the equations c1 c6 in proposition .
iii verify that xi uniontext j negationslash ixj and lscripti uniontext j negationslash ixjfor alli j i. the last step can be done in polynomial time in bardblp bardblbecause by proposition .
each xi is of size bounded by bardblci bardbl.
remark .
.
an immediate consequence of proposition .
is that for any balanced statement c its critical pairs crit c and size bardblc bardblboth remain unchanged under applications of the following rewrite rules to substatements of c if thenc1elsec2 mapsto c1 c2 and while doc prime mapsto c prime.
therefore the deadlock problem for our language reduces polynomially to the case where statements are restricted tothe deterministic grammar c skip p acq lscript c rel lscript c c. 960vi.
i mplement a tion and impact in this section we describe our implementation of a compositional deadlock analysis tool for code changes in android java applications.
the core of the tool described in sec tion vi a is an abstract interpretation analysis for computingthe critical pairs of a method.
in section vi b we describe ourextension of this core procedure to an interprocedural analysisfor android java code and in section vi c we discuss itsdeployment and impact at facebook.
a. core analysis in abstract interpretation style the core of our implementation is an analysis that computes the critical pairs of a statement in abstract interpretation style.
given any statement c we define an analysis function llbracketc rrbracket onabstract states which track the lock state and the set of critical pairs accumulated during the possible executions of c. definition .
.
an abstract state is a pair angbracketleftl z angbracketright wherel is a lock state and z locks locks .
we define a partial join operation unionsqon abstract states by angbracketleftl z angbracketright unionsq angbracketleftl z angbracketright angbracketleftl z z2 angbracketright.
we often write for abstract states and for the empty abstract state angbracketleft angbracketright.
the function llbracketc rrbracket is then defined by structural induction oncin figure .
the clauses for the control flow statements are generic to abstract interpretation given a suitable joinoperation unionsq which is why we do not simply define e.g.
llbracketwhile doc rrbracket unionsq llbracketc rrbracket as would intuitively be implied by equation c5 .
however this identity and similar ones canbe inferred from our correctness proof.
we draw particular attention to the clause for procedure calls computing the critical pairs of a procedure call p depends only on the current abstract state angbracketleftl z angbracketrightand the critical pairs of the procedure body in the empty state llbracketbody p rrbracket which can be computed once and for all in advance.
this means that our analysis is compositional in that when a procedure is changed we only require to re analysethat procedure and its dependents not the whole program.
proposition .
.
f or any balanced statement cand abstract state angbracketleftl z angbracketright the result llbracketc rrbracket of the analysis is given by angbracketleftl z l x lscript x lscript crit c andl lscript angbracketright.
thus llbracketc rrbracket angbracketleft crit c angbracketright.
moreover llbracketc rrbracket is computable.
proof.
by structural induction on c making use of the equations c1 c6 in proposition .
.
example .
.
continuing example .
statement cis acq lscript if then acq j skip rel j else acq k skip rel k rel lscript .
llbracketacq lscript rrbracket angbracketleftl z angbracketright angbracketleftl z z prime angbracketright wherez prime braceleftbigg l lscript ifl lscript ifl lscript llbracketrel lscript rrbracket angbracketleftl z angbracketright angbracketleftl z angbracketright llbracketp rrbracket angbracketleftl z angbracketright angbracketleftl z z prime angbracketright where angbracketleft z prime prime angbracketright llbracketbody p rrbracket in z prime l m lscript m lscript z prime prime l lscript llbracketskip rrbracket llbracketc1 c2 rrbracket llbracketc2 rrbracket llbracketc1 rrbracket llbracketif thenc1elsec2 rrbracket llbracketc1 rrbracket unionsq llbracketc2 rrbracket llbracketwhile doc rrbracket unionsqtext n llbracketc rrbracketn fig.
.
abstract analysis definition.
writing abbreviations c acq lscript c prime rel lscript andc prime if thenc1elsec2 we have by the clauses for if and for sequential composition in figure llbracketc rrbracket llbracketacq lscript c prime rel lscript rrbracket llbracketc prime rel lscript rrbracket llbracketacq lscript rrbracket llbracketrel lscript rrbracket llbracketc prime rrbracket llbracketacq lscript rrbracket llbracketrel lscript rrbracket llbracketif thenc1elsec2 rrbracket llbracketacq lscript rrbracket llbracketrel lscript rrbracket llbracketc1 rrbracket llbracketacq lscript rrbracket unionsq llbracketc2 rrbracket llbracketacq lscript rrbracket .
this gives us the basic structure of the computation.
next using the rule for acq lscript in figure we have llbracketacq lscript rrbracket llbracketacq lscript rrbracket angbracketleft angbracketright angbracketleft lscript angbracketright.
we write l lscriptfor the lock state sending lock lscriptto and all other locks to .
next we have llbracketc1 rrbracket llbracketacq lscript rrbracket llbracketc1 rrbracket angbracketleftl lscript lscript angbracketright llbracketacq j skip rel j rrbracket angbracketleftl lscript lscript angbracketright llbracketskip rel j rrbracket llbracketacq j rrbracket angbracketleftl lscript lscript angbracketright llbracketrel j rrbracket llbracketskip rrbracket llbracketacq j rrbracket angbracketleftl lscript lscript angbracketright llbracketrel j rrbracket llbracketskip rrbracket angbracketleftl lscript lscript lscript j angbracketright llbracketrel j rrbracket angbracketleftl lscript lscript lscript j angbracketright angbracketleftl lscript lscript lscript j angbracketright angbracketleftl lscript lscript lscript j angbracketright.
and by a similar calculation llbracketc2 rrbracket llbracketacq lscript rrbracket angbracketleftl lscript lscript lscript k angbracketright.
961now using the definition of our abstract join unionsq w eh a v e llbracketc1 rrbracket llbracketacq lscript rrbracket unionsq llbracketc2 rrbracket llbracketacq lscript rrbracket angbracketleftl lscript lscript lscript j angbracketright unionsq angbracketleftl lscript lscript lscript k angbracketright angbracketleftl lscript lscript lscript j lscript k angbracketright.
thus putting everything together we get llbracketc rrbracket llbracketrel lscript rrbracket llbracketc1 rrbracket llbracketacq lscript rrbracket unionsq llbracketc2 rrbracket llbracketacq lscript rrbracket llbracketrel lscript rrbracket angbracketleftl lscript lscript lscript j lscript k angbracketright angbracketleftl lscript lscript lscript j lscript k angbracketright angbracketleft lscript lscript j lscript k angbracketright.
thus recalling our recursive computation of crit c in example .
we can see that indeed llbracketc rrbracket angbracketleft crit c angbracketright.
lemma .
.
given a balanced statement c the computation llbracketc rrbracket requires at most quasi exponential time in bardblc bardbl.i fc does not contain any procedure calls the computation requires at most quadratic time in c .
proof.
follows from the fact that the computation of llbracketc rrbracket is linear in the size of crit c its result and the bounds on crit c given by proposition .
.
theorem .
.
the problem of checking whether a parallel program p c1 ... cndeadlocks can be solved in time exponential in bardblp bardblandn.
if the program does not contain any procedure calls checking for deadlocks can be solved intime polynomial in bardblp bardbland exponential in n. proof.
computing crit c ... crit cn can be performed in exponential time in bardblp bardbl by lemma .
and they contain at most exponentially many critical pairs byproposition .
.
then checking the deadlock condition oftheorem .
over all possible index sets i can be performed within a time bound exponential in bardblp bardblandn.i fp does not contain any procedure calls then lemma .
and prop.
.4instead yield a time bound polynomial in bardblp bardbl but still exponential in n .
b. analysing android java code changes the requirement that the analysis targets code changes leads to a number of design constraints chief amongst which is thatthe analysis does not have the runtime envelope to analysethe whole program at hand thus the analysis must work byanalysing a modest superset of the modified code in a commit.such a constraint can be problematic in looking for concur rency bugs due to their global nature.
we note here techniquesfor addressing those difficulties as well as differences betweenimplementation and theory.
we also outline features specific toandroid java which we leverage in our analysis cf.
paragraphsonnon deterministic control and concurrency inference .
balanced locking.
the correctness of our analysis relies on balanced locking.
as a general rule this is good programmingpractice supported in java via the synchronized keyword and we have found very few instances of unbalanced lockingin the codebases targeted by our tool.
this means that analysisprecision does not suffer and that no changes to the analysisare needed and is one reason we opted for a balanced lockinglanguage model in the first place the other reason beingdecidability .
it is of course quite possible that unbalancedlocking might well be more prevalent in other domains butthat is a matter of speculation.
incidentally our analyseractually will return a result when run on non balanced code but its correctness is not then guaranteed.
non deterministic control.
control in java is mostly deterministic so our abstract semantics is over approximate.
in early trials of the tool the majority of false positiveswe observed in practice stemmed from insensitivity to twoconditions firstly whether a lock acquisition succeeded e.g.
vialock.trylock and secondly whether the current thread is the ui thread.
therefore we specialised the imple mentation domain to introduce partial path sensitivity on theseconditions this eliminated most of the false positives due tocontrol abstraction.
lock names.
the set locks must approximate the set of java objects that can be used as monitors.
rather than use an expensive and typically whole program which wouldrun against our main design constraint pointer analysis weuse access paths syntactic expressions built with a program variable root and iteration of field or array dereferencing .
for example this.f.g represents an object accessed through dereferencing the field fof the object this.
such a domain of abstract addresses has several trade offs withrespect to false positives and negatives but that is beyondthe scope of this paper.
we also classify objects into globally referenced or objects referenced through method parameters.
objects referencedthrough local variables are ignored.
for globally referencedobjects the rule for method calls in figure applies un changed.
for parameter referenced objects we apply a substi tution of argument expressions over parameters on the calleesummary before applying the procedure call rule.
for instance if the summary of method foo x involves the lock x.f then applying the procedure call rule on foo h.g will result in the substitution and the resulting critical pair at the callsite will involve the monitor h.g.f.
concurrency inference.
since whole program analysis is impracticable in our setting we cannot always observe thespawning of execution threads for these may happen inmethods that are unmodified and unrelated via the call graph.as such we use an abstract domain for thread identity whereeach method can be of unknown identity the ui thread some background thread or both it may be executed on theui thread as well as background threads .
we extract thisinformation from a thread annotations in android code suchas uithread and workerthread b android method calls that test whether the current thread is the ui thread c upward propagation through the call graph.
every criticalpair in a method summary is decorated with the inferred threadidentity and this information is used to determine whether 962fig.
.
analysis report on textbook deadlock across two java classes.
two critical pairs can occur concurrently two ui thread pairs cannot be concurrent though any other combination can .
detecting deadlocks non globally.
as the analysis targets code changes it begins by summarising all methods in the set of changed files in a commit.
by the procedure callrule this leads to analysing all methods transitively calledby the modified files.
if we restrict deadlock detection tothis set of summaries we will miss deadlocks due to lockacquisitions performed by methods outside the call graphrooted in modified files.
thus the analysis selects additionalmethods to summarise using the following heuristic.
for every method msummarised and every critical pair of the form l root.f .....fn in the summary of m where root is of class c all methods of class care also analysed in search of a critical pair l prime lscript prime where root.f .....fn l prime .
the analyser continues this process until the set of analysedmethods reaches a fixpoint.
this heuristic works well when certain java idioms are observed namely when the monitors used are the this object for example in synchronized methods or they are immutable private objects stored in object fields.
for instance this heuristic will catch the deadlock between classes aand bin figure where we also illustrate a sample report to developers even in a commit where only a.foo is modified.
it s worth noting that our heuristic admits false negatives e.g.
when global locks are acquired in methods that residein classes not containing the globals.
however in the code weusually analyse global locks are significantly less commonlyused than non global objects.
c. industrial deployment and impact our flow sensitive context insensitive analysis is implemented in ocaml around 3kloc within the i nfer static analysis framework and is specifically targeted at detecting thread deadlocks in code changes commits ofandroid apps within a continuous integration environment ci .
deployment.
infer is deployed at facebook through a ci system which launches an analysis job whenever a commit is submitted for code review.
this job concurrently runs multipleanalysers on the submitted code changes and appears to theauthors of the commit as yet another reviewer commentingon the code based on the potential bugs found.
the deadlock analysis has been deployed on all android code commits atfacebook for about two years.
fixed reports.
in a non safety critical context such as facebook an analysis engineer s time is better spent developing analysis features than triaging reports for false positives.
thus we track fixed reports reports that code authors addressedby submitting a new version of a commit rather than truepositives.
since it was deployed the deadlock analyser has processed hundreds of thousands of commits has issued morethan deadlock reports with a fix rate of .
as for the of non fixed reports these fall into three broad categories.
first true positives that were in fact fixedby the developer but not picked up by our fix tracking e.g.because the bug was fixed in a new commit rather than a newversion of an existing commit .
second true positives that thedeveloper decided not to address e.g.
because the bug wouldoccur only in very rare circumstances .
third false positives e.g.
because the tool reports a deadlock between two methodsthat will never in fact be run concurrently .
unfortunately wehave absolutely no way of knowing how many reports fall intoeach of these categories.
analysis performance.
the architecture of i nfer means peranalyser runtime is not recorded.
for this reason we report only the total analysis time including various other analysers which provides an upper bound for our analysis.
runtime for all analysers in the last days to submission had a medianof seconds and an average of seconds per commit.
inthe same time period i nfer analysed a median of 2k methods and on average 5k methods per commit.
vii.
r ela ted work in this section we compare our contribution to related work first on theoretical deadlock detection results basedon automata and second on automated deadlock detectiontools.
we note that such tools are naturally classified as eitherdynamic static or hybrid depending on whether they oper ate primarily on program executions program text or both.analysers that target java programs typically rely on balancedlocking and must accurately model re entrant locks whereasanalysers for c code do not expect balanced locking andassume non reentrant locks.
in addition deadlock analyserscan be categorised according to whether they detect deadlocksinvolving only two threads or more and whether they producefalse positives on guarded cycles.
963a.
automata theoretical deadlock detection there is a substantial body of work on the literature on analysing general safety and liveness properties for communicating systems of pushdown automata e.g.
.
our abstract concurrentprograms fall under this general umbrella since as we havealready observed cf.
remark .
they can be seen ascollections of finite automata that synchronise via their sharedlocks.
indeed our model can be polynomially encoded as acommunicating pushdown system as considered e.g.
in .however while arbitrary dataflow properties of even two threaded pushdown systems are undecidable in general our deadlock problem is decidable and thus represents aspecial case which relies crucially on the fact that lockingin our language is balanced.
the papers in this area most directly relevant to our own work are probably and which both consider comuu nicating pushdown systems in which locks are also balanced there nested .
in particular reports decidability of thedeadlocking problem for such systems based on a cycle checking condition in a graph obtained by augmenting theautomaton with lock acquisition histories.
this condition issomewhat similar to though arguably more complicated than our condition based on critical pairs and the central theoreticalresult on which it relies theorem has the same essentialflavour as our similarly crucial lemma .
although thetechnical machinery is quite different.
in this result isstrengthened to the decidability of any ltl property of com municating nested lock pushdown systems in exponential timein the number of locks.
while these papers do not explicitlytreat reentrant locks it is shown in that reentrant locks canbe modelled in such systems using only non reentrant locks so this is not a serious point of difference.
thus although our deadlock characterisation result theorem .
is new in itself it probably could have alternatively been arrived at via a combination of the results in and by encoding our language as a communicatingnested lock pushdown system.
however such an approachwould almost certainly be messy unsatisfying and no lesswork than our own proof.
compared to these works thenovelties of our approach are as follows we characterisedeadlocks in a simple concurrent programming languagerather than a system of communicating automata our deadlockcondition based on critical pairs is simpler than the automata theoretic condition and we give a proof for this setting that isentirely direct self contained and we believe quite elegant.
in a different direction it is also worth mentioning and .
these both aim at deadlock avoidance rather than detection in a concurrent functional language with re entrantlocks by developing a type system for the language such thattypable expressions are guaranteed not to deadlock.
whilethe earlier requires locks to be balanced lifts thisrestriction and provides a prototype implementation.b.
static analyses static deadlock detectors typically require a complete program in order to run.
most are focused on soundness wherethe absence of reports implies deadlock freedom.
all analysesdiscussed are interprocedural top down context sensitive andtypically non compositional.
r acer x is a path insensitive analysis for c programs which does not use a pointer analysis instead using syntacticinformation and types about variables ignoring locks in localvariables.
heavy use of caching transfer functions on state ments is made to improve runtimes due to context sensitivity.the search for cycles is up to a user specified number ofthreads.
many heuristics and techniques are employed toreduce false positive reports.
reports on a java analysis which targets libraries thus partly dealing with the problem of identifying programentrypoints.
as such the analysis cannot see global aliasinginformation and uses a coarse type based memory domain.it can detect cycles of more than two threads up to a pre specified bound.
the pure analysis reports too many falsepositives therefore several unsound heuristics are used.
j ade is a path insensitive java analysis which breaks down the problem into several sub analyses including reach ability aliasing escaping reentrancy and guarded ness.
it fo cuses on two thread deadlocks and has explicit mechanismsfor rejecting guarded deadlock reports.
it is expressed indatalog and uses an iterative refinement scheme to increaseprecision where the degree of sensitivity is increased basedon the reports found in the last iteration.
reports on an analysis for an abstract language which reduces detection of deadlocks into race detection.
a typesystem captures lock dependencies and the inferred types areused to detect program points where a nested lock acquisitionmay occur.
these points are instrumented with code mutating race variables.
a data race detector then finds possibledeadlocks.
too many false positives are reported for deadlocksamong more than two threads and additional checks aremade to improve precision and to filter guarded cycles.
noimplementation is reported.
t hread safe is a commercial flow and path sensitive per class analysis for java.
little detail is reported on thefoundations of the analysis.
it uses as entry points the publicmethods of each class or modelled android lifecycle methods.only calls to private and protected methods are followed.
reports on an analysis targeting c code with posix threads.
it infers concurrency on spawn join points throughthe program graph and contexts represent call and thread creation sites.
a must lock analysis is employed to deal withguarded locks.
function pointer calls are inlined into casedistinctions over the calls they might resolve to.
j ada is a java bytecode analysis that uses behavioural type rules to compositionally extract an infinite state abstractmodel from bytecode.
this model is then analysed using acontext sensitive fixpoint computation generating reports ofcyclic dependencies.
the main strength of the approach seems 964to be the ability to analyse recursive functions that spawn an unbounded number of threads.
c. dynamic and hybrid analyses analyses that work with program traces usually require the whole program as well as appropriate test input and tend to be focused on completeness most reports are true positives .
good lock is an analysis for java programs implemented in java pathfinder jpf which maintains a lock tree for each execution thread where each node representsthe lifetime of a lock acquisition and children nodes representacquisitions wholly contained within the parent.
a warningis reported whenever two threads have lock trees which mayrequest the same pair of locks in opposite orders.
since thewhole lock tree is available gate locks can be detected and thewarning suppressed.
m agic fuzzer m agic lock undead and a irlock all adopt and improve on this basic approach by applying various optimisations to theextracted lock order graph with u ndead also attempting to keep traces in memory rather than external storage as faras possible and a irlock operating on the fly running a polynomial time algorithm on the lock graph to eliminate partswith no cycles before running the higher cost algorithm todetect actual lock cycles.
describes an analysis for java programs also implemented in jpf that constructs a lock order graph from anexecution trace of an instrumented program.
although thegraph edges denote dependencies between only a pair of locks they are also labelled by the complete lock set and the threadacquiring the lock.
these labels are used to detect deadlocksbetween more than two threads and to filter out gated cycles.
presents a sound type inference mechanism for types that ensure deadlock freedom for java programs.
appropriateinstrumentation for the untyped parts of the program is thenused to feed an extension of the g ood lock algorithm to the unbounded thread case yielding a hybrid analysis.
furtherfiltering is then used to exclude gated cycles.
s herlock is an analysis for java programs which uses g ood lock to get a set of deadlock candidates.
the program is run on given inputs producing an initial schedulewhich is then concolically executed and permuted in repeatedsteps in search of witnessing schedules.
the g ood lock based algorithm can deal with more than two threads and theoriginal version can deal with gated cycles.
viii.
c onclusions and future work in this paper we provide a highly scalable open source deadlock analyser for android java based on a sound andcomplete deadlock analysis in np for an abstract concurrent programming language.
our deadlock analyser has been de ployed at facebook as part of the i nfer framework for the last two years and has resulted in hundred of potential bugsbeing flagged with an actual developer fix rate of over and we note that this does not imply a false positive rate ofnearly50 .
the abstract programming language on which the analysis is based contains balanced or nested reentrant locks nondeterministic control flow commands and nonrecursiveprocedure calls but with all other features in particularvariable assignment abstracted away.
an abstraction ofthis sort is of course necessary to obtain decidability forfundamental computability reasons.
however our overapprox imation of real concurrent programs turns out to be sufficientlyfaithful to detect deadlock bugs in practice and sufficientlyscalable to run on commercial android applications.
it is natural to wonder whether and how our abstract language might be extended while preserving the decidabilityof deadlock existence.
unfortunately it seems to us thatalmost any nontrivial extension presents significant obsta cles.
for example allowing procedure calls to be recursivecauses problems for our approach since it is then possible tocreate statements with infinite non balanced traces e.g.
bythe procedure definition p acq lscript p rel lscript a second difficulty is that we also cannot straightforwardly reason byinduction over the structure of statements.
allowing controlflow to be deterministic e.g.
by allowing guards to query thelock state is similarly problematic since the critical pairs ofa statement are then dependent on the lock state in whichit is executed meaning that at the very least we wouldrequire a finer abstraction in order to avoid false positives.finally modelling forking and joining by allowing parallelcompositions to appear nested within statements makes theproblem much more complicated since conceptually it wouldrequire that we construct abstractions of all subthreads as wellas determining which of them can run in parallel with eachother.
we nevertheless consider these and other extensionsto be interesting potential directions for future work.
it wouldalso be nice to establish a lower complexity bound on ourdeadlock problem we speculate that the problem is likely npcomplete but unfortunately we have so far failed to find asuitable reduction.
r eferences facebook i nfer static analysis framework.
r. agarwal l. wang and s. d. stoller detecting potential deadlocks with static analysis and run time monitoring in hardware and software v erification and testing.
springer pp.
.
r. atkey and d. sannella threadsafe static analysis for java concurrency eceasst vol.
.
s. bensalem and k. havelund dynamic deadlock analysis of multithreaded programs in hardware and software v erification and testing.
springer pp.
.
a. bouajjani j. esparza and t. touili a generic approach to the static analysis of concurrent programs with procedures in proceedings of popl .
acm p. .
g. boudol a deadlock free semantics for shared memory concurrency inproceedings of ictac .
springer pp.
.
y .
cai and w. chan magicfuzzer scalable deadlock detection for large scale applications in proceedings of icse .
acm pp.
.
magiclock scalable detection of potential deadlocks in largescale multithreaded programs ieee transactions on software engineering vol.
no.
pp.
.
y .
cai r. meng and j. palsberg low overhead deadlock prediction inproceedings of icse .
acm pp.
.
e. dijkstra hierarchical ordering of sequential processes acta informatica vol.
no.
pp.
.
d. distefano m. f hndrich f. logozzo and p .
w. o hearn scaling static analyses at facebook comm.
acm vol.
no.
p. jul.
.
d. engler and k. ashcraft racerx effective static detection of race conditions and deadlocks in proceedings of sosp .
acm p. .
m. eslamimehr and j. palsberg sherlock scalable deadlock detection for concurrent programs in proceedings of fse .
acm p. .
j. esparza p .
ganty and r. majumdar parameterized verification of asynchronous shared memory systems in proceedings of ca v. springer pp.
.
a. farzan and z. kincaid compositional bitvector analysis for concurrent programs with nested locks in proceedings of sas .
springer pp.
.
p .
gerakios n. papaspyrou and k. sagonas a type and effect system for deadlock avoidance in low level languages in proceedings of tldi7.
acm pp.
.
m. hague parameterised pushdown systems with non atomic writes lipics vol.
.
k. havelund using runtime analysis to guide model checking of java programs in spin model checking and software v erification.
springer pp.
.
k. havelund and t. pressburger model checking java programs using java pathfinder international journal on software tools for technology transfer vol.
no.
pp.
.
a. heu ner j. leroux a. muscholl and g. sutre reachability analysis of communicating pushdown systems in proceedings of f ossacs.
springer pp.
.
j. e. hopcroft and j. d. ullman f ormal languages and their relation to automata.
addison wesley jan. .
n. d. jones and s. s. muchnick flow analysis and optimization of lisplike structures in proceedings of popl .
acm p. .
v .
kahlon boundedness vs. unboundedness of lock chains characterizing decidability of pairwise cfl reachability for threads communicating via locks in proceedings of lics .
ieee pp.
.
v .
kahlon and a. gupta an automata theoretic approach for model checking threads for ltl properties in proceedings of lics .
ieee pp.
.
v .
kahlon f. ivancic and a. gupta reasoning about threads communicating via locks in proceedings of ca v .
springer pp.
.
n. kidd a. lal and t. reps language strength reduction in proceedings of sas .
springer pp.
.
d. kroening d. poetzl p .
schrammel and b. wachter sound static deadlock analysis for c pthreads in proceedings of ase pp.
.
c. laneve and a. garcia deadlock detection of java bytecode in logic based program synthesis and transformation.
springer pp.
.
m. naik c. s. park k. sen and d. gay effective static deadlock detection in proceedings of icse .
ieee computer society p. .
k. i. pun m. steffen and v .
stolz deadlock checking by data race detection journal of logical and algebraic methods in programming vol.
no.
pp.
the 24th nordic workshop onprogramming theory nwpt .
g. ramalingam context sensitive synchronization sensitive analysis is undecidable acm trans.
program.
lang.
syst.
vol.
no.
p. .
a. williams w. thies and m. d. ernst static deadlock detection for java libraries in ecoop object oriented programming a .p .
black ed.
springer pp.
.
j. zhou s. silvestro h. liu y .
cai and t. liu undead detecting and preventing deadlocks in production software in proceedings of ase .
acm pp.
.
w. zielonka notes on finite asynchronous automata rairo theoretical informatics and applications vol.
no.
pp.
.