gentree using decision trees to learn interactions for configurable software kimhao nguyen and thanhvu nguyen university of nebraska lincoln usa fkdnguyen tnguyeng cse.unl.edu abstract modern software systems are increasingly designed to be highly configurable which increases flexibility but can make programs harder to develop test and analyze e.g.
how configuration options are set to reach certain locations what characterizes the configuration space of an interesting or buggy program behavior?
we introduce gentree a new dynamic analysis that automatically learns a program s interactions logical formulae that describe how configuration option settings map to code coverage.
gentree uses an iterative refinement approach that runs the program under a small sample of configurations to obtain coverage data uses a custom classifying algorithm on these data to build decision trees representing interaction candidates and then analyzes the trees to generate new configurations to further refine the trees and interactions in the next iteration.
our experiments on configurable systems spanning languages show that gentree efficiently finds precise interactions using a tiny fraction of the configuration space.
i. i ntroduction modern software systems are increasingly designed to be configurable.
this has many benefits but also significantly complicates tasks such as testing debugging and analysis due to the number of configurations that can be exponentially large in the worst case every combination of option settings can lead to a distinct behavior.
this software configuration space explosion presents real challenges to software developers.
it makes testing and debugging more difficult as faults are often visible under only specific combinations of configuration options.
it also causes a challenge to static analyses because configurable systems often have huge configuration spaces and use libraries and native code that are difficult to reason about.
existing works on highly configurable systems showed that we can automatically find interactions to concisely describe the configuration space of the system.
these works focus on program coverage but can be generalized to arbitrary program behaviors and define an interaction for a location as a logically weakest formula over configuration options such that any configuration satisfying that formula would cover that location.
these works showed that interactions are useful to understand the configurations of the system e.g.
determine what configuration settings cover a given location determine what locations a given interaction covers find important options and compute a minimal set of configurations to achieve certain coverage etc.
in the software production line community feature interactions and presence conditions vii are similar to interactions and has led to many automated configuration aware testing techniques todebug functional e.g.
bug triggers memory leaks and nonfunctional e.g.
performance anomalies power consumption behaviors.
interactions also help reverse engineering and impact analysis and even in the bioinformatics systems for aligning and analyzing dna sequences .
these interaction techniques are promising but have several limitations.
the symbolic execution work in does not scale to large systems even when being restricted to configuration options with a small number of values e.g.
boolean needs user supplied models mocks to represent libraries frameworks and native code and is language specific c programs .
itree uses decision trees to generate configurations to maximize coverage but achieves very few and imprecise interactions.
both of these works only focus on interactions that can be represented as purely conjunctive formulae.
the igen interaction work adopts the iterative refinement approach often used to find program preconditions and invariants e.g.
.
this approach learns candidate invariants from program execution traces and uses an oracle e.g.
a static checker to check the candidates.
when the candidate invariants are incorrect the oracle returns counterexample traces that the dynamic inference engine can use to infer more accurate invariants.
igen adapts this iterative algorithm to finding interactions but avoids static checking which has limitations similar to symbolic execution as mentioned above.
instead igen modifies certain parts of the candidate interaction to generate new configurations and run them to test the candidate.
configurations that break the interaction are counterexamples used to improve that interaction in the next iteration.
however to effectively test interactions and generate counterexample configurations igen is restricted to learning interactions under specific forms purely conjunctive purely disjunctive and specific mixtures of the two and thus cannot capture complex interactions in real world systems vi .
in this paper we introduce gentree a new dynamic interaction inference technique inspired by the iterative invariant refinement algorithm and igen.
figure gives an overview of gentree.
first gentree creates an initial set of configurations and runs the program to obtain location coverage.
then for each covered location l gentree builds a decision tree which represents a candidate interaction from the configurations that do and do not cover l. because gentree works with just a sample of all configurations the decision trees representing candidate interactions may be imprecise.
to refine these trees gentree analyzes ieee acm 43rd international conference on software engineering icse .
ieee program and testsuiteconfigs finalinteractionsno1 waycovering arraynew trees ?postprocessingcoverageclassifierrun programyesgen new configsfig.
gentree overview configuration options s t u v bool a b c d e2f0 2g printf l0nn true if a 1 b f printf l1nn a 1 b g else if c d f a2f0 2g b2f0 1g c d printf l2nn g if u v f printf l3nn u v return g elsef printf l4nn u vif s e f s e u v printf l5nn return g g s e2f0 1g u v printf l6nn if e f s e u v printf l7nn if u v f s e u v u v printf l8nn g g fig.
a program having nine locations l0 l8annotated with interactions them to generate new configurations.
in the next iteration these configurations may provide the necessary data to invalidate the current trees i.e.
counterexamples and build more precise trees which correspond to better interactions.
this process continues until we obtain no new coverage or trees for several consecutive iterations at which point gentree returns the final set of interactions.
the design of gentree helps mitigate several limitations of existing works.
by using dynamic analysis gentree is language agnostic and supports complex programs e.g.
those using third party libraries that might be difficult for static analyses.
by considering only small configuration samples gentree is efficient and scales well to large programs.
by integrating with iterative refinement gentree generates small sets of useful configurations to gradually improve its results.
by using decision trees gentree supports expressive interactions representing arbitrary boolean formulae and allows for generating effective counterexample configurations.
finally by using a classification algorithm customized for interactions gentree can build trees from small data samples to represent accurate interactions.
we evaluated gentree on programs in c python perl and ocaml having configuration spaces containing to 1014configurations.
we found that interaction results from gentree are precise i.e.
similar to what gentree would produce if it inferred interactions from all possible configurations.
we also found that gentree scales well to programs with many options because it only explores a small fraction of the large configuration spaces.
we examined gentree s results and found that they confirmed several observations made by prior work e.g.
conjunctive interactions are common but disjunctive and mixed interactions are still important for coverage and enabling options which must be set in a certain way to cover most locations are common .
we also observed that complex interactions supported bygentree but not from prior works cover a non trivial number of locations and are critical to understand the programbehaviors at these locations.
in summary this paper makes the following contributions i we introduce a new iterative refinement algorithm that uses decision trees to represent and refine program interactions ii we present a decision tree classification algorithm optimized for interaction discovery iii we implement these ideas in the gentree tool and make it freely available and iv we evaluategentree on programs written in various languages and analyze its results to find interesting configuration properties.
gentree and all benchmark data are available at .
ii.
i llustration we use the c program in figure to explain gentree .
this program has nine configuration options listed on the first line of the figure.
the four options s t u v are booleanvalued and the other five options a b c d e range over the setf0 2g.
the configuration space of this program thus has possible configurations.
the code in figure includes print statements that mark nine locations l0 l8.
at each location we list the associated desired interaction.
for example l5is covered by any configuration in which sistrue eis and either uorvis false.l0is covered by every configuration i.e.
having the interaction true butl6isnotcovered by every configuration because the program returns when it reaches l3orl5.
prior interaction inference approaches are not sufficient for this example.
the works of reisner et.
al and itree only support conjunctions and therefore cannot generate the correct interactions for any locations except l0 l2 andl3.
the igen tool which supports conjunctions disjunctions and a limited form of both conjunctions and disjunctions also cannot generate the interactions for locations l6andl8.
initial configurations gentree first creates a random way covering array to obtain a set of initial configurations which contains all possible settings of each individual option.
figure shows the initial configurations and their coverage information for the running example.
1599config s t u v a b c d e cov l c1 c2 c3 sh a m b fig.
initial configurations using way covering array and the decision tree for l8built from these configurations.
the label at the leaf e.g.
h a indicates the classification hit or miss of the path from the root to this leaf the name of the path and the number of configurations used for this classification config s t u v a b c d e cov l c4 c5 c6 c7 uem a 2m b 2m c 1vh d 1h e fig.
new configurations created from path a in the tree in figure counterexamples are underlined and new decision tree forl8.
config s t u v a b c d e cov l path in fig.
c8 c c9 c c10 c c11 d c12 d c13 d c14 e c15 e c16 e vem a 1m b 1m c 2uh d 1sm g h e 3um f fig.
new configurations created from paths c d e in the tree in figure and new decision tree for l8.
decision trees for each covered location l gentree uses a classification algorithm called c5 i developed specifically for this work iv b to build a decision tree representing the interaction for l. to build the tree for l c5 iuses two sets of data the hitsets consisting of configurations covering land the miss set consisting of configurations not covering l. for example for l8 gentree builds the decision tree in figure from the hit sets fc2gand the miss setfc1 c3g.
from the given configurations c5 idetermines that the coverage of l8just requires option sbeing false .
thus the interaction for l8 represented by the condition of the hitpath a of the tree in figure is s. this interaction is quite different than s e u v u v the desired interaction for l8.
however even with only three initial configurations the tree is partially correct because configurations having sas true would miss l8andsbeing false is part of the requirements for hitting l8.
new configurations gentree now attempts to create new configurations to refine the tree representing the interaction for location l. observe that if a hit path is precise then any configuration satisfying its condition would cover l similarly any configuration satisfying the condition of a miss path would not cover l .
thus we can validate a path by generating configurations satisfying its condition and checking their coverage.
configurations generated from a hit or miss path that do not or do cover larecounterexample configurations which show the imprecision of the path condition and help build a more precise tree in the next iteration.
in the running example gentree selects the condition s of the hit path a of the tree shown in figure and generates four new configurations shown in figure with s and covering values for the other eight variables.
if path a is precise then these configurations would cover l8.
however only configuration c7coversl8.
thus c4 c5 c6 which do not coverl8 are counterexamples showing that path a is imprecise and thus sis not the correct interaction for l8.
note that we could also generate new configurations using path b which represents the interaction for notcoveringl8.
however gentree prefers path a because the classifier uses one configuration for path a and two for path b i.e.
the condition sfor covering lis only supported by one configuration and thus is likely more imprecise.
1600next iterations gentree now repeats the process of building trees and generating new configurations.
continuing with our example on finding the interaction for l8 gentree addsc7to the hit set and c4 c5 c6to the miss set and builds the new tree for l8in figure .
the combination of the hit paths d and e gives e u u v as the interaction forl8.
this interaction contains options e u v which appear in the desired interaction s e u v u v .
to validate the new interaction for l8 gentree generates new configurations from paths c d e of the tree in figure because they have the fewest number of supporting configurations.
figure shows the nine new configurations.
note that c is a miss path and thus c8 c9 c10arenot counterexamples because they do not hit l8.
also in an actual run gentree would select only one of these three paths and take two additional iterations to obtain these configurations.
for illustration purposes we combine these iterations and show the generated configurations all together.
in the next iteration using the new configurations and the previous ones gentree builds the decision tree in figure forl8.
the interaction obtained from the two hit paths d and e is s e v u v u which is equivalent to the desired one and thus would remain unchanged regardless of any additional configurations gentree might create.
finally gentree stops when it cannot generate new coverage or refine existing trees for several consecutive iterations.
in a postprocessing step gentree combines the hit path conditions of the decision tree for each location linto a logical formula representing the interaction for l. complete run gentree found the correct interactions for all locations in the running example within eight iterations and under a second.
the table below shows the number of iterations and configurations used to find the interaction for each location.
for example the desired interaction for l8 took configurations and is discovered at iteration and the interaction true of l0 was quickly discovered from the initial configurations.
l0 l1 l2 l3 l4 l5 l6 l7 l8 iter.
found configs overall gentree found all of these interactions by analyzing approximately configurations median over runs out of possible ones.
the experiments in vi show that gentree analyzes an even smaller fraction of the possible configurations on programs with larger configuration spaces.
iii.
p reliminaries a configurable software consists of multiple configuration options where each option plays a similar role as a global program variable but often has a finite domain e.g.
boolean and does not change during program execution.
a configuration is a set of settings of the form x v wherexis a configuration option and vis a valid value of x.a interactions an interaction for a location lcharacterizes of the set of configurations covering l. for example we see from figure that any configuration satisfying u v i.e.
they have the settings u 1andv is guaranteed to cover l3.
although we focus on location coverage interaction can be associated with more general program behaviors e.g.
we could use an interaction to characterize configurations triggering some undesirable behavior.
to obtain coverage we typically run the program using a configuration and a test suite which is a set of fixed environment data or options to run the program on e.g.
the test suite for the unix ls listing command might consist of directories to run lson.
in summary we define program interactions as definition iii.
.
given a program p a test suite t and a coverage criterion x e.g.
some location lor behavior b an interaction forxis a formula over the initial settings of the configuration options of psuch that a any configuration satisfying is guaranteed to cover xundertand b is the logically weakest such formula i.e.
if also describes configurations covering xthen .
b decision trees we use a decision tree to represent the interaction for a location l. a decision tree consists of a root leaves and internal non leaf nodes.
each non leaf node is labeled with a configuration option and has koutgoing edges which correspond to the kpossible values of the option.
each leaf is labeled with a hit or miss class which represents the classification of that leaf.
the path from the root to a leaf represents a condition leading to the classification of the leaf.
this path condition is the conjunction of the settings collected along that path.
the union disjunction of the hit conditions is the interaction for l. dually the disjunction of the miss conditions is the condition for not covering l. the length of a path is the number of edges in the path.
for illustration purposes we annotate each leaf with a label t a k wheretis either the h hit or m miss class ais the path name so that we can refer to the path and kis the number of supporting configurations used to classify this path.
intuitively the more supporting configurations a path has the higher confidence we have about its classification.
for example the decision tree in figure for location l8 consists of four internal nodes and seven leaves.
the tree has five miss and two hit paths e.g.
path d which has length and condition s e v u is classified as a hit due to one configuration hitting l8 c2in figure and g is a miss path with condition sbecause seven configurations satisfying this condition miss l8.
the interaction for l8is s e v u v u the disjunction of the two hit conditions.
iv.
t hege ntr e e algorithm figure shows the gentree algorithm which takes as input a program a test suite and an optional set of initial configurations and returns a set of interactions for locations in the program that were covered.
initial configurations e.g.
default or factory installed configurations if available are useful starting points because they often give high coverage.
1601input program p test suite t initial configs i optional output a set of interactions of p 1configs i oneway covering configs 2cov run p t configs 3trees 4explore iters 5while explore iters max explore iters do explore iters explore iters explore mode explore iters foreach location l2cov do hits hit cov l misses miss cov l need rebuild is null trees test tree trees hits misses ifneed rebuild explore mode then ifneed rebuild then explore iters trees build tree hits misses paths select ranked paths trees ifexplore mode then paths paths select random paths trees configs gen new configs paths cov cov run p t configs 21interactions post process trees 22return interactions fig.
gentree s iterative refinement algorithm gentree starts by creating a set of configurations using a randomly generated covering array and the initial configurations if they are available.
gentree then runs the program onconfigs using the test suite and obtain their coverage.
next gentree enters a loop that iteratively builds a decision tree for each covered location iv b and generates new configurations from these trees iv a in order to refine them.
gentree has two modes exploit andexplore .
it starts in exploit mode and refines incorrect trees in each iteration.
when gentree can no longer refine trees e.g.
it is stuck in some plateau it switches to explore mode and generates random configurations hoping that these could help improve the trees and if so gentree switches back to exploit mode in the next iteration .
for each covered location l gentree performs the following steps.
first we create hit and miss sets consisting of configurations hitting or missing l respectively.
second if gentree is inexploit mode we build a decision tree for l from the hit and miss sets of configurations if either lis a new location a tree for ldoes not exist or that the existing tree for lis not correct the test tree function checks if the tree fails to classify some configurations .
if both of these are not true i.e.
the existing tree for lis correct we continue to the next location.
otherwise if gentree is inexplore mode we continue to the next step.
third we rank and select paths in the tree that are likely incorrect to refine them.
if gentree is inexplore mode we also select random paths.
finally uem a 2m b 2m c 1vh d 1h e 20120101s t u v a b c d e fig.
a decision tree and new configurations created from path c of the tree we generate new configurations using the selected paths and obtain their coverage.
gentree uses these configurations to validate and refine the decision tree for lin the next iteration.
gentree repeats these steps until existing trees remain the same and no new trees are generated i.e.
no new coverage for several iterations.
in the end gentree uses a postprocessing step to extract logical formulae from generated trees to represent program interactions.
a. selecting paths and generating configurations given a decision tree gentree ranks paths in the tree and generates new configurations from high ranked ones.
intuitively we use configurations generated from a path to validate that path condition which represents an interaction.
if these configurations do not violate the path condition we gain confidence in the corresponding interaction.
otherwise these configurations are counterexamples that are subsequently used to learn a new tree with more accurate paths.
a selecting paths to select paths to generate new configurations gentree favors those with fewer supporting configurations because such paths are likely inaccurate and thus generating counterexample configurations to break them is likely easier.
if there are multiple paths with a similar number of supporting configurations we break ties by choosing the longest ones.
paths with few supporting configurations but involving many options are likely more fragile and inaccurate.
if there are multiple paths with a similar length and number of supporting configurations we pick one arbitrary.
for example paths c and d in the tree shown in figure have the highest rank because they each have just one supporting configuration.
paths a b and e have two configurations each but path e is longer and thus ranked higher.
the final ranking for this tree is then c d e a and b .
b generating configurations from the highest ranked path gentree generates covering configurations that satisfy the path condition i.e.
these configurations have the same settings as those in the condition of that path.
gentree keeps generating new configurations this way for the next highestranked paths until it achieves up to a certain number of new configurations currently configured to generate at least two new configurations .
1602tsm a 10m b 5h d 1zm g 1m c 1h f 1h e a m a b tsm a 101m b 5h c c fig.
ideal tree a and c5.
trees b c using high ranked paths to generate configurations is a greedy approach which might not always give useful configurations that help improve the tree.
thus gentree also selects random paths during the explore mode i.e.
when a tree remains unchanged in the previous iteration so that lowerranked paths can also be improved.
figure shows one possible set of configurations generated from the highest ranked path c. the condition of path cis e u v 0and thus all generated configurations have values of e u v fixed to respectively.
b. building decision trees gentree uses a specialized classification algorithm to build decision trees.
while many decision tree classifiers exist e.g.
the popular family of id3 c4.
and c5.
algorithms they do not fit our purpose because they employ aggressive pruning strategies to simplify trees and need large dataset to produce accurate results.
limitations of c5.
consider an example where we have three options s tare bool and zranges over the values f0 4g.
assume we use all configurations as sample data and use the interaction s t z z to classify these configurations hits there are only configurations satisfy this interaction and misses.
the c5.
algorithm would not be able to create a decision tree e.g.
the one shown in figure 8a that perfectly classifies this data set to represent the desired interaction.
for example the official c5.
implementation with default settings yields the tree in figure 8b which represents the interaction false .
this is because by default the tool determines that most samples were misses and prunes nodes to create a tree reflecting this belief1.
after tweaking the tool s parameters to avoid pruning2 we obtain the tree in figure 8c that represents the interaction s t which is more accurate but is still far from the desired one shown in figure 8a.
even with this full set of configurations we cannot modify c5.
to obtain the desired interaction because c5.
like many other ml techniques requires a very large set of sample data to be accurate leaves with too few samples e.g.
the 1the label indicates this classification has a total of samples but of them are incorrect.
2using the custom parameters c m g .hit configurations in this example are given low confidence level and therefore are pruned .
the c5 ialgorithm we develop c5 i a simplified version of c5.
for interaction learning.
similarly to c5.
c5 i builds a decision tree to split a training sample e.g.
hit and miss configurations based on the feature e.g.
configuration options that provides the highest information gain.
each subsample is then split again using a different feature and the process repeats until meeting some stopping criteria.
classification algorithms including id3 c4.
c5.
cart are designed around the concept of pruning i.e.
remove parts of the tree that do not contribute to classification accuracy on unseen cases producing something less complex and thus more comprehensible .
but pruning leads to inaccuracy as shown in iv b1.
thus c5 iavoids pruning to achieve a accuracy on the training sample i.e.
every sample configuration is correctly classified.
other than pruning the two algorithms have several main differences.
first we use two classification categories hit and miss and features configuration options with finite domains e.g.
boolean or over a finite set of values.
our training samples do not contain unknown values c5.
allows some values in the training data to be omitted .
the sample data also does not contain noise e.g.
if cis an interaction for a location then any configuration satisfies cwill guarantee to hit c. we give similar weights to samples and similar costs for misclassifications c5.
allows different cost assignments to misclassification .
finally we perform splitting until we can no longer split subsamples while c5.
uses heuristics to decide when to stop splitting and prune the rest.
using the set of configurations in the example in iv b1 c5igenerates the tree in figure 8a which represents the desired interaction.
in fact c5 ican generate the same tree using just configurations.
however by requiring exact instead of more generalized trees c5 iis prone to overfitting i.e.
generating trees that are correct for the sample data but might not in general.
gentree s iterative refinement phase is specifically designed to mitigate this problem i.e.
by generating counterexample configurations to gradually correct overfitting mistakes.
in vi we show that the integration of c5iand iterative refinement helps gentree scale to programs with very large configuration spaces and learn trees representing accurate interactions using small sets of configurations.
v. s ubject programs gentree is implemented in c and uses the z3 smt solver to encode and simplify interactions.
we also use z3 to analyze interactions as described in vi e.g.
checking that interactions are equivalent to ground truth .
a. subject programs to evaluate gentree we used the subject programs listed in table i. for each program we list its name language version and lines of code as measured by sloccount .
we also report the number of configuration options opts and the configuration spaces cspace .
1603table i subject programs prog lang ver loc opts cspace id c .
uname c .
cat c .
mv c .
ln c .
date c .
join c .
sort c .
ls c .
grin python .
.
pylint python .
.
unison ocaml .
.
bibtex2html ocaml .
cloc perl .
ack perl .
.
vsftpd c .
.
ngircd c .
.
these programs and their setups v b are collected from igen.
we include all programs that we can reproduce the igen s setup and omit those that we cannot e.g.
the runscripts and tests are not available for the haskell and apache httpd used in igen .
in total we have programs spanning languages c python perl and ocaml .
the first group of programs comes from the widely used gnu coreutils .
these programs are configured via command line options.
we used a subset of coreutils with relatively large configuration spaces at least configurations each .
the second group contains an assortment of programs to demonstrate gentree s wide applicability.
briefly grin andack are grep like programs pylint is a static checker for python unison is a file synchronizer bibtex2html converts bibtex files to html and cloc is a lines of code counter.
these programs are written in python ocaml and perl and have the configuration space size ranging from four million to .
the third group contains vsftpd a secure ftp server and ngircd an irc daemon.
these programs were also studied by who uses the otter symbolic execution tool to exhaustively compute all possible program executions under all possible settings.
rather than using a test suite we ran gentree on these programs in a special mode in which we used otter s outputs as an oracle that maps configurations to covered lines.
b. setup we selected configuration options in a variety of ways.
for coreutils programs we used all options most of which are boolean valued but nine can take on a wider but finite range of values all of which we included e.g.
all possible string formats the program date accepts.
we omit options that range over an unbounded set of values.
for the assorted programs in the second group we used the options that we could get working correctly and ignore those that can take arbitrary values e.g.
pylint options that take a regexp or python expression as input.
for vsftpd andngircd we used the same options as in igen.we manually created tests for coreutils to cover common usage.
for example for cat we wrote a test that read data from a normal text file.
for ls we let it list the files from a directory containing some files some subdirectories and some symbolic links.
finally we obtained line coverage using gcov for c coverage for python devel cover for perl and expression coverage using bisect for ocaml.
we used a custom runner to get the coverage for vsftpd and ngircd using otter s result as explained in v a. our experiments were performed on a core amd cpu .9ghz linux system with gb of ram.
gentree and all experimental data are available at .
vi.
e valuation to evaluate gentree we consider four research questions can gentree learn accurate program interactions r1accuracy ?
how does it perform and scale to programs with large configuration spaces r2 performance ?
what can we learn from the discovered interactions r3 analysis ?
and how doesgentree compare to igen r4 comparing to igen ?
table ii summarizes the results of running gentree on the benchmark programs v taking median across runs and their variance as the semi interquartile siqr range .
for each program columns configs andcov report the number of configurations generated by gentree and the number of locations covered by these configurations respectively.
the next two columns report the running time of gentree search is the total time minus the time spent running programs to obtain coverage .
the next five columns report the number of distinct interactions inferred by gentree .
column single shows the number of interactions that are true false or contain only one option e.g.
s. columns conj disj mix total show the number of pure conjunction pure disjunction mixed arbitrary form and all of these interactions respectively.
the low siqr values on the discovered coverage and interactions indicate that gentree despite being non deterministic3 produces relatively stable results across runs.
the next two columns list the max and median interaction lengths which are further discussed in vi c. column min cspace lists the results for the experiment discussed in vi c. a. r1 accuracy to measure the accuracy of inferred interactions we evaluated whether gentree produces the same results with its iterative algorithm as it could produce if it used all configurations i.e.
the results gentree inferred using allconfigurations are ground truths representing the real interactions .
to do this comparison we use all coreutils programs except ls grin and ngircd because we can exhaustively enumerate all configurations for these programs.
3gentree has several sources of randomness the initial one way covering array the selection of paths used for generating new configurations the selection of option values in those new configurations and the creation of the decision tree by the classification algorithm.
1604table ii results.
column min cspace lists the results for the experiment in vi c time s interaction types inter.
lengths min prog configs cov search total single conj disj mix total max median cspace id uname cat mv ln date join sort ls grin pylint unison bibtex2html cloc ack vsftpd ngircd table iii comparing gentree a vs. exhaustive b vs. igen vi d cov interactions mixed prog exact total pure ok fail id uname cat mv ln date join sort grin ngircd table iiia shows the comparison results.
column cov compares the locations discovered by gentree and by exhaustive runs means no difference kmeans gentree foundkfewer locations .
the next two columns show interactions found by gentree exact that exactly match the interactions discovered by exhaustive runs total .
overall gentree generates highly accurate results comparing to ground truth while using only a small part of the configuration space as shown in table ii and further described in vi b. for uname gentree misses location uname.c which is guarded by a long conjunction of options of uname thus the chance of hitting it is configurations .
also for times gentree infers inaccurately uname.c which is a long disjunction of options.
for ln gentree was not able to compute the exact interaction for location ln.c in all runs.
manual investigation shows that the interaction of this location is a long disjunction consisting of all run time options and thus is misidentified by gentree astrue .
for sort three locations sort.c sort.c sort.c are non deterministic running the program on the same configuration might not always hit or miss theselocations and thus produce inaccurate interactions.
b. r2 performance table ii shows that for programs with large configuration spaces gentree runs longer because it has to analyze more configurations and the run time is dominated by running the programs on these configurations total search .
in general gentree scales well to large programs because it only explores a small portion of the configuration space shown in table i .
for small programs e.g.
id uname cat gentree analyzes approximately half of the configuration space.
however for larger programs e.g.
sort ls pylint bibtex2html gentree shows its benefits as the number of configurations analyzed is not directly proportional to the configuration space size.
for example lshas eight more orders of magnitude compared to sort but the number of explored configurations is about the same.
note thatcloc andack s long run times are due to them being written in perl which runs much slower than other languages such as c and even python on our machine .
convergence figure shows how gentree converges to its final results on the programs used in table iii which we can exhaustively run to obtain ground truth results.
the xaxis is the number of explored configurations normalized such that represents all configurations used by gentree for that particular program .
the y axis is the number of discovered interactions equivalent to ground truth normalized such that represents all interactions for that program .
these results show that gentree converges fairly quickly.
at around of configurations gentree is able to accurately infer more than of the total ground truth interactions.
it then spent the rest of the time refining few remaining difficult interactions.
comparing to random search we also compare interactions inferred from gentree s configurations and randomly generated configurations.
for each program we generate the same number of random configurations as the number of configurations normalized exact interactions normalized id id uname uname cat cat mv mv ln ln configurations normalized exact interactions normalized date date join join sort sort grin grin ngircd ngircd fig.
progress of gentree on generating interactions italic program name indicates randomized version configurations gentree uses and then run c5 ion these configurations to obtain interactions.
figure shows that gentree s configurations help the tool quickly outperform random configurations and stay dominated throughout the runs.
comparing to random configurations gentree s configurations also learns more accurate interactions especially for large programs or those with complex interactions e.g.
random configurations can only achieve about of the ground truth interactions for sort .
c. r3 analysis we analyze discovered interactions to learn interesting properties in configurable software.
these experiments are similar to those in previous interaction works .
interaction forms table ii shows that singular and conjunctive interactions are common especially in small programs.
however disjunctive interactions are relatively rare e.g.
only disjunctions occur in the subject programs.
mixed interactions are also common especially in large programs e.g.
in sort ls unison and bibtext2html .
existing works do not support many of these interactions and thus would not able to find them see vi d .
interaction length table ii shows that the number of obtained interactions is far fewer than the number of possible interactions which is consistent with prior works results.
for example for id which has boolean options total configurations and 21024possible interactions gentree found only interactions which are many orders of magnitude less than .
also most interactions are relatively short regardless of the number of configurations e.g.
all but join sort and ack have the median interaction lengths less than .
we also observe that we can achieve coverage using only interactions with length at most and coverage with length at most .
this observation is similar to previous works.
enabling option enabling options are those that must be set in a certain way to achieve significant coverage.
forexample many locations in coreutils programs have interactions involving the conjunction help version .thus bothhelp andversion are enabling options that must be turned off to reach those locations because if either one is one the program just prints a message and exits .
we also have the enabling options zforid because it is only applicable in selinux enabled kernel and listenipv4 forngircd this option need to be turned on to reach most of locations .
in general enabling options are quite common as suggested in previous works .
minimal covering configurations a useful application ofgentree is using the inferred interactions to compute a minimal set of configurations with high coverage.
to achieve this we can use a greedy algorithm e.g.
the one described in igen which combines interactions having high coverage and no conflict settings generates a configuration satisfying those interactions and repeats this process until the generated configurations cover all interactions.
column min cspace in table ii shows that gentree s interactions allow us to generate sets of high coverage configurations with sizes that are several orders of magnitude smaller than the sizes of configuration spaces.
for example we only need configurations to cover lines in idand configurations to cover lines in sort .
d. r4 comparing to igen comparing to igen gentree generally explored more configurations but discovered more expressive interactions.
table iiib compares the interactions inferred by gentree and igen.
column pure shows the number of single purely conjunctive and pure disjunctive interactions supported and thus inferred by both tools.
columns okandfail show the numbers of mixed interactions supported and not supported by igen respectively gentree found all of these .
for example both igen and gentree discovered the purely conjunctive interaction help version zforid.c andthe mixed interaction help version z u g g forid.c .
however only gentree inferred the more complex mixed 1606interaction help version z g g n u r z for location id.c .
for small programs we observe that many interactions are pure conjunctive or disjunctive and hence supported by both tools.
however for larger and more complex programs e.g.
sort ngircd igen could not generate most mixed interactions while gentree could.
for example igen failed to generate of the mixed interactions in sort while gentree generated most of them.
e. threats to validity although the benchmark systems we have are popular and used in the real world they only represent a small sample of configurable software systems.
thus our observations may not generalize in certain ways or to certain systems.
gentree runs the programs on test suites to obtains coverage information.
our chosen tests have reasonable but not complete coverage.
systems whose test suites are less or more complete could have different results.
our experiments used a substantial number of options but do not include every possible configuration options.
we focused on subsets of configuration options that appeared to be important based on our experience.
finally gentree cannot infer interactions that cannot be represented by decision trees e.g.
configuration options involving non finite numerical values .
interactions involving such options might be important to the general understanding and analysis of configurable software.
vii.
r elated work interaction generation as mentioned gentree is mostly related to igen which computes three forms of interactions purely conjunctive purely disjunctive and specific mixtures of the two.
in contrast we use decision trees to represent arbitrary boolean interactions and develop our own classification algorithm c5 ito manipulate decision trees.
to illustrate the differences consider the interaction for location id.c help version z g g n u r z which can be written as the disjunction of two purely conjunctive interactions help version z g g n u help version z g g n r z .
igen can infer each of these two purely conjunctions but itcannot discover their disjunction because igen does not support this form e.g.
a b a c .
for this example even when running on all1024 configurations igen only generates help version z g g n u which misses the relation with randz.
in contrast gentree generates thisexact disjunctive interaction and many others using configurations in under a second table ii in vi b .
moreover while both tools rely on the iterative guessand check approach the learning and checking components and their integration in gentree are completely different from those in igen e.g.
using heuristics to select likely fragile tree paths to generate counterexamples.
also while c5iis a restricted case of c5.
it is nonetheless a useful case that allows us to generate a tree that is exactly accurate over data instead of a tree that approximates the data.
wedeveloped c5 ibecause existing classification algorithms do not allow easy interaction inference due to agressive pruning and simplification as explained in iv b2 .
precondition and invariant discovery researchers have used decision trees and general boolean formulae to represent program preconditions interactions can be viewed as preconditions over configurable options .
the work in uses random sat solving to generate data and decision trees to learn preconditions but does not generate counterexample data to refine inferred preconditions which we find crucial to improve resulting interactions.
similarly pie uses pac probably approximately correct algorithm to learn cnf formula over features to represent preconditions but also does not generate counterexamples to validate or improve inferred results.
only when given the source code and postconditions to infer loop invariants pie would be able to learn additional data using smt solving.
gentree adopts the iterative refinement approach used in several invariant analyses e.g.
.
these works in particular that use decision trees rely on static analysis and constraint solving to check and generate counterexamples that the inferred invariants are correct with respect to the program with a given property assertion i.e.
the purpose of these works is to prove correct programs correct .
in contrast gentree is pure dynamic analysis in both learning and checking and aims to discover interactions instead of proving certain goals.
gentree can be considered as a dynamic invariant tool that analyzes coverage trace information.
daikon infers invariants from templates that fit program execution traces.
gentree focuses on inferring interactions represented by arbitrary formulae and combines with iterative refinement.
dysy is another invariant generator that uses symbolic execution for invariant inference .
the interaction work in also uses the symbolic executor otter to fully explore the configuration space of a software system but is limited to purely conjunctive formulae for efficiency.
symbolic execution techniques often have similar limitations as static analysis e.g.
they require mocks or models to represent unknown libraries or frameworks and are language specific e.g.
otter only works on c programs .
finally gentree aims to discover new locations and learns interactions for all discovered locations.
in contrast invariant generation tools typically consider a few specific locations e.g.
loop entrances and exit points .
binary decision diagrams bdds the popular bdd data structure can be used to represent boolean formulae and thus is an alternative to decision trees.
two main advantages of bdds are that a bdd can compactly represent a large decision tree and equivalent formulae are represented by the same bdd which is desirable for equivalence checking.
however our priority is not to compactly represent interactions or check their equivalences but instead to be able to infer interactions from a small set of data.
while c5 iavoids aggressive prunings to improve accuracy it is inherently a classification algorithm that computes results by generalizing training data like the original c5.
algorithm gentree 1607performs generalization by using heuristics to decide when to stop splitting nodes to build the tree as described in iv b2 .
to create a bdd representing a desired interaction we would need many configurations e.g.
2n miss or2n 1hit configurations to create a bdd for a b1 b2 bn .
in contrast c5 iidentifies and generalizes patterns from training data and thus require much fewer configurations.
for instance the configuration space size of the example in figure is and from just configurations c1 c2 c3 c5 ilearns the interaction sbecause it sees that whenever s l8is miss and whenever s l8ishit.
bdd would need configurations to infer the same interaction.
combinatorial interaction testing and variability aware analyses combinatorial interaction testing cit is often used to find variability bugs in configurable systems.
one popular cit approach is using t way covering arrays to generate a set of configurations containing all t way combinations of option settings at least once.
cit is effective but is expensive and requires the developers to choose ta priori.
thus developers will often set tto small causing higher strength interactions to be ignored.
gentree initializes its set of configurations using way covering arrays.
variability aware is another popular type of analysis to find variability bugs .
classify problems in software product line research and surveys static analysis to solve them.
gentree s interactions belong to the feature based classification and we propose a new dynamic analysis to analyze them.
study feature interactions in a system and their effects including bug triggering power consumption etc.
gentree complements these results by analyzing interactions that affect code coverage.
viii.
c onclusion we presented gentree a new dynamic analysis technique to learn program interactions which are formulae that describe the configurations covering a location.
gentree works by iteratively running a subject program under a test suite and set of configurations building decision trees from the resulting coverage information and then generating new configurations that aim to refine the trees in the next iteration.
experimental results show that gentree is effective in accurately finding complex interactions and scales well to large programs.
ix.
d ata availability gentree and all benchmark data are available at the public github repository .
a snapshot of the tool and benchmark used in this paper is available at .
acknowledgment we thank the anonymous reviewers for helpful comments.
this work was supported in part by awards ccf from the national science foundation and w911nf from the army research office.
kimhao nguyen is also supported by the ucare award from the university of nebraska lincoln.