jest n version differential testing of both javascript engines and specification jihyeok park school of computing kaist daejeon south korea jhpark0223 kaist.ac.krseungmin an school of computing kaist daejeon south korea h2oche kaist.ac.krdongjun youn school of computing kaist daejeon south korea f52985 kaist.ac.krgyeongwon kim school of computing kaist daejeon south korea gyeongwon.kim kaist.ac.krsukyoung ryu school of computing kaist daejeon south korea sryu.cs kaist.ac.kr abstract modern programming follows the continuous integration ci and continuous deployment cd approach rather than the traditional waterfall model.
even the development of modern programming languages uses the ci cd approach to swiftly provide new language features and to adapt to new development environments.
unlike in the conventional approach in the modern ci cd approach a language specification is no more the oracle of the language semantics because both the specification and its implementations interpreters or compilers can co evolve.
in this setting both the specification and implementations may have bugs and guaranteeing their correctness is non trivial.
in this paper we propose a novel n version differential testing to resolve the problem.
unlike the traditional differential testing our approach consists of three steps to automatically synthesize programs guided by the syntax and semantics from a given language specification to generate conformance tests by injecting assertions to the synthesized programs to check their final program states to detect bugs in the specification and implementations via executing the conformance tests on multiple implementations and to localize bugs on the specification using statistical information.
we actualize our approach for the javascript programming language via jest which performs n version differential testing for modern javascript engines and ecmascript the language specification describing the syntax and semantics of javascript in a natural language.
we evaluated jest with four javascript engines that support all modern javascript language features and the latest version of ecmascript es11 .
jest automatically synthesized programs that covered .
of syntax and .
of semantics from es11.
using the assertion injected javascript programs it detected engine bugs in four different engines and specification bugs in es11.
index terms javascript conformance test generation mechanized specification differential testing i. i ntroduction in peter o hearn s keynote speech in icse he quoted the following from mark zuckerberg s letter to investors the hacker way is an approach to building that involves continuous improvement and iteration.
hackers believe that somethings can always be better and that nothing is ever complete.
indeed modern programming follows the continuous integration ci and continuous deployment cd approach rather than the traditional waterfall model.
instead of a sequential model that divides software development into several phases each of which takes time ci cd amounts to a cycle of quicksoftware development deployment and back to development with feedback.
even the development of programming languages uses the ci cd approach.
consider javascript one of the most widely used programming languages for client side and server side programming and embedded systems .
various javascript engines provide diverse extensions to adapt to fast changing user demands.
at the same time ecmascript the official specification that describes the syntax and semantics of javascript is annually updated since ecmascript es6 to support new features in response to user demands.
such updates in both the specification and implementations in tandem make it difficult for them to be in sync.
another example is solidity the standard smart contract programming language for the ethereum blockchain.
the solidity language specification is continuously updated and the solidity compiler is also frequently released.
according to hwang and ryu the average number of days between consecutive releases from solidity .
.
to .
.
is .
in most cases the solidity compiler reflects updates in the specification but even the specification is revised according to the semantics implemented in the compiler.
as in javascript bidirectional effects in the specification and the implementation make it hard to guarantee their correspondence.
in this approach both the specification and the implementation may contain bugs and guaranteeing their correctness is a challenging task.
the conventional approach to build a programming language is uni directional from a language specification to its implementation.
the specification is believed to be correct and the conformance of an implementation to the specification is checked by dynamic testing.
unlike in the conventional approach in the modern ci cd approach the specification may not be the oracle because both the specification and the implementation can co evolve.
in this paper we propose a novel n version differential testing which enables testing of co evolving specifications and their implementations.
the differential testing is a testing technique which executes nimplementations of a specification concurrently for each input and detects a problem when the outputs are in disagreement.
in addition to n implementations our approach tests the specification as well using a mechanized specification.
recently several approaches ieee acm 43rd international conference on software engineering icse .
ieee to extract syntax and semantics directly from language specifications are presented .
we utilize them to bridge the gap between specifications and their implementations through conformance tests generated from mechanized specifications.
then version differential testing consists of three steps to automatically synthesize programs guided by the syntax and semantics from a given language specification to generate conformance tests by injecting assertions to the synthesized programs to check their final program states to detect bugs in the specification and implementations via executing the conformance tests on multiple implementations and to localize bugs on the specification using statistical information.
given a language specification and nexisting real world implementations of the specification we automatically generate a conformance test suite from the specification with assertions in each test code to make sure that the result of running the code conforms to the specification semantics.
then we run the test suite for nimplementations of the specification.
because generated tests strictly comply with the specification they reflect specification errors as well if any.
when one of the implementations fails in running a test the implementation may have a bug as in the differential testing.
when most of the implementations fail in running a test it is highly likely that the specification has a bug.
by automatically generating a rich set of test code from the specification and running them with implementations of the specification we can find and localize bugs either in the specification written in a natural language or in its implementations.
to show the practicality of the proposed approach we present jest which is a j avascript e ngines and s pecification tester usingn version differential testing.
we implement jest by extending jiset a javascript ir based semantics extraction toolchain to utilize the syntax and semantics automatically extracted from ecmascript.
using the extracted syntax our tool automatically synthesizes initial seed programs and expands the program pool by mutating specific target programs guided by semantics coverage.
then the tool generates conformance tests by injecting assertions to synthesized programs.
finally jest detects and localizes bugs using execution results of the tests on njavascript engines.
we evaluate our tool with four javascript engines google v8 graaljs quickjs and moddable xs that support all modern javascript language features and the latest ecmascript es11 .
the main contributions of this paper include the following presentn version differential testing a novel solution to the new problem of co evolving language specifications and their implementations.
implementn version differential testing for javascript engines and ecmascript as a tool called jest .
it is the first tool that automatically generates conformance tests for javascript engines from ecmascript.
while the coverage of test262 the official conformance tests is .
for statements and .
for branches the coverage of the conformance tests generated by the tool is .
for statements and .
for branches.
a the abstract equality comparison abstract algorithm in es11 javascript engines exception with err ecmascript es11 result false var obj valueof throw err var result obj b javascript code using abstract equality comparison try var obj valueof throw err var result obj assert result false catch e assert false c javascript code with injected assertions fig.
abstract algorithm in es11 and code example using it evaluate jest with four modern javascript engines and the latest ecmascript es11.
using the generated conformance test suite the tool found and localized engine bugs in four different engines and specification bugs in es11.
ii.n version differential testing this section introduces the core concept of n version differential testing with a simple running example.
the overall structure consists of two phases a conformance test generation phase and a bug detection and localization phase.
a. main idea differential testing utilizes the cross referencing oracle which is an assumption that any discrepancies between program behaviors on the same input could be bugs.
it compares the execution results of a program with the same input on n different implementations.
when an implementation produces a different result from the one by the majority of the implementations differential testing reports that the implementation may have a bug.
on the contrary n version differential testing utilizes not only the cross referencing oracle using multiple implementations but also a mechanized specification.
it first generates test code from a mechanized specification and tests ndifferent implementations of the specification using the generated test code as in differential testing.
in addition it can detect possible bugs in the specification as well when most implementations fail for a test.
in such cases because a bug in the specification could be triggered by the test it localizes the bug using statistical information as we explain later in this section.
14fig.
overall structure of n version differential testing for nimplementations engines and one language specification b. running example we explain how n version differential testing works with a simple javascript example shown in figure .
figure a is an excerpt from ecmascript es11 which shows some part of the abstract equality comparison abstract algorithm.
it describes the semantics of nonstrict equality comparison such as and !
.
for example null undefined istrue because of the algorithm step .
according to the steps and if the type of a value is string number bigint or symbol and the type of the other value is object the algorithm calls toprimitive to convert the javascript object to a primitive value.
note that this is a specification bug caused by unhandled abrupt completions!
to express control diverters such as exceptions break continue return and throw statements in addition to normal values ecmascript uses abrupt completions.
ecmascript annotates the question mark prefix ?
to all function calls that may return abrupt completions to denote that they should be checked.
however even though toprimitive can produce an abrupt completion the calls of toprimitive in steps and do not use the question mark which is a bug.
now let s see how n version differential testing can detect the bug in the specification.
consider the example javascript code in figure b which triggers the above specification bug.
in the abstract equality comparison algorithm variables xandyrespectively denote 42and an object with a property named valueof whose value is a function throwing an error.
step calls toprimitive with the object as its argument and the call returns an abrupt completion because the call of valueof throws an error.
however because the call oftoprimitive in step does not use the question mark the specification semantics silently ignores the abrupt completion and returns false as the result of comparison.
using the specification semantics we can inject assertions to check that the code does not throw any errors as shown in figure c .
then by running the code with the injected assertions on n javascript engines which throw errors we can find that the specification may have a bug.
moreover we can localize the bug using statistical information because most conformance tests that go through steps and of the algorithm would fail in most of javascript engines we can use the information to localize the bug in the steps and of abstract equality comparison with high probability.c.
overall structure figure depicts the overall structure of n version differential testing for ndifferent implementations engines and one language specification.
it takes a mechanized specification extracted from a given language specification it first performs the conformance test generation phase which automatically generates conformance tests that reflect the language syntax and semantics described in the specification.
then it performs the bug detection and localization phase which detects and localizes bugs in the engines or the specification by comparing the results of the generated tests on nengines.
the functionalities of each module in the overall structure are as follows seed synthesizer the first module of the conformance test generation phase is seed synthesizer which synthesizes an initial seed programs using the language syntax.
its main goal is to synthesize a few number of small sized programs that cover possible cases in the syntax rules as many as possible.
target selector starting from the seed programs generated by seed synthesizer as the initial program pool target selector selects a target program in the program pool that potentially increases the coverage of the language semantics by the pool.
from the selected target program program mutator constructs a new mutated program and adds it to the program pool.
when specific criteria such as an iteration limit are satisfied target selector stops selecting target programs and returns the program pool as its result.
program mutator the main goal of program mutator is to generate a new program by mutating a given target program in order to increase the coverage of the language semantics by the program pool.
if it fails to generate a new program to increase the semantics coverage target selector retries to select a new target program and repeats this process less than a pre defined iteration limit.
assertion injector finally the conformance test generation phase modifies the programs in the pool to generate conformance tests by injecting appropriate assertions reflecting the semantics described in the specification.
more specifically assertion injector executes each program in the pool on the mechanized specification and obtains the final state of its execution.
it then automatically injects assertions to the program using the final state.
15algorithm worklist based shortest string input r syntax reduction rules output m map from non terminals to shortest strings derivable from them function shorteststrings r m ?
w a queue that contains r whilew6 ?do pop a w ifupdate a then propagate w r a function update a str an empty string foralls2 do ifsis a terminal tthenstr str t else ifsis a non terminal a0 a02mthen str str m else return false if9m jjstrjj jjm jjthen return false m str return true function propagate w r a forall a0 2rdo ifa2 0then push a0 !w bug localizer then the second phase executes the conformance tests on nengines and collects their results.
for each test if a small number of engines fail it reports potential bugs in the engines that fail the test.
otherwise it reports potential bugs in the specification.
in addition its bug localizer module uses spectrum based fault localization sbfl a localization technique utilizing the coverage and pass fail results of test cases to localize potential bugs.
iii.n version differential testing for javascript we actualize n version differential testing for the javascript programming language as jest which uses modern javascript engines and ecmascript.
a. seed synthesizer jest synthesizes seed programs using two synthesizers.
non recursive synthesizer the first synthesizer aims to cover as many syntax cases as possible in two steps to find the shortest string for each non terminal and to synthesize javascript programs using the shortest strings.
for presentation brevity we explain simple cases like terminals and non terminals but the implementation supports the extended grammar of ecmascript such as parametric non terminals conditional alternatives and special terminal symbols.
the shorteststrings function in algorithm shows the first step.
we modified mckenize s algorithm that finds random strings to find the shorted string.
it takes syntax reduction rules r a set of pairs of non terminals and alternatives algorithm non recursive synthesize input r syntax reduction rules s start symbol output d set of strings derivable from s function nonrecsynthesize r s v ?
m shorteststrings r return getprod m v r s function getprod m v r a ifa2vthen returnfm g d ?
v v fag forall a0 2rs.t.a0 ado d d getalt m v r a returnd function getalt m v r a l an empty list foralls2 do ifsis a terminal tthen append ftg t tol else ifsis a non terminal a0then append getprod m v r a0 m tol d point wise concatenation of first elements of pairs inlusing second elements as default ones.
returnd and returns a map mfrom non terminals to shortest strings derivable from them.
it utilizes a worklist w a queue structure that includes syntax reduction rules affected by updated nonterminals.
the function initializes the worklist wwith all the syntax reduction rules r. then for a syntax reduction rule a it updates the map mvia the update function and propagates updated information via the propagate function.
the update function checks whether a given alternative of a non terminal acan derive a string shorter than the current shortest one using the current map m. if possible it stores the mapping from the non terminal ato the newly found shortest string inmand invokes propagate .
the propagate function finds all the syntax reduction rules whose alternatives contain the updated non terminal aand inserts them into w. the shorteststrings function repeats this process until the worklist wbecomes empty.
using shortest strings derivable from non terminals the nonrecsynthesize function in algorithm synthesize programs.
it takes syntax reduction rules rand a start symbol s. for the first visit with a non terminal a the getprod function returns strings generated by getalt with alternatives of the non terminal a. for an already visited non terminal a it returns the single shortest string m .
the getalt function takes a non terminal awith an alternative and returns a set of strings derivable from via point wise concatenation of strings derived by symbols of .
when the numbers of strings derived by symbols are different it uses the shortest strings derived by symbols as default strings.
for example figure shows a simplified memberexpres16fig.
the memberexpression production in es11 sion production in es11.
for the first step we find the shortest string for each non terminal forarguments and xfor the other non terminals.
note that we use pre defined shortest strings for identifiers and literals such as xfor identifiers and 0for numerical literals.
in the next step we synthesize strings derivable from memberexpression .
the first alternative is a single non terminal primaryexpression which is never visited.
thus it generates all cases of primaryexpression .
the fourth alternative consists of one terminal newand two non terminals memberexpression and arguments .
because memberexpression is already visited it generates a single shortest string x. for the first visit of arguments it generates all cases x ...x and x .
note that the numbers of strings generated for symbols are different.
in such cases we use the shortest strings for symbols like xformemberexpression as follows built in function synthesizer javascript supports diverse built in functions for primitive values and built in objects.
to synthesize javascript programs that invoke builtin functions we extract the information of each built in function from the mechanized ecmascript.
we utilize the function .prototype.call function to invoke built in functions to easily handle the this object in program mutator we use a corresponding object or null as the this object by default.
in addition we synthesize function calls with optional and variable number of arguments and built in constructor calls with the newkeyword.
consider the following array.prototype.indexof function for javascript array objects that have a parameter searchelement and an optional parameter fromindex the synthesizer generates the following calls with an array object or null as the this object as follows array.prototype.indexof.call new array array.prototype.indexof.call new array array.prototype.indexof.call null array.prototype.indexof.call null moreover array is a built in function and a built in constructor with a variable number of arguments.
thus we synthesize the following six programs for array array array array new array new array new array b. target selector from the synthesized programs target selector selects a target program to mutate to increase the semantics coverage of the program pool.
consider the abstract equality comparison algorithm in figure a again where the first step has the condition if type x is the same as type y .
assuming that the current pool has the following three programs true false because later two programs that perform comparison have values of the same type the pool covers only the true branch of the condition in the algorithm.
to cover its false branch target selector selects any program that covers the true branch like true false andprogram mutator mutates it to false for example.
then since the mutated program covers the false branch the pool is extended as follows true false false which now covers more steps in the algorithm.
this process repeats until the semantics coverage converges.
c. program mutator jest increases the semantics coverage of the program pool by mutating programs using five mutation methods randomly.
random mutation the first na ve method is to randomly select a statement a declaration or an expression in a given program and to replace it with a randomly selected one from a set of syntax trees generated by the nonrecursive synthesizer.
for example it may mutate a program var x by replacing its random expression 1with a random expression true producing var x true .
nearest syntax tree mutation the second method targets uncovered branches in abstract algorithms.
when only one branch is covered by a program it finds the nearest syntax tree in the program that reaches the branch in the algorithm and replaces the nearest syntax tree with a random syntax tree derivable from the same syntax production.
for example consider the following javascript program var x while it covers the false branch of the first step of abstract equality comparison in figure a assume that no program in the program pool can cover its true branch.
then the mutator targets this branch finds its nearest syntax tree in the program and replaces it with a random syntax tree.
string substitutions we collect all string literals used in conditions of the algorithms in es11 and use them for random expression substitutions.
because most string literals in the specification represent corner cases such as infinity and nan they are necessary for mutation to increase the semantics coverage.
for example the semantics of the internal method of array exotic objects depends on whether the value of its parameter pis length or not.
object substitutions we also collect string literals and symbols used as arguments of object property access algorithms in es11 randomly generate objects using them and replace random expressions with the generated objects.
because some abstract algorithms in the specification access object properties using hasproperty getmethod get and ordinarygetownproperty objects with such properties are necessary for mutation to achieve high coverage.
thus the mutator mutates a randomly selected expression in a program with a randomly generated object that has properties whose keys are from collected string literals and symbols.
statement insertion to synthesize more complex programs the mutator inserts random statements at the end of randomly selected blocks like top level code and function bodies.
we generate random statements using the non recursive synthesizer with pre defined special statements.
the special statements are control diverters which have high chances of changing execution paths such as function calls return break and throw statements.
the mutator selects special statements with a higher probability than the statements randomly synthesized by the non recursive synthesizer.
d. assertion injector after generating javascript programs assertion injector injects assertions to them using their final states as specified in ecmascript.
it first obtains the final state of a given program from the mechanized specification and injects seven kinds of assertions in the beginning of the program.
to check the final state after executing all asynchronous jobs we enclose assertions with settimeout to wait ms when a program uses asynchronous features such as promise andasync ... a given program settimeout ... assertions exceptions javascript supports both internal exceptions like syntaxerror andtypeerror and custom exceptions with the keyword throw .
note that catching such exceptions using thetry catch statement may change the program semantics.
for example the following does not throw any exception var x function x but the following try var x function x catch e throws syntaxerror because declarations of a variable and a function with the same name are not allowed in try catch .
to resolve this problem we exploit a comment in the first line of a program.
if the program throws an internal exception we tag its name in the comment.
otherwise we tag throw for a custom exception and normal for normal termination.
using the tag in the comment jest checks the execution result of a program in each engine.
aborts the mechanized semantics of ecmascript can abort due to unspecified cases.
for example consider the following javascript program var x x the postfix increment operator increases the number value stored in the variable x. however because of a typo in the evaluation algorithm for such update expressions in es11 the behavior of the program is not defined in es11.
to represent this situation in the conformance test we tag abort in the comment as follows abort var x x variable values we inject assertions that compare the values of variables with expected values.
to focus on variables introduced by tests we do not check the values of pre defined variables like built in objects.
for numbers we distinguish 0from 0using division by zero because and produce negative and positive infinity values respectively.
the following example checks whether the value of xis3 var x assert.samevalue x object values to check the equality of object values we keep a representative path for each object.
if the injector meets an object for the first time it keeps the current path of the object as its representative path and injects assertions for the properties of the object.
otherwise the injector adds assertions to compare the values of the objects with the current path and the representative path.
in the following example var x y z p x q y assert.samevalue z.p x assert.samevalue z.q y because the injector meets two different new objects stored in xand y it keeps the paths xand y. then the object stored inzis also a new object but its properties z.pand z.qstore already visited objects values.
thus the injector inserts two assertions that check whether z.pandxhave the same object value and z.qand yas well.
to handle built in objects we store all the paths of built in objects in advance.
object properties checking object properties involves checking four attributes for each property.
we implement a helper verifyproperty to check the attributes of each property for each object.
for example the following code checks the attributes of the property of x.p var x p verifyproperty x p value .
writable true enumerable true configurable true property keys since ecmascript es6 the specification defines orders between property keys in objects.
we check the order of property keys by reflect.ownkeys which takes an object and returns an array of the object s property keys.
we implement a helper assert.comparearray that takes two arrays and compares their lengths and contents.
for example the following program checks the property keys and their order of the object in x var x p q assert.comparearray reflect.ownkeys x internal methods and slots while internal methods and slots of javascript objects are generally inaccessible by users the names in the following are accessible by indirect getters name indirect getter object.getprototypeof x object.isextensible x typeof f function reflect.construct function x the internal slot represents the prototype object of an object which is available by a built in function object.getprototypeof .
the internal slot is also available by a built in function object.isextensible .
the internal methods and represent whether a given object is a function and a constructor respectively.
because the methods are not javascript values we simply check their existence using helpers assert.callable and assert.constructable .
for we use the typeof operator because it returns function if and only if a given value is an object with the method.
for method we use the reflect.construct built in function that checks the existence of the methods and invokes it.
to avoid invoking unintentionally we call reflect.construct with a dummy function function as its first argument and a given object as its third argument.
for example the following code shows how the injector injects assertions for internal methods and slots function f assert.samevalue object.getprototypeof f function .prototype assert.samevalue object.isextensible x true assert.callable f assert.constructable f e. bug localizer the bug detection and localization phase uses the execution results of given conformance tests on multiple javascript engines.
if a small number of engines fail in running a specific conformance test the engines may have bugs causing the test failure.
if most engines fail for a test the test may be incorrect which implies a bug in the specification.
when we have a set of failed test cases that may contain bugs of an engine or a specification we classify the test cases using their failure messages and give ranks between possible buggy program elements to localize the bug.
we use spectrum based fault localization sbfl which is a ranking technique based on likelihood of being faulty for each program element.
we use the following formula called er1b which is one of the best sbfl formulae theoretically analyzed by xie et al.
nef nep nep nnp wherenef nep nnf andnnprepresent the number of test cases subscripts eand nrespectively denote whether a test case touches a relevant program element or not and subscripts fand prespectively denote whether the test case is failed or passed.we use abstract algorithms of ecmascript as program elements used for sbfl.
to improve the localization accuracy we use method level aggregation .
it first calculates sbfl scores for algorithm steps and aggregates them up to algorithm level using the highest score among those from steps of each algorithm.
iv.
e valuation to evaluate jest that performs n version differential testing of javascript engines and its specification we applied the tool to four javascript engines that fully support modern javascript features and the latest specification ecmascript es11 .
our experiments use the following four javascript engines all of which support es11 v8 v8.
an open source high performance engine for javascript and webassembly developed by google graaljs v20.
.
a javascript implementation built on graalvm which is a java virtual machine jvm based on hotspot openjdk developed by oracle quickjs a small and embedded javascript engine developed by fabrice bellard and charlie gordon moddable xs v10.
.
a javascript engine at the center of the moddable sdk which is a combination of development tools and runtime software to create applications for micro controllers to extract a mechanized specification from ecmascript we utilize the tool jiset which is a javascript ir based semantics extraction toolchain to automatically generate a javascript interpreter from ecmascript.
to focus on the core semantics of javascript we consider only the semantics of strict mode javascript code that pass syntax checking including the earlyerror rules.
to filter out javascript code that are not strict or fail syntax checking we utilize the syntax checker of the most reliable javascript engine v8.
we performed our experiments on a machine equipped with .0ghz intel r core tm i7 6700k and 32gb of ram samsung ddr4 2133mhz 8gb .
we evaluated jest with the following four research questions rq1 coverage of generated tests is the semantics coverage of the tests generated by jest comparable to that of test262 the official conformance test suite for ecmascript which is manually written?
rq2 accuracy of bug localization does jest localize bug locations accurately?
rq3 bug detection in javascript engines how many bugs of four javascript engines does jest detect?
rq4 bug detection in ecmascript how many bugs of es11 does jest detect?
a statement coverage b branch coverage fig.
the semantics coverage changes during the test generation phase table i number of generated programs and covered branches of mutation methods mutation method program branch avg.
nearest syntax tree mutation random mutation statement insertion object substitution string substitution total a. coverage of generated tests jest generates the seed programs via seed synthesizer which synthesizes javascript programs in about seconds and covers .
of reachable alternatives in the syntax productions of es11.
among them we filtered out programs that do not increase the semantics coverage and started the mutation iteration with programs.
figure shows the change of semantics coverage of the program pool during the iterative process in hours.
the left and right graphs present the statement and branch coverages respectively and the top red line denotes the coverage of test262.
we generated conformance tests two times before and after fixing bugs detected by jest because the specification bugs affected the semantics coverage.
in each graph dark gray x marks and blue o marks denote the semantics coverage of generated tests before and after fixing bugs.
the semantics that we target in es11 consists of algorithms with statements and branches.
for the statement coverage test262 covers .
statements.
the initial program pool covers .
statements and the final program pool covers .
and .
statements before and after fixing bugs respectively.
for the branch coverage test262 covers .
branches.
the initial program pool covers .
branches and the final program pool covers .
and .
branches before and after fixing bugs respectively.
table i shows the number of synthesized programs and covered branches for each mutation method during the test generation phase.
in total jest successfully synthesize new programs that cover more branches than the initial program pool.
among five mutation methods the nearest syntax tree mutation is the most contributed method programs and covered branches and the least one is fig.
ranks of algorithms that caused the bugs detected by jest the string substitution programs and covered branches .
on average .
branches are covered by a new program.
finally jest generates javascript programs and their average number of lines is .
.
after injecting assertions their average number of lines becomes .
.
compared to test262 the number of generated tests are much smaller and their number of lines are also shorter than those of tests in test262.
test262 provides tests for the same range of semantics and their average number of lines is .
.
b. accuracy of bug localization to detect more bugs using more diverse programs we repeated the conformance test generation phase for ten times.
we executed the generated conformance tests on four javascript engines to find bugs in the engines and the specification.
after inferring locations of the bugs in the engines or the specification based on the majority of the execution results we manually checked whether the bugs are indeed in the engines or the specification.
the following table shows that our method works well failed engines total average engine bugs specification bugs for engine bugs the average number of engine failures is .
while the average number of failed engines for specification bugs is .
.
as we expected when most engines fail for a test the specification may have a bug.
based on the results of conformance tests on four javascript engines we localized the specification or engine bugs on the 20table iii specification bugs in ecmascript es11 detected by jest name feature description assertion known created resolved existed es11 function wrong order between property keys for functions key o days es11 function 8missing property name for anonymous functions key o days es11 loop 1returning iterator objects instead of iterator records inforin ofheadevaluation forfor inloopsexc o days es11 expression 4using the wrong variable oldvalue instead of oldvalue inevaluation ofupdateexpressionabort o days es11 expression 1unhandling abrupt completion inabstract equality comparisonexc o days es11 object 1unhandling abrupt completion in evaluation of propertydefinition for object literalsexc x tbd tbd table ii the number of engine bugs detected by jest engines exc abort var obj desc key intotal v8 graaljs quickjs moddable xs total semantics of es11.
among bugs we excluded syntax bugs and localized only semantics bugs.
figure shows the ranks of algorithms that caused the semantics bugs.
the average rank is .
and .
of the algorithms causing the bugs are ranked less than .
less than and .
less than .
note that the location of one bug is ranked because of the limitation of sbfl its localization accuracy becomes low for a small number of failed test cases.
c. bug detection in javascript engines from four javascript engines jest detected bugs from v8 from graaljs from quickjs and from moddable xs.
table ii presents how many bugs for each assertion are detected for each engine.
we injected seven kinds of assertions exceptions exc aborts abort variable values var object values obj object properties desc property keys key and internal methods and slots in .
the effectiveness of bug finding is different for different assertions.
theexcandkeyassertions detected engine bugs the most out of bugs the former detected bugs and the latter detected bugs.
desc andvardetected and bugs respectively but the other assertions did not detect any engine bugs.
the most reliable javascript engine is v8 because jest found only two bugs and the bugs are due to specification bugs in es11.
because v8 strictly follows the semantics of functions described in es11 it also implemented wrong semantics that led to es11 and es11 listed in table iii.
the v8 team confirmed the bugs and fixed them.
we detected engine bugs in graaljs and one of them caused an engine crash.
when we apply the prefix increment operator for undefined as undefined graaljs throws java.lang.illegalstateexception .
because it crashes the engine developers even cannot catch the exception as follows try undefined catch e the graaljs team has been fixing the bugs we reported and asked whether we plan to publish the conformance test suite because the tests generated by jest detected many semantics bugs that were not detected by other conformance tests right now we are running test262 and the v8 and nashorn unit test suites in our ci for every change it might make sense to add your suite as well.
in quickjs jest detected engine bugs most of which are due to corner cases of the function semantics.
for example the following code should throw a referenceerror exception function f ... x x return x f because the variable xis not yet initialized when it tries to read the right hand side of x x .
however since quickjs assumes that the initial value of xisundefined the function callf returns undefined .
the quickjs team confirmed our bug reports and it has been fixing the bugs.
jest found the most bugs in moddable xs it detected bugs for various language features such as optional chains number.prototype.tostring iterators of map and set and complex assignment patterns.
among them optional chains are newly introduced in es11 which shows that our approach is applicable to finding bugs in new language features.
we reported all the bugs found and the moddable xs team has been fixing them.
they showed interests in using our test suite as you know it is difficult to verify changes because the language specification is so big.
test262 as great a resource as it is is not definitive.
d. bug detection in ecmascript from the latest ecmascript es11 jest detected specification bugs.
table iii summarizes the bugs categorized by their root causes.
among them five categories es11 to es11 were already reported and fixed in the current draft of the next ecmascript but es11 was never reported before.
we reported it to tc39 they confirmed it and they will fix it in the next version ecmascript es12 .
es11 contains bugs it is due to a wrong order between property keys of all kinds of function values such as async and generator functions arrow functions and classes.
for example if we define a class declaration with a name a class a three properties are defined in the function stored in the variable a length with a number value prototype with an object and name with a string a .
the problem is the different order of their keys because of the wrong order of their creation.
from ecmascript es6 21the order between property keys is no more implementationdependent but it is related to the creation order of properties.
while the order of property keys in the class ashould be according to the semantics of es11 the order is in three engines except v8.
we found that it was already reported as a specification bug we reported it to v8 and they fixed it.
this bug was created on february and tc39 fixed it on april the bug lasted for days.
es11 contains bugs that are due to the missing property name of anonymous functions.
until es5.
anonymous functions such as an identity arrow function x x had their own property name with an empty string .
while es6 removed the name property from anonymous functions three engines except v8 still create the name property in anonymous functions.
we also found that it was reported as a specification bug and reported it to v8 and it will be fixed in v8.
the bug in es11 comes from the misunderstanding of the term iterator object and iterator record .
the algorithm forin ofheadevaluation should return an iterator record which is an implicit record containing only internal slots.
however in es11 it returns an iterator object which is a javascript object with some properties related to iteration.
it causes a typeerror exception when executing the code for var xin according to es11 but all engines execute the code normally without any exceptions.
this bug was resolved by tc39 on april .
es11 contains four bugs caused by a typo for the variable in the semantics of four different update expressions x x x and x. in each evaluation of four kinds of updateexpression there exists a typo oldvalue in step instead of oldvalue declared in step .
jest could not execute the code x using the semantics of es11 because of the typo.
for this case we directly pass the code to bug localizer to test whether the code is executable in real world engines and to localize the bug.
of course four javascript engines executed the update expressions without any issues and this bug was resolved by tc39 on april .
two bugs in es11 and es11 are caused by unhandling of abrupt completions in abstract equality comparison and property definitions of object literals respectively.
the bug in es11 was confirmed by tc39 and was fixed on april .
the bug in es11 was a genuine one and we reported it and received a confirmation from tc39 on august .
the bug will be fixed in the next version es12.
v. r elated work our technique is related to three research fields differential testing fuzzing and fault localization.
differential testing differential testing utilizes multiple implementations as cross referencing oracles to find semantics bugs.
researchers applied this technique to various applications domain such as java virtual machine jvm implementations ssl tls certification validation logic web applications and binary lifters .
moreover nezha introduces a guided differential testing tool withthe concept of diversity to efficiently find semantics bugs.
however they have a fundamental limitation that they cannot test specifications they use only cross referencing oracles and target potential bugs in implementations.
our n version differential testing extends the idea of differential testing with not onlyndifferent implementations but also a mechanized specification to test both of them.
in addition our approach automatically generates conformance tests directly from the specification.
fuzzing fuzzing is a software testing technique for detecting security vulnerabilities by generating or mutating test inputs.
for javascript engines patrice et al.
presented white box fuzzing using the javascript grammar han et al.
presented codealchemist that generates javascript code snippets based on semanticsaware assembly wang et al.
presented superion using grammar aware greybox fuzzing park et al.
presented dieusing aspect preserving mutation and lee et al.
presented montage using neural network language models nnlms .
while they focus on finding security vulnerabilities rather than semantics bugs our n version differential testing focuses on finding semantics bugs by comparing multiple implementations with the mechanized specification which was automatically extracted from ecmascript by jiset .
note that jest can also localize not only specification bugs in ecmascript but also bugs in javascript engines indirectly using the bug locations in ecmascript.
fault localization to localize detected bugs in ecmascript we used spectrum based fault localization sbfl which is a ranking technique based on likelihood of being faulty for each program element.
tarantula was the first tool that supports sbfl with a simple formula and researchers have developed many formulae to increase the accuracy of bug localization.
sohn and yoo introduced a novel approach for fault localization using code and change metrics via learning of sbfl formulae.
while we utilize a specific formula er1bintroduced by xie et al.
we believe that it is possible to improve the accuracy of bug localization by using more advanced sbfl techniques.
vi.
c onclusion the development of modern programming languages follows the continuous integration ci and continuous deployment cd approach to instantly support fast changing user demands.
such continuous development makes it difficult to find semantics bugs in both the language specification and its various implementations.
to alleviate this problem we present n version differential testing which is the first technique to test both implementations and its specification in tandem.
we actualized our approach for the javascript programming language via jest using four modern javascript engines and the latest version of ecmascript es11 .
it automatically generated javascript programs with .
of syntax coverage and .
of semantics coverage on es11.
jest injected assertions to the generated javascript programs to convert them as conformance tests.
we executed generated 22conformance tests on four engines that support es11 v8 graaljs quickjs and moddable xs.
using the execution results we found engine bugs for graaljs for quickjs for moddable xs and for v8 and specification bugs.
all the bugs were confirmed by tc39 the committee of ecmascript and the corresponding engine teams and they will be fixed in the specification and the engines.
we believe thatjest takes the first step towards co evolution of software specifications tests and their implementations for ci cd.