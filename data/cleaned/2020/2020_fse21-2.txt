a comprehensive study of deep learning compiler bugs qingchao shen college of intelligence and computing tianjin university school of new media and communication tianjin university china qingchao tju.edu.cnhaoyang ma college of intelligence and computing tianjin university china haoyang 9804 tju.edu.cnjunjie chen college of intelligence and computing tianjin university china junjiechen tju.edu.cn yongqiang tian cheriton school of computer science university of waterloo canada y258tian uwaterloo.cashing chi cheung department of computer science and engineering the hong kong university of science and technology china scc cse.ust.hkxiang chen school of information science and technology nantong university china xchencs ntu.edu.cn abstract there are increasing uses of deep learning dl compilers to generate optimized code boosting the runtime performance of dl models on specific hardware.
like their traditional counterparts dl compilers can generate incorrect code resulting in unexpected model behaviors that may cause catastrophic consequences in missioncritical systems.
on the other hand the dl models processed by dl compilers differ fundamentally from imperative programs in that the program logic in dl models is implicit.
as such various characteristics of the bugs arising from traditional compilers need to be revisited in the context of dl compilers.
in this paper we present the first systematic study of dl compiler bugs by analyzing 603bugs arising in three popular dl compilers i.e.
tvm from apache glow from facebook and ngraph from intel .
we analyzed these bugs according to their root causes symptoms and the stages where they occur during compilation.
we obtain findings and provide a series of valuable guidelines for future work on dl compiler bug detection and debugging.
for example a large portion nearly of dl compiler bugs are related to types especially tensor types.
the analysis of these bugs helps design new mutation operators e.g.
adding type cast for a tensor to promote implicit type conversion in subsequent tensor computations to facilitate type related bug detection.
further we developed tvmfuzz as a proof of concept application of our findings to test the tvm dl compiler.
it generates new tests based on tvm s original test suite.
they expose tvm bugs that are missed by the original test suite.
the result demonstrates the usefulness of our findings.
junjie chen is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
concepts software and its engineering compilers software defect analysis computing methodologies neural networks .
keywords deep learning deep learning compiler bug empirical study compiler testing acm reference format qingchao shen haoyang ma junjie chen yongqiang tian shing chi cheung and xiang chen.
.
a comprehensive study of deep learning compiler bugs.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
introduction deep learning dl has emerged as a promising computational paradigm to solve problems in various domains such as autonomous driving cars face recognition aircraft collision avoidance systems and software engineering .
various dl frameworks e.g.
tensorflow pytorch and keras are developed to facilitate the implementation of dl models e.g.
convolutional neural network cnn recurrent neural network rnn and generative adversarial network gan .
specific hardware has also been designed to accelerate the execution of these dl models.
examples include google tpu intel nnp and apple bionic .
driven by immense demands there are many dl frameworks and hardware products on the market.
coding efficient dl models to cater to these frameworks and hardware products is challenging .
to alleviate the burden dl compilers were proposed .
they take a dl model programmed on a dl framework as input and generate hardware optimized code as output.
multiple dl compilers are now available in the market.
the dominant ones are tvm from apache glow from facebook and ngraph from intel.
like other software systems dl compilers are subject to bugs.
buggy dl compilers can be devastating when their incorrectly generated codes are deployed for mission critical dl applications.esec fse august athens greece qingchao shen haoyang ma junjie chen yongqiang tian shing chi cheung and xiang chen besides dl compiler bugs complicate the fault diagnosis of anomalous behaviors in dl applications.
dl compilers may not share the same characteristics as traditional compilers .
on one hand the processed subjects are very different.
the dl models processed by dl compilers do not have explicit logical structures like those in the imperative programs processed by traditional compilers.
on the other hand dl compilers have their own multi level ir intermediate representation and a large number of dl specific optimizations such as operator fusion .
therefore existing test generation and bug localization techniques for traditional compilers may not work for dl compilers.
this motivates us to conduct the first systematic study on dl compiler bugs to facilitate the understanding of dl compiler bugs.
in particular we investigated the root causes of dl compiler bugs thesymptoms that bugs exhibit and the stages of a dl compiler in which bugs occur.
our study is based on three most popular dl compilers including tvm from apache glow from facebook and ngraph from intel as experimental subjects.
these three compilers are diverse in nature e.g.
the dynamic tensor shape is supported by tvm and ngraph but not glow and autotuning is supported by tvm but not the other two.
the diversity facilitates the generalizability of our findings.
we studied 603bugs that were collected and labeled manually according to a systematic process to be presented in section .
.
from our manual analysis on these dl compiler bugs we identified root causes and bug symptoms and obtained major findings.
based on these findings we provided a series of guidelines for dl compiler bug detection and debugging in the future.
in particular we further made a preliminary proof of concept application of our findings by designing a simple but effective method tvmfuzz for testing tvm.
the design of tvmfuzz is inspired by some findings in our study.
it can generate new tests based on tvm s original test suite.
we ran tvmfuzz for two days.
it detected tvm bugs that cannot be detected by tvm s original test suite.
the result demonstrates the usefulness of our findings.
to sum up we make four major contributions.
we conduct the first systematic study on dl compiler bugs based on 603bugs from three popular and diverse dl compilers.
we provide a classification of root causes of dl compiler bugs and symptoms that dl compiler bugs exhibit.
we discuss and provide a series of guidelines for dl compiler bug detection and debugging in the future.
we conduct a preliminary proof of concept application of our findings by designing a testing tool for the tvm compiler.
it exposes tvm bugs that cannot be detected by tvm s original test suite.
deep learning compilers dl models are popularly programmed on top of dl frameworks such as tensorflow pytorch and keras .
various kinds of hardware e.g.
google tpu intel nnp and apple bionic are also designed to accelerate the execution of these models.
to attain the acceleration a dl model based on a specific framework is deployed with code that is compiled for optimized execution on the deployed hardware.
various dl compilers have high level ir low level irmodel dl compilersframework deployable module hardware conversion high level optimization low level optimization model loading high level ir transformation low level ir transformation ...figure the architecture of dl compilers been developed to take a dl model as input and generate hardwareoptimized code as output.
although dl compilers are built with functional components e.g.
front end and back end similar to traditional compilers these two types of compilers have different characteristics.
firstly dl compilers take dl models as input while traditional compilers take programs as input.
there are fundamental differences in the controland data flow structures between dl models and programs.
secondly dl compilers have their own multi level ir and dl specific optimizations such as operator fusion and layout transformation .
figure shows the general architecture of dl compilers which contain the following three major stages model loading is a stage responsible to load a dl model and transform it into a computation graph representation i.e.
high level ir .
high level ir which aims to construct the control flow and the dependency between data and operators is hardware independent.
high level ir transformation is a stage responsible to conduct hardware independent optimizations on high level ir to reduce redundancy and improve efficiency.
it generates an optimized computation graph for the next stage.
the optimizations can be general purpose or dl specific.
they include node level optimizations e.g.
zero dim tensor elimination block level optimizations e.g.
operator fusion and dataflow level optimizations e.g.
layout transformation .
low level ir transformation is a stage responsible to transform high level ir to low level ir which is sufficiently fine grained to capture hardware characteristics.
the transformation also involves hardware specific optimizations such as hardware intrinsic mapping and memory latency hiding on the low level ir.
then the optimized low level ir is compiled to generate code deployed on the specific hardware.
we selected three popular dl compilers i.e.
tvm from apache glow from facebook and ngraph from intel as experimental subjects in our study.
all the three compilers are built with the architecture in figure but they are also enough diverse especially in the low level ir transformation stage.
specifically tvm adopts machine learning methods to automatically determine the optimal optimizations for a specific hardware.
glow designsa comprehensive study of deep learning compiler bugs esec fse august athens greece table statistical information on datasets compiler duration pr bug tvm glow ngraph total a lowering phase in this stage to reduce the operator space by transforming each operator into a sequence of low level primitives.
ngraph does not have its own low level ir.
its low level ir transformation is implemented by integrating existing kernel libraries e.g.
cudnn or coordinating with plainml .
methodology and classification .
data collection in the study we used the three most popular dl compilers as subjects including tvm from apache glow from facebook and ngraph from intel.
since our study aims to investigate the characteristics of dl compiler bugs we collected closed and merged pull requests that are responsible to fix bugs from their github repositories following the existing work .
the reasons why using such pull requests are twofold bugs involved in such pull requests have been accepted and fixed by developers such pull requests contain more comprehensive information e.g.
code changes links to related issues and discussions among developers about the involved bugs which facilitates to understand these bugs.
in fact there are several categories of pull requests with different purposes such as bug fixing refactoring and adding new features .
hence we need to identify the pull requests with the purpose of bugfixing among the collected pull requests for our study.
specifically following the existing study we collected the pull requests whose tags or titles contain at least one bug relevant keywords i.e.
fix defect error bug issue mistake incorrect fault and flaw and call such pull requests bug fixing pull requests .
table presents the detailed information on our datasets.
since we need to manually analyze each bug it is unaffordable for us to collect all bugs for manual inspection.
therefore we collected the bugs for a given duration i.e.
over months shown in the second column in table .
the third column presents the number of collected bug fixing pull requests for the given duration.
after obtaining bug fixing pull requests the first two authors manually analyzed and labeled them independently the process will be described in section .
and the last column presents the number of bugs identified from these bug fixing pull requests.
in total we collected bug fixing pull requests and identified 603bugs including 318tvm bugs 145glow bugs and 140ngraph bugs.
the dataset can be found at our project homepage1.
.
classification and labeling process in the study we investigated each bug from three aspects the root causes of bugs the symptoms that bugs exhibit and the stages of a dl compiler in which bugs occur.
to label the root cause symptom of each bug we adopted the taxonomies of root causes and symptoms from the existing work as the initial taxonomies and then adapted them to dl compiler bugs through an open coding scheme following the existing work .
regarding the stages of dl compilers they have been introduced in section .
more specifically one author first went through all the pull requests to determine the root cause and symptom categories of our collected dl compiler bugs based on the initial general taxonomy including adding dl compiler specific categories e.g.
node type problem and removing irrelevant categories.
then the first two authors independently labeled these pull requests.
following the existing work we measured the inter rater agreement among them via the cohen s kappa coefficient .
in particular the cohen s kappa coefficient was nearly for the first of labeling results and thus we conducted a training session about labeling.
after that the first two authors labeled of pull requests including the previous of pull requests and the cohen s kappa coefficient achieved .
after further discussion and investigation for these disagreements the cohen s kappa coefficient was always more than in subsequently labeling studies i.e.
labeling of pull requests with the interval of .
in each labeling study the first two authors discussed the disagreements with the third author and finally all the bugs were labeled consistently.
during the labeling process we filtered out the pull requests that are actually irrelevant to bug fixing.
some pull requests fixed more than one bug and we labeled each of them as an individual bug following the existing work .
.
root causes of dl compiler bugs based on the above classification and labeling process all the root causes of dl compiler bugs are presented as follows.
.
.
api misuse.
this category of bugs occur due to misunderstanding of apis including wrong api developers use a wrong api or wrong arguments in an api condition missing redundancy developers miss to use or redundantly use a condition check for an api api missing redundancy developers miss to use or redundantly use an api.
.
.
incompatibility.
this category of bugs occur under the three scenarios there are api compatibility issues within a dl compiler caused by api evolution called internal api incompatibility there are api compatibility issues between a dl compiler and third party libraries e.g.
tensorflow and numpy called external api incompatibility there are compatibility issues between a dl compiler and external resources called resource incompatibility for example the used image is too large to be incompatible with the dl compiler or some characteristics of the target device are incompatible with the dl compiler.
.
.
type problem.
this category of bugs involves type related problems such as type conversion and type inference.
according to the characteristics of dl compilers we further divide this category into three subcategories node type problem a dl compiler works on a computational graph where nodes represent the atomic dl operators such as convolution and pooling and edges represent the tensors .
each node takes zero or more tensors asesec fse august athens greece qingchao shen haoyang ma junjie chen yongqiang tian shing chi cheung and xiang chen input and produces a tensor as output.
this subcategory refers to the problem involving the types of nodes tensor type problem this subcategory refers to the problem involving the types of tensors.
specifically a tensor is a multi dimensional matrix containing elements of a single data type.
conventional data type problem besides nodes and tensors there are also conventional variables widely used in the development of traditional software systems.
this subcategory refers to the problem involving the types of conventional variables.
.
.
tensor shape problem.
this category of bugs is related to tensor shape or layout.
specifically tensor shape describes the number of elements in each dimension.
layout describes how the tensor is represented in memory which plays an important role in model performance.
these bugs are triggered during the operation of tensor shape matching tensor shape transformation tensor shape inference data layout transformation etc.
.
.
incorrect numerical computation.
this root cause involves incorrect numerical computations values or usages such as using incorrect operators or operands dividing by missing operands or redundant operands.
.
.
incorrect assignment.
this root cause involves that a variable is incorrectly initialized or assigned or a variable lacks initialization.
.
.
incorrect exception handling.
this category of bugs occurs due to incorrect exception handling for example a dl compiler does not throw an exception when it should throws an exception when it should not and provides incorrect imprecise exception messages.
.
.
misconfiguration.
this category of bugs is caused by incorrect configurations in a dl compiler such as misconfigurations in the file cmake .
.
.
concurrency.
this root cause involves incorrect operations on concurrency oriented structures e.g.
locks threads and critical regions .
.
.
incorrect code logic.
code logic refers to the implementation logic of an algorithm e.g.
an optimization on the computational graph .
this category of bugs involves a number of statements or blocks.
according to the components where bugs occur this category of bugs are divided into two subcategories incorrect optimization code logic.
optimization is an important functionality of a dl compiler.
as presented in section a dl compiler tends to contain a number of optimizations including high level optimizations and low level optimizations .
this subcategory of bugs occurs at the component of various optimizations.
incorrect non optimization code logic.
this subcategory of bugs occurs at the other components except for dl compiler optimizations.
.
.
typo.
this root cause is due to the carelessness of developers e.g.
default is mistakenly written as defualt .
.
.
others.
each case in this root cause occurs very infrequently and does not belong to any other root causes.
.
symptoms of dl compiler bugs based on the above classification and labeling process all the symptoms of dl compiler bugs are presented as follows .
.
crash.
crash means that a dl compiler terminates unexpectedly during compilation which usually produces an error message.
.
.
wrong code.
wrong code means that a dl compiler behaves in an unexpected way without a crash which produces a wrong result or middle result e.g.
the non equivalent ir after an optimization .
.
.
bad performance.
this symptom means that the time cost or memory consumption spent by a dl compiler is much larger than developers users expectation e.g.
the performance achieved on the previous version during regression testing or the performance required by specific hardware .
.
.
hang.
this symptom means that a dl compiler keeps running for a long period of time without producing the expected result.
.
.
build failure.
this symptom means that the installation of a dl compiler terminates unexpectedly.
.
.
unreported.
there are also dl compiler bugs whose symptoms cannot be identified by analyzing the corresponding pull requests including code changes discussions and related issues .
.
research questions our study aims to address the following five research questions rqs rq1 what is the occurrence frequency of different root causes of dl compiler bugs?
the root causes facilitate the understanding of the nature of dl compiler bugs which is helpful to detect localize and fix bugs.
moreover it is interesting to explore the root causes specific to dl compiler bugs and also investigate whether the conclusions on common root causes between dl compiler bugs and traditional software bugs are consistent or not.
rq2 what is the occurrence frequency of different symptoms of dl compiler bugs?
the symptoms facilitate the understanding of the consequences of dl compiler bugs which is helpful to triage them and assess their impacts.
also according to the bug symptoms it is helpful to design dl compiler testing methods with effective test oracles.
rq3 what is the relationship between root causes and symptoms of dl compiler bugs?
understanding root causes in rq1 and symptoms in rq2 is the first step to investigate dl compiler bugs.
by mapping them i.e.
understanding which root cause is more likely to produce a specific bug symptom it is helpful to provide more information to deal with bugs.
rq4 which stages in dl compilers are more fragile to bugs?
dl compilers contain three major stages and the fragility of different stages may be different.
identifying bug prone stages is helpful to guide developers to allocate their efforts during the process of dl compiler testing and maintenance.
rq5 do the bugs of different dl compilers have commonality?
identifying the relationship among the bugs in different dl compilers is helpful to design general bug detection and localizationa comprehensive study of deep learning compiler bugs esec fse august athens greece concurrencytypoothersincorrect numerical computationincorrect assignmentincompatibilitymisconfigurationincorrect exception handlingapi misusetensor shape problemincorrect code logictype problem tvm glow ngraph figure bug distribution by root causes table bug distribution by type problem subcategories compiler tensor type conventional type node type tvm glow ngraph total methods for dl compilers even achieve the goal of cross compiler bug detection.
results and analysis in this section we present and discuss the experiment results for the five rqs.
.
rq1 root causes figure shows the number of dl compiler bugs by their root causes.
from this figure type problem is the most common root cause.
it accounts for bugs including in tvm in glow and in ngraph.
table further shows the bug distribution by subcategories.
we find that tensor type problem is the most common subcategory.
specifically among bugs in type problem bugs are caused by tensor type problem bugs are caused by conventional data type problem and bugs are caused by node type problem.
this is because all the dl computations rely on one or more tensors and both ir and a large number of optimizations in dl compilers involve tensors.
moreover tensor type is an important property in a tensor.
therefore there are a large number of operations on type conversion especially implicit type conversion and type inference during compilation.
the result indicates that handling types especially tensor types in dl compilers is very challenging and deserves more attention.
figure shows an example of tensor type problem bug2 where pytorch expects the output tensor type for the operator to be float32 but the corresponding glow operator outputs float16 leading to type mismatch.
thus the fix is to add an upcast operator to convert its output tensor type to float32 .
if is4bit auto ct f.createconvertto convertembeddingbag4bitrowwiseoffsetsoutput eb elemkind floatty return addvaluemapping outputs ct getresult else return addvaluemapping outputs eb getresult return addvaluemapping outputs eb getresult figure a tensor type bug example from glow target shape tuple weight tensor shape input size for shape in enumerate input tensor shape input size shape batch size int input size weight tensor shape target shape tuple batch size weight tensor shape figure a tensor shape bug example from tvm finding type problem is the most common root cause accounting for .
of dl compiler bugs.
among these bugs tensor type problem bugs are the most common.
incorrect code logic is the second most common root cause accounting for .
dl compiler bugs including bugs caused by incorrect optimization code logic and bugs caused by incorrect non optimization code logic.
due to the rapid development of deep learning dl compilers are also frequently updated so as to incorporate the rapid advancement in dl algorithms and hardware.
moreover for new features in dl frameworks and hardware the implementation in dl compilers supporting the corresponding features tends to involve complex code logic.
therefore that may lead to various technical debts occurring in the implementation of dl compilers.
optimization code tends to be more complex than the non optimized one due to the complexity in the optimization algorithms and the handling of different kinds of hardware.
as a result the bugs arising from incorrect optimization code outnumber those arising from incorrect non optimization code.
finding code logic bugs are common due to the implementation complexity of dl compilers.
these bugs are more often caused by incorrect optimization code logic than incorrect non optimization code logic.
the third most common root cause is tensor shape problem according to figure .
it accounts for .
of bugs including in tvm in glow and in ngraph.
figure shows an example of tensor shape problem bugs3 where the fully connected converter used the shapes from the tflite model to reshape the data tensor but the tflite model shapes do not reflect those provided by the data shape parameter in from tflite .
thus the fix is that august athens greece qingchao shen haoyang ma junjie chen yongqiang tian shing chi cheung and xiang chen table distribution of api misuse bugs compilerapi m rcondition m rwrong api receiver name args total tvm glow ngraph total m r is short for missing redundancy.
the reshape is always set to n units without needing to calculate a batch size for the particular operator.
similar to the tensor type problem this root cause also concerns the tensor computation in dl and indeed tensor shape is also an important property in a tensor.
the result indicates that tensor operations are errorprone regardless the operations are type related or shape related.
therefore more care should be devoted to tensor operations in dl compilers.
finding tensor shape problem is the third most common root cause accounting for .
of dl compiler bugs.
while the root causes e.g.
tensor type problem tensor shape problem and incorrect optimization code logic specific to dl compilers are significant some root causes common to dl compilers and traditional software systems are notable e.g.
api misuse and incompatibility.
therefore we further analyzed whether they follow similar patterns or not by taking the two relatively frequent common root causes i.e.
api misuse and incompatibility as the representatives.
following the practice of existing work we divide the bugs caused by api misuse into three subcategories as shown in table .
according to the existing studies on mubench which is one of the most widely studied benchmarks in the area of api misuse and contains api misuses from real world java projects api missing redundancy is the most common cause but it is the least common in dl compilers.
in dl compilers the most common api misuses concern wrong api among which .
are caused by wrong receivers .
are caused by wrong api names and .
are caused by wrong arguments.
it suggests that developers may not often understand the correct api usage scenarios especially when multiple similar apis exist.
table presents the distribution of incompatibility bugs by subcategories.
the bug distribution differs significantly from that of dl program bugs .
for example external incompatibility .
accounts more often than internal incompatibility .
and resource incompatibility .
for dl compiler bugs while internal incompatibility accounts most often for dl program bugs.
the reason may be that the third party libraries used in dl compilers are also frequently evolving such as various dl frameworks e.g.
tensorflow has nearly commits per day on average and has already had releases till february and are relatively complex such as various fundamental libraries relevant to systems even hardware .
indeed by analyzing the external incompatibilitytable distribution of incompatibility bugs compiler internal external resource tvm glow ngraph total table bug distribution by symptoms compiler crash wc bp hang bf unreported tvm glow ngraph total wc wrong code bp bad performance bf build failure bugs bugs are due to the incompatibility with dl frameworks and bugs are due to the incompatibility with fundamental libraries relevant to systems.
finding api misuse and incompatibility bugs manifest in different ways between dl compilers and traditional software calling for different bug detection strategies.
.
rq2 symptoms table presents the distribution of dl compiler bugs by symptom categories.
it shows that crash is the most common symptom in all the three dl compilers.
there are and bugs that exhibit the crash symptom in tvm glow and ngraph respectively.
detection of crashes does not require explicit test oracles.
therefore the large percentage of crashes suggests the potentials of augmenting the existing test suite with the generated ones.
besides it suggests the opportunities to design effective localization and deduplicate methods based on the descriptive information collected from crashes.
finding crash is the most common symptom of dl compiler bugs accounting for .
of bugs.
wrong code occurs when dl compilers generate incorrectly compiled code.
it is a common symptom according to table accounting for .
tvm bugs .
glow bugs and .
ngraph bugs respectively.
the symptom is not as obvious as crash.
specifically the output of a dl compiler is an optimized model in some optimized ir.
determining the correctness of an optimized model or ir is hard due to its complexity.
therefore testing such bugs is challenging because test oracles are difficult to define.
further the adverse impact of this category of bugs is severe since the bugs could propagate to the models subsequently built using the buggy compiled code.
to sum up more attention should be paid to design effective testing methods for wrong code bugs froma comprehensive study of deep learning compiler bugs esec fse august athens greece operator int64 t const return static cast int64 t fp16 ieee to fp32 value data operator int32 t const return static cast int32 t fp16 ieee to fp32 value data operator int32 t const return static cast int32 t data operator int64 t const return static cast int64 t data ...... figure a wong code bug example from glow pr both academia and industry.
figure shows a wrong code bug example4 where glow incorrectly calls static cast onfloat16 directly when casting float16 toint32 orint64 resulting in a wrong result as float16 is defined using a proxy type uint16 t .
thus the fix is that when casting float16 tointtype it first converts it to float32 and then conducts static cast.
finding wrong code is the second most common symptom of dl compiler bugs accounting for .
of bugs.
generating high quality test oracles for wrong code bugs is challenging.
according to table the symptoms of hang and bad performance are uncommon while the symptom of build failure is nonnegligible.
there are only bugs with the hang symptom and bugs with bad performance symptom in total while the percentage of bugs with the build failure symptom ranges from .
to .
across the three compilers.
it indicates that configuring and building dl compilers require non trivial efforts.
in particular build failure bugs occurs more often in ngraph .
than in tvm .
and glow .
.
the reason may be that ngraph contains more loc lines of code in configuration files than tvm and glow and both tvm and glow provide more detailed configuration instructions than ngraph.
therefore the provision of better organized configuration options and more detailed configuration instructions in dl compilers especially ngraph is desired.
finding hang and bad performance are uncommon symptoms .
and .
while build failure is a nonnegligible symptom .
in dl compilers.
.
rq3 root causes and symptoms table presents the number of dl compiler bugs caused by each root cause with each symptom.
as the most common root cause type problem occurs in almost all categories of symptoms except build failure .
another root cause that can result in the same categories of symptoms is incorrect optimization code logic which is also common.
that is the bugs caused by type problem and incorrect optimization code logic not only occur frequently but also produce a wide variety of effects.
moreover the two categories of tend to be specific to dl compilers.
therefore more attention from both dl compiler developers and researchers should be paid to detecting localizing and fixing these bugs.
the symptom of build failure is also non negligible but are not exhibited by the bugs induced by the common root causes.
as shown in table build failure bugs are mainly caused by incorrect configuration and incompatibility.
these bugs are mostly caused by errors in configurations and dependencies.
our dataset of these bugs can facilitate the research on automated build failure fixing and dependency conflict detection for dl compiler bugs.
finding type problem and incorrect optimization code logic are common root causes of dl compiler bugs.
they can induce all kinds of buggy symptoms except build failure which is mostly exhibited by incorrect configuration and incompatibility bugs.
from table crash and wrong code are the most common symptoms of dl compiler bugs.
both can be induced by all categories of root causes except two i.e.
incorrect configuration and typo for wrong code .
therefore generating high quality test oracles around the two symptoms can detect a wide variety of dl compiler bugs.
as presented above crash has an obvious test oracle while regarding wrong code differential testing may be a potentially promising direction e.g.
comparing the output results from the three dl compilers under the same set of test inputs.
finding the symptoms of crash and wrong code can be produced by various root causes of dl compiler bugs.
.
rq4 bug prone stages figure presents the bug distribution among the three dl compilation stages.
the model loading stage is relatively less buggy than the two ir transformation stages which involve sophisticated ir optimization.
unlike tvm and glow the high level ir transformation .
of ngraph is significantly more buggy than its low level ir transformation .
.
this is because ngraph does not have its own low level ir design.
instead its low level ir transformation integrates existing kernel libraries or coordinates with plainml for hardware specific optimizations as explained in section .
through further analysis incorrect code logic especially incorrect optimization code logic is the most frequent root cause for both high level ir transformation and low level ir transformation stages.
due to a large number of dl compiler bugs induced by ir optimization a variant of differential testing i.e.
different optimization levels dol method may be adapted to detect optimization related bugs which compares the results under different optimizations.
here the characteristics of multi level ir optimization in dl compilers should be considered.esec fse august athens greece qingchao shen haoyang ma junjie chen yongqiang tian shing chi cheung and xiang chen table relationship between root causes and symptoms.
root causessymptomscrash wrong code bad performance build failure hang unreported total symptom type problem incorrect code logic tensor shape problem api misuse incorrect exception handling misconfiguration incompatibility incorrect assignment incorrect numerical computation others typo concurrency total causes .
.
.
tvm35.
.
.
glow73.
.
.
ngraph model loading high level ir transformation low level ir transformation figure bugs across stages of the dl compiler pipeline finding the high level ir transformation stage .
and the low level ir transformation stage .
are relatively more buggy than the model loading stage .
on average.
figure shows that a significant number of dl compiler bugs occur at the model loading stage which plays a role analogous to the front end in traditional compilers.
it differs from the prior findings that front end bugs are rare in traditional compilers e.g.
gcc and llvm .
it is because the model loading stage unlike traditional front ends needs to handle inputs in multiple representations adopted by various dl frameworks.
moreover the model loading stage needs to deal with various operators e.g.
convolution and pooling supported by each dl framework when transforming an input model into high level ir.
in particular different from stable front ends of traditional compilers more and more dl operators can be proposed and developed and thus dl compilers need to continually support them which could incur new bugs at the model loading stage.
as a result the model loading stage requires handling a large number of cases arising from the data representations and operations supported by fast evolving dl frameworks and libraries.
we also analyze which dl frameworks are more often to induce bugs at the model loading stage.
specifically through analyzing the front end bugs in our dataset there are bugs for which we can identify the corresponding bug inducingdl frameworks.
we find that .
.
.
.
.
.
.
.
of bugs arose from onnx pytorch tensorflow keras tflite mxnet coreml and caffe2 respectively.
this indicates that it is important to consider inputs from different dl frameworks in designing tests for the model loading stage.
finding unlike traditional compilers a significant proportion of bugs .
on average across the three dl compilers occur at the model loading stage.
.
rq5 commonality to measure the commonality across dl compilers we calculated the spearman correlation between each pair of dl compilers in terms of root cause distribution and symptom distribution.
spearman s correlation coefficient is a statistical measure of the strength of a monotonic relationship between two paired variables .
figure shows the correlation results.
we find that all the correlation coefficients are larger than .
in terms of root causes and all the correlation coefficients are in terms of symptoms.
this demonstrates that the three dl compilers share a very high degree of commonality in the root causes and symptoms of bugs.
it suggests the generalizability of the findings in this study as well as the feasibility to develop solutions that can be generalized to different dl compilers for the detection localization and fixing of dl compiler bugs.
finding the three dl compilers share significant commonality in the root causes and symptoms of bugs.
discussion .
implications we discuss the implications on the detection and debugging of dl compiler bugs according to our findings.a comprehensive study of deep learning compiler bugs esec fse august athens greece .
.
.
1tvm glow ngraphtvm glow ngraph1 .
.
.
a root causes correlation .
.
.
1tvm glow ngraphtvm glow ngraph1 b symptoms correlation figure correlation among dl compilers according to findings and a large proportion of bugs are related to the type and shape of tensors in dl computation.
therefore new criteria can be defined to measure the test coverage of tensor type and tensor shape .
existing mutation based coverage can be adapted to include representative mutation operators on tensor type and shape accordingly.
for example we find that dl compilers are more fragile in implicit type conversion data layout transformation and tensor shape matching.
therefore new mutation operators should include adding typecast for a tensor to promote implicit type conversion in tensor computations replacing a tensor with another one with a different layout to trigger data layout transformation and insert some new layers with diverse shapes to detect tensor shape mismatching.
a large proportion of these bugs are manifested as crashes.
these bugs can be detected if they are triggered.
as such new methodologies can be developed to search for effective tests based on the adapted coverage criteria.
according to findings and crash and wrong code are the two most common bug symptoms that can be exhibited by dl compiler bugs due to all kinds of root causes.
even though detecting crash bugs has an obvious test oracle the crash messages reported by many crash bugs are ambiguous.
the ambiguity can affect the localization and fixing of bugs.
analyzing the crash bugs in our dataset we find the crash messages of nearly of bugs were rephrased to provide more information after their fixes.
moreover we find some users complained that crash messages are not informative in their issue reports using the words such as the error message is confusing and unhelpful error message .
therefore it is necessary for developers to provide precise and informative error messages which could facilitate the understanding of crash bugs and the design of automated localization methods.
regarding wrong code bugs it is difficult to define test oracles to detect them.
to facilitate their detection one potential direction is to transform some wrong code bugs to crash bugs by adding more checks e.g.
assertions in dl compilers .
that is it is important for researchers to explore where to check andwhat to check in dl compilers.
even though this solution could relieve the efforts of detecting wrong code bugs to some degree the task of adding assertions manually is non trivial.
therefore the design of high quality oracle to detect wrong code bugs is still a challenging problem to the quality assurance of dl compilers.
this problem deserves more attention from the software engineering community.
findings and suggest that optimization related bugs occur frequently and can lead to almost all kinds of symptoms.
therefore designing tests that can trigger various optimizations and theircombinations is a promising research direction .
in particular the mechanism of multi level optimizations should be considered when designing tests.
moreover a large number of optimizations can be involved during the compilation of a dl model and thus it is also useful to design automated localization techniques for identifying the buggy optimizations to improve the quality of dl compilers.
finding discusses the differences in the common root causes i.e.
api misuse and incompatibility between dl compilers and traditional software systems.
the differences show that the two categories of dl compiler bugs manifest in different ways from those of traditional software systems.
it suggests that different bug detection strategies should be designed for dl compilers .
specifically api misuses in dl compilers are mainly due to invoking the wrong apis .
of api misuse bugs but existing api misuse detection techniques for general software mainly focus on apimissing redundancy.
thus incorporating api recommendation knowledge to api misuse detection for dl compilers is useful which could help distinguish usage scenarios of different apis even though they have very similar names by mining code snippets.
for incompatibility bugs .
of them are caused by external incompatibility especially the incompatibility with various dl frameworks and fundamental system libraries.
therefore adding version checks for these third party libraries is helpful to avoid many incompatibility bugs.
moreover our dataset of external incompatibility bugs may facilitate the research on dependency conflict detection for dl compilers.
dependency conflict detection has been an important topic in the software engineering community .
as shown in finding front end bugs in traditional compilers are rare but the number of dl compiler bugs in the model loading stage analogous to the front end is non trivial due to the diverse input representations from various dl frameworks.
moreover different dl frameworks can cause dl compilers to make mistakes at model loading as presented in section .
.
it suggests that this stage also deserves attention during the process of dl compiler bug detection.
meanwhile it is necessary to consider various dl frameworks when constructing tests .
.
threats to validity internal threat.
the internal threat to validity mainly lies in our manual classification and labeling of dl compiler bugs which may have subjective bias or errors.
to reduce this threat we referred to the previous taxonomies of root causes and bug symptoms as the initial taxonomies and then adopted an open coding scheme to update the taxonomies to fit dl compiler bugs.
during the labeling process the first two authors independently labeled dl compiler bugs with the supervision of cohen s kappa coefficient .
any disagreement was discussed with the third author until a consensus is reached.
more details about our classification and labeling process can be found in section .
.
external threat.
the external threat to validity mainly lies in the datasets used in our study.
to reduce this threat we systematically collected dl compiler bugs as presented in section .
.
in particular we only considered closed and merged pull requests that are responsible to fix bugs since the bugs involved in these pull requests have been fixed and accepted by developers.
to guarantee the generalizability of our study we used three popular andesec fse august athens greece qingchao shen haoyang ma junjie chen yongqiang tian shing chi cheung and xiang chen diverse dl compilers as subjects and studied dl compiler bugs in total by balancing the effort of manual analysis and the study scale.
moreover we conducted the analysis about commonality as presented in section .
whose results demonstrate the significant commonality in the root causes and symptoms of bugs across all the three dl compilers.
a preliminary application in this section we demonstrate the usefulness of our findings with a preliminary proof of concept application tvmfuzz5 which aims to generate unit tests for the stage of high level ir transformation in tvm based on existing tvm tests.
in the preliminary application we selected tvm due to its great popularity.
specifically tvmfuzz leverages two findings a bugs arising from tensor type and tensor shape are common and b high level ir transformation is the most error prone dl compiler stage.
first tvmfuzz constructs a directed graph for the calling relationship of those tvm apis involved in a set of existing unit tests for the high level ir transformation stage .
second it randomly selects a subgraph and then constructs a new unit test by considering legitimate api call dependencies in this subgraph and randomly mutating the tensor type tensor shape node name and the primitive value of tensor elements .
tvmfuzz repeatedly performs the second step until the testing process terminates.
we applied tvmfuzz to tvm via differential testing and the test oracle is whether a test produces consistent results between two tvm versions.
we conducted experiments to evaluate the effectiveness of tvmfuzz by producing new tests based on the existing tests in tvm v0.
which is the latest release version of tvm.
we deployed tvmfuzz on tvm v0.
and v0.8dev the latest version under development for two days which include the time to produce and execute the new tests.
finally tvmfuzz detected crash bugs further confirming finding in our study including bugs in tvm v0.
and bugs in tvm v0.8dev.
regarding the crash bugs in tvm v0.
all of them cannot be detected by the existing tests in tvm v0.
.
the bugs have been fixed in the latest version under development v0.8dev.
this demonstrates that the generated tests by tvmfuzz are able to effectively augment the existing test suite.
regarding the crash bugs in tvm v0.8dev after our manual inspection we have submitted them to the tvm developers and are awaiting their responses.
please note that the false positives of tvmfuzz are rare i.e.
there is only one false positive in our experiment via our manual inspection and communication with tvm developers.
table presents the details of the detected bugs by tvmfuzz.
we found that bugs are caused by type problem bugs are caused by tensor shape problem and bugs are caused by incorrect exception handling.
although this is a preliminary application a simple testing tool with short testing time several bugs have been detected by tvmfuzz and these bugs cannot be detected by the original test suite in the corresponding tvm version.
the results demonstrate the usefulness of our findings.
please note that the effectiveness of tvmfuzz generated unit tests depends on the adequacy of existing 5the implementation and results of tvmfuzz can also be found at our project homepage bugs detected by tvmfuzz version root cause status v0.
type problem fixed v0.
type problem fixed v0.
type problem fixed v0.
tensor shape problem fixed v0.
tensor shape problem fixed v0.8dev incorrect exception handling awaiting v0.8dev incorrect exception handling awaiting v0.8dev incorrect exception handling awaiting unit tests.
it is independent of data dimension and complexity as data are handled by the same api calls in existing unit tests.
related work empirical studies on bugs.
there are a number of empirical studies on bugs in the literature .
the most related ones to ours are the empirical studies on traditional compiler bugs .
for example sun et al.
conducted an empirical study to analyze the duration priority fixes test cases and locations of gcc and llvm bugs.
zhou et al.
conducted an empirical study to investigate the optimization bugs in gcc and llvm.
also there are some empirical studies on dl program bugs.
for example islam et al.
and zhang et al.
conducted empirical studies on dl program bugs such as tensorflow program bugs.
jia et al.
investigated the bugs inside the tensorflow framework.
garcia et al.
conducted an empirical study on the bugs of autonomous vehicles a kind of important dl based applications .
humbatova et al.
studied the taxonomy of dl programs bugs which includes layer related and training related categories.
in addition there are some work on dl testing including dl model testing dl program testing and dl library testing .
furthermore there are also many studies on bugs in other software systems.
for example lu et al.
conducted an empirical study on concurrency bugs.
franco et al.
conducted an empirical study on numerical bugs.
han and yu studied the performance bugs of highly configurable software systems and wan et al.
characterized the bugs of blockchain systems.
different from the previous studies we target dl compiler bugs.
as presented in section dl compilers have different characteristics from traditional compilers e.g.
gcc and llvm .
moreover dl compilers are one of the most important infrastructures for deep learning which have different roles and characteristics with dl programs and dl frameworks.
specifically dl compilers take trained dl models as inputs.
our taxonomy includes dl compiler specific categories e.g.
node type problem dl compilers need determine node type before many operations and incorrect optimization code logic dl compilers enact specific optimizations customized to various hardware .
to our best knowledge we are the first to characterize dl compiler bugs.
traditional compiler bugs.
besides the above mentioned empirical studies on traditional compiler bugs there are a number of studies on testing and localizing traditional compiler bugs in thea comprehensive study of deep learning compiler bugs esec fse august athens greece literature for example yang et al.
developed csmith the most widely used c test program generation tool to test c compilers.
le et al.
proposed emi which relies on a pair of equivalent test programs under a set of inputs to test c compilers.
chen et al.
proposed diwi to localize the buggy compiler file by generating a set of effective witness test programs.
also regehr et al.
proposed creduce to reduce a bug triggering test program to a minimal one that is still able to trigger the compiler bug.
different from them our work focuses on dl compilers rather than traditional compilers.
due to their significant differences presented in section the existing testing and debugging methods in traditional compilers cannot be directly applied to dl compilers.
that is there is no work directly targeting dl compiler testing and debugging.
therefore as the first empirical study on dl compiler bugs we believe that our work is helpful to design effective testing and debugging methods specific to dl compilers.
in particular we have conducted the first attempt to design a simple tvm testing tool tvmfuzz according to our findings and our preliminary study demonstrates the effectiveness of tvmfuzz by detecting crash bugs that cannot be detected by existing tests in the corresponding tvm version.
conclusion dl compilers can significantly alleviate the burden of deploying and optimizing dl models programmed on top of various dl frameworks to various hardware and have been become one of the most fundamental and important software infrastructures in dl.
however it is inevitable for them to have bugs like traditional compilers.
their bugs could be propagated to dl models compiled by them and produce unexpected even dangerous model behaviors during the real model usage.
therefore it is necessary to guarantee the quality of dl compilers.
in this paper we conducted the first comprehensive study to understand dl compiler bugs so as to promote the design of effective bug detection and debugging techniques.
specifically we manually studied bugs from three popular and diverse dl compilers i.e.
tvm glow and ngraph identified root causes and bug symptoms and obtained major findings.
based on these findings we provide a series of guidelines for dl compiler bug detection and debugging in the future and make the first attempt to design a simple but effective tvm testing tool i.e.
tvmfuzz .
during the testing period of two days it generates new tests based on existing tests in tvm and detects tvm bugs that cannot be detected by tvm s original test suite which can demonstrate the practical potentials of our findings.