intelligent rest api data fuzzing patrice godefroid microsoft research usa pg microsoft.combo yuan huang princeton university usa byhuang princeton.edumarina polishchuk microsoft research usa marinapo microsoft.com abstract the cloud runs on rest apis.
in this paper we study how to intelligently generate data payloads embedded in rest api requests in order to find data processing bugs in cloud services.
we discuss how to leverage rest api specifications which by definition contain data schemas for api request bodies.
we then propose and evaluate a range of data fuzzing techniques including structural schema fuzzing rules various rule combinations search heuristics extracting data values from examples included in rest api specifications and learning data values on the fly from previous service responses.
after evaluating these techniques we identify the top performing combination and use this algorithm to fuzz several microsoft azure cloud services.
during our experiments we found 100s of internal server error service crashes which we triaged into unique bugs and reported to azure developers.
all these bugs are reproducible confirmed and fixed or in the process of being fixed.
ccs concepts software and its engineering software testing and debugging correctness networks cloud computing .
keywords rest apis json data fuzzing api data payload testing cloud security and reliability acm reference format patrice godefroid bo yuan huang and marina polishchuk.
.
intelligent rest api data fuzzing.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
introduction cloud computing is exploding.
today most cloud services such as those provided by amazon web services and microsoft azure are programmatically accessed through rest apis both by third party applications and other services .
rest apis are implemented on top of the http s protocol and offer the work of this author was mostly done at microsoft research.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
uniform way to manage cloud resources.
cloud service developers can document their rest apis using interface description languages like swagger recently renamed openapi .
a swagger specification describes how to access a cloud service through its rest api including what requests the service can handle what responses may be received and the request and response formats.
rest apis can be very complex.
for instance rest apis of azure services are described in millions of lines of swagger code publicly available on github .
to master this complexity new tools are needed to prevent expensive outages and sla violations due to service bugs .
tools for automatically testing cloud services are still in their infancy.
several fuzzing1tools for rest apis fuzz and replay manually defined or previously captured api traffic to try finding bugs .
perhaps the most advanced and recent tool in this space is restler which performs stateful rest api fuzzing .
given a swagger specification restler automatically generates sequences of requests in order to reach deeper service states and find more bugs.
without requiring pre recorded api traffic restler can find bugs such as unhandled exceptions service crashes which are detected as internal server error responses.
the data payloads sent in rest api request bodies can be very complex as well.
as an example the azure dns service maps domain names to ip addresses following mapping rules defined by users these rules are specified using json data with variable size arrays strings and numerical values that are sent in bodies of rest api requests see section .
what happens when such arrays are re ordered or swapped or made very large or strings are replaced by numerical values or parameters are dropped or duplicated?
can the dns service handle all these cases?
in this paper we study how to intelligently generate data payloads embedded in rest api requests to find data processing bugs in cloud services.
by intelligently we mean fuzzing techniques that can find bugs even with a limited testing budget.
for instance simpleblackbox random fuzzing works well for binary formats but is ineffective for structured json data because the probability of generating new interesting inputs is extremely low .
symbolicexecution based whitebox fuzzing or simpler code coverageguided greybox fuzzing are not applicable because the cloud service under test is a remote distributed black box.
support for fuzzing complex rest api data payloads is also very limited in existing rest api fuzzing tools.
for instance restler can only replace body values by other values of the same type selected from a user defined dictionary of fixed values .
this paper aims to fill this void.
specifically we explore how to leverage rest api specifications which by definition contain 1fuzzing means automatic test generation and execution with the goal of finding security vulnerabilities.esec fse november virtual event usa patrice godefroid bo yuan huang and marina polishchuk etag string properties registrationvirtualnetworks id string maxnumberofrecordsets numberofrecordsets nameservers zonetype enum registrationvirtualnetworks id string resolutionvirtualnetworks id string id string name string type string location string tags string string figure example of rest api json body schema.
data schemas for api request bodies.
we then propose and systematically evaluate a wide range of data fuzzing techniques.
we proceed in several stages to evaluate the benefit that each technique provides.
we start with simple structural schema fuzzing rules which modify the tree structure or data types of json data section .
then we study combinations of individual fuzzing rules to identify synergies or redundancies among them section because rule combinations generate so much fuzzed data we also evaluate several search heuristics to deal with this combinatorial explosion.
next we propose and evaluate two new techniques for generating specific concrete data values that typically need to be provided throughout a body schema we discuss how to extract data values from examples included in rest api specifications and how to learn data values on the fly from previous service responses section .
after evaluating all these techniques we identify the best combination and use this algorithm to fuzz several microsoft azure cloud services section .
during our experiments we found 100s of internal server error service crashes which we triaged into unique bugs and reported to azure developers.
all these bugs are reproducible confirmed and fixed or in the process of being fixed.
we discuss related work in section and conclude in section .
background and motivation most cloud services are programmatically accessed through rest apis .
swagger also known as openapi is a popular specification language to define rest apis .
for instance most public microsoft azure services have swagger api specifications available on github .
a swagger specification describes how client requests can create put post monitor get update put post patch and delete delete cloud resources.
cloud resource identifiers are specified in the path or the body of the request.
typically put post and patch api requests require additional input parameter values to be included in the request body.
such parameter values and their format are described in a json dataschema that is part of the api specification.
a combination of concrete input parameter values included in a request body is called a body payload .
as an example figure shows the schema for the body of the request put dns zone that creates a new dns zone in azure see under the directory specification dns .
this schema can be viewed as a tree with nodes.
for instance the root node on line is an object which has children.
the first child is named etag line and is of type string .
the second child is an object named properties line .
this object has itself a child named registrationvirtualnetworks line of type array denoted with and so on.
in line the node zonetype is of enum type and takes any value among the specified array of constants here either the string constant public orprivate .
in line tags is an object which can have key value pairs as children where both the key and value are of type string .
because this schema includes objects arrays and strings of a priori unbounded sizes as well as numerical values there are infinitely or astronomically many ways to generate concrete inputparameter values i.e.
payloads satisfying the schema.
worse there are even more ways to generate body payloads violating the schema which may also be worth testing in order to find bugs in the code processing api requests.
also rest api data schemas are sometimes much larger than this simple example.
given a rest api data schema what are the most effective testgeneration techniques to fuzz the body of rest api requests?
the purpose of this paper is to address this question.
many api requests with non empty bodies are used to create or update service resources that can be reached only after creating parent resources.
for instance the azure dns service consists of request types and only of these have non empty bodies a putrequest to create a dns zone and whose body schema of nodes is shown in figure a patch request to update a dns zone with a schema of only nodes a putrequest to create a dns record set with a schema of nodes and a patch request to update a dns record set with a schema of nodes.
a valid dns zone identifier must be provided in the path of a putrequest that creates a dns record set because a dns record set is a child resource of a parent dns zone .
in order to reach deeper service states where child resources can be created hence increasing the number of requests with nonempty bodies we can fuzz we build upon recent work on stateful rest api fuzzing .
specifically we leverage the tool restler which performs an initial static analysis of a swagger specification to infer the parent child dependencies and generate sequences of requests instead of single requests to reach such deeper states.
a test suite generated by restler attempts to cover as much as possible of the input swagger specification although full specification coverage is not guaranteed.
while testing a service restler reports allinternal server error responses http status code .
these are unhandled exceptions service crashes that may severely damage service health.
in this work we investigate how to extend stateful rest api fuzzing in general and restler in particular by intelligently fuzzing rest api data body payloads to find even more internal server error bugs in service code that processes complex data.intelligent rest api data fuzzing esec fse november virtual event usa example schema nodes v root tag properties id time edges e root tag root properties properties id properties time type t root object t tag string t properties object t id string t time integer1 example payload tag global properties id abcd time root tag properties id time object string integer figure example of schema and payload.
in the next sections to we propose various json payload data fuzzing techniques and we evaluate their effectiveness using the azure dns service as a benchmark.
on the one hand the dns service is a real non trivial with body schemas up to nodes widely used azure service.
on the other hand it is small enough request types to run many experiments quickly in hours and simple enough to allow non experts to analyze results.
schema fuzzing in this section we define schema fuzzing rules that take as input a body schema and return a set of fuzzed schemas .
.
schema and fuzzed schema a request body schema is encoded in the json format.
it can be viewed as a tree in which each node corresponds to a property field and is labeled with a type.
formally a schema is defined as a treestructure g v e t where vis a set of nodes e p q p q v is a set of edges string integer boolean object array is a set of supported types and t v is a type labeling function mapping each node to one type.
a fuzzed schema is defined similarly.
figure shows an example of schema with five nodes an example of a concrete json payload satisfying the schema and a pictorial representation of the schema tree structure with its labeled types.
.
schema fuzzing rules given a schema g aschema fuzzing rule modifies its tree structure vande or its type labeling function t to generate a setof fuzzedschemas.
moreover a schema fuzzing rule can be applied once or multiple times to a given schema.
.
.
node fuzzing rules.
anode fuzzing rule defines how to modify a node in a schema.
in our schema fuzzer we implemented four node fuzzing rules drop select duplicate and type .
drop.
given an internal node n vin the schema g v e t the node fuzzing rule drop removes one child node cof node n where n c e. other child nodes remain unchanged.
a original schema b single c path d allfigure the original schema and the fuzzed schemas generated by applying the node fuzzing rule drop using different tree fuzzing rules single path and all .
select.
given an internal node n vin the schema g v e t the node fuzzing rule select keeps only one child node cof node n where n c e. all other child nodes of nare removed.
duplicate.
given an internal node n vin the schema g v e t the node fuzzing rule duplicate adds a new child node rtonby copying an existing child cofn.
the descendant nodes of c i.e.
the subtrees are also copied.
type.
the node fuzzing rule type changes the labeled type of a node n vin a schema g v e t and generates a fuzzedschema g v e t where t n t n .
note that changing the type of an internal node may have side effects on the tree structure e.g.
changing an array to a string removes all the child nodes .
in contrast changing the type of a leaf node to object or array preserves the tree structure because those objects or arrays are empty.
.
.
tree fuzzing rules.
atree fuzzing rule defines how to apply a node fuzzing rule over a schema tree to produce a new fuzzedschema tree.
in our fuzzer we implemented three different tree fuzzing rules single path and all.
single.
given a node fuzzing rule and a schema the tree fuzzing rulesingle applies the node fuzzing rule on one single node while keeping all other nodes unchanged.
the rule single applied exhaustively on the entire schema tree yields the smallest set of fuzzedschema variants linear in the original schema size .
path.
given a node fuzzing rule and a schema the tree fuzzing rule path selects a path in the schema tree then selects a set of nodes on that path and finally applies the node fuzzing rule to every node in that set.
the tree fuzzing rule explores more structural and type variants than single does.
however multiple sibling nodes will never be modified.
all.given a node fuzzing rule and a schema the tree fuzzing rule allselects a set of nodes in the schema tree then applies the node fuzzing rule to every node in that set.
this rule generalizes both single andpath but can generate exponentially many fuzzedschema variants.esec fse november virtual event usa patrice godefroid bo yuan huang and marina polishchuk figure a shows an example schema a tree of eight nodes with labeled types.
given this schema figure b c and d shows one fuzzed schema that can be generated by applying drop using single path and all respectively.
the node fuzzing rule drop is applied to the dash circled highlighted nodes.
.
experimental evaluation to evaluate the effectiveness of these node and tree fuzzing rules we performed experiments with various fuzzing rule combinations using the azure dns service as a target.
.
.
evaluation metric.
the cloud services we aim to fuzz are black boxes to us we cannot instrument their code to measure code coverage.
in order to evaluate fuzzing effectiveness in a consistent way not just by counting bugs found since bugs are rather rare we introduce a new coverage metric for cloud services tested through rest apis the response error type coverage metric .
error code.
when a service fails to process a request it returns anerror code to notify the client of this failure.
minimally every rest api request returns an http status code which is in the 40xrange when the failure is triggered by an invalid yet handled request or in the 50xrange for unhandled conditions or generic failures to process the request.
in addition a service may define its own finer grained error code that includes domain specific information.
for the dns service example a response with the error code domainnamelabelmissing may be received if the request body payload does not provide the required labeling.
error message.
in addition to an error code the response for a failed request typically also includes an error message .
this message is valuable in that it further describes how the payload is being processed especially when the same error code is used for many invalid requests.
for example the error messages the resource record is missing field target and record type srv is not supported for referencing resource type dnszones both return the same error code badrequest .
these two messages provide additional context for the errors which cannot be distinguished by using the error code alone.
error type.
we define an error type as a pair of error code and error message.
error messages are sanitized by removing runtime specific information such as timestamps session ids guids etc.
the number of distinct error types is used as the effectiveness metric in our experiments we will favor fuzzing techniques that maximize error type coverage.
.
.
experiment settings.
we implemented our body schema fuzzer as an extension of restler .
in all the experiments reported in this paper we run restler under its test mode where it attempts to generate one valid response for every request type .
when restler tests a request type for the first time our new schema fuzzer is called to generate variants of the body payload of that request.
thus our payload schema fuzzer is called once for each request type with a non empty body schema.
we experimented on all combinations node fuzzing rules and tree fuzzing rules under a maximum bound of fuzzedschemas per request type.
thus if any combination generates more than fuzzed schemas only the first will be tested.
we 020406080100120schema fuzzing ruleserror types each point represents a unique error type drop single total drop pa th total drop all total sel ect s ingle t ot al sel ect pat h total sel ect a ll t ot al type si ngle total type path total type al l total duplicate singl e tota l duplicate path total duplicate all tota l figure error type coverage for each schema fuzzing rule.
systematically enumerate possible fuzzed schemas and the process is deterministic.
since dns has request types with non empty payloads at most fuzzed schemas were tested per node tree fuzzing rule pairs.
given a fuzzed schema a json payload is rendered by filling in concrete values based on the labeled type of each leaf node.
in this experiment we use fuzzstring false and for leaf nodes labeled with type string integer boolean object and array respectively.
the value rendering is only based on the labeled types.
we will discuss other value rendering strategies in section .
.
.
experiment results.
figure shows the error types discovered by the schema fuzzing rules node tree fuzzing rule pairs .
each column represents a unique error type whereas each row reports which error types were found by the specific schema fuzzing rule.
the total count for each rule is shown in the legend.
drop and select.
for node fuzzing rules drop andselect using thepath tree fuzzing rule covers more distinct error types than using other tree fuzzing rules.
both drop andselect modify a schema by removing nodes from the original tree.
a removed node can be either a required property or optional and used only under certain conditions e.g.
in the absence of another node .
therefore applying such structural modifications on different nodes i.e.
path and all is effective.
however since allgenerates an exponential number of fuzzed schemas and the fuzzing budget is limited it ends up testing many redundant combinations before quickly running out of budget.
in contrast path modifies the nodes along a single path restricting the fuzzing combinations of descendants of sibling nodes.
since child nodes of sibling nodes are usually independent path avoids generating many useless combinations of independent sub trees.
therefore the tree fuzzing rule path works best for node fuzzing rules drop andselect when the budget is limited.
type.
the node fuzzing rule type modifies a schema by changing the labeled types of its nodes.
as shown in figure there is some overlap between the error types triggered by drop select and type .
this is due to the structural side effects of the node fuzzing rule type as discussed in section .
.
.
in addition to structural side effects type may also introduce deserialization errors caused by type mismatches which often terminate the payload parsing process immediately.
this makes it less effective to apply the node fuzzing rule type on multiple nodes at a time i.e.
path andall .intelligent rest api data fuzzing esec fse november virtual event usa by analyzing the results further data not shown here we also see that changing the types of internal nodes is as effective as changing the types of leaf nodes.
further when changing the labeled type of a node the new type matters.
for example changing a string typed node to an integer or an object can trigger different error types.
duplicate.
the node fuzzing rule duplicate in contrast to drop and select modifies a schema by adding new nodes to the original tree.
this can introduce the duplicate keys error when inserting a duplicate key value pair to an object typed node.
in other words the payloads rendered from such fuzzed schemas will violate the json format and thus result in deserialization errors.
therefore applying this kind of modification on multiple nodes at a time i.e.
path andall does not provide much benefit although it consumes a great portion of the limited budget.
rules are complementary.
although the node fuzzing rules drop and select discover fewer error types there are some error types that cannot be triggered by type orduplicate .
they are usually tree structure related for example the error type with the error code locationrequired is only discovered by drop andselect .
similarly there are deserialization related error types that are uniquely triggered by either type orduplicate .
error types covered by multiple fuzzing rules are mostly due to bad value rendering e.g.
expect fully qualified resource id that start with ... rather than due to a fuzzed structure or type.
.
.
conclusion.
the tree fuzzing rule single works best for node fuzzing rules that trigger deserialization errors such as type and duplicate .
the tree fuzzing rule path works best for node fuzzing rules that modify the tree structure without introducing deserialization errors such as drop andselect .
different node fuzzing rules are able to discover different kinds of error types and are thus complementary.
all the above observations hold for every single dns request type with a non empty body schema.
from these conclusions we select schema fuzzing rules as the building blocks of our payload fuzzer drop with path denoted drop select with path denoted select duplicate with single denoted duplicate and type with single denoted type .
combining schema fuzzing rules in this section we combine multiple schema fuzzing rules in pipelines and evaluate the effectiveness of such combinations.
.
pipelining schema fuzzing rules since the schema fuzzing rules drop select duplicate and type are complementary perhaps combining these could trigger even more error types in the service under test.
to explore this idea further we combine schema fuzzing rules in a sequential pipeline one fuzzing rule is applied to an initial body schema and generates a set of fuzzed schemas then a second fuzzing rule is applied to all these fuzzed schemas and generates even more fuzzedschemas and so on.
for example consider a two stage pipeline denoted as drop type with its first stage associated with the schemafuzzing rule drop and the second stage associated with type .
it first takes an original schema gand generates a set of fuzzed schemas drop g g1 g2 .
.
.
gn by applying the schema fuzzing rule drop .
it then applies type to every gi drop g to get the final set of fuzzed schemas drop type g gi drop g type gi .
.
search heuristics.
since pipelining schema fuzzing rules results in enormous numbers of new fuzzed schemas but fuzzing budgets are limited we propose and evaluate heuristics to select fuzzed schemas generated by pipelining fuzzing rules depth first df breadth first bf and random rd .
depth first df .
given a maximum bound m the search heuristicdfgenerates fuzzed schemas in depth first order with respect to the pipeline stages and selects the first mfuzzed schemas.
for example with df a two stage pipeline drop type takes an initial input schema g generates a first fuzzed schema g1 drop g and then generates the set type g1 of fuzzed schemas.
it then continues generating fuzzed schemas type gi for other giindrop g one by one until the bound mis reached.
in other words the search heuristic dfprioritizes more fuzzing in the later stages than in the earlier stages.
breadth first bf .
in contrast to df the search heuristic bfprioritizes fuzzing more in the earlier stages by generating fuzzedschemas in breadth first order.
for example with bf a two stage pipeline drop type taking as input an initial schema gfirst generates all fuzzed schemas giindrop g then it will generate the fuzzed schemas in type gi for some gi drop g and so on up to the given bound m. random rd .
while dfandbfprioritize fuzzing in either the later or earlier pipeline stages respectively the search heuristics rduses a random search order that does not favor specific stages.
for example with rdand some random seed a two stage pipeline drop type taking as input an initial schema gfirst generates some fuzzed schema g1 drop g then generates some fuzzed schema g2 type g1 then generates some fuzzed schema g drop g then generates some fuzzed schema g type g and so on until the given bound mis reached.
.
experiments to study the effectiveness of combining schema fuzzing rules as a pipeline we compare various rule combinations under different search heuristics.
.
.
experiment settings.
similar to the experiments of section .
we fuzz the azure dns service.
each schema fuzzing rule pipeline regardless of the search heuristic is bounded by a maximum number of fuzzed schemas per request type.
for value rendering we use the same type value mapping as in section .
.
we compare different rule combinations and search heuristics based on the error types obtained from responses.
rule combination.
based on the results in section .
we group the four schema fuzzing rules into three groups drop and select that discover structure related errors type that triggersesec fse november virtual event usa patrice godefroid bo yuan huang and marina polishchuk 050100150schema fuzzing rule pipelines error types each point represents a unique error type dr op total select total dr op select total select drop total type tota l type type total du plicate to tal du plicate dupl ic ate total type drop total type select total dr op typ e total select type total dr op select type total select drop type total du plicate drop total du plicate select total dr op duplicate total select duplicate total dr op select dup licate total select drop duplicate total du plicate type total type dupli ca te total select drop duplicate type to tal figure error type coverage for each schema fuzzing rule pipeline search heuristic rd random seed .
deserialization errors due to type mismatches and duplicate that discovers deserialization errors triggered by malformed json request payloads duplicated keys .
the three schema fuzzing rule groups tend to have disjoint error type coverage.
in this experiment we implemented 23schema fuzzing rule pipelines to cover different combinations of the three groups.
for example we have two pipelines type duplicate andduplicate type for combining the second and third groups.
search heuristic.
to compare how the search heuristics affect the schema fuzzing rule pipelines given a limited budget we ran all the 23pipelines using df bf and rd.
experiments with rdare repeated five times using five different random seeds and .
each pipeline will thus be evaluated times in total.
the only source of randomness is in rdwith a random seed whereas dfand bfare deterministic.
.
.
experiment results.
rule combination.
figure compares the error type coverage of each schema fuzzing rule pipeline when using the rdsearch heuristic with a random seed .
it includes the results of all four dns request types with non empty body schemas.
pipelines combining drop select and type are marked in squares.
pipelines combining error types tested fuzzed schemas a put dns zonedfbfrd error types tested fuzzed schemas b put dns record setdfbfrdfigure the growth trends of the number of error types discovered over the number of tested fuzzed schemas schema fuzzing rule pipeline select drop duplicate type .
drop select and duplicate are marked in diamonds.
pipelines combining type andduplicate are marked in crosses.
the pipeline that combines all the three groups i.e.
select drop duplicate type is marked in triangles.
as a baseline pipelines that do not combine multiple groups are marked in circles.
we can observe the following.
combining schema fuzzing rules drop select and type as a pipeline is beneficial in that it helps discover newerror types that are not triggered by drop select or type alone.
furthermore based on a finer grained analysis of the results having drop orselect at stages earlier than type usually has a better error type coverage than the opposite.
on the other hand combining duplicate with other schema fuzzing rules does not provide significant improvements although the total number of covered error types is higher the coverage is mostly the union of the individual ones.
note that the above observations hold for all runs with different search heuristics not only just the one using rdwith a random seed .
search heuristic.
figure compares how the total number of covered error types grows as additional fuzzed schemas are tested using different search heuristics.
these results are obtained by applying the pipeline select drop duplicate type to the requests put dns zone andput dns record set shown in parts a and b respectively.
the dashed blue and dotted orange lines correspond to using dfandbf respectively while the gray line showsintelligent rest api data fuzzing esec fse november virtual event usa the average of all runs using rd.
the gray bars show the variation ranges among the runs using different random seeds.
from these experiment results we see that using rd regardless of the random seed used provides a more stable growth rate.
this is desirable and important when only a subset of the fuzzed schemas the first few generated can be tested given a limited fuzzing budget.
remarkably besides the two configurations a and b shown in figure we observed data not shown here similar conclusions for all experimented schema fuzzing rule pipelines and for all dns request types with non empty body schemas.
this indicates that the search heuristic rdis effective regardless of the schema structure.
.
.
conclusion.
combining schema fuzzing rules drop select and type as a pipeline is helpful especially when having drop andselect beforetype .
combining the schema fuzzing rule duplicate with other rules does not provide significant benefit in covering new error types.
therdsearch heuristic provides a more stable growth rate in covering unique error types and is therefore more favorable when the budget is limited.
all of the above conclusions were observed for all dns request types with a non empty body schema.
data value rendering we now discuss several data value rendering strategies i.e.
how we render fuzzed schemas with concrete values.
.
challenges in value rendering as described in section .
a body fuzzed schema defines an overall tree structure and labeled types.
every leaf node represents a property field that needs to be rendered with a concrete value to form a complete json payload.
unfortunately this rendering process is non trivial and may require some domain knowledge of the service under test.
for instance a specific service request with a string typed node location might accept the value global but not us or europe even though all of these are syntacticallyvalid string typed values and moreover may be accepted in other contexts for location .
in practice many requests end up being rejected due to a single specific invalid value rendering of one single node in their body payload.
figure compares how often each error type is triggered during one of the experiments of section .
the one with the schema fuzzing rule pipeline drop select type .
each partition corresponds to a unique error type showing the percentage of tests over all tests that trigger that error type.
as the figure shows the top most frequent error types consume more than of the total fuzzing budget.
based on the error messages allthese error types are due to invalid value renderings such as rendering the node id with value fuzzstring .
in other words regardless of what the tree structures and labeled types of these fuzzed schemas are the service under test rejects these payloads due to a specific invalid value rendering of one single node e.g.
node id .
this value rendering barrier can be broken down into the following root causes.
.
.
.
.
.
error code invalidlinkedpropertyid error message property id fuzzstring at path properties.targetresource.id is invalid.
expect fully qualified resource id that start with subscriptions subscriptionid or providers ... .
cause invalid value renderingfigure percentage of tests triggering each error type schema fuzzing rule pipeline drop select type .
lack of client specific information such as subscription id and resource group name.
lack of domain specific information for example only local and global are valid location values and a timeout value can only be a positive integer smaller than .
lack of run time dependent information such as the name of a resource dynamically created by a previous request.
.
value rendering strategies given a body schema restler can only replace body values by other values of the same type selected from a user defined dictionary of values .
unfortunately this simple strategy is insufficient to address the above challenges.
we now discuss several new value rendering strategies that significantly extend the restler functionality and effectiveness for dealing with body payloads.
.
.
static type value mapping.
the simplest way of assigning a concrete value to a leaf node in a fuzzed schema is to have a typevalue mapping which maps each type to a single value.
in our body schema fuzzer we use the same mapping as discussed in section .
namely fuzzstring false and for leaf nodes labeled with type string integer boolean object and array respectively.
this simple strategy can be used by default as a baseline but it does not address the lack of either client specific domain specific or run time dependent information.
.
.
examples from the swagger specification.
as discussed in section a swagger specification may contain examples of concrete json payloads.
these examples if present are useful for getting concrete values for nodes especially those that require domainspecific information.
however examples do not help discover client specific and runtime dependent values.
moreover the provided examples usually cover only a subset of nodes e.g.
the required property fields and leave the rest unspecified.
.
.
learning from responses.
the response to a valid request may contain information on the service state as opposed to an error message when the request is invalid.
for example the response to aesec fse november virtual event usa patrice godefroid bo yuan huang and marina polishchuk name object abcd properties type public numberoftags maxnumberoftags location global id subscriptions subid resourcegroup ... figure example response payload of a successful request.
successful putrequest may contain the identification of the newly created resource i.e.
run time dependent information.
similarly the responses to successful getandpatch requests may return details of the target resources.
unlike the request examples provided in a swagger specification which is based on the body schema the responses may have properties not declared in the body of the request.
often the response schema is actually similar to the request body schema which makes it possible to re use response values for some parameters in the body of future requests.
in other words learning from responses may reveal the context of the current client service interaction and potentially provides client specific domain specific and run time dependent information.
matching values in responses.
the payload body of a response is represented as a json object like the example provided in figure .
we extract the value of each leaf node in the response payload body and tag it with its path in the json hierarchy.
for instance object abcd and public will be tagged with name and properties.type respectively.
we collect this pool of tagged values on the fly by analyzing responses and keep only the most recent value for each tag.
these values are then used as candidate values when rendering a fuzzed schema.
in selecting a concrete value for a node we use pattern matching to compare the tags of candidate values to the node path in the fuzzed schema tree structure.
two levels of precision are considered conservative and aggressive.
when in conservative mode a candidate value is chosen for a node nonly if its tag exactly matches the node path of nin the fuzzed schema.
for the example in figure given a node ntypein the fuzzed schema we select the candidate value public for it only if its parent is nproperties and there are no other parents.
on the other hand under aggressive mode we only compare the last level leaf in the hierarchy.
for the example in figure as long as a candidate value has a tag suffixed with type it will be chosen for the node ntype regardless of the parent nodes.
.
.
supported value rendering strategies.
following the previous discussion we implemented different value rendering strategies.
baseline bas select a value for a node using only the type value mapping.
examples only exm select a value for a node by using the examples use the type value mapping if no example is available.
responses only conservative con select a value for a node using the responses in conservative mode use the type value mapping if no candidate value is available.
020406080100120140160180value rendering strategieserror types each point represents a unique error type bas total exm tota l con total con exm total agg total agg exm total figure error type coverage for each value rendering strategy pipelines duplicate and drop select type .
responses only aggressive agg select a value for a node using the responses in aggressive mode use the typevalue mapping if no candidate value is available.
responses conservative and examples con exm select a value for a node using the responses in conservative mode use examples if no candidate value is available otherwise use the type value mapping.
responses aggressive and examples agg exm select a value for a node using the responses in aggressive mode use examples if no candidate value is available otherwise use the type value mapping.
.
experiments .
.
experiment settings.
we now evaluate those different value rendering strategies.
similar to the experiments of section .
we use the azure dns service as a fuzzing target.
following the results of section we select the two best schema fuzzing rule pipelines to generate a set of fuzzed schemas duplicate anddrop select type .
each pipeline is bounded by a maximum number of fuzzed schemas per request type and uses the rdsearch heuristic with a random seed .
based on the same set of fuzzed schemas we compare all the value rendering strategies described in section .
.
.
in other words we fuzz azure dns times using the same set of fuzzed schemas but render them using different value rendering strategies.
all execute the same number of tests.
as before we evaluate fuzzing effectiveness using the covered error types obtained from the responses received.
.
.
experiment results.
figure shows the error types covered by each of the value rendering strategies.
the results include all dns request types with non empty body schemas.
compared to the baseline bas both using the examples from the swagger specification exm and matching the values in the responses con are helpful in covering more error types.
for example an error type with an error message record type txt is not supported for referencing resource type dnszones is never triggered when using the baseline strategy bas.
although conalready shows some benefit of learning from responses its effectiveness is still limited when the request body does not share the same schema with the response body.
this can be seenintelligent rest api data fuzzing esec fse november virtual event usa .
.
.
.
.
error code request error error message the server encountered an error processing the request.
the exception message is expecting state element ... encountered text with name xxx namespace xxx ... cause type mismatch figure percentage of tests triggering each error type rendering strategy agg exm pipeline drop select type .
in the comparison between aggvs.conandagg exm vs.con exm where matching response values in the aggressive mode brings even more improvements than in the conservative mode.
in general using both the responses and the examples yields better results.
however agg exm does not outperform aggsignificantly.
this is because the value rendering strategy agg exm prioritizes the values from responses over those from examples.
furthermore in aggressive mode almost every node will find a match in some responses and thus examples are barely utilized.
after using the new value rendering strategies introduced in section .
.
the distribution of error types significantly changes and becomes more uniform value rendereing bottlenecks now disappear.
figure shows the percentage of tests triggering each error type when applying the agg exm value rendering strategy.
compared to figure which uses bas the distribution is more even and the most frequently triggered error type is now due to type mismatch.
.
.
conclusion.
using examples from the swagger specification when selecting a value for a leaf node is helpful in covering more error types.
learning from responses when selecting a value for a leaf node provides a significant improvement in covering more error types especially when matching the values in the aggressive mode.
utilizing both responses and examples is usually beneficial in covering more error types.
bug hunting in cloud services .
rest api data fuzzing algorithm based on the evaluation results presented in sections to we now define our overall rest api data fuzzing algorithm used for longer fuzzing experiments to find bugs in cloud services.
the algorithm is divided into two phases using the fuzzing rules duplicate and drop select type respectively.
each phase has a budget of times the number of nodes in the schema.
the first phase focuses on generating data payloads violating the json format while the second phase focuses on testing various tree structures and typemismatches.
when pipelining schema fuzzing rules we use the rdsearch heuristic with a random seed .
we render every selected fuzzed schema using the agg exm value rendering strategy.
the second phase drop select type is itself divided into two steps.
in the first step we apply the schema fuzzing rule pipeline drop select to the original schema and test the generated fuzzedschemas up to of the budget during this testing process we analyze the responses on the fly and select one fuzzed schema for every unique error type.
in the second step we apply the fuzzing rule type to all previously selected fuzzed schemas for up to of the budget.
all the results of this section were obtained using this algorithm.
.
experimental setup to evaluate the effectiveness of our new rest api data fuzzing algorithm at finding new bugs in existing cloud services we fuzzed microsoft azure cloud services related to networking.
they are used for example to allocate ip addresses and domain names or to provide higher level infrastructures such as load balancers and firewalls.2specifically we fuzzed the azure dns service already used as a benchmark in the previous sections and a large collection of other networking services.
their swagger specifications are publicly available on github under the specification dns andspecification network directories respectively.
the azure dns api consists of request types described in about lines of swagger specifications including examples .
the azure networking api is much larger it is a collection of different apis targeting different services that are written and maintained by different service owners.
overall this api consists of request types described in about lines of swagger specifications across files including examples .
all experiments were conducted on a single commodity pc with an intel i7 processor and 32gb of main memory under windows .
we ran restler extended with our new rest data fuzzing algorithm in a single thread and process.
we used a regular azure subscription3to authenticate and access the azure services being tested.
no other special test setup or service knowledge was required.
.
azure dns bugs found table summarizes the bugs found while fuzzing the bodies of the out of dns requests with non empty body schemas.
overall in minutes of fuzzing we generated tests api requests and found instances of internal server error bugs.
after triaging these we reported unique bugs to azure developers.
these bugs are briefly described in table .
bug was found by replacing a valid location like global by an empty array.
this bug was also found multiple times in azure networking services as will be discussed below.
bug was found when the type of dns record set specified in the path of the rest api request did not match the type of records in the body of the request after fuzzing that body variants were found by our fuzzer.
bug occurs when records becomes empty or an empty array.
bug was triggered when replacing an integer value by a boolean value like false in total integer nodes were subject to this bug.
bugs and 2see 3anyone can get a free trial azure account from azure.com .esec fse november virtual event usa patrice godefroid bo yuan huang and marina polishchuk table overview of the bugs found in azure dns rest apis.
api request schema node bug description variants 1put dns zone location type mismatch string to array or boolean 2put dns record set records enum type mismatch between request path and body e.g.
srvandcaarecords 3put dns record set records missing node e.g.
arecords or arecords 4put dns record set value type mismatch integer to boolean or string 5patch dns record set records enum type mismatch between request path and body e.g.
aaaa andsrvrecords 6patch dns record set records missing node e.g.
txtrecords or txtrecords 7patch dns record set ttl type mismatch integer to boolean or string table overview of the bugs found in azure networking rest apis.
api request schema node bug description variants 1put virtualwans location type mismatch string to array or boolean 2put virtualnetworks addressspace type mismatch object to boolean 3put virtualnetworks addressprefixes type mismatch array to boolean 4put virtualnetworks addressprefixes array type mismatch object to boolean 5put virtualnetworks subnets name type mismatch string to integer 6put virtualnetworks subnets addressprefix type mismatch array to boolean 7put virtualnetworks subnets delegations name type mismatch string to boolean 8put virtualnetworks subnets delegations properties type mismatch array to boolean 9put virtualnetworks subnets delegations missing node e.g.
properties 10put virtualnetworks subnets delegations properties missing node e.g.
properties forpatch dns record set were similar to bugs and for put dns record set respectively.
note that these two requests have the same body schema which would explain similar bugs can be found in both putandpatch requests for dns record set .
for dns we fuzzed api version .
this api has requests including requests with a non empty body whose schema sizenis and respectively.
we found internal server errors in out of these requests the 4th request patch dns zone has only a small body schema with nodes.
during this fuzzing session different error types were found.
in other words beside the one error type internal server error there were other error types returned during these tests for a total of .
.
azure networking bugs found table summarizes the bugs found while fuzzing the bodies of the out of azure networking requests with non empty body schemas.
overall in minutes of fuzzing we generated tests api requests and found instances of internal server error bugs.
after triaging these4 we found variants of distinct bugs which are briefly described in table and which we reported to azure developers.
bug is similar to bug of table replacing a valid location value by an empty array or a boolean value.
triggers an internal server error .
this bug can actually be found using many other requests which take a location value in their bodies and all have a common root cause as confirmed by azure developers .
bugs to were found while fuzzing the very complex body of the put virtualnetworks request.
bugs to are found while fuzzing the type of various parts of the schema of this request.
in contrast bugs and are found using structural 4our tool automatically generates information as shown in columns of table and triaging took less than one hour.fuzzing rules and removing two specific parts of the schema of that request.
the variants of bug are obtained by dropping various parts of the properties sub tree of a subnets delegations but we grouped all these together for the sake of brevity.
for the azure networking api we fuzzed api version .
this api has requests including requests with a non empty body whose schema size nvaries from to nodes.
we found internal server errors across of these request types.
note that of the remaining requests where we did not find any bug have simple bodies with schemas of less than nodes.
during this fuzzing session different error types were found.
as can be seen from table most of the bugs were found when fuzzing the request put virtualnetworks which has a large body schema with nodes.
however fuzzing even larger body schemas such as the body of the putrequest for networkinterfaces with nodes did not find any new bug there except for another variant of bug .
.
discussion the number of tests executed per minute was slower with the dns service than with the azure networking services.
we repeated the above experiments several times but the overall results i.e.
the number of bugs found did not vary significantly.
as we progressively designed and evaluated the algorithms discussed in sections to we started finding our first internal server error bugs in dns only after introducing pipelines without pipelines we would not have found any of the bugs of tables and .
note that restler as is i.e.
without our new extension did not find any of these bugs either.
as can be seen from these two tables the type fuzzing rule was key to find many of these bugs in conjunction with structural fuzzing rules which alone also found several other bugs.
in contrast theduplicate fuzzing rule which may generate malformed jsonintelligent rest api data fuzzing esec fse november virtual event usa request bodies did not trigger any internal server error bug in our experiments however it did trigger two other bugs in dns where the response format was erroneously set to xml instead of json and did not follow the response schema defined in the swagger specification.
we reported all the bugs we found to azure service developers.
all of them are easily reproducible deterministic and have been acknowledged.
we have been told that allof these bugs will be fixed and most of them have been fixed already.
indeed internal server error bugs are unhandled exceptions which may cause severe service back end state corruptions or leaks.
it is safer to fix these bugs rather than risk a live incident or outage with unknown consequences.
related work test authoring tools for rest apis.
with the recent explosion of web and cloud services testing has been applied to rest apis as well mostly in commercial tools such as postman soapui and others .
these tools enable the automatic execution of tests manually written by developers like junit does in java .
test generation tools for rest apis.
other tools available for testing rest apis generate new tests starting from manually defined or previously recorded api traffic and then by fuzzing and replaying new traffic to try finding bugs .
some of these can leverage rest api swagger specifications and then fuzz http requests using either pre defined heuristics or user defined rules .
other extensions are possible if the service code can be instrumented or if a functional specification is available .restler is a recent tool that performs a lightweight static analysis of a swagger specification in order to infer dependencies among request types and then automatically generates sequences of requests instead of single requests in order to exercise the service behind the api more deeply in astateful manner and without pre recorded api traffic .
all these tools can find bugs like internal server errors but they do not fuzz body payloads intelligently using json body schemas and fuzzing rules as in this paper.
grammar based fuzzing.
general purpose grammar based fuzzers like peach and spike among others are not swagger specific but can also be used to fuzz rest apis.
with these tools however the user has to manually construct an api specific input grammar specifying what and how to fuzz.
for structured input formats like xml dialects automatic xml aware fuzzers parse the high level tree structure of an input and include custom fuzzing rules like reordering child nodes increasing their number etc.
that will challenge the application logic while still generating syntactically correct xml .
our json schema fuzzing rules are inspired by related xml fuzzing rules which have successfully found new bugs in xml based file parsers such as microsoft office xml based formats docx xlsx etc.
.
compared to this prior work our main contributions are to adapt such rules to the context of rest api json data sections to to conduct a detailed evaluation of these rules and to demonstrate their effectiveness in the rest api context by finding new bugs in mature cloud services section .
unlike prior off line grammar basedfuzzing we also leverage dynamic feedback extracted from service responses in order to learn new state dependent data values and then refine body payloads embedded in subsequent service requests.
api attacks based on feedback from responses.
in our implementation extra properties returned in responses that are not specified in the request or response schema are simply ignored.
however detecting and using such extra properties is relevant for mass assignment vulnerabilities.
a mass assignment vulnerability may be present when json data is bound to service internal data structures without proper filtering .
for example an attacker may gain unauthorized access to parts of an api by observing an is admin oris debug property in a response then discovering requests that allow setting it to true without having proper permissions.
in future work we plan to explore how to extend our implementation to check for such vulnerabilities.
conclusion this paper has main contributions and takeaways.
we demonstrate that rest api data processing bugs do exist in widely used cloud services.
we show that such bugs are not that difficult to find provided intelligent data fuzzing techniques are used.
we describe several such data fuzzing techniques and evaluate their effectiveness in the rest api context.
cloud service developers do not already use these techniques otherwise they would have found already the bugs we reported in this paper .
cloud service developers care about these bugs otherwise they would not fix them .
to the best of our knowledge this paper is the first to highlight points above.
to further validate points and more rest api data fuzzing experiments are needed with more rest apis and services.
update.
since the first writing of this paper we have fuzzed several other large azure services over the past few months and we have found over new unique bugs in these so far for a total of thousands of crashes .
we have reported these bugs to azure developers and they are currently being reviewed and fixed.