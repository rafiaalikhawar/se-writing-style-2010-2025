abacus precise side channel analysis qinkun bao zihao wang xiaoting li james r. larusy and dinghao wu the pennsylvania state university yepfl abstract side channel attacks allow adversaries to infer sensitive information from non functional characteristics.
prior sidechannel detection work is able to identify numerous potential vulnerabilities.
however in practice many such vulnerabilities leak a negligible amount of sensitive information and thus developers are often reluctant to address them.
existing tools do not provide information to evaluate a leak s severity such as the number of leaked bits.
to address this issue we propose a new program analysis method to precisely quantify the leaked information in a singletrace attack through side channels.
it can identify covert information flows in programs that expose confidential information and can reason about security flaws that would otherwise be difficult if not impossible for a developer to find.
we model an attacker s observation of each leakage site as a constraint.
we use symbolic execution to generate these constraints and then run monte carlo sampling to estimate the number of leaked bits for each leakage site.
by applying the central limit theorem we provide an error bound for these estimations.
we have implemented the technique in a tool called abacus which not only finds very fine grained side channel vulnerabilities but also estimates how many bits are leaked.
abacus outperforms existing dynamic side channel detection tools in performance and accuracy.
we evaluate abacus on openssl mbedtls libgcrypt and monocypher.
our results demonstrate that most reported vulnerabilities are difficult to exploit in practice and should be de prioritized by developers.
we also find several sensitive vulnerabilities that are missed by the existing tools.
we confirm those vulnerabilities with manual checks and by contacting the developers.
i. i ntroduction side channels are ubiquitous in modern computer systems as sensitive information can leak through many mechanisms such as power electromagnetic radiation and even sound .
among them software side channel attacks such as cache attacks memory page attacks and controlled channel attacks are especially problematic as they do not require physical proximity .
these attacks arises from shared microarchitectural components in a computer processor.
by observing inadvertent interactions between two programs attackers can infer program execution flows that manipulate secrets and guess secrets such as encryption keys .
many side channel attacks originate in two code patterns data flow from secrets to load addresses and data flow from secrets to branch conditions.
we refer to them as secretdependent data accesses and control flows respectively.
recent work can detect many side channel vulnerabilities.
for example data reports potential leakage sites for the rsa implementation in openssl .
.0f.
further analysis shows leaks can be dismissed.
but that leaves data access leaks and control flowleaks.
many of these vulnerabilities have not been fixed by developers for a variety of reasons.
first some vulnerable implementations perform better.
for example rsa implementations usually adopt the crt optimization which is faster but vulnerable to fault attacks .
second fixing vulnerabilities can introduce new weaknesses.
third most vulnerabilities pose a negligible risk.
although some vulnerabilities result in the key being entirely compromised many others are less severe in reality.
therefore we need a proper quantification metric to assess the sensitivity of side channel vulnerabilities so a developer can efficiently triage them.
previous work can identify numerous leakages or even provide an upper bound on the amount of leakage which is useful to verify that an implementation is secure if it incurs zero leakage.
however these techniques cannot quantify the severity of a leak because they over approximate the leakage.
for example cacheaudit reports that the upper bound leakage of aes exceeds the original key size.
besides existing side channel quantification work assumes an attacker runs the target program multiple times with different input secrets and calculates an average estimation which is different from real attack scenarios when the secret that an attacker wants to retrieve is fixed.
as a consequence those results are less useful to assess the severity level of each leakage site.
to overcome these limitations we propose a novel method to quantify information leakage precisely.
we quantify the number of bits that can leak during a real execution and define the amount of leaked information as the cardinality of possible secrets based on an attacker s observation.
before an attack an adversary has a large but finite input space.
whenever the adversary observes a leakage site they can eliminate some impossible inputs and reduce the input space s size.
in an extreme case if the input space s size reduces to one an adversary has determined the input which means all secret information e.g.
the entire secret key is leaked.
by counting the number of inputs we can quantify the information leakage precisely.
we use symbolic execution to generate constraints to model the relation between the original sensitive input and an attacker s observations.
symbolic execution provides fine grained information but it is expensive to compute.
therefore prior symbolic execution work either analyzes only small programs or applies domain knowledge to simplify the analysis.
we examine the bottleneck of the trace oriented symbolic execution and optimize it to work for real world crypto systems.
we have implemented the proposed technique in a tool ieee acm 43rd international conference on software engineering icse .
ieee unsigned long long r int secret ... while i r r r n if secret r r x n figure secret dependent control flow transfersstatic char fsb ... ... uint32 t a rk fsb secret fsb fsb fsb ... figure secret dependent data accesses called abacus and demonstrated it on real world crypto libraries including openssl mbedtls libgcrypt and monocypher.
we collect execution traces of these libraries and apply symbolic execution to each instruction.
we model each sidechannel leak as a logic formula.
these formulas precisely model side channel vulnerabilities.
then we use the conjunction of those formulas to model the leaks at a statement that appears in different location in the execution trace file e.g.
leaks inside a loop .
finally we introduce a monte carlo sampling method to estimate the information leakage.
the experimental results confirm that abacus precisely identifies previously known vulnerabilities and reports how much information is leaked and which byte in the original sensitive buffer is leaked.
we also test abacus on side channel free algorithms.
abacus produces no false positives.
the result also shows the newer version of crypto libraries leak less information than earlier versions.
abacus also discovers new vulnerabilities.
with the help of abacus we confirm that some of these vulnerabilities are severe.
in summary we make the following contributions we propose a novel method that can quantify fine grained leaked information from side channel vulnerabilities that result from actual attack scenarios.
our approach differs from previous ones in that we model real attack scenarios for one execution.
we model the information quantification problem as a counting problem and use a monte carlo sampling method to estimate the information leakage.
we implement the method into a tool and apply it to several pieces of real software.
abacus successfully identifies previous unknown and known side channel vulnerabilities and calculates the corresponding information leakage.
our results are useful in practice.
the leakage estimates and the corresponding trigger inputs can help developers to triage and fix the vulnerabilities.
ii.
b ackground and threat model a. address based side channels side channels leak sensitive information unintentionally through different execution behaviors caused by shared hardware components e.g.
cpu cache tlb and dram in modern computer systems .
the key intuition is that many of those side channel attacks happen when a program accesses different memory addresses depending on the values in sensitive inputs .
as shown in figure and figure if a program executes different patterns of control transfers or data accesses when it processes differentsensitive inputs the program may be vulnerable to sidechannel attacks.
different side channels can be exploited to retrieve information at various granularities.
for example cache side channels observe cache accesses at the level of cache sets cache lines or finer granularities .
other types of side channels such as controlled channel attack can observe the memory accesses at the granularity of memory pages.
b. exisiting information leakage quantification information theory tells us that if an event ethat occurs with the probability p e we receive i log2p e bits of information by knowing the event ehappened.
considering a char variable a with one byte size in a c program its possible values range from to .
if we observe a equals without prior domain knowledge the probability of this observation is1 .
so we obtain log bits of information which is exactly the size of a char variable.
existing work on information leakage quantification typically use shannon entropy min entropy or maxentropy .
in these frameworks the input sensitive information kis considered to be a random variable.
letkbe one of the possible value of k. the shannon entropyh k is defined as h k x k2kp k log2 p k shannon entropy can be used to quantify the initial uncertainty about sensitive information.
it measures the amount of information in a system.
min entropy describes the information leaks for a program in terms of its most likely input.
for example min entropy can be used to describe the highest chance of success in guessing a password by using the most common password.
min entropy log2 pmax max entropy is defined solely on the number of possible observations.
max entropy log2n as it is easy to compute most recent works use maxentropy as the definition of the amount of leaked information.
c. threat model we assume that an attacker shares the same hardware platform with the target.
the attacker attempts to retrieve sensitive information through address based side channel attacks.
the attacker has no direct access to the target s memory or cache but it can probe its memory or cache at each program point.
in reality the attacker will face many possible obstacles such as the noisy observations of the memory or cache.
however for this project we assume the attacker has noise free observations as in previous work .
the threat model captures most cache based and address based side channel attacks.
we 798only consider deterministic programs and assume an attacker has access to the source code or binary executable of the target program.
iii.abacus precise side channel analysis in this section we discuss how abacus quantifies the amount of leaked information.
we first present the limitation of existing quantification metrics.
then we introduce our model the mathematical notation used in the paper and our method.
a. problem setting existing static side channel quantification works define information leakage using max entropy or shannon entropy.
if zero bits of information leakage is reported a program is secure.
however when a tool using these metrics reports leakage it is the average leakage.
in a real attack the leakage could be dramatically different.
1char key input 2if strcmp key password leakage site c pass branch 4else fail branch figure a dummy password checker consider a password checker sketched in figure .
the password checker takes an byte char array exclude null character and checks if the input is the correct password.
if an attacker uses a side channel attack to determine that the code executes branch f1g they can infer the password equals to password in which case the attacker retrieves the full password.
therefore the total leaked information should be bits which equals to the size of the original sensitive input when the code executes branch .
however prior static approaches cannot precisely capture the amount of leakage.
according to the definition of shannon entropy the leakage will be1 log21 log2264 0bits.
max entropy is defined from the number of possible observations.
because the program has two branches tools based on max entropy will report the code has alog22 bit leakage.
random key k fixed key k target program p observation o observation o a previous model b real attacktarget program p figure the gap between a real attack and previous models both approaches fail to tell how much information is leaked during the actual execution.
the problem with existing methods is that their approaches do not consider input values and real runtime information.
they assume an attacker runs the program multiple times with many different or randomsensitive inputs.
as shown in figure a both shannon entropy and max entropy give an average estimate of the information leakage.
however generating random inputs is not the typical scenario for an adversary launching a sidechannel attack.
in a typical attack the adversary wants to retrieve sensitive information which is typically fixed e.g.
aes keys .
the adversary performs their attack over and over again with fixed input and guess the value bit by bit e.g.
kocher s timing attacks as in figure b .
we need a theory for dynamic analysis that says an attack leaks xbits of secret information where xis useful in estimating the sensitive level of the vulnerability.
however all previous methods fail for real attack models.
this is the first challenge we face challenge c1 .
b. notation in the section we give necessary definitions and notation for dealing with programs and side channels.
we use capital letters e.g.
a to represent a set.
jajrepresents the cardinality of seta.
we use corresponding lower case letters to represent one element of the set e.g.
a2a .
we assume a program haskas its sensitive input.
kshould be a finite set of keys.
the program also takes known messages mas its input.
during an aes encryption for example is the encryption function.
kis the set of all possible aes keys and mrepresents the set consisting of all plaintext messages to be encrypted.
in a real execution an adversary may have some observations o of the program.
examples of those observations include timing cpu usages and electromagnetic signals em .
this paper only uses secretdependent control flows and secret dependent data accesses as observations.
with the above definition we have the following mapping between k m ando k m !o we model a side channel in the following way.
an adversary does not have access to k but he knows m ando.
for one execution of a deterministic program once k2kandm2m are fixed the observation o2o should also be determined.
an attacker knows o andm.
the attacker wants to infer the value ofk.
we usekoto denote the set of possible kvalues that produce the same observation ko fk2kj k m !
og then the problem of quantifying the amount of leaked information can be restated as the following question how much uncertainty of kis reduced if an attacker knows m ando?
c. theoretical analysis solution to challenge c1 in information theory the mutual information i is a measure of the mutual dependence between two variables.
we useito describe the dependence between original sensitive keys k and attackers observations o which is defined as i k o x k2kx o2op k o log2p k o p k p o 799wherep k o is the joint probability mass function of k ando.
alternatively the mutual information can also be equivalently expressed as i k o h k h kjo h kjo is the entropy of kunder the condition o. it quantifies the uncertainty of k given the value of o. in other words the conditional entropy h kjo marks the uncertainty aboutkafter an adversary has made observations o. h kjo x o2op o x k2kp kjo log2p kjo in this project we hope for a very precise definition of information leakages.
suppose an attacker runs the target program with one input we want to know how much information they can infer by observing the memory access patterns o .
we come to the simple formulation that information leakage initial uncertainty remaining uncertainty next we compare the eq.
with the above formulation we findh k is the initial uncertainty andh kjo is remaining uncertainty .
during a real attack the observation o is known.
thus we have h kjo h kjo .
therefore we define the amount of leaked information as leakage h k h kjo for a program without any domain information all possible sensitive inputs appear equally likely.
therefore for anyk2k p k jkj.
we have h k x k2k1 jkjlog2jkj log2jkj for anyk02knko p k0jo .
we get h k o x k2kop kjo log2p kjo x k knko p k0jo log2p k0jo x k2ko1 jkojlog2jkoj log2jkoj definition .
given a program with the input set k an adversary has the observation owhen the input k2ko.
we denote it as ko m !o the amount of leaked information l k !obased on the observation o is l k !o log2jkj log2jkoj the above definition can be understood in an intuitive way.
suppose an attacker guesses a bit encryption key.
without any domain knowledge they can find the key by performing anexhaustive search over 2128possible keys.
however assume the program has a side channel leakage site.
after the program finishes execution the attacker has some observations and only needs to find the key by performing an exhaustive search over 2120possible keys.
then we say that bits of the information is leaked.
in this example 2128is the size of kand2120is the size ofko.
with this definition if an attacker observes that the code in figure executes branch then ko1 f password g. therefore the information leakage lp k o1 log2264 log21 bits which means the key is entirely leaked.
if the attacker observes the code hits branch the leaked information is lp k o2 log2264 log2 0bits.
as the size of input sensitive information is usually public the problem of quantifying the leaked information is equivalent to the problem of estimating the size of input key jkojunder the condition o2o.
d. our conceptual framework we now discuss how to model observations o which are the direct information that an adversary can obtain during a side channel attack.
during an execution a program has many temporary values ti2t .
once program k secret and m message public are determined tiis also fixed for deterministic programs .
therefore ti fi k m wherefiis a function that maps between tiand k m .
in the paper we consider two code patterns that can be exploited to infer sensitive information by an attacker secret dependent control transfers andsecret dependent data accesses .
secret dependent control transfers a control flow path is secret dependent if different input sensitive keys k can lead to different branch conditions.
we define a branch to be secret dependent if 9ki1 ki22k fi ki1 m fi ki2 m an adversary can observe which branch the code executes if the branch condition equals tb.
we use the constraint ci fi k m tbto model the observation o on secretdependent control transfers.
secret dependent data accesses similar to secretdependent control flow transfers a data access operation is secret dependent if different input sensitive keys k cause access to different memory addresses.
we use the model from cached .
the low lbits of the address are generally unimportant in side channels.
a data access is secret dependent if 9ki1 ki22k fi ki1 m l6 fi ki2 m l if the memory access equals to tb we can use the constraint ci fi k m l tb l to model the observation of a secret dependent data access.
800iv.
s caling to real world crypto systems in the previous section we propose an information leakage definition for realistic attack scenarios to model two types of address based side channel leakages and showed how to quantify them by calculating the number of input keys ko that satisfy the formulas.
intuitively we can use symbolic execution to capture math formulas and model counting to obtain the number of satisfying input keys ko .
however preliminary experiments showed that this approach was far too expensive to use with real world applications.
in this section we discuss the bottlenecks in this approach and propose a practical solution.
in general abacus faces the following performance challenges in scaling to production system crypto analysis .
symbolic execution challenge c2 counting the number of items in ko challenge c3 a. trace oriented symbolic execution symbolic execution is notorious for its high performance cost.
previous trace oriented symbolic execution work has serious performance bottlenecks.
as a result these approaches either apply only to small programs or require domain knowledge to simplify the analysis.
we implement the approach presented in iii and model the side channels as formulas.
while the tools can analyze some simple cases such as aes it cannot handle complicated examples such as rsa.
we observe that finding side channels using symbolic execution differs from traditional symbolic execution and it can be optimized to be as efficient as other methods.
interpret instructions symbolically existing binary analysis frameworks translate machine instructions into intermediate languages ir to simplify analysis since the variety of machine instructions is enormous and their semantics is complex.
the intel developer manual documents more than different x86 instructions.
unfortunately the ir layer which reduces the workload of these tools is not suitable for side channels analysis because ir based or source code side channels analyses do not represent the executed instructions accurate enough to analyze fully their control and memory accesses.
for example a compiler may use conditional moves or bitwise operations to eliminate branches.
also as some irs are not a superset or a subset of isa it is hard to rule out conditional jumps introduced by ir and add real branches eliminated by ir transformations.
moreover the ir causes significant overhead .
translating machine instructions into ir is time consuming.
for example reil ir adopted in caches has multiple transform processes from binary to vex ir bap ir and finally reil ir.
also ir increases the total number of instructions.
for example x86 instruction test eax eax transfers into reil ir instructions.
our solution we abandoned ir and expended the effort to implement symbolic execution directly on x86 instructions.
table i shows that eliminating the ir reduces the number of instructions examined during analysis.
previous works table i the number of x86 reil ir and vex ir instructions on the traces of crypto programs.
number of x86 instructionsnumber of vex irnumber of reil ir aes openssl .
.
15x 36x des openssl .
.
15x 33x rsa openssl .
.
15x 37x rsa mbedtls .
15x 39x also adopted a similar approach to speed up fuzzing.
our implementation differs from that work in two aspects we use complete constraints.
we run the symbolic execution on one execution path each time.
our approach is approximately times faster than using an ir transferring isa into ir and symbolically executing it .
constraint solving as discussed in iii d the problem of identifying side channels can be reduced to the question can we find two different input variables k1 k22k that satisfy the formula fa k1 fa k2 ?
existing approaches rely on satisfiability modulo theories smt solvers e.g.
z3 to find satisfying assignments tok1andk2.
while this is a universal approach to solving constraints for constraints of this form using custom heuristics and testing is much more efficient in practice.
constraint solving is a decision problem expressed in logic formulas.
smt solvers transfer the smt formula into the boolean conjunctive normal form cnf and feed it into the internal boolean satisfiability problem sat solver.
the translation process called bit blasting is time consuming.
also as the sat problem is a well known np complete problem it is hard to deal when it comes to practical uses with huge formulas.
despite the rapid improvement in smt solvers in recent years constraint solving remains one of the obstacles to scaling the analysis of real world crypto systems.
our solution instead of feeding the formula fa k1 fa k2 into a smt solver we randomly pick k1 k22kand test them if they satisfy the formula.
our solution is based on the following intuition.
for most combination of k1 k2 fa k1 fa k2 .
as long as fais not a constant function suchk1 k2must exist.
for example suppose each time we only have chance to find such k1 k2 then after we test with different input combination with times we have chance find such k1 k2.
this type of random algorithm works well for our problem.
b. counting the solutions in this section we present the algorithm to calculate the information leakage based on definition iii answering tochallenge c3 .
problem statement for each leakage site we model it with a constraint using the method presented in iii d. suppose the address of the leakage site is i we usec ito denote the constraint that models its side channel leakage.
according to the definition to calculate the amount of leaked information the key is to calculate the cardinality of ko.
suppose an attacker can observe nleakage sites and each leakage site has the following constraints c c c n respectively.
the total leakage can be calculated from the 801constraintct n c c c n. a simple method is to pick elements kfromkand check if an element is also contained in ko.
assumeqelements satisfy this condition.
in expectation we can usek qto approximate the value ofjkj jkoj.
however the above sampling method fails in practice due to the following two problems the curse of dimensionality problem.
ct n is the conjunction of many constraints.
therefore the input variables of each constraints will also be the input variables of the ct n .
the sampling method fails asngrows.
the number of satisfying assignments could be exponentially small.
according to chernoff bound we need exponentially many samples to get a tight bound.
however despite above two problems we also observe two characteristics of the problem ct n is the conjunction of several short constraintsc i. the set containing the input variables of c i is the subset of the input variables of ct n .
some constraints have completely different input variables from other constraints.
each time when we sample ct n with a point the sampling result is satisfied or not not satisfied .
the outcome does not depend on the result of previous experiments.
also as the amount of leaked information is calculated by a logfunction we need not exactly count the number of solutions for a given constraint.
in regard to the above problems we present our methods.
first we split ct n into several independent constraint groups.
after that we run a multi step sampling method for each constraint.
maximum independent partition for a constraint c i we define function which maps the constraint into a set of different input symbols.
for example k1 k2 fk1 k2g.
definition .
given two constraints cmandcn we call them independent iff cm cn ?
based on the definition we can split the constraint ct n into several independent constraints.
there are many partitions.
for our project we are interested in the following one.
definition .
for the constraint ct n we call the constraint group g1 g2 gmthe maximum independent partition of ct n iff g1 g2 gm ct n 8i j2f1 mgandi6 j gi gj ?
for any other partitions h1 h2 hm0satisfy and m m0 the reason we want a good partition of constraints is we want to reduce the dimensions.
for example a good partition off k1 k2 k3 k3 k4 would beg1 k1 g2 k2 g3 k3 k3 k4 we can sample each constraint independently and combine them with theorem .
theorem .
letg1 g2 gmbe a maximum independent partition ofct n .kcis the input set that satisfies constraintc.
we have the following equation in regard to the size ofkc jkct n j jkg1j jkg2j jkgnj with theorem we change the problem of counting the number of solutions to a complicated constraint in a highdimension space into counting solutions to several small constraints.
we compute the maximum independent partition by iterating each iand applying the function over the constraint i. multiple step monte carlo sampling after we split those constraints into several small constraints we count the number of solutions for each constraint.
even though the dimension has been significantly reduced by the previous step this is still a p problem.
we apply the counting by sampling method.
for the constraintgi ci1 ci2 cij cim if the solution satisfiesgi it should also satisfy any constraint from ci1tocim.
in other words kcgishould be the subset of kc1 kc2 .
.
.
kcm.
we notice that ciusually has fewer inputs than gi.
for example if cijhas only one bit input variable we can find the exact solution set kcijofcijby trying every possible solution.
after that we only generate random input numbers for the other input variables in constraint gi.
with this simple yet effective trick we reduce the number of input while still ensuring accuracy.
error estimation our result has a probabilistic guarantee that the error of the estimated amount of leaked information is less than bit under the central limit theorem clt and uncertainty propagation theorem.
letnbe the number of samples and nsbe the number of samples that satisfy the constraint c. then we get p ns n. if we repeat the experiment multiple times each time we get a p. as each pis independent and identically distributed according to the central limit theorem the mean value should follow the normal distribution p e p pn!n .
heree p is the mean value of p and is the standard variance of p. if we use the observed value pto calculate the standard deviation we can claim that we have 1confidence that the error p p e p falls in the interval j pj 96r p p n since we use l log2pto estimate the amount of leaked information we can have the following error propagation formula l p pln 2by taking the derivative from definition .
for abacus we want the error of estimated leaked information l to be less than bit.
so we get p pln .
1for a normal distribution of variable pfall within two sigmas of the mean.
802010101010110101010100010010100110100101010101100101010101111010100000110100001101010binary codeformulastracereportpush ebpmov ebp espsub esp 0x18xor eax eaxadd eax ebxadd eax 0x1f k1 k2 k3 k1 k3 1k1 k2 k4 0fead74b2 bits k1 k2 k3fead74a1 bits k1 k2 k4ffad3211 bits k1 k2 k9ffad3111 bits k1 k2 k7 k8ffadd12f bits k1 k2 k3...figure the workflow of abacus .
therefore as long as n p p ln we have confidence that the error of estimated leaked information is less than bit.
during the simulation if nandpsatisfy this inequality the monte carlo simulation will terminate.
v. d esign and implementation a. design figure shows the three steps of abacus .
first we run the target program with a concrete input sensitive information under the dynamic binary instrumentation dbi framework to collect an execution trace.
after that we run the symbolic execution to capture fine grained semantic information for each secret dependent control flow transfer and data access.
finally we run monte carlo mc simulation to estimate the amount of leaked information.
execution trace generation the design goal of abacus is to estimate the information leakage as precisely as possible.
we run the target binary under a dynamic binary instrumentation dbi tool to record execution traces and runtime information.
once the sensitive information is loaded into memory we start to collect the trace.
in this step we mark variables and buffers that hold the sensitive data by either annotating the source code make abacus symbolic or telling the dbi tool of the memory address and the length of secrets.
instruction level symbolic execution we model attackers observations from side channel vulnerabilities with logic formulas.
each formula captures the fine grained information between input secrets and leakage sites.
the engine only symbolically executes instruction that might be affected by the input sensitive data.
abacus works on one path at a time.
the memory model is conceptually similar to other offline executors e.g.
sage and the trace based executor of bitblaze .
that is we use symbolic execution to track secrets.
when secrets are loaded into the memory abacus starts to interpret instructions symbolically.
we treat secrets as symbols s .
for other variables we use concrete values c from the execution.
we do not know which instruction may manipulate a secret until we execute it.
for each instruction if all its operands and implicit memory accesses are concrete values we perform concrete calculation and update the destination with the concrete value according to the instruction semantics.
otherwise we symbolically interpret the instruction and update the destination with a formula.
leakage estimation we change the information leakage quantification problem into the counting problem.
we propose a monte carlo method to estimate the number of satisfying solutions.
with the help of the central limit theorem clt we also give an error estimate with the probability which provides us with the precision guarantee .table ii evaluation results overview name side channel leaks leaks secret dependent control flows cf secretdependent data flows df the number of instructions instructions symbolic execution se and monte carlo mc time.
name leaks cf df instructions se mc ms ms aes168 aes268 aes475 aes588 aes688 aes788 aes888 des115 des215 des46 des58 des68 des78 des86 seconds seconds chacha2030 poly130530 argon2i30 ed2551930 ecdsa16 ecdsa24 ecdsa55 ecdsa65 ecdsa75 ecdsa80 ecdsa90 minutes minutes rsa16 rsa212 rsa4107 rsa538 rsa636 rsa731 rsa84 rsa98 rsa1011 rsa1114 rsa128 total 341m 232m 1mbedtls .52mbedtls .153monocypher .
4openssl .
.75openssl .
.2f6openssl .
.2k 7openssl .
.0f8openssl .
.19openssl .
.1g 10libgcrypt .
.111libgcrypt .
.312libgcrypt .
.
b. implementation abacus consists of lines of code in c and python.
it has three components an intel pin tool that collects the execution trace the instruction level symbolic execution engine and the backend that estimates the information leakage.
our current implementation supports most intel bit instructions that are essential to find address based side channel vulnerabilities including bitwise operations control transfer data movement and logic instructions.
the tool uses the real values to update the registers and memory for instructions that the implementation does not support.
therefore the tool may miss some leakages but will not raise false positives.
803vi.
e valuation we evaluate abacus on widely used crypto libraries including openssl mbedtls libgcrypt and monocypher.
we mark variables and buffers that store a secret.
for des and aes we mark symmetric keys as secrets.
for rsa we mark private keys as secrets.
for ecdsa we mark nonces and private keys as secrets.
we build the source program into bit x86 linux executables with gcc .
running on ubuntu .
.
we run our experiments on a .90ghz intel xeon r e5 cpu with 128gb ram.
the execution time is calculated on a single core.
during our evaluation process we are interested in the following aspects identifying side channels leakages.
isabacus effective to detect side channels in real world crypto systems?
vi a and vi b quantifying side channel leakages.
canabacus precisely report the number of leaked bits in crypto libraries?
is the number of leaked bits reported by abacus useful to justify the severity levels of each sidechannel vulnerability?
vi c1 vi c2 vi c3 a. evaluation result overview table ii summarizes the results.
abacus finds leaks in the crypto libraries.
among these leaks are due to secret dependent control flow transfers and are due to secret dependent data accesses.
abacus also finds that most side channel vulnerabilities leak very little information in practice which confirms our initial assumption.
however abacus finds some vulnerabilities with severe leakages.
prior research has confirmed that some of these vulnerabilities can be exploited in real attacks.
with our tool developers can distinguish non critical vulnerabilities from severe ones.
symmetric encryption implementations in openssl and mbedtls have significant leakage due to their lookup table implementations.
abacus confirms that those leakage comes from table lookups.
the new implementation of openssl has adopted several methods e.g.
one single s box instead of four lookup tables smaller lookup tables to mitigate the problem.
those changes are rather easy but significantly decrease the total amount of leaked information as the quantification result indicates.
we also evaluate our tool on the rsa implementation.
with the optimization introduced in iv we need not apply domain knowledge to simplify the analysis.
our tool identifies all leakage sites reported by cached and find new leaks in less time.
we also find newer versions of rsa in openssl have fewer leaks.
we will discuss the version changes and corresponding leakages in vi c2.
abacus can estimate how much information is leaked from each vulnerability.
during the evaluation for each leakage site abacus will stop once it has confidence that the error of the estimated leaked information is less than bit which gives the leakage quantification a precision guarantee or it cannot reach the termination condition after minutes.
inthe latter case it means abacus cannot estimate the amount of leakage with a probabilistic guarantee.
we manually check these leakage sites and find most of them are quite severe.
we will present the details in the subsequent sections.
b. comparison with the existing tools in this section we compare abacus with the existing tracebased side channel detection tools on vulnerability detections.
for other tools we use the data in the paper.
as other tools do not quantify leakage sites we only include the time of detecting vulnerabilities to perform a fair comparison.
the comparison result with cached is shown in table iii.
note that one statement in the source code can be compiled into several machine instructions.
so it is possible that one statement can have multiple leakage points.
under the circumstance we think it is only a leakage.
we have confirmed that abacus can identify all the secret dependent data access vulnerabilities reported by cached.
in addition abacus finds many new ones.
cached fails to detect some vulnerabilities for two reasons.
first cached can only detect secret dependent data access vulnerabilities.
abacus can detect secret dependent control flows as well.
second according to the cached paper cached times out after hours to process asymmetric ciphers.
cached applies some domain knowledge to simplify and speed up the analysis.
while those optimizations do not introduce false positives they may miss some vulnerabilities.
we notice that the number of instructions in those traces are different due to the different analysis starting functions and building options during the evaluation.
table iii shows that abacus is faster than cached.
abacus is much faster than cached when analyzing the same number of instructions.
for example when we test abacus on aes from openssl .
.
abacus is over 100x faster than cached.
data identifies side channel leakages by finding differences in execution traces of the test program under various secret inputs .
according to the original data paper it uses different traces to analyze the side channel vulnerabilities in symmetric cyphers and different traces to analyze the side channel vulnerabilities in asymmetric cyphers.
on the other hand abacus detects side channel vulnerabilities from one execution trace.
abacus uses symbolic analysis to extract formulas that model each side channel leakage.
after that we sample the formula with various secret inputs to detect and quantify each leakage site.
in theory data might have better code coverage than abacus because it uses more execution traces but abacus has the following advantages.
a abacus is faster than data.
for example it takes minutes for data to detect vulnerabilities in the rsa implementation in openssl .
.0f.
abacus only spends minutes as shown in table ii.
it takes minutes and minutes for data to analyze the side channel leakages in aes and des respectively.
on the other hand abacus finishes its analysis in less than ten seconds while finding all the leakages reported by data.
b because abacus does not run the test program again when we have a new secret input abacus can test more input secrets on those formulas 804table iii comparison with cached time secret dependent control flows cf secret dependent data flows df the number of instructions instructions .
cached abacus name time s instructions df time s instructions cf df aes143.
.
aes248.
.
rsa1199.
.
rsa2165.
.
rsa311542.
.
rsa410788.
.
total .
.
of instructions per second cached abacus 1openssl .
.72openssl .
.2f3libgcrypt .
.14libgcrypt .
.
within the same time to achieve better precision.
c data tries to use leakage models domain knowledge to classify each leakage.
the strength of abacus is that it does not need such domain knowledge.
data reports control flow and memory access leaks for the rsa implementation in openssl .
.0f.
among those leakages they find one new vulnerability in rsa after some manual analysis.
abacus finds the vulnerability and reports the vulnerability is severe int bn mod inverse leaks more than .
bits and bn div leaks more than .
bits which helps identify real sensitive leaks.
for each leakage site abacus can provide concrete examples to trigger the issue and give an estimation to assess the severity level of the vulnerability.
c. case studies symmetric ciphers des and aes we test both des and aes ciphers from mbedtls and openssl.
both cipher implementations apply lookup tables which improve performance but can also introduce side channels as well.
during our evaluation we find mbedtls .
and .
.
have the same implementation of aes and des.
therefore our tool reports the same leakages for both versions.
we find that the des implementations in both mbedtls and openssl have several severe information leakages in the key schedule function.
we do not see any mitigation in the new version.
we think it is not seen as worth the engineering efforts given the life cycles of des.
abacus shows that the aes in openssl .
.
has less leakage than other versions.
openssl .
.
uses 1kb lookup tables with bit entries unlike older versions that use a table with bit entries.
our tool suggests a smaller lookup table might mitigate side channel vulnerabilities.
asymmetric ciphers rsa we also evaluate abacus on rsa.
due to the page limit we do not present the detailed leakage report.
as shown in figure the result indicates that the newer versions of openssl leak less information than earlier versions.
after version .
.7g openssl adopts a fixedwindow mod exp mont implementation for rsa.
with this design the sequence of squares and multiples and the memory access patterns are independent of the secret key.
abacus s result confirms the new exponentiation implementation has mitigated most leakages effectively because the four newer versions have fewer leakages than version .
.
which in troduced this change.
openssl version .
.2f .
.2k and .
.0f almost have the same amount of leakage.
we check the changelog and find only one change to patch vulnerability cve .
abacus finds openssl .
.
and .
.1g have significantly less leaked information than other versions.
we check the changelog of these two versions and find a claim that the new rsa implementation adopts numerous side channel attack mitigation which proves the effectiveness of our quantifying method.
our quantification result shows vulnerabilities that leak significant amounts of information are more likely to be fixed in the updated version.
as presented in figure openssl .
.
has several severe leaks from function bn sqr comba8 which is a main component of the openssl big number implementation.
shown in figure it has a secret dependent control flow at line .
the value of the function parameter a is derived from the secret key.
as function bn sqr comba8 calls the macro sqr add c2 multiple times and the code can leak some information each time.
abacus indicates the vulnerability is quite serious.
it was patched in openssl .
.
.
in figure control flows transfers are replaced so there are no leaks in the function sqr add c2 in openssl .
.
.
we note that line and in figure both contain if branches.
however they are not leaks because most compilers use add with carry instruction to eliminate the branch.
in addition branches can be compiled into non branch machine instructions with conditional moves.
we notice a bitwise operation in libgcrypt .
.
is compiled to a conditional jump which leads to a sidechannel leakage.
therefore source level code reviews are not accurate enough to detect side channels.
for vulnerabilities that leak less amount of information developers are more reluctant to fix them.
for example openssl .
.
adds a fixed windows version of function bn mod exp mont consttime to replace original function bn mod exp mont .abacus detects a minor vulnerability in the original function that can leak the last bit of the big number m. in the updated version developers make the fixed windows the default option and rewrite most of the function.
however the leakage site still exists in openssl .
.
.
monocypher monocypher is a small easy to use cryptographic library with performance comparable to libsodium and nacl .
we choose four ciphers that are designed to be side channel resistant from the library.
because those ciphers have no data flow from secrets to branch conditions and load addresses.
monocypher should be safe under our threat models.
we analyze those ciphers with abacus and it reports no leaks.
this indicates that abacus is effective for validating countermeasures.
vii.
d iscussions and limitations while recent work found many side channel vulnerabilities we note that many of them have not been patched by developers.
side channels are ubiquitous in software and it would be difficult to fix all of them.
we need a tool that estimates the sensitivity of each vulnerability so software engineers can focus on severe leakages.
for example abacus reports leakage amount bits 10305070number of leakages a openssl .
.
leakage amount bits 10305070number of leakages b openssl .
.2f leakage amount bits 10305070number of leakages c openssl .
.2k leakage amount bits 10305070number of leakages d openssl .
.0f leakage amount bits 10305070number of leakages e openssl .
.
leakage amount bits 10305070number of leakages f openssl .
.1g figure side channel leakages in different implementations of rsa in openssl.
we round the number of leaked information into the nearest integer.
the mark means timeout see vi a .
define mul add c2 a b c0 c1 c2 t bn ullong a b tt t t bn mask if tt t c2 t1 bn ulong lw tt t2 bn ulong hw tt c0 c0 t1 bn mask2 if c0 t1 t2 bn mask2 c2 c1 c1 t2 bn mask2 if c1 t2 c2 figure macro sqr add c2 in openssl .
.
define mul add c2 a b c0 c1 c2 do bn ulong ta a tb b bn ulong lo hi tt bn umult lohi lo hi ta tb c0 lo tt hi c0 lo ?
c1 tt c2 c1 tt ?
c0 lo hi c0 lo ?
c1 hi c2 c1 hi ?
while figure macro sqr add c2 in openssl .
.
that the modular exponentiation using square and multiply algorithms can leak more information than a key validation function.
software developers can use abacus to find severe vulnerabilities and reason about countermeasures.
abacus estimates the amount of leaked information for each side channel leakage in one execution trace.
abacus is useful for software engineers to test programs and fix vulnerabilities.
the design which is more precise in reporting true leakages as compared with other static methods obviously misses leakages on unexplored traces.
the amount of leaked information also depends on the secret key.
however as the tool is intended for debugging and testing we think it is a software engineer s responsibility to select the input key and trigger the path in which they are interested.
it is not a problem for crypto software since virtually all keys follow similar computational paths.
we use the amount of leaked information to represent the sensitivity level of each side channel vulnerability.
although imperfect abacus produces a reasonable measurement for each leak.
for example the simple modular exponentiation is notoriously famous for multiple side channel attacks .
during the execution a single leak point may execute multiple times and each time leak a different bit.
in this case abacus reports that the vulnerability can leak the whole key.
however not every leak point inside a loop is severe.
if a site in the loop leaks the same bit from the original key and these leaks are notindependent.
abacus captures most fine grained information by modeling each leak during the execution as a formula and the conjunction of the formulas to describe its total effect.
some leakage sites e.g.
square and multiply can leak one particular bit of the original key but some leakage sites leak one bit from several bytes in the original key.
abacus can capture the dependency among the leaks and reports more precise leakage information.
abacus reaches full precision if the number of estimated leaked bits equals to definition .
abacus may lose precision from the memory model it uses in theory.
however we did not find false positives caused by the imprecise memory model during our evaluation.
sampling introduces imprecision but with a probabilistic guarantee.
however during the evaluation we find that abacus cannot estimate the amount of leakage for some leakage sites in a reasonable time which means the number ofkois very small.
according to definition it means the leakage is very severe.
the sampling method in iv seems simple and may miss some leakages e.g.
chosen ciphertext attacks in theory.
however the evaluation result shows abacus can identify all leakages found by the previous work .
viii.
r elated work there is a vast amount of work on side channel detection mitigation information quantification and model counting .
here we only present work closely related to ours.
due to space limit we do not discuss related work on side channel attacks.
a. detection and mitigation cacheaudit uses abstract domains to compute an over approximation of cache based side channel information leakage upper bound.
however it is difficult to judge the sensitive level of the side channel leakage based on the leakage provided by cacheaudit.
caches improves on cacheaudit with new abstract domains that only track secret related code.
like cacheaudit caches cannot indicate the sensitive level of side channel vulnerabilities.
casym introduces a static cache aware symbolic reasoning technique to cover multiple paths in a target program.
again their approaches cannot evaluate the sensitive level for each side channel vulnerability and it only work on small code snippets.
806the dynamic approach usually consists of taint analysis and symbolic execution can perform a very precise analysis.
cached takes a concrete execution trace and runs symbolic execution on the trace to get the formula of each memory address.
cached is quite precise in avoiding false positives.
however cached is not able to detect secretdependent control flows.
we adopted a similar approach to model the secret dependent data accesses.
abacus differs from cached in that we do not use traditional taint tracking or domain knowledge to cut the trace when identifying secret dependent data access vulnerabilities.
abacus works on machine instructions directly instead of intermediate representations.
moreover abacus finds secret dependent controlflows at the same time and gives a precise quantification of the leakage.
data detects address based side channel vulnerabilities by comparing different execution traces under various test inputs.
after collecting execution traces data aligns them and finds the differences.
it uses statistical hypothesis testing to find true leakages.
however both imperfect trace alignment and statistical testing result that data can produce false positives.
microwalk uses mutual information mi between sensitive input and execution state to detect sidechannels.
both hardware and software side channels mitigation techniques have been proposed recently.
hardware countermeasures including partitioning hardware resources randomizing cache accesses and designing new architecture require changes to complex processors and are complex to adopt.
on the contrary software approaches are usually easy to implement.
coppens et al.
uses a compiler to eliminate key dependent controlflow transfers.
crane et al.
mitigated side channels by randomizing software.
as for crypto libraries the basic idea is to eliminate key dependent control flow transfers and data accesses.
common approaches include bit slicing and unifying control flows .
b. quantification proposed by denning and gray quantitative information flow qif aims at providing an estimation of the amount of leaked information from the sensitive information given the public output.
if zero bits of the information are leaked the program is called non interference.
mccamant and ernst quantify the information leakage as the network flow capacity.
backes et al.
propose an automated method for qif by computing an equivalence relation on the set of input keys.
but the approach cannot handle real world programs with bitwise operations.
phan et al.
propose symbolic qif.
the goal of their work is to ensure a program is non interference.
they adopt an over approximation method to estimate the total information leakage and their method does not work for secret dependent memory access side channels.
pasareanu et al.
combine symbolic analysis and maxsmt solving to synthesize the concrete public input that can lead to the worst case leakage.
they assume the target program has multiple different input secrets and calculate theaverage leakage for one fixed public input.
chalice quantifies the leaked information for a given cache behavior.
it symbolically reasons about cache behavior and estimates the amount of leaked information based on cache miss hit.
their approach only scale to small programs which limits its usage in real world applications.
on the contrary abacus assesses the sensitive level of side channels with different granularities.
it can also analyze side channels in real world crypto libraries.
c. model counting model counting refers to the problem of computing the number of models for a propositional formula sat .
there are two approaches to solving the problem exact model counting and approximate model counting.
we focus on approximate model counting since it is our approach.
wei and selman introduce approxcount a local search based method using markov chain monte carlo mcmc .
approxcount has the better scalability than exact model counters.
other approximate model counter includes samplecount mbound and minicount .
unlike approxcount these model counters can give lower or upper bounds with guarantees.
despite the rapid development of model counters for sat and some research on modulo theories model counting smt they cannot be directly applied to side channel leakage quantification.
approxflow uses approxmc for information flow quantification but it has only been tested with small programs.
ix.
c onclusion this paper presents a novel method to quantify addressbased side channel leakage.
we implement the method in a prototype called abacus and show its effectiveness in finding and quantifying side channel leakage.
with the new definition of information leakage that models actual sidechannel attackers quantifying the number of leaked bits helps understand the severity level of side channel vulnerabilities.
the evaluation confirms that abacus is useful in estimating the amount of leaked information in real world applications.
x. d ata availability abacus is publicly available at abacus.
the repository also contains benchmarks metadata and raw results of our experiments.
xi.
a cknowledgement we thank ziqi wang pei wang zhaofeng chen and the anonymous reviewers for their valuable feedback.
the work was supported in part by the national science foundation nsf under grant cns and the office of naval research onr under grants n00014 n00014 and n00014 .
807references d. agrawal b. archambeault j. r. rao and p. rohatgi the em sidechannel s in international workshop on cryptographic hardware and embedded systems .
springer .
m. kar a. singh s. mathew a. rajan v .
de and s. mukhopadhyay improved power side channel attack resistance of an aes core via a security aware integrated buck voltage regulator in isscc .
s. chari c. s. jutla j. r. rao and p. rohatgi towards sound approaches to counteract power analysis attacks in annual international cryptology conference .
springer .
m. alam h. a. khan m. dey n. sinha r. callan a. zajic and m. prvulovic one done a single decryption em based attack on openssl s constant time blinded rsa in usenix security .
d. genkin a. shamir and e. tromer rsa key extraction via lowbandwidth acoustic cryptanalysis in annual cryptology conference .
springer .
y .
xu w. cui and m. peinado controlled channel attacks deterministic side channels for untrusted operating systems in ieee symposium on security and privacy .
j. v .
bulck m. minkin o. weisse d. genkin b. kasikci f. piessens m. silberstein t. f. wenisch y .
yarom and r. strackx foreshadow extracting the keys to the intel sgx kingdom with transient out of order execution in usenix security .
s. van schaik c. giuffrida h. bos and k. razavi malicious management unit why stopping cache attacks in software is harder than you think in usenix security .
s. lee m. w. shih p. gera t. kim h. kim and m. peinado inferring fine grained control flow inside sgx enclaves with branch shadowing inusenix security .
d. gruss r. spreitzer and s. mangard cache template attacks automating attacks on inclusive last level caches in usenix security .
f. liu y .
yarom q. ge g. heiser and r. b. lee last level cache side channel attacks are practical in ieee symposium on security and privacy .
d. a. osvik a. shamir and e. tromer cache attacks and countermeasures the case of aes in proceedings of the the cryptographers track at the rsa conference on topics in cryptology ser.
ct rsa .
springer verlag .
d. gullasch e. bangerter and s. krenn cache games bringing access based cache attacks on aes to practice in ieee symposium on security and privacy .
s. wang p. wang x. liu d. zhang and d. wu cached identifying cache based timing channels in production software in usenix security .
y .
tsunoo t. saito t. suzaki m. shigeri and h. miyauchi cryptanalysis of des implemented on computers with cache in cryptographic hardware and embedded systems ches c. d. walter .
k. ko and c. paar eds.
springer berlin heidelberg .
s. weiser a. zankl r. spreitzer k. miller s. mangard and g. sigl data differential address trace analysis finding address based side channels in binaries in usenix security .
j. wichelmann a. moghimi t. eisenbarth and b. sunar microwalk a framework for finding side channels in binaries in acsac .
r. brotzman s. liu d. zhang g. tan and m. kandemir casym cache aware symbolic execution for side channel detection and mitigation in ieee symposium on security and privacy .
s. wang y .
bao x. liu p. wang d. zhang and d. wu identifying cache based side channels through secret augmented abstract interpretation in usenix security .
g. doychev d. feld b. kopf l. mauborgne and j. reineke cacheaudit a tool for the static analysis of cache side channels inusenix security .
c. aum ller p. bier w. fischer p. hofreiter and j. p. seifert fault attacks on rsa with crt concrete results and practical countermeasures ininternational workshop on cryptographic hardware and embedded systems .
springer pp.
.
y .
yarom and k. falkner flush reload a high resolution low noise l3 cache side channel attack in usenix security .
m. backes b. k pf and a. rybalchenko automatic discovery and quantification of information leaks in ieee symposium on security and privacy .
w. wei and b. selman a new approach to model counting in theory and applications of satisfiability testing f. bacchus and t. walsh eds.
springer berlin heidelberg .
q. ge y .
yarom d. cock and g. heiser a survey of microarchitectural timing attacks and countermeasures on contemporary hardware journal of cryptographic engineering vol.
no.
.
j. szefer survey of microarchitectural side and covert channels attacks and defenses journal of hardware and systems security vol.
no.
.
y .
yarom d. genkin and n. heninger cachebleed a timing attack on openssl constant time rsa journal of cryptographic engineering vol.
no.
.
d. moghimi j. van bulck n. heninger f. piessens and b. sunar copycat controlled instruction level attacks on enclaves in usenix security .
c. e. shannon a mathematical theory of communication bell system technical journal vol.
no.
pp.
.
d. clark s. hunt and p. malacaria a static analysis for quantifying information flow in a simple imperative language journal of computer security vol.
no.
pp.
.
g. smith on the foundations of quantitative information flow in foundations of software science and computational structures l. de alfaro ed.
springer berlin heidelberg .
g. doychev and b. k pf rigorous analysis of software countermeasures against cache attacks in pldi .
k. zhang z. li r. wang x. wang and s. chen sidebuster automated detection and quantification of side channel leaks in web application development in ccs .
l. bang a. aydin q. s. phan c. s. p as areanu and t. bultan string analysis for side channels with segmented oracles in fse .
s. chattopadhyay m. beck a. rezine and a. zeller quantifying the information leak in cache attacks via symbolic execution in memocode .
p. c. kocher timing attacks on implementations of diffie hellman rsa dss and other systems in annual international cryptology conference .
springer pp.
.
a. askarov and s. chong learning is change in knowledge knowledge based security for dynamic policies in ieee 25th computer security foundations symposium csf .
ieee pp.
.
z. wang and r. b. lee new cache designs for thwarting software cache based side channel attacks in isca .
y .
shoshitaishvili r. wang c. salls n. stephens m. polino a. dutcher j. grosen s. feng c. hauser c. kruegel and g. vigna sok state of the art of war offensive techniques in binary analysis inieee symposium on security and privacy .
d. brumley i. jager t. avgerinos and e. j. schwartz bap a binary analysis platform in computer aided verification g. gopalakrishnan and s. qadeer eds.
.
d. song d. brumley h. yin j. caballero i. jager m. g. kang z. liang j. newsome p. poosankam and p. saxena bitblaze a new approach to computer security via binary analysis in international conference on information systems security .
springer pp.
.
intel corporation intel and ia architectures software developer s manual .
i. yun s. lee m. xu y .
jang and t. kim qsym a practical concolic execution engine tailored for hybrid fuzzing in usenix security .
t. dullien and s. porst reil a platform independent intermediate representation of disassembled code for static code analysis .
l. de moura and n. bj rner z3 an efficient smt solver in proceedings of the theory and practice of software 14th international conference on tools and algorithms for the construction and analysis of systems ser.
tacas etaps pp.
.
p. godefroid m. y .
levin d. a. molnar et al.
automated whitebox fuzz testing.
in ndss vol.
pp.
.
libsodium .
.
available d. j. bernstein t. lange and p. schwabe the security impact of a new cryptographic library in international conference on cryptology and information security in latin america .
springer pp.
.
j. b. almeida m. barbosa g. barthe f. dupressoir and m. emmi verifying constant time implementations in usenix security .
j. bacelar almeida m. barbosa j. s. pinto and b. vieira formal verification of side channel countermeasures using self composition sci.
comput.
program.
vol.
no.
.
a. langley ctgrind checking that functions are constant time with valgrind url com agl ctgrind vol.
.
d. page partitioned cache architecture as a side channel defence mechanism iacr cryptology eprint archive vol.
.
d. zhang y .
wang g. e. suh and a. c. myers a hardware design language for timing sensitive information flow security.
x. li v .
kashyap j. k. oberg m. tiwari v .
r. rajarathinam r. kastner t. sherwood b. hardekopf and f. t. chong sapper a language for hardware level security policy enforcement in asplos .
m. werner t. unterluggauer l. giner m. schwarz d. gruss and s. mangard scattercache thwarting cache attacks via cache set randomization in usenix security .
m. w. shih s. lee t. kim and m. peinado t sgx eradicating controlled channel attacks against enclave programs.
in ndss .
b. coppens i. verbauwhede k. d. bosschere and b. d. sutter practical mitigations for timing based side channel attacks on modern x86 processors in ieee symposium on security and privacy .
e. brickell g. graunke m. neve and j. p. seifert software mitigations to hedge aes against cache based software side channel vulnerabilities.
iacr cryptology eprint archive vol.
.
s. crane a. homescu s. brunthaler p. larsen and m. franz thwarting cache side channel attacks through dynamic software diversity.
in ndss .
f. biondi m. a. enescu a. heuser a. legay k. s. meel and j. quilbeuf scalable approximation of quantitative information flow in programs in international conference on verification model checking and abstract interpretation .
springer pp.
.
b. kopf l. mauborgne and m. ochoa automatic quantification of cache side channels in computer aided verification p. madhusudan and s. a. seshia eds.
springer berlin heidelberg .
s. mccamant and m. d. ernst quantitative information flow as network flow capacity in pldi .
q. s. phan p. malacaria o. tkachuk and c. s. p as areanu symbolic quantitative information flow sigsoft softw.
eng.
notes vol.
no.
.
z. zhou z. qian m. k. reiter and y .
zhang static evaluation of noninterference using approximate model counting in ieee symposium on security and privacy .
c. s. pasareanu q. s. phan and p. malacaria multi run side channel analysis using symbolic execution and max smt in ieee 29th computer security foundations symposium csf .
ieee pp.
.
w. wei and b. selman a new approach to model counting in international conference on theory and applications of satisfiability testing .
springer pp.
.
c. p. gomes j. hoffmann a. sabharwal and b. selman from sampling to model counting.
in ijcai pp.
.
c. p. gomes a. sabharwal and b. selman model counting a new strategy for obtaining good bounds in aaai .
l. kroc a. sabharwal and b. selman leveraging belief propagation backtrack search and statistics for model counting in international conference on integration of artificial intelligence ai and operations research or techniques in constraint programming .
springer pp.
.
k. v. gleissenthall r. g. k c d. stefan and r. jhala iodine verifying constant time execution of hardware in usenix security .
m. tiwari j. k. oberg x. li j. valamehr t. levin b. hardekopf r. kastner f. t. chong and t. sherwood crafting a usable microkernel processor and i o system with strict and provable information flow security in acm sigarch computer architecture news vol.
no.
.
acm .
r. k nighofer a fast and cache timing resistant implementation of the aes in cryptographers track at the rsa conference .
springer .
c. rebeiro d. selvakumar and a. devi bitslice implementation of aes in international conference on cryptology and network security .
springer .
d. e. robling denning cryptography and data security .
addisonwesley longman publishing co. inc. .
j. w. gray iii toward a mathematical foundation for information flow security journal of computer security vol.
no.
pp.
.
d. chistikov r. dimitrova and r. majumdar approximate counting in smt and value estimation for probabilistic programs acta informatica vol.
no.
pp.
.
q. s. phan model counting modulo theories arxiv preprint arxiv .
.
s. chakraborty k. s. meel and m. y .
vardi algorithmic improvements in approximate counting for probabilistic inference from linear to logarithmic sat calls tech.
rep. .