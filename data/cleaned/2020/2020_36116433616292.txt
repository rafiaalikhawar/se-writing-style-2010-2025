codecoveragecriteriaforasynchronous programs mohammad ganji simonfraseruniversity canada m ganji sfu.casaba alimadadi simonfraseruniversity canada saba sfu.cafrank tip northeasternuniversity usa f.tip northeastern.edu abstract asynchronous software often exhibits complex and error prone behaviorsthatshouldbetestedthoroughly.codecoveragehasbeen themostpopularmetrictoassesstestsuitequality.
however traditional code coverage criteria do not adequately re f lect completion interactions anderrorhandling ofasynchronous operations.
this paper proposes novel test adequacy criteria for measuring i completion of asynchronous operations in terms of both successful and exceptional execution ii registration ofreactions for handling both possible outcomes and iii execution of said reactionsthroughtests.
weimplement jscope atoolforautomaticallymeasuringcoverageaccordingtothesecriteriainjavascript applications as an interactive plug infor visualstudiocode.
anevaluationof jscopeon20javascriptapplicationsshowsthat theproposedcriteriacanhelpimproveassessmentoftestadequacy complementing traditional criteria.
according to our investigation of real github issues concerned with asynchrony the new criteriacanhelprevealfaultyasynchronousbehaviorsthatareuntested yet are deemed covered by traditional coverage criteria.
we also reportonacontrolledexperimentwith12participantstoinvestigatetheusefulnessof jscopeinrealisticsettings demonstrating itseffectivenessinimprovingprogrammers abilitytoassesstest adequacyanddetectuntestedbehaviorofasynchronous code.
ccs concepts softwareanditsengineering softwaretestinganddebugging.
keywords code coverage dynamicanalysis asynchronous javascript acmreference format mohammad ganji saba alimadadi and frank tip.
.
code coverage criteriaforasynchronousprograms.in proceedingsofthe31stacmjoint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa 13pages.
.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forpro f itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe f irstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspeci f icpermission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
introduction asynchronousprogrammingisextensivelyused forwebdevelopmentandiscrucialforprovidingbene f itssuchasnon blockingi o seamless and real time user interactions and efficient client server communications.
javascript is single threaded and asynchronous execution of potentially long running tasks is what enables the applications to remain responsive while processing events.
in recent years javascript spromises and async await haverapidlybecomethemostpopularmechanismsfor supportingasynchrony supplantingthepreviouserror proneapproachbasedonevent basedprogrammingandcallbacks.
however understanding the f low of asynchronous execution and identifying and f ixingfaultsremainchallengingfordevelopers .
developers typically rely on an application s tests to identify faults and verify the application s behavior.
they often use code coverage criteria such as statement and branch coverage to assess the adequacy of their tests throughout the process and to identify and address the shortcomings of existing tests in order to improve their quality .
however traditional coverage criteria are unable to examine various scenarios of exercising asynchronous code in terms of eventual completion of asynchronous operations theirinteractions andtheirerrorhandling.despitetheimportance of testing asynchronous programs and the severity of the issues that occur in such programs there are currently no code coverage criteriathattargettheadequacyoftestswithregardtoexploring scenarios that occur inasynchronous code.
this paper presents new coverage criteria for assessing the adequacyoftestsinexercisingtheasynchronousbehaviorofjavascript applications.
these criteria quantify the adequacy of tests in covering eventual successful or exceptional completion of asynchronous operations associatingreactionswiththeoutcomesofasynchronousoperations andexecutionof chainsof reactionsbytheapplication s tests.
these criteria target the semantics of javascript s promises and async awaitfeatures and are meant to complement existing coveragemetrics such as statementandbranchcoverage.
we implement our approach in a plugin for visual studio code namedjscope which presents coverage results as a textual report andthroughaninteractivevisualization.
jscopeautomaticallyinstrumentsan application scodetocalculate andreportcoverage according to three criteria namely settlement coverage reaction registration coverage andreaction executioncoverage .
anevaluationof jscopeon20javascriptapplicationsshowsthat theproposedcriteriacanhelpimproveassessmentoftestadequacy complementing traditional criteria.
furthermore an investigation of real github issues concerned with asynchrony demonstrates thatthenewcriteriacanhelprevealfaultyasynchronousbehaviors thatareuntestedyetaredeemedcoveredbytraditionalcoverage criteria.
we also report on a controlled experiment with participantstoinvestigatetheusefulnessof jscopeinrealisticsettings esec fse december 3 9 san francisco ca usa mohammad ganji saba alimadadi and frank tip demonstratingthatitiseffectiveinimprovingprogrammers ability to assesstest adequacyanddetectuntestedandbuggy behavior.
in summary this paper makesthe following contributions newcoveragecriteriathatquantifythedegreetowhichkey scenarios are exercisedinasynchronous code aninstrumentation basedtechniqueformeasuringcoverage according to thesecriteria implementation of the technique in an interactive vs code extension named jscopethat computes a coverage report andprovidesan interactive visualization and anempiricalevaluation demonstratingtheabilityoftheproposed criteria to identify test inadequacies in asynchronous code.
we also report on a user study showing that jscope improvestheeffectivenessofprogrammerswhentestingand debuggingasynchronous code.
background inrecentyears manyprogramminglanguageshavebeenextended with support for asynchrony.
for example java and dart now support futures c and python support async await and javascript f irst added promises and then de f ined an async await feature intermsof promises.
thesenewfeatures injavascriptare usedpervasivelyandpose signi f icant newchallenges for testing.
in this section we provide an overview of promises and async await two features that have supplanted event driven asynchronousprogramminginjavascript.whileourtechniquesdonotapply directlytothelatter anyevent drivenapicanbe promisi f ied into an equivalent promise based one using standard library functions.
creatingpromises.
apromiserepresentsthevalueofanasynchronouscomputation andis inone ofthree states pending ful f illed orrejected.thestateofapromisecanchangeatmostonce from pendingtoful f illed orfrompendingtorejected.wewillsaythat apromiseis settledifitsstateisful f illedorrejected.promisesare created by invoking the promiseconstructor and are initially in the pending state.
promises come equipped with two methods resolve andreject for ful f illing or rejecting the promise with a particular value respectively.
for example the following code assigns a promise to a variable p1that is either ful f illed with the value hello orrejectedwithan errorobject.
1const p1 new promise resolve reject 2if math.random .
resolve hello 3else reject new error oops promisescanalsobeconstructedusingthefunctions promise.
resolveandpromise.reject .
each of these functions takes a single argument i.e.
the value that the promise should be ful f illed or rejected with.
the following example creates a promise that is ful f illedwiththe value 5const p2 promise.
resolve synchronizationfunctionssuchas promise.all andpromise.race areotherwaystocreatepromises.theywaitonasetofpromises to be settledinany order returningasinglepromise.
registeringreactionsonpromises.
thethenandcatchmethods enableprogrammerstoregister reactionsonpromises i.e.
functions that are executed asynchronously when a promise is ful f illed orrejected.thevaluereturnedbyareactioniswrappedinanother promise thusenablingprogrammersto chainasynchronouscomputations and propagate errors.
for example the following code fragment shows the creation of a promise chain that starts with p1 6p1.then function f1 v console .
log v world .catch f3 err console .
log error occurred err ifp1was ful f illed with the value hello the reaction that is registeredbycalling thenonp1online6concatenatesthatvaluewith anotherstring world andprintsittotheconsole line 7registers arejectreactiononthepromisethatiscreatedbycalling thenon line6.
it prints an error message if any of the previous promises in thechainisrejected.therefore theabove codesnippetwilleither print hello world or error occurred oops .
linkingpromises.
invokingthe promiseconstructorandthe then andcatchmethodscreatesanewpromise u1d45d.however ifthe resolve associated with the promiseconstructor is invoked with an argument that evaluates to a promise u1d45d or when a reaction that is registeredbycalling thenorcatchreturnsapromise u1d45d thepromise u1d45d becomes linkedwith u1d45d.
assuch if u1d45d isresolved with a value u1d463 then u1d45disalsoresolvedwith u1d463 and if u1d45d isrejectedwith a value u1d452 then sois u1d45d andif u1d45d remainspending sodoes u1d45d.this example 8const p3 promise.
resolve hello 9const p4 promise.
resolve there 10p3.then p4 establish link with p4 .then v console .
log v prints there creates promises and assigns them to variables p3andp4.
given thatp3is ful f illed its reaction is executed and returns p4 sop4 andthepromisereturnedby p3.then online10becomelinked.
sincep4resolvesto there the promisereturnedby p3.then on line10resolves to there as well causingthe reaction registered online11to executeandprint this value.
async await.javascript s async awaitfeatureprovidesasyntactic enhancementontopofpromises.afunctiondeclaredas asyncreturns apromise that isful f illedwiththe function s return value.
in anasyncfunction await expressions may be used to wait for a promise settle.
if an expression u1d452evaluates to a promise u1d45d then an expression await u1d452evaluates to u1d463 if it is rejected with a value err erristhrownas an exception that can be caught using try catch .
12async function f 13try 14letv await e catch e intheaboveexample eisanexpressionthatevaluatestoapromise u1d45d.
the execution of the code fragment depends on ful f illmentof u1d45d.soonemaythinkof asaful f illreactionassociated with u1d45d and similarly the fragment as a reject reaction of u1d45d.
motivation and challenges this section elaborates on some challenges in identifying parts ofasynchronouscodethatdespitebeingcoveredbytests arenot tested sufficiently andthusmayincludebugs.
weuserealbug reports from figures 2toillustrate thechallenging nature oflocating bugs in asynchronous code.
these challenges are intensi f ied by developers con f idence in correctness of the code when their testsexercisethatcode.whileexistingcoveragemetricsmayshow 1308code coverage criteria for asynchronous programs esec fse december 3 9 san francisco ca usa remove async req const dbrepo await repo.remove req.args if dbrepo dbrepo.gist try webhook.remove req await webhook.remove req catch error handle the error return dbrepo figure implementation of reposervice.remove .
fullcoverageofthesecodesegments thesemetricsareunableto examine the execution of scenarios speci f icto asynchronous code.
.
unhandledexceptions an asynchronous operation can eventually terminate successfully or it may fail.
while a successful completion is usually the desired outcome the failures or exceptional cases should be tested thoroughly to assess the applications robustness and error recovery.
exceptional scenarios are often not thoroughly tested by many applications whichcanleadtobugsandunexpectedbehaviorsduringexecutionshouldan exception occur .
for instance await expressions may be surrounded by try catch for handling a failed completion of the async function.
however many applications do not have adequate exception handling in place and do not sufficientlytestexceptionalandfailurecasesintheirasynchronouscode.
inthefollowingexample wediscusshowfailuretoproperlyhandle the rejection of an asynchronous operation results in the whole system crashing.
the bug occurs despite code coverage reports showing that the relatedpart ofthe code wasinfact covered.
.
.
example .
cla assistant is aweb servicethat streamlines theprocessofsigningcontributorlicenseagreements clas .
thisprojectisbuiltbysapse2developersandhasmorethan1000 stars.thecodein figure1showstheasyncfunction reposervice .remove which is responsible for removing a repository from cla assistant using repo.remove on line18 and removing all of its webhooks webhook.remove line21 .
tohandleunexpectederrors thecallto webhook.remove isplaced inside a try catch lines20 which assures programmers of the robustness of this code segment.
programmer con f idence in thiscodesegmentisreinforcedbycoveringandexercisingallits statements through the tests.
despite this a bug was reported whereanunhandledrejectioninthismethodresultedinthehard shutdownoftheservice.furtherinvestigationshowedthatwhile thereisa try catch inplacetohandleerrorsinremovingwebhooks the developers failed to awaitthe asynchronous webhook.remove method.
without an awaitstatement the program does not wait for theasyncfunction to complete its execution.
the execution ofreposervice.remove could end before webhook.remove is rejected withanerrorasynchronously.theexceptionwasthrownoutside the scope of reposervice.remove and thus the catchclause could not have caughtit causing an unhandledrejection.
the f ixaddsan awaitbeforewebhook.remove tomakereposervice .removewaituntil its completion line .
function visibility preview widgetvalue params 27 await new promise resolve await new promise resolve reject this.
trigger up action demand onsuccess resolve onfailure reject addedinfix.
33this.
trigger up option visibility update show figure implementation ofasync function visibility .
.
pending asynchronousoperations anasynchronousoperationremainspendinguntilitis settled successfullyorthroughafailure i.e.
ful f illedorrejected.itiscommon tochainasynchronousoperationstoimposeanorderingontheir execution.
in such cases successful and exceptional completion of anasynchronousoperationeachtriggerrespectivereactions and the execution of the program continues.
it is typically expected for allasynchronousoperationsto settle.
incaseswherethisdoesnot happen theappropriatereactionsarenotinvoked andthechain ofexecutionisinterrupted.thefollowingexampledemonstrates a real bug where a pending asynchronous operation causes the program to freeze in a loading state preventing the users from further interactionswiththe system.
.
.
example .
figure 2shows changes related to a bug f ix from odoo asuiteofweb basedopensourcebusinessapps including marketing ecommerce andwebsitebuilderapps.3ithasnearly 25k stars on github and is forked over 16k times.
the async functionvisibility isresponsibleforupdatingthevisibilityofa f ield insideawidgetinthesidebarmenuofthewebsitebuilder.theexecution of this method depends on the completion of a promise that noti f ies the parent widget to toggle its visibility lines .
the noti f icationoccursthrough trigger up onlines29 .areaction is assigned to this operation that is invoked upon its successful completion ful f illingthepromise line .thevisibility method then makes the f ield on the widget visible allowing the user to interact withthe editor line .
thebugreportindicatesascenariowhereawidgetisfrozen with aspinnerspinningforever.theissueoccurswhentheevent f iredby trigger up ends withan exception.
hence the onsuccess callback is not called to ful f ill the promise.
as there is no reject reaction devisedforunsuccessfulcompletionofthepromise itneversettles.
astheexecutionoftheremainingpartofthe visibility method depends on the settlement of the promise the pending promise prevents the execution of line .
this causes the widget to get stuckinaloadingstate makingthe applicationdysfunctional.
the f ixrejects the promise upon failure of trigger up line31 whichsettlesthe promise andallowsthe executionto continue.
asynchronous coveragecriteria ourgoalistode f inecoveragecriteriathatre f lecttowhatextentthe possible asynchronous behaviors of an application are exercised focusing on promise based asynchrony.
figure 3illustrates the lifecycleofapromise uponcreation apromiseisinthe pending statefromwhenceitmaytransitiontothe settledstatewhenitis 1309esec fse december 3 9 san francisco ca usa mohammad ganji saba alimadadi and frank tip pendingnew promise ... settledfulfill reject .then .catch register reaction .then .catch register reaction execute reaction figure illustrationofthelifecycleofapromise.
ful f illed or rejected.
reactions may be registered on a promise at anytimeinthependingorsettledstate.suchreactionswillexecute whenthepromiseissettled.ourcoveragecriteriare f lectthekey steps of promise settlement promise registration and promise execution.itis noteworthythatnoneof thesestepssubsumesthe others because i settlement of a promise does not imply that reactions are registered on it ii registration of a reaction of a promise does not imply that the promise will be settled and hence that the reaction will execute and iii execution of a reaction of a promiserequires bothsettlementofthepromiseandregistration ofthereaction.further reactionsmayberegisteredonpromises afterthey have settled.
by proposing distinct criteria for each step issuesthatresultinfailuretoful f illapromiseandfailuretoregister areactionwillmanifestthemselves throughlackofcoverage.
we de f ine our criteria in terms of events in execution traces thatpertaintotheuseofasynchronousfeatures.wede f inethree coverage criteria that target the completion of all asynchronous operations successful and exceptional registration of reactions for both outcomes of the operations and the execution of said reactions respectively.
we begin by de f ining coverage notions for javascript applications that use promises and will then explain informally how these notions extend to async await.
finally we willdiscuss the feasibilityofthesecriteria.
.
eventsandtraces table1de f inesthepromise relatedeventsthatmayoccurduring execution.here weassumethateachpromisethatiscreatedatrun time hasaunique promise identi f ier pid .further let sde f inethe set of source locations where promises are created including i calls to the promiseconstructor ii calls to promise.resolve and promise.reject iii calls to then catch andfinallyon promise objects iv calls to promise.all promise.race promise.any and promise.allsettled and v the end of execution of an asyncfunction eithernormal orexceptionalexit .
createevents occur when any of situations i v occurs.
link eventsoccurwhenthe resolvefunctionassociatedwithacalltothe promiseconstructor or promise.resolve is invoked with an argumentthatisapromise.a linkeventisalwaysimmediatelypreceded byacreateevent.
ful f illedeventsoccurwhenthe resolvefunctionassociatedwith apromiseisinvokedwithanargumentthatisnotapromise and when a reaction returns a value that is not a promise.
likewise rejectedeventsoccurwhenthe rejectfunctionassociatedwitha promiseisinvoked andwhenareactionthrowsanexception.note thatthetraceonlyrecords ful f illedandrejectedeventsforpromises thatareexplicitlyful f illedorrejected andnotforlinkedpromises .
regful f illevents happen when thenis used to register a ful f illreactiononapromise and regrejecteventshappenwhen catchorthe second argument of thenis used to register a reject reaction.
lastly execful f illandexecrejectevents happen when a previously registeredful f ill reactionorreject reactionstartsexecuting.
.
coverage criteriaforpromise basedcode in the de f initions that follow pid pid represent promise identi f iers u1d453 u1d453 denote functions and loc loc denote source locations.
de f inition 1de f ines a trace as a sequence of trace events see table .
we willuse u1d70f u1d70f to refer to executiontraces.
definition trace .
atraceis an ordered sequence of trace events as speci f ied in table .
foreachpromise pidthatoccursinatrace u1d70f thereisaunique trace element create pid loc corresponding to its creation.
we de f ineloc pid as the location locthat is referenced in this trace element.the f irstcoveragecriterionwede f ineis settlementcoverage.this measures the fractionof promises de f inedbyan application that are settled i.e.
ful f illed or rejected .
here we consider a promise pidoriginating from location locto be fully covered if the trace contains both ful f illedandrejectedevents for pid which requireslocation loctobeexecutedatleasttwice.moreover whena ful f illedorrejectedeventisobservedforapromise pid allpromises directly or indirectly linked with pidare settled as well.
to capture this we f irstde f ine l pid u1d70f todenotethesetofpromiseslinked topidintrace u1d70f.
definition2 linkedpromises .
letpidbethepromiseidenti f ier for a promise.
then the set of promises linked to pidin a trace u1d70f denoted by l pid u1d70f is de f ined as l pid u1d70f pid pid pid or loc link pid pid loc u1d70f pid l pid u1d70f notethat piditself isalsoan element of l pid u1d70f .
using de f inition we now de f ine the notion of settlement coverage as stated in de f inition .
informally the de f inition computes the number of locations loc of promises pid that are linked to a promisepidforwhicha ful f illedorarejectedeventoccursinthe trace u1d70f.itthendividesthesumoftheseby s wheresisthe number oflocations where apromise iscreated.
definition settlement coverage .
let program pcreate promisesatlocationsin s andlet u1d70fbethetraceforanexecutionof p.wede f inethe settlement coverage of u1d70fas loc ful f illed pid loc u1d70f pid l pid u1d70f loc loc pid loc rejected pid loc u1d70f pid l pid u1d70f loc loc pid s ournextgoalistomeasurethepercentageofpromisesonwhich reactions are registered.
here we consider a promise fully covered if both a ful f ill reaction and a reject reaction are registered on it.
however we need to consider that the rejection of a promise u1d45d maybehandledbyarejectreactionthatisnotregistereddirectly on u1d45ditself but at the end of apromise chain that starts with u1d45d.to capture this we de f ine the set of dependent promises pidthat occur at the end of a chain of ful f ill reactions that starts at pid.
in such cases we willwrite pid pid as de f inedbelowinde f inition .
1310code coverage criteria for asynchronous programs esec fse december 3 9 san francisco ca usa table traceevents forasynchronousoperations.
create pid loc creationofpromise pidat location loc ful f illed pid loc promisepidis ful f illed at location loc rejected pid loc promisepidis rejected at location loc link pid pid loc promisepidbecomeslinked to promise pid at location loc regful f ill pid u1d453 loc register ful f ill reaction u1d453on promise pidat location loc whichmay chain it to promise pid regreject pid u1d453 loc register rejectreaction u1d453on promise pidat location loc whichmay chain it to promise pid execful f ill pid u1d453 loc execute ful f ill reaction u1d453on promise pidat location loc execreject pid u1d453 loc execute rejectreaction u1d453on promise pidat location loc definition dependent promises .
let program pcreate promisesatlocationsin s andlet u1d70fbethetraceforanexecutionof p.then pid pid if braceleftbiggpid pid or pid pid andregful f ill pid loc u1d453 pid usingde f inition de f inition 5belowcomputesreactionregistration coverage through the following steps i compute the number oflocations loc wherearegful f illeventoccursonapromise pidfor whichacreateeventoccursinthetrace ii computethenumber of locations loc where aregrejectevent occurs on a promise pid wherepid pid andwherea createeventfor pidoccursinthe trace and iii compute the sum ofthese anddivide itby s .
definition5 reactionregistrationcoverage .
letprogram pcreate promises at locations in s and let u1d70fbe the trace for an executionof p.wede f inethe reactionregistrationcoverage of u1d70fas loc create pid loc u1d70f regful f ill pid u1d453 loc pid u1d70f loc create pid loc u1d70f pid pid regreject pid u1d453 loc pid u1d70f s lastly we de f ine the notion of reaction execution coverage measuring the percentage of promises with executed reactions.
this is expressedbyde f inition 6below whichissimilartode f inition except that it checks for the presence of execful f illandexecreject events in the trace instead of regful f illandregrejectevents.
achieving full reaction execution coverage for a promise created at loc requires that locisexecutedat leasttwice.
definition6 reactionexecutioncoverage .
letprogram p createpromiseatlocationsin s andlet u1d70fbethetraceforanexecution ofp.wede f inethe reactionexecutioncoverage of u1d70fas loc create pid loc u1d70f execful f ill pid u1d453 loc u1d70f loc create pid loc u1d70f pid pid execreject pid u1d453 loc u1d70f s .
async await the semantics of javascript s async awaitis de f ined in terms of promises and provides a more convenient syntax that is highly similar to that of sequential code.
an asyncfunction always returnsapromise thusuponcallsto asyncfunctionsa createevent is included in the trace.
when an asyncfunction returns a value that is not a promise a ful f illedevent is included in the trace to re f lect its ful f illment.
a rejectedevent is emitted if an asyncfunction throwsanexceptionthatisnotcaughtwithinitsbody.
thecode fragmentfollowingan awaitstatementwillbeconsideredaful f ill reactionforthepromise u1d45dreturnedbythe asyncfunction andthus aregful f illevent will be added to the trace.
if the await expressionis in atry catch thecatchstatement will be the reject reaction i.e.
aregrejectevent.if u1d45disful f illed thenan execful f illeventisemitted.
otherwise the catchstatement executes and an execrejectis recorded in the trace.
assuming these trace elements the same coveragede f initionsapply.
.
example consider thefollowing codedisplaying function funand itstests.
35function fun inputstr const p1 new promise resolve resolve json.parse inputstr .then function f1 data console .
log data.foo .bar tests test t1 inputstr is valid json fun foo bar hello .
test t2 inputstr is not a valid json fun hello .
in orderto measure fun s asynccoverage criteria we f irstobtain the following trace.
46create u1d45d u1d456 u1d451 u1d45d1 l36 l38 start of t1 47ful f illed u1d45d u1d456 u1d451 u1d45d1 l37 l37 48create u1d45d u1d456 u1d451 u1d461 uni210e u1d452 u1d45b l38 l40 promise.then returns a promise 49regful f ill u1d45d u1d456 u1d451 u1d45d1 f1 l38 l38 u1d45d u1d456 u1d451 u1d461 uni210e u1d452 u1d45b 50ful f illed u1d45d u1d456 u1d451 u1d461 uni210e u1d452 u1d45b l38 l40 51execful f ill u1d45d u1d456 u1d451 u1d45d1 f1 l38 l40 52create u1d45d u1d456 u1d451 u1d45d1 l36 l38 start of t2 53rejected u1d45d u1d456 u1d451 u1d45d1 l37 l37 error thrown by json.parse rejects p1.
54create u1d45d u1d456 u1d451 u1d461 uni210e u1d452 u1d45b l38 l40 55regful f ill u1d45d u1d456 u1d451 u1d45d1 f1 l38 l38 u1d45d u1d456 u1d451 u1d461 uni210e u1d452 u1d45b we then identify two unique promises from the traces obtained fromt1andt2.the promisecreatedatl36 l38achieves full settlementcoveragewitha ful f illedeventint1anda rejectedevent int2.however thepromisecreatedatl38 l40achievespartial settlementcoveragewithonlyone ful f illedeventint1.basedon theobserved regful f illandregrejectevents thetwopromisesachieve partial and minimal reaction registration coverage respectively.
reaction execution coverage can also be measured in a similar manner.
overall we calculate a total of settlement coverage reaction registration coverage and reaction execution coverage for function fun.
to achieve full coverage a reject reactionneedstoberegisteredtobothpromises e.g.
addinga catch at the end of the chain .
the reaction then needs to be executed throughanewly writtentest that rejectsthe promise at l38 l40.
1311esec fse december 3 9 san francisco ca usa mohammad ganji saba alimadadi and frank tip figure jscopecoverage results forclaassistant.
the open editorshows reposervice.remove inrepo.js.
.
feasibility ofasynchronouscoverage criteria the proposed coverage criteria for asynchronous programs are similartotraditionalcoveragecriteriainthesensethat100 coverage whiledesirable isnotalwaysattainable.forexample ina conditionalstatement if u1d438then u1d4461else u1d4462 ifthecondition u1d438always evaluates to true then the else branch and all the statements in u1d4462areunreachable andbranchcoverageandstatementcoverage willbe less than100 .
analogously inacodefragment e.then whereeisanexpressionthat evaluates to apromise u1d45d the promise createdbythe calltothenwillremainpendingif u1d45disneverful f illedcausingsettlementcoverage toremain lessthan andreactionregistration coverage and reaction execution coverage may remain below for similar reasons.
similar scenarios arisefor asyncfunctions.
approach in this section we describe our approach and our tool jscope for automaticallymeasuringandvisualizingasynchronouscoverage criteriaas de f inedin section4.
.wewill usetheterm asynccoverage to refer to the results of settlement reaction registration and reaction execution coverage combined as jscopecalculates and reports them collectively.
our approach relies on the instrumentationofasynchronousbehaviorsofajavascriptapplication onthe f ly.
jscopeexecutes theinstrumented codethroughthe application s test suite to collect execution traces.
next it utilizes the traces to locate promises their reactions and relations between them such as chains as means to calculate async coverage.
finally jscopepresents the results and relevant warnings in terms of a textual report and an interactive visualization embedded within the developmentenvironment ofvisualstudiocode.
.
instrumentationandtracecollection to automatically collect trace events described in table 1for a program weinstrumentthebehaviorofjavascriptpromisesand asyncfunctionsonthe f ly.executingtheinstrumentedcodethrough runningtheprogram stestsuite weobtainatraceofeventscreated as discussedin section .
.
measuringasynchronouscoverage aspromisescanonlybesettledonce atleasttwotestsarerequired to achieve full async coverage for a promise.
as such we uniquely identify a promise based on its static creation location in the code.
multiple createevents with the same location across several test executionsinatestsuitewillbeconsideredasthesamepromise.
insuchcases coveragereportedby jscopeshouldbeinterpreted accordingly.
in particular if full settlement coverage is reported for a promise created at location u1d43f then this means that at least one promise created at u1d43fwas ful f illed and at least one promise created at u1d43fwas rejected meaning that both possible outcomes were observed.
wethenintegratedifferentexecutionpathscorrespondingtothe same promise to locate its various settlements registered reactions andexecutionofsuchreactions.
ouranalysismaymisspromisesin unexercised parts of code due to the incomplete nature of dynamic analysis.
however the low traditional coverage of these parts will warnthedevelopers f irst.assuch asynccoverageismosteffective when usedcomplementary to the existing coveragecriteria.
next we detect relations between promises such as promise chainsandlinkedpromises.byde f inition arejectreactionatthe endofachainiscapableofcatchingallexceptionscausedbyany promiseinthatchain.inordertohaveamorepreciserepresentation of sufficient error handling our algorithm propagates a reject reaction in a chain to all of its ancestor promises.
additionally for promisesreturnedby catch weonlyrequire ful f illedevent andthe rest are considered covered.
this implies that registering reactions forcatchisoptional asendingchainswitha catchisagenerally acceptedwayofusingpromises.similarly toavoidunresolvable missingcoveragewarnings regful f illeventsareoptionalfor then.
without these heuristics achieving async coverage would be impossible astherewillalwaysbeonepromisewithoutanyhandlersattheendofanychain.ouralgorithmalsodetectspromise linksbylocatingwhereapromise u1d45d1isful f illedwithpromise u1d45d2 andapplies all ful f illedandrejectedeventsof u1d45d2to u1d45d1as well.
finally we calculate and visualize the overall async coverage bycombiningasynccoverageofallpromises andreportalistof warnings for allpromises missingreactions.
1312code coverage criteria for asynchronous programs esec fse december 3 9 san francisco ca usa table summary ofdifferentcoverage metrics reported by jscopeandtraditionalcoverage.
application objects traditional coverage asychronouscoverage name loc tests promises statement function branch settlement registration execution .
nodefetch .
claassistant .
minipassfetch .
cacache .
githubactionmergedependabot .
co .
deleteempty .
json schema refparser .
asynccachededupe .
environment .
socketclusterserver .
socketclusterclient .
minipass .
grant .
expresshttpproxy .
install .
cachegoose .
enquirer .
avvio .
matched average .
visualizingtheasynchronouscoverage wedesignedaninteractivevisualizationintegratedinvscode a widelyuseddevelopmentenvironment basedondatagatheredfrom apreliminaryuserstudyweconducted.userscaninvoke jscope ondemand figure4 a topresenttheresultsasatextualreport figure b c and visual cues overlayed on the code figure d f .jscopesummarizesasynccoverageresultsinthe coverage overview panel to help with overall understanding of async coverage figure4 b c .theoverviewincludesclickablewarnings linkedtothelocationsoftheirrespectivepromises.
jscopeoverlays relevantvisualcuesonthecodeintheeditor.ithighlightspromises using a red yellow green color spectrum to determine their level ofasynccoverage figure4 d .assuch thepromiseinline82is markedred indicatingminimalasynccoverage.similarly thegreen and yellow highlights on line and indicate fully and partially covered promises respectively.
users can obtain more details on the warnings on demand by hovering the mouse over warning cues figure e f .
by leveraging the integration of focus within the context we help maintain programmers mentalmodel of the overallprogram whileworkingwithindividualpromises.
.
implementation we used nodeprof.js for instrumentation and used javascript proxiestointercepttheexecutionofbuilt infeaturesforsettling promises and registering their reactions .
we utilized programmatic apis of mocha and tap testing frameworks for automatic execution of apps and vscode s extension development apito integrate jscopeinto its editor.
in ourimplementationof coverage criteria as per section functions u1d453that create and returnanewpromiseobject similarto util.promisify aretreated specially when a call to u1d453is encountered a createevent is generated for that call and the promise creation inside u1d453is ignored.
this custom notion of context sensitivity during identifying promise creation sites generally results in lower coverage.
however theresults are more actionable as theyenabledetecting lackofcoveragewhenpromisesarecreatedusinghelperfunctions.
evaluation in order for our new coverage criteria to be useful they should be able to reveal untested asynchronous behaviors that are not detectedbytraditionalcoveragecriteria.tothisend we f irstmeasure coverageaccordingtothenewcriteriafor20javascriptapplications and study correlations with traditional coverage criteria.
next we reportonexperimentsthataimtodetermine i whetherthenew coveragecriteriaidentifyuncoveredcodethatcontainsbugs and ii whether using jscopecan improve developers performance when performing tasks related to assessing test adequacy and debugging.
our evaluation targets the following research questions rq1.does having high traditional coverage imply adequate testingofasynchronous code?
rq2.howcanasynchronouscoveragecriteriafacilitateidentifyingtest inadequaciesregarding faultyasynchronous code?
rq3.howdoesusing jscopehelpimprovedevelopers performance inassessing test adequacyanddebugging?
rq4.whatisthe performance overheadof jscope?
.
asynchronouscoverage to answer rq1 weranjscopeon 20web applications measured three types of asynchronous coverage criteria and studied their correlations withtraditional coveragemetrics.
.
.
experimental design and procedure.
we adopted a similar approach to zhou et al.
and davis et al.
in selecting open sourcejavascriptapplicationsfromgithub.theseprojects used promises and or async awaitconsiderably were accompanied by reasonable test suites and were compatible with graal.js .
they represented various sizes domains and architectures and the average statement coverage of the benchmark applications was .
we ran jscopeon the subjects by automatically exercising them through their tests.
we measured the results of the three asynchronouscoveragemetrics andcalculatedstatement function andbranchcoverageusingistanbul 5apopularjavascriptcoverage 1313esec fse december 3 9 san francisco ca usa mohammad ganji saba alimadadi and frank tip table correlation coefficients for asynchronous and traditionalcoverage criteria.
statement function branch settlement registration execution settlement .
.
.
.
.
registration .
.
.
.
.
execution .
.
.
.
.
tool.wethenexaminedthepossiblecorrelationsofourproposed asynchronous coveragecriteriawiththesetraditional criteria.
.
.
results anddiscussion.
the results are displayed in table .
the f irstfourcolumnsshow anapplication sname loc number of tests and number of promise objects observed in the analysis respectively.thenextthreecolumnsdepicttheresultsoftraditional coveragecriteria i.e.
statement function andbranchcoverage.
overall thebenchmarkshadrelativelyhightraditionalcoverage scores withanaverageof92 and85 statement function and branch coverage respectively.
however it can be seen that settlement reaction registration and reaction execution coverage scores were much lower with an average of and respectively.
this means that on average the test suite of a typical javascriptapplication u1d44eexercises92 ofthestatementsbutabout of the expected outcomes of its promises and async functions.
u1d44emaynot even register over25 of necessaryreactionsfor async operations.
even fewer reactions are actually exercised through tests.
next we examined the potential correlations between asynchronousandtraditionalcoverage.weusedthekendallrankcorrelationcoefficient whichdoesnotassumeanormaldistribution.the results depictedin table3 shownostrongcorrelationsbetween traditional and asynchronous coverage metrics.
this indicates that traditional coverage metrics are not necessarily equipped for identifying the sufficient execution of asynchronous scenarios through tests.
in other words covering more lines or functions does not imply covering more of the asynchronous behavior of an application.
overall whilethehightraditionalcoveragescoresraisecon f idence insufficienttestingofthecode theyarenotequippedwithidentifying shortcomings of the tests in asynchronous scenarios.
for instance while of the statements are exercised on average only of the expected reactionsofasynchronousoperations areinvoked.
.
asynchronouscoverage andtest effectiveness toaddress rq2 weused jscopeandistanbultoexaminebothtypes of coverage for code snippets related to previously resolved issues ongithub.
amainapplicationofcoveragecriteriaisidentifying code segments that may contain bugs due to insufficient coverage which can be helpful during debugging.
as such given a set of known bugs we investigated if traditional coverage criteria raise warnings about inadequate testing of faulty asynchronous code and if jscopecould have helpeddiscover thesebugs.
.
.
experimental design and procedure.
we searched the repositories of the projects in table 2for issues that involvedpromises and or async await were closed with the f ixes linked to the relevantcommits and3 hadcompletestatementcoverageinthetable asynchrony related javascript issues fromgithub.
commitappcategory settlement registrationexecution statement .
f56491a express http proxy unhandled exp.
.
d902776 cla assistant unhandled exp.
.
8ff7de7 streamroller unhandled exp.
.
8e94a60 eslint d.js unhandled exp.
.
6bcf8ca check f ire unhandled exp.
.
fff6640 postgres unhandled exp.
.
2fc9693 haraka unhandled exp.
.
e5615da ioredis unhandled exp.
.
146bb3b install unhandled exp.
.
0dfff52 json schema ref parserunhandled exp.
.
cbcdfc6 socketcluster server unhandled exp.
.
dfbafbf clamscan pendingop.
.
48a2ddf cla assistant brokenchain .
b0a86d4 avvio brokenchain .
68342f8 libnpmteam unnecessary async.
version before the f ix.
we found seven bugs in six of the repositories.
we expanded our search to real bugs from other projects on github that met our requirements.
we selected a total of bugs.
we then ran jscopeon two versions of each project one immediately before and one immediately after each bug f ix.
we usedjscope s output to investigate the inadequacies of the tests in exercising the asynchronous behavior in code segments related to eachbug.
.
.
resultsanddiscussion.
table4displaystheresults.columns show the commit pertaining to the bug f ix the application name andthebugcategory respectively.thenextthreecolumns displaytheasynccoveragenumbersbeforethe f ix.thelastcolumn showsstatementcoveragebefore the f ix reportedbyistanbul.js.
overall jscopereportedinsufficientcoverageandrelevantwarningsforallbugs addressingwhichcouldhavehelpeddetectand f ix thebugsbeforedeployment.statementcoverage however showed nosignofwarningorinsufficienttestingforanyofthebugsortheir relevant code segments.
next we discuss the main categories of studiedbugsanddescribehow jscope sreportsandwarningscould have bene f itedthe bug f indingprocessthroughtwoexamples.
unhandled exceptions.
developers often neglect to test exceptionalexecutionsofasynchronousoperations .whilecurrent coverage criteria can indicate insufficient testing of conditions and branches theyareunabletodetectinsufficienttestingofalternative scenariosforasynchronousoperations suchasmissingreactions for rejectedasynchronous operations ormissingerrorhandling.
example a eslint d.js is an application that daemonizes eslint forhigherperformanceandhas 30kweeklydownloads on the npm registry table row4 .
it caches a single linter object to reduce overhead.
line of the left code snippet in figure5 ashowshowtheasyncfunction getcache isinvokedtoasynchronouslyretrieveacachedeslintlinterobjectfromagivenpath.
the program using await waits until this promise ful f ills.
a bug wasreportedinthismethoddespitethefullcoverageofthiscode segmentbythetests asdepictedbythegreenmarkingsbytheline numbers.itstatedthattheapplicationcrasheswithanunhandled promiseexceptionifthepathgivento getcache cannotberesolved.
the proposed f ix added a try catch around the call to getcache toallowhandlingexceptionscausedbytherejectedpromiseand preventfurthercrashes figure5 a rightsnippet lines273 .
1314code coverage criteria for asynchronous programs esec fse december 3 9 san francisco ca usa figure jscoperesults highlightsandwarnings overlayed on code vs.istanbulresults markingsby the line numbers .
acorrespondingtestwasalsoaddedtothetestsuitethatsimulates the exception andexercises the catchblock lines275 .
thisbughadremainedundetectedinproductionforfourmonths.
however running jscopeonthefaultyversionofthecodereported insufficientcoverageintermsofamissingrejectreactionforthe promisereturnedby getcache shownasthe highlightedcodeon line and the missing error handler warning message box figure5 a .havinghadaccessto jscopeduringtestingcouldhave helpedreveal this bugbefore production.
ourresultsin table4showedmultipleinstancesofunhandled exceptions similarly missed by the applications tests.
row 3is an example where developers managed to achieve statement coverage while still failing to detect a missing reject reaction causingacrash.considerour f irstmotivatingexamplefrom section3.
.
ambiguousreports mentionthe sameissuetwoyearsbeforethe f ix.
the issue persisted to a point where it had damaged the users trust withausercallingclaassistantaphishingtool.
brokenpromisechains.
javascriptprogramswillnotwaitforthe completion of asynchronous operations unless explicitly speci f ied.
inotherwords theexecutionofoperationsthatdependonthecompletionofapromiseisreliantonproperlychainingthemthrough promisereactionsor awaitstatements.
developerscan mistakenly break the chain of asynchronousoperationsby not awaitingtheir completion .
this may alter the f low of execution leading to undesired outcomes.
moreover the outcome of the promise will not be used and potential exceptions will not be caught which can lead to a myriad of issues in programs.
our f irst motivating exampledisplayedacasewerethismistakeledtotheclaassistant application crashing caused by an unhandled exception thrown by an un awaitedpromise section .
.
example b row13oftable 4shows another issue in cla assistant.repositoriesthatuseclaassistantmayrequirecontributorstosignacontributorlicenseagreement cla throughcla assistant swebinterface.whenausersignsaclathroughclaassistant swebinterface handlewebhook is invoked partiallyshown infigure5 b .uponinvocationofthe asyncfunction updateforclanotrequired line146 apromiseisreturnedthatasynchronously communicatesthestatusupdateonthesignaturetogithubservers.
itthen sends acon f irmationto the user line153 .
and users had reported issues where the web interface shows an updatedstatusforapullrequest whereasongithub therepository isstillpendingclaassistant supdate.twootherprecedingissues vaguely report the same bugbut were unable to reproduce it.
jscopereported low async coverage for the promise on line beforethe f ix figure5 b .thewarningstatesthatthepromisehas notsettledandhasnoreactions suggestinga f ixthroughadding athenorawaitstatement.this matches the f ix providedby the developers for the original issue which added an awaitbefore the call toupdateforclanotrequired towaitforthefunction scompletion before sendingaresponse to user line146 .
pending operations.
if not explicitly settled asynchronous operationsremain pending causing nonterminationormemoryleaks.
suchproblemsoftenhappenasaresultofdeveloperstreatingasynchronous code similar to synchronous code such as incorrectly callingreturninside the promise executor function to denote its completion instead of calling resolveas is the case in table row12.
for these cases jscopereports missing ful f illment and low settlement coveragefor the pendingpromise.
unnecessary asynchrony.
developers may complicate code by usingpromiseswhereasynchronyisnotrequired.theymayalso nestpromises causingunanticipatedbrokenpromisechains.while generally less severe jscopewarns abouttheir missing rejections.
overall asynccoveragecriteriacaneffectivelyexposetestinadequacies related to asynchrony that are not detected by traditional coverage metrics.
as such jscopecan help identify parts of code that contain asynchrony related bugs in practice despite being covered by traditional coverage.
.
usefulness ofasynchronouscoverage to developers to address rq3 we conducted a controlled user experiment to investigate the effectiveness of jscopein helping programmers identifyanddebug un coveredjavascript code.
.
.
experimentaldesignandprocedure.
ourexperimenthada between subject design to avoid the carryover effect.
we divided ourparticipantsintotwo groups controlandexperimental groups.
theexperimental grouphadaccessto asimpli f iedand web based 1315esec fse december 3 9 san francisco ca usa mohammad ganji saba alimadadi and frank tip table tasks used intheuserstudy.
task description t1.a identifying sufficiently tested functions t1.b identifying less robust functions i.e.not sufficiently tested t2.a locating all promises created duringtesting t2.b identifying promises thatare not properlytested t3.a identifying theunderlying causes ofa failure t3.b findingthe f ixto thefailure version of jscoperesults.
both groups had access to the code as wellasstatementcoverageresultsfromistanbul loadedonourwebbaseduserinterfacewithastyle similar to jscopefor consistency.
variables.
ourindependent variable is the type of tool used referredtoas toolfromhereon whichisanominalvariablewith twolevels jscopeandistanbul.wehavetwocontinuous dependent variables thatrepresentthedevelopers performanceincompleting the tasks taskcompletion duration seconds andaccuracy .
participants.
wesentoutrecruitmentemailstograduatestudents mailinglists.fromthereplies weselectedtheoneswhomet ourknowledgerequirementsofjavascriptdevelopmentandtesting.
themajorityofourparticipantshadamedium levelexpertisein javascriptprogramming andfamiliaritywithtesting.
werecruited sixmaleandsixfemaleparticipants aged21 consistingof10 graduatestudentsandtwosoftwareengineers with1 5yearsofexperience in software development.
we assigned them randomly to experimental and control groups.
we balanced the expertise based onourparticipants responsestoapre questionnaire section6.
.
.
experimental object.
we used a simpli f ied version of the body.js f ilefromnodefetch 8alibraryimplementingbrowsers window.fetch innode.js.forthedebuggingtask wechosea f ixed bug from docusaurus a website building application.9the unhandledrejectreactionbug coveredbythetests ledtosilentfailureof the wholeapplication.
tasks.we designed three tasks that pertained to test adequacy andqualityassessment table5 .t1andt2weredesignedtoassess effectivenessoftoolinhelpingprogrammersidentifywell tested and insufficiently tested functions and promises.
t3 was designed toinvestigatetheusefulnessof toolinhelpingparticipantsidentify the underlying causes ofthe bug t3.a andpropose a f ix t3.b .
pre study.
all participants f illed a pre questionnaire form prior totheirsession indicatingtheirdemographicinformationandtheir experienceinprogramming javascriptdevelopment andtesting and self assessed pro f iciency levels.
we used this data to fairly balance the participants between groups.
all participants signed a consent formedprior to starting the study.
training.
the participants were given refresher tutorials on main concepts of asynchronous javascript coverage and istanbul to ensure consistency in the knowledge required for completing thetasks..theexperimentalgroupalsoreceivedatutorialonusing jscope.
bothgroupsweregivensometimetofamiliarizethemselves withthe toolsandthe setupofthe experiment.
taskcompletion.
next theparticipantsstartedperformingthe tasks .
the participants were allowed to interact with the codeandthetoolsandwritetheiranswersonagoogledocshared withtheexaminer.wemeasuredthe durationduringthesession providing each task to the participants individually which they returnedaftercompletingthetask.tomeasure accuracy weused pre de f inedrubricsto markthe responses later.
post study.
afterthesession theparticipantsrespondedtoa post questionnaire form with qualitative data on usefulness of the toolusedandits limitations.
.
.
results and discussion.
we ran the shapiro wilk normality testonthe data and sincethe distributions werenot normal we used mann whitney u tests to analyze the results.
the results showed a statistically signi f icant difference on average on thetotalaccuracyofresponsesfortheexperimentalgroupusing jscope mean stddev comparedtothecontrolgroup mean stddev .
theresultsalsoshowedthecontrolgroupspentslightlylesstime intotal mean stddev comparedtotheexperimental group mean stddev althoughthedifferencewasnot statistically signi f icant.
theexperimentalgroupspent an average of .
and minutes for completing t1 t2 and t3 respectively.
thecontrolgroupspent6 12minutes for performingthesametasks onaverage.
theresultsofindividual tasksshowedthatalthoughtheexperimentalgroupspentmoretime for completing t1 compared to the control group they performed all other tasks faster on average .
it was expected for the experimentalgrouptospendmoretimeont1duetotheadditional learning curve incurred by their unfamiliarity with jscope and theystillachievedanaverageof33 higheraccuracyfort1.forthe remaining tasks the experimental group performed consistently fasterthanthe controlgroup whileachievinghigher accuracy.
more accurate assessment of test effectiveness.
the tasks involvedperformingvariousactivitiesincludinggeneralfunction coveragetomorespeci f icpromisecoverage forallofwhich jscope showedtoimprovetheaccuracyoftheparticipants.wehadhypothesizedthat jscopewouldbemostusefulfortasksdirectlyinvolving asynchronous interactions.
for instance t2 involved examining promisesandasync awaitstatements whereweexpected jscope tobehelpful.using jscopehelpedtheexperimentalgroupperform signi f icantly better for t2.
they completed this tasks faster p .
and30 more accurately p .
onaverage.
debugging.
theeffectivenessoftestsisdirectlydependentonits bug f indingcapability.coveragemetricsdonotdirectlyattributeto identifyingand f ixingbugs.however theycanfacilitatetheprocess byguidingprogrammerstowardsthelesstestedportionsofthecode thatmaycontainbugs.using jscopehelpedtheexperimentalgroup indebuggingtoachievemoreaccurateanswerswhilespendingless timelocatingtheunderlyingcausesofafailure t3.a and f indinga f ix t3.b .
the results were statistically signi f icant for the accuracy oftheproposed f ix t3.b whereexperimentalgroupachievedan averageof37 higher accuracy p .
.
participants feedback.
overall the experimental group found jscopeuseful.inparticular theylikedtheoverviewofthecoverage report interactionswiththeoverlayedvisualcues andthewarning messagesthat guidedthemtowardsmissingfunctionalityortests.
overall participantsusing jscopeperformed28 moreaccurately in testingand debuggingasynchronouscode.
1316code coverage criteria for asynchronous programs esec fse december 3 9 san francisco ca usa .
performance wemeasuredtheperformanceof jscopeintermsofitsoverhead of instrumentation and test suite execution time by averaging f ive executionsofeachtestsuite withandwithout jscope.ouranalysis for the applicationsin table2indicates amedian of31 secondsof instrumentation 97seconds .theslowdownfactorforexecutionoftheinstrumentedcodegenerallyranges2x 100x median .5x .
the slowdown is similar to other instrumentation based dynamicanalysesfor javascript .
.
threatsto validity therearethreatspertainingtotherepresentativenessofourparticipants benchmark projects or issues.
we addressed these by randomly selecting participants who met the minimum experience requirements and projects of different sizes from different domains that met the prerequisites for using jscope.
to mitigate the examiner sbiasinouruserstudy wedelegatedthetimekeepingto the participants allowing them to decide the start and end time of eachtaskbyhandingthemthetasksseparatelyandaskingthem to return it afterwards.
we de f ined detailed rubrics for grading the accuracyoftheresultspriortothestudytoaddressasimilarbiasin measuringparticipants accuracy.wetriedtoalleviatetheimpactof expertiselevelinourstudybybalancingtheparticipants expertise levels based on their responses to our pre questionnaire.
we made jscopeandourexperimentaldataavailabletoallowreproducibility.
related work while being the most prominent test quality assessment technique code coverage criteria have always been under scrutiny abouttheireffectiveness .thegenericnatureoftraditionalcoveragecriteriahasledtotheemergenceofvariousdomainspeci f ic coverage criteria .
several coverage metricshavebeenintroducedusingdata f lowtotargetconcurrency in actor based concurrent and distributed programs .
researchers have proposed novel criteria for dynamic web applications orlooselytypednatureofjavascript or dom elements .
none of these techniques however address the asynchronous executionandits respective challenges.
event dependentandasynchronouscallbacksformamajorityof untested code in javascript .
prior work has used static analysisto modelevent drivenjavascript .otherworkhasfocusedonconstructingpromisegraphsthatexpresstherelationships between promises and relevant code and detecting promise anti patternsbasedonpromisegraphs .toidentifyperformancerelated anti patterns involving promises .
arteca et al.
presentarefactoringforenablingadditionalconcurrencybysplittingandmoving awaitexpressions andgokhaleetal.
presenta refactoringformigratingapplicationsfromtheuseofsynchronous apis to equivalent asynchronous apis.
moreover dynamic analysishas been popularly used in javascript to address the imprecision of static analysis in analyzing javascript s inherent dynamism .
much research in this area targets understanding debugging and testing techniques for programs in general andmore recently for asynchronous javascript in particular .
a long line of research projects has focused on the detection andremediationofeventraces concurrencybugs andschedulefuzzersforevent drivenprograms .
theextensive research on bug detection and comprehension of asynchrony con f irms our argument for the necessity of test adequacy criteria that takeintoaccounttheasynchronyinjavascriptandotherlanguages.
visualization has been effectively used for comprehension and modelingevent drivenandasynchronousprograms .
similartoseifertetal.
weleveragededitorintegrationtofacilitatethecomprehensionofasynchronouscoveragethroughan interactive interface.
codecoverageiscrucialinevaluatingtheeffectivenessof test generation techniquessuchasfeedback directedrandomtesting dynamic symbolic execution and searchbasedandevolutionarytechniques .nessie isafeedbackdirectedtestgenerationtoolforjavascriptthattargetsevent driven asynchrony.
event driven asynchrony is rapidly being supplanted bypromisesand async awaitbecausethesefeaturesleadtoamore readable and less error prone code.
however nessie does not providespecialsupport for promises and async await.
mutation testing is also used as an alternative approach for measuringtestquality .despitetheireffectiveness mutation testing for javascript is typically very costly and has yet to gain the popularity ofcode coverage .
concludingremarks inthispaper weproposedasetofcoveragecriteriaforassessingthe adequacy of tests with respect to asynchronous program behavior.
wedesignedaninteractivevisualizationandimplementedatoolto allow programmersto viewasync coverage resultsin a typicaldevelopment environment.
the results of our evaluation showed that asynccoveragemetricsarecomplementarytotraditionalmetrics andcanhelpprogrammersdetectinsufficienciesoftestsandrelated bugsinasynchronouscodewheretraditionalmetricscannot.our user experiment also demonstrated that our tool helps improve developers performanceintasksrelatedtoassessingtestquality anddebuggingofasynchronous code.
the coverage criteria presented in this paper are designed for javascript.aswaspointedoutin section2 similarfeatureshave been added to various programming languages and adaptingthecoveragecriteriatotheselanguagesisaninteresting futuredirection.anotheravenueforfutureworkisthedevelopment of test generation techniques that aim to improve asynchronous coverage.
for example one could imagine extending nessie to register reactions on promises returned by function calls in previously generatedtests.
data availability jscopeandour experimental data are publiclyavailable .