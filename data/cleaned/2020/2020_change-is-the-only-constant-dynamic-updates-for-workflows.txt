change is the only constant dynamic updates for workflows daniel sokolowski daniel.sokolowski unisg.ch university of st. gallen switzerlandpascal weisenburger pascal.weisenburger unisg.ch university of st. gallen switzerlandguido salvaneschi guido.salvaneschi unisg.ch university of st. gallen switzerland abstract softwaresystemsmustbeupdatedregularlytoaddresschanging requirementsandurgentissueslikesecurity relatedbugs.traditionally updatesareperformedbyshuttingdownthesystemtoreplace certain components.
in modern software organizations updatesare increasingly frequent up to multiple times per day hence shutting down the entire system is unacceptable.
safedynamic softwareupdating dsu enablescomponentupdateswhilethesystem is running by determining whenthe update can occur without causingerrors.safedsuiscrucial especiallyforlong runningor frequently executed asynchronous transactions workflows e.g.
user interactive sessions or order fulfillment processes.
unfortu nately previous research is limited to synchronous transaction models and does not address this case.
in this work we propose a unified model for safe dsu in workflows.wediscusshowstate of the artdsusolutionsfitintothis model andshow that theyincur significant overhead.toimprove theperformance weintroduce essentialsafety anovelsafedsu approach that leverages the notion of non essential changes i.e.
semantics preserving updates.
in realistic bpmn workflows essential safety reduces the delay of workflow completions on average by47 .
comparedtothestateoftheart.weshowthat thedistinctionofessentialandnon essentialchangesplaysacrucial role in this reduction and that as suggested in the literature non essential changes are frequent at least and often more than of systems updates in eight monorepos we analyze.
ccs concepts software and its engineering software evolution applied computing business process modeling.
keywords software evolution dynamic software updating workflows acm reference format daniel sokolowski pascal weisenburger and guido salvaneschi.
.
change is the only constant dynamic updates for workflows.
in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa 13pages.https permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
introduction updating long running software systems is essential to address changing requirements and mitigate security vulnerabilities in a timelymanner.updatesbecomemorefrequentinmodernsoftware development following agile methods and devops principles requiring automation of updates and low impact on the running system to prevent frequent interruptions.
traditionally software updates are performed by shutting down software systems and restarting them after replacing some com ponents with new versions.
while this approach is simple it isdisruptive and infeasible for larger systems where a full restart maytakealongtime.asaresult researchershaveinvestigatedless disruptive dynamic software updating dsu i.e.
updates that occurwhilethesystemisrunning.thereby acomponentupdate in the middle of a transaction must not result in inconsistencies.
for example if a client requires a security token to access a server and the server is updated to a new token scheme in a na ve way verifying a previously generated token could fail .
safe dsu determines whenanupdatecanbeperformedwithoutincurringsemantic inconsistencies the so called update condition.
it leverages various information such as the system topology and the progress of transactions.
acommonsolutiontoimplementlong running frequent and expensivetransactionsare workflows sometimesreferredtoas longrunning transactions .
workflows are extremely common in modern software applications to express a sequence of tasksand the data flow between them decoupling process flows from applicationlogicandenablingautomation.workflowshavebeen used for a long time and recently gained popularity to orchestrate weakly coupled components.
for instance workflow engines have been adopted at modern software companies e.g.
conductor at netflix andaresupportedbymajorcloudproviders e.g.
aws stepfunction and google cloud workflows .
safe dsuis crucial forworkflows ignoring update safetyand retryingthetransactionsthatwerebrokenbyanupdatemaybeac ceptableforapplicationswithinexpensive short livedtransactions but the cost of repeating broken transactions increases with the transactions amount duration andresourceconsumption.thus es peciallyforlong runningorfrequentlyexecutedworkflows delays or retries after failure on component updates potentially require large amounts of additional resources and introduce severe delays.
thisissueisevenmorerelevantinci cdpipelines wherechanges are small and frequently deployed .
unfortunately existingsafedsusolutionshavenotbeenstudied inthecontextofreal worldworkflows.crucially previousresearch only considers synchronous transactions and cannot be directly transferredtoworkflows whichareasynchronous.toclosethisgap we investigate a new formal model for safe dsu suitable for workflows.
we show how our new model can capture state of the art ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa daniel sokolowski pascal weisenburger and guido salvaneschi dsu approaches and analytically compare them within the model setting the conceptual ground for the performance differences that we later inspect empirically.
another challenge in using safe dsu for workflows is that existing approaches introduce significant performance overhead.
they either do not reach their update condition in a timely manner version consistency vc or make strong assumptions sacrificing safety if the assumptions are not satisfied tranquility tq .
to reduce the performance overhead compared to thestateoftheart andretainsafety weproposethesafedsuapproachessential safety.
its updatecondition essential freeness is based on the observation that a significant amount of updates are non essential changes i.e.
they never interfere with running transactionsbecausetheydonotintroducesemanticchanges.thanksto identifying non essential changes essential safety reduces delays andinterruptionsduetoupdatesinworkflow basedapplications and retains strong guarantees on correct system operation.
thisworkpavesthewaytoapplysafedsutomodernworkflow architectures e.g.
in cloud applications .
in addition the identification of non essential changes updates without semantic changes canberefinedusinginsightsfromtheapplicationandthe developers.thisinsightopensanopportunityforfutureresearch to provide more precise characterizations of non essential changes reducingthenumberofexpensiveupdatesandfurtherimproving dsu performance.
allourevaluationdataandthesoftwaredevelopedforthispaperarepubliclyavailable .insummary thispapermakesthe following contributions we propose a new formal model for dsu supporting asynchronousworkflows.weshowthatstate of the artdsuapproaches aswellasourapproach fitintosuchamodel enabling a direct comparison.
we propose essential safety as a novel approach for safe dsu whichleveragesthe identificationofwhetheranupdate introduces a semantic change i.e.
is essential.
we analytically compare essential safety to previous dsu approaches show that version consistency is a conservativeover approximationof tranquility andessentialsafety and highlight the different information taken into account explaining the performance difference among such solutions.
we empirically confirm by simulating realistic collaborative bpmn workflows and analyzing eight monorepos thatessential safety provides the best performance among safe dsu approaches that identifying non essential changes iseffective to improve safe dsu s performance and that in practice atleast60 andoftenmorethan90 oftheupdates are non essential changes.
thepaperisorganizedasfollows.section 2outlinestheissue of safe dsu for workflows.
section 3presents related work.
section4describes our model for safe dsu in workflows and introducesourapproach essentialsafety.section 5presentsessential safety spracticalrealization.section 6analyticallycompares essentialsafety withpreviousdsusolutions.section 7empirically evaluates our contribution and section 8concludes.
rrn krwho rrn ljkw rrn fdu dqfho krwho dqfho fdu dqfho ljkw6xffhvv 6xffhvv 6xffhvv hv qr qr qr7uls uhtxhvwhg7uls errnhg hv hv 7uls errnlqj idlohg figure bpmn workflow of the trip booking saga.
the dynamic update problem inthissection weintroduceaworkflowasarunningexampleto explaintheproblemofsafedsu.workflowsareusedextensively in software systems to express the execution of interrelated tasks.
.
the trip booking saga the running example is the trip booking case study shown as bpmn workflow in figure .
a hotel a car and a flight are booked sequentially.
each of these steps may fail triggering compensatingactionsforthebookingsperformeduptothecurrent execution point a design pattern referred to as saga .
eachtaskintheworkflowisimplementedasaserverlessfunction.
some of the functions are coupled through a shared database on which they operate constituting components.
in our example the carbooking andcancelfunctions constitutethe carrental component and the remaining four functions are the holidaycomponent.
these components are the smallest unit of updates e.g.
whenthecarrentalcomponentisupdated theserverlessfunctions for both book car and cancel car are replaced by a new version.
figure2showsthetripbookingcasestudyasaumlsequence diagram.
we added the labels atoeand btodto reference points in time during the execution.
if there is no error only atoeoccur and not btod because they are on the paths that only occur on the failure of a booking task executing the compensation tasks.
.
the need for safe dynamic updates updating a component in a workflow may break the correct executionintwocases.thefirstcaseistheupdateofacomponentwhile it is currently executing a task i.e.
it is active.
for example if a workflowinstancerunsthe bookhotel task updatingtheholiday component can cause incorrect behavior.
in line with the literature on dynamic updates we consider updating an active component i.e.
onethatexecutesatask alwaysunsafe thisproblemisstudied inadifferentresearchline andrequires hot swapping code as well as migrating the state representation across versions.
thesecondcaseiswhenacomponentperformstwotaskswithin the same transaction and an update introduces a semantic change inbetween.forexample inthetripbookingsaga after bookhotel completes after binfigure if bookcar isnotsuccessfuland the holiday component is updated with a new version that usesa different format for hotel booking ids cancel hotel does notbehave correctly either it does not find the correct booking to cancel or even worse it finds the wrong one.
thus the workflow instancefailstorevokethehotelbooking.toavoidsucherrors safe dsuapproachesspecify updateconditions.theydetermine when anupdatecanbeperformedsuchthatitdoesnotcausesemantic mismatches.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
change is the only constant dynamic updates for workflows icse may pittsburgh pa usa rolgd du 5hqwdo fdqfho fdufdqfho ljkw vxffhvv idloxuh idloxuh idloxuh efg vxffhvv errn fdu errn krwho fdqfho krwhofdqfho krwho fdqfho krwhofdqfho fdu vxffhvv dow errn ljkw doww dow figure sequence diagram of the trip booking saga.
.
the role of non essential changes toreachtheupdateconditionforasafeupdateandtoupholdituntil theupdatecompletes safedsuapproachesrequiremonitoringand may block tasks.
for instance to update the car rental component adsuapproachmightblockall calls tothecarrentalcomponent until the update completes.
once all running tasks on car rental terminate a safe update condition is met and upheld until theupdate is completed.
both reaching and upholding a safe updatecondition lead to significant overhead and delay.
the overheadgrows with the amount duration and resource consumption of the transactions which results in considerable overhead for highly frequent expensivetransactionsthatcanbefoundinworkflows.
dsu approaches should block tasks as little and short as possible.
forexistingdsuapproaches theoverheadishigh in long running frequently executing workflows cf.
section prohibitingtheiruseforthesafecontinuousdeploymentofsuch applications.
however in practice a substantial fraction of the changesrunningthroughacontinuousdeploymentpipelinetend tobesmallanddonotintroducesemanticchanges i.e.
non essential changes a reality ignored by previous work on dsu.
thus we can applyalessdisruptiveupdateconditiontomostupdates.itrequires less task blocking to be reached and upheld and greatly reduces unnecessary overhead.
essential safety es our novel safe dsu approach for workflows leveragesthedistinctionbetweenessentialandnon essential changes.
essential safety reduces dsu disruption to a minimum whileprovidingthesamesafetyasthestateoftheart enablingsafe dsu in real world long running frequently executed workflows.
intable1 wecompare forexistingdsuapproaches and foressential safety whenupdating the components in the trip booking case study cf.
section .
is safe.
checkmarks correspond to safe update time intervals.
the highlighted cells indicate intervalswherethecomponentisactive theseintervalsareunsafe under all update conditions.
if an update is an essential change essential safety provides the same safe update intervals as version consistency vc which is generally safe in contrast to tranquility tq .fornon essentialchanges theintervalsindicatedby check are additional safe intervals and thus essential safety provides the highest number of safe update intervals.table1 updateconditionsoverthetime tinthetripbooking saga for quiescence q tranquility tq version consistency vc andessential safety es .
holiday car rental tqt qv ce s qt qv ce s a check check check check check check b check check check c check check d check d check c check check b check check check check e check check check check check check check check related work closesttoourworkispreviousresearchonopaqueboxsafedsu which we compare with in detail in section .
in contrast transparent box approaches leverage formal models of the programs to identify points in time when it is safe to update.
whiletransparentboxmethodsallowmorefine grainedanalyses theyrelyonstrongassumptionsontheimplementationtechnology making them hard to apply to general distributed systems supporting components implemented using heterogeneous paradigms languages and technologies.
the survey of seifzadeh et al .
discussesseveralplatformswithdsu.wenowdiscussrelatedresearch on updating software in running processes software reconfiguration workflowevolution and continuousdelivery.
finally we provide an insight into dsu in practice.
dynamiccodereplacement.
inthiswork wefocusonsafedynamicupdatesofcomponentsthatare notcurrentlyexecutingcode.
complementary to our work there are approaches for updating runningcomponents.updatingthecodeofarunningprogramwas investigated already in the 1970s .
later erlang has been oneofthefirstprogramminglanguagestoenable hotswapping i.e.
modules can be replaced at run time the new version is loaded when the next invocation occurs and programmers can specify state transfer between modules.
a similar solution for dynamiccode replacement is also available in the ada programming language .
morerecently dynamic codereplacement on thejava virtualmachinehasbeensupportedinthejvolve andinthe dce vms as a modification to the java hotspot vm.
these approaches focus on the technical realization of code replacement while the system is running and assume that developers correctly handle transferring the state of components across updates.
another line of work focuses on ensuring that state transformations are correct e.g.
using type systems .
gu et al .
replay the sequence of invocations performed on the old object on the new one to ensure that it reaches the same state.
software reconfiguration.
dynamic software reconfiguration is aboutchangingtheconfigurationofasoftwareproductatruntime whilethesystemisoperational.researchfocusesonreconfiguration models ensuring the preservation of consistency propertiesand minimizing system disruption .
adapta is a reflectivemiddlewareforself adaptive component basedapplications.it aimstodecoupletheapplicationlogicfromthecodethathandles authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa daniel sokolowski pascal weisenburger and guido salvaneschi the adaptation and it requires run time monitoring and triggering mechanisms.
software reconfiguration has been applied to distributed execution where remote system nodes interpret reconfiguration scripts .
software self adaptivity is a research line on switching the behavior of applications at run time for example usingmetaprogrammingorreconfigurationofcomponent based systems .
updatingworkflows.
researchershaveexaminedhowexisting workflowscanbemodeledtosupportchangeswhiletheyareexecuted.casatietal .
addresstheproblembydefiningasetof transformation rules and dividing the state space into parts that are terminated or handled by different process definitions.
geiger et al.
present a detailed review of the current state and evolution of bpmn .
support and implementation finding a lack of standard compliance in current implementations.
updatesincontinuousdelivery.
arecentoverviewoftheimpact ofcontinuousdelivery cd bylwakatareetal .
investigatescd implementations in five different development contexts.
laukka nen et al .
provide an overview of adoption problems of cd and show that most research work focuses on issues that devel opers face but developers usually consider release and software updateproblemstobeexternalfactors.updatingcomponentsincdposesaprobleminreal worldsettingsaccordingtosemi structured interviews conducted by claps et al .
at atlassian.
at least out of interviews highlight that seamless upgrades are hard to implement in large systems and potentially consume signifi cant amounts of resources.
gallaba et al .
infer dependencies between components using build execution tracing to accelerate ci cdpipelines informationthatcouldbeusedtoidentifynonessential changes.
infrastructure as code iac has been adopted to increase automation in modern development pipelines .
traditionally iac solutions in cd are executed as one off tasks and treatwhentoupdateasexternaldecision.however therecentintroduction of long running reactive deployment scripts blurs the line between application and infrastructure code enabling the required monitoring and logic for safe dsu.
dsuinpractice.
today safedsureliesoncomplexworkarounds avoiding the need for safe update intervals.
cloud vendors and deploymentplatforms e.g.
kubernetes providevariationsof blue green and canary deployment strategies.
parallel change is a pattern for safe interface updates that replaces unsafe changes with a sequence of safe ones.
these solutions provide safedsuforsoftwarewherethecomponentsfortheapplicationlogic are stateless and a transactional database holds the state.
however this hypothesis does not always apply e.g.
in the case of workflowsinvolvingcomponentsthatbelongtovariousauthorities.
in such a case using a central database is infeasible a codified principleinmicroservicearchitectures .inmanyscenarios e.g.
web applications for social networks it is accepted that updates maybreakmulti requesttransactions retryischeap butithampers user experience.
in other scenarios retry is not acceptable becauseitrequirestoomuchtimeorresources whereforesafedsu is needed to minimize the updates impact.
efficient safe dynamic updates of workflow components in this section we present a formal model for workflow execution.
we propose essential safety as a safe and efficient updating approach.
we then show how essential safety s update condition essential freeness can be reached and upheld during an update.
.
workflow execution model variousworkflowmodelinglanguagesexist includingstandards like bpmn and bpel as well as vendor specific dsls liketheamazonstateslanguage forawsstepfunctions .
thoughthesemodelinglanguagesdifferinfeaturesandexpressivity they all organize consecutively executed tasks in a graph structure.
we formally model their shared core concepts.
weconsiderthesystemlandscape l r w t c i consisting of workflow engines r workflows w and tasks t which are implementedbycomponents c relatedby i t c.w emodel a workflow w t p b e wwith a directed graph of tasks t tthatareconnectedtothetaskswhichcanbeexecutednext thesucceeding tasks by arcs p t t. a workflow s initial tasks areb tand the end tasks e t. all non end tasks must have at least one succeeding task.
thus a task t tis either in eor there exists at least one edge t t prime p. workflows are executed as workflow instances i r w a v f s i in the workflow enginer rwherea tistheactivetasks initializedas a b. the workflow engine updates aduring the execution of i. the workflow instanceterminates once notask is activeanymore i.e.
a .sistheworkflowinstance sstate.alltasks toficanread fromitatthebeginningoftheirexecutionandwritetoitaftertheirexecution.
v tarethevisitedtasks i.e.
thesetisinitiallyempty and all tasks that are removed from aduring the execution are addedtov.f tarethepotentialfuturetasks i.e.
alltasksthat are reachable in the directed graph t p from a task in a. note thatfis a conservative over approximation of the future tasks i.e.
notalltasksin fhavetobeexecuted.forinstance considerbpmn exclusivegateways asincludedthreetimesinfigure whichhave multiple outgoing paths but only exactly one will be executed.
all tasksonapathafterabpmnexclusivegatewayareinitiallyin f andalltasksonthepathsnottakenareremovedfrom fwithout being executed once the gateway is processed.
basedonthedefinitionofactivetasks a wedefineacomponent c cis active if it executes any active task definition .
active component .
a component c cis called activeif it currently executes a task in any workflow instance i r w a v f s i t a i t c. .2essential safety wedefineasafeandefficientupdateconditionforlong running frequentlyexecutedworkflows.aworkflowinstancealwaysexecutescorrectlyifeverycomponentisonlyupdated afterithas executed its last task before it executes its first task or if itdoes notexecute anytask inthe workflowinstance.
incontrast to previous work our approach also allows a component to be updated if it already executed a task andmay execute a task in the future if the update does not introduce a semantic change.
we call authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
change is the only constant dynamic updates for workflows icse may pittsburgh pa usa such updates non essential changes in contrast to essential changes which introduce a semantic modification definition .
essential change .
an update of a component c cfrom version vtov primeis an essential change for workflow instancei r w a v f s i ifthepossibleexecutionofany futuretask t f i t conv primeisnotguaranteedtoproducethe same resulting state sand side effects as executing tonv.
everyotherchange giventhedefinitionabove isanon essential change.
identifying whether a change is non essential is not decidableingeneralasitboilsdowntotheprogramequivalenceproblem.
since misclassifying essential changes as non essential breaks safety weconservativelyunder approximatenon essentialchanges withacatalogofknownnon essentialchangesthatcanbefound throughefficientanalyses.kawrykowandrobillard describe non essential changes as cosmetic behavior preserving and unlikely to provide further insight into component relationships.
this includes but is not limited to trivial type updates local variable extractions rename induced modifications trivial keywordmodifications localvariablerenames andwhitespaceand documentation relatedupdates.definition .2leavesopenadding more sophisticated analyses to find non essential changes includ ing application specific ones.
identifying non essential changes isimportant in practice but orthogonal to our contribution.
updatingacomponentwithnon essentialchangesisalwayssafe whilethecomponentisnotactive.weintroduce essentialsafety es only updating components when they are essentially free.
definition4.
essentialfreeness .
acomponent c cisessentially free i fi t is not active and a. willnotbeactiveinaworkflowinstanceinwhichitalready executed a task nexistsi w a v f s i t v t prime f i t c i t prime c o r b.its update is a non essential change for all workflow instancesi w a v f s i t v i t cin which it already processed a task.
consideringasingleworkflowinstanceofthetripbookingsaga updates with non essential changes can always be performed without violating the workflow s correctness if the respective com ponent is not currently executing a task.
for instance using the intervals marked in figure the car rental component can always be updated except within cand c. if the update is an essential change the update must not occur between a component s first and last task execution in the workflow instance.for example an essentialchangeofthecarrentalcomponentmaynotoccurwithin b d and cbecauseitmightbethecasethat cancelcar isexecuted inthefutureafterthat bookcar hasbeenalreadyexecutedonthe current version of the component.
.
reaching essential freeness strategiestoreachsafedsuupdateconditionstrade offbetween updatetimeliness andinterruption.timelinessisthelengthofthe intervalbetweenrequestingtheupdateandthebeginningofthe componentexchange i.e.
thepointintimewhenthecomponent stops executing tasks.
interruption is how long a workflow in stance s completion is delayed due to the update.
the followingreaching strategies from the literature can be used to reachessential freeness.
waiting w .
the update waits for essential freeness.
the interruptionislimitedbecauseonlyworkflowinstancesthatstartedaftertheupdatebeginsaredelayedandtheupdate sdurationboundsthe interruption.
yet the update is not guaranteed to start in bounded time i.e.
timeliness is unpredictable.
thus this approach is not suitable where essential freeness rarely occurs by chance.
blockingtasks bt .
thestartingoftaskson thecomponentto update is delayed until after the update.
this strategy ensures that essential freeness is reached in bounded time but it may cause more interruption than waiting.
blockinginstances bi .
thestrategyissimilarto blockingtasks but instead of delaying tasks the start of new workflow instances thatneedthecomponentisdelayeduntilaftertheupdate.while thisstrategyalsoguaranteestheupdateisreached itmighttake longer.theinterruptionisexpectedtobesimilarto blockingtasks but is reduced if multiple updates occur in parallel.
concurrentversions cv .
fornon essentialchanges allnewtask executions are served by the new version running in parallel tothe old version which completes the already running tasks.
for essentialchanges theoldversionalso executesnewtasks belongingtoworkflowinstancesthatalreadyexecutedatleastonetask on it.
thus the old version remains available until no workflow instance needs it anymore.
this strategy provides good timeliness andnointerruption butitrequiresrunningtwoparallelversions of a component significantly increasing complexity especially for stateful components.
except for concurrent versions all reaching strategies require essentialfreeness toholduntiltheupdateiscompleted.thiscan be achieved by applying blocking tasks to a component during its update delayingthestartofnewtasksuntiltheupdateiscompleted.
realizing safe dynamic updates determining and reaching the update condition is trivial with a singlecentralizedworkflowengine.suchacentralentity knowsthestateofallworkflowinstances i and candelaytheexecution of tasks and whole workflow instances.
however the system landscapelmay comprise multiple workflow engines r each hosting a subset of workflow instances i. hence no centralized view exists on all workflow instances.
modern scalable workflow engines e.g.
zeebe areby default decentralized over multipleseparate workflow engines to improve scalability and fault tolerance.
toensuretheirsafeupdate allworkflowenginesinvokingtasks on asharedcomponent have to coordinate.
hence reaching essential freeness for a component requires considering all workflow instances ithatusethecomponent.weproposeadissemination algorithm that the workflow engines use to notify componentsof their workflow instances status.
the algorithm ensures that components are aware of their role in all workflow instances using them.
each component can then locally decide whether it reached the update condition and can be safely updated.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa daniel sokolowski pascal weisenburger and guido salvaneschi .
dissemination algorithm algorithm 1shows the dissemination algorithm that workflow enginesexecute foreachworkflowinstance.thefourcallbackprocedures in algorithm 1are called reactively based on the events in the workflow execution e.g.
before a task is started the procedure in line1.5is called.
using the procedures the workflow engine announces to components that they might be used marks componentsthatwereused and lockscomponents notexclusively whiletheyareused.everycomponentstoresitsstatusinthe workflowinstances i.e.
everycomponentmaintainsforeachworkflowinstancetheinformationwhetheritreceivedanannouncement or a marking which was not revoked yet and a lock counter.
beforeworkflow afterworkflow beforeeachtask and aftereachtask are executed on the workflow engine before after aworkflowinstanceisexecutedandbefore aftereachtaskisrun.
theannounce revokeannouncement mark revokemarking lock andunlockproceduresarecalledremotelyonthecomponent passed as their first argument.
remote calls are asynchronous unless the execution blocks to get the return value using await.
componentscandelaytheirresponseatthe awaitsynchronization points to interrupt the workflow instance s execution until they can accept the announcement marking or lock.
the beforeworkflow procedure line .
announces to componentsc line1.
from the set of potential future tasks line .
of the workflow instance ithatcmight participate in i. announcements are revoked after completing tasks lines .11to1.
if the component will not be used again .
beforetheworkflowinstanceinvokesataskonacomponentfor the first time the engine marks the component lines .6to1.
.
markings remain for the rest of the workflow instance s execution and are revoked after its completion line .
.
every time a workflow instance invokes a task the engine locks the component line .
and unlocks it after the task is completed line1.
.aworkflowinstancemightlockthesamecomponent multiple times beforeunlocking due to paralleltask execution.
the componentsinternallyincreaseacounterwitheverylockingand decrease it with every unlocking.
if the counter is positive the workflow instance runs tasks on the component.
thepresentation ofalgorithm 1is simplifiedfor clarity.our implementation includes some optimizations e.g.
it sends announcements line .
inparallel andthemessagesto i task inlines1.
to1.9are packed into a single multipurpose message.
.
handling essential freeness algorithm 1disseminates the necessary information to the components to determine reach and uphold essential freeness.
when performingan updatethatintroducesessential changes acomponentisessentiallyfreeifitholdsfornoworkflowinstanceanannouncement anda marking i.e.
no workflow instance that already used the component will use it again.
for non essential changes a componentisessentiallyfreeifitisnotlocked i.e.
fornoworkflow instance the lock counter is greater than zero.
usingthe blockinginstances strategy acomponentdelaysthe confirmation of announcements until the update has been completed blocking all new workflow instances that will call the component in beforeworkflow and delaying their start.
blockingalgorithm1 modulardisseminationalgorithmonworkflowengine rfor workflow instance r w a v f s with unique identifier i. announcements markings locks .
announcements markings procedure beforeworkflow announcements c c t f i t c for allc announcements do await announce c i procedure beforeeachtask task ifi task markings then awaitmark i task i markings markings i task awaitlock i task i procedure aftereachtask task previousannouncements announcements announcements c c t f i t c for allc previousannouncements announcements do revokeannouncement c i unlock i task i procedure afterworkflow for allc markings dorevokemarking c i tasksuses a similar approach with locks for non essential changes andmarkingsforessentialchanges.locksblockallworkflowinstances markings only the ones that did not use the componentyet.blocking tasks does not generally block all task invocations by delaying locks because this could lead to a deadlock in case ofessentialchanges thenot blockedworkflowinstancesalready usedthecomponentandmayprevent essentialfreeness which would cause a deadlock or do not use it anymore.
for this reason blockingtasks canonlybeactivatedatonecomponentatatime to ensure deadlock freeness.
for both strategies above once reached the update condition must be uphelduntil the update completes.
foressential changes delayingtheconfirmationofmarkingsupholdstheupdatecondition.
for non essential changes locks are delayed.
waitingandconcurrentversions donotrequireanyaspectof algorithm 1fortheirupdateconditionbecausetheydonotinfluence the execution of workflow instances.
workflow updates in context in this section we show how essential safety relates to existing solutions for safe dynamic software updating.
.
from transactions to workflows previousworkondsu focusedonsynchronousdistributedtransactionsincomponent basedsystems.theyassume thatexternalclientstriggerso calledroottransactions which in turn can run other sub transactions on the same or other components.
the execution blocks until a sub transaction completes with areturnvalue.infigure 3a component arunsasub transaction on b which runs a sub transaction on c. afterward creturns a value to b bone to a and new sub transactions are run on b and c.figure3bshowsthesameinteractionpatternbutsynchronous transactions are nested differently instead of ending the first transaction on b bruns a sub transaction on a. authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
change is the only constant dynamic updates for workflows icse may pittsburgh pa usa a synchronous transaction.
b alternative synchronous transaction.
c asynchronous workflow.
figure modeling a synchronous transaction as workflow.
in this work we model the system as asynchronous workflows.
tasksarestartedbasedontheirorderasdefinedintheworkflow after the previous task s are completed.
the tasks are coordinated by the workflow engine which acts as an event based middleware.
thus upon completion tasks send their results as an update of the state sto the workflow engine which then starts the succeeding task s with s. modern cloud based systems also beyond workflows adopttheasynchronousmodel.typically suchsystems use asynchronous decoupled communication patterns e.g.
eventbased microservice choreographies or serverless computing .
ourasynchronousworkflowmodelcanemulatethesynchronous model.forinstance thetransactioninfigure 3acanbemodeledas infigure 3c thesynchronousparenttransactionsaresplitintotwo tasks beforeandafterthesubtransaction .statecanbeconveyed viathe workflowinstance sstate s.this transformationisneither injective norsurjective not every asynchronousworkflow can be translatedtoasynchronoustransaction andmultipledifferently nestedsynchronoustransactionsmightbetransformedtothesame workflow e.g.
both figures 3aand3bresult in figure 3c.
.
existing safe dsu approaches we now present three update conditions from the literature and show how they fit into our asynchronous workflow model.
kramerandmagee proposed quiescence q whichdoes notrelyonruntimeinformationofworkflowinstances.instead the workflows structure which is known at design time and whether a new workflow instance will be started suffice.
if necessary all future workflow instances are blocked to enforce quiescence.
definition6.
quiescence .
acomponentis quiescent ifit is not active and will not be active in a workflow instance.
ma et al.
proposed version consistency vc and evaluated it with a simulation which was later extended with a system implementation and evaluation based on apache tuscany .
the update condition of version consistency is calledfreeness.
definition6.
freeness .
acomponentis freeifit isnotactive and willnotbeactiveinaworkflowinstanceinwhichitalready executed a task.
versionconsistency issimilartoourapproachbutitdoesnot distinguishbetweendifferenttypesofupdates whichareallconservatively over approximated to an essential change.
vandewoude et al.
proposetranquility tq .definition6.
tranquility .
acomponentis tranquilifit is notactiveand willnotbeactiveinaworkflowinstanceinwhich it might execute a succeeding task for a component for which it already executed a succeeding task.
though proposed before version consistency tranquility effectivelycorrespondsto versionconsistency withtheadditional assumption that components follow a black box principle .
for systems satisfying this principle tranquility assumes that versionconsistencydoes nothavetobeenforcedbetweentheinternals ofdifferentsub transactions.forinstance ifwithinthesameroot transactionaclientusesanauthenticationcomponentandcallsthe server which uses authentication internally too client and server may safely use different versions of the authentication component.
leveraging the black box principle tranquility results in better update timeliness and less interruption than version consistency .
however tranquility is unsafe for systems that do not follow the black box principle as ma et al .
already noticed.
it is generally questionable whether workflows follow the black box principlebecausetheirtasksoftendependoneachother leading to a violation of the principle.
quiescence andversionconsistency mapdirectlytoourasynchronous workflow model section .
i.e.
definitions .1and6.
canbetriviallyverifiedbyinspectingthepotentialfuturetasks f and thevisited tasks v.tranquility definition .
however distinguishes between sub transactions that are called from the same transaction and ones that are called from a different transaction.
for example component cis tranquil between its two executions in figure 3a and it is not tranquil between its two task executions infigure 3b.yet thereisnosuchdistinctionintheasynchronous modelinfigure 3ccomparedtothesynchronousmodel section .
.
embracing tranquility s black box principle we assume that all taskexecutionsofacomponentwithprecedingtasksfromthesame component belong to a single synchronous transaction i.e.
for eachcomponent thesameversionofanothercomponentisusedfor each of its succeeding tasks.
with this definition in the asynchronousworkflowinfigure 3c component cisonlytranquilbefore the first and after the second task.
component a however may be updated after its first task i.e.
tranquility is unsafe if components do not respect the black box principle.
.
update conditions operationally differentsubsetsofourdisseminationalgorithm algorithm pr ovide the necessary data to a component to determine that an updateconditionforthecomponentisreached reachthecondition quicker and uphold the condition once reached.
our algorithmisinspiredbythecontrolalgorithmproposedfor version consistency which is based on graph transformations and verified to be correct .announcements are similar to their future edgesandmarkings topast edges there is no counterpart for locks.
however their transaction model lacks a holistic view of transactionswithinthesameroottransactionbecausecomponentsdo not share their internal logic.
in our workflow model such a view on workflow instances is available in their workflow engine.
we leverage this holistic view to reduce communication.
table 2summarizesthe partsofalgorithm 1requiredbythe updateconditions and reaching strategies.
we now provide more detailed insights.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa daniel sokolowski pascal weisenburger and guido salvaneschi abcdd c be q rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u tq rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u vc rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u es rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u rolgd du 5hqwdo rq u figure announcements markings and locks at intervals in figure 2during the execution of the trip booking saga with algorithm1forallupdateconditions announcement marking lock update safe non essential update safe update unsafe .
table elements of algorithm 1for updating approaches andreachingstrategies checknecessary checkcperprecedingcomponent check sufficientfornon ess.changes trianglesolidupholdcondition ess.
changes squaresoliduphold condition non ess.
changes .
approach strategy announcements markings locks quiescence check trianglesolid squaresolid tranquility checkc checkc trianglesolid squaresolid version consistency check check trianglesolid squaresolid essential safety check check trianglesolid check squaresolid waiting blocking instances check blocking tasks check check concurrent versions check inquiescence announcements are sufficient to check if componentsarequiescent theyareiftheyhavenoannouncements.to reachquiescence kramerandmagee onlydiscuss blocking instances as passivation of components i.e.
ensuring that no transactionsareinvokedonthecomponentinthefuture.theother threereachingstrategiesarealsoapplicablebutrequireruntime information which kramer and magee do not consider.
versionconsistency requiresannouncementsandmarkings but no locks.
a component is free if it has for no workflow instance an announcement anda marking.
ma et al .
discusswaiting blocking tasks and concurrent versions forversion consistency concluding that the last one should be the preferred strategy if applicable otherwise blocking tasks.
essential safety andversion consistency are equivalent if all updates are essential changes.
tranquility alsorequiresannouncementsandmarkings.yet both need to be per workflow instance andper component of the precedingtask s notonlyperworkflowinstanceasinalgorithm .
the condition is then similar to version consistency the component is tranquil if it has for no pair of workflow instance and preceding tasks component an announcement anda marking.
for blocking tasks this may deadlock workflow instances makingblocking tasks fortranquility generally unsafe also for single updates.
vandewoude et al .
usewaitingfortranquility and resort toblocking instances if the update point is not reached.
.
comparing the update conditions figure4showstheexecutionofalgorithm 1inthetripbookingsaga section2.
forthediscussedupdateconditions.thecolumnsshow thetimeintervalsfromfigure aligningwithtable .therows showtheupdateconditions.eachcelldepictstheannouncements markings andlocks storedonbothcomponentsatthegiven time interval when using the respective update condition.
they further show whether a component can be updated safely only for non essential changes or the update is unsafe.
timeinterval astartsafterbeforeworkflowcompletesand ends before beforeeachtask starts for the first time.
all other time intervals are during the execution of the respective task.
as an example the bottom row shows essential safety.
the firstentryillustratesthatattimeinterval a boththeholidayand the car rental component hold an announcement for the workflow instanceiexecutedonworkflowengine r.bothcomponentscanbe safely updated.
in the second entry at time interval b the holiday component is additionally marked and locked.
hence it cannot besafelyupdated.attimeinterval c theholidaycomponentcan be updated in case the update is a non essential change becauseit holds no lock.
however an essential update would be unsafe because it holds a marking andan announcement of i. quiescence exhibits the fewest safe update intervals because itdoesnotconsiderruntimeinformationonworkflowinstances.
we assume that no new workflow instance is started after the one in figure .
otherwise there would be no safe update interval for quiescence atall.incontrast thesafeupdateintervalsfortheother approaches remain unchanged without such an assumption.
tranquility features all safe update intervals of version consistency.
plus it permits intervals cand cfor the holiday component checkin table1 which cannot be considered generally safe if the componentdoesnot respecttheblack boxprinciple.for instance iftheholidaycomponentisupdatedattheseintervalsinawaythat it writes and reads the hotel booking id in another format to from workflows state s cancel hotel could fail.
essential safety features all safe update intervals of version consistency for essential changes.
for non essential changes it provides the most safe update intervals of all approaches.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
change is the only constant dynamic updates for workflows icse may pittsburgh pa usa table construction statistics of therealistic collaborative bpmn workflows dataset based on reprository .
workflow collection size recovered unchanged reprository collaborative workflows stuck endless loop incomplete missing internals evaluation dataset evaluation inthissection weempiricallyevaluatedynamicsoftwareupdating forlong runningandhighly frequentworkflows.weaimtoanswer the following research questions.
rq1 can safe dsu be adopted in real world collaborative workflow applications?
with this question we empirically investigate whether with our model for safe dsu in workflows section4.
the approaches discussed in section .2and6.2can be applied to real world collaborative workflow applications.
rq2 does essential safety significantly reduce the performanceoverheadofsafedsuinrealisticworkflows?
thisquestionempiricallyinvestigatestheperformancedifferencesamong thedsuapproachesdiscussedanalyticallyinsection .
.specifically we assesswhether essential safety significantly reduces the impact of updating realistic workflow applications.
rq3 how does the share of non essential changes impactthe performance of essential safety?
this question investigates to which degree essential safety s performance depends on the amount of non essential changes estimating the share of nonessentialchangesthatissufficienttoachievebetterperformance thanthepreviousapproaches.with rq4 rq3validatestheassumptionsmotivating the essentialsafety sperformance improvement.
rq4 how frequent are non essential changes in software systems with multiple components?
this question verifies the hypothesis behind essential safety that most updates are nonessential ensuring the generalizability of our results.
such evidence is required to determine the significance and applicability of our approach to real world workflows.
.
applicability of safe dsu to workflows we now evaluate whether our model and the safe dsu approaches are applicable to workflows.
for this we constructed a dataset of real world bpmn workflows and implemented a discrete eventbasedsimulationforsafedsuinworkflowsusingthedissemination algorithm section .
.
we assess essential safety section4 and theothersafedsuapproaches section .
.thesimulationandall scripts and data are publicly available .
no standard benchmark for realistic workflow models exists possibly due to their complexity and business relevance .
reprository isadatabaseofrealisticbpmnworkflows.based onafullcopyfromaugust3 weconstructedanevaluation dataset containing collaborative bpmn workflows .
weselectedallcollaborativeworkflowswithtwoormorebpmntable simulation parameter distributions.
parameter distribution network latency weibull .
30ms .1ms sd .4ms instances per workflow weibull .
s d avg.
task duration weibull .
2min .3s sd .6s task duration gaussian sd avg.
update interval gaussian 12h sd 4h min 1h max 24h avg.
update duration weibull .
5min .5min sd .1min update duration gaussian sd lanesorpools thebpmnelementsthatassignprocesselementstocollaborationparticipants whichweinterpretasworkflowcompo nents.everythingoutsideanylaneorpoolisaseparatecomponent.
accordingly allworkflowshavetasksonatleasttwodifferentcomponents.57workflowsarenotexecutablebecausetheygetstuck include endless loops are incomplete or only contain the internal workflowofonelaneorpool.wemanuallyrecovered28ofthese with minimal changes.
table4providesthesimulation parameterdistributions.all parameters are chosen with the intent to be as realistic as possible.
interarrival parameters and durations are weibull distributed with .
commonlyusedforinternet basedtrafficsimulations .
updateintervalsandtaskdurationsaregaussian distributed simu latingregularci cdexecutionsandtaskswithpredictable roughlyconstantexecutiontime whichiscommoninbusinessapplications.
the workflow instances are distributed over ten workflow engines.
for each workflow the number of instances is weibull distributed with on average one invocation every 66s.
.
of the components are updated between once per day and once per hour which are fixed limits of the mean update frequency.
we draw the points in time for startingworkflow instances and triggering componentupdates from a uniform distribution over the simulation timespan of two weeks.
of the updates are non essential changes.
we performedasensitivityanalysiswithbothdoubleandhalfthevalueofeachparameterusingthetripbookingsaga section .
.weomit the plots reported in as they do only confirm obvious correlations e.g.
halvingthetaskdurationmeansincreasesupdatability and decreases workflow duration and update time.
we successfully simulated all workflows for the safe dsu approaches in section .2and6.2and the reaching strategies section4.
.thisresultpositivelyanswers rq1 showingthatsafedsu can be applied to real world collaborative workflow applications.
.
performance of essential safety we now investigate the performance differences of the dsu approaches in the simulation introduced before.
table 5and figure comparetheupdatingapproaches section .2and6.
andreaching strategies section .
with the baseline no updates where no updatesareperformed.allsimulationsareexecutedonthesame trace of workflow instance executions and updates.
updatability is theoveralltimeinwhichtheupdateconditionismetatthecomponents i.e.
whenupdatingissafe .the updatetime measuresthe timespan from triggering to completing a component update.
it is splitintothe updatetimeliness untiltheupdateconditionismet and theupdate duration after the update condition is met .
the 1all exclusions and adjustments are documented in the dataset s build script .
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa daniel sokolowski pascal weisenburger and guido salvaneschi table5 performancemetricmeansforallupdateapproaches and reaching strategies over all simulations in minutes.
approach strategy updatabilityupdate workflow duration timeliness duration delay no updates baseline .
.
quiescence .
.
.
.
.
version consistency .
.
.
.
.
tranquility .
.
.
.
.
essential safety es .
.
.
.
.
es essential changes .
.
.
es non ess.
changes .
.
.
blocking instances .
.
.
.
.
blocking tasks bt .
.
.
.
.
btw otranquility .
.
.
.
.
concurrent versions .
.
.
.
.
waiting .
.
.
.
.
workflowduration isthetimespanbetweenworkflowinstancestart andcompletion.the workflowdelay isthedifferenceoftheworkflow instances start to its start in the baseline.
analogously the workflow interruption is the difference of the instances completion times measured by the sum of the instances delay and duration differences.for essentialsafety wealsoreportthemetricsseparately for essential and non essential changes a distinction that does not lead to different results for the other approaches.
among all approaches we find the least performance impact on updates and workflow instances with tranquility.
however tranquility is generally unsafe in contrast to all other approaches.
further tranquility withblockingtasks istheonlysimulationwith deadlockedworkflowinstances .
preventingtheircompletion.thesedeadlockspositivelyskewtheaveragesofallmetricsfor tranquility2because deadlocked workflow instances are excluded from the measurement data.
we observe that essential safety has similarperformanceto versionconsistency foressentialchanges and slightly better performance than tranquility for non essential changes.
overall essential safety s performance is similar to tranquility but retains update safety.
on average essential safety s workflow interruption is .
and it provides .
higher updatability .
lessupdatetime and47 .
lessworkflowinterruption thanversion consistency the best safe competitor.
the reaching strategies relative performance trends are similar among the updating approaches.
all strategies add only a small delaytotheworkflows.
versionconsistency exhibitsnodelayat all.blockinginstances entailsthehighestdelays.for concurrent versions the update timeliness is similarly low for all updating approaches whereas the update duration exhibits some variability.
viceversa allother reachingstrategies exhibitsimilar update durations but variableupdate timeliness.
this differenceis due to concurrent versions running two component versions in parallel eliminating the workflow interruption because workflow instancesneverwaitforcomponentupdates.however concurrent versions requiresthatthecomponents implementationssupport running two different versions in parallel which our simulation assumesispossible.ifnotsupportedbythecomponents implementations concurrentversions mustnotbeused.instead blocking 2due to the deadlock skew table 5also reports blocking tasks withouttranquility.
!
figure performance of the safe dsu approaches.
taskscauses the least impact on component updates in such cases.
thoughwaitingdelays workflow instances to a lesser extent it heavily delays updates on average by .
hours.
ourresultsanswer rq2andshowthattheimpactofsafedsu can be significant.
for essential safety the impact of non essential changesiscompletelynegligible andtheimpactofessentialchanges isnothigherthanwithpreviousapproaches.forarealisticchangeset essential safety significantly decreases the overhead of safe dsu compared to the state of the art.
.
effect of non essential updates to evaluate whether distinguishing essential and non essential changesiseffective theassumptionbehind essentialsafety we repeattheprevioussimulationwithdifferentratiosofnon essential toessentialchanges.figure 6showsthemetricsfromsection .
foressential safety with only essential changes only nonessential changes and all ratios in between in steps of points.
the results are presented separately for essential ess.
and non essential changes non ess.
as well as combined total .
intotal theupdatabilityincreaseswiththeshareofnon essential changes on average .
from to non essential changes.
theupdatetimereduces onaverage byupto52 .
andtheworkflow interruption by .
.
wenowconsideressentialandnon essentialchangesseparately.
for all metrics and approaches the results are similar i.e.
inde pendent from the share of non essential changes except for thefollowing cases for blocking instances andblocking tasks the updatabilities slightly decrease with the increasing share of nonessential changes because the likelihood that multiple updates are reached jointly and executed as a batch is lower.
this increases blocking times to reach safe update intervals.
for the same reason the timeliness of essential change updates gets worse for waiting.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
change is the only constant dynamic updates for workflows icse may pittsburgh pa usa !
!
figure6 performanceof essentialsafety fordifferentshares of non essential changes ess.
essential changes non ess.
non essential changes total all changes .
theresultsanswer rq3 thehighertheshareofnon essential changes the smaller essential safety s overall performance impact.
thus considering non essential changes is crucial and effective to reduce the overhead of safe dsu for workflows.
.
frequency of non essential updates to answer rq4 we focus on open source software repositories and assume that they use a continuous deployment pipeline.
in continuousdeployment everycommitmaytriggerthedeployment ofanupdate.identifyingwhichcomponentsareaffectedbyeach commit requires application knowledge and cannot be easily automated.hence forsimplicity acommonpracticeis toredeployall components even though one can easily hypothesize that a subset suffices.
to assess this hypothesis we focus on repositories that aggregate various software components.
such monorepos arewidelyused .typically thedegreetowhich componentsinthemdependoneachothervaries allowingusto identify the subset of components that a commit changed.
we investigated eight monorepos that are publicly available on githubanddescribedin .inthemonorepos eachcomponent is encapsulated in its own directory.
we identify the directories that contain a component based on the repository description.
we explore the most recent commits of each repository to determinehowmanycomponentsareaffectedbyeachcommit.we assumethatacomponentchangedifacommitmodifiesafileinthe component s directory.
for commits that change files not associated to any component we consider a conservative approximation upperbound thatthecommitsaffecteverycomponent andaspeculativeapproximation lowerbound thattheydonotaffectany.
we ignore changes to tests documentation and hidden directories.
table6showsforeachmonorepotheabsolutenumberandthe percentage of affected components mean over all commits .
onaverage even under the conservative approximation a commitaffects less than half of the components.
under the speculative approximation commits affect less than of the components in mostmonorepos.accordingly atleast60 ofthecomponent updates are non essential changes.table6 affectedcomponentspercommitinmonorepos .
average number of components average share of components monorepo affected by a commit affected by a commit startupos foursquare fsq.io m3 celo berty stellar go habitat nixpkgs sofarwehavedemonstratedhowoftencommitsarenon essential component changes because the commits do not change a component s code.
additionally not all code changes introduce semantic changes i.e.
they are non essential for allcomponents.
such commits further reduce the observed numbers in table .
previous studies provide evidence that the amount of such non essential changesissignificant kawrykowandrobillard analyzed seven open source java systems finding that up to .
of the methodupdatesarecosmetic behavior preserving orunlikelyto provide further insight into component relationships.
based on the travistorrent dataset abdalkareem et al .
found that ofthecommitsdevelopersmanuallyskipinci cdpipelines are skipped because they are non essential changes i.e.
they only touch documentation source code comments formatting of source code meta files or are code release preparations.
theseresultsanswer rq4 onaverage ofthecomponent changes are non essential as a lower bound while we realistically assume a considerably higher percentage of over .
conclusion traditionally software updates require shutting down the system beforereplacinganycomponent.toavoidservicedisruption dynamicsoftwareupdating dsu techniquesensurethatcomponents can safely be replaced while the application is running.
unfortunately existing safe dsu approaches introduce a significant performance overhead and it is unclear how to apply them to workflows i.e.
long running asynchronoustransactions.toclosethisgap we proposeaunifiedformalmodelforsafedsuinworkflows show howstate of the artdsuapproachesarecapturedbyit andcomparethemanalyticallywith essentialsafety ournovelsafedsu solution.
essential safety leverages the identification of updates that have no semantic changes non essential changes effectively reducing the performance overhead of dsu.
the empirical eval uation on realistic collaborative bpmn workflows and eight monoreposconfirmsthatweenableefficient safedynamicsoftware updating in long running and frequently executed workflows.