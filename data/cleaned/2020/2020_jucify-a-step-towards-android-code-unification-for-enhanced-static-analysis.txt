jucify a step towards android code unification for enhanced static analysis jordansamhi1 jungao1 nadiadaoudi1 pierregraux1 henrihoyez4 xiaoyusun2 kevinallix1 tegawend f. bissyand 1 jacques klein1 1snt university of luxembourg luxembourg firstname.lastname uni.lu 2monash university australia firstname.lastname monash.edu 3univ.
lille cnrs centrale lille umr cristal f lille france firstname.lastname univ lille.fr 4technische universit t kaiserslautern germany firstname.lastname sms group.com abstract native code is now commonplace within android app packages whereitco existsandinteractswithdexbytecodethroughthejava nativeinterfacetodeliverrichappfunctionalities.yet state of theartstaticanalysisapproacheshavemostlyoverlookedthepresenceofsuchnativecode which however mayimplementsomekeysensitive or even malicious parts of the app behavior.
this limitation ofthestateoftheartisaseverethreattovalidityinalargerangeof static analyses that do not have a complete view of the executable codeinapps.toaddressthisissue weproposeanewadvancein the ambitiousresearch directionof buildinga unified modelof all codeinandroidapps.thejucifyapproachpresentedinthispaper is a significant step towards such a model where we extract andmerge call graphs of native code and bytecode to make the final modelreadily usablebyacommonandroidanalysisframework in our implementation jucify builds on the soot internal intermediaterepresentation.weperformedempiricalinvestigationsto highlight how without the unified model a significant amount ofjavamethodscalledfromthenativecodeare unreachable in apps call graphs bothingoodwareandmalware.usingjucify we were able to enable static analyzers to reveal cases where malware relied on native code to hide invocation of payment library code or of other sensitive code in the android framework.
additionally jucify smodelenablesstate of the arttoolstoachievebetterprecision and recall in detecting data leaks through native code.
finally we show that by using jucify we can find sensitive data leaks that pass through native code.
acm reference format jordan samhi1 jun gao1 nadia daoudi1 pierre graux1 henri hoyez4 xiaoyu sun2 kevin allix1 tegawend f. bissyand 1 jacques klein1.
.
jucify a step towards android code unification for enhanced static analysis.in 44thinternationalconferenceonsoftwareengineering icse may pittsburgh pa usa.
acm new york ny usa pages.
this work is licensed under a creative commons attribution international .
license.
icse may pittsburgh pa usa copyright held by the owner author s .
acm isbn .
introduction android app analysis has been one of the most active themes of software engineering research in the last decade.
static analysis research inparticular hasproducedavarietyofapproachesandtools that are leveraged in a variety of tasks including bug detection securitypropertychecking malwaredetection orempiricalstudies.
thewidely usedstate of the artapproaches suchasflowdroid develop analyses that focus on the dex bytecode in apps.
unfortunately recentstudies haveshownthatmalware authorsoftenbuildonnativecodetohidetheirmaliciousoperations e.g.
private data leak or to implement sandbox evasion .
the need to account for native code within android apps is becoming urgent as the usage of native code is growing within both benign and malicious apps.
our empirical investigation on apps from the androzoo repository reveals that in up to .
of collected apps included native code within their packages.
yet nativecodeisscarcelyconsideredinappsecurityvetting .
inthemajorityofstatic dynamic and machine learning based techniques native code is overlooked since it presents several challenges.
when researchers propose techniques to address native code such as with jn saf droidnative nativeguard taintart and others the integrated analyses e.g.
for taint tracking native entry point detection and machine learningfeatureextraction aregenerallyad hoc.indeed theseworks develop custom techniques to bridge native code and bytecode typicallybycombiningresultsofseparateanalysesofbytecodeand native code.
therefore they do not yield an explicit unified model of the app to which generic analyses can be applied to explore bytecode and native code altogether.
our work aims to fill the gap in whole app analysis by researchingmeanstobuildaunifiedmodelofandroidcode.wepropose jucify asteptowardbuildingaframeworkthatbreaksbytecodenative boundaries for android apps and therefore copes with acommon limitation of static approaches in the literature.
to thebest of our knowledge jucify is the first approach that targetsthe unification of android bytecode and native code into a uni fied model and is instantiated in a standard representation .
we target the jimple intermediaterepresentation assupport forjucifyunifiedmodel.jimpleistheinternalrepresentationin the widely used soot framework and is indeed the representation that is considered in a large body of static analysis works .
by supporting jimple jucify provides the opportunity for several analyses in the literature to readily account for native code.
ieee acm 44th international conference on software engineering icse this paper.
jucify is a multi step static analysis approach that weimplementasaframeworkforgeneratingaunifiedmodelofapps taking into account native code.
it relies on symbolic execution to retrieve invocations between both the dex bytecode and the native worlds pre computes native call graph merges dex bytecode and native call graphs and populates newly generated functions with heuristic based defined jimple statements using code instrumentation.
the main contributions of our work are as follows we propose jucify an approach to build a unified model of android app code for enabling enhanced static analyses.
we haveimplementedjucifytoproducethejimplecodethat unifies bytecode and native code within an app package we conduct an assessment of the jucify yielded model.
we showthatjucifycansignificantlyenhanceandroidapps call graphs.
jucify connects previously unreachable methods in android apps call graphs weevaluatetheunifiedmodelofappcodeinthetaskofdata flowtracking.
we showthat jucify cansignificantly boost the precision of the state of the art flowdroid from to82 anditsrecallfrom0 to100 onanewbenchmark targeting bytecode native data flow tracking we evaluate jucify on a set of real world android apps and show that it can augment existing analysers enabling them to reveal sensitive data leaks that pass through the native code which were previously undetectable.
wereleaseouropen sourceprototypejucifytothecommunity as well as all the artifacts used in our study at the remainder of this paper is organized as follows.
we first introduce background notions and motivate our work in section .
in section we present our jucify approach.
we evaluate jucify in section .
in sections and wepresent the limitations and the threats to validity of the current state of our approach.
finally we overview the related work in section and conclude in section .
background motivation javaandkotlinarethetwomainstreamprogramminglanguages that support the development of android apps.
their programs are compiled into dex bytecode and included within app packages in the form of dex files .
nevertheless thanks to java native interface native code functionalities are accessible in android apps.theycomeinbinary e.g.
.sosharelibrary filescompiled from input programs written in c c for instance.
.
java native interface jni jniisanimplementationofthe foreignfunctioninterface ffi mechanism that allows programs written in a given language to invoke subroutines written in another language.
jni allows both java to native and native to java invocations.
.
.
java to native code.
listing presents an example where jni capabilities are used to call a native function here written in c fromjava.first arelevantjavamethodisdefinedwiththekeyword native line4 .wewillrefertoitasa javanativemethod .then its1 java world public class mainactivity extends activity static system.loadlibrary native lib public native stringnativegetimei telephonymanager tm override protected voidoncreate bundle savedinstancestate super.oncreate savedinstancestate telephonymanager tm telephonymanager getsystemservice phone string imei nativegetimei tm log.d imei imei public voidmalicious malicious code c world 15jniexport jstring jnicall 16java mainactivity nativegetimei jnienv env jobject thiz jobject tm jclass c env .getobjectclass tm jmethodid m env .getmethodid c getimei ljava lang string jstring i jstring env .callobjectmethod tm m c env .getobjectclass thiz m env .getmethodid c malicious v env .callobjectmethod thiz m returni listing code illustrating how an app can trigger native code.
methods and code are simplified for convenience correspondingnativefunctionisregisteredtosetupthemapping between them.
such a registration can be static thenativefunctiondefinitionfollowsanamingconvention based on specific jni macros.
for example the java native method nativegetimei line corresponds to a native function named java com example nativegetimei in c line .
dynamic developers can arbitrarily name their native functions in c as shown in listing lines but must inform jni abouthowtomapthemwithjavanativemethods.thus developers first map java native methods to their counterpart native functions by using specific jninativemethod structures lines in listing overload a specific jni interface function jni onload to register the mapping lines in listing and invokeregisternatives injni onload which will be called by android vm line in listing .
.
.
native to java.
with jni developers can create and manipulatejava objectswithin thenative code e.g.
writtenin c .
the fieldsandmethodsofjavaobjectsarealsoaccessiblefromthenative code and can be invoked using specific jni interfacefunctions.
eventually likewise java reflection i.e.
using strings to get methods and classes the developer can invoke the java methods e.g.
lines in listing .
note that listings and illustrate the interaction between java and c .
however jucify the approach proposed in this paper works at the apk level.
therefore the invocations are between bytecode and compiled native code.
.
motivating example binarystaticcodeanalysisisinitselfachallenge sincethecompiled code is hard to represent for appropriate investigation .
althoughcurrentstate of the artandroidstaticcodeanalysis approaches are sophisticated most of the time they overlook native code with only a few of them considering it .
withasimpleexampleillustratedinlisting1 wemakethecase thatnativecodeshouldbeconsideredinstaticanalysisapproaches.
java world public class mainactivity extends activity static system.loadlibrary native lib public native stringnativemethod override protected voidoncreate bundle b nativemethod c world 9jniexport jstring jnicall 10jstring arbitrary name jnienv e jobject thiz std string str str returne newstringutf str.c str static const jninativemethod m nativemethod ljava lang string jstring arbitrary name 17jniexport jint jni onload javavm vm void reserved jnienv e null if vm getenv void e jni version 1 4 !
jni ok return jclass c e findclass com example mainactivity if !c return if e registernatives c m sizeof m sizeof m return return1 listing dynamic native function registration example.
methods and code are simplified for convenience first intheoncreate methodofthemain activity astring is retrieved on line from the method nativegetimei then this stringisusedasaparametertothemethod log.d .fromthepoint of view of taint tracking there is a flow from the getimei method source tothe log.d method sink .
however moststate of theartapproacheswillmissthisflowduetotechnicallimitationssince themethod nativegetimei isnotanalyzed.thereforethevariable imeiis not tainted and the flow is not detected.
second themethod malicious line12 isnevercalledinthe javacode thus itwillnotappearinthecall graphsinceitisconsideredasunreachable .henceitwillnotbeanalyzed causingexisting tools to fail to detect potential malicious code in the method.
let us consider figure which presents the expected call graph ofthisexample.thecurrentstate of the artapproaches suchas generally analyze the green nodes which are reachable from an entry point.
however the red nodes will only be considered by approaches able to analyze the native code.
approaches tryingtoovercomethechallengeofnativecodeanalysisinandroid apps already exist e.g.
.
however they focus on specific analyses and propose custom solutions to bridge bytecode and native code.
in contrast in this paper we aim at offering an explicitunifiedmodelofandroidappstowhichgenericanalysis could be applied to explore altogether bytecode and native code.
oncreatednativegetimei getsystemservice getimeigetobjectclassgetmethodid callobjectmethod malicious figure unified call graph representation for the code in listing greennodes represent reachable nodes of existing static approaches while redones represent the nodes unreachable with most of the existing static approaches approach for a given android app jucify aims to unify its dex bytecode and native code into a unified model and instantiate this model inthejimplerepresentation i.e.
theintermediaterepresentationof the popular soot framework .
in this section we will first detail theoveralljucifyconceptualapproach andthenwewillbriefly present how we instrument the app to approximate the native behavior.however duetospaceconstraints wewillnotpresentall technicaldetails relatedtojimple.
weinvite theinterestedreader toconsiderallourpublicly sharedartifactsontheprojectgithub repository1.
jucify implementation is fully open sourced.
.
call graph as unified preliminary model toexplaintheoverallfunctioningof jucify wewillrestrictour explanationstothenotionofcallgraph cg .acgcanbedefined ascg v e wherevis a set of vertices representing functions ande u v u v v is a set of edges such as u v e there is a call from utovin the program.
jucify is a multi step static analysis framework whose overall architecture is depicted in figure .
first a submodule called nativediscloser constructs the native callgraph and extracts the mutualinvocationsbetweenbytecodeandnativecode.then native callgraphisprunedandpreparedtobesoot compliantbeforebeing mergedwiththebytecodecallgraph.eventually bothcallgraphs are unified thanks to information related to the bytecode native method invocations.
in the following with give more details about the different steps of our approach.
step native call graph construction nativeprogramcall graphconstructionisnottrivial .infact a large body of work tackled this problem and proposed several solutions to find function boundaries .
in this work thecall graphsnativelibrariesinandroidappsaregeneratedby angr a well known binary analysis framework which is wrapped into our submodule nativediscloser.
step bytecode native code invocations extraction this step is performed over sub steps retrieve bytecode methods information extract entry method invocations i.e.
bytecode to native track native function calls and extract exit method invocations.
step .
methods info extraction is a straightforward task that extracts information of bytecode methods such as the class of a method methodsignature.thisstepaimstocompletethesignature informationrequiredtoperformthemethodinvocationsextraction task for statically registered functions.
we perform this task by relying on androguard .
step1.
entrymethodinvocationsextraction anentrymethod invocation is a native method invocation from the bytecode i.e.
abytecode to native link .asdescribedinsection2.
forsuch an invocation we need to match a java native method i.e.
a method declared in java with the nativekeyword also called entry method and anentry function i.e.
the counterpart native function .
to perform this task we have to take care of both static anddynamicregistrations.thestaticallyregisteredfunctionscanbe easily spotted via their naming conventions.
however as dynamic registrationreliesonjni interfacefunctioncalls moresophisticated techniquesarerequired.inourcase werelyonsymbolicexecution.
1234cg call graph native cg node bytecode cg node previously unreachable bytecode cg node step .
methods info extractionstep .
entries extractionstep .
exits extraction step native cg extraction step .
native cg pruning step .
native cg conversionstep .
patch cg with bytecode tonative edgesstep .
patch cg with nativeto bytecode edges and bytecode nodes step .
bytecode cg constructionnativediscloser entry functions final app modelcg component generationbytecode and native call graphs unification entry invocationsentry exit invocations .dex files.so files method info entry exit invocationsentry functions figure overview of the jucify approach from the angle of call graph construction from a more technical point of view nativediscloser takes as input the library i.e.
.so files of an apk and the method informationfromthepreviousstep.itfirstscansthesymboltableofeach binary to search for statically registered native functions and thejni onload function for the case of dynamically registered functions.then if jni onload exists thisfunctionissymbolically executed to further detect dynamically registered native functions.
for symbolic execution nativediscloser relies on angr .
step1.
exitmethodinvocationsextraction wearelookingfor theinvocationsofabytecodemethodfromthenativecode.wecall exit method this bytecode method.
in section .
.
we explained that this exit method is called by invoking certain jni interface functionsinachainedmanner.collectinginformationrelatedto this chain of jni function invocations is challenging.
inpractice toovercomethischallenge nativediscloserexecutes all the entry functions acquired from step .
symbolically to search for the exit method invocations and set up the relation mapping between entry and exit method invocations.
furthermore exit methods could be invoked deep down in a nativefunctionchain.however thesymbolicexecutionisnotawareof the boundaries between native functions.
hence we implemented atrackingmechanismduringthesearchofexitmethods.werely onthestartingaddressofeachnativefunctionobtainedfromthe native call graph to maintain a stack of native functions and push a new function into the stack when its starting address is reached.
popping a function from the stack is triggered by the arrival of the return addresses of native functions which can be obtained fromacertainregisterormemorylocationbasedonarchitecture specifications e.g.
link register lrforarm during entering a nativefunction.thisallowsustoknowfromwhichnativefunction an exit method invocation occurs.
step cg components generation step .
native cg pruning.
since in .so libraries not all the functions are necessarily called in an app we rely on a strategy to onlykeeprelevantcallgraphparts.todoso weprunetheobtainednative call graphs constructed in step with the help of the entry functions passed in from step .
we only keep the sub graphs startingfromtheentryfunctions withallsuccessornodes since the remaining parts will not be reachable from the bytecode.
step .
bytecode cg construction.
our approach also requires thebytecodecall graph.forthispurpose weuse flowdroid itself based on soot which leverages an advanced modeling of app components life cycle.
step bytecode and native call graphs unification step3.
nativecgconversion.
inpractice thetargetistoload both native and bytecode call graphs in soot.
although this is straightforward for the bytecode call graph the native call graph requires a conversion step to fit with soot technical constraints.
once loaded the sets of nodes and edges of both call graphs are merged but the call graphs are not yet connected together.
step3.
patchcgwithbytecode to nativeedges.
then according to the entry invocations obtained from step .
edges between entry methods in bytecode and their counterpart entry functions in native code are added.
step .
patch cg with native to bytecode edges and bytecode nodes.finally with the information of exit invocations and the relationswithentryinvocationsfromstep1.
edgesbetweennative functionstoexitmethodsareadded.thisstepallowsuncovering previously unreachable bytecode callgraph nodes.
.
from cg to jimple for a unified model a call graph is a useful model but it is still limited because it does not contain enough information to perform static analysis e.g.
dataflowanalysis .indeed importantinformationsuchasthe statements present in each method is missing i.e.
the control flow graph cfg .atoolsuchasflowdroidprovidesthecfgforeach bytecodemethodwherethemethodbehaviorisrepresentedwith jimple statements.
we will now explain how jucify adds jimple statements in specific native functions in a best effort mode.
after 1235thisstep foragivenapk weobtainthejimplerepresentationof the apk with both bytecode and native code unified.
native functions generation jucify relies on a dummybinaryclasswhosepurposeistoincorporateanynewlyimportednative function in the soot representation.
for each native function in the native call graph jucify generates a new method in the dummybinaryclass with appropriate signatures.
bytecode method statements instrumentation jucify generates bytecode to native call graph edges.
it also has to replace the initialcalltothenativemethodatthestatementlevelwithacall to the newly generated native function.
jucify takes care of the returnedvalueandtheparameterstonotfoolanyanalysisbased on the new built model.
native function statements generation there is no bijection between native code and jimple code .
moreover bytecode and native code manipulate different notions e.g.
pointers that cannotbetranslateddirectly.therefore wehavetouseheuristics based on the information at our disposal to put a first step toward reconstructing native function behavior.
letusconsideranativefunctionnamed foo containingatleast oneinvocationtoabytecodemethod m.asexplainedinsection3.
the first step of jucify aims to collect information about bytecode methods fullsignature .thankstothis wecanapproximatethe parameters used by mas well as its return values.
more specifically in listing we detail the steps jucify implementstopopulatethenativefunction foo thatcallsabytecode methodm.letconsider misdefinedinajavaclassnamed myclass.
in line jucify starts with the empty method foo .
then step in listing if the bytecode method mshould return a value jucify generates a new local variable with the same type as the method s return type line .
step2inlisting3 jucify generates the declaration of a variable oftypemyclass theclassinwhich misdefined line8 .inline9 jucifycreatesanew myclassinstance ifthereisnotoneusable as a base for the bytecode call .
step3inlisting3 regardingtheparametersthatshouldbeused for the invocation of m jucify scans foo for local variables and parameters whose types match the types of the parameters of m. if for a given type no local variable nor parameter of foo is found jucify generates one e.g.
line .
then it generates all the permutations of these variables with a given length i.e.
the number of parameter of m and retains only those matching the types order of the parameters of m i1 s and i2 s in listing .
each retained permutation corresponds to a possible call to the bytecode method in the native function as an over approximation.
nevertheless these calls cannot be generated sequentially since they correspond to different realities.
hence we rely on opaque predicates ifstatements whose predicate cannot be evaluated statically sothateachcontrolflowpathisconsideredidentically lines .
step in listing if the native function returns a value from the signature of foo jucify should generate return statements.
todoso itoperatesasfor m.itreliesonopaquepredicates.indeed first jucifyscansthebodyofthecurrentnativefunctiontofind any local variable corresponding to the type of the return value eventhosenewlygeneratedlocalvariablesthatcouldbereturned .
ifnovariableisfound jucifygeneratessuchavariable.else for1 public boolean foo inti1 inti2 boolean b1 step public boolean foo inti1 inti2 boolean b1 boolean b2 step public boolean foo inti1 inti2 boolean b1 boolean b2 myclass jc jc newmyclass step public boolean foo inti1 inti2 boolean b1 boolean b2 myclass jc string s jc newmyclass s newstring if opaque predicate b2 jc.m i1 s else if opaque predicate b2 jc.m i2 s step public boolean foo inti1 inti2 boolean b1 boolean b2 myclass jc string s jc newmyclass s newstring if opaque predicate b2 jc.m i1 s else if opaque predicate b2 jc.m i2 s if opaque predicate returnb1 else if opaque predicate returnb2 listing jucify s process to populate native functions eachoffoundlocalvariables jucifygeneratesreturnstatements withopaquepredicatessothateachpathcanbeequallyconsidered lines in listing .
finally jucify yields a unified model of android apps on which analysts can perform any static analysis.
evaluation weinvestigatethefollowingresearchquestionstoassesstheimportance of our contributions rq1 whatistheproportionandevolutionofnativecodeusage in both real world benign and malicious apps?
rq2 to what extent our bytecode native invocation extraction step namednativediscloser yieldsbetterresultsthanthe state of the art ?
rq3 can jucify boost existing static data flow analyzers?
rq4 how does jucify behave in the wild?
we address this question both at the quantitative and qualitative levels rq4.a to what extent can jucify augment apps callgraphs and reveal previously unreachable javamethods?
rq4.b can jucify reveal previously unreachable data leaks that pass through native code in real world apps?
.
rq1 native code usage in the wild this section presents general statistics about the usage of native code in both benign and malicious android apps.
we also perform an evolutionary study of this usage.
dataset we rely on the androzoo repository to build a dataset of benign apps where we consider an app as benignifnoantivirusinvirustotal hasflaggedit score0 and adatasetof 174342maliciousapps whereweconsideran appasmaliciouswhenatleast10antivirusenginesinvirustotal haveflaggedit .bothdatasetscontainalltheappsfrom2015to2020 thatwewereabletocollectfromandrozoowiththementioned virustotal constraints.
empiricalstudy androidprogrammingwiththenativedevelopment kit ndk suggests developers to integrate native libraries i.e.
.sofiles whose code can be invoked from the java world.
therefore tostudytheextentofnativecodeusageinandroidapps asapreliminarystudy foreachapp wecheckifitcontainsatleast one .so file in its apk file.
however since native libraries can be presentinappsbutneverused wealsocheckforeachappifjava native methods cf.
section .
are declared in the bytecode.
goodware malware apps w .so files w native methods apps w .so files w native methods .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
total2641194 table number and proportion of android apps that containatleastone .sofile javanativemethod w with .
resultsof our empirical study are presented in table .
they indicate that overall benign apps i.e.
contain at leastone.sofile and i.e.
containatleastonejava native method declaration.
this means that .
of apps with native libraries contain java native method declaration in their bytecode.
regarding malware i.e.
of apps contain nativelibrariesand i.e.
javanativemethoddeclarations.hence .
ofmalwarewithnativelibrariescontainjava native method declarations.
overall these results show that native code is in proportion more used in malicious apps.
regarding usage evolution in benign apps the rate increases until to reach a plateau at around .
the trend regarding malware is much more erratic with sharp decreases in and .however foreachyear maliciousappsusesignificantlymore native code than benign apps.
rq1answer nativecodeisdefinitelypervasiveinandroidapps.
whilebothbenignandmaliciouscodeleveragenativecode native invocationsare substantiallymore commonin malware vs. .
theseresultsindicatethatignoringnativecodeisaseriousthreat to validity in android static code analysis.
.
rq2 bytecode native invocation extraction comparison identifyingnative to bytecodeandbytecode to nativecodeinvocationsarekeysteps towardscodeunification.ourobjectiveisto estimatetowhatextentthecorrespondingbuildingblockinjucify is effective against a benchmark and against the state of the art.
native to bytecode fourtounis et al.
proposed an approach to detect exit invocations i.e.
native to bytecode invocations c.f.
section .
in native code via binaryscanning.
their tool named native scanner has been developed as a plugin ofaframeworkcalleddoop .briefly theirtoolscansbinary filesforstringconstantsthatmatchjavamethodnamesandjava vmtypesignaturesandfollowstheirpropagation.inthisway they consider all matches as new entry points back to bytecode.
tocompareournativediscloserwithnative scanner we developed and released benchmark apps.
all these apps are executable android apps and have been tested on a nexus5 phone with android version .
.
.
we design these apps to cover differentsituations such as dynamic static registration chained invocations innativefunctions parameterpassingviastructuresandclasses stringaccessingviaarraysandfunctionreturns stringobfuscation etc.
table presents the results obtained with both tools.
tp true positive fp false positive fn false negative benchmarknative scanner nativediscloser tp fp fn tp fp fn bm1 bm7 bm10 bm6 bm8 bm9 bm13 bm14 bm15 bm16 precision .
recall .
.
due to space limitation we put together apps with same results.
e.g.
nativediscloser detects tp for each app bm6andbm8.
table comparison of tools these results show that native scanner misses a high number ofexitinvocations.werealizedthatnative scannerseemsnot to consider android framework apis the tool misses the api invocationsinallbenchmarkapps .notethat native scannerisnot specific to android.
this could explain why it does not consider android apis.
the tool is also challenged by constant string obfuscation app bm9 whichisalsothecasefornativediscloser.
bm14 implements fake method string constants in the native part.
for this app we can observethe over estimation of native scanner i.e.
ahighnumberoffalse positive whilenativediscloserisnot affected.finally nativediscloseralsofailedwithstringconstants passing via arrays and function returns as implemented in bm15 andbm16respectively.
limitations of angr could cause this in parsingpointerofpointers.overall comparedtonative scanner nativediscloser obtains significantly higher precision and recall.
bytecode to native we were unable to compare nativediscloser with native scanner.
unlike our tool native scanner doesnotinvestigate bytecodetonativeentryinvocationsand the relations mapping between entry and exit invocations.
note however thatonourbenchmarkof16apps nativediscloser yields precision in finding both the entry invocations and theentry to exit relations and achievesa recall of .
and .
respectively.
rq2answer comparedtothestate of the artnative scanner our nativediscloser extracts exit invocations with better precisionandrecall.besides itcanprovideextrainformation including entry invocations i.e.
bytecode to native invocations and the relations with exit invocations which is essential to generate comprehensive call graphs.
.
rq3 can jucify boost static data flow analyzers?
insection3 wedescribedhowjucifycouldapproximatethebehavior of native functions based on the information retrieved from signatures parameters returntype andbytecodemethodscalled from native code via jni.
in this rq we check if this first step approximationhelpsperformadvancedstaticanalysessuchasdata 1237leak detection on a well defined benchmark.
we will assess the capability of jucify on real world applications in rq4.
the benchmark that we built for rq3 contains apps that we plantointegrateintodroidbench anopentestsuitethatcontains hand crafted android apps to assess taint analyzers.
among these apps 9containaflowgoingthroughthenativeworld and2donot contain any data flow to detect potentialfalse positives .
then we apply the state of the art flowdroid taint analysis engine before and after applying jucify in our benchmark apps to show that flowdroidcan likewisein beboosted.flowdroiddetects paths from well defined sources e.g.
getdeviceid and sinks e.g.
sendtextmessage methods in android apps.
benchmarkconstruction we identified cases on which we builtour11benchmarkappstoassesstheabilityoftoolsindetecting data leak via native code a getter source in native code and sink in java code b leaker source in java code and sink in native code c proxy source in java code and sink in java code d delegation source in native code and sink in native code note that source sink in native code means that the call to a sensitive method is actually performed in native code but the sensitive method is always a method from the android framework accessedwithjni e.g.
callingwithjnithe getdeviceid from thenativecode .foreachofthesecases atleastonestephappensin native.
figure illustrates these four cases.
the red dots represent tainted information from a source method and the red arrows representhowthisinformationflowsintheprogram.the getter use caseallowsdeveloperstogetsensitivedatafromthenativecode to leak it in the java world.
the leakeruse case allows developers to get sensitive data from the java world to leak it in the native world.regardingthe proxyuse case thesensitiveinformationis retrieved in the java world sent to the native world to break the flow and sent back to the java world to be leaked.
concerning the delegation use case asimplenativefunctioniscalledfromthejava world and the sensitive information is retrieved and leaked in the native world.
our benchmark apps has been built upon these four cases that weidentified toberepresentativeofthesecases withcombination of multiple cases.
results table provides the results of our experiments.
flowdroid is clearly limited and not designed to handle native code.
therefore its inferior performances are not surprising.
indeed flowdroid gets a precision and recall of on this benchmark.
nevertheless wecanseethatafterapplyingjucify flowdroid performanceissignificantlyboosted.indeed itcandetectallthe leakspresentinthebenchmark henceachievingarecallscoreof .
regardingapps getter string andleaker string flowdroid reportsforbothofthemafalsepositivealarmleadingtoaprecision of on this benchmark.
in these apps a string is sent outside theapps notsensitivedata.thisiseasilyexplainedbythefactthat when jucify reconstructs the native function s behavior it uses opaquepredicatestoapproximatewhatvariablecanbereturnedby the current function given its signature.
therefore there is a path in which the sensitive data is considered whereas it is not leaked.
tainted information call edge taint propagation method entrypoint native sink source return java native a getter source native sink java native b leaker source native sink return java native c proxynative source sink java native d delegation figure four propagation scenarios through native code circlecopyrt true positive false positive circlecopyrt false negative test case leakflowdroid jucify getter imei circlecopyrt circlecopyrt leaker imei circlecopyrt circlecopyrt proxy imei circlecopyrt circlecopyrt delegation imei circlecopyrt circlecopyrt getter string leaker string proxy double circlecopyrt circlecopyrt delegation pr oxy circlecopyrt circlecopyrt getter leaker circlecopyrt circlecopyrt getter pr oxy leaker circlecopyrt circlecopyrt getter imei de ep circlecopyrt circlecopyrt sum precision recall circlecopyrt higheris better lower is better circlecopyrt lower is better precisionp circlecopyrt circlecopyrt recallr circlecopyrt circlecopyrt circlecopyrt f1 score 2pr p r table results of data leak detection through native code inbenchapps.flowdroidcolumnrepresentstheresultsof running flowdroid alone.
jucify column represents the results of running flowdroid after applying jucify rq3answer jucifyisessentialforboostingstate of the artstatic analyzerssuchasflowdroidtotakeintoaccountnativecode.on our constructed benchmark flowdroid which failed to discover any leak is now able to precisely identify leaks in a high number of samples f1 score at .
.
rq4 jucify in the wild in this section we evaluate jucify in the wild from two points of view a quantitative assessment in section .
.
and a qualitative assessment in section .
.
.
.
.
rq4.a towhatextentcanjucifyaugmentapps call graphs and reveal previously unreachable java methods?
toassesstowhatextentcall graphsareaugmentedby jucify we appliedit on twosets ofandroidapps 1000benign apps 1000malware.notethatweonlyselectedappsthatcontainatleast one.sofile.theresultsreportedconcernappsforwhichjucify succeededtomakecall graphchanges.thereasonsforwhichthere are apps without changes is related to the absence of bytecode tonativelinks i.e.
for559goodwareand384malware and orjucify reaching the 1h timeout i.e.
for goodware and malware .
number of nodes and edges in call graphs we first report the average number of nodes i.e.
the number of methods and edges i.e.
the number of potential invocations in the call graphs obtained before and after having applied jucify.
thecall graphaugmentationsbroughtbyjucifyarevisiblein table4.column appsrepresentsthenumberofappsforwhich jucify made callgraphchanges i.e.
theydid not reach the timeout andcontainedbytecode nativelinks.wenoticethatabouthalfof theapps call graphsareimpactedbyjucify 426and565forgoodwareandmalwarerespectively .wethennoticethatthenumber ofnodesandedgesaddedbyjucifyishigherforgoodwarethan formalware vs.197onaverageperapp fornodes and778vs.
for edges.
this shows that classical static analyzers that do not take into account the native code overlook a significant amount of nodes and edges in their call graph.
before jucify after jucify difference apps nodes edges nodes edges added nodes added edges goodware .
.
malware565 .
.
table average numbers of nodes and edges before and after jucify on goodware and malware numberofbinaryfunctionsintheaugmentedcall graph newlyaddednodescanbeexplainedbythebinaryfunctions i.e.
functionsinthenativecodepart thatarenowconsideredinthe unifiedcallgraphyieldedbyjucify.figure4detailsthedistributionsofthenumberofbinaryfunctionsforbothdatasets.wenotice thatbenignappstendtohavemoreaddedbinaryfunctionnodes median and mean .
in the call graph than malicious apps median andmean .
.bothdistributionsaresignificantly different as confirmed by a mann whitney wilcoxon mww test significance level set at .
.
ppexbsf.bmxbsf figure distribution of the number of binary functions nodes in benign and malicious android apps numberofbytecode to nativecall graphedges newlycreated edges can originate from nativefunction invocations in bytecode methods i.e.
entry invocations .
we compute the number of bytecode to native edges in apps call graph and detail theirdistributions over our datasets in figure .
the difference between malwareandgoodwareissignificant withamedianequalto14for malwareand8forgoodware.overall jucifyrevealsatotalof bytecode to nativeinvocationsinthemalwaredatasetand in the goodware dataset.
ppexbsf.bmxbsf figure distribution of the number of bytecode to native edges in benign and malicious android apps numberofnative to bytecodecall graphedges newlyadded edges can also originate from bytecode methods invoked in nativefunctions i.e.
exitinvocationswithreflection likemechanisms as explained in section .
.
.
the median of number of edges is significantlylowforbothgoodwareandmalware.indeed themedian of native to bytecode edges is equal to for both datasets the distribution is available in figure .
overall jucify reveals a total of261native to bytecodeinvocationsintheentiregoodwareset and in the malware set.
the conclusion that can be drawn from these results is the following thelownumbersofnative to bytecodeedgesingoodwareshows thatbenignappsmakelittleuseofreflection likemechanismsto invoke java methods from native code compared to malware.
ppexbsf.bmxbsf figure distribution of the number of native to bytecode edges in benign and malicious android apps newpreviouslyunreachablebytecodemethods byconsideringnativecode jucifycanrevealpreviouslyunreachablebytecode methods that are now reachable because called from the nativepart .thenumberofpreviouslyunreachablebytecodemethodsishighlylinkedtothenumberofnative to bytecodecall graph edgesdiscussedinthepreviousparagraph.however anewedge fromnativetobytecodecansimplyendtoapreviouslyreachable node whichdoesnotpresentaninteresthere.indeed newlyreachablenodesareinterestingsincetheyallowstaticanalyzerstonot consider them as dead code anymore.
in section .
we give a concrete example of the importance of this metric.
overall jucifycanreveal 34previouslyunreachablebytecode methods in benign apps with a maximum of for one given app .
for malicious apps jucify reveals 122previously unreachable bytecode methods called from native code in apps.
this accountsfor13 ofnative to bytecodeinvocationingoodwareand .
formalware.thissuggeststhatinmostcaseswhenandroid app developers invoke bytecode methods from native code it is to trigger bytecode methods that are already reachable from the bytecode.however thisshowsthatanon negligeableproportion of bytecodeinvocation from the nativein goodware and malware are overlooked by classical static analyzers since they account for non reachable nodes in original bytecode callgraph.
goodware vs. malware native bytecode calls tobetterunderstand the difference between goodware and malware we inspected the native functions invoked from the bytecode and the 1239bytecodemethodsinvokedfromthenativecode.resultsindicate thatin82.
ofthecases thenativefunction java mono android runtime register isinvokedfromthebytecodeingoodware.in fact most of the top invoked native functions in goodware are from the monoframework which is used by xamarin .
the samemethodis however notfoundinthemalwaredataset.the top invoked native functions in malware is composed of different elements such as java com seleuco mame4all emulator setpaddata java com shunpay210 sdk cppadapter210 pay or more suspicious functions java iqqxf tzfff ggior andjava glrrx efgnp twcjn .
from native to bytecode we note some interesting insights while benign apps invoke from the native code in the majority ofcases bytecodemethodslike context.getpackagename .
orthreadlocal.get .
maliciousappsinvokemethodssuchas telephonymanager.getdeviceid .
ortelephonymanager.
getsubscriberid .
which can indicate suspicious behaviors.
ourresultsbecomemoreconvincingbyfocusingonbytecode methodsthatwerepreviouslyunreachableincall graphsandcalled fromnativecode.whilemostofthebytecodemethodsthatwere previouslyunreachableandcalled inthenativecodeingoodware aremonoframework methods in malware the situation is different.
indeed the most used bytecode methods in native code are dedicatedtopaymentlibraries e.g.
com.shunpay208.sdk.shunpay208 and sensitive methods such as getdeviceid .
rq4.a answer jucify helps to discover new paths in app behaviour.itaugmentscall graphswithabout5 newnodesin bothbenignandmalwareapps.overall appstendtousemuch more bytecode to native invocations than native to bytecode.
however malwareseemstousebytecodeinvocationsfromnative to perform suspicious activities.
.
.
rq4.b canjucifyrevealpreviouslyunreachablesensitivedata leaks that pass through native code in real world apps?
withthisrq ourgoalistoassessjucifyfromaqualitativepoint ofview.inparticular wecheckwhetherthecall graphsaugmented by jucify with previously unseen nodes are relevant.
to that end we run jucify and flowdroid on real world apps to check if flowdroidcandetectsensitivedataleaksthroughthenativecode.
experimental setup to assess jucify in the wild we selected malicious applications since the intuition is that malicious apps tend to leak sensitive data more than goodware.
therefore we randomly selected 1800malicious apps i.e.
virustotal score fromandrozoo thatcontain.sofiles.besides todetectdataleaks weusedthedefaultsourcesandsinksprovidedbyflowdroid.for each of these 1800apps we set a hour timeout min for the symbolic execution and min for flowdroid .
findings among the 1800malicious apps 1460contained java native methods declaration s in the code.
in total jucify was abletoaugmentthecall graphof i.e.
ofthe 1460apps that contain both .so files and java native method declaration in bytecode.
from these 1460apps flowdroid revealed sensitive data leaks that take advantage of the native code in apps.
these apps were manually checked and confirmed to contain sensitivedataleaksthatgoesthroughthenativecode.notethatthisnumber is highly linked to the source and sink methods used.
in the following we discuss two case studies where jucify was able to reveal sensitive data leaks that pass through native code.
both android apps were manually checked by the authors to confirm the presence of a leak detected by flowdroid.
.
.
getter scenario case study.
in figure 3a we illustrated an exampleofhowmalwaredeveloperscanrelyonnativecodetohide from static analyzers the retrievalof sensitive data from static analyzers.jucifyrevealedanandroidmalware2implementingthis specificbehavior.jucifyreconstructedthe a nativemethodfrom thecom.yclass as the following dummybinaryclass java .lang.string java com y a android.content.context .in this native function the imei number of the device is obtained via the jni interface and returned as a result.
this reconstructed method is called in method b of classcom.cance.b.q to store the imei number.
the resulting imei number is then wrapped and transferred to a method to log it.
after examining the virustotal report of this app we found that the flags raised by antiviruses refer to trojan behavior and explicitlymentiontheretrievalofsensitiveinformationfromthe deviceaswellastheuseofnativecodeintheimplementationof the malicious behaviour.
to some extent this corroborates that jucifycontributedtouncoveramaliciousbehaviourthatishidden through exploiting native to bytecode links which state of the art static analyzers could not be aware of .
.
.
leaker scenariocasestudy.
infigure3b weillustratedhow app developers can rely on native code to hide the leakageof sensitivedata.jucifyrevealedanandroidmalware3withthisbehavior.
first theimeinumberisobtainedinthe getoperator method of thecom.umeng.adutils.appconnect class and stored in the imeifield of the same class.
then in the processreplymsg method of this class method which is triggered when an sms isreceived theimeinumberiswrappedinanotherstringandsent to the native method stringfromjni as a parameter.
jucify s instrumentation engine constructed the following method from this native method dummybinaryclass java.lang.string java com umeng adutils sdkutils stringfromjni android.
app.pendingintent java.lang.string java.lang.string .
thislatterhasbeenpopulatedwiththeinformationgivenbythe symbolicexecutionandrevealedthatthe sendtextmessage methodfromthe android.telephony.smsmanager classiscalledwith the valued derived from the imei number as parameter.
tosummarize avaluederivedfromtheimeinumberissentout of the device using an sms through the native code.
so the leak would have remained undetected without jucify.
asinthepreviouscasestudy weexaminedthevirustotalreport of this app.
in their majority antiviruses flag it as a trojan app.
some reports even explicit tag the use of getdeviceid and of native code for the malicious operations.
thus with jucify we enabled an existing analyzer to uncover a leak being performed through native code.
2sha 54dafdf3635b18c0fd9f5ce89fe14c072d75ab4687b376fbadf370388574dc14 3sha a0b7bfbc272b462a2f59cc09acc8b75114137cf7a2b391201c14c1a90ea7e369 1240rq4.b answer jucify is effective for highlighting data flows across native code that were previously unseen.
indeed its enhanced call graphs enable static analysers to reveal sensitive data leaks within real world android apps.
limitations our approach is a step towards realizing the ambition offull code unification for android static analysis.
our current prototype of jucify despitepromisingperformances presentsafewlimitations first ourimplementationreliesonexistingtoolstoextractnative call graphsandmutualinvocationsbetweenbytecodeandnative code.limitationsofthesetoolsarethereforecarriedovertojucify.
suchlimitationsincludetheexponentialanalysistimeforsymbolic execution thelimitationinfindingtheboundariesofnativefunctions theunsoundnessinappmodelingwithflowdroiddueto reflectivecalls multi threading anddynamicloading .
second our prototype currently relies on symbolic execution whichisknowntobenon scalableinthegeneralcase.therefore as describedinsection4.
.
thecall graphofsomeandroidappswas notaugmentedduetothesymbolicexecutionthatdidnotreturn native bytecode links and or due to the timeout.
third a major limitation of jucify lies in the fact that it does notyetreconstructnativefunctionsbehaviorwithhighprecision.
indeed as described in section .
for the native functions that represent java native function jucify considers a partial list of statements it employs opaque predicates to guide static analyzers into considering every possible path during analyses.
moreover jucifyoverlooksnativefunctionsthatarenotexplicitlytargeted by jni java calls since it cannot approximate their behavior in the current implementation.
as a result jucify cannot generate nativefunctions controlflowgraphswithjimplestatementsthat cover the full behavior of functions.
this limitation implies that if for instance a leak is performed by using internet communication implemented purely inc e.g.
withasocket thenthisleakwould notbedetectedwithflowdroidevenafterjucifyprocessing.also duringthereconstructionphasedescribedinsection3.
in some cases where the number of parameter is important the number ofparametercombinationcanexplode.thiscanleadtomethods beingextremelylongthatmightnotrepresentreality.weplanto address this limitation in future work.
threats to validity manual checking.
to check the correctness of the results we manually checked a hundred android apps.
to do so we relied on java bytecode decompilers and native code decompilers such as jadx and retdec .
although native code manual checking ischallenging wewereabletoconfirmthatthenativenodesadded byjucifymatchedthenodesfromthenativecallgraphconstructed bynativediscloser.regardingbytecode to nativelinks asthe symbolswerealwaysavailablefortheappswechecked sincenative methods were statically registered we were able to confirm the correctness of those links in the callgraph generated by jucify.
we reverse engineered these apps and were able to reach the same conclusions.regardingnative to bytecodelinks themethodnames arerepresentedasstrings whicharenotdirectlyavailableinthe nativecode.therefore wefacedachallengetocheckifthesymbolicexecution yielded correct links.
one way to verify would be to executethecodeparttotriggerthenativecodeandensurethatthe correct information are yielded by nativediscloser but this is a challengeperseanditisoutofthescopeof thisstudy.therefore we made the hypothesis that the symbolic yields correct results.
related work staticanalysisofandroidapps.
staticanalysisofandroidapps iswidelyexploredtoassessappproperties.lessthan10yearsafter theintroductionofandroid asystematicliteraturereview has shownthatoveronehundredpaperspresentedstaticapproaches to analyze android apps.
the review highlights that android apps security vetting is one of the main concerns for analysts who assess properties such as sensitive data leak detection or check for maliciousness .
static approaches have alsobeenimplementedtoidentifyfunctionalandnon functional defects and towards fixing runtime crashes .
static analysis is also further leveraged to collect information in apps towards improving dynamic testing approaches .
given these fundamental usages of static analysis it is essential totakeintoaccountallcodethatimplementsanypartoftheapp behavior.
therefore the fact that many analyses are reduced to focus on the bytecode while leaving out native code within app packages constitutes a severe threat to validity in many studies.
binary analysis.
binary analysis techniques have been applied for different platforms using static dynamic hybrid and machine learning based approaches.
a recent work tackles the challenging task of analyzing binaries by combining declarative static analysis usingdatalogdeclarativelogic basedprogramminglanguage with reverse engineering techniques to perform x refs analysis in native libraries using radare2 .
in the android realm analysis of binaries can be essential to cope with obfuscation .
cross languageanalysis.
severalresearchershavealsoacknowledged the presence of native code alongside bytecode in their analysisofandroidapps.forinstance in2016 alametal.
presented droidnative which can perform android malware detection considering both the bytecode and the native code.
ndroid and taintart were proposed for dynamic taint analysis to track sensitive information flowing through jni.
jn saf is also proposed as an inter language static analysis framework to detect sensitive data leaks in android apps taking into account native code.alltheaforementionedtools however aretask specific.they also typically perform their analyses separately for bytecode and nativecode andlaterpost processandmergetheoutputstopresent unifiedanalysisresults.incontrast jucifyproposestounifythe representation before task specific analyses.
this enables other analysestobebuiltupontheoutputof jucify.forexperimental assessment of jucify representation for data flow analysis rq5 weenvisionedacomparisonwithjn saf.unfortunately two co authors independently failed to run the tool.
overall therearevariousapproachesandstudies in the literature that investigate the possibility to analyze apps by accountforthedifferentlanguage specificartifactsinthepackage.although the approaches described are promising for cross language analysis they do not generally offer a practical framework to unify 1241the representation of both the bytecode and the native code into a single model that standard static analysis pipelines can leverage.
our prototype jucify does bring such a unified model and targets thejimpleintermediaterepresentation whichisthedefaultinternal representation of soot.
therefore by pushing in this research direction weexpecttoprovidethecommunitywithareadilyusable framework whichwillallowto re performtheiranalysesonwhole code in android apps.
conclusion wecontributeintheambitiousresearchagendaofunifyingbytecodeandnativecodetosupportcomprehensivestaticanalysisof androidapps.wepresentedjucify asasignificantsteptowards thisunification itgeneratesanativecall graphthatismergedwith thebytecodecall graphbasedonlinksretrievedviasymbolicexecution.inthismodel i.e.
theunifiedcall graph weareableto heuristicallypopulatespecificnativefunctionswithjimplestatements.thejimpleintermediaterepresentationwasselectedtoreadily support existing static analysers based on the soot framework.
we first empirically showed that jucify significantly improves android apps call graphs which are augmented to include native code nodes and enhanced to reveal pre viously unreachable methods .
then we showed that jucify holds its promise in supporting state of the artanalyzerssuchasflowdroidinenhancingtheir tainttrackinganalysis.finally wediscusshowjucifycanreveal sensitive data leaks that pass through the native code in real world android apps which were previously undetectable.
data availability for the sake of open science we provide to the community all the artifacts used in our study.
in particular we make available the datasets used for our experimentations the source code of jucify the jucify executable and our benchmark apps.
all artifacts code benchmarks results are available at acknowledgment thisworkwaspartlysupported bytheluxembourgnational research fund fnr under projects reprocess c21 is the afr grant by the sparta project which has receivedfundingfromtheeuropeanunion shorizon2020research and innovation program under grant agreement no by the natural project which has received funding from the europeanresearchcouncilundertheeuropeanunion shorizon research and innovation programme grant n and by the inter mobility project sleepless seattle no .