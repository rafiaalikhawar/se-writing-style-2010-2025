do this!
do that!
and nothing will happen do specifications lead to securely stored passwords?
joseph hallett nikhil patnaik benjamin shreeve and awais rashid university of bristol abstract does the act of writing a specification how the code should behave for a piece of security sensitive code lead to developers producing more secure code?
we asked developers to write a snippet of code to store a password half of them were asked to write down a specification of how the code should behave before writing the program the other half were asked to write the code but without being prompted to write a specification first.
we find that explicitly prompting developers to write a specification has a small positive effect on the security of password storage approaches implemented.
however developers often fail to store passwords securely despite claiming to be confident and knowledgeable in their approaches and despite considering an appropriate range of threats.
we find a need for developer centered usable mechanisms for telling developers how to store passwords lists of what they must do are not working.
i. i ntroduction developers struggle to store passwords securely.
naiakshina et al.
have repeatedly shown that developers do not build in security unless explicitly asked to do so and even then typically do so poorly .
in organizations one can support developers coding securely through code review and acceptance testing but not all developers work in teams and many work alone on their own projects .
developers continue to seek guidance on how to handle passwords.
in a survey of developers posts on stack overflow a popular developer question and answer site barua et al.
found that posts related to authentication and security including password storage and were one of the top topics on the site and accounted for .
of all questions .
furthermore in a survey of just security focussed posts on stack overflow yang et al.
found that the most viewed of all security focussed posts related to passwords with each post viewed on average times.
whilst there are alternatives to passwords many developers still appear to be working with passwords and implementing password storage in their apps and software.
as well as working with passwords they are seeking guidance on how to do it right .
it is well established that writing a specification before implementing it leads to code that is of a higher quality .
since specification writing is beneficial for quality does the act of writing one also improve developers security practices?
naiakshina s work suggests that developers only consider security aspects if explicitly prompted but if we try to continuously prompt developers towork securely we risk security fatigue .
since the quote in the title is attributed to harry s. truman and is used as the opening quote to chapter in the mythical man month .specification is an established developer practice this paper seeks to explore whether the act of writing any form of specification primes developers to program securely in other words whether giving developers time to make a plan however formally or informally leads them to either recalling more about how to store passwords or to recall that a standard exists and to check.
to test this we recruited developers from an online platform for recruiting participants for studies and asked them to write code to store a password in whatever language they were most comfortable with.
half the developers were asked to write down a specification any form of specification from a formal definition to a prose description of how they would implement this before they were allowed to write their solution the rest were allowed to write their implementation immediately.
we scored the security of their implementations using naiakshina s end user password storage criteria figure which is itself based on nist sp and analyzed their written justifications of their choices and threats considered.
specifically we address the following research questions rq1 does specification writing lead to a measurable improvement in password storage method?
rq2 what approaches do developers take when implementing password storage and what do they typically remember and forget?
rq3 how do developers justify their implementation approach and what threats do they consider?
our key findings are as follows developers who were explicitly prompted to write a specification stored their passwords slightly more securely than those who were not prompted p rrb .
only of developers remembered to hash passwords remembered to salt them but other secure password storage practice was largely absent figure .
developers think they are storing passwords correctly but their scores according to naiakshina s criteria figure do not indicate best practice.
if given time to reflect some developers do realize that there are threats to stored passwords and that their solutions may not be secure.
our novel insights are in examining whether specification is a useful tool for priming for security related tasks and how developers justify the code they write and the threats they consider with respect to the specifications they write.
ieee acm 43rd international conference on software engineering icse .
ieee the end user password is salted and hashed .
the derived length of the hash is at least bits long .
the iteration count for key stretching is at least .
or for pbkdf2 and at least 210for bcrypt .
a memory hard hashing function is used .
the salt value is generated randomly .
the salt is at least bits in length .
fig.
.
naiakshina s end user password storage assessment criteria copied verbatim.
a score 6indicates industrial best practice.
analyzing the developer s rationale suggests that whilst some developers consider appropriate threats their knowledge of best practice is out of date and that current cryptographic guidelines .
providing lists of what developers must do is not working.
instead we must fit the task to the developer and provide usable mechanisms for password storage.
ii.
b ackground and related work a. benefits of specification the benefits of program specification are well established in both the academic and engineering communities.
spolsky notes their benefit saying if you don t have a spec you will always spend more time and create lower quality code.
brooks jr. also notes the benefit of a specification careful function definition careful specification and the disciplined exorcism of frills of function and flights of technique all reduce the number of system bugs that have to be found.
dromey suggested that quality models and requirements specifications could lead to an improvement in software quality .
haigh and landwehr have suggested that by building code to security specifications drawing analogy to us building codes we can reduce the vulnerability in software systems .
polikarpova et al.
found that twice as many bugs were found when code was written with a strong specification .
mohanani et al.
however found that specifications can lead to developers blindly following them without considering why the rules exist .
our work seeks to demonstrate that the act of writing a specification creates an implicit priming effect that can impact a developer s approach to security.
b. work on password security there is a large body of work surrounding passwords but a small subset that addresses how developers perform password storage and present analysis of the process.
password storage is a feature generally supported by cryptographic libraries.
the usable security community has studied the developers interaction with the cryptographic apis.
naiakshina et al.
ran the first qualitative usability study to observe how computer science students address thetask of password storage .
they concluded that participants consider functionality before security.
unless participants are primed they do not think the task of password storage requires a secure solution.
on the other hand participants who were primed to consider security used various hash functions and different algorithms to secure their password.
for the participants who were primed none of their solutions met the academic standards of the time.
cryptographic frameworks offer password storage as an opt in feature.
this means the developers needs to understand cryptography to store passwords.
of the non primed participants attempted a secure solution for password storage while of the primed participants attempted a secure solution.
on asking the nonprimed students about the security oversight they replied that they would have implemented secure storage if they were writing code for a commercial product.
to address this insight naiakshina et al.
conducted a field study with freelance developers.
like students freelance developers do not consider security for password storage unless prompted.
both students and freelance developers have misconceptions about secure password storage however interestingly freelance developers show a wider range of these misconceptions.
freelance developers often stored passwords with base64 confusing encoding functions with hash functions a misconception they shared with end users.
naiakshina et al.
conclude that even when developers believe they are coding for companies they seldom store the password securely without prompting .
acar et al.
conducted an experiment with github developers to establish if they are an accurate representation of developers in general for security based developer studies.
the github developers were asked to perform password storage securely.
the solutions included the storage of plain text passwords use of static salts use of unsafe hashing algorithms .
our work goes beyond acar et al.
s and naiakshina et al.
s work by examining developer s rationale for their password storage implementations and finds that whilst developers aren t storing passwords securely they think they re following best practices.
oesch et al.
evaluated popular password managers and their solutions for handling the main stages of a password s life cycle password generation storage and auto fill.
their evaluation of password storage showed that developers stored information in plain text left metadata unencrypted and used insecure defaults .
our work compliments this by diving deeper into why developers do not engage with best practice.
there is a large body of work on end user passwords and their security .
in contrast our work focuses on developer s approaches to storing passwords.
c. work on secure programming weir et al.
looked at the prevalence of security assurance techniques including threat assessment and code review among android developers .
they found that between only of android developers used these techniques despite a high perceived need for security.
we found that of developers claimed to write a specification without prompting.
fischer et al.
examined the amount of code copied from stackoverflow and its security .
they found that of android apps contained vulnerable code copied from stackoverflow.
we found that of developers copied from stackoverflow specifically but that a further copied from other online sources.
many vulnerabilities arise due to developers misusing cryptographic libraries.
nadi et al.
performed an empirical investigation into challenges developers face when using java cryptographic apis.
based on the analysis of stack overflow posts github repositories and a survey of developers they found that developers find cryptographic features such as encryption and digital signatures difficult to program.
they also found that apis are generally perceived to be too low level for developers .
egele et al.
studied the integration of cryptographic apis in android applications.
they found errors in of the applications.
cryptolint was introduced as a static analysis tool to find these errors .
patnaik et al.
performed a thematic analysis of stack overflow posts from developers seeking help with using cryptographic libraries and found usability issues that could be related to green and smith s earlier work that proposes usability principles for cryptographic apis.
show that developers find cryptographic apis challenging to use.
we find that as well as struggling with apis developers are not clear on what they need to do to store passwords securely following current guidelines .
iii.
m ethod we used a between subjects design to explore whether the act of specification writing results in more secure code being produced.
a. study design to test the effect specification writing had on implementation we designed a study where developers would implement the part of an app s code for storing passwords.
we chose password storage as a task as it is security relevant implementable within a relatively short space of time and is a common task with plenty of guidance available that most developers would have encountered in their work.
our study was implemented as a set of online tasks and questions to capture rationale .
developers were randomly assigned a grouping either specification orno specification and shown the following scenario you are working on the backend of an application.
users create an account on the app and login before being allowed to use the program.
the application is complete bar one task writing the login system users use to authenticate with the app.
you have been tasked with implementing this part of the app.
you decide to start with storing the users passwords.
your boss trusts your judgment when it comes to implementing this feature.developers in the specification group were then asked to write a specification for how the password should be stored.
you decide to start by writing a specification for how the password should be stored and to note down any special requirements and implementation details.
you are provided with a username and password and they have been checked to see that they are valid text.
describe your specification below.
you can describe your specification using formal notation informal notes a list mathematical notation or any other method.
if you draw a picture as part of your specification please say so and say what is shown.
both groups were then asked to implement the password storage using whichever language they wished.
if they used a real programming language they were asked to note it.
you start writing the password storage method.
you have been given the password the user wishes to use and you need to store it so that it can be checked whenever users try and login.
you are given a username and password.
both have been checked to be valid text i.e.
neither empty nor containing bad characters write code or pseudocode to implement the password storage.
your code doesn t need to be compilable or syntactically correct but should illustrate your general approach to the implementation.
developers in the no specification group were then asked if they had made some form of specification or plan before starting their implementation without being asked to .
those that indicated that they did were asked to describe their specification and their results were added to those of the specification group.
both groups were then asked to provide a rational for their coding approach in a free text box.
they were asked if they considered what threats might attack a stored password and whether they referred to any standards for password storage when implementing the code.
finally participants were asked whether they had any formal qualifications in software engineering or computer science and to rate their knowledge of security and cryptography on a point likert scale and briefly describe their security and development experience.
b. analysis to analyze the data we scored each of their implementations using naiakshina s metric and compared the average score between different groups using the mann whitney utest a rank based non parametric test to explore if two groups are distinct to test for significance and to calculate the effect sizes using the rank biserial correlation .
to analyze developer s rationale and threat models we asked developers to describe them and analyzed them qualitatively using a grounded theory approach .
c. recruitment and ethics developers were recruited from prolific academic and were screened by prolific based on their familiarity with computer 488programming.
developers were offered a financial reward for completing the study of inline with the living wage in our country.
all developers who completed the study were paid for their work.
ethical approval for the study was sought from and granted by bristol university.
no personal data was collected and demographic data was deleted after coding and validation.
data is available by request.
d. limitations and threats to validity we acknowledge the following limitations and threats to our study our developers were recruited by prolific academic and as such may not be representative of how developers as a whole behave.
other studies have also used similar populations for studying passwords and developers .
developers may not know how to store a password and may not be aware that it is a security related task.
we mitigate this by qualitatively analyzing the developers rationale behind their code.
developers who were not prompted to write a specification may opt to write a specification anyway.
to correct for this we asked developers not in the specification group if they wrote a specification after their implementation.
we assume that the specification produced by the unprompted group is similar to the prompted group and we ask them to describe it but this may not be the case and some participants may retrospectively write a specification.
we ask the developers about their qualifications and experience however all data is self reported and may not be accurate.
we asked developers to implement password storage and developers did so.
developers instead appeared to write code implementing password authentication how one would check if a password was correct but from which their approach to password storage could be seen.
a further developers stored the password but did so only checking if the password contained a suitable range of letters numbers and symbols approached the problem by retransmitting their passwords over http1 and insisted the passwords be stored alphabetically .
we include all in our analysis as they were all conceivably ways a developer may approach storing passwords.
scoring implementations according to naiakshina s criteria could introduce subjectivity.
to mitigate this one author scored and then another author independently rescored all the implementations and calculated cohen s kappa a measure of inter rater reliability .
the kappa value indicates almost perfect agreement .
similarly our codebooks whilst grounded in data were likely influenced by the coder s background and experiences.
using our codebooks a separate coder independently re coded the entire 1three appeared to have copied the question from com questions password storage in code how to make it safe.dataset.
we found substantial agreement with our coding for developers explanations for their implementations table vi and almost perfect agreement with our coding for the threats developers considered.
we measure developers password storage approaches using naiakshina s criteria but this poses a construct validity threat.
we chose this metric as it has been used in prior work and on a nist standard for password storage .
we mitigate this threat by qualitatively analyzing why developers wrote the code they did as well as their implementations.
iv.
q uantitative results table iii reports how the teams scored against naiakshina s criteria figure .
in our sample only developers produced outputs that fulfilled at least one part of naiakshina s criteria.
the most common criterion fulfilled was that of hashing data demonstrated by of participants who scored a point of overall sample .
just under of the developers who scored a point used a random salt or an appropriate hash length overall and the remainder of the points in naiakshina s criteria were awarded rarely.
a. rq1 do specifications lead to securely stored passwords?
developers prompted for a specification n scored better than those that were unprompted n a comparison by mann whitney usuggests that this is a significant difference p u but with only a small effect size rank biserial coefficient rrb .
there remains a significant difference in performance if we omit the subset of the unprompted group who reported writing a specification without being asked to prompted participants n in contrast to developers who did not write a specification n .
the two groups are distinct mann whitney u p but the effect size remains small rrb .
however a comparison between all participants who wrote a specification prompted or not n and those who did not write a specification n is not statistically significant p u rrb .
this could be explained by developers in the unprompted specification group those who were not asked to write a spec but who claimed to have written one anyway actually writing their spec after their implementation in response to us asking if they had written one beforehand.
this theory is supported by table ii where we found no significant difference between the unprompted specification and the group that claimed not to write a specification p .
the distribution of scores is given in table i. of developers did not store a password in any meaningfully secure way a score of and no developer obtained a perfect score of using naiakshina s metric although two developers did meet the score indicating best practice a score of both were in the prompted specification group .
of the developers whom we did not prompt to write a specification claimed to write one anyway unprompted 489table i distribution of scores for password storage methods by different groups .
absolute values are given in parentheses .
t he specification group consists of two subgroups those that we explicitly prompted for a specification and those that we did not prompt but reported writing one unprompted .
a score of 6or more is considered to be following best practice .
group count specification .
.
prompted specification .
.
unprompted specification .
.
unprompted .
.
no specification .
.
used standard .
.
no standard .
.
formally qualified .
.
not formally qualified .
.
overall .
.
table ii comparison between groups using the mann whitney utest .
group group u p r rb prompted specification unprompted .
.
specification all no specification .
.
prompted specification no specification .
.
unprompted specification no specification .
.
used standard no standard .
.
formal qualification no qualification .
.
table iii frequency different points in naiakshina s criteria were observed compared to the whole population .
no answer scored a half point for key stretching .
a bsolute values .
criteria observations hashed salted hash length key stretching memory hard hashing random salt salt length of developers reported referring to some kind of standard or guide when writing their password storage method claimed some formal software engineering qualification.
finding examining the rank biserial correlation rrb to the scores themselves in table i suggests that whilst forcing developers to write a specification before coding will lead to more secure password storage approaches p it isn t going to make a huge difference developers might remember to hash them or to add salt but will still leave them stored insecurely.
b. so what else has an effect?
if the act of forcing developers to write a specification only has a small impact on their ability to store passwords securely then do we find anything else having an effect?table iv co occurrences of points in naiakshina s criteria i.e.
of all participants who hashed their password also salted their passwords .
a bsolute values .hashed salted hash length key stretching memor y hard random salt saltlength hashed36 salted100 hash length100 key stretching100 memory hard100 random salt100 salt length100 table v observations of specific hashing methods used by developers .
some developers recommended multiple hashing methods .
hash observations encryption aes md5 sha1 sha256 sha512 base64 custom cipher bcrypt pbkdf2 argon2 insecure method secure method 490participants reported their familiarity with cryptography on a point likert scale.
there is a small positive relationship between reported cryptography experience and score spearmans rho s p with most developers reporting that they had little to no experience no experience little experience moderate experience very experienced extremely experienced .
this is in contrast to the findings of hazhirpasand et al.
who found no significant relationship between developer experience and their ability to use a cryptography api though hazhirpasand et al.
rated developer experience on the basis of activity on github as opposed to a self reported value.
we did not find a significant relationship between developers who had a formal software engineering qualification and those who did not p .
participants who reported using a standard to inform their code implementation scored better than those who used no standard but not significantly p .
c. rq2 what did developers do?
our observations of hashing and salting rates are broadly inline with what naiakshina et al.
observed where an overall of developers hashed passwords and also salted them however naiakshina et al.
s study explicitly primed half of their developers by asking them to store them security and only the primed groups hashed or salted their passwords.
in contrast in our findings we observe similar rates over all participants.
in our study we asked developers to provide code in any programming language including pseudocode.
most developers described their implementation in these terms using functions called hash and appending salts however some gave specific methods for storing their passwords.
table v shows the specific methods we encountered for hashing passwords.
many developers recommended hash functions that were inappropriate for password storage2 including md5 the sha family and a substitution cipher.
other developers recommended encryption which is unsuitable for password storage or even using base64.
of all the developers who stored their passwords hashed used an inappropriate hashing method and only recommended a secure modern password hash.
one developer recommended both a secure and insecure method ...hash password in bcrypt or md5... scored finding only a third of developers wrote code to store their passwords hashed.
of those developers recommended an insecure hash function and only recommended a secure hash function.
the remaining did not specify the method they just hashed them.
of developers remembered to salt and hash their passwords.
more comprehensive security figure was rare.
2they are quick to calculate using little memory thus making them amenable to cracking unlike memory hard hashes such as pbkdf2.v.
rq3 w hy are developers storing passwords like this ?
after implementing their solutions we asked developers why they had used a particular approach.
two of the authors used a grounded theory approach to analyze the responses.
two passes were required to reach the point of theoretical saturation when no new codes were identified.
the resulting codebook and illustrative examples of each code is shown in table vi.
we also contrasted the distribution of codes in the prompted specification andno specification groups and found them to be broadly similar with the no specification group being slightly more likely to report they wrote their code the way they did because the implementation was easy.
consequently our remaining analysis of developers explores why they implemented password storage in the way they did and is over the entire study group.
we also asked the developers if they considered any threats when implementing their password storage solution?
threat modeling is a standard technique when designing for security that encourages developers to consider what defenses are needed to mitigate the potential threats to a system.
developers reported considering potential threats when implementing their password storage solution.
their responses were analyzed by one author again using a grounded theory approach .
two passes were required to reach the point of theoretical saturation when no new codes were identified.
the resulting codebook again with illustrative examples of each code is shown in table vii.
a. you either think you do know or you know you don t know our analysis of the reasons why developers implemented password storage in the ways they did reveal two interesting sub groups.
several answers appear to indicate that the developers thought they had stored the passwords properly the experience replication of previous efforts perceived best practice andtaken under advisement codes whereas others seemed to know that their implementation was limited and that they didn t know how to do it the na ve acknowledgment of limitations andonly way i know codes .
within the group who thought they knew how to store passwords developers indicated that they believed their approaches were best practice .
one developer stored the password directly into a database insert into users username password values user password password1 they explained this as because that is the best way to store the password yet their solution stores the passwords directly without hashing or salting they scored .
others stated this is most accepted way of storing passwords scored it s based on corporate best practices scored 491table vi codebook formed from the analysis of developers explanation of their implementation approach .
quotes are given to illustrate the use of all codes with relevant passages underlined .
some responses were assigned more than one code .
no more than 3codes were used to capture any single response .
code description count prompted spec no spec implementation ease the developer wrote it like that as the implementation would be simple because it was a simple but quite effective way to store .
to ensure that the data is secure the function that encrypts the password must be very good.
scored readability the developer focused on how understandable their code would be to a reader.
i wrote that way because it shows the idea very clearly .
the encryption code is a more difficult question and needs time and ideas to implement a good encryption.
scored na ve the developer wrote the code in a literal manner without considering the merits of any other approaches.
because i don t know how to wrote code so just used a literal approach.
scored experience the developer made reference to their experience when describing how they wrote their code.
i m somewhat experienced in applied security and i consider the password should be stored securely considering the worst case possible.
scored replication of previous efforts the developer said they had done it like this before.
i wrote code like this because it is something i have done before.
i ve written a login system for a password manager so recognise that passwords before storage should always be hashed or encrypted to avoid storing them in plain text.
i used a struct mainly for storage purposes of this task but would normally use a database such as sql to store them after hashing.
scored feature justification the developer justified a specific feature of their implementation e.g.
ability to send password reminders .
this is a simple way to code and allow for a reminder to the recipient!
scored method justification the developer justified the structure of their code.
i used a utility class.
this class stores usernames and passwords in a map data structure and then provides functions for user registration and login.
scored acknowledgment of limitations the developer noted that their code has limitations and that it doesn t have a certain feature e.g.
it is insecure .
it assures the storage of password and allows to recover the password easily even if the security is not high.
scored perceived best practice the developer did it this way as this is the correct way to store a password or a standard way in their company.
this is most accepted way of storing passwords scored consideration of threats the developer considered a threat that might attack the code and explicitly attempted to mitigate that threat.
hashing passwords is a necessity storing passwords in plain text is a huge security concern and should never even be considered.
scored taken under advisement someone told them this was a good way to do it.
my friend who is into cybersecurity told me about this scored only way i know the developer indicates that this is the only way they knew how to complete the task.
that was the only way i knew to solve that problem scored 492table vii codebook from the analysis of developers responses to what threats did they consider when storing the passwords .
only developers who indicated that they had considered a threat s responses were analyzed .
quotes are given to illustrate the use of all codes with relevant passages underlined .
some responses were assigned more than one code .
no more than 4codes were used to capture any single response .
code description count prompted spec no spec access threat from unauthorized access to the database e.g.
leaks .
password leaks scored cracking threat from attacks on stored passwords e.g.
cracking or rainbow tables .
reverse the hash code but i think that is impossible because is unidirectional scored hacking threat from unspecified threat actors phishing or social engineering.
stealing them by a hacker hacked by an unknown user to steal information and data scored programming concerns.
the threat from vulnerabilities in their code e.g.
bugs sql injection sql injection unauthorized db access scored confidentiality concerns about making the stored passwords harder to see.
someone accessing the content that is not the main user.
if i used strings the password would be stored in strings until the garbage collector clears it and we cannot control when that happens.
scored malware threat from malware key loggers or network attacks.
someone tracing you with keylogger or maybe trojan horse scored reflection consideration of what they should have done and the security of their implementation.
since the good is quite simple i am not certain if the storage is secure .
scored wider context concerns about the wider impact of an insecurely stored password.
potential of a database dump hackers can just login if the passwords were stored in plain text with hashed passwords they would need to brute force the password.
failure to secure our users passwords could lead to them having their accounts on other platforms compromised too as users tend to reuse passwords.
scored insider threat threats from insiders who might have access to stored passwords.
the database being accessed by a 3rd party internal threat actors excepting those with access to the code for password storage scored developers indicated that they knew their answer was correct because they had done similar tasks before calling upon both their experience as well as previously written code because i wrote a user registration system in the past.
scored i m used to implementing similar login and authentication mechanisms in university projects and the thought process is always the same .
.
.
scored i wrote code like this because it is something i have done before.
i ve written a login system for a password manager so recognize that passwords before storage should always be hashed or encrypted to avoid storing them in plain text.. .
.
scored the relevant part of the code based on the login system for the password manager looked like user.username std cin.get user.password hashpassword std cin.get void hashpassword std string password cryptography algorithm to hash password preferably using a salt it hashed the password with a cryptography algorithm .
it would preferably use salt.
another developer told us that they had taken advice from someone they considered knowledgeable about cybersecurity my friend who is into cybersecurity told me about this scored yet the solution their friend supplied was mostly inadequate only showing signs of hashing with md5 .
string hashpass md5 password passworddatabase.put login password this group of developers appear to believe their answers are correct and that they are following best practice.
they indicate that code similar to what they wrote is in projects they ve implemented.
yet despite this there are many low scores.
one developer described their experience as i have been working as a software engineer for years and have developed authentication systems for our clients hundreds of times so have come to learn the best practices for so.
scored their score would suggest they have more to learn.
not all developers seemed to be so confident.
in contrast to the first group other developers gave explanations that suggest they are aware that they don t know how to store passwords properly or at least that their code had limitations.
for example one developer stated i don t have a lot of knowledge about password storaging.
.
.
scored their implementation hashed the password suggesting the developer was confused about the distinction between hashing andencryption string encpass anhashingfunction password myfile username endl myfile encpass endl they scored point using naiakshina s criteria for hashing the password.
another said i wrote the code that way since it s the only way i know how to check if the passwords are valid and the hashing storing bit because unhashed passwords are unsafe.
.
.
.
other methods could be used to encrypt the password but i ve heard hashing or md5 hashing is the most common.
scored the following two explanations came from developers who were in the top of highest scoring implementations according to naiakshina s criteria.
both acknowledge the security of their implementations and that it wasn t perfect it assures the storage of password and allows to recover the password easily even if the security is not high.
scored it was the simplest and easiest way i could think .
.
.
this way it protects most cases but of course a more elaborate with more defence lines is needed and the salt implementations is not very well done .
.
.
scored this group of developers form a counterpoint to the first group who think they know how to store passwords they know they don t know everything.
whilst directly comparing groups is hard the codes are not independent and emerge from what developers said a comparison of average score between themsuggests that neither group is storing passwords more securely comparison of mean score between the think they know and know they don t know groups 79vs0 .
in short roughly a third of developers appear to be overly confident in their knowledge of best practice in our study.
despite this their answers do indicate that developers are aware that password storage is an inherently security oriented task.
they know they should be storing passwords securely but plenty of them are overconfident and have misplaced assurance in what they do.
b. on reflection perhaps you know theacknowledgment of limitations code from table vi and thereflection code from table vii are interesting as they highlight when developers indicated that their implementation was lacking security aspects.
for example one developer remembered to use a hash function with a suitable length in their implementation.
when stating which threats they considered they note that they had forgotten to salt the password and why that was necessary .
.
.
.
thinking about it it might have been a good idea to concatenate some constant text at the end of the password so that whether the user uses the same password on two different attacked services cannot be determined simply by checking whether the hashes are identical.
scored others on reflection realized their solution was inadequate with respect to security .
both of the following developers stored their passwords directly as plain text scoring yet when asked to consider the threats they later seemed to realize that there were some they should have considered unfortunately i have not considered any threats but i know that the password should be encrypted.
scored actually i didn t consider them in the pseudo code but i assume there are some threats like brute hacking scored one developer stored their password directly but when considering threats gave a guide to storing them that would have scored at least the best security practice is not to store the password at all not even encrypted but to store the salted hash with a unique salt per password of the encrypted password.
scored whilst we did not prime developers for storing passwords securely as naiakshina did we still found that developers talked about the security of their implementation.
around half of the developers reported considering threats when implementing their solutions and some made reference to those threats when describing why they d implemented the code in the way that they did.
the threats described in table vii are reasonable the reason we hash and salt passwords is to ensure if the database is accessed illegally that the passwords cannot be trivially cracked .
this is hopeful it suggests developers may be learning that passwords and security are linked and that they should store them securely not if we want them to .
developers may not realize it immediately that passwords 494table viii sites apparently referenced by developers .
source count stackoverflow.com gist.github.com docs.microsoft.com simplecode121.blogspot.com happycoding.io pypi.org medium.com docs.python.org howto should be stored securely but if given time to reflect they do seem to make that connection.
even if a developer doesn t initially realize that password storage is a security oriented task by giving them time to reflect in complement with time to consider a specification some developers do realize that passwords must be stored securely.
c. google is your friend there is much guidance and advice online about how to store passwords on sites such as stack overflow for example .
when analyzing developers reasons and implementations we checked for copying from such sites.
we searched online to see if any of the implementations and pseudocode developers provided appeared online and found appearing on the stack overflow developer forum alongside others appearing on other websites table viii .
we found that developers appeared to have copied code from various sites shown in table viii with the majority having taken code directly from stack overflow.
of these reported using a standard.
the group that used the online source appeared to score significantly higher than the group whose source was unknown 19vs p though the effect size was relatively small u rrb however when reading the solutions online we noticed that some of the articles developers appeared to have copied from also contained guidance on how to store them near perfectly according to naiakshina s criteria .
one developer justified their answer as i wrote the code like this because it is good practice not to store a password in clear.
scored the solution appeared to have been taken from a how to site which described how to implement password storage with a variety of hashes and salts starting with md5 and ending with bcrypt and scrypt however the site went on to describe a solution at the end of the article that would have scored points losing the last point for only using instead of bits for the salt .another developer described their implementation as the first and foremost way to store passwords in your database is to have the plain text.. .
.
scored this came from a blog post .
the remainder states don t do this i can t emphasize strongly enough that you should never ever store passwords in plain text.
the article does describe how to store passwords using a hash and a randomly generated salt points yet again the developer only copied the insecure counter example at the start of the article.if we want developers to store passwords correctly then we need to make sure the code we want them to copy is immediately obvious.
that developers are copying code from online isn t of itself worrying if they copied the right solutions we might see secure password storage.
instead some developers seem to be copying online code using the articles to justify themselves but not reading the article all the way through.
vi.
d iscussion a. do specifications lead to securely stored passwords?
writing a specification has a small but positive effect on developers ability to store passwords securely.
yet in saying this we avoid the bigger issue that developers seem to really struggle with implementing password storage correctly.
in our study of developers failed to hash salt or add any security mechanism whatsoever.
our paper joins an ever growing body of work demonstrating that developers are struggling implementing password storage but our work also finds that it isn t just that developers struggle to use cryptography apis and it isn t just that developers don t know enough about cryptography to complete the task correctly developers stated that hashing passwords with md5 was best practice it isn t .
developers would forget about salting and say that s the way that they do it in their company.
they would claim cybersecurity expertise to have password storage code in production as reasons why their code is secure as reasons why their code follows best practice and yet they fall short.
our paper finds that specification is beneficial p but equally importantly it highlights that developers don t know that they re storing passwords insecurely.
b. beyond naiakshina s criteria in this study we measured developers ability to store passwords using naiakshina s criteria as a proxy for the nist sp standard which defines current best practice.
the criteria and standard itself is somewhat quizlike asking developers to remember cryptographic techniques like hashing and salting as well as arbitrary lengths and counts.
if developers do not know these requirements then they will not remember them.
so what then do we learn beyond the fact that developers do not seem to recall naiakshina s criteria?
an ideal specification might have listed the criteria in full as functional requirements but it might also have been as simple 495as store the password securely following nist sp .
yet none of the developers in our study made reference to any standard in their specifications.
developers seemed to know there was a best practice they ought to be following yet didn t appear to go look up what it actually was.
whether this generalizes and developers recollection of other standards is equally poor is a topic for future work.
whilst one good approach to implementing password storage is to do what the standard says another equally valid and arguably better aproach is to use a framework and let it do it for you.
webframeworks like django include password storage systems and in django s case explicitly reference nist password standards and can take care of passwords for developers.
again developers in our study did not appear to make use of frameworks like this so is it that developers are unaware of these features inside frameworks or did they choose not to use them?
perhaps given the seeming recalcitrance towards reading standards the resistance towards using frameworks and the confidence many displayed that they were in fact following best practice we might conclude that developers are over confident in their abilities.
why use a library when you can implement it yourself trivially?
why check the standard when you know already what best practice is?
developers seem to have learned not to roll their own crypto perhaps they should also consider avoiding rolling their own authentication in future too?
c. developers are still not the enemy we say that users and developers are not the enemy that we must not blame users or developers when an api or security interface is not designed for a human to be able to use correctly.
yet when we talk about password storage we present it as a list diktats that developers must implement to ensure they do the task correctly.
as we and others have shown developers cannot follow these instructions.
perhaps then instead of pointing out that developers can t store passwords and providing lists on what they must do we should fit the task to the human and provide alternative mechanisms for storing passwords correctly without having to remember what the current best practice actually is or understand the intricacies of various hashing schemes.
truman said of being the president he ll sit here and he ll say do this!
do that!
and nothing will happen and a comparison can be drawn to the security and cryptography communities we cannot keep sitting here saying hash this!
salt that!
and pointing at nist sp because truman was right nothing will happen .
we need to find usable mechanisms for password storage.
what might these mechanisms look like?
cryptography libraries such as google s tink are attempting to wrap cryptographic details so that developers can use cryptography without understanding what a hash really is .
there has been limited usability validation of such approaches however and further work documentation and exemplar code is needed to show whether this approach is effective.
alternatively some developers seemed to copy code from online sources ensuring that developers canfind the trivially find the right way to store passwords and that theright code is trivially available may also help developers without requiring them to understand the cryptographic details.
finally a different solution altogether may be to encourage developers not to store passwords at all and instead use federated identity management systems such as oauth .
whilst these systems can remove the need for some app developers to implement cryptography correctly they come with their own set of privacy and security gotchas and challenges we should be cautious that by recommending an alternative to passwords we are not replacing the challenge of storing a password with the challenge of implementing a federated authentication system.
work on privacy preserving federated identity management has helped to resolve some of the privacy challenges associated with federated identity management though these are yet to be widely adopted in practice.
explicitly prompting developers to write a specification does help improve the quality of password storage but developers are still mostly failing at password storage whilst still believing they are getting it right.
giving developers time to reflect helps them realize the limitations of their approach but until we have developer centered usable password storage methods the problem of poorly stored passwords isn t going away.
we can do better than saying do this!
do that!
and watching nothing happen.
vii.
c onclusion does the act of writing a specification how the code should behave for a piece of security sensitive code lead to developers producing more secure code?
in a statistical sense yes though the effect is small p rrb .
in a broader sense however we show that whilst writing a specification does help developers remember more of the conditions for secure password storage leaving this task to a memory exercise and hoping developers refer to a standard isn t working.
future work should examine and empirically evaluate alternative strategies for helping developers complete authentication tasks whether in the form of usable cryptography libraries privacy preserving federated identity schemes or alternative awareness schemes to diktats and standards.
additionally whilst this study looked to see ifany form of specification improved developers ability to store passwords correctly specific approaches whether that be software building codes requirements engineering or formal verification may yield more promising results.
finally in this study we saw developers struggling to remember how to do secure password storage but we may see similar results for other areas where knowledge of what the right thing to do is conveyed only through diktats and standards future work should examine whether this result is general or specific to password storage.
acknowledgment this research is supported in part by epsrc grant ep p011799 and the national cyber security centre.
496references r. e. neustadt presidential power .
new american library new york .
f. p. brooks jr. the mythical man month .
addison wesley ch.
.
passing the word.
a. naiakshina a. danilova c. tiefenau m. herzog s. dechand and m. smith why do developers get password storage wrong?
a qualitative usability study in proceedings of the acm sigsac conference on computer and communications security acm.
dallas tx acm pp.
.
a. naiakshina a. danilova c. tiefenau and m. smith deception task design in developer password studies exploring a student sample infourteenth symposium on usable privacy and security m. e. zurko and h. r. lipford eds.
baltimore md usenix association pp.
.
.
available soups2018 presentation naiakshina a. naiakshina a. danilova e. gerlitz e. von zezschwitz and m. smith if you want i can store the encrypted password a password storage field study with freelance developers in proceedings of the chi conference on human factors in computing systems s. a. brewster g. fitzpatrick a. l. cox and v .
kostakos eds.
glasgow scotland acm p. .
.
available a. n. meyer t. zimmermann and t. fritz characterizing software developers by perceptions of productivity in acm ieee international symposium on empirical software engineering and measurement a. bener b. turhan and s. biffl eds.
toronto on canada ieee computer society pp.
.
.
available d. van der linden p. anthonysamy b. nuseibeh t. t. tun m. petre m. levine j. towse and a. rashid schr odinger s security opening the box on app developers security rationale in 42nd international conference on software engineering icse .
a. barua s. w. thomas and a. e. hassan what are developers talking about?
an analysis of topics and trends in stack overflow empirical software engineering vol.
no.
pp.
.
x. l. yang d. lo x. xia z. y .
wan and j. l. sun what security questions do developers ask?
a large scale study of stack overflow posts journal of computer science and technology vol.
no.
pp.
.
d. hardt et al.
the oauth .
authorization framework rfc tech.
rep. .
b. w. boehm verifying and validating software requirements and design specifications ieee software vol.
no.
p. .
d. l. parnas a technique for software module specification with examples communications of the acm vol.
no.
pp.
.
j. spolsky the joel test steps to better code in joel on software .
springer pp.
.
t. demarco structure analysis and system specification in pioneers and their contributions to software engineering .
springer pp.
.
b. meyer applying design by contract ieee computer vol.
no.
pp.
.
.
available https s. furnell and k. l. thomson recognising and addressing security fatigue computer fraud security vol.
no.
pp.
.
s. parkin k. krol i. becker and m. a. sasse applying cognitive control modes to identify security fatigue hotspots in twelfth symposium on usable privacy and security soups .
denver co usenix association jun.
.
.
available workshop program wsf presentation parkin a. van lamsweerde formal specification a roadmap in 22nd international conference on on software engineering future of software engineering track icse limerick ireland june a. finkelstein ed.
acm pp.
.
.
available a. padegs system and beyond ibm journal of research and development vol.
no.
pp.
.
p. a. grassi m. e. garcia and j. l. fenton digital identity guidelines nist standard special publication .
r. g. dromey cornering the chimera ieee software vol.
no.
pp.
.
t. haigh and c. landwehr building code for medical device software security ieee cybersecurity .
c. e. landwehr and a. valdes building code for power system software security technical report.
ieee computer society .
n. polikarpova c. a. furia y .
pei y .
wei and b. meyer what good are strong specifications?
in 35th international conference on software engineering icse san francisco ca usa may d. notkin b. h. c. cheng and k. pohl eds.
ieee computer society pp.
.
.
available r. mohanani p. ralph and b. shreeve requirements fixation inproceedings of the 36th international conference on software engineering ser.
icse .
new york ny usa association for computing machinery p. .
.
available y .
acar c. stransky d. wermke m. l. mazurek and s. fahl security developer studies with github users exploring a convenience sample inthirteenth symposium on usable privacy and security soups pp.
.
s. oesch and s. ruoti that was then this is now a security evaluation of password generation storage and autofill in browser based password managers in proc.
of usenix security symp .
r. shay s. komanduri p. g. kelley p. g. leon m. l. mazurek l. bauer n. christin and l. f. cranor encountering stronger password requirements user attitudes and behaviors in proceedings of the sixth symposium on usable privacy and security pp.
.
b. ur g. kelley s. komanduri j. lee m. maase m. l.mazurek t. passaro r. shay t. vidas l. bauer n. christin l. f.cranor s. egleman and j. l opez helping users create better passwords usenix login .
b. ur f. noma j. bees s. m. segreti r. shay l. bauer n. christin and l. f. cranor i added !
at the end to make it secure observing password creation in the lab in eleventh symposium on usable privacy and security fsoupsg2015 pp.
.
b. ur j. bees s. m. segreti l. bauer n. christin and l. f. cranor do users perceptions of password security match reality?
in proceedings of the chi conference on human factors in computing systems pp.
.
b. ur f. alfieri m. aung l. bauer n. christin j. colnago l. f. cranor h. dixon p. emami naeini h. habib et al.
design and evaluation of a data driven password meter in proceedings of the chi conference on human factors in computing systems pp.
.
j. bonneau the science of guessing analyzing an anonymized corpus of million passwords in ieee symposium on security and privacy .
ieee pp.
.
s. egelman a. sotirakopoulos i. muslukhov k. beznosov and c. herley does my password go up to eleven?
the impact of password meters on password selection in proceedings of the sigchi conference on human factors in computing systems pp.
.
s. komanduri r. shay p. g. kelley m. l. mazurek l. bauer n. christin l. f. cranor and s. egelman of passwords and people measuring the effect of password composition policies in proceedings of the sigchi conference on human factors in computing systems pp.
.
m. weir s. aggarwal m. collins and h. stern testing metrics for password creation policies by attacking large sets of revealed passwords in proceedings of the 17th acm conference on computer and communications security pp.
.
c. weir b. hermann and s. fahl from needs to actions to secure apps?
the effect of requirements and developer practices on app security in29th usenix security symposium usenix security .
f. fischer k. b ottinger h. xiao c. stransky y .
acar m. backes and s. fahl stack overflow considered harmful?
the impact of copy paste on android application security in ieee symposium on security and privacy sp .
ieee pp.
.
s. nadi s. kri uger m. mezini and e. bodden jumping through hoops why do java developers struggle with cryptography apis?
in ieee acm 38th international conference on software engineering icse pp.
.
m. egele d. brumley y .
fratantonio and c. kruegel an empirical study of cryptographic misuse in android applications in proceedings of the acm sigsac conference on computer communications security .
acm pp.
.
n. patnaik j. hallett and a. rashid usability smells an analysis of developers struggle with crypto libraries in fifteenth symposium on usable privacy and security fsoupsg2019 .
h. b. mann and d. r. whitney on a test of whether one of two random variables is stochastically larger than the other the annals of mathematical statistics pp.
.
e. e. cureton rank biserial correlation psychometrika vol.
no.
pp.
.
a. l. strauss and j. m. corbin basic of qualitative research techniques and procedures for developing grounded theory .
sage publications .
b. g. glaser and a. l. strauss the discovery of grounded theory strategies for qualitative research .
new york aldine de gruyter .
p. g. kelley s. komanduri m. l. mazurek r. shay t. vidas l. bauer n. christin l. f. cranor and j. lopez guess again and again and again measuring password strength by simulating password cracking algorithms in ieee symposium on security and privacy .
ieee pp.
.
a. naiakshina a. danilova e. gerlitz and m. smith on conducting security developer studies with cs students examining a passwordstorage study with cs students freelancers and company developers inchi conference on human factors in computing systems r. bernhaupt f. f. mueller d. verweij j. andres j. mcgrenere a. cockburn i. avellino a. goguey p. bj n s. zhao b. p. samson and r. kocielnik eds.
honolulu hi acm pp.
.
.
available j. r. landis and g. g. koch the measurement of observer agreement for categorical data biometrics pp.
.
c. spearman the proof and measurement of association between two things studies in individual differences the search for intelligence .
m. hazhirpasand m. ghafari s. kr uger e. bodden and o. nierstrasz the impact of developer experience in using java cryptography in2019 acm ieee international symposium on empirical software engineering and measurement esem .
ieee pp.
.
a. shostack threat modeling designing for security .
john wiley sons .
j. cox password storage methods .
.
available c. wijayarathna and n. a. g. arachchilage why johnny can t store passwords securely?
a usability evaluation of bouncycastle passwordhashing in proceedings of the 22nd international conference on evaluation and assessment in software engineering ser.
ease .
new york ny usa association for computing machinery p. .
.
available m. green and m. smith developers are not the enemy!
the need for usable security apis ieee security privacy vol.
no.
pp.
.
password management in django accessed .
.
available a. adams and m. a. sasse users are not the enemy communications of the acm vol.
no.
pp.
.
google tink.
.
available s. schmieg this issue demonstrates nicely how software engineers and cryptographers have a completely different idea about what a hash function does.
for many software engineers a hash function is a one way function with the output being essentially meaningless.
august tweet.
schmiegsophie.
.
available https mobile.twitter.com schmiegsophie status k. mindermann and s. wagner fluid intelligence doesn t matter!
effects of code examples on the usability of crypto apis in 42nd international conference on software engineering icse posters poster.
t. lodderstedt j. bradley a. labunets and d. fett oauth .
security best current practice ietf web authorization protocol tech.
rep. draft ietf oauth security topics .
.
available s. t. sun and k. beznosov the devil is in the implementation details an empirical analysis of oauth sso systems in proceedings of the acm conference on computer and communications security pp.
.
s. s. chow y .
j. he l. c. hui and s. m. yiu spice simple privacypreserving identity management for cloud environment in international conference on applied cryptography and network security .
springer pp.
.
m. isaakidis h. halpin and g. danezis unlimitid privacy preserving federated identity management using algebraic macs in proceedings of the acm on workshop on privacy in the electronic society pp.
.
c. landwehr we need a building code for building code vol.
no.
.
.
available