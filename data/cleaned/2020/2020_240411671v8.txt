a study of undefined behavior across foreign function boundaries in rust libraries ian mccormack carnegie mellon university pittsburgh pa usa icmccorm cs.cmu.edujoshua sunshine carnegie mellon university pittsburgh pa usa sunshine cs.cmu.edujonathan aldrich carnegie mellon university pittsburgh pa usa jonathan.aldrich cs.cmu.edu abstract developers rely on the static safety guarantees of the rust programming language to write secure and performant applications.
however rust is frequently used to interoperate with other languages which allow design patterns that conflict with rust s evolving aliasing models.
miri is currently the only dynamic analysis tool that can validate applications against these models but it does not support finding bugs in foreign functions indicating that there may be a critical correctness gap across the rust ecosystem.
we conducted a large scale evaluation of rust libraries that call foreign functions to determine whether miri s dynamic analyses remain useful in this context.
we used miri and an llvm interpreter to jointly execute applications that call foreign functions where we found instances of undefined or undesired behavior in libraries.
three bugs were found in libraries that had more than daily downloads on average during our observation period and one was found in a library maintained by the rust project.
many of these bugs were violations of rust s aliasing models but the latest tree borrows model was significantly more permissive than the earlier stacked borrows model.
the rust community must invest in new production ready tooling for multi language applications to ensure that developers can detect these errors.
index terms rust interoperation undefined behavior aliasing bugs foreign functions i. i ntroduction the rust programming language has become increasingly popular due to its static safety guarantees which provide security benefits comparable to garbage collection without additional run time overhead .
however rust is also frequently used in interoperation with languages that do not provide similar assurances.
to call foreign functions developers must use a subset of unsafe features to bypass rust s restrictions.
if these features are used incorrectly they can break rust s aliasing rules.
the rust compiler relies on these rules to optimize code.
if they are broken optimizations may be applied incorrectly which can introduce security vulnerabilities.
miri is a widely used rust interpreter that uses dynamic analysis to detect violations of rust s aliasing model.
a limitation of miri is that it cannot detect these errors across foreign function boundaries.
however one of the most common reasons for using rust s unsafe features is to call foreign functions .
we seek to determine whether the differences between rust and other languages are leading to errors in practice.
rq1 what types of errors occur in rust libraries that call foreign functions?
the rust community has proposed two aliasing models stacked borrows and tree borrows .
the goal of these models is to strike a balance between performance and usability by providing a set of rules that developers must follow to ensure that compile time optimizations are applied correctly .
since stacked borrows and tree borrows both provide rules of this kind we ask a second research question rq2 which of rust s aliasing models permits more realworld programs with foreign function calls?
to answer these questions we created mirilli a tool which combines miri with an llvm interpreter to jointly execute programs and detect undefined behavior across foreign function boundaries.
we used mirilli to conduct a largescale study of test cases from rust libraries that call foreign functions.
we identified unique instances of undefined or undesirable behavior from libraries.
of the test cases that violated stacked borrows did not violate tree borrows.
our results indicate that rust s restrictions on aliasing mutability and initialization make it easy to inadvertently introduce undefined behavior when calling foreign functions.
developers can take immediate steps to avoid these errors by auditing their use of certain types at foreign callsites.
however the rust project must invest in new production ready tooling to ensure that these errors can be easily detected.
overview in section ii we compare rust s semantics with c and c and we describe the resources and best practices that rust developers use to interoperate with these languages.
in section iii we document our methodology for sampling and evaluating test cases from rust libraries that call foreign functions and we describe the challenges that we encountered when implementing mirilli.
in section iv we describe each type of bug that we found.
we discuss the implications of our findings in section v. we review prior work on rust interoperation in section vi we discuss threats to validity in section vii and we conclude in section viii.
our dataset the appendix and the source for mirilli are available in our replication package1.
apr 2025ii.
b ackground rust s safety restrictions begin at the level of a value which is valid for a particular scope.
a value s type implements traits that define how it behaves.
for example all types have move semantics by default meaning that each value has a unique owner.
however values with the copy trait have no owner and can be freely duplicated.
ownership can be transferred through assignment or borrowed by creating a reference.