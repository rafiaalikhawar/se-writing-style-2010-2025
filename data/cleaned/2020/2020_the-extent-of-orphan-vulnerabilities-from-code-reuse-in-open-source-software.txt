the extent of orphan vulnerabilities from code reuse in open source software david reid university of tennessee knoxville tn usa dreid6 vols.utk.edumahmoud jahanshahi university of tennessee knoxville tn usa mjahansh vols.utk.eduaudris mockus university of tennessee knoxville tn usa audris utk.edu abstract motivation a key premise of open source software is the ability to copy code to other open source projects white box reuse .
such copyingacceleratesdevelopmentofnewprojects butthecodeflaws in the original projects such as vulnerabilities may also spread even if fixed in the projects from where the code was appropriated.
the extent of the spread of vulnerabilities through code reuse the potentialimpactofsuchspread oravenuesformitigatingriskof these secondary vulnerabilities has not been studied in the context of a nearly complete collection of open source code.
aim weaimtofindwaystodetectthewhite boxreuseinduced vulnerabilities determinehowprevalenttheyare andexplorehow they may be addressed.
method we rely on world of code infrastructure that provides a curated and cross referenced collection of nearly all open source softwaretoconductacasestudyofafewknownvulnerabilities.to conduct our case study we develop a tool vdios to help identify and fix white box reuse induced vulnerabilities that have been already patched in the original projects orphan vulnerabilities .
results wefindnumerousinstancesoforphanvulnerabilities even in currently active and in highly popular projects over 1k stars .
even apparently inactive projects are still publicly available for others to use and spread the vulnerability further.
the often longdelayinfixingorphanvulnerabilitieseveninhighlypopular projects increasesthe chancesof itspreading tonew projects.
we provided patches to a number of project maintainers and found that only a small percentage accepted and applied the patch.
we hope that vdios will lead to further study and mitigation of risks from orphan vulnerabilities and other orphan code flaws.
ccs concepts software and its engineering software configuration management and version control systems .
keywords code reuse cve security vulnerabilities git permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
reference format davidreid mahmoudjahanshahi andaudrismockus.
.theextent of orphan vulnerabilities from code reuse in open source software.
in44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
https introduction therapidgrowthofhighqualityopensourcesoftware oss has significantly increased the different kinds of software that can be built upon thus potentially enhancing developer productiv ity increasingcodequality andimprovingsoftwaresecurity .
a key feature of open source code is that it may becopiedintonewprojects1 butsuchcopyingmaybringvulnerabilities or other issues .
we define orphan vulnerabilities as vulnerabilities in copied code that still exist in a project after theyarediscoveredandfixedinanotherproject.insomecases the copying is a result of forking and the link to the original code is readilyavailable.inothercases especiallywhenthecopyingisa resultofmanyiterations thelinktotheoriginalcodemaynotexist.eitherway thevulnerablecodeispubliclyexposeduntiltheorphan vulnerabilityisfixedorthevulnerablecodeisremoved.theaimof thisstudyistodetermineiftheabilitytocopyosscodeactually results in widespread orphan vulnerabilities.
orphan vulnerabil ities present significant risk for several reasons.
first an exploit for such vulnerabilities may be widely known making it easier to attacksoftwarewithknownvulnerabilities .second thecode insuch repositoriesmay becopiedto otherprojects thatmaynot be aware of the vulnerability.
third code in such repositories may be built into applications and run by unsuspecting users.
fourth if asubstantialnumberofossprojectscontainknownandunfixed vulnerabilities ossmaysufferreputationaldamageasadumpof lowqualitycodewhereitmaybehardtofindhigh qualityprojects.
to better understand and address the problem of copied and unpatched code we first would like to create a tool that given a vulnerability fix in one project identifies all other projects that containeitherstillvulnerableorfixedcode.suchatool ifwidely deployed wouldhaveatleasttwopositiveimpacts informmaintainersand usersofstillvulnerable projectsabouttherisks ofthe vulnerabilityintheircodeandwarnusersthatcontemplatereusing such code about the unpatched vulnerabilities.
second we want to determine if and how the still vulnerable projects may differ from the patched ones.
for example we expect thatthemoreactiveprojectsaremorelikelytofixknownvulnerabilities than the less active projects.
this would suggest that the risks posed by unpatched projects may be attenuated by presumably morenarrowdeployment.linus slawstatesthat givenenough 1subject to licensing terms of the original and target project.
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa david reid mahmoud jahanshahi and audris mockus eyeballs allbugsareshallow .thiswouldsuggestthatprojects with more developers are less likely to contain vulnerabilities.
but little empirical evidence exists to support this .
we want to see if our results support linus s law.
third we would like to understand how quickly patches to known vulnerabilities propagate to unpatched projects.
we expect that older vulnerabilities are more likely to be fixed in a project than the more recent ones as it takes time and effort for project maintainers to patch their project.
presence of such a trend would suggest that convenient tools supporting such patching may speed up the deployment of patches.
fourth wewanttodetermineifthetoolweintroduceddetects vulnerabilitiesofadifferentkindthanoneofthemostwidelyknown tools dependabot todetermineiftheapproachusedinourtool ispracticallyrelevantorifdevelopersmaysafelyrelyondependabot.
fifth we wouldliketo identifyhowmany oftheprojectsthat contain orphan vulnerabilities are not just forked from the original project where the vulnerability was fixed.
since many forks are done simply to contribute a patch not to start a new development it would not be surprising if such forks are not updated and do not patch their code.
for any developer it would be easy to look up the origin of the fork to get the most authoritative code.
however itmaybehardertodowithclonedprojects.if ontheotherhand many of the projects are not forks it would be much more difficult for potential users to identify such authoritative versions.
sixth wewouldliketounderstandtowhatextentthestillvulnerableprojectsarewillingtoacceptpatchesofthevulnerability offeredtothem.forexample whiledependabotcreateswarnings and provides patches not all projects are willing to accept them as the patches may break functionality.
toproducethetool vdios webuildontopofworldofcode woc infrastructure that attempts to approximate the source code in public git version control systems and provides crossreferencesamongversionsofthecode projects andchangestothe code.
to answer our research questions we employ a mixed methods approach where we analyze large volumes of data to selectcandidates for a case study.
such an approach is suitable for our investigationbecauseononehandwehaveaverylargeandcom plexdatasource representingalmostallopen sourcecode andwe need computational approaches to select meaningful examples for our case study.
the case study approach is needed because we havelimitedunderstandingoftheproblems andacasestudyapproachprovides anin depth multi facetedexplorationofcomplexissuesintheirreal lifesettings .wecarefullypickthesubjects vulnerabilities toshedlightonalloftheaboveresearchquestions.
itisimportanttonotethathereweareexclusivelyfocusedonthe so called white box reuse where the source code is copied instead of employed as library system call.
furthermore we only consider matching any exact version of the vulnerable code though theapproach can be straightforwardly extended to cases where the copied code has been modified and does not match exactly any of the known fixed or vulnerable versions.wesucceededinbuildingvdios atoolthatidentifiesprojects with orphan vulnerabilities and applied it in four cases investigatingfourvulnerabilitiesinpnglibrary openssl andxzcompression written in go language .
none of the vulnerabilities were reported by dependabot in thousands of vulnerable projects that are not forks of the original projects.
only a fairly small fraction of projectsacceptedthepullrequestfixingtheknownvulnerability.
on the positive side we found older vulnerabilities to be more likely to be fixed and the still vulnerable projects tended to be less active than the patched ones.
in summary our work makes the following contributions we provide a working approach to find file level exact code reuse in any language across all open source repositories.
we provide a tool to implement our approach.
weconductacasestudywithfourcasestoanswerourre search questions regarding vulnerabilities that are spread via file level code reuse.
our primary objective is to reduce security vulnerabilities in software by identifying cases where a known vulnerability has beenfixed butcopiesofversionsthatarestillvulnerablearestill inuseinotherprojects.thisisawell knownsecurityriskinthe softwaresupplychain.theopenwebapplicationsecurityproject owasp lists using components with known vulnerabilities in itstop10webapplicationsecurityrisks owasptop10 .the software supply chain is a significant source of data breaches with one estimate suggesting of such breaches come from supply chain vulnerabilities .
finding file level duplication and locating where a file originated helps identify vulnerable or buggy code.
in the rest of the paper we start from the general background on the data used in the study in section discuss our research methodologyinsection3 presentourvdiostoolinsection4 and the results from our case study in section .
we then discuss these results in section .
finally we present limitations in section related work in section and conclude in section .
background .
software reuse softwarereuseisthepracticeofusingexistingsoftwarecomponents whenbuildingnewsoftwaresystems .therearetwotypesof software reuse often referred to as black box and white box reuse.
black box reuse refers to external code that is used by a project but generally not committed into the project s repository.
thismay include for example linkable libraries.
black box reuse is code that is not modified by the developer.
white box reuse refers to the case where source code is reused by copying the originalcode and committing the duplicate code into a new repository.
white boxreusecodemaybemodifiedbythedeveloper.white box reuse results in multiple copies of the source code across multiple repositories.thesecopiesmaybechanged andtherefore theremay bemultipledifferentversionsofthecode.thispaperspecifically looksatwhite boxreuse.welookatcodereuseontheindividual file level not at the function or method level.
white boxreusepresentsseveralchallenges.vulnerabilitiesand otherbugsmaybefoundandfixedinacopyofthecodethatexists in one project but the fixes may not get propagated to all projects authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the extent of orphan vulnerabilities from code reuse in open source software icse may pittsburgh pa usa that use the file.
similarly useful enhancements may have been added to different versions of the code.
the result is that fixes to known vulnerabilities as well as other bug fixes and enhancementsmayexistinoneprojectbutnotinotherprojects.also licenseterms may not be properly propagated from the original code causing licenseviolationsfordeveloperswhodonotknowtheoriginsofthecode.forqualityandsecurityreasons itisimportanttounderstand where the reused code came from who has worked on it and if betterversionsofitexistinotherrepositories.knowingwhereelse the code exists can help identify if there are known vulnerabilities inthecodebyseeingknownvulnerabilitiesinotherprojectswhere the same code exists.
.
world of code due to the vast quantity of open source software available from manydifferentpublicsourcecode repositoryhostingplatforms it hastraditionallybeentoocomputationallyintensivetofindoriginsofaduplicatedpieceofcodeandallrevisionsofthatcodeacrossall opensourceprojects.therefore previousresearchoncodereuse has typically looked at a relatively small subset of open source software.
however a new inno vation worldofcode woc opens up new research possibilities in this area.
woc provides an infrastructure that makes it possible to efficiently find all versions of reused source code files across all of the major source code repository hostingplatforms.
we build onthe woc infrastructure to find file level code duplication in any language from a woc s expansive collection of open source software.
additional tools that build on woc suchas developer reputation estimator dre can be used to help identify the best of several versions of a file.
the tool described in this paper vdios uses the world of code infrastructure to find duplicate code across many public source codehostingplatforms.wocisanearlyexhaustiveandcontinually updated collection of open source software along with tools to efficientlyextractandanalyzetheextremelylargesetofcode.withouttheinfrastructureprovidedbywoc itwouldnotbepossibletofind suchacompletecollectionofcodecopied andpossiblymodified acrosssuchalargecollectionofcodeinmanyrepositoriesacross many hosting platforms.
since most open source software today is stored in git repositories wocuses similar constructs tostore the data.for example blobs trees and commits in woc are identical to the same objects in git and are referenced with a sha1 hash just like git.
black box reuse can be detected with static analysis techniques that look for dependencies.
these dependencies can be checked against public sources like libraries.io.
but white box reuse which isthesubjectofthispaper requiresaccesstothesourcecodefor all projects from which code may be reused.
woc provides not only the near complete collection of open source software but also organizes its databases for efficient searching.
woc provides a number of mappings that allow us to efficiently extract the information that we need.
woc maintains a database ofseveralobjectsincludingblobs files commits projects andauthors allowing for efficient mappings.
for example given the contents ofafile wecomputethesha 1hash usingthesamemechanism that git uses that identifies the blob.
we then use woc s blob to commitmappingtogetthesha 1hashofthecommit.thecommitto project and commit to time author mappings give us the project name fromwhichwecanidentifythegitrepofromwhichitcame and the author and time of commit which helps us identify where the file originally came from .
we also use the blob to old blob mapping to find old versions of the source code of a particular file.
in order to better understand the entirety of open source in our context weneedtogetahandleonthesetofdistinctprojects.easy creation of clones in version control systems result in numerous repositoriesthatarealmostentirelybasedonsomeparentrepository.therehavebeenvariousattemptstodetectcommunitiesin this ecosystem to address this issue some using visual models and some community detection algorithms .
we use the latter utilizing woc mappings that maps each repository to a central repositoryinadetectedsetofrepositorieswhichpresumablyrepresent the same project.
this mapping is called project to deforked project p2p in woc.
research methodology weconductedanexploratorycasestudytobetterunderstandissues surrounding the spread of software security vulnerabilities caused by copying open source software.
we chose to use an exploratory case study because we are in the early stages of understanding theproblemandpossiblesolutions.wehopetogenerateideasto mitigate these types of security vulnerabilities and spur additional academic research.
the case study approach allowed us to look atasmallnumberofwidely reusedprojectsin depthandwithin their real life context.
this in depth examination allowed us to increaseourunderstandingandgaininsightsthatwouldotherwise be difficult to obtain.
consistent with best practices conducting case studies we investigated a small number of cases in depth and in their context usingmultipledatasourcesandemphasizingqualitativedataand analysis while also collecting significant quantitative data.
the subjectofeachcaseisaknownvulnerability asdescribedbythe commonvulnerabilitiesandexposures cve database hosted atmitre andtheopensourceprojectcontainingthevulnerable code as described by the cve entry.
we examined in detail four specific cases of known software securityvulnerabilitiesthathavebeenfixedintheiroriginalprojectrepository.weusedmultiplecasestoincreasetheconfidenceofthe results and increase generalization of the results.
we avoid making broadgeneralizationclaimsbasedonjustfourcases althoughwe believe that our results provide insights that are applicable to a broaderrangethanjustourfourspecificcases.wecarefullyselected these four cases by searching for vulnerabilities in popular open sourceprojectsthathavebeenwidelycopied.weusedvdiosto screenoutcasesofknownvulnerabilitiesincodethatisnotwidely copied.
we specifically selected common cases not unique or edge cases.weselectedavulnerabilityinlibpng2thatwasinthecodefor alongtime allowingformanycopiesoverthattime.weselecteda new and an old vulnerability in openssl3to highlight differences in the age of the vulnerability.
openssl was chosen in part because it is critical to internet security.
we selected the xz package4 authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa david reid mahmoud jahanshahi and audris mockus written in the go language to contrast with the other projects that were all c language projects.
we selected cases that we believe are representative of the broader group of known vulnerabilities in opensourcesoftware.ourcasesrepresentbothliteralreplication because they are representative of the broader group of known vulnerabilities and theoretical replication because we compare an old vs new vulnerability in the same project and projects in different programming languages .
weexaminedthesefourcasesincontextbylookingatspecific opensourceprojectsthatreusevulnerablecodeandthatarehosted onpublichostingplatformsincludinggithub bitbucket sourceforge and others.
by looking at the cases in context we see a realisticpictureofvulnerablecodereuseintherealworldrather thancontrivedresultswemightgetinatraditionallab basedstudy.
multipledatacollectiontechniquesprovidedcorroboratingevidence.
we used artifacts observations and direct contact withproject maintainers through pull requests and issues allowing us to gather more insights than using just one method.
looking at artifacts the code actually committed in real world repositories providesaconcreteviewofactualpracticewithoutanybiases.ourobservationsallowforsomequalitativeanalysis.contactingprojectmaintainersprovidesmoreinsightintotheirwillingnesstoaddress issues once they are aware of the vulnerabilities.
case studies tend to focus more on qualitative data than quantitativedata.ourstudycontainsboth.vdiosproducessignificant quantitative data which we report in detail.
we also attempt to describe behavior based on our observations and interactions with project maintainers.
our results are also being used to craft survey questions for future research to collect more qualitative data to explain the behavior of project maintainers.
our primary data source is world of code.
we also collect some datadirectlyfromthesourcecodehostingplatformslikegithub bitbucket sourceforge andothers.datacollectionisaccomplishedusingthevdiostoolthatwedevelopedspecificallyforthisresearch project.
vdios is described in detail in section .
we started by selecting a sample of known vulnerabilities identifyingallaffected andfixed versionsofthesourcecodefilesin theprimaryrepositoriesandusingwoctoidentifyallotheross projects thathave versionsof thecode that eitherprecede inversion history the affected version or is modified past it withoutapplying the patch.
we codified this algorithm as a tool that can be usedfor any vulnerabilityor any othertype of defect.
wethen obtained and analyzed the numbers activity states and properties of the affected patched and potentially patched projects.
furthermore we manually investigated many instances of cases where the code is still vulnerable to identify if the project is still active if thedefecthasbeenfixed andifnot whetherthemaintainersare willing to accept the patch.
the vdios tool inthissectionwedescribevdios vulnerabilitydetectioninopen source our tool for finding file level code reuse across all opensource repositories and tracing the version of a single file acrossall repositories and version history.
we build on the woc infrastructure to find duplicate files at a scale that has traditionally been computational infeasible.vdiostakesthecontentsofafileandfindsallduplicateversions of that file or any revision of that file across all of the open source softwareavailableinwoc.thesevulnerablefilesarethentraced backtotheopensourceprojectinwhichtheyarecontained.theseprojects may be hosted on many different source code hosting platforms such as github bitbucket sourceforge etc.
vdios displays a url link to the project and the affected file or files within the given project.
our approach looks for file level reuse that is exact copies of entire files.
we include all files in the version control history when looking for duplicate files.
this allows us to find files that were duplicated and then modified.
whenlookingforsecurityvulnerabilities vdioshastheability toseparaterevisionsoffilesintotwolists revisionsthatcontain thevulnerabilityandrevisionsthatdonotcontainthevulnerability.
this allows vdios to identify projects that are still vulnerable projectsthatusedtobevulnerablebuthavenowbeenfixed andprojects that used to be vulnerable and have changed but we do not know if the change fixed the vulnerability.
figure vdios architecture diagram .
architecture vdiosisimplementedasalayerontopoftheworldofcode woc shell apis as shown in figure .
the woc shell apis provide a convenient way to access the woc data.
specifically vdios needs accesstowoc sdatamapsaswellasinformationabouttheobjects.
woc stores data maps in a way that allows vdios to efficiently look up information.
the specific information we need pertains to blobs commits projects files authors and times.
therearetwoprimarywocshellapisusedbyvdios getvalues and showcnt.
showcnt is used to show the content of the basic git objects blob tree and commit.
getvalues is used to access the woc data maps to get the following information blob to commit b2c finds all commits of the specified blob.
commit to project c2p finds all projects containing the specified commit.
committoproject c2p islikec2pexceptitfindsdeforked projects.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the extent of orphan vulnerabilities from code reuse in open source software icse may pittsburgh pa usa committoparentcommit c2pc andcommittochildcommit c2cc finds the parent and child commit respectively from a given commit.
commit to time author c2ta finds the time of the commit and the author of the commit.
blob to old blob b2ob finds the predecessor of the given blob.
old blob to blob ob2b is the inverse of b2ob.
vdios also retrieves a small amount of data directly from the source code hosting platform github bitbucket gitlab etc .
a systemindependentinterfaceallowsvdiostouseasinglecallto getdata hidingtheplatformspecificdetails.asystemdependent layer whichcallstheappropriateapi forexample thegithubapi provides a glue layer to connect to the popular hosting platforms toretrievethedata.thesystemdependentlayercanbeextended to support additional hosting platforms as needed.
the vdios output is a set of reports generated in html format for viewing in a web browser.
.
algorithm vdios is divided into four phases each of which is described in this section.
the first phase identifies all of the blobs that contain the vulnerability and all the blobs that contain the fix.
starting with a commit that fixes a vulnerability vdios finds the relevant blob or blobs in that commit.
when looking for a security vulnerability it islikelythatnotonlyistherevisionbeforethefixvulnerable but the predecessors of that revision are also likely to be vulnerable.
vdiosuseswoc sblobtooldblobmappingorcommittoparent commit mapping recursively to find all predecessor blobs.
if we knowthecommitthatintroducedthevulnerability vdioslooksat only blobs between the breaking commit and the fixing commit.
it is highly likely that all of those blobs will contain the vulnerability.
vdios next finds the descendent blobs using woc s old blob to blobmappingorcommittochildcommitmapping.theseblobsare highlylikelytocontainthefix.manualinspectionoftheselistscan be done at this point to confirm that the blobs in the first list are vulnerable and the blobs in the second list are fixed.
at the end of phase one we have two lists of blobs.
the first list contains one or more blobs that contain the vulnerability.
the second list contains zero or more blobs that are fixed.
the second phase searches for all projects in woc that contain aduplicateofanyofthevulnerableblobsidentifiedinphaseone by using woc s blob to commit mapping and commit to projectmapping.
note that vdios looks for duplicates in any revision within a project.
that is it will find all projects that have ever contained the vulnerable blob even if it has been fixed or removed in the most current version.
at the end of phase two we have a listofallprojectsthathaveevercontainedoneofthepotentially vulnerable versions of the file.
the third phase checks if the blob s in question are in the most current revision of the project.
in this phase vdios looks through the projects found in the second phase.
those are projects thathave at some point in time contained a known vulnerable blob.
wenowwanttofindoutiftheprojectstillcontainsavulnerable blob.
using the hosting platform s api we find the most current revisionofthefile.nowwelooktoseeifthatrevisionmatchesanyofthevulnerableblobs.ifso weknowtheprojectstillcontainsthe vulnerable code.
next we look to see if that revision matches any of the known good blobs.
if so we know that the vulnerable file has been fixed.
if we do not find a potentially vulnerable or known goodfile thenweknowthattheprojecthascontainedavulnerable file thatfilehasbeenchanged butwedonotknowifthechange fixed the vulnerability.
the final phase generates the reports in html format for viewing in a browser.
the first page of the report shows the committhat fixed the vulnerability if applicable .
next it has a link to a list of blobs and filenames where the vulnerability was fixed a link to a list of ancestors of those blobs which presumably contain the vulnerability and a link to the descendants of those blobs which presumablyallcontainthefix .finally ithaslinkstolistsofvul nerable projects not vulnerable projects and projects where the vulnerablefilehasbeenchangedbutwedonotknowifitisfixedor if it is still vulnerable.
for each of the three categories vulnerable not vulnerable and unknown a report provides more detailed information.
results inthissection wepresenttheresultsofourcasestudyinvolving fourcases thatdemonstrate someof thesecurityproblems caused byorphanvulnerabilities.thefourcasesarefourknownsecurity vulnerabilities that have now been fixed in popular open source projects.
our case study looks at projects that copied vulnerable filesbeforethefileswerefixedin theoriginalprojectfromwhere they were copied.
we look at two vulnerabilities within the widely used cryptography library openssl.
the first vulnerability is very recent and the second heartbleed is relatively old.
we look at onerecentvulnerabilityinagolanguagepackagesupportingxz compression.welookatonevulnerabilitythatwasfixedmorethan three years ago in the mature and proven open source png graphics library libpng which is very widely copied.
our case study looks at code written in different languages to show that our approach is language agnostic.
it works the same regardless of the language.
wefindtensofthousandsofopensourceprojectsthatcontain files with known vulnerabilities even though the vulnerabilities havebeenfixedintheoriginalprojectfromwherethevulnerablefile was copied.
many of the vulnerable projects appear to be inactive but some are clearly still active.
in some cases the fix is recent and project maintainershave not had much time toapply patches.
in other cases the fix is several years old and yet many projectsstill contain the vulnerable code.
patches we provided were only accepted by a small percentage of project maintainers.
.
case cve in openssl opensslisaverywidelyusedopensourcecryptographylibrary implementingsecuresocketlayer ssl andtransportlayersecurity tls .
projects that incorporate openssl play a vital role in internet security.
this was made clearly evident with the discoveryin 2014of thesecurity vulnerabilityinopenssl known as heartbleed .
openssl is the leading cryptography library used for email and website encryption and for software securityinmanyotheropensourcesoftwarepackages.inthiscasestudy authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa david reid mahmoud jahanshahi and audris mockus we look at two vulnerabilities in openssl.
first we look at the most recent as of this writing known vulnerability in openssl.
this vulnerability described in cve allows a maliciouslycraftedrenegotiationclienthellomessagetocrashatls server.
openssl considers this a high severity vulnerability .
itwasfixedinmarch2021.sinceitwasonlyrecentlydiscovered and fixed we might expect to find a number of projects that still contain the vulnerable code.
the second openssl vulnerability we look at heartbleed is discussed in the next section .
.
the firstopenssl vulnerability we look at cve was introducedinthefilessl statem extensions.cincommitc589c34e61 in january and fixed in commit 02b1636fe3 in march .
accordingtotheopensslvulnerabilitieslist5 allopenssl1.
.
versionsareaffectedbythisissue.usersoftheseversionsshould upgrade to openssl .
.1k.
since the vulnerability only existed inafewversions ofopenssl weexpecttofindarelativelysmall number of projects that use one of the vulnerable versions.
following the algorithm described in section .
vdios finds revisions of extensions.c that contain the vulnerability.
that is thereare56revisionsbetweenthecommitthatintroducedthe vulnerability andthe commit thatfixed thevulnerability.vdios finds three revisions of the file that contain the fix and are thus known to be not vulnerable to this specific issue.
additionally vdios finds the following 614projectscontainoneoftheknownvulnerablerevisionsofssl statem extensions.cinthemostcurrentrevisionofthe project.
projects contain one of the known fixed revisions of ssl statem extensions.c in the mostcurrentrevision meaning it used to be vulnerable but now it is fixed.
079projectscontainarevisionofssl statem extensions.c that is not in either the list of vulnerable blobs or the list of fixedblobs meaningthattheprojectcontainedapotentially vulnerableblobinthepast theblobhasbeenmodifiedinthe mostcurrentversion butwedonotknowifthemodification fixed the vulnerability.
projectsused to containa vulnerable version ofthe filebut the file has since been removed.
for further investigation of these projects we used woc p2p mappings to see how many of these projects are forked.
deforking1614vulnerableprojectsresultedinto132projects.tosee if they are active projects or not we looked to see if they have any commitinthepast6and18months.wefoundthat23ofthemhave at least one commit in the past months and have at least onecommit in the past months.
to have an idea about their impact intheosscommunity welookedatthenumberofstars each oftheseprojectshave.weobservedthatfouroftheseprojectshave more than stars and have more than a thousand stars implying their wide impact in the oss community.
.
case cve in openssl we next look at the openssl heartbleed vulnerability.
heartbleed describedincve isaveryseriousvulnerability thatwasfixedin2014.duetoaboundscheckerrorinthetlsheart beatextension thebugallowsdisclosureofinformationthatshould wasfixedsevenyearsago weexpectnottofindmany ifany active projectsstillusing codevulnerabletoheartbleed.we usevdiosto testthishypothesisandtheninvestigatetheprojectswefindthat still contain the heartbleed vulnerability.
heartbleedwasintroducedbycommit4817504d06ondecember inthefilesssl t1 lib.candssl dl both.c.thefirstreleaseofopensslwiththisvulnerabilitywasrelease1.
.1onmarch14 .
the vulnerability was fixed two years later by commit 731f431497f made on april and released in release .
.1g on april .vdiosfirstfindsallrevisionsofthefilessl t1 lib.cbetween thedecember2011committhatintroducedthevulnerabilityand thecommitinapril2014thatfixedthevulnerability.itfinds90vulnerable revisions of ssl t1 lib.c.
following the procedure described in section .
above to find projects containing the vulnerability we discover the following results projects contain one of the known vulnerable revisions of ssl t1 lib.c in the most current revision of the project.
projects contain one of the known fixed revisions of ssl t1 lib.cinthemostcurrentrevision meaningitusedto be vulnerable but now it is fixed.
projects contain revisions of ssl t1 lib.c that is not ineither the list of vulnerable blobs or the list of fixed blobs meaning that the project contained a potentially vulnerable blob in the past the blob has been modified in the mostcurrent version but we do not know if the modification fixed the vulnerability.
becauseoftheveryseriousnatureofheartbleed webelieve it is important to investigate all projects that contain a known vulnerableversionofssl t1 lib.c.wefindthefollowinginformation about these projects of the projects are forks that were all forked between whenthevulnerabilitywasreleasedin2012andwhenitwas fixed in and that have had no activity on the project since before the vulnerability was fixed in .
threeoftheprojectsareclonesthatwereallclonedbetween whenthevulnerabilitywasreleasedin2012andwhenitwas fixed in and that have had no activity on the project since before the vulnerability was fixed in .
theremainingeightprojectshavehadsomeactivity commitsorissues dated2017orlater wellafterthevulnerability was fixed.
these projects are a potential concern and therefore we investigated these eight in more depth.
the113projectswithnoactivitylaterthan2014appeartobeinactive projects.
of course any publicly available project containing heartbleed has the potential to be copied and reused even if the projectisnotactive.wefindtheremainingeightprojects theones with activity dated or later to be more concerning since they have been active since the vulnerability was fixed yet they do not containthefix.
welookedintothose eightprojectsinmoredetail and found the following information oneprojecthasseveralcommitsthisyear .thisclearly indicates that it is an active project and potentially concerning since it contains the heartbleed code.
upon further investigation wefindthatthisprojectcontainstoolsforthe authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the extent of orphan vulnerabilities from code reuse in open source software icse may pittsburgh pa usa purposeofanempiricalstudyofbugsinrealworldcsoftware.opensslisincludedasoneofthesubjectsofthestudy ratherthanbeinglinkedintothisproject ssoftware.thus this project is not vulnerable to heartbleed.
tworelatedprojectsongithubhavecommitsin2018and which would seem to indicate that they are still active.
oneofthemaddedawhitesourcebolt6configurationfile in .
the other is a fork of that project and updated itsconfigurescript7andtravisci8filesin2018.noother changes have been made to either project since well before heartbleed was discovered and fixed.
two related projects on github have activity more recentthan the fix.
one of the projects has two open issues from november where someone asks questions that indicatetheyareactivelyusingtheproject.thequestionswere never answered and there are no recent commits which indicatesthattheprojectisnotactive.butthisdoesshowthat people could be using projects that have been inactive for manyyears.anotherprojectisaforkofaforkofthisproject andhasonecommitin2018.thecommitisonlyachangein whitespace in a readme.
there are no other commits since .
two related projects on gitlab have changes in thatonly affect whitespace in a readme.
one is a fork of theother.
no substantive changes have been made to either project since the fix of heartbleed.
oneproject whichisnotafork hasanumberofcommitsin indicating that it has been active much more recently thantheheartbleedfix.thisgithubprojecthaszerostars zero forks and only commits.
based on the above information we conclude that heartbleed isvirtuallyeliminated althoughnotcompletelyeliminated from activeopensourcesoftwareprojects.however anumberofinactiveprojectsthatarestillvulnerabletoheartbleedarestillreadily available online and thus could still be reused.
.
case cve in package xz our next case looks at a vulnerability in a popular go language package.
most of our work to date has studied c language projects.
vdiosiscompletelyindependentofthelanguage.wewantedto look at a go project to demonstrate the language independence of vdios and woc.
the project at github.com ulikunitz xz is a go languagepackagesupportingxzcompression.theproject which is still under development is subject to the vulnerability described bycve whichisidentifiedashighseveritybythe nationalvulnerabilitydatabase.
thevulnerabilitywasfixedinthe file bits.go by commit 69c6093c7b on august and released in release v0.
.
.
vdios found versions of the file that are potentially vulnerable and twoversionsthat are fixed.
usingthese two lists vdiosfound projects that are known to contain a vulnerable ver sion of bits.go in the most current revision and projects that areknowntocontainafixedversioninthemostcurrentrevision.
notsurprisingthatthereareonly185projectscontainingafixed version.
only one project was found that contained the vulnerable fileinthepastbutdoesnotcurrentlycontainanyoftheknownvulnerable or known fixed versions.
we looked into this one case and found that the only difference was that it used the dos windows format with carriage return and line feed r n at the end of each line instead of the unix format with only line feed n .
there were2 037projectsfoundthatusedtocontainthevulnerablefile but that no longer contain the file at all.
toexamineprojectsfurther weusedwocprojecttodeforked project p2p mappings tofindouthowmanyoftheprojects arenotforked.outof7 105vulnerableprojects thisresultedin758 uniqueprojectsthatarenotforkedandcontainthisvulnerability.
thenumbersfornotvulnerableprojectsare185and82respectively.toseehowmanyofthesedeforkedprojectsareactivelymaintained we looked for those that have at least one commit in the past and past months at the time of our study .
we found that in vulnerable projects have at least one commit in the past months and472 have acommit in the past18 months.
inthe case ofnot vulnerableprojects thesenumbers are68 for6months and 82for18months.aswecansee thepercentageofactiveprojectsin vulnerable projects are significantly lower than in not vulnerable projects which was intuitively expected.
nevertheless not having a commit in a certain period of time does notmeanthattheotherprojectsarenotbeingused andsoitisstill important to address the vulnerability issue.
this already shows the significance of the vulnerability being widely spread.
toinvestigatetheimpactofthisvulnerabilityfromadifferent standpoint welookedat the number ofstars each ofthese projects has been given as a measure of their popularity in oss .
the results show that in vulnerable projects at least projects have more than one star more than more than one hundred more than one thousand and projects have more than thousand stars.in notvulnerable projects the numbersare and respectively.
table case number of projects and their percentage from deforked projects as we can see in table the number of stars in projects that fixed the vulnerability is relatively higher than vulnerable projects which again is what we would intuitively expect.
we have also authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa david reid mahmoud jahanshahi and audris mockus looked at the number of contributing authors in each project using wocprojecttoauthormappings p2a whichmapsthedeforked projectstoaliasedauthorids .lookingatthepercentages it seems that vulnerable projects have relatively fewer developers involved.
.
case cve in libpng libpng is a very popular open source graphics library for manipulatingpng portablenetworkgraphics imagefiles.itisanold library datingbackto1995 andisstillactivelymaintained.because of its popularityand its very longhistory we expectto find many copiesinotheropensourceprojects makingitastrongcaseforour study.thelibpngsourcecode ishostedonsourceforge and mirrored on github .
libpng was the first case that we studied.
lessons learned from thiscasewereappliedtoourstudyoftheothercases.improvements to vdios as described later in this section were applied based on those lessons learned.
thiscasespecificallylooksatthelibpngfilepngpread.c.thatfile isthesubjectofthevulnerabilitydescribedbycve which is labeled as a critical vulnerability in the national vulnerability database nvd .
the vulnerability was fixed in august of in release .
.
.
this fix is in commit 347538e and the blob for pngpread.c at that revision is 45b23a7.
usingwoc sblobtooldblob b2ob mappingrecursively vdios finds951oldversionsofthefilepngpread.c.theoldversionsare thepotentiallyvulnerableversions.usingwoc soldblobtoblob ob2b mapping vdios finds new versions of that file.
the new versions presumably all contain the fix.
next vdios looks at each potentially vulnerable blob and uses woc s blob to commit mappingtofindthecommits.onceithasthecommits ituseswoc s commit to project mapping to find all of the projects containing thediscoveredcommits.thisgivesusalistofallprojectsthathave ever contained one of the potentially vulnerable versions of thefile pngpread.c.
finally vdios looks at the head commit of each projecttoseeifitcontainsaversionofthefilefromthepotentially vulnerable list the presumably fixed list or neither.
the results are as follows projects contain one of the potentially vulnerable blobs in the most current revision even though it was fixed in the original file more than three years ago.
projects contain one of the presumably fixed blobs in the most current revision meaning it used to be vulnerable but now it is no longer vulnerable.
274projectsdonotcontainblobsfromeitherofthetwo previouslists meaningthattheprojectcontainedapotentiallyvulnerableblobinthepast theblobhasbeenmodifiedinthemostcurrentversion butwedonotknowifthemodificationfixedthevulnerability.wemanuallyinspectedthe first of those projects and found that two out of the 10projects still contain the vulnerability.
in those two cases the file was modified but the specific vulnerability was not fixed.
in the remaining eight cases the vulnerability was fixed.
376projectsusedtocontainavulnerableversionofthe file but the file has since been removed.we see that over sixty thousand projects contain a vulnerable versionofthefile.weselectedasubsetofthoseprojectstoanalyze inmoredetail.toselectthesubset wefirstselectedprojectsthat have a commit within the last months to eliminate long dormantprojects.next weselectednon forkedprojectstogetalistof independentprojects.finally whenonecommitwenttomultiple projects weselectedthefirstonethatvdiosfoundandeliminatedtheremainingduplicates.thisprocessofeliminationleavesuswith projects.
from those projects we randomly selected projectsto analyzeinmoredetail.
inlookingatthese projects we findthattheycopytheentirecontentsoflibpng notjustselected files.
our first step is to verify that the projects do indeed contain the vulnerable code.
we manually inspected all of the projects and found six false positives.
there were four projects that had deleted thevulnerablefileandtwoprojectsthathadfixedthevulnerable file.weremovedthosesixprojectsfromfurtheranalysis leaving projects.
we investigated these six cases to understand why vdios produced false positives.
in all six cases the reason was timing.
we ran vdios to produce the results in early february2021 and analyzed the results over the next two months.
woc is continuously updated but will always be a little bit behind what is liveonthesourcecoderepositoryhostingplatforms.weranvdioson version s of woc which was updated in august .
we foundinthosesixcasesthatthevulnerablefileshadbeenfixedorremoved after the woc version that vdios used to produce the reports and beforeweverifiedtheresultsinapril2021.weconcludethatvdios producedthecorrectoutput butthecontinuouslychangingopen source projects will be different from our reports to the extent that changes are made after the most recent woc update.
as a result of thisdiscovery wemodifiedvdiostousetheapisofthehosting platforms to get the most current revision of the file.
the results presentedinthiscasearebasedontheoriginalversionofvdios this new enhancement to vdios is used for the rest of the cases.
for projects hosted on github we also verified that github s dependabot did not find the vulnerability.
while dependabot has similar goals to vdios in finding vulnerable dependenciesin the software supply chain it uses a very different mechanism.dependabot requires that a repository define dependencies in a supportedpackageecosystemwhilevdioslooksforfilelevelcode duplication.
as expected none of the projects we found with a vulnerableversionoflibpngwereidentifiedbydependabot.several oftheprojectshadotherissuesidentifiedbydependabot butnot the libpng issue we are investigating.
this shows that dependabot isenabled forthese projects.clearly vdiosfinds differentsupply chain dependency vulnerabilities than github s dependabot.
finally we wanted to find out if the maintainers of the projects that contain known vulnerable files are willing to accept a patch to fix the vulnerability.
for the vulnerable projects we produced a patchandsentamessagetothemaintainersthroughapullrequest an issue or an email.
we waited up to two weeks for responses.
sevenprojectmaintainersacceptedourpullrequestwiththepatch.
one project maintainer updated to a newer version of libpng becauseofourcontact.twoprojectmaintainersrespondedandsaid they would continue using the existing vulnerable code.
we received no responses about the remaining projects.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the extent of orphan vulnerabilities from code reuse in open source software icse may pittsburgh pa usa asidefromwhatwefoundthroughthese82projects wewanted to have some overall statistics on activity and popularity measures of vulnerable and not vulnerable projects as we had in previous cases.
following the same procedures we found that the vulnerableprojectsreduceto9 680deforkedprojectsfromwhich have at least one commit in the past months and in thepast18months.otherthanthat thereareatleast25projects with more than thousand stars and projects with more than stars which attest the importance of such vulnerabilities.
the detailed numbers are presented in table .
table case number of projects and their percentage from deforked projects discussion our research is motivated by the orphan security vulnerabilitiescaused by code reuse in open source software.
our primary goalis to better understand orphan security vulnerabilities and howthey may be mitigated.
in this work we explore the scope of the problem on a small sample of vulnerabilities and the willingness of project maintainers to fix issues.
the vast quantity of open source projects distributed over different hosting platforms complicates our task.
by exploiting the world of code infrastructure we build a tool vdios that collects code reuse data with the coverage and scale that had previously been impractical.
vdios is targeting orphan vulnerabilities unlike thenationalvulnerabilitydatabasethatidentifiesavulnerability in a single project.
first usingvdios wefindaverylargenumberofprojectswith orphan vulnerabilities based on the four vulnerabilities in our case study.
as hypothesized the probability of an orphan vulnerability islowerformoreactiveprojects.also supportinglinus slaw theprobabilityofanorphanvulnerabilityislowerforprojectswith more developers.
orphan vulnerabilities appear to concentrate in inactiveornolongermaintainedprojects buttheyarealsopresent in very popular over 10k stars and very active projects as well.
orphanvulnerabilities eveniftheyareinunmaintainedorinactive projects still pose risks.
first a developer might copy code from such projects as for example they may have a unique feature that fixed projects lack.
second code from inactive projects may still berunninginexistingsystems forexampleinembeddeddevices.
we in fact found a case where someone asked a question abouta project that appeared to be inactive indicating that they wereusing it.
by looking both at relatively old orphan vulnerabilities andveryneworphanvulnerabilities weobserverelativelyfewer oldorphanvulnerabilities suggestingthatoftenorphanvulnerabilities are eventually fixed or removed.
the time to fix appearsto be substantial providing opportunity for the orphan vulnera bility to propagate further.
even very well known and very old vulnerabilities still persist in the orphan form.
our attempts to gauge willingness of the project maintainers to fixorphanvulnerabilitiesyieldedmixedresults withonlyasmall fraction applying the patch.
our case study suggests that orphan vulnerabilities are widespread they take a very long time to be fixed or they persist.
they exist not only in forks or abandoned projects but also in highlyactiveandpopularprojectsaswell.evenonceanorphanvulner ability is identified and the fix provided to a maintainer only a small fraction act upon the suggested fix.
we conclude that orphan vulnerabilitiesposeanongoingproblemthatneedstobeaddressed not just by identifying and providing fixes to the projects but also byprovidingscreeningtoolstoprojectsreusingsourcecodeand by educating the open source development community.
limitations our internal validation relates to the way the tool operates and the coverage of woc data.
specifically vdios looks for exact matches atthefilelevelforthesetofcodeversionsbetweentheversionsthat introduced and fixed the reference code.
code fragments copied fromwithinafilemaynotbedetected.first thisprovidesonlya conservative estimate of vulnerable files as minor modifications to vulnerable orfixed filesmaynotbedetected.second itisfairly straightforward to enhance vdios to look for snippets patches ormoreabstractrepresentationsofthevulnerability.itwasnota priority for our case study but is important to cast a wider net for capturing more orphan vulnerabilities.
vdiostakestherevisionofafilethatfixesavulnerabilityand then uses woc s blob to old blob b2ob and old blob to blob ob2b mappings recursivelyto find olderand newer revisionsof the file.
alternatively it can use woc s commit to parent commit c2pc and commit to child commit c2cc to find older revisions up tothe revision that introduced the vulnerability if we know that andnewerrevisions.theolderrevisionsarelikelytocontainthe vulnerability andthenewerrevisionsarelikelytocontainthefix.
however thatisnotguaranteedtobethecase.inextremelyrare cases projects revert back to vulnerable code even after fixing it.
vdios allows a manual inspection and modification of the lists of old and new blobs to see if they are actually vulnerable and fixedrespectivelybeforemovingontothenextphase.thismanual interventionsolvestheproblem buttoscalethesolutionvdios will need to be enhanced.
if a developer copies a file and makes a small change before committingforthefirsttime vdioswillnotfindthematch.addinganewcopyrightnotice makingformattingchangestomatchastyleguide orchangingthecr lfformatattheendoflinesareexamples of inconsequential changes that would affect the ability to find a match.itwillonlyfindthematchiftheinitialcommitisidentical tothecopiedfileorapreviousrevisionofthecopiedfile.vdios authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa david reid mahmoud jahanshahi and audris mockus can be enhanced to catch such and other modifications and it is the subject of future work.
woc contains a relatively complete collection of open source software but the collection is not complete with some projects missingandaseveralmonthdelaybetweentheversionsofwoc whennewprojectswithvulnerabilitiesmaybecreated.vdioswill missanycodethatisnotincludedinwoc.onlyincreasingopen source coverage for woc would address this limitation.
it is important to note that some vulnerabilities are never discoveredorfixed ornotreportedinpublicvulnerabilitydatabases.
in all of these cases vdios would not help.
ourfindings aboutthescope andage oforphanvulnerabilities is limited by the relatively small sample of vulnerabilities explored.
we hope that by highlighting the scope and seriousness of the problem with our case study and by building vdios we will spur improvements to vdios and wider studies of vulnerabilities in the future.
related work significant amount of research in the area of code reuse is domi natedbystudiesofblack boxreuse.researchonwhite boxcode reuse where code is reused by copying the original code and committing the duplicate code into a new repository is limited due tothedifficultyofsearchingtheentiretyofopensourcesoftware looking for duplicates.
using world of code woc infrastructure opens new research possibilities in the area of white box code reuse as described in section .
.
we use woc to find cases of code reuse across open source projects.
gharehyazie et al.
looked at the prevalence of cross project codereuseandreportlargeamountsofcodeclonedacrossmultiple projects.
they find that most cloned code comes from projects in a similardomain.githubwasthe onlyrepositoryhostingplatform thattheylookedatandjavawastheonlylanguage.inourwork we look at code in many different languages and from many different repository hosting platforms including github bitbucket sourceforge gitlab and more.
xiaetal.
performedanempiricalstudytofindtheproportion of out of date third party code reused by c language oss projects.
usingopenccfinder whichusedexternalcodesearchengines googlecodesearchandspars theyfound123projectsthat reusedoutdatedcodecopiedfromthreeoriginalprojects.similar toourfindings theydeterminedthatasignificant numberofoss projectsreusedout of datecodethatcontainsecurityvulnerabilities.
they report that openccfinder only returns a very small subset ofopensourceprojects.byusingourvdiostoollayered ontopofwoc snearlycompletecollectionofossinanylanguage we are able to find a significantly larger number of projects that reuse vulnerable code.
decanetal.
throughempiricalstudyusingjavaprojectsthat use maven show that it is common practice to use third party software components that have known security vulnerabilities suggestingthatwhatwefoundforcandgolanguagesinwhite box also applies to black box reuse in java.
alqahtani et al.
link the nvd9with maven to identify known vulnerabilities in mavenprojects.weexpandonthatbyincludingwhite boxreuse 9national vulnerability database by looking at projects in any language that may not use or have management tools like maven.
kawamitsu et al.
studied code reuse across repositories but only lookedat reuse between pairs of repositoriesrather than acrossthefullspectrumofopensourcerepositories.theyintroduce a method to detect code reuse across repositories.
ishioetal.
proposedamethodtofindtheoriginalversion ofclonedsourcecodefiles.theirmethodfindsfilesthataresimilar not just files that are exact copies.
we only look for exact copies of any revision of the file.
their method may find additional matches that ourmethod would miss dueto minor changes ina cloned file beforeitiscommittedthefirsttime.ourmethodmayfindmatches that theirs miss because we run it over a much larger dataset of code repositories.
inoue et al.
use code search engines such as google code search and koders to find reused code fragments.
they presenta tool which takes code fragments and finds cloned fragments using the public code search engines.
it is unclear what coverage is provided by these third party tools.
github sdependabot createspullrequestsforprojectsthat relyonvulnerablelibrariesbutonlyworksforgithubprojectsandonlywhendependenciesaredefinedinasupportedpackageecosys tem.vdios ontheotherhand looksforfilelevelcodeduplication anddoesnotrelyonsupportedpackageecosystems.vdiosalso works with projects across all repository hosting platforms not just github.
szz unleashed finds information about when bugs were introduced.currently vdiosreliesontheusertospecifythecommit that introduced a vulnerability but if it is not available all previous revisions of a file are considered vulnerable.
using szz might reduce that set.
conclusion code reuse through code duplication white box reuse is a common practice in software development.
while it has benefits such as faster development time lower cost and improved quality it alsohasinherentrisksasthereusedcodemaycontainsecurityvulnerabilities or other problems.
in some cases those vulnerabilities or bugs may be orphan known and fixed in other repositories .
in this paper we describe a case study with four different cases that show the extent of security vulnerabilities in open source softwarecausedbycodereuse.wealsopresentatool vdios to findfile levelcodereuseinanylanguageacrosstheentiretyofopen source software by leveraging the world of code infrastructure.
usingvdios wefindveryextensivewhite boxreuseofvulnerable codewithalargenumberofprojectsthatdonotappeartofixthe upstreamvulnerability.thesearecaseswherereusedcodecontains known vulnerabilities or other bugs that persist in open source projects even though they have been fixed in other projects.
overall we mayconclude that extensive code copying inoss results in an extensive spread of vulnerable code that may take yearstofixandthataffectsnotonlyinactive butalsohighlyactive and popular projects.
we also found that many of the projects may notbewillingtopatchthevulnerabilitiesevenafterbeingprovided a fix.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the extent of orphan vulnerabilities from code reuse in open source software icse may pittsburgh pa usa thesefindingssuggestthataddressingunfixedvulnerabilities in oss requires at least three types of support.
on one hand if a patchisprovided someoftheprojectsarewillingtoapplyit.on the other hand for projects that do not fix vulnerable code we needtoprovideinformationtopotentialusersofthecodethattheir applicationstillcontainsunfixedvulnerability.finally developers who are contemplating reusing the code in a project that contains unfixed vulnerabilities need to be informed about the risks and provided withsuggestions onhow topatch or withpatches fixing the existing vulnerabilities.