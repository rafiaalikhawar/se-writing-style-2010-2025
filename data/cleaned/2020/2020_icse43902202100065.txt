flack counterexample guided fault localization for alloy models guolong zheng thanhvu nguyen sim on guti errez briday germ an regisy marcelo f. friasz nazareno aguirrey hamid bagheri univeristy of nebraska lincoln fgzheng tnguyeng cse.unl.edu bagheri unl.edu yuniversity of rio cuarto and conicet fsgutierrez gregis naguirreg dc.exa.unrc.edu.ar zdept.
of software engineering instituto tecnol ogico de buenos aires mfrias itba.edu.ar abstract fault localization is a practical research topic that helps developers identify code locations that might cause bugs in a program.
most existing fault localization techniques are designed for imperative programs e.g.
c and java and rely on analyzing correct and incorrect executions of the program to identify suspicious statements.
in this work we introduce a fault localization approach for models written in a declarative language where the models are not executed but rather converted into a logical formula and solved using backend constraint solvers.
we present flack a tool that takes as input an alloy model consisting of some violated assertion and returns a ranked list of suspicious expressions contributing to the assertion violation.
the key idea is to analyze the differences between counterexamples i.e.
instances of the model that do not satisfy the assertion and instances that do satisfy the assertion to find suspicious expressions in the input model.
the experimental results show that flack is efficient can handle complex realworld alloy models with thousand lines of code within seconds accurate can consistently rank buggy expressions in the top .
of the suspicious list and useful can often narrow down the error to the exact location within the suspicious expressions .
i. i ntroduction declarative specification languages and the corresponding formally precise analysis engines have long been utilized to solve various software engineering problems.
the alloy specification language relies on first order relational logic and has been used in a wide range of applications such as program verification test case generation software design network security security analysis of emerging platforms such as iot and android and design tradeoff analysis to name a few.
cunha and macedo among others use a recent extension of alloy called electrum to validate the european rail traffic management system a system of standards for management and inter operation of signaling for the european railways .
kim proposes a secure swarm toolkit sst a platform for building an authorization service infrastructure for iot systems and uses alloy to show that sst provides necessary security guarantees.
similar to developing programs in an imperative language such as c or java developers can make subtle mistakes when using alloy in modeling system specifications espe cially those that capture complex systems with non trivial behaviors rendering debugging thereof even more arduous.
these challenges call for debugging assistant mechanisms such as fault localization techniques that support declarative specification languages.
however there is a dearth of fault localization techniques developed for alloy.
alloyfl is perhaps the only fault localization tool available for alloy as of today.
the key idea of alloyfl is to use unit tests where a test is a predicate that describes an alloy instance to encode expected behaviors to compute suspicious expressions in an alloy model that fails these tests.
to compute the suspicious expressions alloyfl uses mutation testing and statistical debugging techniques i.e.
it mutates expressions collects statistics on how each mutation affects the tests then uses this information to assign suspicion scores to expressions.
while alloyfl pioneered fault localization in the alloy context and the obtained results thereof are promising it relies on the assumption of the availability of aunit tests i.e.
predicates representing alloy instances which are not common in the alloy setting.
indeed instead of writing test cases alloy users write assertions to describe the desired property and let the alloy analyzer search for potential counterexamples cex s that violate the property.
moreover it is unclear how many test cases are needed or how good they must be for alloyfl to be effective e.g.
in the alloyfl evaluation the number of tests ranges from to .
to address this state of affairs and improve the quality of alloy development we present an automated approach and an accompanying tool suite for fault localization in alloy models using counterexamples called flack .
given an alloy model and a property that is not satisfied by the model flack first queries the underlying alloy analyzer for a counterexample an instance of the model that does not satisfy the property.
next flack uses a partial max sat pmaxsat solver to find an instance that does satisfy the property and is as close as possible to the counterexample.
flack then determines the relations and atoms that are different between the cex and sat instance.
finally flack analyses these differences to compute suspicion scores for expressions in the original model.
ieee acm 43rd international conference on software engineering icse .
ieee unlike alloyfl that relies on unconventional unit tests flack uses well established and widely used assertions naturally compatible with the development practices in alloy.
also instead of using mutation testing or statically analyzing the effects of tests flack relies on counterexamples and satisfying instances generated by constraint solvers which are the main underlying technology in alloy.
we evaluated flack on a benchmark consisting of a suite of buggy models from alloyfl .
the experimental results corroborate that flack is able to consistently rank buggy expressions in the top .
of the suspicious list.
we also evaluated flack on three case studies consisting of larger alloy models used in the real world settings e.g.
alloy model for surgical robots java programs and android permissions and flack was able to identify the buggy expressions within the top .
the run time of flack for most the models is under seconds under second for the alloyfl benchmarks .
the experimental results corroborate that flack has the potential to facilitate a non trivial task of formal specification development significantly and exposes opportunities for researchers to exploit new debugging techniques for alloy.
to summarize this paper makes the following contributions fault localization approach for declarative models we present a novel fault localization approach for declarative models specified in the alloy language.
the insight underlying our approach is that expressions in an alloy model that likely cause an assertion violation can be identified by analyzing the counterexamples and closely related satisfying instances.
tool implementation we develop a fully automated technology dubbed flack that effectively realizes our fault localization approach.
we make flack publicly available to the research and education community .
empirical evaluation we evaluate flack in the context of faulty alloy specifications found in prior work and specifications derived from real world systems corroborating flack s ability to consistently rank buggy expressions high on the suspicious list and analyze complex real world alloy models with thousand lines of code.
the rest of the paper is organized as follows.
section ii motivates our research through an illustrative example.
section iii describes the details of our fault localization approach for alloy models.
section iv presents the implementation and evaluation of the research.
the paper concludes with an outline of the related research and future work.
ii.
i llustration to motivate the research and illustrate our approach we provide an alloy specification of a finite state machine fsm adapted from alloyfl benchmarks .
the specification defines two type signatures i.e.
state andfsm along with their fields lines .
the specification contains three fact paragraphs expressing the constraints detailed below if a start or a stop state exists there is only one of them fact onestartandstop .
the start state is not a subset of the stop state no transition terminates at the start state and no1one sig fsm start set state stop set state 5sig state transition set state 6fact onestartandstop if a start state exists there is only one of them all start1 start2 fsm.start start1 start2 if a stop state exists there is only one of them all stop1 stop2 fsm.stop stop1 stop2 some fsm.stop 13fact validstartandstop start state is not a subset of stop state fsm.start !
infsm.stop no transition ends at the start state.
all s state fsm.start !
ins.transition error should be instead of .
all s state s.transition none s infsm.
stop 21fact reachability all states are reachable from the start state.
state fsm.start.
transition the stop state is reachable from any state.
all s state fsm.stop ins.
transition 27assert nostoptransition nofsm.stop.transition 30check nostoptransition for fig.
buggy fsm model adapted from alloyfl .
transition leaves a stop state fact validstartandstop .
finally every state is reachable from the start state and the stop state is reachable from any state fact reachability .
each assertion specifies a property that is expected to hold in all instances of the model.
for example we use the assertion nostoptransition to check that a stop state behaves as a sink.
the alloy analyzer disproves this assertion by producing a counterexample shown in figure 2a in which the stop state labeled state3 transitions to state1 .
thus there is a bug in the model causing the assertion violation.
indeed careful analysis of the model and the generated cex reveals that the problem is in the expression on line instead of stating that a stop state does not have any transition to any state the expression states that any state not having a transition to anywhere is a stop state a subtle logical error that is difficult to realize1.
the goal of flack is to identify such buggy expressions automatically.
for this example within a second flack identifies four suspicious expressions with the one on line ranked first.
table i shows the results expressions or nodes with higher scores are ranked higher.
moreover flack suggests that the operator is likely the issue in the expression.
1there are two potential fixes for this i reverse the expression to s in fsm.stop s.transition none or ii replace the implication operator to logical equivalence which technically would strengthen the intended requirement.
638table i flack s results obtained for the model in figure .
suspicious expression score s.transition none s in fsm.stop .
s.transition none .
fsm.stop in s. transtion .
s in fsm.stop .
a counterexample b pmax sat instance fig.
instance pair.
note the similarity between the instances.
such a level of granularity can significantly help the developer understand and fix the problem.
the results in section iv show that flack can consistently rank the exact buggy expression within the top suspicious ones and do so under a second.
the key idea underlying our fault localization approach is to analyze the differences between counterexamples instances of the model that do not satisfy the assertion and instances that do satisfy the assertion to find suspicious expressions in the input model.
flack first checks the assertion nostoptransition in the model using the alloy analyzer which returns the cex in figure 2a.
next flack generates a satisfying sat instance that is as minimal and similar to the cex as possible.
their differences promise effective localization of the issue.
a generating sat instances to obtain an instance similar to the cex flack transforms the input model into a logical formula representing hard constraints and the information from cex into a formula representing soft constraints .
essentially flack converts the instance finding problem into a partial max sat problem and then uses the pardinus solver to find a solution that satisfies all the hard constraints and as many soft constraints as possible.
thus the result is an instance of the model that is similar to the cex but satisfies the assertion.
figure 2b shows an instance produced by pardinus considering the cex shown in figure 2a.
notice that this instance is similar to the given cex except for the edge from state3 tostate1 which represents the main difference between the two instances.
b finding suspicious expressions flack analyzes the differences between cexs and the sat instances e.g.
here the transition from state3 tostate1 which only appears in the cex but not the sat instance to identify alloy relations causing the issue.
as shown in table ii that demonstrates the alloy text representation of the cex in figure 2a thetransition relation involves the tuple state3 state1 and the stop relation involves state3 .
thus flack hypothesizes that two relations of transition and stop may cause the difference in the two models.
note that while we present one cex and one sat instance in this example for the sake of simplicity flack supports analyzing multiple pairs of cex and sat instances in tandem.
table ii text representation of the cex in figure 2a relation tuples fsm fsm0 start fsm0 state0 stop fsm0 state3 state state0 state1 state2 state3 transitionstate0 state1 state0 state3 state1 state2 state2 state3 state3 state1 next flack slices the input model to contain only expressions affecting both relations transition and fsm.stop .
this results in two expressions all s state fsm.stop in s. transition line and all s state s.transition none s in fsm.stop line .
at this point flack could stop and return these two expressions one of which is the buggy expression on line .
indeed this level of statement granularity is often used in fault localization techniques like tarantula or ochiai .
however flack aims to achieve a finer grained granularity level by also considering the boolean and relational subexpressions detailed below.
c ranking boolean nodes the expressions on lines and have four boolean nodes a fsm.stop in s. transition b s.transition none c s in fsm.stop and d s.transition none s in fsm.stop .flack instantiates each of these with state1 andstate3 the values that differentiate the cex and sat instance.
for example a becomes fsm.stop in s1.
transition and fsm.stop in s3.
transition .
next flack evaluates these instantiations using the cex and sat instance and assigns a higher suspicious score to those with inconsistent evaluation results.
for example the instantiations fsm.stop in s1.
transition andfsm.stop in s3.
transition of node a evaluate to true in both cex and sat instance so we give a the score i.e.
no changes .
we assign score to b because state3.transition none evaluates to false in the cex but true in the sat instance thus change and state1.transition none evaluates to false in both no change .
overall flack obtains the scores for nodes a b c d respectively.
thus flack determines that nodes b s.transition none and d s.transition none s in fsm.stop are the two most suspicious boolean subexpressions within the expression on line .
d ranking relational nodes while subexpression d indeed contains the error it receives the same score as subex639pression a .
to achieve more accurate results2 flack further analyzes the involving relations.
flack instantiates these relations with state1 andstate3 assesses them in the context of the cex and sat instances and assigns scores based on the evaluations.
for example node d s.transition none s in fsm.stop contains relations s.transition s and fsm.stop .
instantiating these relations with state3 and evaluating them using the cex is as follows becomes fstate1g fstate3g and fstate3g.
thus for the cex d involves both state1 andstate3 and flack gives it a score of .
next it evaluates the instantiations using the sat instance as follows becomesfg fstate3g and fstate3g.
d does not involve state1 and thus has a score .
flack assigns d the average score of .
for the instantiations of state3 .
performing a similar computation for the instantiation of state1 we obtain a score of for d as the evaluation for the cex and sat instances involves both state1 andstate3 differentiated values and state2 regular value .
thus d has a score of .
as an average of .
and .
overall flack obtains the scores .
.
.
.
for a b c and d respectively.
note that the node d is now ranked higher than a as desired.
e suspicious scores flack computes the final suspicious score of a node as the sum of the boolean and relational scores of that node as shown above.
for example the node d s.transition none s in fsm.stop in the expression on line has the highest suspicious score of .
.
table i shows suspicious scores of the expressions in the ranked list returned by flack .
in addition flack analyzes non atomic nodes containing boolean connectors and reports connectors that connect subnodes with different scores.
for example flack suggests that the operator is likely responsible for the error in d because the two subexpressions s.transition none ands in fsm.stop have different scores as shown in table i. indeed in this example the assertion violation is entirely due to this operator a potential fix would be strengthening the model to or switching the two subexpressions as alloy does not have the operator .
iii.
a pproach figure gives an overview of flack which takes as input an alloy model with some violated assertion and returns a ranked list of suspicious expressions contributing to the assertion violation.
the insight guiding our research is that the differences between counterexamples that do not satisfy the assertion and closely related satisfying instances can drive localization of suspicious expressions in the input model.
to achieve this flack uses the alloy analyzer to find counterexamples showing the violation of the assertion.
it then uses a pmax sat solver to find satisfying instances that are as close as possible to the cex s. next flack analyzes the differences 2while this example has only two expressions with similar scores we obtain many expressions with similar scores in more complex and real world models.
thus this step is crucial to distinguish the buggy expressions from the rest.
fig.
overview of flack .
between the cex s and satisfying instances to find expressions in the model that likely cause the errors.
finally flack computes and returns a ranked list of suspicious expressions.
a. the alloy analyzer an alloy specification or model consists of three components i type signatures sig define essential data types and their fields capture relationships among such data types ii fact s predicates pred and assertions assert are formulae defining constraints over data types and iii run andcheck are commands to invoke the alloy analyzer.
thecheck command is used to find counterexamples violating some asserted property and run finds satisfying model instances sat instances .
for a model mand a property p a cex is an instance of mthat satisfies m p and a sat instance is one that satisfies m p. the specification in figure defines two signatures fsm state three fields start stop transition three facts onestartstop validstart validstop and one assertion nostoptransition .
analysis of specifications written in alloy is entirely automated yet bounded up to user specified scopes on the size of type signatures.
more precisely to check that pis satisfied by allinstances of m i.e.
pis valid up to a certain scope the alloy developer encodes pas an assertion and uses the check command to validate the assertion i.e.
showing that no cex exists within the specified scope a cex is an instance isuch thati m p .
to check that pis satisfied by some instances ofm the alloy developer encodes pas a predicate and uses therun command to analyze the predicate i.e.
searching for a sat instance isuch that i m p. in our running example thecheck command examines the nostoptransition assertion and returns a cex in figure 2a.
internally alloy converts these tasks of searching for instances into boolean formulae and uses a sat solver to check the satisfiability of the formulae.
each value of each relation is translated to a distinct variable in the boolean formula.
for example given a scope of in the fsm model in figure the relation state contains values and is translated to distinct variables in the boolean formula and the transition is translated to values representing values of combinations ofkstatek k statek.
an instance is an assignment for all variables that makes the formula true.
for example cexin figure 2a is an assignment where all variables corresponding to values in table i are assigned true and others are false.
finally alloy translates the result from the sat solver e.g.
640algorithm flack fault localization process input alloy model m property pnot satisfied by m output ranked list of suspicious expressions in m 1alloysolver alloyanalyzer m p 2pairs 3whilejpairsj max instance pairs do c alloysolver gencex alloysolver blockcex c s pmaxsolver m c ifs nilthen u alloysolver get unsatcore return unsat analyzer m u c pairs pairs c s 11end 12diffs comparator pairs 13return diffs analyzer diffs an assignment that makes the boolean formula true back to an instance of m. b. the flack algorithm algorithm shows the algorithm of flack which takes as input an alloy model mand a property pthat is not satisfied bym as an assertion violation and returns a ranked list of expressions that likely contribute to the assertion violation.
flack first uses the alloy analyzer and the pardinus pmaxsat solver to generate pairs of cex and closely similar sat instances.
flack then analyzes the differences between the cex and sat instances to locate the error.
if flack cannot generate any sat instance flack inspects the unsat core returned by the alloy analyzer to locate the error.
generating instances to understand why mdoes not satisfy p flack obtains differences between cexs and relevant sat instances.
these differences can lead to the cause of the error.
one option is to use the alloy analyzer to generate a sat instance directly e.g.
by checking a predicate consisting ofp .
however such an instance generated by alloy is often predominantly different from the cex and thus does not help identify the main difference.
for example the cex shown in figure 2a that violates the assertion nostoptransition is quite different from the two alloy generated satisfying instances shown in figure .
to generate a sat instance closely similar to the cex we reduce the problem to a pmax sat partial maximum satisfiability problem.
definition iii.
finding a similar sat instance from a cex .
given a set of hard clauses collectively specified by model mand property p and a set of soft clauses specified by a counterexample cex find a solution that satisfies allhard clauses and satisfies as many soft clauses as possible.
more specifically the hard clauses are generated by constraints in the alloy model and the soft clauses are the assignment represented by cexwhere all presenting variables are true and other variables are false.
because the relations and scope of the alloy model stay the same the variables in the transformed boolean formula would also remain the same and just the values assigned to them would differ between fig.
model instances generated by the alloy analyzer.
various model instances.
thus this encoding can apply to general instances regardless of their structures.
flack then uses an existing pmax sat solver pardinus to find an instance that has the property pand is as similar to the cex as possible3.
for example the instance in figure 2b generated by pardinus is similar to the cex in figure 2a but has an extra edge from state3 tostate1.
the idea is that such minimal differences can help flack identify the error.
comparator flack compares the generated cex s and sat instances to obtain their differences which involve atoms tuples and relations.
first it obtains tuples and their atoms that are different between the cex and sat instance e.g.
in figure the tuple state3 state1 which has the atoms state1 andstate3 is in the cex but not in the satisfying instance.
next it obtains relations with different tuples between the cex and sat instance e.g.
the transition relation involves the tuple state3 state1 in the cex but not in the sat instance.
third it obtains relations that can be inferred from the tuples and atoms derived in the previous steps e.g.
the relation fsm.stop involves tuples having the state3 atom.
in summary for the pair of cex and sat instance in figure flack obtains the suspicious relations transitions and stop and the atoms state1 state3.
flack applies these comparison steps for all pairs of instances and cex s and uses the common results.
diff analyzer after obtaining the differences consisting of relations and atoms between cex s and sat instances flack analyzes them to obtain a ranked list of expressions based on their suspicious levels.
flack assigns higher suspicious scores to expressions whose evaluations depend on these differences and lower scores to those not depending on these differences .
algorithm shows the diff analyzer algorithm which takes as input a model m the differences diffs obtained in sect iii b2 and pairs of cex and sat instances obtained in sect iii b1 and outputs a ranked list of suspicious expressions inm.
it first identifies expressions in mthat involve relations indiffs.
these expressions are likely related to the difference between cex and sat instance.
for example consider the model in figure .
flack identifies two expressions 3based on our experiment the first solution returned by the pmax sat solver is similar enough for flack to locate bugs.
641algorithm diff analyzer input alloy model m differences diffs pairs of cex s and sat instances pairs output ranked list of suspicious expressions in m 1exprs get susp exprs m diffs 2results fg 3foreach expr2exprs do computescore expr results 5end 6return sort results 7function computescore expr results score ifisleaf expr then isexpr instantiate expr diff foreach c s 2pairs do cvals eval c isexpr svals eval s isexpr instscore ifdiff cvals then instscore instscore jdiffj jcvalsj ifdiff svals then instscore instscore jdiffj jsvalsj score score instscore end score score jpairsj else ifisbool expr then isexpr instantiate expr diff foreach c s 2pairs do ifeval c isexpr eval s isexpr then score score end foreach child2getchildren expr do score score computescore child results end end results results expr score return score all s state fsm.stop in s. transition on line and all s state s.transition none s in fsm.stop on line as they involve the relations transition andstop indiffs.
flack then recursively computes the suspicious score for each collected expression e represented as an ast tree.
if e is a leaf e.g.
a relational expression flack instantiates e with atoms from diffs.flack then evaluates the instantiated expression for each pair of cex and sat instance.
if the evaluated result for an instantiated expression contains all atoms involved in diffs flack computes the score as size ofdiffs size of evaluated results otherwise the score is .
for a pair the score is then the average score of cex and sat instance.
at last the score of eis the average among all pairs.
essentially a higher suspicious score is assigned to a relational subexpression whose evaluation involves many atoms in diffs.
ifeis not a leaf node e s score is the sum of boolean and relational scores.
if eis a boolean expression i.e.
an expression that returns true orfalse we instantiate e with atoms from diffs and evaluate it on each cex and sat instance pair.
if it evaluates to different results between the cex and sat instance e.g.
one is true and the other is false flack increases e s score by .
thus a higher boolean scoreis assigned to the expressions whose evaluation does not match between pairs of the cex and sat instances.
then e s relational score is calculated as the sum of e s children.
the final score assigned to each expression is the sum of the e s boolean scores and the relational scores of e s children.
in the end flack returns all expression ranked by their suspicious scores.
to make the idea concrete consider the expression s.transition none in figure .
for the cex and sat instance pair in figure diffs contain two atoms state1 andstate3 .flack first instantiates the expression under analysis with the atoms mentioned above into two concrete expressions state1.transition none and state3.transition none .
the concrete expression evaluates to false in both cex and sat instance while the concrete expression evaluates to true in cex and false in the sat instance.
thus the boolean score for the expression under analysis is as the aggregation of the values obtained for the concrete expressions and .
flack then computes the relational score for the expression under analysis as the sum of the relational scores for its children s.transition andnone both of which are leaves.
to compute the score for s.transtion it is instantiated to state1.transition andstate3.transtion .
state1.transition evaluates to state2 in both cex and sat instance.
thus it gets a score of .
for state3.transition in cex it evaluates to state1 and gets a score of as the size of different values fstate3 state1 gdivided by the size of the instantiated valuesfstate3gand the evaluated values fstate1g.
in sat instance it evaluates to an empty set and gets a score of .
overall s.transition gets a relational score of .
as the average of all its instantiated expressions state1.transition and state3.transition .
.
finally the overall score of .
is assigned to the expression s.transition none as the aggregation of its boolean and relational scores.
unsat core analyzer it is possible that we can only generate cex s but no sat instances indicating that some constraints in the model have conflicts with the property we want to check.
to identify these constraints flack inspects theunsat core returned by the alloy analyzer.
the unsat core explains why a set of constraints cannot be satisfied by giving a minimal subset of conflicting constraints.
those conflicting constraints can help flack identify suspicious expressions.
algorithm outlines the process underlying our unsat core analyzer which takes as input a model m an unsat core u and a cex cshowing mdoes not satisfy a property p and outputs a list of expressions in mconflicting with p. recall that these values m u and c are earlier inferred by flack as outlined in algorithm .
flack starts by producing a sliced model m0 in which all expressions in the unsat core are omitted from the original model m. removing these conflicting expressions would allow us to obtain sat instances from the new model m0 to compare with the cex.
flack now generates a minimal sat instance from m0and compares it with the input cex to 642algorithm unsat analyzer input alloy model m unsat core u counterexample c output a set of expressions in m 1m0 slice m u 2s pmaxsolver m0 c 3diffs comparator f c s g 4exprs collect exprs u 5conflicts 6foreach expr2exprs do foreach diff2diffs do ifeval expr diff m0 false then conflicts conflicts expr end 11end 12return conflicts obtain the differences between the cex and the sat instance as shown in section iii b2.
then flack attempts to identify which of the removed expressions really conflict with pby evaluating them on obtained differences.
the idea is that if an expression evaluates to true then adding that expression back to the model would still allow the sat instance to be generated i.e.
that expression is not conflicting with p. thus expressions that evaluate to false are ones conflicting with pand are returned as suspicious expressions.
note that we assign similar scores to these resulting expressions because they all contribute to the unsatisfiability of the original model and the intended property.
for example if we change line in the model shown in figure to all s state s.transition !in fsm.start alloy would find counterexamples such as the one in figure 2a but fail to generate any sat instances.
this is because the modified line forces all states to have some transitions which conflicts with the constraint requiring no transition for stop states.
from the unsat core flack identifies four expressions in the model a all start1 start2 fsm.start start1 start2 b some fsm.stop c fsm.start !in fsm.stop and d all s state s.transition !in fsm.start .
after removing these four expressions from the model flack can now generate the same sat instance in figure 2b.
as before the main difference between the cex and sat instance involves two values state1 andstate3 .
then flack evaluates each expression using these values.
expressions a b and c are evaluated to true for both values while expression d evaluates to false forstate3 .
thus flack correctly identifies d as the suspicious expression.
iv.
e valuation flack is implemented in java and uses alloy .
.
we extend the backend kodkod solver in alloy to use the pardinus solver to obtain sat instances similar to counterexamples.
we also modify the ast expression representation in alloy to collect and assign suspicious scores to boolean and relational subexpressions.
our evaluation addresses the following research questions rq1 can flack effectively find suspicious expressions?
rq2 how does flack scale to large complex models?
rq3 how does flack compare to alloyfl?
all experiments described below were performed on a macbook with .
ghz i7 cpu and gb of ram.
a. rq1 effectiveness to investigate the effectiveness of flack we use the benchmark models from alloyfl .
table iii shows buggy models collected from alloy models in alloyfl.
these are real faults collected from alloy release .
amalgam and alloy homework solutions from graduate students.
briefly these models are addr address book and farmer farmer cross river puzzle from alloy bempl bad employer grade grade book and other access control specifications are from amalgam and arr array bst balanced search tree ctree colored tree cd class diagram dll doubly linked list fsm finite state machine and ssl sorted singly linked list are homework from alloyfl.
for models with assertions e.g.
from amalgam we use those assertions for the experiments.
for models that do not have assertions e.g.
homework assignments we manually create assertions and expected predicates by examining the correct versions or suggested fixes provided by .
moreover from the correct models or suggested fixes we know which expressions contain errors and therefore use them asground truths to compare against flack s results.
flack deals with models containing multiple violated assertions by analyzing them separately and returning a ranked list for each assertion.
for illustration purposes we simulate this by simply splitting models with separate violations into separate models e.g.
bst2 contains two assertion violations and thus are split into two models bst2 bst2 1 .
finally flack is highly automatic and has just one user configurable option the number of pairs of cex and satisfying instances which by default is set to based on our experiences .
a results table iii shows flack s results.
for each model we list the name lines of code the number of nodes that flack determined irrelevant and sliced out and the number of total ast expression nodes.
the last two columns show flack s resulting ranking of the correct node and its total run time in second.
the italicized models contain predicate violations while the other models contain assertion violations.
flack automatically determines the violation type and switches to the appropriate technique e.g.
using comparator for assertion errors and the unsat analyzer for predicate violations section iii .
finally the models are listed in sorted order based on their ranking results.
in summary flack was able to rank the buggy expressions in the top e.g.
the buggy expression is ranked first for top to for top to for above top for out of models.
for models flack was not able to identify the cause of the errors e.g.
the buggy expression are not in the ranking list many of which are beyond the reach of flack e.g.
the assertion error is not due to any existing expressions in the model but rather because the model is missing some constraints .
finally regardless 643table iii results of flack on alloy models.
results are sorted based on ranking accuracy.
times are in seconds.
model loc total sliced rank time model loc total sliced rank time model loc total sliced rank time top .
ssl10 .
dll20 .
addr .
ssl12 .
fsm6 .
arr3 .
ssl14 .
fsm9 .
arr4 .
ssl14 .
ssl11 .
arr5 .
ssl14 .
bst8 .
arr6 .
ssl14 .
bst8 .
arr7 .
ssl17 .
bst22 .
bst2 .
ssl17 .
dll1 .
bst2 .
ssl18 .
dll18 .
bst3 .
ssl18 .
fsm4 .
cd1 .
ssl19 .
fsm5 .
cd1 .
arr1 .
ssl2 .
cd2 .
arr2 .
ssl13 .
cd3 .
arr10 .
ssl18 .
cd3 .
bst1 .
arr8 .
dll1 .
bst4 .
bst2 .
dll2 .
bst5 .
bst3 .
dll3 .
bst7 .
fsm2 .
dll3 .
bst8 .
fsm8 .
dll4 .
bst9 .
arr11 .
dll5 .
bst10 .
bst10 .
dll6 .
bst10 .
fsm9 .
dll7 .
bst11 .
ssl15 .
dll8 .
bst13 .
top .
.
dll9 .
bst14 .
bst3 .
dll11 .
bst15 .
bst20 .
dll12 .
bst17 .
fsm7 .
dll13 .
bst18 .
ssl19 .
dll14 .
bst20 .
bst6 .
dll15 .
bst21 .
bst12 .
dll16 .
bst22 .
bst19 .
dll17 .
dll7 .
ssl19 .
dll18 .
dll10 .
bst17 .
dll18 .
dll14 .
bst22 .
dll20 .
dll17 .
.
.
farmer .
fsm1 .
bst4 .
fsm1 .
fsm3 .
bst16 .
fsm7 .
fsm9 .
bst17 .
fsm9 .
fsm9 .
ssl12 .
grade .
top .
.
ssl9 .
ssl1 .
arr7 .
bst22 .
ssl2 .
arr9 .
fail .
ssl3 .
bst2 .
bst4 .
ssl3 .
bst12 .
bst11 .
ssl4 .
bst18 .
bempl .
ssl5 .
bst19 .
ctree .
ssl6 .
bst19 .
dll3 .
ssl6 .
dll2 .
other .
ssl6 .
dll17 .
ssl16 .
ssl6 .
dll18 .
ssl16 .
ssl7 .
dll19 .
ssl16 .
ssl7 .
dll20 .
ssl16 .
ssl8 .
of whether flack succeeds or fails the tool produces the results almost instantaneously under a second .
b analysis flack was able to locate and rank the buggy expressions in models.
many of these bugs are common errors in which the developer did not consider certain corner cases.
for example stu5 contains the buggy expression all n this.header.
link n.elem n.link.elem that does not allow any node without link the fix is changing to all n this.header.
link some n.link n.elem n.link.elem .flack successfully recognizes the difference that the last node of thelist contains a link to itself in the cex but not in the sat instance and ranks this expression second more importantly it ranks first the subexpression n.elem n.link.elem where the fix is actually needed.
flack also performed especially well on models with violated predicates by analyzing the unsat cores and correctly ranked the buggy expressions first.
for six models bst4 2 bst16 bst17 bst22 3 stu9 and stu12 1 flack was not able to place the buggy expression within the top but still within the top .
for these models flack obtains differences that are not directly related to the error but consistently appear in both the cex and 644table iv flack s results on large complex models model loc total sliced rank time s surgical robots .
android permissions .
sll contains .
count nodes .
remove nth .
stat instances and therefore confuse flack .
flack was not able to identify the correct buggy expressions in models e.g.
the resulting ranking list does not contain the buggy expressions.
most of these bugs are beyond the scope of flack and fault localization techniques in general .
more specifically the models bst4 bst11 bempl ctree dll3 2 ssl16 ssl16 1 ssl16 2 andssl16 3 have assertion violations due to missing constraints in predicates and thus do not contain buggy expressions to be localized.
for other flack did not find the ground truth buggy expression the buggy expression does not contain the different relation but ranked first another expression that could also be modified to fix the error.
b. rq2 real world case studies the alloyfl benchmark contains a wide variety of alloy models and bugs but they are relatively small loc .
to investigate the scalability of flack we consider additional case studies on larger and more complex alloy models.
a surgical robots the study in uses alloy to model highly configurable surgical robots to verify a critical arm movement safety property the position of the robot arm is in the same position that the surgeon articulates in the control workspace during the surgery procedure and the surgeon is notified if the arm is pushed outside of its physical range.
this property is formulated as an assertion and checked on alloy models representing types of robot arms using different combinations of hardware and software features.
the study found that models violate the property.
table iv which has the same format as table iii lists the results.
we use all buggy models each has about loc but list them under one row because they are largely similar and share many common facts and predicates but with different configurable values one model has a fact that has an anglelmit set to while another has value .
the buggy expression is also similar and appears in the same fact.
for each model flack ranked the correct buggy expressions in the second place in less than seconds.
flack returned two suspicious expressions hapticsdisabled in usedgeomagictouch.force and some notification geomagictouch.force notification hapticsenabled .
modifying either expression would fix the issue e.g.
changing disable to enabled in or enabled todisabled in .
b android permissions the covert project uses compositional analysis to model the permissions of androidos and apps to find inter app communication vulnerabilities.
the generated alloy model used in this work does not contain bugs violating assertions thus we used the mualloy mutation tool to introduce random bugs to various predicates in the model binary operator mutations unary operator mutation and variable declaration mutation.
table iv shows the result.
flack was able to locate buggy expressions the unary modification ranked 2nd the binary operations ranked 3rd 9th and 11th but could not identify the other mutated expression the variable declaration mutation .
however after manual analysis we realize that this mutated expression does not contribute to the assertion violation i.e.
flack iscorrect in not identifying it as a fault .
c taco the taco translation of annotated code project uses alloy to verify java programs with specifications.
taco automatically converts a java program annotated with invariants to an alloy model with an assertion.
if the java program contains a bug that violates the annotated invariant then checking the assertion in the alloy model would provide a counterexample.
we use three different alloy models with violated assertions representing three real java programs from taco sll contains checks if a particular element exists in a linked list count nodes counts the number of a list s nodes and remove nth removes the nth element of a list.
these machine generated models are much larger than typical alloy models to loc each .
table iv shows the results.
for ssl contains flack ranked the buggy expression third within seconds.
this expression helps us locate an error in the original java program that skips the list header.
the faulty expressions of remove nth andcount nodes are ranked 12th and 18th respectively which are still quite reasonable given the large number of possible locations .
note that these buggy expressions consist of multiple errors e.g.
having buggy nodes causing flack to instantiate and analyze combinations of a large number of subexpressions.
manual analysis on the identified buggy expressions showed that the original java programs consist of single bugs within loops.
taco performs loop unrolling and thus spreads it into multiple bugs in the corresponding alloy models.
in summary we found that flack works well on large realworld alloy models.
while coming up with correct fixes for these models remain nontrivial flack can help the developers or automatic program repair tools quickly locate buggy expressions which in turn helps understand and hopefully repair the actual errors in original models.
c. rq3 comparing to alloyfl we compare flack with alloyfl which to the best of our knowledge is the only alloy fault localization technique currently available.
while both tools compute suspicious statements they are very different in both assumptions and technical approaches.
as discussed in section v alloyfl requires aunit tests provided by the user or generated from the correct model and adopts existing fault localization techniques in imperative programs such as mutation testing 645table v comparision with alloyfl.
top avg tool failed rank time s flack .
.
alloyfl .
.
and spectrum based fault localization in contrast flack uses violated assertions and relies on counterexamples.
to apply alloyfl on the benchmark models we use the best performance configuration and testsuites described in .
specifically we use the alloyfl hybrid algorithm with ochiai formula and reuse tests in automatically generated by mualloy as described in .
table v compares the results of flack and alloyfl.
the two approaches appear to perform similarly with flack being slightly more accurate.
overall flack outperforms alloyfl where on average the buggy expressions ranked 2nd and 3rd byflack and alloyfl respectively.
also in top ranking flack performs much better compared to alloyfl over models .
moreover flack is much faster where the average analysis time is far less than a second for flack it takes over seconds for alloyfl to analyze the same specifications.
we were not able to apply alloyfl to the models in section iv b because mualloy which is used to generate aunit tests for alloyfl does not work with these models e.g.
mostly caused by unhandled alloy operators .
this is not a weakness of alloyfl but it suggests that it is not trivial to generate tests from existing alloy models automatically.
d. threats to validity we assume no fault in data type sig s and field declarations which may limit the usage of flack .
however none of the benchmark models we used has bugs at these locations.
moreover we could always translate constraints for sig and field to facts.
for example one sig a could be translated tosig a factfone ag.
the models in the alloyfl benchmark are collected from graduate student s homework and relatively small.
thus they may not represent faulty alloy models in the real world.
we also evaluate flack with large alloy models written by experienced alloy developer the surgical robot models and android permissions model or generated by an automatic tool taco and show that flack performs well on these models section iv b .
we manually create assertions for models that do not have assertions.
thus our assertions might be inaccurate and not as intended.
however for other models with assertions e.g.
those in the alloyfl benchmark and all the case studies we use those assertions directly and flack output similar results.
v. r elated work flack is related to alloyfl which adopts spectrumbased fault localization and mutation based techniques from imperative languages.
given aunittests labeled with should pass or should fail alloyfl computes a suspicious score for expression by mutating and giving it a higher score if the mutation increases the number of should pass tests pass and the number of should fail tests fail.
alloyfl uses mualloy to automatically generate tests.
however mualloy requires the correct alloy model to generate these tests.
flack does not require tests and instead uses assertions which are commonly used in alloy.
the generation of similar instances can be viewed as a model exploration problem .
bordeaux uses alloy to find pairs of sat unsat instances with minimum relative distances.
in contrast flack reduces the generation of an instance as close as possible to the identified counterexamples into a partial max sat problem and solves it using a pmaxsat solver.
amalgam explains why some tuples of a relation do or do not appear in certain instances.
a user would manually select a tuple to add or delete and amalgam tries to explain why they can or cannot do so typically the reason for counterexamples is due to the assertions .
flack instead automatically identifies why a counterexample fails and finds locations that relate to this violation.
many fault localization techniques have been developed for imperative languages.
spectrum based techniques identify faulty statements by comparing passing and failing test executions.
sat based techniques convert the fault location problem into an sat problem.
statistic based methods collect statistical information from test executions to locate errors.
feedback based techniques interactively locates error by getting feedback from the user.
delta debugging identifies code changes responsible for test failure.
there are also works on minimizing differences in inputs based on the assumption that similar inputs would lead to similar runs .
program slicing has also been used to aid debugging.
model based diagnosis mbd approaches identify faulty components of a system based on abnormal behaviors.
griesmayer applied mbd to localizing fault in imperative programs using model checker.
marques silva converted the mbd problem into a maxsat problem to find the minimal diagnosis where the system description is encoded as the hard clauses and the not abnormal predicates as the soft clauses.
there has also been another similar line work in pinpointing axioms in description logic .
vi.
c onclusion and future work we introduce a new fault localization approach for declarative models written alloy.
our insight is that alloy expressions that likely cause an assertion violation can be obtained by analyzing the counterexamples unsat cores and satisfying instances from the alloy analyzer.
we present flack a tool that implements these ideas to compute and rank suspicious expressions causing an assertion violation in an alloy model.
flack uses a pmax sat solver to find satisfying instances similar to counterexamples generated by the alloy analyzer 646analyzes satisfying instances and counterexamples to locate suspicious expressions analyzes subexpressions to achieve a finer grain level of localization granularity and uses unsat cores to help identify conflicting expressions.
preliminary results on existing alloy benchmarks and large real world benchmarks show that flack is effective in finding accurate expressions causing errors.
we believe that flack takes an important step in finding bugs in alloy and exposes opportunities for researchers to exploit new debugging techniques for alloy.
currently we are improving the accuracy and efficiency offlack .
specifically instead of using a default number of instance pairs we can search for instances incrementally until the algorithm converges.
we are also exploring new approaches to effectively integrate flack with automatic alloy repair techniques.
preliminary results from the recent beafix work shows that flack accurately identifies faults in alloy specifications which in turn helps beafix automatically analyze and repair those specifications.
vii.
d ata availability we make flack and all research artifacts models and experimental data reported in the paper available to the research and education community .
acknowledgment we thank the anonymous reviewers for helpful comments.
this work was supported in part by awards w911nf from the army research office ccf ccf1755890 and ccf from the national science foundation and pict and from the argentine national agency of scientific and technological promotion anpcyt .