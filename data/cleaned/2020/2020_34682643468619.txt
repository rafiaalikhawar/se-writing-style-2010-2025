graph based seed object synthesis for search based unit testing yun lin dcsliny nus.edu.sg national university of singapore singaporeyou sheng ong ong.aaron u.nus.edu national university of singapore singaporejun sun junsun smu.edu.sg singapore management university singapore gordon fraser gordon.fraser uni passau.de university of passau germanyjin song dong dcsdjs nus.edu.sg national university of singapore singapore abstract search based software testing sbst generates tests using search algorithms guided by measurements gauging how far a test case is away from exercising a coverage goal.
the effectiveness of sbst largely depends on the continuity and monotonicity of the fitness landscape decided by these measurements and the search operators.
unfortunately the fitness landscape is challenging when the function under test takes object inputs as classical measurements hardly provide guidance for constructing legitimate object inputs.
to overcome this problem we propose test seeds i.e.
test code skeletons of legitimate objects which enable the use of classical measurements.
given a target branch in a function under test we first statically analyze the function to build an object construction graph that captures the relation between the operands of the target method and the states of their relevant object inputs.
based on the graph we synthesize test template code where each slot is a mutation point for the search algorithm.
this approach can be seamlessly integrated with existing sbst algorithms and we implemented evoobj on top of the well known evosuite unit test generation tool.
our experiments show that evoobj outperforms evosuite with statistical significance on methods taken from open source java projects using state of the art sbst algorithms.
ccs concepts software and its engineering software testing and debugging search based software engineering .
keywords object oriented software testing search based code synthesis acm reference format yun lin you sheng ong jun sun gordon fraser and jin song dong.
.
graph based seed object synthesis for search based unit testing.
in proceedings of the 29th acm joint european software engineering conference permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
introduction search based software testing sbst generates test cases guided by measurements that gauge how far tests are from reaching a coverage objective.
using the measurement as fitness functions the search algorithms can gradually improve the tests to achieve high coverage.
sbst requires only light weight instrumentation and has been demonstrated to be practically applicable in many scenarios in practice .
despite the success of sbst and random testing tools like evosuite and randoop recent empirical results suggest that object oriented code challenges the fitness functions traditionally used in search based test generation resulting in limited coverage performance and ability to detect real faults .
a primary cause appears to be the inability of search based test generators to instantiate and configure valid objects .
unfortunately object inputs are very common.
figure summarizes the distribution of java methods with object inputs in the sf100 benchmark a dataset of open source java projects .
of all java methods take at least one object input.
the effectiveness of sbst relies on the assumption that the search space is overall continuous andmonotonic with respect to fitness measurements.
for example consider listing in which one would use the traditional branch distance measurement to guide the search towards executing the true branch b in line .
this branch is based on two branch variables i.e.
operand op1as the returned value of the call of getawardnum and operand op2 as the constant .
given a test tand the condition of basb.c the branch distance of tfrom exercising bis defined as distance b t op2 op1 kifb.cevaluates to false otherwise wherekis a constant as minimum value of the branch distance when the branch is not covered.
let kbe assuming a test whose runtime valuation of op1is0 and the valuation of op2 a constant is always the branch distance is a branch distance of0indicates that the branch is covered.
based on the guidance of the branch distance sbst algorithms treat the relation between the input variables and target branch condition as a black esec fse august athens greece yun lin you sheng ong jun sun gordon fraser and jin song dong figure the distribution of the ratio of java methods with object inputs from the projects in sf100 benchmark.
among the java projects projects have over of methods with object inputs projects have of methods with object inputs etc.
overall the mean ratio is .
and the median ratio is .
.
public int example student s if s.getsupervisor .getcv .getawardnum return class student supervisor s ... class supervisor cv cv ... class cv int awardnum ... listing a branch relevant to object states student s new student example s a initial test tini1 student obj0 new student supervisor obj1 new supervisor cv obj2 new cv int a0 obj2.setawardnum a0 obj1.setcv obj2 obj0.setsupervisor obj1 example s b effective test tefffor sbst figure there is no continuity and monotonicity in the search space landscape to evolve from the initial test tinito the effective test tefffor sbst with mutations regarding the branch distance measurement.
box randomly mutate the evolving tests e.g.
via statement modification insertion and deletion and select more promising tests i.e.
with the minimum branch distance in each evolving iteration.
object inputs unfortunately usually lead to search spaces that are neither continuous nor monotonic.
in particular given a test with randomly constructed object inputs it is hard for the branch distance measurement to guide the evolution.
consider the initialized testtiniin figure 2a since s.getsupervisor will return a null value a null pointer exception will be thrown at line in listing .
thus the branch distance of tiniforbis inaccessible as branch distance test tini ttar teff0.
single mutation t ini search space with branch distance inaccessiblefigure the idea underlying evoobj traditional mutation can hardly help tiniescape from a search landscape with local optima.
in this work we aim to synthesize a seed point teff which has a more continuous and monotonic landscape than pointtitowards the global optimum.
the branch operands are not even executed.
even worse any tests t iniresulting from a mutation e.g.
inserting deleting and modifying statements in tini ontinialso leads to an inaccessible branch distance.
consequently the search has no guidance.
figure illustrates this problem using the fitness landscape induced by the branch distance given tini figure 2a the branch distance exists neither for tininor for any of its neighbour tests resulting from a mutation e.g.
t ini .
as a consequence there is no gradient that guides the search to reaching the target test ttar.
however consider test case teff as shown in figure 2b for this test case the null pointer exception does not occur and therefore the branch distance measurement now exists i.e.
.
and neighbour tests by mutating line in figure 2b can also have a different branch distance.
in the fitness landscape figure there is now a gradient that guides the search from tefftottar.
in this paper we propose a systematic and practical approach to synthesize object inputs by analyzing static control and data flow to facilitate sbst.
the approach creates seed tests such asteffin figure from which sbst can start the search with a more continuous and monotonic fitness landscape.
this test seed synthesis approach works as follows first for an uncovered branch we construct a test template which leaves some slots for an sbst algorithm to mutate their values.
each slot represents a descendant attribute of primitive type of an object input representing the relevant object state to the branch.
to this end we construct an object construction graph by statically analyzing the interprocedural data and control flow from the object inputs of the target method to the operands used in the target branch.
the object construction graph depicts what descendant attributes of the object input are relevant and how to construct object input accordingly see figure .
the test templates are then generated through traversing the graph.
second the test template code is used in the search through its statements assigning values for its slots.
here each slot in the template represents a state variable of the object input.
finally we integrate our approach into existing sbst algorithms at the minimum cost.
1according to listing the branch distance will be normalized by some function as f n n n .
thus for the example code of figure 2b we have the branch distance as which will be further normalized to3 .
.
1069graph based seed object synthesis for search based unit testing esec fse august athens greece class basicrules target method boolean checkrules action action gamestate state player actor state.player action.getactor player target state.player action.gettarget if actor null return false if target null return false target branch if actor.getaction return true listing target method checkrule we implemented this approach in the evoobj tool which extends evosuite for testing java programs and conducted experiments on methods from open source java projects sf100 dataset .
although we implemented and evaluated this approach in the context of java it is independent of the language used and generalizes to any programming language where test generation requires the construction of complex objects via sequences of calls.
our experiment results show that evoobj improves branch coverage compared to evosuite on various sbst algorithms with moderate runtime overhead.
in detail our work makes the following contributions we propose a test seed synthesis approach designed for facilitating sbst on object oriented programs mitigating the problem of non monotonic or non continuous landscapes in the search space section .
we present an implementation of our approach evoobj the source code and binaries of which are publicly available section .
we conduct an experiment consisting of methods in projects showing evoobj outperforms evosuite using various sbst algorithms section .
motivating example in this section we illustrate our approach using an example.
listing shows a simplified excerpt of the gangup project the 27th project in sf100 benchmark which we will use as a running example in the remaining sections.
in this example the target method is the checkrules method and the target branch is the true branch of the if statement in line .
the target method takes two object inputs of type action andgamestate and the operand in the target branch has both control and data dependencies on their attributes and returned value of the method calls e.g.
player .
even with a time budget of minutes evosuite does not succeed in generating a test that reaches the target branch.
listing shows an example test case generated by evosuite .
since action0 isnull the call to checkrules immediately leads to a null pointer exception.
even if action were not null there are further challenges the target branch is control dependent on the return values of the calls of state.player line and in listing which is influenced by the internal states of action and1 public void test basicrules basicrules0 new basicrules action action0 null gamestate gamestate0 new gamestate basicrules basicrules1 new basicrules gamestate0.notifyobservers int int0 string string0 gamestate0.tostring gamestate0.setgamestate int0 byte bytearray0 gamestate0.pack basicrules0.checkrules action0 gamestate0 listing test initialized by evosuite class gamestate extends observable private player players ... public player player int id if id id return null return this.players class action private int actor private int target ... public action int actor int target ... public void setactor int actor ... public int getactor return actor class player private int action ... listing the class of gamestate action and player state .
however the branch distance measurement for the target branch provides no guidance for evolving these states.
listing shows the relevant dependency code the return value of the method player defined in the gamestate class is guarded by the condition on line in listing and depends on the players attribute in the state object line in listing .
without constructing the players field with at least one element for the gamestate object the execution of test case will always terminate with a null pointer exception in line of listing resulting in an unavailable branch distance on the target branch.
however random construction of state andaction objects is very likely to result innull values returned from the player method making the branch distance on the target branch ineffective.
as a result the target branch is unlikely to be covered.
in this work we overcome the challenges by synthesizing promising test templates for sbst to start the search.
to this end for an uncovered branch our approach builds its construction graph from the target method depicting how to construct the object input with states relevant to the target branch generates test template code based on the graph and searches appropriate valuation for instantiating the template.
object construction graph.
an object construction graph links object inputs with their transitively relevant data fields.
figure 1070esec fse august athens greece yun lin you sheng ong jun sun gordon fraser and jin song dong action stateactor players index actiontarget basicrules basicrules new basicrules int int int int action action new action int1 int2 gamestate gamestate new gamestate player players new players int int player player new player int3 int int players player gamestate .setplayers players int int player player gamestate .player int4 int int player .setaction int5 basicrules .checkrules action gamestate basicrules basicrules new basicrules int int int int action action new action int1 int2 gamestate gamestate new gamestate player players new players int int player player new player int1 int int players player gamestate .setplayers players int int player player gamestate .player int1 int int player .setaction int5 basicrules .checkrules action gamestate search a object construction graph b synthesized test template c test cover ing the branch2 16player where exception happens2 16mutation slotslegend input field array element method figure example of graph based test template generation.
in the object construction graph grey rectangles represent graph inputs red rectangles represent fields get field operations green rectangles represent call call operations and blue rectangles represent array element get array element operations.
each node in the object construction graph can be used to generate a statement in the test code.
then we apply mutations on the slots of the generated test template to evolve the test.
shows the object construction graph for listing which starts with two object inputs action andstate in grey .
the rectangles of different colors represent different types of variables e.g.
fields array elements or method return values .
edges between nodes indicate dataflow relations relevant for guiding test code construction.
for example there is an ownership relation between the input object action and the field target this information allows to construct a target attribute for the object input action when generating the test code.
each leaf node in the graph represents a variable which is a descendant attribute from some object input and has data and control dependencies with the operands of the target branch.
graph based template synthesis and search valuation.
based on the object construction graph we can construct a test seed template where each node in the graph corresponds to a statement in the test template.
a test template consists of code preparing the object inputs with its required descendant attributes followed by a call of the target method.
the assigning variable values in the statements test template can be considered as slots .
each slot is a value of primitive type allowing the search algorithms to more effectively evolve tests based on the resulting fitness guidance.
thus generated test templates serve as shortcuts towards global optima.
in our experiments evoobj can cover the target branch in listing in seconds on average while evosuite cannot even cover it within minutes search budget.
approach in this section we describe in detail how object construction graphs are created how code is synthesized from these graph and how to integrate this approach into sbst algorithms.
.
building object construction graphs .
.
object construction graphs.
given a target branch bin the target method mt we define its object construction graph g b i n e whereidenotes the set of graph inputs i.e.
the inputs formt ndenotes the set of variables e.g.
fields local variables etc.
andedenotes the set of information flows for constructingone variable based on other variables i.e.
e i n i n .
more specifically an object construction graph describes what descendant object attributes are relevant state variables for exercising a branch and how to construct a child node i.e.
variable based on its parent nodes variables .
figure a shows an object construction graph for the target method in listing .
the graph inputs i are represented as rectangles in grey.
the variables n are represented as rectangles in red green and blue colors representing fields or get field operations array elements or get array index operations and intermediate local variables or invoke call method operation such as player .
the flow from player toaction means that the return value of calling the player method serves as an input for anaction get field operation.
moreover the leaf nodes target accessed via method gettarget called on action in method checkrules actor accessed via method getactor index accessed via method player called on gamestate and action accessed via method getaction called on the actor object are the relevant data control dependent attributes for the target branch.
explicitly setting these attributes in the tests improves the effectiveness of sbst as it allows the search to evolve these values towards values that satisfy the target branch condition.
in addition given an operand in a branch and its relevant object input we need to know how to access or transform the operand from an object input to synthesize test code.
to this end we also regard each node in an object construction graph as an operation serving as a micro function which takes at least one input and generates one and only one output.
for example in figure the players node to which the parent state node points can be considered either as a variable representing an attribute of state object or as an operation taking the state object as an input and generating the players attribute as output.
the operation view on the graph nodes allows us to generate code based on the graph.
in this regard each operation is similar to an instruction in an intermediate representation form e.g.
java bytecode and the flow between the operations represents how the output of an operation serves as the input of another operation.
thus a node in the graph 1071graph based seed object synthesis for search based unit testing esec fse august athens greece if icmpeqaload state getfield players aaload index getfield action invokevirtual player iconst 1invokevirtual player invokevirtual getaction aload actor if null if nullaload actor aload target invokevirtual getactor invokevirtual gettarget astore actor astore target getaction ireturniload id ireturnplayer other instructionslegend method input field array element method information flow extended flow target branchaload action aload this aload this figure a partial graph of sliced program dependency graph on the target branch represented by the if icmpeq instruction.
each node represents an instruction and each edge represents the producing consuming relation between the instructions.
can represent both an operation and its output variable.
each leaf nodenlindicates a variable reachable from a graph input and it is data control dependent on the operands of the target branch b. .
.
constructing object construction graphs.
overall constructing an object construction graph ocg takes three steps.
first given a target branch bin the target method mt we takebas a slicing criterion and slice a partial graph from the program dependency graph of mt which captures the interprocedural controland data dependencies.
second on the partial graph we identify relevant state variables of object inputs of mtand add information flow for objects across method calls.
finally we remove irrelevant paths to the state variables in the partial graph resulting in an ocg of branchbinmt.
graph slicing.
backwards slicing starts from the target branch b and ends at instructions satisfying one of these conditions an instruction which reads a method input an instruction which reads a global variable e.g.
static field in java and an instruction with no incoming flow.
here the method inputs of mtinclude both its parameters and accessed instance fields.
when slicing interprocedural information flow we introduce a threshold tdepto control the depth of the call graph hierarchy to limit the performance overhead.
that is once there is a call chain from mttomk for example mt m1 ...mk we letk tdep.
figure shows the sliced partial graph based on the target branch in listing .
for simplicity we use java bytecode a stack based instruction architecture as intermediate representation in this example.
note that our approach is applicable in more general cases e.g.
register based instruction architecture as llvm just as well.
in figure each rectangle represents an instruction and each edge represents the dataflow between the instructions specifically how a temporary variable is produced by one instruction and consumed by another.
for example an invokevirtual instruction e.g.
getaction produces a temporary variable as its returnedvalue which is consumed as an operand of the target branch represented as an if icmpeq instruction.
we refer to the jvm documentation for more details on the semantics of java bytecode.
relevant state variables and interprocedural analysis.
we use the descendant fields of an object input as its state variables.
in an object oriented program a branch can be covered only if an object is in a specific state e.g.
the array elements in a stack object players field in a gamestate object and actor field in a action object .
we consider the instance fields and their descendant array elements as the state variable of an object.
therefore when we track the instruction reading a field e.g.
a getfield instruction or an array element e.g.
an aaload instruction and keep them as a node in the graph representing a relevant state variable i.e.
field or array element is required in certain object input.
in addition in order to track all the relevant state variables across method calls to the target branch we extend the object relevant flow across method calls to preserve complete information flows.
when a method mcis invoked by the method ma we analyze how the descendant fields of mc s caller object and method parameters defined inma are used in mc.
thus we can track the relevant state variables used in mcback to the caller method ma.
for example in figure the player method2is called from the object state of type gamestate .
in such a call the players field in the state object input will be used to compute the returned value which is in turn used to calculate the operand of the target branch.
a lightweight alias analysis allows us to track the object produced byaload state in grey in the target method to the object produced by aload this in the player method.
thus we can extend the information flow from aload state togetfield players in the player method.
we use a dashed curve line in figure for the extended information flow.
similarly we also extend the information flow from aload actor togetfield action in the getaction method.
2note that the method player is called in line and line in the target method in listing .
given they are called in different call sites we use different subscripts to distinguish them.
1072esec fse august athens greece yun lin you sheng ong jun sun gordon fraser and jin song dong distilling relevant paths.
finally we further reduce the partial graph by only keeping the paths starting with a method input and ending with an instruction reading a field or array element .
note that our interprocedural graph slicing can produce a path ending at a operand and starting at an instruction reading a constant e.g.
iconst 0 .
given that we cannot modify such a constant when generating a test such a path is irrelevant to generate a test template.
moreover we also remove the aliased caller object and method parameters during the interprocedural analysis e.g.
the aload this instruction in the player method as their flow information has been duplicated with the extended interprocedural flow.
figure a shows an example.
as a result each path in the resultant ocg indicates what state variables of an object input are relevant and how to construct an object with the state variables.
for example one path in the resultant ocg is aload state invokevirtual player astore actor aload actor getfield action .
the first instruction is the method input the last instruction is the relevant state variable and the whole path indicates the construction order which we can reverse engineer into source code in the test.
.
graph based test code synthesis in this section we describe how we traverse object construction graphs in order to synthesize test template.
.
.
code skeleton synthesis.
we traverse the object construction graph in a breadth first manner for generating a test template.
overall the traversal start from the nodes corresponding to an object input.
each time we visit a graph node we can synthesize its statements in the test code.
algorithm shows the overall approach which takes an object construction graph gas input and generates a test testas output.
we first initialize the testby calling the target method with random inputs line .
then we select the nodes in top layer of g i.e.
the nodes with no parents and push them into a queue line .
afterwards we use the queue to generate the statements in test in breadth first order line .
note that we keep a map map node statement to track the location of statements in test of each graph node line and line .
each time a node node is taken from the queue we first check whether its code has already been generated.
if it has we find the corresponding code statement s ofnode intestand build the mapping relation between node and s line .
otherwise we check whether all its parent nodes in ghave a corresponding statement in test.
if not we re enqueue node so that we can generate code for its parent nodes first line .
otherwise we generate the statements for node line .
note that the code of node e.g.
a method call cannot be generated if any of its parents are missing e.g.
the object to start the call or its required parameters .
once a new statement is generated in test we further push its children into the queue line .
readers can refer to the links in blue between figure a and figure b to go through the bfs algorithm.
.
.
code element synthesis.
each time we visit a non leaf node nin the object construction graph g we generate a statement s regarding the instruction of n. our transformation from a graphalgorithm test code template synthesis input an object construction graph g output a generated test case test 1test call the target method with random initialization 2nodes top layer nodes in g 3queue.push nodes 4map node statement 5whilequeue is not empty do 6node queue.pop ifnode s code has not been generated then ifall the parent nodes of node have a corresponding statement in testthen s generate statement for node withmap map.push node s t insertsintotest queue.push node.children else queue.push node else 16s find the corresponding statement of node 17map.push node s 18returntest node to a code statement aims to meet the following needs first the generated test code should strictly conform to the dataflow indicated in the ocg.
second when a state variable i.e.
a field or array element in the ocg is private we need to search for the most promising setter getter function for the test code.
dataflow preservation.
in order to preserve the dataflow in the generated test we maintain a node statement map where the keys are ocg graph nodes and values are statements and their defined variables in the test.
overall the generated test consists of the code to prepare the method inputs and call the target method at the end.
thus we do not need to synthesize control flow code in the test.
moreover we track the defined variable of each statement.
for example the statement basicrules basicrules0 new basicrules has a defined variable of basicrule0 .
if a statement does not define a variable e.g.
obj.setaction its defined variable is void.
when visiting a graph node n we first check all its parent nodes nd n1 n2 ... nm in ocg and use the node statement map to locate their corresponding statements code nd code n1 code n2 ... code nm in the test.
each defined variable of codei i plays a role to synthesize the statement of n. given each node is essentially an instruction based on the information flow between the instructions we know what role e.g.
caller object method parameter operand of assignment etc each defined variable plays in synthesizing a new statement.
for the example in figure the graph node player in green depends on the node state and the node actor where the node state is mapped to gamestate gamestate0 new gamestate line and the node actor is mapped to int int2 line .
moreover the flow between instructions allows us to know that state is the caller object and actor is the method parameter.
1073graph based seed object synthesis for search based unit testing esec fse august athens greece thus we generate the statement for the node player as player player1 gamestate0.player actor line in figure b .
note that some graph nodes such as loading or storing a variable e.g.
aaload andastore may not derive new statements.
it is because such instructions generate no additional variable semantically which allow us to reuse generated variable in the test template.
in this case we still map those nodes to an existing statement so that their defined variable can be used in synthesizing the follow up statement in the test.
setting object states.
we use fields to represent the state variables of the method input objects3.
different from the graph nodes such as calling a method synthesizing a statement from a non static and non public field related node is more complex and requires selecting appropriate method calls to get or set the field.
note that there can be multiple public methods to get or set a field in a direct or indirectly way.
first of all when we visit a graph node nrepresenting a non static and non public field f we synthesize a getter method for fifnis a non leaf node and a setter method for fifnis a leaf node.
given the set of methods as m m1 m2 ... mk we sample a candidate method mfrom mbased on an estimate of the likelihood of m s invocation to get or set f. a field accessing node will derive a field setting statement if it is a leaf node and a field reading statement otherwise.
when visiting a node related to an instance field e.g.
with instruction as getfield we must start with an object obj.
first we scan all the methods accessible by objin its class and superclass and build their call graph.
given a path in the call graph p ms ... me wheremsis the starting node and meis the ending node if its ending node mesets the required field we keep it as an interesting path.
for each interesting path p ms ... me we then estimate its likelihood to set the field by the number of method inputs in ms nv which are data dependent by the instruction in meto set the required field and the complexity of p defined as follows .
for each node mi we assigning a score comp mi by heuristically estimating how likely mican callmi 1in the call chain p. for the ending node me the score estimates how likely mecan set the required field.
given a node mi we build its control flow graph.
let the set of branches to access the required method call or field setting instruction be b and the set of total branches b comp mi b b .
as a result we use equation to assign the score for each path where p means the length of p score p nv p 1comp mi p given a method mserving as the starting node for multiple interesting paths p1 ... pn we evaluate its score score m asmax score p1 ... score pn .
finally we sample the methods based on their score and call the selected method to set the field.
figure shows an example where all four methods can set the fieldfdirectly or indirectly.
we build five interesting paths and their score as follows p1 m1 m2 m3 score p1 .
p2 m2 m3 score p2 3here we regard array element as a special form of field of an array object.
public m1 a a b b if .. m2 a m3 b public m2 a a m3 a.getb public m3 b b this.f b.getf public m4 this.f figure an example of setter selection p3 m1 m3 score p3 p4 m3 score p4 p5 m4 score p5 as a result score m1 max .
score m2 score m3 score m4 .
thus we can normalize their score to the sampling probability as p m1 p m2 p m3 .
whilep m4 .
.
.
integration to sbst note that static data control flow analysis and code generation can incur additional runtime overhead which can influence the efficiency of test generation.
in order minimize the incurred runtime overhead we integrate the test code synthesis during the evolution stage using a user defined probability.
it means that if a branch relevant for an object input is trivial i.e.
easy to cover by random test generation in the initialization stage we do not bother to generate test code templates.
we only pay the runtime computational resource on hard branches.
during test evolution we collect the set of uncovered program branchesbafter each iteration and randomly select one branch bfromb.
takingbas the target branch we synthesize tests for b with a probability of papp.
implementation we implemented the proposed approach in the tool evoobj on top of evosuite a state of the art java testing framework.
in evoobj we integrate our approach into three search algorithms i.e.
dynamosa mosa and monotonicga and leave extensible interface to integrate with more search algorithms in the future.
moreover we introduce new configurable options in evoobj to support the introduced new features.
its source code and binaries are available on our website .
note that although our implementation of evoobj depends on the evosuite framework the challenge of synthesizing object inputs exists in any search based testing fuzzing solutions such as randoop and afl .
the idea of evoobj to parse the structure of the object inputs and compute their relevance to uncovered branches is orthogonal to and thus can complement various search algorithms seeding techniques testability transformation and test generation heuristics under many testing frameworks.
1074esec fse august athens greece yun lin you sheng ong jun sun gordon fraser and jin song dong figure distribution of the number of branches experiment we evaluate our approach with the following research questions rq1 can evoobj outperform the state of the art?
rq2 how does evoobj perform with different time budgets?
rq3 how does evoobj perform with different sbst algorithms?
.
experiment setup baseline we choose evosuite as a baseline for comparison.
evosuite supports various object oriented mutations such as randomly initializing java objects and invoking method calls on these objects.
more importantly it integrates many state of the art approaches for testing object oriented programs.
for example it supports useful heuristics such as generating seeds with static and dynamic constants and constructing objects of diversified types to cover challenging branches .
experiment subjects our subject dataset consists of two sources the sf100 dataset and three popular complementary open source java projects.
the sf100 dataset is a standard benchmark for evaluating unit testing which consists of open source java projects.
since some of the projects contained in sf100 are no longer actively maintained we further included the weka jfeechart and jedit projects in our experiments.
these three projects are still well maintained often used in the annual test generation contest thus enhancing the diversity and representativeness of our dataset.
as targets for our experiments we randomly selected java methods from the sf100 dataset and java methods from the three complementary java projects.
figure shows the distribution of the number of branches in the total methods omitting outliers for clarity .
overall the mean number of branches of the sampled methods is .
the median number is the maximum is and the minimum is .
more details of our sampled methods can be found online .
configuration both evosuite andevoobj are configured to run the same three search algorithms i.e.
dynamosa mosa and a monotonic genetic algorithm .
this selection of algorithms covers many single objective optimization test cases test suites as individuals for evolution and different heuristics.
note that single objective approaches calculate a single cumulative fitness value by aggregating the fitness values for all individual coverage objectives of a method class while many objective approaches figure coverage distribution of different configurations the blue color represents dynamosa the red color represents mosa and the green color represents monotonicga the solid line represents evoobj and the dashed line represents evosuite .
consider each branch to cover as an independent objective.
since both approaches try to maximize the coverage their performance can be directly compared using coverage.
dynamosa has been empirically demonstrated to be the best performing evolutionary algorithm in the context of test generation .
performance evaluation we set the overall time budget to seconds for each method.
while generating tests for each method and configuration we record intermediate coverage values every seconds which allows us to compare their coverage performance under various budgets such as 60s 70s ... 190s 200s and observe how the coverage of each approach grows with the increase of the time budget.
given that the common range for unit test generation tools is about minutes we choose the budget of seconds to evaluate the impact of the additional computational effort.
both tools stop when either the budget is used up or branch coverage is achieved.
for each method we run each tool under a configuration for times and then compare the average coverage and time respectively.
we set the bound on call depth tdepto be the maximum length of generated test case to be and the probability to apply object construction technique to be .
.
we run our experiment on nodes on the ncl cloud consisting of nodes with intel xeon e5 cpu of .1ghz and 64g ddr4 memory.
besides we let evoobj andevosuite share the default runtime configurations.
the details can be found on our tool website .
.
rq1 performance of evoobj figure and figure show how evoobj andevosuite are compared with respects to the three sbst algorithms in terms of coverage and time distribution within the runtime budget of seconds.
moreover table shows a detailed coverage comparison of evoobj and 1075graph based seed object synthesis for search based unit testing esec fse august athens greece table coverage performance comparison on different sbst algorithms regarding the budget of 100s 150s and 200s.
coverage performancebudget 100s budget 150s budget 200s dynamosa mosa monotonicga dynamosa mosa monotonicga dynamosa mosa monotonicga evoobj .
.
.
.
.
.
.
.
.
evosuite .
.
.
.
.
.
.
.
.
p value 10e 10e 10e 10e 10e 10e 10e 10e 10e effect size .
.
.
.
.
.
.
.
.
figure time distribution of different configurations the representation is the same as figure .
table runtime overhead on different sbst algorithms approach dynamosa s mosa s monotonicga s evoobj .
.
.
evosuite .
.
.
p value 10e 10e .
effect size .
.
.
evosuite for three specific points in time after 100s we expect to see negative effects of the overhead produced by evoobj after 200s we expect that both tools had sufficient time for the search to converge and 150s is an intermediate point between these two values.
in addition table shows the runtime overhead of evoobj andevosuite given the total second budget.
we apply the mann whitney u test on coverage and calculate the two tailed significance valuepvalue as well as the cohen s d as effect size.
we consider evoobj to outperform evosuite in coverage if evoobj achieves a higher average coverage than evosuite and thepvalue is smaller than .
and evoobj outperforms evosuite in runtime overhead ifevoobj achieves less average overhead than evosuite and thep value is smaller than .
.
overall we observe that evoobj outperforms evosuite in terms of branch coverage with statistical significance for all three algorithms.
this suggests that evoobj explores the structure of object inputs1 public boolean equals object obj if this obj return true if obj instanceof custpayeemodrssequence2 custpayeemodrssequence2 temp custpayeemodrssequence2 obj if custpayeeid !
null if temp.
custpayeeid null return false if !
custpayeeid.equals temp.
custpayeeid return false else if temp.
custpayeeid !
null return false if custpayeeinfo !
null ... ... if sprefid !
null ... else if temp.
sprefid !
null return false ... listing complicated containment relationship uses the branch distance more effectively.
this is more impressive considering the runtime overhead in evoobj for code analysis and synthesis.
moreover we also observe that the coverage runtime improvement on the monotonicga is not so significant as dynamosa mosa we will discuss more in section .
.
next we discuss the negative impact incurred by evoobj .
the most important challenge for evoobj is that large object construction graphs can incur large runtime overhead and may increase the risk for runtime exceptions when constructing the object inputs.
we observe significant runtime overhead when the required object is complicated i.e.
there are many fields and many layers of objects.
in such as a case evoobj constructs a huge object construction graph which leads to a long test case.
the longer the test the more likely it results in unexpected runtime exceptions.
more importantly a huge graph means that synthesizing test templates takes more time at runtime which reduces the number of iterations of the evolutionary algorithm within a limited time budget.
for example listing shows the code of the equals method in thecustpayeemodrssequence class in project ifx framework .
the method compares two objects regarding their attributes layers by layers.
figure shows a part of its object construction graph which consists of nodes and the synthesized test consists of over statements.
note that a node in an object construction graph may correspond to multiple statements.
for example a method call requires preparing the code for all its parameters.
as executing tests with such a length will incur unacceptable runtime overhead our implementation sets a test case length limit of statements.
in contrast evosuite has a default test length threshold i.e.
which avoids long tests.
we further discuss this in section .
.
in order to cover a deeply nested branch a test with sufficient statements to set all the relevant object state is necessary.
evoobj only conducts static taint analysis to track the branch operand back 1076esec fse august athens greece yun lin you sheng ong jun sun gordon fraser and jin song dong custpayeemodrssequence custpayeeinfocustpayeerec custpayeeinfo ...custpayeeinfo choicedfltpmti nfo stdpayee idbillercontact type postaddrpostaddr xferpayeefspayee type fspayee ty pechoicebillretaddr ... ... ... ... ...... figure the object containment relation for the equals method for the custpayeemodrssequence2 class.
the parentchild relationship represents the parent class has an attribute of the child class.
200coverage time budget s dynamosa evoobj mosa evoobj monotonic ga evoobj dynamosa evosuite mosa evosuite monotonic ga evosuite figure the coverage of evoobj andevosuite on different sbst algorithms under the budget from 60s 70s ... to 200s.
to some state variable of an input object which favors completeness over soundness.
a more optimal solution would be to conduct dynamic taint analysis to discriminate some state variable over others thus we can minimize the test case length while preserving the precision.
we will explore this solution in our future work.
finally we observe that evoobj can sometimes be ineffective as some instructions in the computation path cannot be reverseengineered into source code statements.
for example usually a getfield instruction can derive a statement in the test to set or get a field.
however if the field relevant to a branch operand is private and there are no public getters and setters available in the target class our generated test template can be incomplete and thus less effective at facilitating the search process.
.
rq2 search budgets and algorithms figure summarizes the coverage performance of evoobj and evosuite on different sbst algorithms under the budget from 60s to 200s.
in figure the sbst algorithms sharing the same color e.g.
dynamosa algorithm is presented by blue lines mosa algorithm is presented by brown lines and monotonic ga algorithm ispresented by green lines.
moreover the evoobj solutions use solid lines and the evosuite solutions use dashed lines.
generally figure shows that many objective optimization solutions can benefit more from our approach.
our experiment confirms the existing literature in that dynamosa mosa has a better performance than the monotonic ga see the three dashed lines in figure .
in this experiment the average coverage gaps of dynamosa and mosa across different time budget are about .
and .
while that of monotonic ga is only .
.
the results also align with figure and figure in that the advantage ofevoobj on a monotonic ga is smaller than that on dynamosa and mosa.
the monotonic ga is a single objective optimization solution to evolve a test suite on the overall branch coverage while dynamosa and mosa are many objective optimization solutions to evolve test cases regarding each individual branch.
moreover evoobj synthesizes test templates for each branch.
thus improving the branch distance of a single branch may not be well reflected in the overall branch coverage measurement of the monotonic ga algorithm.
hence evoobj aligns with monotonic ga being less effective compared to dynamosa and mosa.
we also observe that the coverage gap between evoobj and evosuite on each algorithm slightly increases during the initial stage of test generation.
for example after 60s the coverage gap is .
.
and .
for dynamosa mosa and monotonic ga respectively.
in contrast the gap increases to .
.
and .
after 100s and finalizes to .
.
and .
after 200s.
we observe that the coverage increase is larger up to around seconds for evoobj andevosuite after which the coverage grows more slowly.
this indicates that the total budget of seconds is sufficient to evaluate method wise unit testing.
.
threats to validity threats to external validity arise from the use of the sf100 dataset as some projects can be obsolete and we observe that some project are not maintained.
to mitigate the risk we include three popular java projects to enhance the diversity and representativeness of the dataset resulting in a dataset of open source java projects.
threats to internal validity may arise from the randomness pf the search algorithms.
to mitigate this threat we evaluated evoobj andevosuite with repetitions on each method.
in the future we will run experiments on more java projects and larger number of iterations for more generalizable results.
related work .
search based software testing search based software testing sbst is an established approach for automating software testing .
the first sbst technique can be traced to miller et al.
s work for generating test cases for functions with parameters of primitive type.
following their work researchers have proposed novel sbst techniques for automating functional testing test case prioritization mutation testing as well as regression testing .
these approaches leverage meta heuristic algorithms to cover various test goals e.g.
branch coverage path coverage use def coverage etc.
with different search strategies hill climbing algorithm 1077graph based seed object synthesis for search based unit testing esec fse august athens greece genetic algorithm etc fitting test representations and the fitness metrics .
readers can refer to survey papers for more details.
.
sbst for object oriented programs search based software testing on object oriented programs is a long standing problem with many different proposed solutions .
wappler et al.
used a tree based representation of method call sequence to ensure that the generated tests are compilation feasible.
arcuri et al.
proposed an approach to address the flag problem via testability transformation caused by container objects such as list andcollections .
sakti et al.
proposed to construct object instances with more diversity to improve upon sbst algorithms.
the state of the art sbst tool evosuite incorporates all of the above techniques.
nevertheless constructing appropriate objects with appropriate attributes remains challenging.
braione et al.
proposed an approach to use object constraints generated by symbolic execution as the search objective but this work is limited by the symbolic execution engine and has only been evaluated on a limited number of java classes.
evoobj uses static analysis to construct object construction graph and generate a test template where mutation brings evolving gradients facilitating the performance of sbst.
aleti et al.
and albunian et al.
investigated the fitness landscape for the sbst application in unit test generation and showed that the most problematic landscape feature is the presence of many plateaus.
the object input problem is a major contributor for these challenging fitness landscapes as traditional fitness measurements are not sensitive to the mutations of changing the object state.
in this work we leverage static analysis to create a shortcut in that landscape so that the measurements such as branch distances can take effect.
.
seed generation technique for sbst seeding refers to the inclusion of external information and solutions into the population of a search algorithm.
rojas et al.
discussed a variety of seeding strategies including the use of static and dynamic constants as seeds for evolution which achieves significant performance improvements.
following their idea anjum et al.
harvest the runtime constants to improve sbst for grammatical evolution.
moreover liu et al.
adopted domain knowledge to construct structural data for fuzzing android native system services.
the idea of ocat is to capture objects at runtime and reuse then during test generation however these objects are deserialized rather than constructed in the generated tests and thus limit possibilities for mutation and maintenance.
an alternative appraoch consists of mining sequences of method calls and information about common usage from existing executions .
in contrast our approach is a general approach for object construction by exploring data and control flow with interprocedural analysis.
moreover our approach is also complementary with existing state of the art seed generation approaches.
.
object construction constructing legitimate complex structural and object inputs to achieve higher coverage is one of the central problems in test generation which applies to many programming languages.
existing solutions include sbst heuristics symbolic execution and separation logics .
sbst heuristics define rules to explore more subclasses and diversify the object construction means .
nevertheless constructing more diversified types of objects can hardly address the issue of constructing legitimate complicated input and answer the questions like which attributes of the object input should be considered?
and how many layers of object attributes should be constructed?
.
symbolic execution and separation logic extract object constraints and solve them by smt solvers but a challenge lies in reconstructing sequences of calls that configure objects according to these constraints.
the sushi approach aims to transform object constraints extracted via symbolic execution into sbst fitness functions and uses search to synthesize test cases.
however so far this approach has only been studied on java classes .
conclusions and future work although search based unit test generation has resulted in mature tools the limited ability of the resulting tests to capture real faults implies a need to further improve sbst techniques.
in order to address this problem we considered the issue of generating complex object instances which is considered an essential factor that affects the challenging fitness landscape in search based unit test generation .
our approach synthesizes seeds by constructing an object construction graph for every branch and then synthesizing a test template based on the graph such that resulting objects are more likely to represent valid objects.
this enables traditional fitness metrics to better guide search algorithms as our experiments confirm.
in future work we will extend our work in the following aspects.
first we will improve the efficiency of the graph based test code synthesis for evoobj by minimizing the generated test cases of large object construction graph integrate our solution into more algorithms e.g.
memetic algorithms and hybrid algorithm and further generalize our experiment.
second we will further investigate evoobj s capability to discover more software faults and integrate it with a set of debugging techniques .
third we will apply our idea of synthesizing structural input in fuzzing scenarios to discover more binary software vulnerabilities .