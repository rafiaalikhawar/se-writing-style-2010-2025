inherent vacuity for gr specifications shahar maoz tel aviv university israelrafi shalom tel aviv university israel abstract vacuity is a well known quality issue in formal specifications studied mostly in the context of model checking.
inherent vacuity is a type of vacuity that applies to specifications without the context of a model.
gr is an expressive assume guarantee fragment of ltl which enables efficient symbolic synthesis.
in this work we investigate inherent vacuity for gr specifications.
we define several general types of inherent vacuity for gr including specification element vacuity and domain value vacuity.
we detect vacuities using a reduction to ltl satisfiability specialized for the context of gr .
we further extend vacuity detection to handle gr specifications that are enriched with past ltl monitors and patterns.
finally we define a novel notion of vacuity core which provides means to localize the cause of vacuity.
we implemented our work and evaluated it on benchmarks from the literature.
the evaluation shows that vacuities are indeed common in gr specifications and that we are able to efficiently detect them and effectively localize their causes.
moreover our evaluation shows that removal of vacuous specification elements may significantly reduce synthesis time.
ccs concepts software and its engineering formal methods .
keywords reactive synthesis gr vacuity acm reference format shahar maoz and rafi shalom.
.
inherent vacuity for gr specifications.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
introduction vacuity is a well known quality issue in formal specifications.
vacuity has been studied extensively and implemented in the context of model checking where one checks whether a system model satisfies a specification and vacuity usually means that some elements of the specification play no role in that satisfaction.
inherent vacuity is a type of vacuity that applies to specifications without the context of an existing model e.g.
ones used for the purpose of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november virtual event usa association for computing machinery.
acm isbn .
.
.
.
roughly a specification is inherently vacuous if one or more of its elements is logically redundant.
inherent vacuity has been studied theoretically very generally in the context of ltl specifications .
however to the best of our knowledge it has not yet been defined implemented and evaluated in any concrete synthesis setup.
gr is an assume guarantee fragment of linear temporal logic ltl that has an efficient symbolic synthesis algorithm and whose expressive power covers most of the well known ltl specification patterns of dwyer et al.
.
gr specifications include assumptions and guarantees about what needs to hold on all initial states on all states and transitions safety and infinitely often on every run justice .
gr has been recently used in several application domains e.g.
to specify and implement autonomous robots control protocols for smart camera networks distributed control protocols for aircraft vehicle management systems and device drivers .
several tools support gr synthesis .
in this work we investigate inherent vacuity for gr specifications.
our first contribution consists of the definition of several types of vacuity for gr specifications including specification elements vacuities and domain value vacuities.
specifically we take advantage of the structure of gr specifications and present case based definitions of vacuous elements and vacuous domain values.
roughly a specification element is vacuous if removing it will not change the semantics of the specification and a domain value is vacuous if it is unreachable in any run that satisfies the specification.
the formal definitions of these vacuity types appear in sect.
.
we further show how to efficiently detect these vacuity types using a reduction to a satisfiability problem over formulas consisting of elements from gr specifications and of their negation.
see sect.
.
it is important to note that inherent vacuity unlike e.g.
unrealizability non well separation is defined not only with regard to the semantics of the specification but fundamentally also with regard to its concrete syntax.
thus two semantically equivalent specifications may exhibit different vacuities.
as a simple example although the formulas p qand p q p q are semantically equivalent the first has no vacuous elements while the second has.
indeed our definitions and algorithms for vacuity detection consider not only the semantics of the gr specification but also its syntax.
we consider it to be a unique and interesting aspect of our work.
detecting vacuity is important but by itself not informative enough.
thus as a second contribution we present means for localizing the cause of the vacuity by computing what we call a vacuity core a locally minimal subset of the specification that is necessary and sufficient for the detected vacuity.
we compute vacuity cores using a delta debugging approach .
see sect.
.
esec fse november virtual event usa shahar maoz and rafi shalom finally we extend the scope of inherent vacuity definitions and detection algorithm to unrealizable gr specifications as well as to specifications that include beyond pure gr elements also past ltl operators monitors and patterns.
these extensions are important because many specifications written during a development process may be unrealizable and because past ltl operators monitors and patterns help engineers write more concise and readable specifications .
see sect.
.
we have implemented all our ideas as an extension of spectra an open source specification language and tool set for reactive synthesis.
we present an evaluation over benchmarks from the literature.
our evaluation shows that vacuity indeed commonly occurs in gr specifications that our algorithms effectively and efficiently detect the different types of vacuity that the vacuity core is effective in localizing the cause of vacuity and that controller synthesis running times are in many cases significantly reduced when a vacuous element is removed from a specification .
see sect.
.
vacuity has been studied in the literature and implemented in model checkers e.g.
.
in the context of synthesis however we are only aware of the theoretical framework of inherent vacuity .
in particular to our knowledge our work is the first to define examine and evaluate inherent vacuity for gr specifications.
note that in the context of model checking vacuity is a property of a specification and a model.
the model may satisfy the specification in a vacuous way.
our context is fundamentally different.
we deal with inherent vacuity which is a property of the specification alone.
vacuity checks are now a standard component in commercial model checkers .
we believe they will become standard components in future synthesizers.
we discuss related work in sect.
.
running example as a running example for this paper we use a lift specification see list.
which has appeared in several variants in previous gr related papers .
the specification is written in spectra format .
we adapted the example by using an integer value to represent the floor number i.e.
variable fin line instead of one boolean variable per floor in order to make the example more concise intelligible and scalable.
the example is small and simple to fit the paper presentation.
in our evaluation we have used larger and more complex specifications taken from benchmarks.
the specification models a controller for a three floors lift.
the lift has three request buttons one on each floor.
requests are represented by environment variables b1 b2 and b3 which may be independently true or false.
the current floor of the lift is represented by the system variable f. the environment is required to initially have no requests line turn off any granted request at the next step lines and keep ungranted requests lines .
the system is required to start the lift on the first floor line and to disallow the lift to move more than one floor at a time line .
the system is also required not to move up when there are no requests line to eventually grant every request lines and to make sure every floor is visited infinitely often lines .
are there vacuous assumptions or guarantees in our example specification?
our tool finds four vacuous guarantees the three1env boolean b1 2env boolean b2 3env boolean b3 5sys int .. f no buttons are initially pressed 8asm !b1 and !b2 and !b3 request is removed when satisfied 11asm g b1 and f next !
b1 12asm g b2 and f next !
b2 13asm g b3 and f next !
b3 request must remain while unsatisfied 16asm g b1 and f !
next b1 17asm g b2 and f !
next b2 18asm g b3 and f !
next b3 lift is initially at lowest floor 21gar f always stay at the same floor or move to an adjacent floor 24gar g f next f and f next f do not move up when there are no requests 27gar g f next f b1 or b2 or b3 eventually grant each request 30gar gf b1 f 31gar gf b2 f 32gar gf b3 f visit every floor infinitely often 35gar gf f 36gar gf f 37gar gf f listing lift controller specification adopted from don t go down when at first floor 2gar g f next f f listing trivial vacuity example guarantees in lines and the guarantee in line .
intuitively removing any single one of these guarantees does not change the specification s semantics.
why are these guarantees vacuous?
our tool also provides a cause for each vacuity in the form of a locally minimal subset of assumptions and guarantees that imply it.
specifically each of the vacuous guarantees in lines is directly implied by one of the guarantees in lines .
the guarantee in line is implied by the conjunction of the guarantees in lines and .
indeed if the lift must be on the first and on the third floors infinitely often it must also be infinitely often on the second floor.
finally we demonstrate an additional vacuity by adding list.
which contains a guarantee that prevents the lift from going down when it is on the first floor.
this guarantee is vacuous because the variable falready has as a minimal value regardless of any assumption or guarantee.
we call such vacuities trivial vacuities.
our tool detects it as a trivial vacuity.
preliminaries .
linear temporal logic ltl we use a standard definition of linear temporal logic ltl e.g.
as found in over present future temporal operators x next u until f finally and g globally and past temporal operator h historically .
for a finite set of boolean variables v acomputation s0s1.. 2v is an infinite sequence of states i.e.
of truth assignments sitov.
we use i to denote that the ltl formula holds at position i 0of .
100inherent vacuity for gr specifications esec fse november virtual event usa we denote by and say that satisfies .
two ltl formulas and are ltl equivalent denoted ltl iff for all computations iff .
one ltl formula implies another ltl formula denoted ltl iff for all computations if then .
an ltl formula is satisfiable iff there is a computation s.t.
.
.
gr and gr realizability ltl formulas can be used as specifications of reactive systems where atomic propositions are interpreted as environment input and system output variables.
an assignment to all variables is called a state.
a strategy for an ltl specification prescribes the outputs of a system that from its winning states for all environment choices lead to computations that satisfy .
a specification is called realizable if a strategy exists such that for all initial environment choices the initial states are winning states.
the goal of ltl synthesis is given an ltl specification to find a strategy that realizes it if one exists.
gr synthesis handles a fragment of ltl where specifications contain initial assumptions and guarantees over initial states safety assumptions and guarantees relating the current and next state and justice assumptions and guarantees requiring that an assertion holds infinitely many times during a computation.
a gr specification sconsists of the following elements x input variables controlled by the environment y output variables controlled by the system x andy copies of input and output variables at next step eassertion overxcharacterizing initial environment states sassertion overx y characterizing initial system states e x y x transition relation of the environment s x y x y transition relation of the system je i ..njustice goals of the environment js j ..mjustice goals of the system.
a gr specification is realizable i.e.
allows an implementation iff the following ltl formula is realizable1 sr e s e g h e s e g e i ..ngfje i j ..mgfjs j .
roughly srmeans that if the environment keeps all initial assumptions then the system should keep all initial guarantees as long as the environment keeps all safety assumptions the system should keep all safety guarantees and in all infinite plays if the environment keeps all justice assumptions the system should keep all justice guarantees.
specifications for gr synthesis have to be expressible in the above structure and thus do not cover the complete ltl.
efficient symbolic algorithms for gr realizability checking and controller synthesis have been presented in .
specifically realizability checking is done in time o nmn2 where nis the size of the state space 2x y. the algorithm of computes winning states for the system i.e.
states from which the system can realize sr. 1we use the definition of strict realizability as defined in and implemented in several gr synthesis tools including slugs and spectra .the semantics of a specification in the context of inherent vacuity was defined as the set of its implementations .
we use here ltl semantics which for gr is the set of computations that srsatisfies formally sr .
this semantics is finer as it determines the set of implementations but not vice versa.
we use a parametrized version of srfor our proofs namely sr p1 p2 p1 g hp3 p4 p1 gp3 p5 p6 .
thus sr sr e s e s i ..ngfje i j ..mgfjs j .
we also use a dot notation to avoid rewriting replacements that remain the same e.g.
sr s g h e s g e .
.
abstract syntax of a specification since vacuity depends not only on semantics but also on syntax in our context it is important to consider variables with multi valued domains and to handle individual specification elements e.g.
initial assertions separately.
we provide an abstract syntax definition of a gr specification inspired by spectra .
definition abstract syntax of a specification .
a gr specification is a tuple spec ve vs d me ms where veand vsare sets of environment and system variables respectively d ve vs doms assigns a finite domain to each variable2 and meandmsare the environment and system modules.
a module is a triplet m i t j that contains sets of initial assertions i in i n safety assertions t tn t n and justice assertions j jn j n 1of the module where i i t t andj j .
the set of elements of module m i t j isbm i gti t i gfji j i .
.
basic symbolic algorithms we describe two basic algorithms that we implemented symbolically and use in our work namely reachability alg.
and a generalized buchi winning region computation alg.
.
we write here in calculus notation the formulas for the two algorithms.
the modal calculus is a fixed point logic .
r f j y.f yk w ji n i j z.n i 1 y. ji z yk equ.
describes states from which one can reach states in fwith a finite path using the transition relation .
equ.
describes states from which there is a path according to that reaches all sets ji n i infinitely often3.
both formulas in equ.
and are interpreted over the transition system with states 2xand transition relation 2x 2x.
we denote with xstates that have a transition entering a state in xaccording to .
explicitly the semantics of xis the set s s x s s .
symbolic algorithms in our context operate on sets of states and transitions over boolean variables xand their primed copy x instead of on their explicit representations.
we operate on assertions using the usual boolean operators.
all operations used in our 2we use formulas with non binary variables without explicitly translating them e.g.
we may write gfx 2where d x without using two binary variables forx.
our implementation fully supports multi valued variables.
3if the set of justices is empty we define one justice that contains all states.
101esec fse november virtual event usa shahar maoz and rafi shalom algorithm reach computes all states that have a path to a set of states given a transition relation.
require a transition relation and a set of states x ensure returns states that reach x r x r while r r do r r r x pred r end while return r algorithm buchiwinregion computes a winning region of a generalized buchi condition given a transition relation and a set of justices.
require a transition relation and a set of justices j ji n i ensure returns winning region of the generalized buchi condition ifj then j end if w w while w w do w w forji jdo start pred w ji w w reach start end for end while return w algorithms are symbolic and have direct implementations using binary decision diagrams bdds with cudd .
we use pred computed symbolically by x prime for states that can enter a state in according to the transition relation .prime translates an assertion overxto an equivalent assertion over x .
existential quantification over x yields an assertion without x that holds iff there exists an assignment to variables inx s.t.
the assertion holds.
defining inherent vacuity for gr intuitively a vacuous element of a specification is a part of it that is redundant in the sense that if we remove it the semantics of the specification will not change.
since we are interested in gr specifications we choose a pragmatic case based approach which takes advantage of the structure of gr specifications.
we require preservation of ltl semantics which ensures that the set of implementations remains unchanged .
we then define several types of vacuities that are applicable to gr specifications.
we consider several cases corresponding to different elements i.e.
members of bme bms of the specification.
for each case we define a set of sub formulas which we call a premise set and another sub formula we call a consequent.
we will then prove that if the premise set implies the consequent the specification element in question is indeed a vacuity.
.
specification elements vacuity we first define an element of a specification as vacuous when its removal from the specification does not change the ltl semantics of the strict realizability formula.
definition vacuous element of a gr specification .
for a specification spec ve vs d me ms and an element v table specification element vacuity types m tv ps v cons v eve ii ie ie i i ve sgt t te te t t ve jgfj j jeie is gt t te ts gfx x je j gfj svs ii is ie is i i vs sgt t ts te ts t t vs jgfj j jsie is gt t te ts gfx x je js j gfj bme bms let srdenote the ltl formula for the realizability of spec see equ.
and let srvdenote the same formula for the specification spec withoutv thenvis vacuous iff sr ltl srv i.e.
the removal ofvdoes not change the ltl semantics of the specification.
we now define types of vacuities for specification elements.
each element whether initial safety or justice element in each module environment or system may be vacuous.
intuitively an element is vacuous when a subset of other elements implies it rendering it redundant.
thus we will define and detect each vacuity type based on a pair a premise set psand a consequent cons whenever the latter is implied by the conjunction of the elements in the former we have a correct vacuity.
table lists six types of vacuities their respective module e stands for environment and s for system their type name under t and their respective premise set and consequent.
for example line of table defines the vacuity of system module safeties vs s a system module safety gtfort tsis vacuous if the conjunction of the propositional parts of all environment and system safeties without it implies its consequent t i.e.
if te ts t ltlt.
remark .
note that safety elements vacuities are defined without the temporal operator g. indeed it would be incorrect to consider implication between safeties with the temporal operator g i.e.
it would not define a vacuity.
consider the specification a a1 b d me ms where aanda1are boolean environment variables d b bme g a g b xa and bms g b b xb xb g b g b xa1 .
in this specification g b b xb xb ltlg b .
the specification is unrealizable but if we remove g b from bmsthe specification becomes realizable because now the system can win by setting b at the initial state.
clearly the semantics has changed.
see for additional examples that guided our definition of vacuity types.
recall the vacuities in the lift specification from sect.
.
we can now explain their types premise sets etc.
example lift example vacuities .
the four vacuities in list.
are of type vs j. their consequent is thus themselves and their premisesets are all the elements of the specification excluding themselves.
the vacuity in list.
is of type vs s. its consequent is thus its propositional part and its premise set is the set of propositional parts of all other safeties in the specification.
we now prove the correctness of table i.e.
that for each of the six formulas vin the table when the premise set implies its consequent the formula is a vacuity.
theorem table element removal preserves ltl semantics .
given a specification ve vs d me ms andv bme bms for the six definitions of premise set ps v and consequent cons v 102inherent vacuity for gr specifications esec fse november virtual event usa presented in table if ps v ltlcons v thenvis a vacuity i.e.
its removal preserves the ltl semantics of the specification.
formally sr ltl srvas defined in definition .
proof.
letme ie te je andms is ts js .
the proof handles each type of vacuity separately.
type ve i letv i bmebe a vacuity of type ve i thenv i ie e x iexand ev x ie i x. sincevis an initial environment vacuity we know that ev i thus e ev i ev and therefore srv sr ltl sr sr. type vs i letv i bmsbe a vacuity of type vs i thenv i is s x isxand sv x is i x. sincevis an initial system vacuity we know that e sv i thus e s e sv and therefore srv sr ltl sr sr. type ve s letv gt bmebe a vacuity of type ve s then t te e x tex and ev x te t x. sincevis a safety environment vacuity we know that ev t thus e ev t ev and therefore srv sr ltl sr sr. type vs s letv gt bmsbe a vacuity of type vs s then t ts s x tsx and sv x ts t x. proving that srv sr ltl sr sr is equivalent to proving that g h e s ltlg h e sv .
note that since s sv then also g h e s ltlg h e sv holds.
conversely let be a computation such that g h e sv .
we now show that for all i we have i h e s which proves that g h e sv ltlg h e s .
for every i either i h e thus i h e s and we are done.
otherwise assume i h e then i sv plus according to the definition ofhwe have i e. sincev gtis a safety system vacuity then e sv t thus i sv t s. preliminary considerations for both types ve jandvs j for justice vacuities of both kinds we show bellow that sr ltl srv by showing both sr ltl srv and srv ltl sr thus we always assume a computation such that either sror srv holds in order to imply the other.
before we discuss both types of vacuities separately we show that it is enough to consider only computations that satisfy e s g e g s. first note that for all e g e we know that sr iff e s e g h e s iff srv.
thus we only need to prove that sr ltl srvfor computations that satisfy e g e. also note that when we assume that srv holds or srholds then sholds because in both cases e s and we focus on computations that satisfy e. similarly we know that g sbecause e g h e s holds in both cases and we focus on computations for which e g eholds.
type ve j letv gfj bmebe a vacuity of type ve j. in order to prove that srv sr x je j gfx ltl sr x jegfx sr it is enough to show that x jegfxiff x je j gfx for all computations e s g e g s. evidently alwaystable unreachable domain values vacuity types m tv ps v cons v e ve ddv var value var ve value d var tevar value s vs ddv var value var vs value d var te tsvar value x jegfx ltl x je j gfx.
since gfjis an environment justice vacuity we know that e s g e g s x je j gfx ltl gfj thus for all computations e s g e g s we know that x je j gfximplies x jegfx.
type vs j letv gfj bmsbe a vacuity of type vs j. for all computations such that x jegfxwe know that srviff e s e g h e s iff sr. otherwise x jegfx and in order to prove that srv sr x js j gfx ltl sr x jsgfx sr it remains to show that x jsgfxiff x js j gfxfor all computations that satisfy e s g e g s x jegfx.
however since gfjis a system justice vacuity we know that e s g e g s x jegfx x js j gfx ltlgfj.
.
unreachable domain values vacuity second we consider unreachable domain values i.e.
values that are unreachable in any controller that realizes the specification as another form of vacuity.
note that this is an extension of the notion of vacuity which is usually defined only w.r.t.
subformulas of a specification.
definition unreachable domain value formula .
an unreachable domain value formula dv var value is the formula gvar value.
we claim that unreachable domain value vacuities as defined in table are indeed vacuities by showing that for ve d resp.
vs d adding dv var value as an assumption resp.
guarantee to the specification does not change its semantics.
theorem semantic eqivalence under unreachable domain value restriction .
given a specification ve vs d me ms and a formula v dv var value of type ve d resp.
vs d such that ps v ltlcons v addingvas an assumption resp.
guarantee does not change the ltl semantics of the specification.
proof.
adding the safety dv var value in both cases would create a new specification in which dv var value is a vacuity of type ve s resp.
vs s .
according to thm.
the new specification is ltl equivalent to the original specification.
.
unsatisfiability as vacuity avoiding vacuous vacuities finally we define unsatisfiable specifications as vacuous.
unsatisfiability is a form of inherent vacuity .
intuitively if the conjunction of all the elements in the specification is equivalent to false the specification is considered vacuous.
formally definition unsatisfiability as vacuity .
for a specificationspec ve vs d me ms consider the formula with the premise set ps bms bmeand the consequent cons .
103esec fse november virtual event usa shahar maoz and rafi shalom algorithm satsatisfiability of initial states a safety and justices.
require andj ji n i ensure returns true iff g n i 1gfjiis satisfiable return buchiwinregion j use alg.
algorithm impjust computes implication of a justice.
require j ji n i andjimp ensure returns true iff g n i 1gfji ltlgfjimpholds return reach buchiwinregion jimp j use alg.
the specification has a vacuity of type v if it satisfies the requirement ps ltlcons i.e.
if bms bme ltl .
defining unsatisfiable specifications as vacuous allows us to avoid the many additional meaningless vacuities one may find in this case.
for example in a specification with seven elements such that the conjunction of three of which equals false up to four elements may be trivially found vacuous because of the unsatisfiability of the specification regardless of their content.
to avoid reporting these vacuous vacuities pun intended when a specification is unsatisfiable we define it as vacuous and avoid looking for vacuous elements in it.
detecting vacuities we now describe how we detect the different types of vacuities defined in the previous section.
we continue with the overall algorithm for detecting all the vacuities in a given specification.
finally we discuss correctness and complexity.
.
detecting specific types of vacuity .
.
detecting initial assertions safeties and domain vacuities.
the premise sets and consequents of vacuities of types ve i vs i ve s vs s ve d and vs d namely initial assertions safeties and domain vacuities of both environment and system modules include no ltl operators.
thus in order to detect them we simply use propositional implication which in our settings is implemented symbolically using bdds.
.
.
detecting unsatisfiability.
for the unsatisfiability of a specification vacuity of type v we consider an algorithm for the satisfiability of formulas of the form g i ..ngfjiover boolean variablesx.
this is easily reducible to the buchi winning region problem in state space 2x by checking that the winning region intersects the initial states i.e.
that w ji n i .
this yields alg.
.
.
.
detecting justice vacuities.
for vacuities of types ve jandvs j we check implications of the form g i ..ngfji ltl gfjimp.
this implication is equivalent to the unsatisfiability of g i ..ngfji fg jimp which is reducible to the buchi winning region problem by computing states r w jimp ji n i and checking that they do not intersect which yields alg.
.
we denote by jimpthe restriction of to states in jimp namely s s s jimp .algorithm vacuities finds all vacuities of a specification.
require spec ve vs d ie te je is ts js ensure returns the set of all vacuities of spec spec ie is spec te ts if sat spec spec je js then use alg.
return end if vac for ie isdo if ps cons then see tbl.
for psandcons def.
add tovac end if end for for te tsdo if ps g cons g then see tbl.
for psandcons def.
add g tovac end if end for forj je jsdo psj je j j je je js j j js if impjust spec spec psj j then use alg.
add gfjtovac end if end for forvar ve vsdo forvalue d var do dv gvar value if ps dv cons dv then see tbl.
for psandcons def.
add dvtovac end if end for end for returnvac .
putting it all together detecting all vacuities in a given specification algorithm finds all vacuities in its input specification spec .
if the specification is unsatisfiable we return as the only vacuity lines see def.
.
otherwise we go through all initial assertions lines safety assertions lines justices assertions lines and domain values lines and check for vacuities according to vacuity types defined in tables and .
.
correctness and complexity the correctness for detecting initial assertions safeties and domain vacuities is immediate.
for the correctness of detecting unsatisfiability and justice vacuities note that alg.
and are symbolic implementations of well known algorithms .
alg.
is correct because alg.
is correct and because it verifies that there are states in from which we can visit all justices infinitely often.
in alg.
we use a direct reduction of the implication of justice jimpto the generalized buchi condition.
lemma proves the correctness of the reduction.
lemma .
let jifor all i n andjimpbe propositional formulas over variables x and let be a propositional formula overx x .
then4 g n i 1gfji ltlgfjimpiff r w jimp ji n i .
4we use set and logic notations interchangeably here e.g.
is both a formula and the subset of 2xwhere the formula holds.
104inherent vacuity for gr specifications esec fse november virtual event usa proof.
r w jimp ji n i iff there is a computation such that and g and fg jimp ltl gfjimpand f n i 1gfji ltl n i 1gfjiiff there is a computation such that g n i 1gfji and gfjimpiff g n i 1gfji9ltlgfjimp finally alg.
is correct because it checks all vacuity types according to their definition.
in terms of complexity measured in symbolic steps detecting initial assertions safeties and domain vacuities requires a number of symbolic operations linear in the number of elements in the specification e bme bms .
alg.
takes o n and alg.
takes o n2 so alg.
and take o n2 .
for alg.
the complexity as measured in symbolic steps is o e2 in lines o e var ve vs d var in lines the conjunction of the only two premise sets requires o e symbolic operations to compute and o m n n2 in lines and .
this is comparable and slightly better than the o mnn2 complexity of realizability checking see sect.
.
.
vacuity cause localization the automatic detection of a vacuity of any type allows the engineer to know that her specification has a redundant element.
however knowing that an element of a specification is redundant may not be enough.
to better understand the detected vacuity and decide what to do with it we provide the engineer with a means to localize the cause of the vacuity.
localizing the cause of vacuities vacuity core.
given a vacuity we define its core to be a locally minimal subset of its premise set that implies its consequent.
formally definition vacuity core .
given a vacuity v a vacuity core ofvis a subset ps v such that ltlcons v but for any strict subset 9ltlcons v .
to compute a vacuity core we apply ddmin which finds a locally minimal subset of a set for a given monotonic criterion.
for each of the vacuities found in lines or of alg.
we minimize its premise set.
the criterion method for minimization is implemented using bddimplication for vacuities found in lines and and using alg.
and alg.
for vacuities found in lines and resp.
unsatisfiability can be viewed as ltl implication of and is thus consistent with our framework.
importantly note that implication is monotonic in the sense that if vis implied by the conjunction of the elements in vis also implied by the conjunction of elements in any superset of .
this satisfies the monotonicity requirement of the ddmin algorithm.
example .
recall the vacuity in line of the specification in list.
.
this is a vacuity of type vs j. we detect it by checking that it is implied by all other elements of the specification its premise set .
then using the ddmin algorithm we find that it is implied by the specification elements in lines and and that it is not implied by any strict subset of this set of elements.
thus this set of three elements constitutes a core for this vacuity.
a vacuity core is a local minimum.
the same vacuity may have different cores of different sizes and ddmin finds one of them.that said a vacuity core is indeed a sufficient and necessary subset of the specification that implies the detected vacuity.
finally in sect.
we empirically show that vacuity cores are in many cases very effective in localizing the cause of vacuities.
trivial vacuities.
a vacuity may be trivial in the sense that it does not depend on any other element in the specification.
a simple example for a trivial vacuity is a tautology e.g.
the guarantee gf x x .
this would be a vacuity in any specification.
interestingly however some trivial vacuities are not tautologies.
for example the guarantee in list.
is a trivial vacuity for the range .. of f but it would not be a vacuity at all if the range was .. .
checking whether a vacuity is trivial is done by checking whether the bdd that represents the assertion of the element and takes into account domain values is .
an exception is a justice that represents a pattern see sect.
.
.
extensions .
vacuities in unrealizable specifications unrealizability is a well known problem in specifications for synthesis.
many specifications written during a development process may be unrealizable.
do unrealizable specifications include vacuities?
defining vacuity for unrealizable specifications requires a careful discussion of the semantics.
the semantics of a specification for reactive synthesis is typically defined as its set of implementations .
accordingly all unrealizable specifications which have no implementations are equivalent.
thus this semantics is not useful for inherent vacuity of unrealizable specifications.
our approach is different.
as we presented in sect.
.
the semantics we use is finer and is defined not as the set of implementations of srbut as the set of computations satisfying sr. since our definition of vacuity preserves the ltl equivalence of sr see theorems and it transfers seamlessly to the unrealizable case removing a vacuous element from an unrealizable specification does not change the set of counter strategies it induces.
intuitively this means that two such specifications before and after removal of a vacuity are different neither in terms of how close they are to realizability nor by their reasons for unrealizability.
for example the specification in list.
which we have borrowed from is unrealizable yet all the vacuities we detect and their causes may contain valuable information for the engineer.
specifically without the guarantees in lines which cause the vacuities in lines the specification becomes realizable and in this case free of vacuities.
finally in sect.
we empirically show that many unrealizable specifications taken from benchmarks that appeared in the literature include vacuities.
.
dealing with auxiliary variables gr has been extended with past ltl formulas already in patterns and monitors .
the extensions are useful and may help engineers write better specifications but their use introduces auxiliary variables that do not appear in the original specification.
auxiliary variables may also be added explicitly.
105esec fse november virtual event usa shahar maoz and rafi shalom it is thus important to note that auxiliary variables do not hinder our ability to detect vacuous specification elements check satisfiability or compute vacuity cores.
our only special treatment for auxiliary variables is to not check them for domain vacuities as we consider this case to be irrelevant.
.
dealing with auxiliary elements patterns allow the engineer to easily express many useful temporal properties as additional assumptions or guarantees although their ltl formulation is not in gr .
for example a response pattern is an ltl formula of the form response p q g p fq which means that whenever poccurs qwill eventually occur as well.
it is thus important to consider vacuities in specifications that include patterns.
defining and detecting vacuity for specifications that use patterns is challenging because their reduction to gr following adds not only auxiliary variables but also auxiliary elements to the specification i.e.
additional initial safety and justice assumptions or guarantees.
these additional elements are not explicit in the specification as written by the engineer and thus any vacuity that may be related to them should not be computed or reported at their level but rather at the level of the pattern that induced them as written by the engineer.
specifically each pattern induces three gr specification elements a justice which is implemented as a part of the respective module and two auxiliary elements one is an initial assertion and one is a safety.
our approach handles auxiliary elements and patterns for all aspects of the vacuities we defined considering patterns as vacuities inclusion in premise sets and vacuity core computations.
we make the special treatment for patterns as detailed below fully transparent to the engineer.
.
.
patterns as vacuities.
for patterns we always use the justice induced by the pattern as the consequent and its auxiliaries are always a part of its premise set.
thus for example the formula response p p which is a trivial vacuity is detected as such because the auxiliary elements of the pattern imply its justice in this case.
.
.
premise sets in the presence of patterns.
when we form premisesets for vacuity element computation we detect the module of each auxiliary element by tracing to the pattern that induced it.
we then classify it based on the premise set definition.
premise sets of initial and safety elements including unreachable domain values ignore auxiliary elements in their premise sets.
.
.
vacuity cores in the presence of patterns.
when a pattern is a part of a premise set of another specification element we bundle all its three elements for core computation.
bundling ensures that the auxiliary elements are counted as one element of the premise set and are not separated when the premise set is split into parts by the ddmin algorithm.
example .
list.
shows a specification for which our tool detects two vacuities and finds each of their cores.
one vacuity is the response pattern guarantee gamma in line .
we detect it because the justice induced by it which is its consequent is implied by the premise set that includes nine elements namely the two auxiliary elements induced by gamma the safety alpha in line1env boolean x 2env boolean y 3sys boolean z 5asm g x alpha 6asm prespondstos x y beta 7gar prespondstos y z gamma a vacuity 8gar prespondstos x z delta a vacuity listing response patterns and cores example and the six elements induced by the patterns beta anddelta in lines and respectively.
the core computation for this vacuity works on a set that has three elements namely alpha the three elements of beta bundled together and the three elements of delta bundled as well.
it finds that given the two auxiliary elements induced by gamma which are not considered for minimization alpha anddelta but not any of them alone are together enough to imply the justice induced bygamma .
thus the tool reports alpha anddelta as a vacuity core ofgamma .
another vacuity is the response pattern guarantee delta in line .
it is a vacuity because of the assumption beta and the guarantee gamma in lines and respectively.
we detect this vacuity because the justice induced by delta which is its consequent is implied by the premise set that includes nine elements the element alpha all six elements induced by beta andgamma and the two auxiliary elements induced by delta .
the core computation works on a set that has three elements one of them is alpha and the other two are each a bundle of the three specification elements induced by beta and by gamma .
the two auxiliary elements of delta are inside the premise set yet not considered for minimization.
the ddmin algorithm detects beta andgamma as a vacuity core of delta .
evaluation we have implemented detection for the different types of vacuity as an extension of spectra based on cudd as a bdd library.
our implementation includes also the computation of vacuity core as an instance of the generic ddmin algorithm implemented in spectra with the performance heuristics described in .
means to run our implementation all specifications used in our evaluation and all data we report on below are available in supporting materials for inspection and reproduction .
we encourage the interested reader to try them out.
the following research questions guide our evaluation.
r1does vacuity appear in specifications and are different types more frequent than others?
r2can vacuity be computed efficiently during development?
r3does vacuity core computation effectively localize its cause?
r4does vacuity removal make controller synthesis faster?
below we report on the experiments we have conducted in order to answer the above questions.
.
corpus of specifications we use the benchmark syntech15 which includes a total of specifications of autonomous lego robots written by 3rd year undergraduate computer science students in a project class taught by the authors of .
out of the specifications in syntech15 we use unrealizable ones which we label syn15u and all realizable ones which we label syn15r .
a similar benchmark from 106inherent vacuity for gr specifications esec fse november virtual event usa table number of vacuities in syntech specifications spec set s h v ve ive sve jvs ivs svs jve dvs d syn15u syn15r syn17u syn17r the same authors syntech17 has specifications.
we use all unrealizable specifications which we label syn17u and realizable ones which we label syn17r .
we further use different sizes of amba to masters realizable and unrealizable specifications in each of the variants of unrealizability described in .
finally we use different sizes of genbuf to senders realizable and unrealizable specifications in each of the variants of unrealizability described in .
.
validation we have implemented an automatic test that removes vacuities found by our algorithm or adds a domain restriction element for domain vacuities see sect.
.
and checks that realizability satisfiability of both modules satisfiability of the specification and well separation all remain unchanged.
the test is reproducible and extensible to any specification in spectra format.
we have also examined dozens of vacuities and their cores and manually checked that their cores imply them and that all of the core elements are indeed required for the implication.
these tests have increased our confidence in the validity of our computations.
.
experiments setup we run all experiments on an ordinary pc intel xeon w cpu .6ghz 32gb ram with windows bit os java 64bit and cudd compiled for 64bit using only a single core of the cpu.
times we report are average values of runs measured by java in milliseconds.
even though the algorithms we deal with are deterministic we performed runs since jvm garbage collection and bdd dynamic reordering add variance to running times.
.
results number of vacuities table presents the number of vacuities found in syntech sets of specifications.
for each set column sshows the number of specifications in the set and column hshows the number of specifications that have at least one vacuity.
all other columns show the number of vacuities per type.
we do not detect and do not report in the table the vacuities in unsatisfiable specifications see sect.
.
.
the results show that vacuities are very frequent in syntech specifications.
of specifications include at least one vacuity.
we observe that the most frequent vacuities are of types ve j vs jand vs d. unsatisfiable specifications are rare.
amba andgenbuf specifications are all satisfiable and contain no domain value vacuities and no trivial vacuities.
this is expected 5the above sets exclude unrealizable syntech15 specifications and realizable syntech17 specifications that are not gr specifications some have system variables in initial assumptions and some have primed system variables in safety assumptions .
6since bdd based implementations performance is sensitive to variable order we note that in all our experiments we used cudd s automatic variable reordering.
this is common practice in the literature.
syn15u sat syn15u all vac syn15r sat syn15r all vac syn17u sat syn17u all vac syn17r sat syn17r all vac specifications .1s 1s 10s 100s 1000s figure running times of satisfiability checks left columns and of finding all vacuities of satisfiable specifications right columns for the syntech sets grouped by increasing ranges in seconds.
because all the variables are boolean and because the specifications were carefully written by experts.
interestingly the specifications do contain many vacuities of type vs sand some of type vs j. for example the realizable amba specification with masters has vacuities of type vs s and vacuity of type vs j. to answer r1 vacuities occur frequently in specifications from the literature.
over of syntech specifications have at least one vacuity.
vacuities of types ve j vs j and vs dare the most frequent.
all amba andgenbuf specifications have vacuities.
.
results running times figure shows the running times for all four syntech sets of specifications.
each set has two columns showing the number of vacuities found up to a growing time limit starting from .
seconds.
the left hand column reports running times of satisfiability checks.
the right hand column reports running times needed in order to find all other vacuities of satisfiable specifications.
the results show that for syn15 specifications computing satisfiability takes less than second and finding all vacuities is always done in less than seconds.
for syn17 specifications seconds are enough in order to compute satisfiability for all but specifications out of and in order to find all vacuities for out of satisfiable specifications.
running times for detecting all vacuities in the amba specifications were on average .
.
.
and .
seconds for to masters resp.
running times for detecting all vacuities in the genbuf specifications were on average .
.
.
seconds for to senders resp.
this growth in running times is expected as the state space in these benchmarks increases exponentially e.g.
inamba by a factor of for each additional master and as the number of elements in the specification increases linearly e.g.
in amba about new elements for each additional master .
to answer r2 satisfiability and finding all vacuities is reached within seconds for all of syntech15 specifications.
within seconds we compute satisfiability and all vacuities for and of syntech17 specifications resp.
107esec fse november virtual event usa shahar maoz and rafi shalom table localization effectiveness spec set tcore size reduction ratio syn15u syn15r syn17u syn17r syn15u syn15r syn17u syn17r vacuities .1s 1s 10s 100s 1000s figure running time of vacuity localization for syntech sets grouped by increasing ranges in seconds.
.
results localization effectiveness table reports localization results for syntech specifications.
given a specification set for each vacuity we first check if it is a trivial vacuity.
for non trivial vacuities we find a core see sect.
.
we report under column tthe number of trivial vacuities found in each specification set.
for non trivial vacuities we report the number of vacuities for each core size with the last column reporting cores of size five or more7.
for example the number in the second row under column 2means that in the syn15r set vacuities had a core of size .
we further report under reduction ratio the percentage of vacuities for which the ratio of the core size to the premise set size8 was at most and .
e.g.
the value in the second row under column means that in the syn15r set for of the vacuities the core size was at most of the premise set size.
the results show that the vacuity core size is less than half of the premise set size for almost all vacuities is less than a quarter for more than of the vacuities and is less than an eighth for more than .
thus a vacuity core is usually very effective in localizing the cause of the vacuity.
in absolute terms cores of sizes and are the most frequent.
large cores of size and higher exist but are relatively rare.
figure shows running times for core computations on syntech specifications.
for syntech15 specifications all core computations take less than seconds.
for each of the syntech17 specification sets all cores are computed within seconds except one.
7note that cores are a local minimum and our algorithm sometimes finds different cores with different sizes so we report the median size of the core on runs.
8we count patterns as single elements in the premise set and in the core see sect.
.
table synthesis time reduction spec set v ve ive sve jvs ivs svs j syn15r .
.
.
syn17r .
to answer r3 vacuity core computations are effective and efficient.
in syntech sets cores are eight times smaller than their respective premise sets in over of the vacuities.
most of the cores are of size or .
core computations take less than seconds for all syntech15 and less than seconds for all vacuities except one in each of the syntech17 sets.
.
results synthesis time reduction table reports median percentage of synthesis running times reduction for all specifications in syn15r andsyn17r for which original synthesis times in spectra is over .
seconds broken down by vacuity types.
column vshows the number of vacuities for which the original synthesis took over .
seconds.
under each vacuity type we show the median percentage of synthesis running time reduction when the vacuity is removed from the specification.
for example the value .
on the second row and rightmost column means that for syn17r specifications whose original synthesis time in spectra was over .
seconds for at least half of vacuities of type vs j removing the vacuous justice guarantee reduced synthesis time by at least .
.
we use to mark cases where there were no relevant vacuities for the vacuity type.
we observe that removing vacuous justice elements for ve jand more so for vs j makes synthesis running times faster.
this is expected as removing justices from the gr winning condition reduces the computations the algorithm has to perform.
these results are encouraging since in realizable specifications vacuities of these two types are very common see sect.
.
.
for other vacuity types we observed only minor effect on running times if any.
again this is expected because for example removing vacuous elements of type ve iandve sdoes not change the game s arena and winning conditions.
results for realizable genbuf andamba specifications which only have vacuities of types vs sandvs j see sect.
.
show a median of and synthesis time reduction for these vacuity types resp.
this is consistent with the results for the syntech specifications.
to answer r4 removal of vacuities of types ve jandvs jhave medians of .
and .
of synthesis running time reduction respectively.
for other vacuity types we observe minor or no difference in synthesis running time.
.
threats to validity we discuss threats to the validity of our results.
first symbolic computations are not trivial and our implementation may have bugs.
to mitigate we performed a thorough validation using all specifications available to us see sect.
.
.
second we have based most of our evaluation on the syntech specifications which were 108inherent vacuity for gr specifications esec fse november virtual event usa created by 3rd year undergraduate cs students with no prior experience in writing ltl specifications.
we further examined specifications from the amba andgenbuf sets.
we do not know if these are representative of specifications engineers would write in practice.
third we did not perform a user study with engineers to examine whether users will find the reported vacuities useful for improving the quality of the specifications they write.
related work vacuity in model checking.
vacuity has been widely studied in the context of model checking .
in this context when one checks whether a system satisfies a specification vacuity usually means that some elements of the specification play no role in that satisfaction.
many different definitions for vacuity exist in this context and they cover different cases.
a classic example for vacuity in model checking is the case where a request grant assertion g r x is satisfied by a system sbecause s g r i.e.
because a request is never made.
note that in the context of model checking vacuity is a property of a specification and a model.
the model may satisfy the specification in a vacuous way.
our context is fundamentally different.
we deal with inherent vacuity which is a property of the specification alone.
some empirical evidence from ibm showed that during the first verification run of a new design of formulas are found to be trivially valid and that trivial validity always points to a real problem in either the design or its specification or environment .
similar empirical evidence for the context of synthesis does not exist.
our work provides a step towards collecting such evidence.
vacuity checks are now a standard component in commercial model checkers .
we believe that they will become standard components in future synthesizers.
vacuity in specifications for synthesis.
fisman et al.
proposed a comprehensive theoretical framework for vacuity in ltl specifications called inherent vacuity.
the framework defines different aspects for vacuity relating e.g.
to the setting closed vs. open systems and to tightening the specification or cleaning it strengthening weakening vs. equivalence .
thus they do not offer a single definition of inherent vacuity but rather a general theoretical parametrized framework.
finally they proved that inherent vacuity detection can be reduced to ltl satisfiability or realizability checks whose complexity is pspace complete and 2exptime complete respectively.
our work is inspired by but follows a pragmatic approach takes advantage of the structure of gr specifications and defines a specific set of practical cases of inherent vacuity for gr that allow efficient detection see sect.
.
.
our setup considers open systems and ltl equivalence.
the use of equivalence allows us to capture vacuities for both realizable and unrealizable specifications.
to our knowledge our work is the first to define implement and evaluate vacuity detection for gr in particular and for specifications for reactive synthesis in general.
finally bloem et al.
present a technique to synthesize nonvacuous systems.
given a specification they show how to synthesize a system that will satisfy the specification non vacuously.
their work is thus very different from ours.
it is not about inherentvacuity.
as in the case of model checking the vacuity they consider is a property of the specification and the synthesized model.
other quality aspects of gr specifications.
some works considered other quality aspects of gr specifications.
one example is the detection explanation and repair of unrealizability see e.g.
.
another example is well separation which detects cases in which the synthesized controller may satisfy the specification by preventing the environment from satisfying the assumptions without satisfying the guarantees.
finally another example is the detection of assumptions that are not necessary for realizability or ones that are not weakest .
the last example may be viewed as a special weakening strengthening case rather than equivalence case of inherent vacuity .
conclusion and future work we presented inherent vacuity definitions and algorithms for gr specifications.
the types of vacuity we detect include vacuous elements and vacuous domain values.
we extended our work with vacuity core which localizes the cause of vacuity.
we implemented our work validated its correctness and evaluated it on benchmarks from the literature including more than realizable and unrealizable specifications of autonomous lego robots from the syntech benchmarks.
the evaluation shows that the different types of vacuity we consider indeed occur in specifications that we detect the different types of vacuities efficiently in acceptable times and that vacuity core is effective in localizing the cause of vacuity.
it further shows that removal of vacuous elements from a specification may significantly reduce synthesis times.
to the best of our knowledge our work is the first to define examine and evaluate vacuity for gr specifications.
our work has important implications to anyone using gr specifications for synthesis.
first we observe that vacuities are common and their presence may hint at problems in the specification.
second we show evidence that removing vacuities of types ve jandvs jmay significantly reduce synthesis time.
thus as we provide efficient means for vacuities detection and localization it is recommended to examine them and consider their removal.
we suggest future research as follows.
first consider a finergrain analysis down to the level of sub formulas i.e.
detecting vacuities within specification elements.
second amram et al.
have recently defined gr an extension of gr specifications with existential guarantees.
gr expressive power is strictly beyond that of ltl so our present work cannot be applied to it as is.
it would be interesting to extend our work on inherent vacuity to gr .