probabilisticdeltadebugging guanchengwang key laboratory of highconfidence softwaretechnologies moe department of computer science and technology peking university beijing pr china guancheng.wang pku.edu.cnruobingshen key laboratory of highconfidence softwaretechnologies moe department of computer science and technology peking university beijing pr china ruobingshen pku.edu.cnjunjie chen collegeof intelligence and computing tianjin university tianjin pr china junjiechen tju.edu.cn yingfeixiong2 key laboratory of highconfidence softwaretechnologies moe department of computer science and technology peking university beijing pr china xiongyf pku.edu.cnluzhang key laboratory of highconfidence softwaretechnologies moe department of computer science and technology peking university beijing pr china zhanglucs pku.edu.cn abstract the delta debugging problem concerns how to reduce an object while preserving a certain property and widely exists in many applications such as compiler development regression fault localization and software debloating.
given the importance of delta debugging multiple algorithms have been proposed to solve the deltadebuggingproblemefficientlyandeffectively.however theefficiencyandeffectivenessofthestate of the artalgorithmsarestill notsatisfactory.for example thestate of the artdeltadebugging tool chisel maytakeupto3hourstoreduceasingleprogram with lines of code while the reduced program may be up to 2times unnecessarily large.
inthispaper weproposeaprobabilisticdeltadebuggingalgorithm named probdd to improve the efficiency and the effectivenessofdeltadebugging.ourkeyinsightis theddminalgorithm thebasicalgorithmuponwhichmanyexistingapproachesarebuilt followsapredefinedsequenceofattemptstoremoveelementsfrom asequence andfailstoutilizetheinformationfromexistingtestresults.toaddressthisproblem probddbuilds aprobabilisticmodel toestimatetheprobabilitiesoftheelementstobekeptintheproducedresult selectsasetofelementstomaximizethegainofthe nexttestbasedonthemodel andimprovesthemodelbasedonthe test results.
weprovethecorrectnessofprobdd andanalyzetheminimality ofitsresultandtheasymptoticnumberoftestsundertheworstcase.
theasymptoticnumberoftestsintheworstcaseofprobddis o n bothauthorscontributed equally to thisresearch.
2corresponding author permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse august 23 28 athens greece associationfor computing machinery.
acm isbn ... .
is smaller than that of ddmin o n2 worst case asymptotic numberoftests.furthermore weexperimentallycomparedprobdd withddminon40subjectsinhddandchisel twoapproaches thatwrapddminforreducingtreesandcprograms respectively.
theresultsshowthat afterreplacingddminwithprobdd hdd and chisel produce .
and .
smaller results and use .
and45.
less time respectively.
ccs concepts software and its engineering software testing and debugging.
keywords delta debugging probabilisticmodel acmreference format guanchengwang ruobingshen junjiechen yingfeixiong andluzhang.
.probabilisticdeltadebugging.in proceedingsofthe29thacmjointeuropean software engineering conference and symposium on the foundations ofsoftwareengineering esec fse august23 28 athens greece.
acm newyork ny usa 12pages.
introduction delta debugging automatically reduces a set of elements while preservingacertainproperty andhasfoundapplicationsinmany domains suchascompilerdebugging regression fault localization isolating the cause effect chain of a failure anddebloatingsoftware toreduce thesize ofa program whilekeeping certaindesiredfunctionalities .
formally deltadebuggingisdefinedasfollows.let xbeauniverse of all objects of interest x f t be a test function determining whether an object exhibits a given property t or not f and x bethesizeofanobject x x.givenanobject x x that x t thegoalofdeltadebuggingistofindanotherobject x xsuch that x is as small as possible and x t i.e.
x preservesthe property.
forexample in compilerdevelopment delta debugging is used to find a smaller program that reproduces a compilation failure.
here xis a universe of programs xis a 881esec fse august athens greece guancheng wang ruobingshen junjiechen yingfei xiong andlu zhang possibly large program that leads a compilation failure and tests whether the compilation failure stillexistsornot.
the state of the art family of delta debugging approaches is builtupontheddminalgorithm .theddminalgorithmviews an object x xas a sequence.
in each iteration ddmin splits x intonsubsequences and tries to remove each subsequence and its complement from x. the number nstarts with and doubles in each iteration.
subsequent approaches in this family assume morecomplexdomain specificstructuresandapplyddmintothe sequences in the structures.
for example hdd assumes the objects have a structure of a tree and applies ddmin only to the sequencesofsiblings.chisel furtherconsidersthedataand control dependency relations between elements in a c program andappliesddmininawaythatwouldnotbreakthedependencies.
however the efficiency and effectiveness of the state of the art deltadebuggingalgorithmsarestillnotsatisfactory.forexample as ourevaluationwillreveallater thestate of the artdeltadebugging tool chisel maytakeupto3hourstoreduceasingleprogram with lines of code while the reduced program may be up to 2times unnecessarily large.
in this paper we aim to improve the effectiveness and efficiency of delta debugging.
our key insight is the ddmin algorithm the centralcomponentofmanyexistingapproaches followsapredefinedsequenceofattemptstoremoveelementsfromtheoriginal object and fails to utilize the information from existing test results.
toaddressthisproblem weproposeaprobabilisticdeltadebugging algorithm probdd.probddbuildsaprobabilisticmodeltoestimate theprobabilityofeachelementtobekeptintheproducedresult.
in each iteration probdd selects a subset of elements to maximize the gain of the next test based on the probabilistic model and tests ifthedesiredpropertyispreservedinthissubset.then probdd updatesthe probabilisticmodelbasedonthe testingresult.
weprovetheresultproducedbyprobddiscorrectandisminimal or minimum if the universe of objects satisfies certain conditions.
we also analyze the asymptotic number of tests under theworstcase.theasymptoticnumberoftestsintheworstcase of probdd is o n which is smaller than that of ddmin o n2 worst case asymptoticnumber oftests.
furthermore we evaluated probdd on40 subjects in twoapplication domains i.e.
trees and c programs by substituting probdd forddminintworepresentativeapproachesforthetwodomains hdd andchisel .thenumberofsubjectsinourevaluation is larger than all recent publications on delta debugging at top venues as far as we are aware.theresultsdemonstratethatprobddsignificantlyimproves boththeefficiencyandtheeffectivenessoftherepresentativeapproachesinthetwodomains.onaverage aftersubstitutingprobdd forddmin hddandchiselproduces59.
and11.
smaller resultswithinthetimelimit respectively.onthesubjectswhere bothversionsfinishwithinthetimelimit aftersubstitutingprobdd forddmin hddandchiseluse63.
and45.
lesstime respectively.
in summary this paper makes the following main contributions.
we propose a novel probabilistic delta debugging algorithm probdd which dynamically learns a probabilistic model to efficiently andeffectivelyreduce asequenceofelements.
weprovethecorrectnessofprobdd analyzetheminimality of its result and the asymptotic number of tests under the worst case.
we evaluate probdd in two application domains demonstrating that probdd significantly improves the representativeapproachesinthetwodomainsinbothefficiencyand effectiveness.
motivating example weuseaprogramminimizationexampletoillustratehowddmin works.
listing 1shows a real program from tensorflow tutorials .letusassumethatthefunctiontype isfaultyandanyvalid invocation to it will result in the same error.
now we would like toreducetheprogramsuchthattheerrorisstillproduced.there are8statementsintheprogram andthegoalofdeltadebugging is tofind a subsequence of statements thatstill invokestype and thus produces the error.
here we use sito denote the statement in linei.
listing example program to be reduced 1import tensorflow as tf 2x tf .
constant .
3b .
4with tf .
gradienttape as tape 5tape .
watch x 6y x 7b tape .
gradient y x 8print type b the ddmin algorithm views the set of elements as a sequence andproceedsastwonestedloops.theouterloopreducesavariable nrepresenting the length of the subsequence to be considered.
the length nstarts from of all elements and reduces by half at each iteration until it reaches .
the inner loop first tests all consecutiveanddisjointsubsequencesoflength n andthentests the complements of these subsequences.
if any test is successful keep only this subsequence.
if a subsequence or its complement has been testedbefore skip it.
the tests that ddmin performs for this example are shown in figure1.
at the end of each row there is a t or an f which means that the error is still produced t or not f .
first nis the two subsequencesof length4 aretested atlines 1and .both testsfail and their complements are all tested so the first outer iteration finishes.second nishalvedas thefoursubsequencesoflength are tested at lines to .
all the tests fail and the tests of their complements also fail so the second outer iteration finishes.
third nis halved as the eight subsequences of length are tested at lines to .
all these tests fail.
then the complements are testedandthecomplementof s3 passesthetestatline21.since thetestpasses theelementsinthecomplementarekeptandthe seven subsequences and their complements need to be tested so the algorithm continues with nas .
however none of the tests forthesevensubsequencessucceed whicharetestedbefore and none of their complements succeed lines so the third outer iterationfinishesandthealgorithmreturns s1 s2 s4 s5 s6 s7 s8 .
the returned set is minimal because it cannot be further reduced byremovingany singleelement from it.
882probabilistic deltadebugging esec fse august athens greece s1s2s3s4s5s6s7s8 1s1s2s3s4s5s6s7s8f 2s1s2s3s4s5s6s7s8f 3s1s2s3s4s5s6s7s8f 4s1s2s3s4s5s6s7s8f 5s1s2s3s4s5s6s7s8f 6s1s2s3s4s5s6s7s8f 7s1s2s3s4s5s6s7s8f 8s1s2s3s4s5s6s7s8f 9s1s2s3s4s5s6s7s8f 10s1s2s3s4s5s6s7s8f 11s1s2s3s4s5s6s7s8f 12s1s2s3s4s5s6s7s8f 13s1s2s3s4s5s6s7s8f 14s1s2s3s4s5s6s7s8f 15s1s2s3s4s5s6s7s8f 16s1s2s3s4s5s6s7s8f 17s1s2s3s4s5s6s7s8f 18s1s2s3s4s5s6s7s8f 19s1s2s3s4s5s6s7s8f 20s1s2s3s4s5s6s7s8f 21s1s2s3s4s5s6s7s8t 22s1s2s3s4s5s6s7s8f 23s1s2s3s4s5s6s7s8f 24s1s2s3s4s5s6s7s8f 25s1s2s3s4s5s6s7s8f 26s1s2s3s4s5s6s7s8f 27s1s2s3s4s5s6s7s8f 28s1s2s3s4s5s6s7s8f figure detailed iterationsofddmin aswecanseefromtheexample thesequenceofattemptsfor ddminispredefinedanddoesnotlearnfrompasttestresults.for example in this example statement s8should not be removed.
however followingthepredefinedorder thestatement s8hasbeen triedtoremove13times andalltheseattemptswouldfail.infact as studied by zeller and hildebrandt the worst case asymptotic number of tests in ddmin is o n2 wherenis the size of the initial set.also thereducedresultcontainssevenstatements whilethe optimal result is s3 s8 containingonly twostatements.
approach fromtheanalysisoftheprevioussection wecanseethatddmin does not learn from the history of test results and could keep removinganelementthoughallhistoricalremovalsofthiselement leadtotestfailures.toovercomethisproblem ourapproachbuilds aprobabilisticmodeltoguidethetestsandupdatestheprobabilistic model based on the test results.
the process continues until the probabilisticmodelpredictswith100 certaintythatasubsequence is the optimal subsequence.
in this way the test history guides future tests through the probabilistic model.
in this section we describe thismodel howthismodelshouldbeupdatedbased onthe test results and howto use this modelto guide tests.
.
the probabilisticmodel .
.
notations.
sinceourgoalistooptimizeddmin wealsoview the input object as a sequence and try to identify a subsequence that makesthe test functionpass.
in otherwords the universe xis an dimensionalbooleanspaceandanobject xintheuniverseis a booleanvector x x1 x2 ... xn wherexi .
herexi indicatesthatthe ithelementisincludedinthesubsequenceand xi indicates that the ith element is excluded from the subsequence.tosimplifythepresentation wealsoviewasubsequence xas a set containing the indexes of the included elements i.e.
i xi so that the set operators such as apply to subsequences.
.
.
the existence of the optimal subsequence.
to simplify the probabilistic analysis we assume two properties of the universe xwhichareoftenassumedordiscussedinexistingwork .
please note the goal of assuming the two properties is to deduce thedesignofourprobabilisticmodel andthecorrectnessandthe time complexityofprobdddo not depend onthe twoproperties.
themonotonypropertysaysthatif xfailsthetestfunction any subsequenceof xfails the test function.
definition .
monotony .
x x x x x x f x f the unambiguityproperty saysthatiftwosubsequencespass the test function theirintersection passesthe test function.
definition3.
unambiguity .
x x x x t x t x x t weshowthattheabovetwopropertiesimplytheexistenceof an optimal subsequence where the test function passes if and only if the elements inthe subsequenceare present.
theorem3.
.
ifauniversexisbothmonotoneandunambiguous there exists an optimal subsequence x such that the following holds.
x braceleftbiggt x x fotherwise proof.letx intersectiontext.
x tx.basedonunambiguity weknow that x t. basedonmonotony we knowthat any superset x ofx makesthetestfunctionpass i.e.
x t.nowlet xbea subsequencethatisnotasupersetof x .ifweassume x t we havex x x by the definition of x which contradicts with the fact that xisnot asuperset of x .therefore x f. .
.
themodel.
nowweproceedtodefinetheprobabilisticmodel.
giventheexistenceoftheoptimalsubsequence x thegoalofdelta debuggingistoidentifyelementsin x .therefore weassignthe element at each index ia bernoulli random variable ito denote whetherthe ithelementisin x ornot.weuseparameter pitodenotetheprobabilityofthe ithelementisin x i.e.
pr i pi.
therefore our probabilistic model is a n dimensional vector of parameters p1 p2 ... pn .
we further assume that the random variables are mutually independent.
this assumption is reasonable because modern delta debuggingapproacheshaveconsideredthedomain specificstructure oftheobjects and if twoelementsdependon eachother e.g.
they can be removed together but cannot be individually removed 883esec fse august athens greece guancheng wang ruobingshen junjiechen yingfei xiong andlu zhang such a dependency are likely to be captured by the outer approach wrappingddmin.whenddminisappliedtoasequence mostofthe elements in this sequence should not depend on each other.
based on this assumption the probability of a vector xbeing equal to x is producttext.
ipxi i pi xi.1thisalsoimpliesthatthedeltadebugging processofour approach stops when each piiseither1or0.
with this model it is easy for us to calculate the probability ofatestresult.forexample theprobabilityof xpassingthetest function is theprobability that noelementin x is excluded from x i.e.
pr x t producttext.
i pi xi.
.
.
prior distribution.
since initially we do not have any knowledge about the individual elements we uniformly set all pito where0 1isahyper parameterofprobdd.therearemultiplewaystodetermine basedonthepropertiesoftheproblem domain.iftheresultsusuallyhaveafixedreductionratio weset to this ratio.
if the reduced subsequences usually have a fixed lengthm wecanset tom n wherenisthelengthoftheinput sequence.
.
update themodel afterasetoftests wewouldliketocalculatetheposteriorprobabilitiesconditionedonthetestresultssoastoguidefuturetestsusing the posterior probabilities.
now assume that we have performed a seriesoftestson x1 x2 ... xmwithtestresults r1 r2 ... rm.we denotetheeventthattesting xireturning ri i.e.
xi ri asti.
then we can calculatethe posteriorprobability of ias follows.
pr i t1 t2 ... tn pr i t1 t2 ... tn pr t1 t2 .. tn a basic method tocalculate the above two joint probabilities is to enumerate the universe of subsequences and sum up the probabilityofasubsequencebeingtheoptimaloneforeachsubsequence consistentwiththeevents.asubsequence xisconsistentwitha test result t x r if x rwhenxis the optimal one.
moreconcretely wedefinethefollowingfunctiontotestwhether asubsequenceisconsistent withthe test results.
con x t1 ... tm braceleftbigg1con x t1 ... con x tm otherwise con x x r braceleftbigg logicalandtext.
x i 0xi 0r t logicalortext.
x i 0xi 1r f basedonthis function we have the following result.
pr i t1 t2 ... tn pr t1 t2 .. tn summationtext.
x x parenleftbig xi con x t1 ... tm jpxj j pj xj parenrightbig summationtext.
x x parenleftbig con x t1 ... tm jpxj j pj xj parenrightbig calculatingtheaboveformulaisatypicalweightedmodelcounting problem we need to sum up the weight of any solution xsatisfyinga constraint con x t1 ... tm and theweightofa solutionistheproductofthe weightofindividualassignmentsto xi i.e.
pior1 pi .
however sofarwe stilllackan efficient algorithmtosolveweightedmodelcounting astate of the artsolver 1in thispaper weassume .often takes thousands of seconds to solve a model of thousands of variables whichistypicalindeltadebugging.thisistooslow to accelerate delta debugging.
alternatively insteadofcalculatingtheposteriorprobabilities conditioned on all test results we calculate the posterior probabilities after every single test and update the model for future calculations.
concretely we update pitopr i t after a testt.
this method ignores the interaction between different tests and is not as precise as the previous one but can be calculated efficiently.
belowwedescribehowtoupdate piforeachi.firstwehavethe following lemma.
lemma .
.
given a subsequence xwherexi .i.e the ith elementispreservedin x then x i i.e.
x and iareindependent.
proof.denote the indexes of elements excluded from xas j1 j2 ... jk.then pr x f pr j1 j2 ... jk and pr x t pr j1 j2 ... jk .
the independence between j1 j2 ... jkand iimplies the independence between x and i. given the above lemma we show how to update pifor eachi.
on the one hand if the test fails the posterior probability is as follows.
pr i x f pr i pr x f i pr x f pr i j pr j xj pi j pj xjxi pr i pr x f pr x f pr i pixi on the other hand if the test passes the posterior probability is as follows.
pr i x t pr i pr x t i pr x t pr i pr x t xi pr i pr x t pr x t pr i pixi basedontheaboveequations weupdatetheparameter pifor eachiafter atest x raccording to the following rules.
piremainsunchangedif the ithelement isincludedin x. piissettozeroifthe ithelementisexcludedfrom xandthe test function passes.
piissettopi j pj xjiftheithelementisexcludedfrom xandthe test function fails.
884probabilistic deltadebugging esec fse august athens greece .
select asubsequence fortesting we first define the gain of a test and then discuss how to maximize the expectedgain.
.
.
the gain of a test.
as we can see from the previous section whenxpassesthetest theprobabilitiesoftheelementsexcluded fromxwould be set to zero i.e.
these elements should not be selected again for testing.
as a result each passed test excludes someelementsfromthefinalresult.tomeasurehowmanyelements atestcanexclude wedefinethe gainofatestonsubsequence x as the number of elements excluded if the test passes and zero otherwise.
gain x xt braceleftbigg ex x xt x t 0 x f herextdenotesthelastsubsequencepassingthetestfunction and ex x xt denotesthesetofelementsnewlyexcludedwhenthetest ofxpasses i.e.
ex x xt i iffxi andpi .
to simplify presentation we would omit the parameter xtif no confusion would be caused i.e.
we would write gain x forgain x xt and ex x forex x xt .
basedontheprobabilisticmodel p1 p2 ... pn wecancalculatethe expectedgainofatest.
e ex x pr x t ex x i pi xi therefore the goal of selecting a subsequence for a test is to selectasubsequence xthat maximizese .
.
.
maximizing the expectedgain.
pleasenotethatsimply selecting the subsequence that has the maximum probability to be equal tox does not necessarily lead to the maximum expected gain because the probability for it to pass the test function may be low.
tounderstandhow to maximize theexpectedgain letusfirst consider a simple situation where all probabilities piare equal.
in this case any subsequence of the same size leads to the same expected gain.
figure 2shows the relation between e and ex x when any piis .
.
as we can see from the figure when we remove more elements the expected gain first increases and then decreases with the maximum at the inflection.
this is becausee is the product of two components ex x and i pi xi.
the first one monotonously increases but the rateofincreasegraduallydecreases.thesecondonemonotonously decreases but the rate of decrease remains the same.
therefore theremustbeapointatwhichtherateofdecreasesurpassesthe rateofincrease whichmaximizesthe expectedgain.
nowletusconsiderthecasewheretheprobabilitiesaredifferent.
the first component ex x is not affected by this change.
the second component i pi xi may lead to different values for different subsequencesofthe same length.to selectthe subsequence with the maximum value we need to exclude the elements whose probabilitiesofbeing in x are the lowest.
based on the above analysis we use the following procedure to findasubsequencethathasthemaximumexpectedgain.remember xtisthe last subsequencethat passesthe test function.
sortthe elements in xtascending bytheirprobabilities pi.
ex x .
.
.
.
.
.
.
.5e figure the relation between e and ex x excludetheelementsonebyonefrom xtbasedontheabove order until the expectedgain begins to decrease.
return the subsequencewiththe highestexpectedgain.
let xbe the subsequence returned from the above procedure.
thefollowingtheoremshowsthat xhasthemaximumexpected gain.
theorem3.
.e e for anyx xt.
proof.uses k to denote the subsequence obtained after removingkelements in step .
first we prove x xt the subsequences ex x whichexcludesthesamenumberofelementsas xbutselectselementsinorderofincreasingprobabilitycannothave a worse expected gain.
second we show the subsequence returned by the algorithm has the highest expected gain among s k where k xt .as a result e e e .the details can be foundinappendix.
s1s2s3s4s5s6s7s8 .
.
.
.
.
.
.
.
1s1s2s3s4s5s6s7s8f .
.
.
.
.
.
.
.
2s1s2s3s4s5s6s7s8t .
.
.
.
3s1s2s3s4s5s6s7s8f .
.
.
.
4s1s2s3s4s5s6s7s8f .
.
.
.
5s1s2s3s4s5s6s7s8t .
.
.
6s1s2s3s4s5s6s7s8f .
.
7s1s2s3s4s5s6s7s8t .
8s1s2s3s4s5s6s7s8f figure iterations ofour algorithm .
revisitingthemotivating example figure3showsapossibletestingsequenceofprobddforthemotivating example.
in figure each odd row represents each test and the selected elements are shown in cells with darker colors.
the last cell of each odd row shows the result of each test.
each even row represents the probability of each element after a test.
the changes are shownincells withdarker colors.
885esec fse august athens greece guancheng wang ruobingshen junjiechen yingfei xiong andlu zhang let us assume that the expected reduction ratio section .
.
is .25andinitiallyallprobabilitiesaresetto0.
.ineachiteration probddkeepsexcludingtheelementwiththelowestprobability untiltheexpectedgainbeginstodecrease.sincetheinitialprobabilities are all equal the selection of the first iteration is effectively random.
probdd excludes s1 s2 s3 ands8and the test function fails so probdd updates the probabilities of the removed elements based onrule at theend ofsection .
.at thesecond iteration probddselectsfourelements withthelowestprobabilities s4 s5 s6 ands7toexclude.inthiscase thetestpasses soprobdddirectly sets the probabilities of the removed elements to zero according to rule .probddsampled s2 s3 and s1 s8 totestatthethirdand fourthiteration respectively.
theyall failed the testand the probabilitiesoftheremovedelementsareupdatedaccordingly.inthe remainingiterations theprobabilitiesoftheremainingelements haveraisedtoalevelsuchthatonlyoneelementcouldbeexcluded at each time and the probability of the removed element would be settoeither0or1basedonthetestresult.finally probddstops whentheprobabilityofeachelementiseither1or0 andreturns s3 s8 .
as we can see from theabove process probdd learnsfrom the historyoftests whenremoving s8fails theprobabilityof s8would be increased and s8would not be repetitively selected for removal.
furthermore intheaboveprocess probddreturnsamuchsmaller result s3 s8 than ddmin.
to reach this result we need to remove s4 s5 s6 ands7 andthefourelementsneedtoberemovedtogether otherwise the error could not be reproduced.
since ddmin uses fixed boundaries to partition subsequences it would never remove the fourelementstogether.onthe other hand probdddoes not usefixedpartitions andcouldpossiblytestanysubsequenceinthe universex.
propertiesofprobdd inthissection wediscusstheefficiency thecorrectness andthe minimalityofthe result.
.
efficiency theorem .
.
given input with size n the asymptotic number oftestsperformed byprobdd is bounded byo n in theworstcase.
proof.first therecanbeatmost npassedtestsaseachpassing test sets the probability of at least one element to .
second it can be shown that there can be at most o n failed tests before the probabilitiesofallelementsareeitherzeroorlargerthan0.
.when theprobabilitiesof all remainingelementsarelarger than0.
the algorithm will test elements one by one so there could be at most o n failedtests left.
the details can be foundinappendix.
pleasenotethatthistheoremimpliesthattheprobddalways terminates.
.
correctness theorem4.
.
thereturnedsubsequence xoofprobddwillalwaysmaintain theproperty i.e.
xo t. proof.letxkbeasubsequencewhereallelementswithzero probability after the kth iteration are removed and all elementswith non zero probabilities are kept i.e.
xk i pi and x0be such a sequencebefore thefirstiteration.
we show that xk passes the test function for k and any iteration kduring an algorithm execution i.e.
xk t. first itiseasytoseethat x0istheinputobjectandpassesthe test function.
letusassumethat xkpassesthetestfunction.ifthetestfunction failsin iteration k then only the probabilities of someelements whoseprobabilitieswerenotzerowouldincrease andthus xk xkstill passes the test function.
if the test function passes the probabilities of the removed elements would be set to zero and thusxk 1isthesameasthetestedsubsequenceandpassesthetest function.
puttingtheabovetogether theabovepropertyholds.since xois xkforthelastiteration k weknowthat xopassesthetestfunction.
.
minimality theorem .
.
if monotony holds the output of probdd xois minimal i.e.
x xo x f. proof.letsibetheelementin xobutnotin x.sincexoisthe output we know that pi .
it is easy to seepi j pj xj only when k i pk xk i.e.
there exists a failed test onx where only siis newly removed.
since xois the output we know that x xo x si .
sincesiis not in x we know x x .since x f bymonotonywe have x f. theorem4.
.
if monotony and unambiguity both hold the output ofprobdd xois minimum i.e.
x x xo x f proof.bytheproofoftheorem .
minimum x intersectiontext.
x tx.
since xo t weknow x xo.letusassume x xo.then from theorem .
we know that x f which contradicts the definitionof x .as aresult x xo i.e.
xoisminimum.
evaluation as discussed before many existing delta debugging approaches aredomain specificbasedontheddminalgorithm.specifically a typical domain specific delta debugging approach considers the constraintsinthedomain andappliesddmintosubsequencesof theelementssuchthatthedomain specificconstraintswouldnot beviolated.sinceourgoalistoimproveddmin wewouldliketo understandwhetherandhowmuchprobddoutperformsddmin indifferentapplicationdomains i.e.
whethertheperformanceof adomain specificapproachimproveswhenreplacingddminwith probdd.furthermore wewouldliketoinvestigatehowprobdd compares with activecoarsen which is the only randomizedsearchalgorithmthatcanbeappliedtodeltadebuggingwithin our knowledge.
to sum up our evaluation addresses the following researchquestions.
rq1 howdoesprobddcomparetoddminindifferentapplicationdomains?
rq2 whatisthe impact of the parameterinprobdd?
rq3 how does probdd compare with activecoarsen?
886probabilistic deltadebugging esec fse august athens greece .
experiment setup application domains.
our evaluation considers the following two application domains in each of which we picked the representativedeltadebuggingapproachbasedonddminasthetarget approach.wereplacedtheddmincomponentwithprobddineach target approach andcompared the performance with the original target approach withddmin.
trees.therepresentativedeltadebuggingapproachfortrees is hdd and is often applied to programs where the abstract syntax tree ast ofthe program isavailable.
c programs .therepresentativedebuggingtoolforcprogramischisel whichreliesonboththegrammarof c language and the dependency relations between elements inprograms.
we chose the two domains because they are actively studied in existingdelta debugging research andthere are publicly available implementations of the representative approaches based on ddmin.
to facilitate presentation we call the original hdd with ddmin asd hdd andtheversionwhereddminisreplacedwithprobdd asp hdd.similarly thetwoversionsofchiseliscalled d chisel andp chisel respectively.wealsouse d version andp version if nospecific approach isreferredto.
subjects.
wemainlypickedthesubjectsforevaluatingtheoriginal approachesinexistingpublicationstoavoidselectionbias.more specifically we chosethe following subjects.
trees.
we used subjects in the domain of trees.
we used the publicly available subjects in the benchmark for comparing hdd and perses which are c programs triggeringcrashandcompilationbugsingccandclang.the property to be preserved is to reproduce the reported bug without any undefined behavior.
since these subjects all fall into the application domain of c programs we added xmlreductiontasksfordiversity.wecrawledacorpusof more than xml files from repositories of xml files publicly available on the internet filtered out of those that cannot be parsed and randomly picked xml files as subjects.
the property to be preservedisto keep at least the original test coverage on an xml parser xmllint .
we did not use the benchmark in the original publication of hdd because itisnot publiclyavailable.
c programs .
we used subjects in the domain of c programs.
we used the benchmark for evaluating chisel which includes subjects that are c programs to be debloatedtobeusedinembeddedsystems aswellasthesame 20subjectsusedfortrees.thepropertyforthose10subjects is to compile successfully pass given test cases and contain specificfunctions.thepropertyforthose20subjectstokeep isthe same as that usedinthe applicationdomainoftrees.
intotal weused40subjectsinourevaluation and20ofthemare usedinbothapplicationdomains.thenumberofsubjectsinour evaluation is larger than all recent publications on delta debugging attopvenues asfarasweare aware.
we made full use of cores of the server and the whole process of our evaluation took about hours per core on average 441hoursintotal .metrics.
followingtheexistingwork weusedthree metricstomeasuretheeffectivenessofadeltadebuggingapproach inthestudy i.e.
thesizeof theproducedresult theprocessingtime andthenumberoftokensdeletedpersecond .wemeasuredthesize of the subjects in both domains using the number of tokens.
we measured the processing time in seconds.
the reduction process of each subject has a timeout limit of hours.
if timed out the size of theproducedresultisthesizeofthesmallestobjectinallpassed tests and the processing time is not available.
when calculating the average results we calculated geometric means rather than arithmeticmeansbecausedifferentsubjectsdivergesignificantly onthe three metrics.
process.
toanswerrq1 wefirstrecordedtheoriginalsizeforeach subject.
then we applied both d and p version of the approaches foreachsubjectandrecordedthesizeoftheproducedresultand the processing time.
then we calculated the number of tokens deleted per second.
what s more we calculated the p value of a paired sample wilcoxon signed ranked test given the size of the produced result the number of tokens deleted per second and the processing time of the subjects without timeout on the both p and d version to answer whether our approach achieves significant improvementinbotheffectivenessandefficiencycompared to the originalapproaches respectively.
to answer rq2 we adjusted the values of the only parameter used in probdd i.e.
the initial value of probability .
since this experiment is time consuming we sampled a subset of subjects for this experiment.
considering the diversity of the reduction ratio i.e.
the ratio of the smallest returned size to the original size we sorted the reduction ratio of all subjects and evenly selected 14subjectswiththereductionratiofrom0.005to0.
.these14 subjects are xml xml xml xml clang gcc clang gcc gcc chown .
mkdir .
.
date8.
sort .
andgrep .19astheascendingorderofthereduction ratio.
we ran the first half of subjects in the application domain of trees and the remaining subjects in the application domain of cprograms.wechangedtheinitialvalueofprobability to0.
.
.
.
.
.
and0.
respectively.foreachsetting we measured the results using all the metrics.
since some subjects are timedout wedonotpresenttheresultsontheprocessingtimebut use the number of tokens deleted per second as the main metric for efficiency.
in this rq we did not conduct experiments on all subjectsbecause itwouldtake avery longtime.
to answer rq3 we selected activecoarsen as the representativerandomsearchalgorithmandusedthedefaultsetting inactivecoarsen.thenwecreatedtwoversionsofhddand chiselbyreplacingddminwithactivecoarsen andtherespectiveversionsarecalled a hddanda chisel .thenwecompared the a version and the p version in all subjects in all domains.
theresultsofprobdd chisel andactivecoarsenarealso affectedbyrandomness.toreducetheinfluenceofrandomness we ran all versions affected by randomness times and computed the averageresults.wechose5timesbecausethestandarddeviationof the running results for each subject and each approach is already less than of their corresponding average results.
in rq1 and rq3 we set inprobddto .
.
887esec fse august athens greece guancheng wang ruobingshen junjiechen yingfei xiong andlu zhang table comparisonbetween probdd andddmin summary rip version d version rp valuer s p values tp valuetrpsptprdsdtd trees .
.
.
.
.
.
c programs .
.
.
.
.
.
inthistableandthetablesinthe restofthissection rrepresentsthesizeoftheresults srepresentsthenumberoftokensdeletedperseconds trepresentstheprocessing timeinseconds rirepresentsthesizeoftheinput prepresentsthep versions drepresentsthed versions denotestheimprovement where x xd xp xd s denotes the speedup where s sp sd.
in this table all numbers are geometric means and the means of process time are only calculated on the subjects where both p and d versionsfinish withinthe time limit.
implementation.
we introduce the implementations for both applicationdomainsbelow.
trees.
we adopted a recent implementation of hdd inpythonasd hddandimplementedp hddanda hdd ontop ofthis implementation.
c programs .
we adopted the implementation of chisel in c by the original authors as d chisel and implementedp chiselanda chiselontopofit.inparticular thechiselimplementationincludescomponentsfor automaticdeadcodeelimination dce anddependencyanalysis da andwedisabledthesecomponentsbyusingthree command lineoptions i.e.
skip local dep skip global dep and skip dce due to the following reasons.
first dce is designedforprogramdebloatinginchiselanditfailsmost ofthetestsinotherdomains e.g.
compilerbugstriggered by unreachable code.
second we found that the da componentproducesincorrectresultsinsomecases e.g.
whena function call is passed as a parameter which exists in the subjects used in our evaluation.
please note that dce and da are disabledfor allversionsofchisel.
ourevaluationwasperformedonalinuxserverwith16 core thread intel r xeon r gold cpu .7ghz gigabyte ram andthe operating systemofubuntulinux .
.
.
results andanalysis .
.
comparison between probdd and ddmin.
table1shows the overallperformance ofthep and d versions in termsof the three metrics.from table we can see that p versions perform better thand versionsinallmetrics.onaverage p versionsdelete5and14 moretokenspersecondtoobtain59.
and11.
smallerresults thand versionsintheapplicationdomainsoftreesandcprograms respectively.onthesubjectswherebothp andd versionsfinish within the time limit p hdd and p chisel use .
and .
less time respectively.allp valuesare significant .
.
detailedresultsineachapplicationdomain.
wetheninvestigate the detailed results of p versions for each subject in both applicationdomains.table 2showsthecomparisonresultsbetween p andd versions.fromtable thep versionsoutperformthedversions on out of subjects.
here we define the p version outperformsthed versiononasubjectifthep versionhasbetter resultinanyofthethreemetricsanddoesnothaveworseresultin anyofthemetrics.onlyon2subjects mkdir .
.1andgrep .
the p versionperforms worse thanthe d version.
we analyzed the two subjects and found that to preserve target properties we have to keep consecutive subsequences in the returned result.
in other words if we know the element at indextable2 comparisonbetweenprobddandddmin detailed data dsubjectp version d version r s trptpsprdtdsd treesclang .
.
.
.
.
clang .
.
.
.
clang .
.
.
.
clang .
.
.
.
.
clang .
.
.
.
clang .
.
.
.
clang .
.
.
.
clang .
.
.
.
clang .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
c programsmkdir .
.
.
.
.
.
.
rm .
.
.
.
.
.
chown .
.
.
.
.
.
grep .
.
.
.
.
bzip2 .
.
.
.
.
sort .
.
.
.
.
gzip .
.
.
.
.
.
uniq .
.
.
.
.
date .
.
.
.
.
tar .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
iis inx elements at indexes i andi are also likely to be inx .
this contradicts with our independence assumption and thus p chisel does not have better performance.
nevertheless evenonthetwosubjectswhereourindependenceassumptiondoes 888probabilistic deltadebugging esec fse august athens greece trees c programs020406080100 r trees c programs0246810xs a detailedresultdistribution of table 2trees c programs020406080100 r trees c programs0246810xs b detailedresultdistribution of table figure detailed resultdistribution not hold the performance of p chisel is only slightly worse than d chisel.
further weconsiderthevalueslargerthan0and1inthecolumns rand sof table2 and use boxplots to show the distribution as shown in left and right sub figures of figure 4a respectively.
in each box the line that divides the box into two parts represents themedianofthedata theendsoftheboxshowstheupper q3 and lower q1 quartiles the difference between quartiles and is called the interquartile range iqr the extreme line shows q3 .5xiqrto q1 .5xiqr andthe outliersare omitted.
rq1 on average probdd improves hdd and chisel by deleting5and14moretokenspersecondtoobtain59.
and .
smaller results respectively.
on the subjects where both versions finish within the time limit probdd reduces theexecutiontimeofhddandchiselby63.
and45.
respectively.
.
.
impactofthe parameter.
we then investigatethe impactof theonlyparameterinp versions i.e.
theinitialprobabilityforeach element based on the selected subjects in both application domains as presented in section .
.
the results are shown in figure5.theleftsub figuresinfigure 5aandfigure 5bshowthe geometric meansof the produced size while the right sub figures depict the geometric means of the number of tokens deleted per second.
in each sub figure the blue line marks the performance of probdd.also weusedtheredlinetomarktheperformanceofthe originalapproacheswithddminfor clear comparison.
weobservethatthoughdifferent valuescausedeviationsinthe performance the p versions stably outperform the d versions with allstudied values.furthermore theperformancedifferencesbetween different values is significantly smaller than the difference between the p versionsandthe d versions.
rq2 theparameter hasasmallimpactontheperformance of probdd and probdd stably improves hdd and chisel inallparametervalueswe tested.
.
.
compared between probdd and activecoarsen.
table3 shows the overall comparison results between p versions and aversions on all the subjects in the application domains of trees and cprograms.fromthistable p versionsdelete3and21moretokens per second to obtain .
and .
smaller size of producedresult than a versions on average in the application domains of treesandcprograms respectively.onsubjectswherebothversions finish the p versions also use .
and .
less time.
the detailedcomparisonresultsoneachsubjectcanbefoundintable and the distribution of the improvement r and speedup s achievedbyprobddcan be foundinfigure 4b.
rq3 onaverage p versionssignificantlyoutperforma versions bydeleting3and22moretokenspersecondtoobtain58.
and27.
smallerresultsintheapplicationdomainsoftrees andcprograms respectively.onthesubjectswherebothversionsfinishwithinthe timelimit p versionsuse58.
and .
less processing time on the two domains respectively.
.
threatsto validity the threat to internalvalidity mainly lies in the correctness of the implementation of p versions and the experimental scripts.
to reduce this threat we have carefullyreviewedour code.
the threat to externalvalidity mainly lies in the subjects and the target approaches.
regarding the subjects used in our study weadoptedthesubjectsusedinexistingpublicationsforthetwo applicationdomains i.e.
treesandcprograms.besides toincrease the subject diversity in the domain of trees we additionallyevaluatedourapproachon10xmlfiles whichwererandomlypicked fromthecrawledcorpus.inthefuture wewillevaluateprobddon moresubjects.regardingthetargetapproaches weadoptedtwo representative approaches in domains of trees and c programs i.e.
hddandchisel as presentedinsection .
.
thethreatto construct validitymainlyliesinrandomness.the randomness may impact the performance of p versions a versions and d chisel.
to reduce this threat we ran each of them on each subject5timesandcalculatedtheaverageresultsaspresentedin section5.
.
related work delta debugging approaches built on ddmin.
as the basic algorithm for delta debugging ddmin was proposed by zeller and hildebrandt to minimize failure inducing test inputs which has been described in section 1and2.
further they proposed an extended version of ddmin named dd which aims to obtain a 889esec fse august athens greece guancheng wang ruobingshen junjiechen yingfei xiong andlu zhang a impact of intrees b impact of inc programs figure impactof forprobdd table comparisonbetween probdd andactivecoarsen summary rip version a version rp valuer s p values tp valuetrpsptprasata trees .
.
.
.
.
.
c programs .
.
.
.
.
.
minimaldifferencebetweenapassingtestinputandafailingtest inputratherthanaminimal failure inducingtest input .
subsequently someapproacheswrapddminfordifferentdomainspecific structures.
misherghi and su proposed hdd for more effective delta debugging on tree structured data that has been described in section .
inspired by hdd modernized hdd coarsehdd andhddr wereproposedtofurtherimprove theperformanceofhdd.forexample hddrisarecursivevariant ofhdd.sun etal.
proposedperses whichutilizestheformal syntax of a programming language to guide reduction and always produces syntactically valid subsequences.
for each iteration of reduction perses invokes ddmin to prune the nodes in the parse tree for quantified nodes and it proposes replacement strategies forregularnodes.chisel implementedbasedonperses introduces dependency analysis to understand which elements need to be removed together.
chisel also improves ddmin and builds a decision tree model to prune the predefined sequences of ddmin duringthe reduction process.
different from most existing approaches that wrap ddmin for differentdomains ourworkaimstoimproveddminitself.different from ddmin probdd builds a probabilistic model to guide the tests and updates the model based on the test results.
our study has demonstratedthatprobddsignificantlyimprovestheperformance ofrepresentativeapproachesbuiltonddminindifferentapplication domainsbyreplacing ddminwithprobdd.
amongtheexistingapproaches chiselalsobuildsstatistical model to improve ddmin and thus is closely related to our work.
however chisel still relies on the predefined sequence of attempts in ddmin and only uses the statistical model to prioritize attempts in the sequence.
different from it probdd directly selects elements based on the learned distribution.
our evaluation has demonstrated that probdd could significantly improve the performance ofchisel.
delta debugging approaches based on transformation templates.there are some approaches that employ transformation templates to transform an original object.
gtr defines twotransformationtemplatesfortree structureddataandcanautomaticallychoosewhichtemplatetouseinthereductionstepbylearning fromacorpusofexampledata.c reduce wasproposedtosolve the problem of test case minimization which employs plenty of source to source transformations for a more effective reduction on c c and opencl programs.
although these transformationtemplate baseddeltadebuggingapproachescanfurtherimprovethe reductioneffectivenessin theirdomains theysufferfrom the serious efficiency problem based on the existing study .
in thispaper wefocusonsolving theefficiencyprobleminthe existing approaches built on ddmin.
improving the transformationtemplate basedapproachesisfuture work.
blackboxoptimization.
deltadebuggingisablackboxoptimization problem.
bayesian optimization is widely used to solve blackboxoptimizationproblems.itbuildsaprobabilisticmodelandupdates the model with test results .
probdd can be viewed as a bayesian optimization algorithm specifically designed for the deltadebuggingproblem.differentfromtheclassicbayesianoptimization algorithms that are designed for objective functions modeled by gaussian process regression probdd targets the deltadebuggingproblemwith binarytestresults.althoughrecently some bayesian optimization approaches were proposed for binary objective functions they are designed for specific tasks.
furthermore somebayesianapproacheshavebeenproposedfor otherdebuggingtasks e.g.
slicing andfaultlocalization .to ourknowledge thereisnoexistingbayesianoptimizationapproach that can be appliedto solve the delta debuggingproblem.
furthermore heuristic search algorithms such as the genetic searchalgorithms arealsowidelyusedtosolveblackboxoptimizationproblems butsimilartoclassicbayesianoptimization classic heuristic search algorithms rely on continuous fitness functions.sincethetestresultsarebinary howtodesignaneffective fitnessfunctiontoguidethesealgorithmsisanopenproblemfor future research.
the only heuristicsearch approach that can beappliedto delta debugging within our knowledge is activecoarsen .
it aims to find a minimal abstraction in the domain of static analyses 890probabilistic deltadebugging esec fse august athens greece table comparison between probdd and activecoarsen detailed data dsubjectp version a version r s trptp spratasa treesclang .
.
.
.
.
clang .
.
.
.
clang .
.
.
.
clang .
.
.
.
.
clang .
.
.
.
clang .
.
.
.
clang .
.
.
.
clang .
.
.
.
clang .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
gcc .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
xml .
.
.
.
.
c programsmkdir .
.
.
.
.
.
rm .
.
.
.
.
chown .
.
.
.
.
grep .
.
.
.
.
bzip2 .
.
.
.
.
sort .
.
.
.
.
gzip .
.
.
.
.
.
uniq .
.
.
.
.
date .
.
.
.
.
tar .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
clang .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
gcc .
.
.
.
.
usingheuristicsearch.inourevaluation weconsideredactivecoarsenasabaselineandtheresultsthatsuggestthatprobdd outperforms activecoarsen inimproving therepresentative approachesinthe twodomains.
recently xinetal .
alsoproposeasoftwaredebloatingapproach debop that is based on mcmc with metropolis hastings sampling a typical blackbox optimization approach.
however deboptargetsasoftwaredebloatingproblemthatisdifferentfrom the standardone instead of passing a testing function the goalof thisproblemistomaximizeasetofcontinuousobjectivefunctions.
inotherwords thereisnobinarytestfunctionandthusthemcmc algorithm applies.
futurework unlike traditional delta debugging algorithms that search with a pre defined order our approach probdd builds a probabilistic model to estimate the probabilities of the elements to be kept in theproducedresult.
abasic assumptionofthis modelisthateach elementisindependentlyrelatedtothepropertytobepreserved.
however elements may depend on each other due to structural constraintsinthetargetdomain.forexample inatreestructure theexistenceofachilddependsontheexistenceofitsparent.inthis paper weensurethesestructuralconstraintsbybuildingprobdd into existing approaches such that these existing approaches apply probdd to only the subsets that would not violate the constraints.
a more direct way to accomplish this is to directly build these constraints in the probabilistic model.
for example in a tree of two elements we can use two random variables to represent the probability of the parent and the conditional probability of the childwhentheparentispresent.wedonotneedtheconditional probability of the child when the parent is not present because we knowthe probability iszero.this isafuture direction.
conclusion inthispaper weproposeaprobabilisticdeltadebuggingalgorithm probdd whichbuildsaprobabilisticmodeltoestimatetheprobabilityofeachelementtobekeptinthereducedresult.probddselects a subset of elements basedon the probabilistic model to maximize the gain of the next test tests whether the subset maintains the property and improves the model based on the test results.
our algorithmterminateswhenthe learnedprobabilitiesare either1or0.
further we prove the correctness of probdd and analyze the minimalityofitsresultanditsworst caseasymptoticnumberoftests.
we evaluated probdd in two application domains i.e.
trees and c programs.onaverage afterreplacingddminwithprobdd hdd and chisel produces .
and .
smaller results within the time limit respectively.
on the subjects where both versions finish within the time limit hdd and chisel with probdd use .
and .
less time respectively.
the results demonstrate that learns from the test results based on a probabilistic model is a promisingdirection andcallfor future work.
ourtool benchmarks andtheappendixcontainingproofsfor the theorems can be foundat