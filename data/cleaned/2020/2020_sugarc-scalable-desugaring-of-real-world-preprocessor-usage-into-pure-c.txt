ieee acm 44th international conference on software engineering icse sugarc scalable desugaring of real world preprocessor usage into pure c zachary patterson the university of texas at dallas usa zach.patterson utdallas.edu shiyi wei the university of texas at dallas usa swei utdallas.edu abstract variability aware analysis is critical for ensuring the quality of configurable c software.
an important step toward the development of variability aware analysis at scale is to transform real world c software that uses both c and preprocessor into pure c code by replacing the preprocessor s compile time variability with c s runtimevariability.
in this work we design and implement a desugaring tool sugarc that transforms away real world preprocessor usage.
sugarc augments c s formal grammar specification with translation rules performs simultaneous type checking during desugaring and introduces numerous optimizations to address challenges that appear in real world preprocessor usage.
the experiments on desugarbench a benchmark consisting of manually created programs show that sugarc supports many more language features than two existing desugaring tools.
when applied on three real world configurable c software sugarc desugared out of files in the three programs taking at most ten minutes in the worst case and less than two minutes for of the c files.
ccs concepts software and its engineering preprocessors source code generation software product lines.
keywords c preprocessor syntax directed translation desugaring acm reference format zachary patterson zenong zhang brent pappas shiyi wei and paul gazzillo.
.
sugarc scalable desugaring of real world preprocessor usage into pure c. in 44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
zenong zhang the university of texas at dallas usa zenong utdallas.edu brent pappas university of central florida usa pappasbrent knights.ucf.edu paul gazzillo university of central florida usa paul.gazzillo ucf.edu introduction the preprocessor is widely used when developing real world c programs to enable flexible configuration and reuse of the software.
its extensive usage has significant impacts on the performance and reliability of c software.
past studies have shown that bugs exist only under some configurations of the software i.e.
variability bugs and the preprocessor makes bug detection challenging since only one configuration can be tested at a time .
most research on bug detection in configurable c software focuses on a combinatorial testing approach which samples the large software configuration spaces and then applies the testing and analysis techniques on each of the samples.
however the sampling based approach lacks the guarantee of program correctness under all configurations.
this limitation makes a sound static analysis more desirable in many applications.
variability aware analyses have been developed to detect parsing errors type errors and run time defects such as double free errors .
viewing real world c programs as being written in two languages i.e.
c and preprocessor the variabilityaware analyses analyze c software as a whole using data structures that represent the combined language.
however the development of the variability aware analyses as specialty analyses of the two languages makes it infeasible to reuse many existing c static analysis tools which focus on analyzing only c i.e.
variability oblivious tools .
this explains the large gap in terms of bug detection capabilities between the state of the art variability oblivious tools which can perform inter procedural analysis using techniques such as separation logic and model checking and variability aware tools .
as research on variability oblivious analysis marches on variability aware analyses lag behind because they have to constantly maintain parity with the state of the art while supporting the preprocessor which amplifies the engineering effort.
our goal is to close the gap by transforming real world c software that uses both c and preprocessor into pure c code ie.
to desugar unpreprocessed c into a simpler subset of the language.
desugaring converts the preprocessor s difficult to analyze compiletime variability into run time variability represented in pure c. this desugared code can then be analyzed by existing variabilityoblivious tools which do not support unpreprocessoed c or it can be used as a common intermediate representation for developing new variability aware analyses.
2056authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa the key challenge to our approach is that preprocessor usage often has no direct equivalence in c. the transformation tool needs to account for all interactions of the preprocessor with c usage and scale to all variations of the source code created by these interactions.
moreover real world c programs are not ideal having syntactic and type errors in untested configurations an obstacle to correct and complete transformation.
prior work on the desugaring approach has limited support for real world c. c reconfigurator is an effort to conduct variabilityaware verification by transforming a subset of unpreprocessed c constructs.
but it specifies its transformation on an idealized language instead of c as such its implementation lacks support for many common c constructs including structs and some function definitions.
hercules handles unpreprocessed c by traversing abstract syntax trees asts produced by the typechef variability aware c parser and type checker.
hercules transformation is informally described and is also not over the complete c grammar thus its implementation has unsound support for c constructs including structs functions and some expressions .
moreover it relies on the strict assumption that no type errors are present in any configuration limiting its capability on real world c. in this paper we introduce a newly designed desugaring transformation and implement it in a new tool called sugarc that is capable of desugaring real world c programs.
because real world cis not guaranteed to be type safe or even syntactically valid in all configurations our desugarer performs simultaneous type checking and transformation and preserves syntactic and type errors in the desugared output as run time errors.
sugarc is specified as a novel syntax directed translation of unpreprocessed c to pure c where we augment c s formal grammar specification with translation rules.
this approach combines both the soundness of a formal grammar specification and the realism of using c s actual grammar specification.
using c s own grammar makes our support for c constructs explicit as well as for those constructs we intentionally omit such as the now uncommon k r style functions .
sugarc s translation is defined by annotating each grammar construct s production with a semantic action that specifies the translation of that construct and by associating each construct with a semantic value.
we represent semantic values in a data structure called a multiverse that has several generic operators including the product operator.
product simplifies the specification of many transformation rules by encapsulating variation with some constructs such as statements representable as identity transformations over multiverse values.
however naive desugaring of more complex c syntax such as user defined types can cause exponential explosion in the desugared output.
to realize sugarc as a practical tool we employ novel optimizations that improve scalability for constructs such as structs unions and enums declarations which can have multiple variations in real world c. to evaluate support for desugaring c constructs we develop a benchmark we call desugarbench.
it consists of hand created programs covering a wide range of constructs drawn from c s grammar specification.
we evaluate sugarc as well as c reconfigurator and hercules to compare support for unpreprocessed c. while no tool supports all constructs we show that sugarc supports many more constructs especially the kinds of challenging zachary patterson zenong zhang brent pappas shiyi wei and paul gazzillo const bool uint char int x 1 char ifdef uint enar x .
unsigned int x if uint !
char endif printf u n x 1 ifdef char mua y x n75 ch fendie if !
uint char .
printf u n x 2 printf u n x if uint char !
uint !
char type error a unpreprocessed c code.
b desugared code.
figure an example of desugaring unpreprocessed c code.
cases found in real world c. in addition we perform an empirical evaluation of sugarc s scalability to desugar three real world configurable programs axtls toybox and busybox .
sugarc desugared out of files in the three programs taking at most ten minutes in the worst case and less than two minutes for of the c files.
this paper makes the following contributions e the design and specification of a syntax directed translation that simultaneously type checks and desugars unpreprocessed c. section e the realization of our desugarer in a new tool called sugarc that incorporates optimizations for scaling to real world usage of c constructs.
section e a new benchmark suite desugarbench that measures support for desugaring unpreprocessed c. section e an evaluation that compares sugarc with prior work on desugarbench and on three real world c programs that demonstrates the scalability of sugarc.
section significance.
some of the most critical software infrastructures are implemented as highly configurable c programs and this configurability increases the challenges of maintaining software quality while also rendering traditional bug detection and testing infeasible.
sugarc is an important step in developing automated analyses that are capable of scaling variability aware analyses to large real world programs.
it creates the foundation for both leveraging existing variability oblivious analysis tools and accelerating the development of new variability aware analyses to increase the reliability and security of our software infrastructures.
we have made our sugarc specification and implementation desugarbench and all experimental data available .
design of sugarc the preprocessor adds several constructs to c macro definition define and expansion header inclusion include and conditional compilation ifdef .
these constructs have subtle semantics when combined with c. for instance making multiple declarations of the same symbol is not possible in c but is legal in unpreprocessed c. figure 1a has two declarations of x lines and .
sinceauthorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sugarc scalable desugaring of real world preprocessor usage into pure c these declarations are guarded by preprocessor conditionals this program is legal as long as only one of the macros unit or char is defined.
otherwise there will be a type error either an undeclared symbol error on line if neither macro is defined or redeclaration error if both macros are defined .
figure 1b shows the desugared code.
in general sugarc represents c constructs affected by the preprocessor s compile time behavior as equivalent run time c behavior.
configuration macros such as unit and char are represented as const bool c variables line and preprocessor conditionals are desugared depending on their context.
the multiple declarations of x in the unpreprocessed code cannot be within c conditionals because of c s scoping rules and because there is no c syntax for conditionals outside of function bodies.
instead we desugar these declarations of the same symbol as single declarations of different symbols x 1 and x 2 lines and .
then the use of the original symbol x is multiplexed into all of its possible variations guarded by c conditionals lines .
note that our desugarer also represents compile time errors at run time via calls to a parse error or type error function that only applies to the errant set of configurations ensuring all variations of the unpreprocessed source are preserved line .
we specify the desugaring as a syntax directed translation of the unpreprocessed source to pure c. syntax directed translation is a classic transformation technique that works by augmenting a formal grammar with rules guiding the translation .
the translation is defined by annotating each grammar construct s production with a semantic action governing the translation of the construct and associating a semantic value that holds the result of the translation of that construct.
in our case each c construct s semantic action produces a pure c version of all variations of the unpreprocessed construct storing the pure c code as a semantic value.
this approach allows us to use a formal grammar specification to model the effects of the preprocessor while still following the actual grammar of c. our syntax directed translation is specified as a bison grammar with semantic actions.
these semantic actions are read by the underlying parsing framework we use superc in our implementation to generate a parser that dispatches control to the semantic actions after parsing each construct.
sugarc also performs simultaneous type checking during the transformation to preserve type and syntactic errors in the desugared output as run time errors.
this is important for handling real world code because unpreprocessed source code is not guaranteed to be type safe in all configurations.
by type checking during desugaring sugarc is able to weaken the assumption of type correctness for all configurations that prior works hercules and c reconfigurator rely on while still desugaring the typesafe variations of the unpreprocessed source.
preserving these errors in the desugared output ensures that type unsafe configurations are not silently transformed into valid variations of the source code.
.
representing semantic values to record all variations of a desugared construct we use a multiverse object for semantic values.
similar to prior work on variational data structures choice calculus and makefile static icse may pittsburgh pa usa analysis sugarc s multiverse holds a set of values each tagged with a presence condition i.e.
a logical expression that represents the configurations in which the value appears.
we define a multiverse m as a set of n pairs of a source code construct s and presence condition p. m s1 p1 s2 p2 sns pn m is always a finite set because there are a finite number of possible variations of unpreprocessed source code due to preprocessor conditionals.
for example the multiverse for all variations of the variable usage of x in figure 1a on line would be x 1 uint a 3 char x 2 .
uint a char type error uint a char v uint a char to ensure all possible variations of each construct are captured sugarc maintains two invariants of the presence conditions in the multiverse.
first the presence conditions must be disjoint i.e.
each pair of presence conditions should be mutually exclusive.
this reflects the determinism of the preprocessor one configuration yields one variation of the source code.
second the presence conditions must be covering i.e.
the union of the presence conditions is logical true.
this ensures that the transformation will record all variations of the input source code.
the above multiverse satisfies these two invariants because a type error is present if uint and char are both defined or undefined and a variation of x is present when only one of the macros is defined the presence conditions are disjoint and cover all four interactions between the two conditions.
we define several generic operations on multiverses to ease the specification of transformation rules.
the product operator lifts any binary operator such as string concatenation to multiverse operator by taking the cartesian product of all elements in the multiverse.
for instance as part of the transformation for the declarations on lines and in figure 1a the semantic action needs to concatenate the resulting desugarered declarations that are emitted on lines in figure 1b.
since there are two variations each there are four possible variations of their concatenation.
the product of two multiverses a and b over a scalar operator o is defined as follows ax b aob paq v ap a v b q b this formal definition can be found in in the context of makefile analysis albeit it was only implemented for string concatenation in that context.
sugarc however embodies the generic version of this operator automatically lifting string concatenation list concatenation declarator construct composition used when collecting declarations among other operators.
the product operator allows for many semantic actions to be specified as a straightforward identity transform with the multiverse encapsulating correct handling of multiple variations see section .
.
in addition we define new operators including scalar product which allows for one operand to be a scalar value instead of a multiverse filter for trimming elements that have infeasible presence conditions deduplicate for unioning elements with identical values and transfom a unary operator which is effectively a map.authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa .
representing the symbol table sugarc maintains a symbol table for all variations for two reasons.
first it stores the renamings of identifiers since multiple declarations of the same symbol may legally occur in unpreprocessed c code.
second it stores type information so that the desugarer can also perform type checking.
while configuration aware symbol tables and type checking have been addressed in prior work sugarc is the first to perform type checking and desugaring simultaneously which addresses the challenge of handling real world code that has no guarantee of type safety in all configurations.
since we need to preserve all variations of the unpreprocessed source we resolve this by generating a unique renaming for each variation of the symbol.
this enables sugarc to choose the right renaming for the symbol wherever it is used.
in the case of multiple possible renamings sugarc generates a c conditional to ensure each variation of the identifier use is preserved lines in figure 1b .
we define symbol table s as a structure that maps m identifiers v from the unpreprocessed source code to a multiverse of pairs of type ri and renaming ri for each identifier.
s or pr e818 pads v2 pr p2 s ey vm ry ri pi p2 s ds a typical type checker will use the lack of an entry in the symbol table to determine whether a symbol has not yet been declared e.g.
to prevent multiple declarations and use before declaration.
our configuration aware symbol table however may have an entry in some configurations while the symbol has not been declared in others.
to account for this we add special type entries to each symbol s multiverse called undeclared and error.
with these entries the symbol table captures in which configurations the symbol is defined or has a type error.
this ensures that each symbol s associated multiverse of definitions meets the covering invariant.
.
semantic actions for desugaring we use pseudo code to show the semantic actions.
an action s function is named after the grammar construct e.g.
whileloop or declaration while its parameters are the components of the grammar rule.
for instance a whileloop construct has the following context free grammar rule whileloop while expression statement its semantic action function thus has the following pseudo code signature wuiileloop expression statement semantic actions in our implementation have access to global parsing state.
in particular this includes the symbol table for the current scope which is called symtab in the semantic actions below.
we now highlight a few illustrative semantic actions from a variety of constructs.
the complete grammar with all semantic actions can be found in the anonymized released artifact.
zachary patterson zenong zhang brent pappas shiyi wei and paul gazzillo algorithm the semantic action for transforming while loops.
input multiverse values for the expression and statement.
output a desugared while loop as a multiverse.
function wuileloop expression statement return while x expression x statement .
.
statements.
desugaring statements in the unpreprocessed c language involves no more than taking the cross product of all variations of the components of statements.
this is possible because transforming a multiverse of statements only requires surrounding each multiverse element with a c conditional.
algorithm shows the semantic action for while loops.
line defines the semantic action function whileloop which takes expression a multiverse of conditional expressions and statement a multiverse of c statements.
line is the cross product of all component symbols of the whileloop construct including the while keyword and semi colon.
the x product operator lifts the string concatenation scalar operation to all pairs of multiverse elements updating the presence conditions accordingly.
note that scalar semantic values such as while are not multiverses and we use a special scalar product operator to take the product of a scalar and multiverse.
the representation and preservation of all variations of the source program is encapsulated by the multiverse enabling a straightforward definition of the translation rule.
for instance if the expression construct has two variations due to a preprocessor conditional while all other constructs have only one variation.
the repeated applications of the product operator will yield two complete variations of the entire whileloop which are stored as a single multiverse object.
the desugaring of compound statements can be expressed similarly using a lifted concatenation.
in practice this can yield an exponential explosion of variations.
this explosion can be avoided by simply swapping out the semantic value of the compound statement.
instead of using a string our specification using a list of strings and lifts list concatenation instead of string concenation.
this allows for the translation rule to remain simple while improving performance in practice.
.
.
declarations.
handling declarations is more complicated than statements because preprocessor conditionals around declarations are not equivalent to c conditionals due to scoping rules multiple declarations of the same symbol are prohibited and there is no language support for conditionals outside of function bodies.
instead sugarc produces one unconditional declaration for each variation but renames the symbol.
in order to ensure the renaming is applied to all uses of the symbol the symbol table records all variations of the symbol simultaneously.
algorithm shows the semantic action for declarations.
c declarations contain a type specifier which can be primitive types structs unions etc.
and a declarator which can both give the symbol its name as well as declare compound types such as functions and pointers.
the semantic action takes a multiverse of values for the type specifier and declarator.
line first combines the two multiverses into all possible pairs of type specifiers and declarators by 2059authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
sugarc scalable desugaring of real world preprocessor usage into pure c algorithm the semantic action for transforming declarations.
input multiverse values for the typespec and declarator.
output desugared declarations ie.
multiverse of declaration renamings.
function declaration typespec declarator d typespec xp declarator for each name pi d do symtab name uppate symtab name j pi a rename symtab typespec b rename symtab declarator return a x b xt ?
lifting an operator that creates a pair of two elements i.e.
axp b a b p aq v ap a v b.q b lines and update the configuration aware symbol table with each declaration.
conceptually the update operation replaces the prior multiverse entry for the given name pair.
this update needs to account for both redeclaration errors and also ensure that each declaration only affects the configuration defined by the presence condition p .
the function ensures this by conjoining the presence condition p of the new declaration with that of the old pojg.
the uppate function is defined as follows uppattee m 7j pi error pola if told error ti pola a pi undeclared poig a pi toa pod m error poig a pi told pola a pi ift jq undeclared if otherwise there are three cases to consider when updating a symbol table entry if the previous entry was a type error then the entry remains a type error.
if the entry was undeclared then the entry is replaced with the newly given type.
since there may still be some configurations left undeclared the undeclared entry remains under the configurations where the new entry does not overlap i.e.
pola a 7pi.
if the entry was already declared the entry becomes an error in the configurations that overlap between the old and new declarations.
for non overlapping configurations the entry remains the same.
c s type checker has subtle rules for redeclaration not reflected in this pseudo code but are present in our implementation redeclarations are prohibited in the function local scopes but are permitted in the global scope as long as the types are identical which c allows to support having separate function definitions from function declarations in headers .
once the symbol table is updated for all variations of the declaration the action produces the desugared version of each variation lines .
our actual implementation creates a new identifier for each new variation of a symbol s declaration and stores it alongside the type in the symbol table.
we abbreviate the symbol table here for brevity and instead use rename in place of the process of looking up the renamings in the table.
the typespecifier also needs renaming because of user specified type names.
declaration syntax in c is complicated supporting not only variable declarations but also additional specifier syntax for structures unions and enums user defined types typedef icse may pittsburgh pa usa separate declarator syntax specifying compound types functions pointers and arrays lists of declarators in one declaration differences between locally and globally scoped symbols and more.
user defined structures and types have consequences for the scalability of desugaring and we leave a discussion of our optimized handling of these in section .
.
.
.
expressions.
like statements expression translations are also specified with an identity transform.
for instance a binary c expressions take the cross product of each element of the multiverses from the left and right expressions i.e.
left x p right.
unlike statements however expressions have type.
in order to perform typechecking and desugaring simultaneously the semantic value of an expression is a multiverse of pairs s to hold both the desugared expression s and its type t. the product xx p lifts the c construct s operator itself both concenating the desugared expression and checking type compatibility ie.
a x p b a op b top ta th s pag v a ta p a v b th q by this desugaring operation is particularly subtle because the operator is used both as a string value for producing a source translation a op bandas a function type top ta tp .
essentially this product operation takes each combination of variations of the left side and the right side then for each combination produces both the desugared string translation and the result of checking the type compatibility of the operands for the operator.
observe that this formulation gracefully handles type errors since the error type is carried along just for the type unsafe configurations until it can be replaced at the statement level with a type error call.
realizing sugarc in practice using cross products from the ground up and killing parsing error branches would create a correct output.
but this approach would lead to incredibly large desugared source files.
to reduce the resulting size of the transformation and create output that is amenable to static analysis we perform several novel optimizations that make desugaring feasible with real world code.
these optimizations involve the user defined types created by structs unions and enums as well as our design choices for error representation.
.
handling struct union and enum c allows for user defined types in the forms of struct union and enum sue constructs.
the preprocessor usage inside and outside of sue definitions cause complex interactions which have not been properly addressed by past works as they either ignore sue constructs or transform them with the naive combinatorial approach.
but using the strategy of taking a cross product of all possible struct definitions creates a large explosion of desugared variations since real world structs commonly use configurable data types as well as have structs as field members that may themselves have multiple definitions.
as an optimization we represent the fields from all variations of an input struct using a single combined sue specifier when possible.
in figure 2a the preprocessor usage in lines defines two possible types of thissize.
using thissize to declare the field f in struct x the type of f depends on the value of the preprocessor condition wordsi1ze.
figure 2b shows the result of applying sugarc on the code.
because each struct stores its fields 2060authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa if wordsize typedef long int thissize 1 typedef long int thissize typedef int thissize 2 else struct x 3 typedef int thissize thissize 1 f 4 endif thissize 2 f 5 struct x thissize f void foo 4 struct x 3 data 5 void foo if wordsize struct x data data.f data 5.f 4 if !
wordsize data 5.f 5 a struct with a configurable field.
b desugared code.
figure desugaring struct with a configurable field.
in the symbol table presented in section .
getting a member for f would only return mutually exclusive conditions for each possible definition.
this can be seen in figure 2b where data.
f expands into an if statement representing the presence conditions associated with f 4 and f 5 respectively.
multiple conditional sue definitions and forward