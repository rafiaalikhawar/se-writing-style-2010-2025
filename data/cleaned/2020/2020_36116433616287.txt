statemergingwith q uantifiers in symbolic execution davidtrabish tel aviv university tel aviv israel davivtra post.tau.ac.ilnoamrinetzky tel aviv university tel aviv israel maon cs.tau.ac.il sharonshoham tel aviv university tel aviv israel sharon.shoham cs.tau.ac.ilvaibhav sharma universityof minnesota minneapolis usa vaibhav umn.edu abstract we address the problem of constraint encoding explosion which hinders the applicability of state merging in symbolic execution.
speci f ically ourgoalistoreducethenumberofdisjunctionsand if then else expressions introduced during state merging.
the main ideaistodynamicallypartitionthesymbolicstatesintomerging groupsaccordingtoasimilaruniformstructuredetectedintheir path constraints which allows to efficiently encode the merged pathconstraintandmemoryusingquanti f iers.toaddresstheadded complexity of solving quanti f ied constraints we propose a specializedsolvingprocedurethatreducesthesolvingtimeinmanycases.
our evaluation shows that our approach can lead to signi f icant performance gains.
ccs concepts software andits engineering keywords symbolic execution statemerging acmreference format david trabish noam rinetzky sharonshoham and vaibhavsharma.
.
statemergingwithquanti f iersinsymbolicexecution.in proceedingsofthe 31stacmjointeuropeansoftwareengineeringconferenceand symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa 13pages.https introduction symbolic execution is a powerful program analysis technique that hasgainedsigni f icantattentionoverthelastyearsinbothacademic and industrial areas including software engineering software testing programming languages program veri f ication and cybersecurity.
it lies at the core of many applications such as high coverage test generation bug f inding debugging permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forpro f itorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe f irstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspeci f icpermission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn .
crosschecking andsidechannelanalysis .insymbolicexecution theprogramis run with an unconstrained symbolic input rather than with a concrete one.
whenever the execution reaches a branch that depends on the symbolic input an smt solver is used to determine the feasibility of each branch side and the feasible paths are further exploredwhileupdatingtheirpathconstraintswiththecorrespondingconstraints.oncetheexecutionofagivenpathiscompleted thesolverprovidesasatisfyingassignmentforthecorresponding pathconstraints fromwhich a concrete testcasethatreplaysthat pathcan be generated.
a key remaining challenge in symbolic execution is path explosion .statemerging isawell knowntechniquefor mitigatingthisproblem whichtradesthenumberofexploredpaths with the complexity of the generated constraints.
more speci f ically merging multiple symbolic states results in a symbolic state where the pathconstraint is expressed using a disjunction ofconstraints and the memory contents are expressed using ite if then else expressions.
unfortunately theintroductionofdisjunctiveconstraintsand ite expressionsmakesconstraintsolvingharderandslowsdownthe exploration especially when the number of states being merged is high.
consider for example the function memspnfrom section which is based on the implementationof strspninuclibc .
memspnreceives a buffer s the size of the buffer n and a string chars andreturnsthesizeoftheinitialsegmentof swhichconsists entirely of characters in chars.
suppose that memspnis called with asymbolicbuffer s asymbolicsize nboundedbysomeconstant u1d45a andtheconstantstring a .
theexplorationoftheloopatlines results in u1d442 u1d45a symbolic states.
if we merge these symbolic states then the encoding of the merged symbolic state which records among others the path constraint and the value of variable count is of size at least linear in u1d45a.
now suppose that the merged return value ofmemspnis used later for example in the parameter sin anothercallof memspn.inthatcase ifweperformasimilarmerging operation thentheencodingofthemergedsymbolicstatewillbeof sizeatleastquadraticin u1d45asincethemergedvaluepropagatestothe path constraints.
such encoding explosion istypically encountered duringtheanalysisofreal worldprograms thusdrasticallylimiting the effectiveness ofstate merging inpractice.
we propose a state mergingapproachthat reduces the encoding complexityofthepathconstraintsandthememorycontents while 1strspnreceivesnull terminated buffers slightlycomplicatingthe presentation.
esec fse december3 san francisco ca usa david trabish noam rinetzky sharonshoham andvaibhav sharma 1intmemspn char s size t n char chars 2char p chars intcount 3while p count n if p s count p chars else p 9returncount figure motivatingexample.
preservingsoundnessandcompletenessw.r.t.standardsymbolic execution.atahighlevel ourapproachtakesasaninputtheexecutiontree whichcharacterizesthesymbolicbranchesoccurring during the symbolic execution of the analyzed code fragment and dynamically detects regular patterns in the path constraints of the symbolic states in the tree which allows us to partition them into merging groups of states whose path constraints have a similar uniformstructure.this enables us to encode the mergedpath constraints using quanti f ied formulas which in turn may also simplify theencodingof iteexpressionsrepresentingthemergedmemory contents.
we observed that the generic method employed by the smt solvertosolvetheresultingquanti f iedqueriesoftenleadstosubpar performance compared to the solving of the quanti f ier free variant of the queries.
to address this we propose a specialized solving procedurethatleveragestheparticularstructureofthegenerated quanti f ied queries and resort to the generic method only if our approach fails.
weimplementedourapproachontopofklee andevaluated it on real world benchmarks.
our experiments show that our approachcanhavesigni f icantperformancegainscomparedtostate mergingandstandardsymbolic execution.
preliminaries statemerging.
asymbolicstate u1d460consistsof i a pathconstraint u1d460.
u1d45d u1d450 ii asymbolic store u1d460.memthat associates variables2 u1d449with symbolicexpressionsobtainedfromthesymbolicinputs iii and aninstruction counter u1d460.ic.
symbolic states are merge compatible if they have the same instruction counter and contain the same variables intheirstores.
de f inition .
.
the merged symbolic state resulting from the merging of the merge compatible symbolic states u1d460 u1d456 u1d45b u1d456 1is the symbolic state u1d460de f inedas follows u1d460.ic u1d4601.
u1d456 u1d450 u1d460.pc logicalortext.
u1d45b u1d456 u1d460 u1d456.
u1d45d u1d450 u1d460.mem u1d706 u1d463 u1d449.merge var u1d460 u1d456 u1d45b u1d456 u1d463 where the mergedvalueofavariable u1d463isde f inedby merge var u1d460 u1d456 u1d45b u1d456 u1d463 ite u1d4601.
u1d45d u1d450 u1d4601.mem u1d463 ite ... ite u1d460 u1d45b .
u1d45d u1d450 u1d460 u1d45b .mem u1d463 u1d460 u1d45b.mem u1d463 2for simplicity we do not describe the handling of stack variables and heap allocated objects.ourimplementation supports both.statemergingisappliedonagivencodefragment typicallya loop or a function.
once the symbolic exploration of the code fragment is complete the resulting symbolic states are partitioned into merge compatible merging groups.
then each merging group is transformedintoasinglemergedsymbolicstate.finally theresulting merged symbolic states are added to the state scheduler of the symbolic executionengine to continue the exploration.
execution trees.
anexecution tree is a tree where every node u1d45bisassociatedwithasymbolicstate u1d45b.
u1d460andasymboliccondition u1d45b.
u1d450correspondingtothetakenbranchsuchthattheconditions associated with any two sibling nodes are mutually inconsistent and the condition of the root node is true.
the execution tree characterizestheanalysisofanarbitrarycodefragment whichisnot necessarilythewholeprogram.therootnodecorrespondstothe symbolicstatethatreachedtheentrypointofthecodefragment and the leaf nodes correspond to the symbolic states that completedtheanalysisofthecodefragment.
forexample considerthe symbolic execution of memspn section1 with a symbolic buffer s asymbolicsize n and a wherenisboundedby3.thecorrespondingexecutiontreeisdepictedinfigure wherethesymbolic conditionassociatedwitheachnodeisdepictedontheincoming edgeofthenode.the node u1d45b1correspondsto theinitialsymbolic state i.e.
u1d45b1.
u1d460.
u1d45d u1d450 u1d45b the nodes u1d45b2 u1d45b6 u1d45b10 and u1d45b14correspond to paths where siscomprised of only acharacters and the nodes u1d45b5 u1d45b9 and u1d45b13correspondtopathswhere scontainsanon a character.for now ignore the colorof the nodes.
givenanexecutiontree u1d461withroot u1d45f wedenotethesequence of nodes on the path from node u1d45b1to node u1d45b u1d458in u1d461by u1d70b u1d461 u1d45b1 u1d45b u1d458 andwrite u1d70b u1d461 u1d45b u1d458 when u1d45b1istheroot u1d45f.givenapath u1d70b u1d461 u1d45b1 u1d45b u1d458 in u1d461 we de f ine its tree path condition tpc andtree path condition tail tpc tpc u1d461 u1d45b1 u1d45b u1d458 u1d45b1.
u1d450 tpc u1d461 u1d45b1 u1d45b u1d458 tpc u1d461 u1d45b1 u1d45b u1d458 logicalanddisplay.
u1d456 u1d458 u1d45b u1d456.
u1d450 we write tpc u1d461 u1d45b tpc u1d461 u1d45f u1d45b andtpc u1d461 u1d45b tpc u1d461 u1d45f u1d45b as shorthands.
we omit the tree subscript when it is clear from the context.
for example inthe executiontree depictedinfigure u1d70b u1d45b3 u1d45b7 tpc u1d45b3 u1d45b7 u1d45b u1d460 u1d45b tpc u1d45b3 u1d45b7 u1d460 u1d45b an execution tree u1d461with root u1d45fisvalidif u1d45b.
u1d460.
u1d45d u1d450 u1d45f.
u1d460.pc tpc u1d45b foreverynode u1d45b.notethat u1d45f.
u1d460isnotnecessarilytheinitial symbolic state of the whole program so tpc u1d45b is a suffix of the pathconstraints.
from nowon we assumethat alltrees are valid.
logicalnotations.
weencodesymbolicpathconstraintsand memory contents in f irst order logic modulo theories using formulasandterms respectively.atermiseitheraconstant avariable or anapplicationofafunctiontoterms.aformulaiseitheranapplicationofapredicatesymboltotermsorobtainedbyapplyingboolean connectivesorquanti f ierstoformulas.let u1d711 u1d711 beformulasand u1d45aa model.
we write u1d711 u1d711 to note that u1d711and u1d711 are semantically equivalentand u1d711 doteq u1d711 tonotethattheyaresyntacticallyequal.we write u1d45a u1d711tonotethat u1d45aisamodelof u1d711.foraterm u1d461 wedenote by u1d45a u1d461 thevalueassignedby u1d45ato u1d461 andwewrite u1d4611 u1d4612todenote that u1d45a u1d4611 u1d45a u1d4612 in any model u1d45a.
we use the standard theory of arrays andwrite u1d44e as ashorthand for select u1d44e u1d452 .
1141statemerging with q uantifiersin symbolicexecution esec fse december3 san francisco ca usa n 0n1 n s0 s0 97n2 n3 n4 n5 n6 n7 n n n8 n9 n10 n11 n12 n13s1 s1 s2 s2 n n n14 n figure2 theexecutiontreeoftheloopfromsection 1when charsisset to a .
recallthat theascii codeof ais97.
statemergingwith quantifiers in this section we describe our approach for state merging with quanti f iers.
we start with a motivating example and subsequently formalize our approach.
motivatingexample.
considerthesymbolicstates associated withthe nodes u1d45b5 u1d45b9 and u1d45b13from theexecution treein figure whosetreepathconditions i.e.
tpc u1d45b5 tpc u1d45b9 andtpc u1d45b13 are u1d45b u1d460 u1d45b u1d460 u1d45b u1d460 u1d45b u1d460 u1d45b u1d460 u1d45b u1d460 thepathconstraintoftheinitialsymbolicstate u1d45b1.
u1d460 is u1d45b so applyingstandardstatemerging de f inition .
onthesymbolic statesofthenodesabovewillresultinasymbolicstatewhosepath constraintisequivalentto u1d45b tpc u1d45b5 tpc u1d45b9 tpc u1d45b13 note however thateachofthedisjunctsabovehasthefollowing uniform structure it uses u1d458formulas for u1d458 of the form u1d45b u1d460 97to encode that the size of the buffer u1d45b is big enoughtocontain u1d458consecutiveoccurrencesof acharacters and another formula u1d45b u1d458 u1d460 .
this uniformity is exposed whenrewritingeachdisjunctusinguniversalquanti f iersasfollows parenleftbig u1d456.
u1d456 u1d45b u1d456 u1d460 parenrightbig u1d45b u1d460 parenleftbig u1d456.
u1d456 u1d45b u1d456 u1d460 parenrightbig u1d45b u1d460 parenleftbig u1d456.
u1d456 u1d45b u1d456 u1d460 parenrightbig u1d45b u1d460 97to exploit the common structure of the rewritten disjuncts we canintroduceanauxiliaryvariable u1d458 andobtainan equisatis f iable mergedpathconstraint3 u1d45b u1d458 u1d458 u1d458 parenleftbig u1d456.
u1d456 u1d458 u1d45b u1d456 u1d460 parenrightbig u1d45b u1d458 u1d460 theauxiliaryvariableallowsustoachievesimilarsavingsinthe encodingofthemergedmemorycontents.consider forexample thevariable count.
its value inthesymbolic states corresponding to u1d45b5 u1d45b9 and u1d45b13is0 and2 respectively so its merged value withstandardstate merging is ite tpc u1d45b5 ite tpc u1d45b9 note however that with the rewritten merged path constraint the path constraints of the symbolic states corresponding to u1d45b5 u1d45b9 and u1d45b13are now correlated with the values of u1d458 and2.
as the valuesof countcanbeencodedasafunctionofthosevalues we can simply rewritethe complex iteexpressionabove to u1d458.
ourapproach.
ourgoalistoreducethenumberofdisjunctions anditeexpressions introduced in standard state merging.
given a set of merge compatible symbolic states our state merging approach works as follows.
first we compute partitions of symbolic statesbased onthesimilarity ofthe pathconstraints section .
.
then for each partition we attemptto synthesize the merged symbolic state using universal quanti f iers sections .2and3.
and resortto standardstate merging if that fails.
.
partitioningmerging groups viaregular patterns toidentifysimilaritybetweensymbolicstates weusetheexecution tree of the analyzed code fragment.
recall that the symbolic states ineachmerginggroupareassociatedwithleafnodesandrespective paths in the execution tree.
we abstract each path to a sequence ofnumbersusingaspecialized hashfunction whichallowsusto detectsimilaritybetween pathsbasedonasharedregularpattern.
de f inition .
.
ahash function uni210emaps constraints formulas to numbers n .
we say that uni210eisvalidfor an execution tree u1d461if for any twosibling nodes u1d45b1and u1d45b2 uni210e u1d45b1.
u1d450 uni210e u1d45b2.
u1d450 in the sequel we assume a f ixed arbitrary valid execution tree u1d461 and a f ixed arbitrary valid hash function uni210efor u1d461.4we now extend uni210e to pathsas follows de f inition3.
.
thehashofapath u1d70b u1d45b1 u1d45b u1d458 in u1d461is de f inedas follows uni210e u1d70b u1d45b1 u1d45b u1d458 uni210e u1d45b1.
u1d450 uni210e u1d45b2.
u1d450 ... uni210e u1d45b u1d458.
u1d450 n notethatthevalidityof uni210eensuresthateverypathin u1d461isidenti f ied uniquely byits hash value.
de f inition .
.
aregular pattern is a tuple u1d7141 u1d7142 u1d7143 where u1d7141 u1d7142 u1d7143 n arewords sequences ofnumbers.givenleafnodes u1d45b u1d457 u1d45b u1d457 1in u1d461 andnumbers u1d458 u1d457 u1d45b u1d457 n wesaythat u1d45b u1d457 u1d458 u1d457 u1d45b u1d457 3notethat u1d458 u1d458 u1d458 canberewrittenas u1d458 .
4in practice we use a hash function that distinguishes between a condition and its negation effectively ensuring validity for any execution tree.
1142esec fse december3 san francisco ca usa david trabish noam rinetzky sharonshoham andvaibhav sharma table aregular partitioningoftheleaf nodes oftheexecution tree infigure and the resultingmerged states.
regularpattern regularpartition pattern based merged states w gb gy u1d45b5 u1d45b9 u1d45b13 formulapattern true u1d45b u1d465 u1d460 u1d45b u1d465 u1d460 pc u1d45b u1d458 u1d456.
u1d456 u1d458 u1d45b u1d456 u1d460 u1d45b u1d458 u1d460 mem w gb r u1d45b2 u1d45b6 u1d45b10 u1d45b14 formulapattern true u1d45b u1d465 u1d460 u1d45b u1d465 pc u1d45b u1d458 u1d456.
u1d456 u1d458 u1d45b u1d456 u1d460 u1d45b u1d458 mem matchthe regular pattern u1d7141 u1d7142 u1d7143 if for every u1d457 ... u1d45b uni210e u1d70b u1d45b u1d457 u1d7141 u1d714 u1d458 u1d457 u1d7143.
de f inition .
.
a set of leaf nodes u1d45b u1d457 u1d45b u1d457 1in u1d461is called a regular partition if there exists a regular pattern u1d7141 u1d7142 u1d7143 and a set u1d458 u1d457 u1d45b u1d457 nsuch that u1d45b u1d457 u1d458 u1d457 u1d45b u1d457 1match that pattern.
a regular partitioning of leaf nodes in u1d461is a partitioning into disjoint regular partitions.
example1.
considerahashfunction uni210ethatoperatesontheabstractsyntaxtree ast ofaformulaandassignsthesamepre de f ined valuetoalltheconstantnumericalterms.suchahashfunctionensures that formulas with a similar shape will be assigned the same hashvalue forexample uni210e u1d45b uni210e u1d45b uni210e u1d45b uni210e u1d460 uni210e u1d460 figure2shows the resulting hash values of the nodes in the executiontree.
forsimplicity we visualizeeveryhashvalueas adistinct color white w red r blue b green g and yellow y .
here u1d45b5 u1d45b9 u1d45b13 matchtheregularpattern w gb gy since uni210e u1d70b u1d45b5 wgy uni210e u1d70b u1d45b9 wgbgy uni210e u1d70b u1d45b13 wgbgbgy a possible regular partitioning of the leaf nodes in figure 2is givenintable whichshowsinthetwoleftmostcolumnstheregular patternsand their correspondingregularpartitions.
in the following sections we show how given a regular partitionanditscorrespondingregularpattern wecansynthesizethe resultingmergedsymbolic state using quanti f iers.
.
pattern basedstate merging a regular pattern indicates the potential existence of a uniform structure in the path conditions of the symbolic states in the associatedregularpartition.we formalizethisintuitionusing formula patterns.
de f inition .
.
aformula pattern is a tuple u1d7111 u1d7112 u1d465 u1d7113 u1d465 where u1d7111is a closed formula and u1d7112 u1d465 and u1d7113 u1d465 are formulas with a free variable u1d465.
we say that u1d45b u1d457 u1d458 u1d457 u1d45b u1d457 1matchthe formula pattern u1d7111 u1d7112 u1d465 u1d7113 u1d465 if for every u1d457 ... u1d45b tpc u1d45b u1d457 doteq u1d7111 parenleftbig u1d458 u1d457 logicalanddisplay.
u1d456 u1d7112 parenrightbig u1d7113 theuniformstructureexposedbyformulapatternsenablesus to perform state mergingwithquanti f iers de f inition .
.
let u1d45b u1d457 u1d45b u1d457 1be a set of leaf nodes in u1d461such that u1d45b u1d457.
u1d460 u1d45b u1d457 1are merge compatible and u1d45b u1d457 u1d458 u1d457 u1d45b u1d457 1match the formulapattern u1d7111 u1d7112 u1d465 u1d7113 u1d465 .thepattern basedmergedsymbolic stateof u1d45b u1d457.
u1d460 u1d45b u1d457 1is a symbolic state u1d460whose path constraint u1d460.
u1d45d u1d450 is u1d45f.
u1d460.
u1d45d u1d450 u1d45b logicalordisplay.
u1d457 u1d458 u1d458 u1d457 u1d7111 u1d456.
u1d456 u1d458 u1d7112 u1d7113 where u1d458is a fresh constant u1d456is a fresh variable and u1d45fis the root of u1d461.
the symbolic store of u1d460is de f ined as follows.
for every variable u1d463 if there exists a term u1d461 u1d465 with a free variable u1d465such that u1d461 doteq u1d45b u1d457.
u1d460.
u1d45a u1d452 u1d45a u1d463 for every u1d457 ... u1d45b then the value of u1d463is encoded as u1d460.mem u1d463 u1d461 .
otherwise u1d460.mem u1d463 merge var u1d45b u1d457.
u1d460 u1d45b u1d457 u1d463 de f inition .
.
pattern basedstatemergingissoundandcompletew.r.t.standard state merging.
this isformalizedinthe following theorem theorem .
.
under the premises of de f inition .
let u1d460be the pattern based merged symbolic state of u1d45b u1d457.
u1d460 u1d45b u1d457 and let u1d460 be their merged symbolic state obtained with standard state merging de f inition2.
.
thefollowingholdsfor anymodel u1d45a u1d45a u1d460 .
u1d45d u1d450iff u1d45a u1d460.
u1d45d u1d450for some u1d458 n. if u1d45a u1d460.
u1d45d u1d450then u1d45a u1d460 .mem u1d463 u1d45a u1d460.mem u1d463 for every variable u1d463.
example .
consider the regular partition u1d45b5 u1d45b9 u1d45b13 shown in the f irstrowoftable .theformulapattern u1d461 u1d45f u1d462 u1d452 u1d45b u1d465 u1d460 u1d465 u1d45b u1d465 u1d460 ismatchedby u1d45b5 u1d45b9 u1d45b13 .
the merged symbolic state induced by that formula pattern is shown intherightmostcolumnintable pcandmem .notethatforthe variablecount theterm u1d461 u1d465 u1d465satis f ies u1d461 u1d461 u1d461 so themergedvalue ofthatvariablecanbesimpli f ied to u1d458.themerging of the other variables is rather trivial as the symbolic states being merged agreeontheir values.
.
synthesizing formulapatterns sofar wehaveyettodiscusshowformulapatternsareobtained.
wenowdescribeanapproachthatattemptstosynthesizeaformula pattern given a regular pattern and its associated regular partition.
asexplainedinsection .
thisenablesustoperformstatemerging withquanti f iers.
our hash function uni210e which we assume to be valid for u1d461 de f inition3.
has the following useful property 1143statemerging with q uantifiersin symbolicexecution esec fse december3 san francisco ca usa lemma .
.
thefollowingholdsforanytwo nodes u1d45b1and u1d45b2in u1d461 if uni210e u1d70b u1d45b1 uni210e u1d70b u1d45b2 then u1d45b1 u1d45b2.
if uni210e u1d70b u1d45b1 is a pre f ix of uni210e u1d70b u1d45b2 then there is a single path u1d70b u1d45b1 u1d45b2 in u1d461.
accordingly we de f ine de f inition .
.
let u1d7141 u1d7142 n be twowordssuch that uni210e u1d70b u1d45b1 u1d7141 uni210e u1d70b u1d45b2 u1d7141 u1d7142 for somenodes u1d45b1and u1d45b2in u1d461.then we de f ine u1d452 u1d465 u1d461 u1d45f u1d44e u1d450 u1d461 u1d7141 tpc u1d45b1 u1d452 u1d465 u1d461 u1d45f u1d44e u1d450 u1d461 u1d7141 u1d7141 u1d7142 tpc u1d45b1 u1d45b2 whichgivesusthetreepathconditiontailsassociatedwiththepaths u1d70b u1d45b1 and u1d70b u1d45b1 u1d45b2 respectively.
note that lemma .8ensures that u1d45b1and u1d45b2are uniquely determinedby u1d7141and u1d7142.
weuseextracttode f inethesufficientrequirementstoobtaina formula pattern from agiven regularpattern.
lemma .
.
suppose that u1d45b u1d457 u1d458 u1d457 u1d45b u1d457 1match the regular pattern u1d7141 u1d7142 u1d7143 .
let u1d7111 u1d7112 u1d465 u1d7113 u1d465 be a formula pattern that satis f ies u1d7111 doteq u1d452 u1d465 u1d461 u1d45f u1d44e u1d450 u1d461 u1d7141 u1d7112 doteq u1d452 u1d465 u1d461 u1d45f u1d44e u1d450 u1d461 u1d7141 u1d714 u1d456 u1d7141 u1d714 u1d456 u1d456 ... max u1d458 u1d457 u1d45b u1d457 u1d7113 doteq u1d452 u1d465 u1d461 u1d45f u1d44e u1d450 u1d461 u1d7141 u1d714 u1d458 u1d457 u1d7141 u1d714 u1d458 u1d457 u1d7143 u1d457 ... u1d45b then u1d45b u1d457 u1d458 u1d457 u1d45b u1d457 1match u1d7111 u1d7112 u1d465 u1d7113 u1d465 .
basedonlemma .
wereducetheproblemof f indingaformula patterntotwosynthesistasks for u1d7112and u1d7113.
notethat u1d7111istrivially obtained from the f irst requirement of the lemma.
each synthesis taskhas the form u1d711 doteq u1d713 uni2113 uni2113 ... u1d45d where i u1d711 u1d465 istheformulato besynthesized i.e.
u1d7112or u1d7113 ii u1d45d isthenumberofequations whichiseither u1d45a u1d44e u1d465 u1d458 u1d457 u1d45b u1d457 1inthecase of u1d7112or u1d45bin the case of u1d7113 iii u1d713 uni2113 u1d45d uni2113 1are formulas obtained from the extracted path constraints and iv u1d451 uni2113 u1d45d uni2113 1are constant numericalterms whicharethe u1d456 sinthecaseof u1d7112orthe u1d458 u1d457 sin the caseof u1d7113 .
as synthesis is a hard problem in general we focus on thecase where all formulas in u1d713 uni2113 u1d45d uni2113 1are syntactically identical up to a constant numerical term i.e.
there exists a formula u1d703 u1d466.alt such that u1d703 doteq u1d713 uni2113for some numerical constants u1d6fe uni2113 u1d45d uni2113 .
to obtain u1d711 u1d465 from u1d703 u1d466.alt it remains to synthesize a term that will express each u1d6fe uni2113using the corresponding u1d451 uni2113.
technically if there exists a term u1d461 u1d465 such that u1d461 u1d6fe uni2113 uni2113 ... u1d45d then the desired formula u1d711 u1d465 will be given by u1d703 .
when lookingforsuch u1d461 u1d465 werestrictourattentiontotermsoftheform u1d44e u1d465 u1d44fwhere u1d44eand u1d44fare constant numerical terms that must satisfy u1d45d logicalanddisplay.
uni2113 u1d44e u1d451 uni2113 u1d44f u1d6fe uni2113 the existence of such u1d44eand u1d44fcan be checked using an smt solver.example3.
consideragaintheregularpattern w gb gy which ismatchedby u1d45b5 u1d45b9 u1d45b13 .welookforaformulapattern u1d7111 u1d7112 u1d465 u1d7113 u1d465 that satis f ies u1d7111 doteq u1d461 u1d45f u1d462 u1d452 u1d452 u1d465 u1d461 u1d45f u1d44e u1d450 u1d461 w u1d7112 doteq u1d45b u1d460 u1d452 u1d465 u1d461 u1d45f u1d44e u1d450 u1d461 w wgb u1d7112 doteq u1d45b u1d460 u1d452 u1d465 u1d461 u1d45f u1d44e u1d450 u1d461 wgb wgbgb u1d7113 doteq u1d45b u1d460 u1d452 u1d465 u1d461 u1d45f u1d44e u1d450 u1d461 w wgy u1d7113 doteq u1d45b u1d460 u1d452 u1d465 u1d461 u1d45f u1d44e u1d450 u1d461 wgb wgbgy u1d7113 doteq u1d45b u1d460 u1d452 u1d465 u1d461 u1d45f u1d44e u1d450 u1d461 wgbgb wgbgbgy consider for example the formulas associated with u1d7112.
first note that they are identical up to a constant numerical term e.g.
for u1d703 u1d466.alt u1d45b u1d466.alt u1d460 u1d703 doteq u1d45b u1d460 u1d703 doteq u1d45b u1d460 now welook forconstantnumerical terms u1d44eand u1d44fsuchthat u1d44e u1d465 u1d44f u1d44e u1d465 u1d44f whichis satis f ied by u1d44e 1and u1d44f therefore u1d7112 u1d465 u1d703 doteq u1d45b u1d465 u1d460 wesimilarlysynthesize u1d7113 u1d465 u1d45b u1d465 u1d460 .
ifwesucceededtosynthesizeaformulapattern u1d7111 u1d7112 u1d465 u1d7113 u1d465 matched by u1d45b u1d457 u1d458 u1d457 u1d45b u1d457 we attempt to synthesize the merged valueofavariable u1d463bysynthesizing aterm u1d461 u1d465 that satis f ies u1d461 doteq u1d45b u1d457.
u1d460.
u1d45a u1d452 u1d45a u1d463 u1d457 ... u1d45b suchterms are synthesizedsimilarlyto formula patterns.
for each regular partition shown in table we automatically synthesizetheformulapatternandtheinducedmergedsymbolic state using the techniqueabove.
the proofs for theorem .7and the other lemmas are given in .
incrementalstatemerging when symbolically analyzing code fragments that contain disjunctiveconditions thenumberofgeneratedstates aswellasthesizeof the generated execution trees might be exponential.
in such cases theexplorationofthecodefragmentmightnotterminatewithin the allocated time budget and the analysis might not even reach the point where state merging and pattern based state merging in particular can be applied.
toaddressthisissue weproposean incremental approachfor state merging in which we merge leaves in the execution tree not only with other leaves but also with internal nodes during theconstructionofthetree.thisallowstocompressthetreeasit is constructed.
once the construction of the tree is complete we can apply our pattern based state merging approach on the leaves.
technically inadditiontothe activesymbolicstates i.e.
thosethat are stored in the current leaf nodes we keep also the non active symbolic states i.e.
those that are stored in the internal nodes.
when a new leaf u1d45b1is added to the execution tree we search for the highest node u1d45b2 i.e.
closest to the root such that u1d45b1.
u1d460and u1d45b2.
u1d460 aremerge compatibleandhavethesamesymbolicstore w.r.t.live variables .
we additionally require that u1d45b1is unreachable from 1144esec fse december3 san francisco ca usa david trabish noam rinetzky sharonshoham andvaibhav sharma n1 s0 s0 s0 s0 s0 s s0 s s0 n2 n3 n4 n5 n1 nnew n5before after figure3 executiontreetransformationwhen memspniscalled withcharsset to ab .
u1d45b2toavoidin f initesequencesofmerges.ifsuchanode u1d45b2isfound wereplace u1d45b1and u1d45b2 andtheirsubtrees withasinglemergednode u1d45bnewthat is added as a child of their lowest common ancestor u1d45blca.
we f ix u1d45bnew.
u1d450 tpc u1d45blca u1d45b1 tpc u1d45blca u1d45b2 and u1d45bnew.
u1d460isthemerged state of u1d45b1.
u1d460and u1d45b2.
u1d460.afterthe above ifa node u1d45dremains witha single child u1d45b we remove u1d45d redirect its incoming edge to u1d45b and update the condition of u1d45bto u1d45b.
u1d450 u1d45d.
u1d450.
as we merge internal nodes our approach does not relyon thesearch heuristic tosynchronize betweentheactivesymbolicstatestoproducesuccessfulmerges.
toavoidnodeswithmorethantwochildren werequirethat u1d45blca isthe parentof u1d45b1or u1d45b2.
thisrestrictioncan be easily lifted.
example4.
consideragainthefunction memspnfromsection .
whensymbolicallyanalyzing memspnwhilesettingthevalueof the charsparameter to ab instead of a this results in an exponential execution tree.
the upper part of figure 3shows the partial execution tree with some of the nodes that were added during the executionofthe f irstiterationsoftheloopatline .assumingthat u1d45b2 is added last we merge it with u1d45b4as the symbolic states associated with u1d45b2and u1d45b4are both located at line 5and their symbolic stores w.r.t.livevariablesareidentical since pisdeadatthislocation.we remove u1d45b2and u1d45b4togetherwithitssubtree andaddanewnode u1d45b u1d45b u1d452 u1d464 asachildof u1d45b1 thelowestcommonancestorof u1d45b2and u1d45b4.then u1d45b3is left with its own child u1d45b5 so we remove u1d45b3and appropriately update the condition of u1d45b5.
this results in the execution tree shown in the lower part of figure .
after applying similar steps in the subsequent iterations of the loop the f inal execution tree is similar to the one from figure and can be obtained from it by replacing u1d460 and u1d460 97with u1d460 u1d460 u1d460 and u1d460 u1d460 respectively for u1d456 .
now patternbased state merging can be applied similarly to the example given in section3.
theincrementalstatemergingapproachusesastandardliveness analysis to f ind symbolic states to be merged.
if the computed liveness results are imprecise our approach will not be able to f ind matchingsymbolicstatesandthereforewillnotbeabletocompress the execution tree.
in that case our approach will only impose the overhead of maintaining snapshots of non active symbolic states.
solving quantified queries in general the quanti f ied queries generated by our approach section3 can be solved using an smt solver that supports quanti f ied formulas e.g.
z3 .inpractice however weobservedthatthe generic method employed by z35to solve such queries often leads tosubparperformancecomparedtothesolvingofthequanti f ierfreevariantofthequeries.hence wedeviseasolvingprocedure that leverages theparticular structure of thegeneratedquanti f ied formulas andresortto the genericmethodif our approach fails.
our solving procedure assumes a closed formula u1d711 logicalandtext.
u1d450where eachclause u1d450iseitheraquanti f ier freeformulaorauniversalformula of the form u1d456.
u1d456 u1d458 u1d713where u1d713is a quanti f ier free formulawithafreevariable u1d456.oursolvingprocedureworksinfour stages quanti f ierstripping.
weweaken u1d711intoaquanti f ier free formula u1d711qfbyreplacingquanti f iedclauseswithimpliedquanti f ierfree clauses.
technically each quanti f ied clause u1d456.
u1d456 u1d458 u1d713 in u1d711isreplacedwiththeconjunctionofthefollowingtwoquanti f ierfree formulas7 u1d458 u1d713 logicalanddisplay.
u1d461 u1d458 u1d713 u1d711 intuitively the formerprovidesaquanti f ier free clausewhichpartiallypreservesthepropertiesimposedbythequanti f iedclause and thelatterreducesthechancesthatthesmtsolvercomputesamodel of u1d711qfthat does not satisfy u1d711 if1 u1d461 u1d458then u1d456.
u1d456 u1d458 u1d713 demands that u1d713 holds in any model of u1d711.
if the smt solver fails to f ind a model for u1d711qf then u1d711is also unsatis f iable.
if a model wasfound we checkwhether itisalsoamodelof u1d711.
example .
consider the following query a simpli f ication of a representativequeryfrom our experiments u1d711 u1d460 u1d458 u1d460 u1d456.
u1d456 u1d458 u1d460 notethat a theinstantiationofthequanti f iedformulausing u1d456 results in u1d458 u1d460 and b u1d460 0is obtained by substituting u1d460 .
thus the weakened query obtained byquanti f ierstripping is givenby u1d711qf u1d460 u1d458 u1d460 u1d458 u1d460 u1d45b u1d458 thefollowingmodel forexample is amodelof u1d711qf u1d45a u1d45b u1d458 u1d460 but unfortunately it is not amodelof u1d711.
assignmentduplication.
if u1d45aisnotamodelof u1d711 wemodify u1d45ainto a model u1d45a u1d451which assigns to every array cell accessed by a quanti f ied clause a value u1d463of a cell in that array that was explicitly constrainedby u1d711qf.technically foreveryarray u1d44eaccessedwithan offsetthatdependsonthequanti f iedvariable u1d456wedothefollowing pickanaccessedoffset u1d45cof u1d44ein u1d713suchthat u1d45cdependson u1d456 evaluatethevalueof u1d44e in u1d45a namely u1d463 and compute theconcreteoffsetsobtainedbyevaluating u1d45c in u1d45a for2 u1d457 5cvc5 and yices failed to solvemostof ourqueries.
6fortheinterestedreader acompletepseudocodeofthesolvingprocedureisgiven in .
7wewrite u1d450 u1d711to notethat u1d450is one of the clauses of u1d711.
1145statemerging with q uantifiersin symbolicexecution esec fse december3 san francisco ca usa u1d45a u1d458 and modify u1d45asuch that the values of u1d44eat these offsets are set to u1d463.
recall that the accessed cells of u1d44ein u1d713 were explicitly constrainedin u1d711qf so u1d463isagoodcandidateto f illinalltheother cellsof u1d44econstrainedin u1d711.however thisduplicationisrathernaive andmightresult inamodelthat does not even satisfy u1d711qf.
example6.
continuingexample wepickfromthequanti f ied clause the accessed offset u1d456 1of the array u1d460 and update the value of u1d460 to u1d45a u1d460 for each1 u1d457 .
this results in the followingmodel u1d45a u1d451 u1d45b u1d458 u1d460 the model u1d45a u1d451helps to satisfy the quanti f ied clause but does not satisfy u1d711 speci f ically theclause u1d460 8is violated .
modelrepair.
if u1d45a u1d451isnotamodelof u1d711 wefurthermodify u1d45a u1d451intoanothermodel u1d45a u1d45f which muchlike u1d45a u1d451 attemptstosatisfytheconstraintsonthecontentsofarraysthatareimposedby u1d711 but omitted in u1d711qf.
for every quanti f ied clause u1d456.
u1d456 u1d458 u1d713 wecollectalltheaccesses u1d44e where u1d45cdependson u1d456.foreachsuch access andfor each u1d457 u1d45a u1d458 we compute the concrete offset obtainedbyevaluating u1d45c in u1d45a u1d451andstrengthen u1d711qfwiththe instantiation u1d713 ifthat offset appears in the concrete offsets of aviolatedquanti f ier freeclause oraviolatedinstantiation .rather than computing from scratch a new model for the strengthened query we f ix the values of all the array cells and variables according to their interpretation in u1d45a u1d451except for the arrays that are accessedwith u1d456 thoseforwhichanewinterpretationissought.if theresultingqueryhas amodel weapplyassignment duplication onit.thistime toavoidoverwriting theduplicationisnotapplied to the offsets involvedinviolations.
example7.
continuingexample theviolatedclauseinthemodel u1d45a u1d451is u1d460 anditsconcreteaccessis u1d460 .theconcreteaccess in the instantiation u1d460 that was omitted in u1d711qfis also u1d460 so we add it to u1d711qf.
in addition we concretize the values of u1d45band u1d458according to u1d45a u1d451.
the resulting strengthened query and its possiblemodelare u1d711qf u1d460 u1d45b u1d458 u1d45b u1d458 u1d460 then we duplicate again but this time while skipping over the cell u1d460 .
similarly to the f irst duplication u1d463is set to but the value of u1d460 is updated only for u1d457 thus avoiding the original violation.
theresulting modelindeed satis f ies u1d711 u1d45a u1d45f u1d45b u1d458 u1d460 fallback.
if no model u1d45a u1d45fis found or if it does not satisfy u1d711 we ask the smtsolver to f ind amodelfor u1d711.
implementation weimplementedourstatemergingapproachontopoftheklee symbolic executionengine con f igured withllvm7.
.
.
our approach generates quanti f ied queries overarrays and bitvectors so we use z3 version .
.
as the underlying smt solver.
we extended klee s expression language to support quanti f ied formulas andmodi f ied some parts of thesolver chain accordingly.
weimplementedoursolvingprocedure section asanadditional component in the solver chain.
to implement the hashfunctionusedbythepattern basedstatemergingapproach section we relied on the expression hashing utility of klee and modi f ied it byassigningapre de f inedhashvaluetoallconstants.toextract the regularpatternsfrom the executiontrees we used abasicregular expression matching algorithm.
if our hash function is not valid for a given generated execution tree de f inition .
or the number of extracted regular patterns in that tree exceeds a userspeci f ied threshold then we fallback to standard state merging de f inition .
.
our implementationisavailable at .
evaluation evaluating astate merging approach requires determining the desiredmergingpoints i.e.
thecodesegmentswherestatemerging should be applied.
in our case this translates to identifying code segments that produce merging operations that involve many symbolicstates.todoso weevaluateourapproachinthecontextofthe symbolic size memorymodel .thismodelsupportsbounded symbolic sizeobjects i.e.
objectswhosesizecanhavearangeof values limitedbyauser speci f ied capacitybound.8itwasobserved in that loops operating on symbolic size objects typically produce many symbolic states and state merging was suggested to combat the ensued state explosion problem.
thus this memory model provides a suitable basis for evaluating our state merging approach.
furthermore the automatic detection of merging points in avoids the need for manual annotations.
we emphasize however that our technique is independent of the symbolic size memory model itself see section .
.
that said the symbolic size memorymodeldoes have thepotentialtoproducemorechallengingmergingoperationsthantheconcrete sizemodelasitconsiders alarger state space.
the followingmodes arethe mainsubjectsofcomparison the patmodeisthepattern basedstatemergingapproachdescribedin section3which partitions the symbolic states into merginggroups based on regular patterns in the execution tree and uses quanti f iers to encode the merged path constraints.
in the patmode the incremental state merging approach section and the solvingprocedure section areenabled.the cfgmodeisthestate mergingapproachdiscussedabove smoptmodefrom which partitions the symbolic states into merging groups according to their exit point from the loop in the cfg and uses the standard qfabvencoding disjunctions and iteexpressions .
the base mode isthe forking approach usedinvanilla klee .
the following research questionsguide our evaluation rq1 does patimprove standardstate merging cfg ?
rq2 does patimprove standardsymbolic execution base ?
rq3 doallcomponentscontributeto the performance of pat?
.
benchmarks the benchmarks used in our evaluation are listed in table .
these benchmarkswerechosenastheyarechallengingforsymbolicexecution and provide numerous opportunities for applying state merging.ineachbenchmark weanalyzedasetofsubjects apis and whole programs whose inputs parameters command line 8this is in contrast to the standard concrete size model where every object has a concretesize.
1146esec fse december3 san francisco ca usa david trabish noam rinetzky sharonshoham andvaibhav sharma arguments etc.
canbemodeledusingsymbolic sizeobjects i.e.
arrays and strings.
in libosip libtasn1 andlibpng the test driversfortheapisweretakenfrom .9inwget alibraryfor retrieving f ilesusingwidelyusedinternetprotocols http etc.
we reusedthetestdriversfromtheexistingfuzzingtestsuitewhenever possible and for other apis we constructed the test drivers manually.
inapr apache portable runtime a library that provides aplatform independentabstractionofoperatingsystemfunctionalities weconstructedtestdriversforapisfromseveralmodules strings f ile ioandtables which manipulate strings f ile system paths and data structures.
in json c a library for decoding and encodingjsonobjects weconstructedtestdriversforapisthat manipulate string objects.
in busybox a software suite that provides a collection of unix utilities we focused on utilities whose inputcomes from command line arguments and f iles which can besymbolicallymodeledusingklee s posixruntime.wedidnot analyze utilities whose behavior depends on the state of system resources processinformation permissions f ile systemdirectories etc.
sincekleehasnosymbolicmodelingforthose.toprevent the symbolic executor from getting stuck in getopt the routine usedinbusyboxtoparsecommandlinearguments weaddedthe restriction that symbolic command line arguments do not begin witha character.
.
setup weruneverymodeunderthesymbolic sizememorymodel withthefollowingcon f iguration adfssearchheuristic aone hour time limit anda4gb memorylimit.the capacitysettings ineach ofthe benchmarks are shownintable .
ineveryexperiment weusethefollowingmetricstocompare betweenthemodes analysistimeandlinecoveragecomputedwith gcov .whenthecomparedmodeshavethesameexploration order weadditionallyusethepathcoveragemetric i.e.
thenumber ofexploredpaths.
each benchmark consists of multiple subjects so when comparingthetwomodes wemeasuretherelativespeedupandtherelative increase in coverage for each subject.
note that when we measure the average and median speedup for example the speedup in thesubjectswherebothmodestimedoutisalways1 .similarly when we measure coverage the coverage in the subjects where both modesterminated i.e.
completed theanalysis before hitting the timeout is always identical.
to separate the subjects where the resultsaretriviallyidentical wereporttheaverage andmedian over asubsetof the subjects depending on the evaluated metric whenmeasuring analysis time we considerthe subsetof thesubjects where at least one of the modes terminated.
when measuring coverage we consider the subset of the subjects where at least one ofthemodestimedout.in weadditionallyreport the average andmedian when computedover allthe subjects.
we ran our experiments on several machines intel i7 .40ghz with32gbram withubuntu20.
.
9we noticed that some of the apis from libosipthat were used in are similar i.e.
different apis with the same internal functionality.
the analysis of such apis leadstothesameresults therefore weexcludedthemfromtheevaluationtoavoid redundancy.
10inlibosip libtasn1 andlibpng the capacity settings were set similarly to the experiments from .table benchmarks.
version sloc subjects capacity libosip .
.
wget .
.
libtasn1 .
.
libpng .
.
apr .
.
json c .
busybox .
.
.
results patvs.cfg in this experiment we compare between the performance of the statemergingmodes patandcfg.theresultsareshownintable andfigure .
analysistime.
columnspeedupintable3showsthe average median minimum and maximum speedup of patcompared to cfgin the subjects where at least one of the modes terminated.
column showsthenumberofconsideredsubjectsoutofthetotal numberofsubjects.in libosip wget apr json c andbusybox pat wassigni f icantlyfasterinmanysubjects andin libtasn1andlibpng theanalysistimeswereroughlyidentical.figure 4abreaksdown the speedup of patcompared to cfgper subject.
overall there were12subjectswhere patwasslowerthan cfg.inlibosip pat was slower only in one api.
in this case the slowdown of .
from20 to seconds wascaused bya small number of queries thatoursolvingprocedure section failedtosolve andwhose solving using the smt solver required most of the analysis time.
inwget patwas slower in two apis.
in one case the slowdown wascausedbythecomputationaloverheadoftheincrementalstate mergingapproach.intheothercase theslowdownwascausedbya relatively high number of queries that our solving procedure failed to solve.
in libtasn1 patwas slower in seven apis but the time difference in these cases was rather minor roughly seconds .
in libpng patwasslightlyslowerinoneapiduetothecomputational overheadofextractingregularpatterns.in busybox patwasslower in one utility with a minor time difference of two seconds.
column diff.intable3showsthedifferencebetween patandcfginterms ofthe totaltime required to analyze allthe subjects.
notethat the time difference is interpreted as zero in subjects where both modes are timed out.
in libosip wget apr andbusybox patachieved a considerable reduction of roughly and hours respectively.
injson c patachievedareductionofroughly20minutes andin libtasn1andlibpng thetimedifferencewasminor.figure 4bbreaks downthe time difference between patandcfgper subject.
coverage.
columncoverage intable3shows the average median minimum andmaximum relativeincreaseinlinecoverageof patovercfginthesubjectswhereatleastoneofthemodestimed out.
again column shows the number of considered subjects.
in libosipandwget patachievedhighercoverageinmanycases.in libtasn1 patresortedtostandardstatemerginginmostcases asit didnot f indregular andformula patterns.therefore theresults weresimilartothoseof cfg andcoveragewasnotimproved.in libpng thecoveragewasroughlyidenticalinalltheapisexceptfor twoapiswhere patachievedanimprovementof8.
and18.
.
inapr the coverage was identical in all the apis except for two cases where pathad an increase of .
and a decrease of .
.
1147statemerging with q uantifiersin symbolicexecution esec fse december3 san francisco ca usa injson c there was only one api where one of the modes timed out and in this case cfgachieved higher coverage.
in busybox there were cases where at least one of the modes timed out.
in four cases patachieved an improvement of .
.
and intwocases cfgachievedanimprovementof1.
and61.
.
intheremaining17cases thecoveragewasidentical.
inmostof thesecases patdidnot f indformulapatterns resultinginidentical explorations.
column diff.intable3showsthedifferencebetween patandcfginterms ofthetotalnumberofcoveredlinesacross all the subjects.
again note that there is no difference in coverage in subjects where both modes terminated.
it is possible to have an improvementinaverage coveragebut not intotalline difference apr and vice versa busybox .
this happens due to shared code that is covered by only one mode in one subject but covered by the othermodeinothersubjects.figure 4cbreaksdownthecoverage improvement of patovercfgper subject.
scaling.the main obstacle in applying state merging originates fromtheintroductionofdisjunctiveconstraintsand iteexpressions especiallywhenthenumberofstatestobemergedishigh.weevaluate the ability of our approach to cope with a particular aspect of thischallengewherethestatesaregeneratedbyloopsiteratingover largedataobjects afrequentsituationinourexperience.technically weconductedacasestudyon libosip oneofourbenchmarks where we gradually increase the capacityofsymbolic sizeobjects.
whenthecapacityisincreased thesizeofthesymbolic sizeobjects ispotentiallyincreasedaswell.thistypicallyleadstoadditional forks forexample inloopsthatoperateonsymbolic sizeobjects.
as we apply state merging in such loops this eventually results inmorecomplexmergingoperations.thus increasingthecapacityallowsustomeasurehoweachmodescalesw.r.t.thenumber of merged states.
in this experiment we run each api in each of the state merging modes patandcfg under several different capacitysettings.the results are shownintable .
ascanbeseen patachievedbetterresultsthan cfginallthe capacity settings.
in general when the capacity is increased there are typically more forksandqueries whichmakestheanalysis of size dependent loops harder for both modes.
therefore the coverageimprovementwaslesssigni f icantunderthehighestcapacity settings 100and200 comparedtothelowercapacitysettings.note alsothatunderthosecapacitysettings therewereonly f iveapis inwhichatleastoneofthemodesterminated.weobservedthat in these apis the analysis time increased in both modes when thecapacitywasincreased.however with cfg theanalysistime increased more signi f icantly so the speedupunder the highest capacitysetting wasgreater.thisindicatesthatourapproach is less sensitive to the input capacity and hence to the resulting number ofmergedstates.
rq1 answer pat outperforms cfg in many cases and scales better in executing complex statemergingoperations.
.
results patvs.base in this experiment we compare the performance of patandbase i.e.
standard symbolic execution that uses the forking approach.
the results are shownintable .
columnspeedupshowsthe averageandmedian speedupof pat compared to basein the subjects where at least one of the modesterminated.
as can be seen patachieved a considerable speedup inthemajorityofthebenchmarks.overall therewereninesubjects in which patwas slower than base.
in three of these cases the timedifferencewasminor roughly5seconds .intheothercases the slowdown was caused by the computational overhead of the incrementalstatemergingapproachandthecomplexconstraints thatwereintroducedduringthestatemerging.regardingtimeouts therewere20subjectsinwhich basetimedoutand patterminated andonlyonesubjectinwhich pattimedoutand baseterminated.
columncoverage shows the average and median relative increase inline coverage of patoverbasein thesubjects where at least one of the modes timed out.
patachieved higher coverage in many subjects especially in libosipandlibpng.
in most of the casesinlibtasn1 apr andjson c bothmodescoveredmostofthe reachablelinesinarelativelyearlystage sothecoveragewassimilar.
inwgetandbusybox patachieved higher coverage in some of thecases buttherewerealsocasesinwhich baseachievedhigher coverage.ingeneral thisisaconsequenceoftheknowntradeoff betweenforkingand statemerging theforking approachexplores more pathsbut generatesless complex constraints.
in addition we observed that there were four subjects in which baseran out of memory.
in two of these cases base f inished the analysis before pat but its analysis was incomplete since klee prunes the searchspaceoncethe memory limit isreached.
for space reasons the breakdown of the improvement of pat overbaseper subjectisshownin .
rq2answer patoutperformsbaseinmanycases however the known tradeoff betweenstatemergingand forkingremains.
.
results component breakdown now weevaluatethesigni f icanceofthecomponentsusedinour pattern basedstate merging approach i.e.
pat .
.
.
solvingprocedure.
toevaluateoursolvingprocedure section5 we ran each subject in two versions of pat one that relies only on the smt solver vanilla z3 and another one that uses our solvingprocedure.
both modesarerunwith the incremental state mergingapproach enabled.
to evaluate the impact of the solving procedure we show in table6its effect on analysis time and coverage in the relevant subsets.
here the two modes have the same exploration order so we use the path coverage metric as well.
in libosip wget apr json c andbusybox our solving procedure generallyleads to lower analysis times and higher line or path coverage.
the results were mostlysimilarin libtasn1andlibpngsincethenumberofquanti f ied queries was relatively low.
the only exception was one of the apis inlibpng where the pathcoveragewasincreasedby39.
.
.
.
incrementalstatemerging.
toevaluatetheincrementalstate merging approach section we run each subject in two versions ofpat one that disables incremental state merging and another one that enables it.the results are shownintable .
inlibosip therewererelativelymanyloopswhereincremental state merging was successfully applied i.e.
reduced the number of exploredpaths.thisresultedinasigni f icantspeedupandhigher linecoverage.in wget therewerefourapiswhereincrementalstate mergingcouldbe applied andintwo ofthesecases the coverage 1148esec fse december3 san francisco ca usa david trabish noam rinetzky sharonshoham andvaibhav sharma table comparisonof patvs.cfg.
time coverage speedup diff.
seconds diff.
lines avg.
med.
min.
max.
avg.
med.
min.
max.
libosip .
.
.
.
.
.
.
.
wget .
.
.
.
.
.
.
.
libtasn1 .
.
.
.
.
.
.
.
libpng .
.
.
.
.
.
.
.
apr .
.
.
.
.
.
.
.
json c .
.
.
.
.
.
.
.
busybox .
.
.
.
.
.
.
.
subjectsspeedup x .
a speedup in analysis time in the subjectswhereatleastoneofthemodesterminated inlog scale .
subjectsdiff.
seconds b difference in analysis time seconds in thesubjectswhereatleastoneofthemodes terminated.
subjectscoverage c relativeincreaseincoverage inthe subjects where at least one of the modes timedout.
figure breakdownoftheimprovementof patovercfgpersubject.
table4 comparisonof patvs.cfgunderdifferentcapacity settings column capacity inlibosip.
capacity speedup coverage avg.
med.
avg.
med.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
table comparisonof patvs.base.
speedup coverage avg.
med.
avg.
med.
libosip .
.
.
.
wget .
.
.
.
libtasn1 .
.
.
.
libpng .
.
.
.
apr .
.
.
.
json c .
.
.
.
busybox .
.
.
.
was improved by .
and .
.
in apr there were four apis where incremental state merging could be applied and in one of these cases the analysis time was reduced by .
and the coverage was improved by .
.
in busybox there were two utilities whereincrementalstate mergingcould be applied andin thesecases thecoveragewasimprovedby11.
and15.
.in libtasn1 libpng andjson c there were no loops where incremental state merging could be applied.
in some cases this resulted in a minor performance penalty due to the computational overhead of theapproach whichmainlycomesfromtheneedtomaintainthe snapshotsofthe non active symbolic states inthe executiontree.table impactofsolvingprocedure.
speedup coverage line path avg.
med.
avg.
med.
avg.
med.
libosip .
.
.
.
.
.
wget .
.
.
.
.
.
libtasn1 .
.
.
.
.
.
libpng .
.
.
.
.
.
apr .
.
.
.
.
.
json c .
.
.
.
.
.
busybox .
.
.
.
.
.
table impactofincremental statemerging.
speedup coverage avg.
med.
avg.
med.
libosip .
.
.
.
wget .
.
.
.
libtasn1 .
.
.
.
libpng .
.
.
.
apr .
.
.
.
json c .
.
.
.
busybox .
.
.
.
rq3answer allthecomponentscontribute.
.
foundbugs we found two bugs during our experiments with busybox.
in both cases anull pointerdereferenceoccurredintheimplementationof realpath inklee uclibc klee smodi f iedversionof uclibc .we reportedthebugs whichwerecon f irmedand f ixedbytheofficial maintainers .wenotethatthesebugsweredetectedby patand base but were not foundby cfgdueto atimeout.
1149statemerging with q uantifiersin symbolicexecution esec fse december3 san francisco ca usa .
threatsto validity first ourimplementationmayhavebugs.tovalidateitscorrectness weperformedaseparateexperimentwhereeachsubjectwasrun in thepatmode with a timeout of one hour.
during these runs wevalidatedthateveryexecutedstatemergingoperationiscorrect w.r.t.
theorem .
.
in addition for every query that our solving procedure was able to solve we validated the consistency of the reportedresult w.r.t.
the underlying smtsolver.
second ourchoiceofbenchmarksmightnotberepresentative enough.thatsaid wechoseadiversesetofreal worldbenchmarks used in prior work .
in addition we used benchmarks that processinputsofboth binary andtextual formats.
third weevaluatedourapproachinthecontextofthesymbolicsize model .
to address the threat that our approach may be bene f icial only in the context of that particular memory model we performedanadditionalexperimentusingthestandardconcretesizememorymodel.inthisexperiment wesettheconcretesizesof theinputobjectsaccordingtothecapacitycon f igurationintable andapplystatemerginginloopswhoseconditionsdependonthese sizes as we do in our original experiments.
the results shown in leadtoconclusionssimilartotheonesdrawn from the originalexperiments.
fourth the search heuristic might affect the coverage when theexploration doesnot terminate.
toaddress thethreat that our resultsmaybevalidonlyforthedfssearchheuristic weperformed anadditionalexperimentusingthedefaultsearchheuristicinklee.
the results shownin are comparable.
.
discussion takingahigh levelviewoftheexperiments weobservethatour approachbringssigni f icantgainsw.r.t.bothbaselinesinmostofthe benchmarks libosip wget apr json c andbusybox .thisisbecause these benchmarks contain an abundant number of size dependent loops that generate expressions that are linearly dependent on the numberofrepetitivepartsinthepathconstraints whichleadsto the detection of many regular and formula patterns.
in libtasn1 andlibpng however most of the size dependent loops generate expressions that cannot be synthesized with our approach for example aggregate values such as the sum of array contents.
as a result relativelyfewformulapatternsaredetected.nevertheless in these cases our approach still preserves the bene f its of standard state mergingw.r.t.
standardsymbolic execution.
related work compact symbolic execution uses quanti f iers to encode the path conditions of cyclic paths that follow the samecontrol f low pathineachiterationandupdateallthevariablesinaregularmanner.thisallowsthemtoencodetheeffectofunboundedrepetitions ofsomeof the cyclic paths in the program.
in contrast we seek regularity at the level of the constraints and therefore do not rely on uniformity in the control f low graph.in memspn section1 for example they can only summarize the paths in which either all thecharactersof sarematchedwiththe f irstcharacterof chars the then branch or the f irst character of sis unmatched the else branch .
in contrast our approach can summarize allpaths up to a given bound using two merged states.
furthermore solves quanti f ied queries using a standard solver as opposed to our specializedsolving procedure.
godefroidetal.
proposeadynamicapproach forinferring invariantsininput dependentloops whichallowsthemtopartially summarize the loop s effect on induction variables.
loop extended symbolicexecution summarizesinput dependentloops.ituses staticanalysistoinferlinearrelationsbetweenvariablesandtrip count variables tracking the number of iterations in the loop.
in contrast ourapproachdoes notrelyoninduction variablesorthe numberof loopiterations.
kapus et al.
summarize stringloops by synthesizing calls to standard string functions.
s looper introduces string constraints that can be solved by solvers that support thestringtheory.
ourapproach is not restrictedtostring loopsanddoes not require asolver supportingstringtheory.
veritesting improves the performance of symbolic execution by merging similar execution paths.
given a symbolic branch veritestingsummarizessideeffectsfrombothbranchsidestoavoid path explosion.
java ranger extends veritesting of java programs to support dynamically dispatched methods by using the runtime information available during the analysis.
multise summarizes updates to values by efficiently guarding each value withapathpredicate.kuznetsovetal.
mergesymbolicstates based on a query count heuristic that estimates if the merging would reduce the solving time in the future.
trabish et al.
perform state merging in loops that depend on objects whose size issymbolic.theyreducethesizeoftheencodingintheresulting mergedstatesusingtheexecutiontree butstillrelyondisjunctions anditeexpressions thereforeunabletoachievethereductionobtainedwithourapproach.weexplicitlycomparedourtechnique with theirs referred to as cfgin section and show that our approach performs better in many cases.
the works mentioned above do not address the encoding explosion problem caused by using disjunctionsand iteexpressions.
there are many works on handling quanti f ied formulas .
our solving procedure section mainly targetssatis f iablequeries andadaptsideasfrome matching and model based quanti f ier instantiation to our speci f ic needs.
conclusionsand futurework weproposeastatemergingapproachthatsigni f icantlyreducesthe encoding complexity of merged symbolic states and show through our evaluation that this is a promising direction toward scaling state merginginsymbolic execution.
ourapproachautomaticallydetectsregularpatternstopartition similar symbolic states into merging groups.
for each group we synthesize a formula pattern that enables an efficient encoding of the merged symbolic state using quanti f iers.
extracting more complexpatterns e.g.
beyondlinearformulas canfurtherimprove the applicabilityofour approach.