ui test migration across mobile platforms saghar talebipour university of southern california los angeles usa talebipo usc.eduyixue zhao university of massachusetts amherst amherst usa yixuezhao cs.umass.eduluka dojcilovi c university of southern california los angeles usa dojcilov usc.edu chenggang li university of southern california los angeles usa chenggan usc.edunenad medvidovi c university of southern california los angeles usa neno usc.edu abstract writing ui tests manually requires significant effort.
several approaches have tried to address this problem in mobile apps by exploiting the similarities of different apps within thesame domain on a single platform they have shown that itis possible to transfer tests that exercise similar functionalitybetween the apps.
a related recent technique enables transfer ofui tests uni directionally from an open source ios app to thesame app implemented for android.
this paper presents mapit a technique that expands existing work in three important ways it enables bi directional ui test transfer between pairs of sibling android and ios apps it does not assume that the apps source code is available it is capable of transferringtests containing oracles in addition to ui events.
mapit runsexisting tests on a source app and builds a partial modelof the app corresponding to each test.
the model comprisesthe app s screenshots obtainable properties of each screenshot sconstituent elements and labeled transitions between the screen shots.
mapit uses this model to determine the correspondinginformation on the target app and generates an equivalent test via a novel approach that leverages computer vision and nlp .
our evaluation on a diverse set of widely used closed sourcesibling android and ios apps shows that mapit is feasible accurate and useful in transferring ui tests across platforms.
i. i ntroduction writing ui tests manually requires significant effort.
this is an especially acute problem on mobile platforms given their rapid app development lifecycle.
a popular alternative is to automatically generate the ui tests e.g.
by relying on modelbased or random testing .
while these approaches have been shown effective for generating ui tests with high code coverage they cannot generate usage based tests that target an app s specific functionality such as login sign up make reservation etc.
it has been shown that such usage based tests are highly valuable to developers and testers .
recent work has demonstrated the possibility of generating usage based tests through test reuse across apps within a single domain e.g.
news shopping etc.
.
guided by this insight prior work has primarily focused on transferring existing usage based tests to a new app within the same domain on a single platform .
specifically these approaches leverage existing usage based tests from a source android app to automatically generate equivalent tests for a target android app.a largely unexplored variant of this problem is transferring tests written for an app implemented on one platform e.g.
android to the same app implemented for another platform e.g.
ios .
we refer to such pairs of apps as sibling apps.
cross platform transfer has unique challenges as compared to test transfer within android alone.
first different platforms employ different technologies such as various app development languages and frameworks which add significant complexity to the problem.
second ios is a closed source platform whichhas led to fewer and more limited tools for analyzing ios apps compared to android.
finally most ios apps themselves are closed source making any code based analysis impossible.
the closest attempt at this problem is testmig which has addressed uni directional test transfer for sibling ios and android apps.
testmig has three important limitations.
first it assumes the availability of both the android and ios apps source code which as mentioned is especially unlikely forios apps.
second testmig only covers transferring tests in one direction ios to android .
supporting the other direction android to ios is inherently challenging unlike android for which many open source reverse engineering tools are readily available e.g.
bytecode decompilers soot gator ios is a closed platform with a smaller developer base and static analyses that existing test transfer techniques rely on arenot an option.
third testmig only targets ui events but cannot transfer test oracles or system events.
oracles are responsible for evaluating the outcomes of tests and are therefore an essential part of usage based testing.
inability to migrate system events additionally limits the set of test cases that can be transferred.
for instance navigating to the previous screen is an andriod system event that frequently occurs in ui tests.
to address these limitations we have developed mapit a novel approach for bi directional transfer of usage based tests across different mobile platforms with no source code required on either platform.
mapit is also the first approach capable of transferring oracle events and system events across mobile platforms.
specifically mapit takes as input the binaries of the sibling apps under test implemented for both ios and android as well as the pre existing tests for one of these platforms and automatically generates equivalent 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee tests for the other platform.
the transfer process comprises two major phases.
first mapit dynamically extracts a gui model of the app on the source platform while executing the source test.
the gui model contains the app screen bitmaps information regarding the relevant widgets contained on each screen e.g.
widget images and descriptive attributes and the events that cause transitions from one app screen to the next.
second based on this gui model the source test is migrated to the target platform by mapping the gui widgets from the source app to the most similar widgets in the sibling app.
thisis done using a novel approach that combines computer vision and nlp techniques and therefore leverages both visual and textual features of apps for mapping gui widgets.
this process additionally recognizes and transfers oracle and system events.
we empirically evaluated mapit on pairs of sibling android and ios apps spanning app categories.
for each pair of sibling apps we transferred test cases corresponding to representative usage scenarios in both directions to evaluatemapit s ability to correctly transfer both individual events and test oracles as well as complete tests.
in total ourevaluation yielded bidirectional transfers of test cases including ui events oracle events and system events.
overall mapit achieved over event mapping ac curacy and showed to be useful in reducing the required manualeffort by over .
furthermore complete test cases were transferred correctly eliminating the manual effort.
note that even if a test is not completely transferred correctly the reduction in manual effort mapit affords is proportional to thefraction of individual events that were successfully transferred.
in those cases the developer can complete the partially transferred test by modifying the events tagged as incorrectly transferred.
furthermore in our evaluation of mapit s accuracy when transferring individual events we compared ourcomposite mapping technique against only textual or only visual information as used in previous cross platform transfer techniques and showed that our composite approach outperforms the previous techniques in nearly all cases.
this paper makes the following contributions a novel technique for bi directional cross platform transfer of usage based tests for closed source apps.
a novel ui widget mapping solution that combines pluggable computer vision and nlp techniques.
an extensible approach for transferring test oracles and system events across mobile platforms.
an empirical evaluation on closed source real world apps and a public repository with mapit s implementation and artifacts to foster future research .
section ii presents our work s background via an exampleand introduces the key terminology.
section iii presents ourapproach and section iv its empirical evaluation.
section v overviews the related work.
section vii concludes the paper.
ii.
b ackground and terminology figure shows the screenshots of the login pages of etsy a popular shopping app on android left and ios right .although the two login pages are not identical they share significant similarities in the appearances of their ui widgets the textual data describing these widgets and the widgets position on the respective screens.
such and even greater pairwise similarities between sibling apps are common.
let us assume that a test of etsy s login functionality exists on android and that we want to transfer it to ios.
the widgets involved in the login test are framed and labeled for both platforms in figure .
we will use this scenario to introduce the terms and describe the concepts relevant to our approach.
the source app is the app with existing tests that are to be transferred to the target app.
source platform and target platform are the platforms on which the source and target apps run respectively.
the source test is the existing test to be transferred while the target test is the transferred test.
a ground truth test is an existing test for the target app that tests the same functionality as the transferred source test .atest scenario is an informal description of a test case in natural language.
for instance the login test scenario consists of entering username and password and clicking the login button.
aground truth test is thus used for evaluating the success of a test transfer corresponding to the same test scenario in the two sibling apps.
note that the source test that is transferred e.g.
from ios to android serves the ground truth test when transferring the same test scenario in the opposite direction.
the contents of a given screen of an app form an app state.
equivalent states on the source and target apps are the states intended to provide the same or equivalent functionalities usually with similar looking uis.
for instance figure shows two equivalent states of the etsy app on android and ios since they both target login functionality.
anevent is defined as a tuple a w t o .
each event has one required element a which is the type of action associated with the event.
the remaining three elements are optional wis the ui widget tis the input text associated with the event such as text entered by the keyboard and ois the oracle type.
mapit supports three types of events ui events for which the supported action types are click andkeyboard input oracle events which are the assertions in the ui tests that determine d d d e e e e d fig.
login pages of etsy on android left and ios right .
ss soruhu 6rxufh 7hvw qwhuqdo 7hvw hqhudwru ss soruhu 7hvw hqhudwru7dujhw 7hvw6rxufh dwd wudfwlrq 3kdvh 7hvw 0ljudwlrq 3kdvh hylfh rq 6rxufh 3odwirup rppdqg yhqwv8 7udqvlwlrq 0rgho uhsuhvhqwlqj 6rxufh 7hvw 6fuhhq8 6wdwh hylfh rq 7dujhw 3odwirup8 6fuhhq rppdqg 0dsshg yhqw 0dsshg yhqw8 7udqvlwlrq 0rgho uhsuhvhqwlqj 7dujhw 7hvw 6rxufh ss 7dujhw ss qwhuqdo 7hvw yhqw 0dsshu2udfoh 0dsshu6 vwhp yhqw 0dsshu yhqw 0dsshu fig.
high level workflow of mapit.
whether a test should pass or fail for which the supported action type is oracle and system events for which the supported action types are back andenter .
note that wis optional since not all events have an associated widget e.g.
system events .
if the event is an oracle event ocontains the specific oracle type.
to demonstrate mapit s ability to transfer oracles in this paper we focus on a representative cross section ofassertion types identified by prior work which will be detailed in section iii.
as an example the ui event of entering the username usr for logging into etsy on android is represented as a tuple a keyboard input w a1 t usr 1 o .
finally each ui test consists of a sequence of tuple events.
iii.
a pproach figure shows an overview of mapit s workflow.
the input to mapit is three fold source test written for the source platform source app that runs on the source platform and its sibling target app that runs on the target platform.
mapit automatically transfers the source test through two major phases source data extraction during which the data needed for the test transfer is dynamically extracted from the source app and test migration during which the extracted data is used to generate the target test the source test s equivalent on the target platform.
the remainder of this section details the two phases.
in developing mapit we made several implementation decisions driven by the third party technologies on which we relied.
we highlight those whenever they are instrumental in enabling a particular facet of mapit.
overall mapit is implemented in .
ksloc of python additionally integrating off the shelf tools for mobile app monitoring analysis and testing.
a. source data extraction during the source data extraction phase the internal test generator component first transforms the pre existing source test to the internal test which is captured in mapit s internal representation for test cases.
this internal representation is both programming language and testing framework independent a critical requirement of cross platform test transfer.
basedon the internal test the app explorer component gradually generates a ui transition model which consists of the observed ui states of the app and the transitions between them.
each transition represents one event e.g.
button click within the corresponding test case.
the ui transition modelis generated by executing each event of the internal test on the source platform and dynamically extracting the requisite information from the source app.
we describe the internal test generator and app explorer components in more detail next.
internal test generator as mentioned above this component translates the source test into the language and platform independent internal test .
figure illustrates this with an example of translating a partial test of etsy s login functionality written in python for the appium testing framework figure a to mapit s internal format figure b .
a test is represented internallyby mapit as a sequence of tuple event s as defined in section ii with the event elements w t and obeing optional.
note that each widget wcontains the information used to locate this widget in the source test such as accessibility id resource id xpath o r coordinates .
thus wis represented as alocator type and its corresponding locator value .
as a proof of concept mapit currently includes support for translating tests written in python for appium and the robot framework.
these two frameworks are widely used in mobile app testing.
the translation in each case is doneby mapping framework specific tests to mapit s internaltest representation through regular expression matching.for instance the first two lines of the appium python testshown in figure a are matched by the regular expressions .
driver.find element by .
.
and el.
.
.
.
respectively and the action locator type locator value and input elements are extracted from them to form the first event in mapit s ho sslxp zhegulyhu ilqgbhohphqwbe blg frp hwv dqgurlg lg hglwbsdvvzrug ho vhqgbnh v sdvvzrug d ho sslxp zhegulyhu ilqgbhohphqwbe blg frp hwv dqgurlg lg exwwrqbvljqlq ho folfn ho sslxp zhegulyhu ilqgbhohphqwbe bdffhvvlelolw blg rx wde ri ho folfn he ulyhu zdlw sslxp zhegulyhu xqwlo ylvlelolw bribhohphqwborfdwhg lg frp hwv dqgurlg lg xvhuqdph dfwlrq nh erdug lqsxw lgjhw orfdwru w sh uhvrxufh g orfdwru ydoxh frp hwv dqgurlg lg hglwbsdvvzrug wh w lqsxw sdvvzrug dfwlrq folfn lgjhw orfdwru w sh uhvrxufh g orfdwru ydoxh frp hwv dqgurlg lg exwwrqbvljqlq dfwlrq folfn lgjhw orfdwru w sh dffhvvlelolw g orfdwru ydoxh rx wde ri dfwlrq rudfoh lgjhw orfdwru w sh lg orfdwru ydoxh frp hwv dqgurlg lg xvhuqdph rudfoh zlgjhw glvsod hg zrug e fig.
translating a etsy s login test written in python for the appium framework to b mapit s internal representation.
fig.
app explorer s internal architecture.
internal test format shown in figure b. this mechanism can be easily extended to translate ui tests written in other programming languages and or for other testing frameworks.
app explorer as shown in figure the app explorer component interacts with a mobile device and gradually generates the ui transition model of the source app while executing the sequence of events in the internal test.
specifically app explorer consists of three sub components as shown in figure event executor state extractor and model generator.
event executor this sub component is tasked with initiating and maintaining an active connection with the mobile device.
it takes the events from mapit s internal test as input and transforms each event to the corresponding commands thatare transmitted to the device and executed.
event executor uses appium for device communication.
in turn appium relies on android debug bridge a tool for communicating with android devices and web driver agent an interface for remotely interacting with ios devices.
state extractor for each event triggered by event executor state extractor captures and processes the data associated with the current device screen in order to generate the current ui state.
a ui state sconsists of the app s current screenshot the graph representing the screen s ui layout hierarchy and all ui widgets that exist on the current screen.
figure shows an example of the ui state extracted from the etsy app at the beginning of a login test scenario.
specifically state extractor first captures the bitmap of the current screen shown in the center of figure and extracts itspage source which contains the screen s ui information as an xml hierarchy .
it then iterates through the ui layout contained in the page source and builds a graph based on the ui element hierarchy shown on the left of figure .
while iterating through the ui layout state extractor extracts the boundaries of each ui widget and crops the capturedscreenshot to get the image representing the widget on thecurrent screen.
also extracted and stored are each widget sdescriptive attributes in the ui layout such as resource id name coordinates element type and whether it is interactable shown on the right of figure .
finally if the widget has any visible text on its image such text is captured using ocr.
to this end we leveraged the tesseract ocr engine .
model generator app explorer s third sub component incrementally generates a ui transition model uitm based ontheui states extracted from state extractor e.g.
recall figure and their corresponding events obtained from internal test generator recall figure .
uitm is a linear fsm representing the transitions in the app taken while executing each event.
uitm has no back transitions app state associated with a given screen is captured separately each time the screen is visited.
specifically uitm a t is the transition model of app a associated with ui test case t which is a sequence of events e1 e2 ... e n. the initial ui state of the app when executing t is annotated as s0.
every state siis reached by successfully executing event eiin state si .
if the event sequence contains nevents the uitm will contain n states s0 s1 ... sn.
figure shows the uitm extracted from the android version of etsy representing a login test case consisting of five events.
this ui transition model is a platform independent representation of the app under execution and can be reused in other cross platform mappings involving closed source apps.
mapit extracts and populates the model with more comprehensive data from each state of an app compared to the corresponding models offered by the existing approach that focuses on extracting models from both ios and android apps .
b. test migration in mapit s second phase the source test is migrated to the target platform.
this is done by transforming uitm a t e x tracted during the previous phase into uitm a prime t prime where a primeis the sibling app of aandt primeis the test generated by mapit to target the same functionality on a primethatttargeted on a. test migration is accomplished iteratively via three principal components app explorer event mapper and test generator recall figure .
a high level summary of this phase is provided in algorithm .
uitm a prime t prime is initialized with s prime which is the initial state of the target app lines .
as depicted in figure this state is extracted using a second instance of the app explorer component discussed in the previous phase this instance of app explorer is responsible for interacting with the target device.
for each state siand transition triggering event ei inuitm a t the event mapper component finds the equivalent e prime i event in the current state s prime ion the target platform line .
e primei is executed by app explorer resulting in the transition from s prime itos prime i line .
additionally e primei is added to the target testt primeby the test generator component line .
at this point s prime i becomes the current state and its corresponding information will be extracted by app explorer line and added to uitm a prime t prime as a new state connected to s prime ivia the transition corresponding to e primei lines .
when the final state of the source app s model is reached all events in the source test have been migrated to the target platform.
event mapper is the core component of mapit.
it dynamically maps each event from the source platform to its equivalent event that is executable in the current state of the target app.
ittakes each state and event in the extracted uitm a t from the previous phase as well as the corresponding state in the target app and outputs the mapped event.
recall from section ii that mapit supports the transfer of three types of events 759algorithm high level test migration process input app a prime ui transition model uitm a t output test t prime ui transition model uitm a prime t prime 1uitm a prime t prime 2s prime extract current state a prime 3uitm a prime t prime .add state s prime 4foreach si ei in uitm a t do e prime i map event s i ei s prime i execute event a prime e primei t prime.add event e primei s prime i extract current state a prime uitm a prime t prime .add state s prime i uitm a prime t prime .add transition s prime i s prime i e primei 11end ui oracle and system events.
correspondingly as shown in figure event mapper consists of ui event mapper oracle event mapper and system event mapper subcomponents.
mapping a source event is handled differently by its corresponding mapper based on the event type.
we now detail each of these mappers.
we will then elaborate on test generator the final component in mapit s architecture.
ui event mapper recall that an event is a tuple a w t o some of whose elements may be optional.
all elements present in a given event must be mapped from the source to the target platform.
for ui events action type acan be click orkeyboard input .
in both cases awill be migrated to the target platform as is.
for keyboard input actions the event will also contain text input t which remains unchanged in the mapped event.
to map a source ui widget wto its most similar widget in the current ui state of the target app mapit leverages both visual and textual information.
as shown in figure it does so via visual comparator textual comparator and widget selector sub components.
by contrast previous work has explored using only textual or only visual features of the screen for widget mapping.
in the ensuing discussion we referto the combination of these three sub components as ui widget mapper to distinguish them from the entire ui event mapper although a key function of ui event mapper is indeed the mapping of ui widgets w it is also responsible for mapping the other elements of an event a t o to the target platform.
visual comparator this sub component extracts the cropped image and coordinates of widget wfrom source app s state s and all widgets that exist in target app s current ui state s prime.
it then calculates a visual similarity score with respect to w for each widget of s primeand ranks the target widgets accordingly.
the intuition behind this component is that equivalent widgets on different platforms tend to have very similar looks by design.
visual similarity of two widgets is computed as the weighted average of their image screen location and size similarities.
computing the latter two scores is relatively straightforward.
the proximity score of two widgets is computed based on the euclidean distance of their locations on the screen.
the size similarity score is determined based on the difference in widget sizes normalized by the device size .
to compute the image similarity score visual comparator leverages the key points and feature descriptors extracted from both the source and destination widget images.
animage s key points are its pixels that have a prominent difference of intensity with their adjacent pixels .
feature descriptors are numerical representations that encode data about each key point s neighborhood and are used widely for image comparison .
for detecting an image s key points and subsequently its feature descriptors we use orb algorithm which is an state of the art image matching technique that has shown to be highly efficient.
once the sets of feature descriptors corresponding to source and destination images have been obtained visual comparator computes the hamming distance for each pair of source and destination descriptors.
it then ranks the destination descrip tors for each source descriptor based on the computed distance.good matches between these two sets of descriptors are next de termined via lowe s ratio test which is widely used in image matching tasks.
in this test for each descriptor of the source fig.
ui state captured from etsy s login page.
the two ui layout hierarchy elements highlighted on the left correspond to the widget data shown on the right.
!
fig.
uitm extracted from etsy s login test case.
each state s0 s5is in the format shown in figure .
7606hyhqw d z w r 0dsshg hyhqw lgjhw 6hohfwru7h wxdo rpsdudwru9lvxdo rpsdudwru8 lgjhw 0dsshu 0dsshg zlgjhw8 lg8 yhqw 0dsshu d w r z d w r z fig.
ui event mapper s internal architecture.
image the two closest matches among the destination descriptors per the computed hamming distance are selected.
if the value ofdistance closest match distance second closest match is less than a customizable ratio then the closest match is considered to be a good match.
we empirically explored different ratios and set the value to .8in our evaluation reported in section iv.
at the end of this process each descriptor of the source image is labeled asmatched if it has a good matching destination descriptor.
finally visual comparator computes a normalized image similarity score for each destination image with respect to the source widget w. this score is calculated as the ratio ofmatched source descriptors to the maximum number of descriptors extracted from the source and destination images.
textual comparator this sub component determines atextual similarity score between two widgets.
it leverages the widgets textual data from their respective uitms extracted by mapit s app explorer recall section iii a .
a widget s textual data consists of the values of its textual attributes.
these attributes are a subset of the information extracted by state extractor recall figure for each widget and include content descriptor resource id and text for the widgets on android and their ios counterparts accessibility id name and label .
any text extracted from a widget s image is also included in its textual data.
for illustration in the etsy example from figure the textual data describing the sign in button on android a3 i s content descriptor resource id com.etsy.android id button signin text widget text sign in while the textual data describing the corresponding button on ios b3 i s accessibility id name sign in label signin widget text sign in .
note that a ui widget need not have all of the mentioned textual attributes.
also the values of multiple attributes may be identical.
in the above case the android widget a3 does not have the content descriptor attribute while the values of name label and widget text attributes for the ios widget b3 are the same.
textual comparator first pre processes the extracted textual data using common nlp practices such as tokenization and stop word elimination.
in addition to general purpose stopwords we constructed a new list of common stopwords in widgets textual attributes that typically do not convey meaningful information such as view bar and container .
textual comparator computes a pairwise similarity score for a given pair of source target widgets textual attributes.
it uses word2v ec and the standard tf idf formula to transform each textual attribute into its embeddings.
the similarity score is then calculated based on the embeddings cosine similarity .
textual comparator computes the similarity score of all pairs of textual attributes regardless of their types e.g.
it will compare text andaccessibility id to maximize the chance of discovering similar widgets.
the reason is that meaningful textual values may be arbitrarily assigned to any attribute in practice.
the textual similarity score between two widgets is then calculated as the highest cosine similarity score among thetextual attribute pairs.
this process naturally filters out the simi larity scores calculated based on meaningless textual attributes.
as an example the home button in etsy on android has com.etsy.android id menu bottom nav home as its resource id and home tab of as its accessibility id .
the same button on ios has home as itsname and as its value attribute.
after the preprocessing step the textual attributes for the android widget become home and menu bottom nav home respectively.
while the cosine similarity between e.g.
menu bottom nav home and is very low .
android s resource id and ios s name are identical home .
this means that the textual similarity score between the two widgets is .
.
widget selector ui event mapper s third sub component selects the mapped ui widget based on the visual and textual similarity scores.
it does so by first checking the top ranked widgets based on the visual and textual similarity scores.
if the respective top ranked widgets are the same widget selector will select this as the mapped widget.
otherwise since the textual data is more informative widget selector first checks whether the top ranked widget in the textual similarity ranking has a score higher than a given adjustable threshold.
if such a widget w primeexists then widget selector will first select all target widgets whose textual similarity score is within an adjustable proximity range of the textual similarity score of w prime.
these selected widgets are considered as close textual matches.
widget selector will choose the widget with the highest visual similarity score among the close textual matches.
if no widget s score is above the specified textual similarity threshold then the mapped widget is the one with the highest visual similarity score.
at this point the final mapped widget is checked for compatibility based on whether its action type is supported on the target device.
if the mapped widget cannot support the transferred action widget selector will remove it from both rankings and then choose another ui widget based on the above process.
oracle event mapper this component is responsible for mapping all four elements a w o t of an oracle event.
for these events the action type a that is oracle and oracle type oare always required and are both migrated to the target platform as is.
mapping the other two elements wcorresponding to the widget and tcorresponding to text is more challenging.
mapit handles the transfer of these 761two elements depending on the oracle s type as detailed below.
as explained in section ii we currently support several common types of oracles identified by prior work mapit can be easily extended to include additional oracle types.
table i shows the oracle types currently supported by mapit divided into widget independent and widget dependent oracles.
note that transferring test oracles is more challenging across platforms than on a single platform since the supported oracle typesand widget attributes will differ across platforms.
this requires more challenging heuristic based mappings as detailed next.
the widget independent oracle types currently supported by mapit are text existence txt and text invisible txt .
these oracles respectively check the presence and visibility of text in the app s current state.
in representing these oracles viamapit s internal events the value of the parameter txtis captured by the oracle event s element t. in these cases the text input txt of the source event will be transferred to the target event as is and the presence or visibility of the same text checked on the target platform.
the widget dependent oracle types mapit currently supports are widget exists w widget invisible w and assert equal w attr val .
for this group of oracles the corresponding mapit events also contain the widget element w which is mapped by ui widget mapper as discussed above.
transferring the widget invisible w oracle is more challenging than widget exists w .
the reason is that the widget wdoes not exist in the current state of the source app and therefore it is not possible to extract the needed data for the widget mapping process from the source ui state.
instead we hypothesized that in most test cases in which the invisibility of a widget wis asserted wis visible in some other app state that is visited during the execution of the scenario under test.
thus for each widget invisible oracle in the source test the existence of its associated widget wis checked in all states of the source app that are visited during the migration process.
if wis found in any state son the source app ui widget mapper will search for its equivalent widget w primein the equivalent state s primeon the destination platform.
after mapping w all remaining elements of the oracle event are mapped to the target platform.
if wis not found its corresponding oracle event will be marked as not mappable on the target test.
the assert equal w attr val oracle checks whether the value of the attribute attr of widget wis equal to the asserted value val.
in this case mapit captures the combination of attr andval parameters as oracle event s element t. transferring this oracle type is challenged by the differences in the widget attributes maintained by ios and android.
the only attribute that exists on both platforms is enabled .
some widget attributes widget independent test oracles textexistence txt textinvisible txt widget dependent test oracles widg etexists w widg etinvisible w assert equal w attr val table i oracle types supported by mapit.have different names but equivalent meanings.
this includes the attributes forming the previously discussed textual data and their corresponding mappings as well as android s visible and ios s displayed attributes.
another group of attributes can be mapped using heuristics.
for instance the selected and checked attributes assess whether a widget e.g.
radio button tab is selected checked on android.
although these two attributes do not exist on ios developers usually denote a widgetbeing selected checked by assigning to its value attribute or including the word selected in its accessibility id .
for other attributes e.g.
android s clickable a mapping is not possible.
mapit transfers such assert equal w attr val oracles to a not mappable event on the destination platform.
system event mapper for system events mapit supports the action types enter and back .
for these events only the action type ain the tuple a w t o has a value.
if aisenter it will remain unchanged between the source and target events.
the challenge in transferring system events is that they may be handleddifferently across platforms.
an example is the transfer of a back system event.
a back is a system event on android but no corresponding system event exists on ios.
instead ios s equivalent would be a ui event with a widget that appears as a back button on the app screen.
we discuss how mapit handles this event s mapping in both directions.
when mapping from ios to android mapit only has to check whether the source event is indeed a back event.
this is done by checking whether the source event s action type aisclick and whether the textual attributes of its widget wcontain the keywords back or previous .
the mapping from android to ios is more challenging since it requires relating a system event to a ui event where the lattercontains information not present in the former.
to address this mapit internally introduces a virtual click event and an associated back button widget.
this widget contains the bitmap of atypical back button with coordinates normalized by device size and relevant textual data to describe the button e.g.
the string back button as the value of the content descriptor attribute .
the normalized coordinates are calculated based on the observation that in most ios apps the back button is located in the bottom left corner of the screen.
finally the corresponding back button on ios is identified by mapping this virtual widget using ui widget mapper as discussed previously.
test generator finally the test generator component generates a ui test for the target platform based on the mapped events.
the generated test is in the internal test format discussed in section iii a. generating tests is particularly challenging when the ui widget w primein a mapped event a prime w prime t prime o prime does not contain an attribute that can be used as a widget locator e.g.
accessibility id orresource id .
this information is needed to identify a specific ui widget to trigger an event.
in such cases mapit needs to generate a locator that is understandable to the target device.
762there are two options to locate the target widget using the widget s coordinates or using the widget s xpath which is the ancestral path from the root of the ui layout hierarchy .
we choose xpath because coordinates are tied to a specific device which would result in brittle tests that are not executable on other devices.
to automatically generatethe xpath locator for a target widget test generator leverages the ui layout hierarchy graph recall figure which is stored as part of the target app s uitm figure .
specifically test generator traverses this graph until the mapped event a prime w prime t prime o prime is reached and retrieves the xpath associated with the target widget w prime.
the xpath is then stored as the mapped event s locator using internal test s representation discussed in section iii a and depicted in figure b. iv .
e v alua tion our evaluation focuses on two key aspects of mapit its accuracy in mapping events from a source to a target platform and usefulness of the tests it transfers.
we first describe our empirical setup and then present the evaluation results.
a. evaluation setup mapit is not tied to a specific android or ios version or device and is only practically constrained by the tools on which its implementation currently relies.
our evaluation was performed on an iphone running ios .
and a pixel emulator running android .
installed on a macos laptop with 16gb ram and .5ghz dual core core i7 processor.
as discussed in the context of ui event mapper in section iii b mapit has two adjustable parameters textual similarity threshold and proximity range.
we empirically determined the best performing values for these parameters to be .
and .
respectively.
our results reported in this section were obtained using these values.
recall that unlike the lone existing approach for crossplatform test transfer mapit does not require the apps source code.
since mapit targets the bi directional transfer of the same app across different platforms we selectedpopular apps that are available on both android and ios.
we first chose five different app categories news shopping todo list web browser and mail client.
we chose these categories for two reasons they have a number of sibling apps on ios s app store and android s google play and apps from these categories have been used to evaluate test migration techniques previously .
in each category we selected five frequently downloaded apps that are available on both platforms totaling app pairs shown in table ii.
table iii shows the test scenarios we used to evaluate mapit.
we selected the most common scenarios for each app category as identified by prior work and subsequently expanded the scenarios by further examining the subject apps.
for each app we evaluated four scenarios.
more thanfour scenarios are shown in three of the categories becausea given scenario may not be applicable to all subject apps.
within each scenario we also identified a set of oracles i.e.
conditions that must hold true in the app at a given point.
to generate the test scripts for both android and ios platforms we manually trigger the events including both ui and system events in each test scenario and used appium to record the process.
appium automatically converts the recorded test scenarios to test scripts in the robot framework format .
these test scripts serve as both source tests to be transferred from and ground truth tests to evaluate mapit s accuracy and usefulness.
we manually added oracle events to the tests after they were translated to mapit s internal formatduring the source data extraction phase recall section iii a .
this was done because the employed appium interface did not allow us to automatically add the oracle events while recording the tests.
in the required manual process we decided to add news shopping todo list web browser mail client bbc wish google tasks chrome gmail ccn etsy microsoft to do firefox blue mail abc news ebay to duckduckgo edison mail the guardian poshmark any.do brave spark mail usa today aliexpress my tasks edge newton table ii subject apps used for mapit s evaluation.
fig.
the accuracy of mapit s event mapping across different app categories.
within each category there are two clusters ofresults the left unhighlighted cluster represent the mapping from android to ios and the right highlighted from ios to android.
within each cluster the results are divided by mapping strategy vision only left text only middle and composite right .
763these events to the internal test rather than the original tests.
note that while this decision may be a limitation of mapit s current implementation it does not present a threat to mapit s validity or applicability the same regular expression matching algorithm used in internal test generator can be leveraged to translate oracle events from any format or language that supports them to mapit s internal representation.
we used mapit to transfer each test script from android to ios and vice versa.
this yielded transfer cases in total apps tests directions .
overall our tests contain ui events oracle events and system events.
this averages to slightly over events per test.
overall the choices we made in evaluating mapit number of apps tests oracles and test sizes are at least comparable to and in several instances significantly surpass those reported in the emerging literature on mobile app test transfer .
our approach does not require all tests to have oracle events since in some cases the goal of usage based tests is only to confirm that a specific scenario can be executed on a device without causing the app to crash.
therefore we include scenarios both with and without oracle events.
this makes our evaluation reflective actual usage based testing in practice.
furthermore there was no notable difference between the mapping accuracies for different types of events.
this stronglysuggests that omitting oracle events from certain tests does not impact the validity of our evaluation results.
b. accuracy of event mappings this part of our evaluation focuses on mapit s ability to correctly transfer a given app oracle or system event e from a source test containing eto the corresponding event cate gory test scenario news1 save or bookmark specific news article navigate to specific category of news search for specific news topic personalize newsfeed based on news topics change edition follow author shop1 login to user account remove item from shopping cart navigate between product categories add item to shopping cart make wishlist filter products todo1 add todo task remove todo task edit todo task change due date of todo task web1 access website by url navigate to previous page navigate to new browser tab bookmark url mail client1 compose email search email by keyword move emails across folders archive existing email reply to email table iii the evaluated scenarios for each app category.e primein the target test.
specifically this reflects the accuracy of event mapper mapit s core component recall section iii b .
measuring event mapper s accuracy requires that we isolate its impact from mapit s remaining components.
to explain how we accomplish that consider the following scenario.
siis a state in the source app and s prime jits equivalent state in the target app.
event ei is an event in the extracted uitm representing a source test that takes the source app from sitosi recall figure .
we evaluate whether event mapper is successful in finding the correct mapping for ei that will advance the target app from state s prime jtos prime j .
to this end we manually inspect each pair of sibling apps and detect their equivalent states for each test scenario based on the functionality they provide.
we feed those states alongside the source event to event mapper.
manually detecting equivalent states in sibling apps was straightforward in practice in more than of the cases in our subject apps there existed one to one mappings between the source and target states and they occurred in the same order i.e.
i j .
this is consistent with our guiding hypothesis that sibling apps will have highly similar functionalities by design.
the correctness of each source event s mapping is determined by manually comparing the transferred test and the groundtruth test.
note that there can be multiple correct mappings fora given source event.
for example the correct mapping of the click event on widget a3in figure can be a click on either b3orb4since they both result in the same action.
mapit s test transfer approach assumes that there exists one to one mappings between ui states of the sibling apps.however in certain rare cases the numbers of events thatrepresent the same test scenario will differ between the two platforms.
for example etsy s login on ios requires the user tochoose the account type first and then navigate to the main login page whereas on android the user chooses the account type on the login page itself.
in the test scenarios used in our evaluation we encountered only such cases this prevalence is consistent with previously reported results .
such differences do not impact mapit s event mapping accuracy.
in stead mismatched ui states affect the usefulness of transferred tests and are taken into account in section iv c below.
recall from section iii that mapit introduces a combination of visual and textual techniques for mapping events between platforms.
we thus also evaluate the benefits of this compositemapping.
note that the sole previously existing cross platform test migration technique testmig only employs textualmapping .
adding visual information was important in our case since we target closed source apps whose textualinformation is limited due to the unavailability of app code.
we were unable to directly compare mapit s accuracy with testmig for two reasons.
first testmig requires access to an app s source code while the code of nearly all of oursubject apps is unavailable.
second testmig only supports uni directional transfer from ios to android.
figure shows the accuracy of our bi directional event mapping in each app category based on vision only text only andcomposite mappings.
with one exception mapit s composite 764mapper outperforms the other two strategies.
the composite mapper was able to accurately map events in over3 4of all cases see all categories in figure .
no notable differences in accuracy emerged when mapping ui oracle or system events.
furthermore these results are independent of the platform the overall results are separated by a single percentage point between the android to ios and ios to android mappings.
the lone exception to the above trends is the ios to android mapping of web browser apps.
our subsequent analysis uncovered a likely reason and a possible remedy.
namely in mapit s analysis of some of the browser apps a textually mapped widget would have been the correct widget to select but its textual similarity with the source widget was below thethreshold discussed in section iii b .
in those cases the visually mapped widget was chosen per the strategy adopted by mapit.however this was a flawed strategy because of the sibling apps layout differences.
this suggests that the thresholds which we set across all apps may need to be further tuned for different app categories and possibly based on other criteria.
c. usefulness of transferred tests to assess how useful the tests transferred by mapit are we leverage a metric introduced by recent work which measurs the reduction in the manual effort required to accomplish a testtransfer task.
specifically the manual effort required after using mapit is quantified as the number of steps needed to rectify the incorrectly mapped events in the transferred test while the effort without using mapit amounts to the number of steps needed to write the entire ground truth test from scratch.
a step can be an event s insertion deletion or substitution .
to perform this evaluation we provide mapit with the binaries of sibling apps as well as a test script on the source platform and compare the transferred test to the ground truth on the target platform.
recall from section iv b that there may exist multiple correct mappings for a source event.
for this reason we manually inspect each transferred test to verify the correctly mapped events.
figure shows the average effort reduction across the different subject app categories.
overall mapit reduces morethan half the manual effort required to write ui tests for a new platform.
furthermore the average reductions are similar in the two transfer directions indicating that mapit s usefulness is independent of the platform.
in our evaluation mapit fig.
effort reduction afforded by mapit.
result pairs within each app category correspond to the mappings from android to ios left and from ios to android right highlighted .was able to achieve reduction eliminating all manual effort in of test cases .
if we consider these results in tandem with those from figure it is interesting to note that in a number of instances mapit achieved high accuracy but relatively low reduction i.e.
usefulness .
initially this seemed counter intuitive since in principle accurate event mappings should result in high quality transferred tests.
however a more detailed analysis uncovered that the incorrectly mapped events in these cases are rare but they start appearing relatively early in a transferred test.
in turn this leads a target app into an incorrect state early during the test migration phase and causes it to get lost so that all subsequent source events are also mapped incorrectly.
in a great majority of cases these subsequent events would have been mapped correctly if the app were in the correctstate as can be confirmed by mapit s complete accuracy data .
in fact of the test cases would only have one incorrectly mapped event if a correct app state were reached.
this strongly suggests that minor human effort hasthe potential to improve mapit s usefulness significantly.
for example slightly nudging mapit in certain cases by manually providing a correct mapping of a single event or by guiding the target app once to a correct state would combine these cases with the fully transferred test cases to raise mapit s reduction in effort to nearly zero in2 3of cases.
another aspect of mapit s usefulness we measured is its performance.
although we have not optimized mapit for speed this aspect of our prototype is an indication of its real world applicability.
on average mapit s source data extraction phase took seconds and its test migration phase took seconds in other words the entire transfer process averaged slightly over minutes per test.
in general mapit s execution time depends on the number of events in a test as well as the complexity of an app s screen layout ateach step of the execution.
an average test in our evaluation had events while each app screen averaged widgets that needed to be extracted and compared.
v. r ela ted work testmig is the lone existing approach for migrating tests across platforms.
however testmig only transfers tests from ios to android and requires the source code of both source and target apps.
other approaches in the mobile app domain have focused on migrating ui tests between different android apps within the same category.
behrang et al.
and lin et al.
rely on static code analysis for extracting the gui models of the app which are not available for closed source ios apps.
mariani et al.
formulated the test reuse problem as a search problem and used evolutionary testing to transfer tests across different android apps.
hu et al.
proposed a machine learning based approach for generating ui tests for an app usinga library of existing tests.
this work generates regression tests for a specific app rather than enabling test migration.
zhao et al.
proposed a framework for automatically evaluating the previous approaches but did not specifically address test migration.
mariani et al.
presented an empirical study 765on techniques for semantic matching of gui events used by existing test reuse approaches.
beyond the mobile app arena rau et al.
proposed an approach for efficiently generating ui tests by learning from the existing tests of other apps but their work targets web applications.
similarly yeh et al.
proposed an early image based platform independent testing tool for testingdesktop and web applications.
finally mariani et al.
proposed an approach that automatically exploits the common functionalities of java applications to generate ui tests.
another related body of work focuses on remote app execution.
y u et al.
proposed lira t a record and replay technique for executing scenarios across mobile platforms.
their approach is based on image feature matching and ui layout characterization.
compared to mapit s compositeapproach using only visual features lowers the mapping accuracy especially in cases where the source and target apps are not visually identical.
furthermore leveraging textual data using a technique such as word2v ec which focuses on the semantics behind the data instead of the exact word matching makes mapit s approach more suitable as a foundation for cross platform test transfer than lira t .
another recent approach enabled remote interaction with ios devices and dynamic extraction of partial app ui models.
theseapproaches do not generate a test case from an existing ui test but replay on a target device a specific scenario that was recorded on a source device.
cross platform test migration is different from them in at least three important ways.
actualtest cases must be human readable and modifiable.
migrated test cases include oracle events which may in fact benefitrecord and replay but are not considered by it.
migratedtest cases are not device coordinate dependent and can be directly reused across devices on the same platform.
there is an emerging body of work that extracts ui models from android apps and uses them to guide testing.
this may be done statically dynamically or by a combined strategy .
our approach is platform independent and is in principle closer to dynamic approaches that do not assume the existence of app code.
vi.
l imita tions and discussion mapit s approach and current implementation have several potential limitations.
we discuss them in this section.
one limitation is presented by sibling apps whose events are not related to .
supporting to n event mappings isespecially challenging in bi directional test transfer across mobile platforms.
this is because of an important difference between android and ios.
in android many reverse engineering tools are available that can help to extract a complete model of a closed source app e.g.
gator .
on the other hand no analogous mechanism exists for ios which makes it challenging to predict possible future events in each state of a closed source ios apps.
even though both our evaluation and prior work indicate that sibling apps whose events have the to n relationships occur relatively infrequently finding ways to address this issue would further improve mapit s utility.mapit currently only supports clicks and keyboard inputs as ui events.
these two ui events are the most common types of events.
they are also more challenging to map than other ui events since they are associated with ui widgets.
mapit sunderlying modular design makes it easily extensible to support additional types of ui events such as swiping and scrolling.one strategy for so would be by introducing event specific heuristics.
we will have to implement and evaluate the effectiveness of such an approach.
another limitation of mapit is its inability to extract data e.g.
the uitm discussed in section iii a from certain commercial apps.
our analysis of this problem identified four potential reasons some apps may use obfuscation and makecertain ui elements inaccessible hybrid apps that combine web and native code may not be analyzable by tools such as appium certain ui states may not allow data extraction for security reasons e.g.
no screenshots may be taken on the login screen and the execution of some tests requires currently unrecognized types of action e.g.
scrolling .
some of these e.g.
adding support for scrolling are straightforwardextensions to mapit but others e.g.
overcoming obfuscation present compelling research challenges.
finally as discussed in section iii a mapit currently relies on regular expression matching for translating tests tomapit s internal representation.
we have considered using methods based on program analysis e.g.
ast parsing for the translation.
however we decided to use regular expressions because they are fast and accurate and most testing frameworks have apis that generate tests in a specific format.
the requirement that original tests be in a specific format can limit the number of input tests mapit can handle.
as a potential remedy mapit s modular architecture makes it possible to substitute the current internal test generator component with a more complex translator.
vii.
c onclusion our work has demonstrated that it is viable to flexibly transfer both individual app events and entire ui tests across mobile platforms.
this will serve as a foundation for a range offollow on activities in this area.
several of those will naturally focus on improving mapit s accuracy and usefulness and onaddressing its current shortcomings.
this may involve relaxing some of our assumptions such as taking advantage of code when it is available.
it may also involve leveraging mapit s modular architecture to introduce platform or technology specific components when appropriate as discussed above.
future work will also require overcoming specific challenges enumerated in section vi that have not been our focus to date for practical reasons.
viii.
a cknowledgments this work is supported in part by the u.s. national science foundation under grants and the computing research association for the cifellows project and the u.s. office of naval research under grant n0001417 .
766references w. wang d. li w. yang y .
cao z. zhang y .
deng and t. xie an empirical study of android test generation tools in industrial cases in 33rd ieee acm international conference on automated software engineering ase .
ieee pp.
.
d. amalfitano a. r. fasolino p .
tramontana b. d. ta and a. m. memon mobiguitar automated model based testing of mobile apps ieee software vol.
no.
pp.
.
y .
zhao j. chen a. sejfia m. schmitt laser j. zhang f. sarro m. harman and n. medvidovic fruiter a framework for evaluating ui test reuse in proceedings of the 28th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering pp.
.
m. linares v asquez c. bernal c ardenas k. moran and d. poshyvanyk how do developers test android applications?
in ieee international conference on software maintenance and evolution icsme .
ieee pp.
.
f. behrang and a. orso test migration for efficient large scaleassessment of mobile app coding assignments in proceedings of the 27th acm sigsoft international symposium on software testing and analysis pp.
.
test migration between mobile apps with similar functionality in 34th ieee acm international conference on automated software engineering ase .
ieee pp.
.
g. hu l. zhu and j. yang appflow using machine learning tosynthesize robust reusable ui tests in proceedings of the 26th acm joint meeting on european software engineering conference and symposium on the foundations of software engineering.
acm pp.
.
j. w. lin r. jabbarvand and s. malek test transfer across mobile apps through semantic mapping in 34th ieee acm international conference on automated software engineering ase .
ieee pp.
.
a. rau j. hotzkow and a. zeller transferring tests across web applications in international conference on web engineering.
springer pp.
.
l. mariani m. pezz e v .
terragni and d. zuddas an evolutionary approach to adapt tests across mobile apps arxiv preprint arxiv .
.
x. qin h. zhong and x. wang testmig migrating gui test cases fromios to android in proceedings of the 28th acm sigsoft international symposium on software testing and analysis pp.
.
soot .
.
available s. yang h. zhang h. wu y .
wang d. yan and a. rountev static window transition graphs for android in ieee acm international conference on automated software engineering pp.
.
s. y u c. fang y .
y un and y .
feng layout and image recognitiondriving cross platform automated mobile testing in ieee acm 43rd international conference on software engineering icse .
ieee pp.
.
.
available appium .
.
available robot framework .
.
available org android debug bridge .
.
available android.com studio command line adb web driver agent .
.
available facebookarchive webdriveragent page source .
.
available chrome.
.69i59j0i22i30.1929j0j7 sourceid chrome ie utf tesseract .
.
available tesseract euclidean distance .
.
available oxfordreference.com view .
oi authority.
e. rublee v .
rabaud k. konolige and g. bradski orb an efficient alternative to sift or surf in international conference on computer vision pp.
.
o. chum j. philbin a. zisserman et al.
near duplicate image detection min hash and tf idf weighting.
in bmvc vol.
pp.
.
e. rublee v .
rabaud k. konolige and g. bradski orb an efficient alternative to sift or surf in international conference on computer vision.
ieee pp.
.
hamming distance .
.
available oxfordreference.com view .
oi authority.
d. g. lowe distinctive image features from scale invariant keypoints international journal of computer vision vol.
no.
pp.
.
nltk stop words .
.
available ch02.html t. mikolov i. sutskever k. chen g. corrado and j. dean distributed representations of words and phrases and their compositionality arxiv preprint arxiv .
.
a. aizawa an information theoretic perspective of tf idf measures information processing management vol.
no.
pp.
.
cosine similarity .
.
available div898 software dataplot refman2 auxillar cosdist.htm xpath .
.
available docs web xpath l. mariani a. mohebbi m. pezz e and v .
terragni semantic matching of gui events for test reuse are we there yet?
in proceedings of the 30th acm sigsoft international symposium on software testing and analysis pp.
.
a. rau j. hotzkow and a. zeller poster efficient gui test generation bylearning from tests of other apps in ieee acm 40th international conference on software engineering companion icse companion .
ieee pp.
.
t. yeh t. h. chang and r. c. miller sikuli using gui screenshotsfor search and automation in proceedings of the 22nd annual acm symposium on user interface software and technology pp.
.
l. mariani m. pezz e and d. zuddas augusto exploiting popular functionalities for the generation of semantic gui tests with oracles inproceedings of the 40th international conference on software engineering pp.
.
n. luki c s. talebipour and n. medvidovi c airmochi a tool for remotely controlling ios devices in 35th ieee acm international conference on automated software engineering ase .
ieee pp.
.
remote control of ios devices via accessibility features in proceedings of the acm workshop on forming an ecosystem around software transformation pp.
.
a. rountev and d. yan static reference analysis for gui objects in android software in proceedings of annual ieee acm international symposium on code generation and optimization pp.
.
d. amalfitano a. r. fasolino p .
tramontana s. de carmine and a. m.memon using gui ripping for automated testing of android applications in2012 proceedings of the 27th ieee acm international conference on automated software engineering.
ieee pp.
.
m. linares v asquez m. white c. bernal c ardenas k. moran and d. poshyvanyk mining android app usages for generating actionable gui based execution scenarios in ieee acm 12th working conference on mining software repositories.
ieee pp.
.
t. su g. meng y .
chen k. wu w. yang y .
yao g. pu y .
liu and z. su guided stochastic model based gui testing of android apps in proceedings of the 11th joint meeting on foundations of software engineering pp.
.