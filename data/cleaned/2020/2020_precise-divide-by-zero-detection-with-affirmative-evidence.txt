precise divide by zero detection with affirmative evidence yiyuan guo the hong kong university of science and technology hong kong china yguoaz cse.ust.hkjinguo zhou ant group china jinguo.zjg antgroup.compeisen yao the hong kong university of science and technology hong kong china pyao cse.ust.hk qingkai shi ant group china qingkai.sqk antgroup.comcharles zhang the hong kong university of science and technology hong kong china charlesz cse.ust.hk abstract the static detection of divide by zero a common programming error isparticularlypronetofalsepositivesbecauseconventional static analysis reports a divide by zero bug whenever it cannot provethesafetyproperty thedivisorvariableisnotzeroinallexecutions.
when reasoning the program semantics over a large numberofunder constrainedvariables conventionalstaticanalyses significantly loose the bounds of divisor variables which easily fails the safety proof and leads to a massive number of false pos itives.
wepropose a static analysisto detect divide by zero bugstaking additional evidence for under constrained variables intoconsideration.
based on an extensive empirical study of known divide by zero bugs we no longer arbitrarily report a bug once the safety verification fails.
instead we actively look for affirmative evidences namely source evidence and bound evidence that imply a high possibility of the bug to be triggerable at runtime.
when applyingourtoolwittothereal worldsoftwaresuchasthelinux kernel we have found new divide by zero bugs with a low false positive rate of .
ccs concepts software and its engineering software verification and validation.
keywords static program analysis bug detection divide by zero.
acm reference format yiyuan guo jinguo zhou peisen yao qingkai shi and charles zhang.
.
precise divide by zero detection with affirmative evidence .
in 44thinternationalconferenceonsoftwareengineering icse may21 pittsburgh pa usa.
acm new york ny usa 12pages.https permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa association for computing machinery.
acm isbn ... .
introduction divide by zeroisoneofthemostcommonprogrammingerrorsthat can lead to undefined runtime behaviors.
over the past five years there are more than security vulnerabilities related to divide byzero documented in the common vulnerabilities and exposures cve database.
static analysis is an important approach to combat this problem.
however its high false positive rate remains a major obstacleforadoption.inourexperiments weobservefalsepositive rates of over in representative static analyzers.
to understand the reason behind these high false positive rates we first examine how static analysis reports a potential divideby zero bug.
the central question is how to decide if the divisor variable may equal zero in some executions.
more specifically a divide by zero happens when c1.thereexistsafeasibleexecutionpath preachingthedivision instruction let pcdenote the path condition for p .
c2.the divisor variable vmay equal zero when preaches the division instruction let qdef v denote the error condition for triggering a divide by zero bug .
conventionally staticanalysisreportsadivide by zerobugif pc q is satisfiable i.e.
under the condition pc the divisor variable vcannotbeprovedtobenon zero.however weobservethatthisscheme often leads to a high false positive rate in divide by zero detection since the under constrainedness of static analysis makes it easy to satisfy the query pc q. many variables are under constrained in the static analysis the program under analysis can be an open program.
for example the analysis often sees a module by interface only of which the variables are under constrained .
the inherent limitations of static analysis introduce the under constrained variables to represent imprecision in the analysis e.g.
the runtime state of the operating system and thepresenceofunmodeledcodeconstructs suchasinline assembly and many others .
to improve the precision our key insight is that instead of reportingerrorswheneversafetyverificationfails wecanattack the divide by zero detection problem from a different angle by activelyfindingaffirmativeevidencefortriggeringthebug.such evidence serves as the extra information on the under constrained variables thus contributes to improving the precision.
ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yiyuan guo jinguo zhou peisen yao qingkai shi and charles zhang 1structcontrol panel 2intx inty intz 3intflag intdistantce ... 6voidtop fun not tracked by the analysis when analyzing move ... 8if d x!
d y!
calls move with non zero values of dx and dy.
move dx dy d ctr 13voidmove int dx intdy intd control panel ctr 14intdiff 15if dx dy diff dx dy 17else diff 20ctr z get step ctr diff 21if d x d d y d ctr setflag long move 24intdz dx dy d 25ctr x get step ctr dx 26ctr y get step ctr dy 27ctr z get step ctr dz 30intget step control pane ctr intstep size 31returnctr distantce step size figure a motivating example.
we use the motivating example in figure 1to illustrate the idea.
in figure the function moveupdates the control panel ctrby adding values to its x y z coordinates computed in the function get step throughadivisionoperation.also weassumethatthe caller function top fun for the function moveis external to the module under analysis and thus not tracked by the analysis.
now consider how static analysis can detect potential divide by zero errors in this program.
line cannot trigger a divide by zero because the used divisor diffis either or no less than .
a path sensitive static analysis correctlyverifiesitssafetysincethetwoqueries dx dy dx dy anddx dy associated with thetwo paths across lines are both unsatisfiable.
however thepath sensitivestaticanalysisstillencountersthe precision problem.
in our example the divide by zero errors are reported for the three calls to get step at line and because the queries dx dy anddz are all satisfiable.
however since top funonlycalls movewithnon zerovaluesfor dx anddy line the reports at lines are false positives.
this fact is unknown to the static analysis because it fails to trace back to the origin of the arguments of movein the function top fun.
ontheotherhand wenoticethatthedivide by zeroreportat line 27hashigh confidenceto betrue sincewe canfind evidence to explain it.
specifically line of figure 1explicitly compares dxanddywith d suggesting that the programmer has beliefs thattheymaybeequalto d.ifsuchbeliefsactuallyhold dzmust equal zero at line i.e.
dz dx dy d d d d leading to a plausible divide by zero report for line .how to report the high confidence divide by zero bug at line instead of the false positives at lines ?
note that all of the three divisions cannot be proved safe by the static analysis regardless of being path sensitive or not.
h owever we have identified theevidence basedon analyzing theprogrammer s beliefsforthe bugreportatline27 whichleadstoitshighconfidencetooccur.
specifically in this work we identify two categories of evidence a source evidence the fact that an explicit source of bad valueisassignedtoavariable v.thesourcecanbeeithera directassignmentofzero e.g.
theassignment v ortakes the value of some tainted input e.g.
v atoi argv .
b bound evidence theequalityfact v1 v2generatedfrom aboundcheckingstatementintheprogramthatcompares v1andv2.
statements like line of figure 1that check numerical bounds of variables can convey the important informationonthepossiblevaluesofthecheckedvariables acomparisonbetween v1andv2suggeststhattheprogrammer may believe that v1can equalv2.
with the generated evidence our method reports a divide by zero bug by adapting the requirements c1 and c2 as follows.
c1 .c1andc2hold pc qissatisfiable where pcdenotesthe path condition for reaching the division instruction and q v is the error condition for divide by zero.
c2 .
one of the following conditions holds the divisor variable vhas the source evidence.
there exists a set eof bound evidence consistent with pc such thatvmustbe zero under e. in other words we seek to detect a fraction of divide by zero bugs withhighconfidencebyfindingtheaffirmativeevidencetoexplain its occurrence.
for example in figure dzat line is the only variable that meets these requirements dz 0musthold if the evidencedx danddy dhold.
hence our approach will only report one divide by zero bug at line .
inthispaper weproposewit aframeworkfortheprecisedetection of divide by zero with the affirmative evidence.
first to understandtheapplicabilityofourdefinitionofevidenceandthecri teriac1 c2 fordetectingbugs weperformanempiricalstudyonexistingcvesrelatedtodivide by zerobugsandinvestigateifthey can be detected by finding a set of supporting evidence.
the result showsthat74 ofthestudieddivide by zerobugshavethesupport ingevidencethatexplainsitsoccurrence showingthegeneralityofourintuition.tocapturetheevidence basedreasoninginachieving the precise divide by zero detection we design a static analysisalgorithm to perform the evidence based inference adhering tothe criteria c1 c2 for reporting bugs.
the algorithm generatesevidence directly from certain code patterns and propagates the generated evidence path sensitively.
to improve its efficiency we utilize a symbolic domain to compactly encode the possible numerical values for variables and apply the data dependence analysis to prune irrelevant execution paths scaling to million lines of code.
in summary we make the following contributions in this paper the insight for improving the precision of divide by zero detectionbyfindingtheaffirmativeevidencetotriggerthe bug.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
precise divide by zero detection with affirmative evidence icse may pittsburgh pa usa anempiricalstudyofcvesrelatedtodivide by zerobugs.
we investigate and classify these existing divide by zero bugsandshowthatmanyofthemcanbeeffectivelydetected based on evidence.
a formalization of the insight in a semantic framework and analgorithm forfindinghigh confidencedivide by zeroerrors through the evidence propagation.
animplementationand extensiveevaluationofthe divideby zero checker.
we demonstrate that it is both precise and efficient uncovering72divide by zerobugs 14ofwhichare confirmed by the developers in large codebases such as the linux kernel with a low false positive rate of .
empirical study on divide by zero bugs tofurtherunderstandtheapplicabilityoftheevidence baseddivideby zero detection method we perform an empirical study on cves caused by divide by zero bugs.
through the empirical study we aim to answer the following research questions rq1 how often can we find the evidence for the divide byzerobugs?inotherwords howoftendoourbugdetection criteria c1 c2 apply to the existing divide by zero bugs?
rq2 what is the distribution for the two kinds of evidence defined in ?
.
data collection wesearchforthekeywords divide by zero and dividebyzero in the cve database and examine the cves starting from the year .
there are cves in total that are caused by the divideby zero bugs.
we exclude the bugs with no source code or stack traces orunabletounderstandwithoutadeepknowledgeof the system or sharing the same root with other bugs .
thus we are left with cves to study.
.
classification criteria sinceourgoalistostudytheproblemingeneralwithoutbeingtied to a specific analysis algorithm or target system we have adopted the following criteria to mimic the reasoning process of a static analyzer starting from the crash site of the bug i.e.
the division instruction with zero divisor we manually examine a backward slice bof some fixed size.
in our experiment we examinebackwardsatmost10callframesfromtheinvolved division.
this isreasonable as lengthy bug traces outputby static analyzers take a non trivialamount of time for users to triage thus should be avoided by practical tools.
basedonourmanualinspectionof b weclassifythedivideby zero bugs based on the evidence found a classsrc source evidenceisfound.
anexplicitsource of zero value for the divisor variable exists in b. the source is either a direct assignment of zero value to the variableor of a tainted value from the input.
b class bd bound evidence is found.
we can find a set of evidence from the bound checking statements in btable classification of cves caused by divide by zero bugs.
class src is bugs with source evidence further classi fied into constant source and taint source class bd is bugs withboundevidence andclassunisbugswithnoevidence.
class srcclass bd class src class bd class unconsttaint that guarantee the divisor variable to be zero.
specifically foranybranchingstatementinvolvingcomparisons if x cmp y cmpis etc.
weconsiderthefact x y as the bound evidence likely to be true.
c class un no evidence is found i.e.
unknown .
we can neitherfindsourceevidencenorboundevidencein b.for example cve is marked as unknown because it requires a deep context of call frames to understand the root cause exceeding the code range of b. conventional static analysis methods detect all three classes ofdivide by zerobugs.asillustratedin theyarelikelytoincur massivefalsepositives.ourmethoddetectsbugsofclasssrcand class bd since they are the classes that satisfy the requirement c1 c2 aiming for a fraction of high confidence divide by zero bugs withpossiblefalsenegatives.theclassificationattemptstostudy how much can be covered by our method.
.
study result bug classification .
table1shows the classification result of the87cvescausedbydivide by zerobugs.forclasssrcbugswith explicit sources we further divide them into two groups those with constant zero value as the source the column labeled with const and those with the tainted input as the source the column labeled with taint .
the bugs with both the source evidence and the bound evidence are counted in the column labeled class src class bd .
from the data we gather we answer the two research questions empirically as follows answer to rq1 we can find evidence for a large proportion src bd src bd of divide by zero bugs.
thus our bug detection criteria c1 c2 are widely applicable.
answertorq2 forthedivide by zerobugsthatwecanfind evidence of them have source evidence of them have bound evidence and of them have both evidence.
therefore we conclude that finding evidence to facilitate the precise divide by zero detection indeed works in real scenarios coveringalargeproportionofinterestingbugs.also bothsource evidence and bound evidence are useful for bug detection in practice.
case study of bugs with evidence .
to give an intuitive understandingofthebugsdetectedbasedonevidence weillustrate some example cves from class src and bd.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yiyuan guo jinguo zhou peisen yao qingkai shi and charles zhang 1voidstart input gif j compress ptr cinfo cjpeg source ptr sinfo u char hdrbuf readok is a wrapper of fread 4if !readok source pub.input file hdrbuf erexit cinfo jerr gif not width lm to uint hdrbuf height lm to uint hdrbuf use the second arg as divisor divop cinfo width numcolors a example cve 1intapplyevaluateoperator randominfo r quantum p operator op intv ... 3switch op 4casedivideevaluateoperator result p v ?
v break 7casegaussiannoiseevaluateoperator result generatedifferentialnoise r p gaussiannoise v 11intgeneratedifferentialnoise randominfo r quantum p noisetype ty intv ... noise quantumrange i v b example cve figure example of bugs with evidence.
figure2ashowsaclasssrcbug.thebuffer hdrbufistaintedby the call to readok line allowing itto parse the variable width to zero value leading to a divide by zero bug at line .
figure2bshows a class bd bug.
at line of the code in figure2b the programmer explicitly checks the value of variable v against .
we can propagate the checked bound as evidence to line uncovering a divide by zero bug inside the called function generatedifferentialnoise at line .
this bug is due to the fact that the programmer has missed the check at line which is successfully captured by the generated bound evidence.
implicationsofourfindings .fromthefindingsofourempirical study we conclude that manyrealdivide by zerobugsdohavethesupportingevidence.inaddition boththesourceevidenceandthebound evidence are useful for understanding existing divide byzerobugs.thus criteriac1 c2 forthedivide by zerodetectionareapplicableforalargeproportionofdivide by zero bugs.
staticanalyzerscanbedesignedtodiscoverandreasonabout the evidence to achieve precise detection results aiming for the high confidence bugs of class src and class bd.
overview inthissection wegiveanoverviewofourevidence baseddivideby zerodetectionmethod usingthemotivatingexampleinfigure .
existingapproaches .beforepresentingourapproach wefirst briefly discuss two conventional techniques for divide by zero detectionandtheirdrawbacks namelythenumericalabstractinterpre tation andtheunder constrainedsymbolicexecution .if we apply the polyhedra abstract domain that is an expressive domain capable of reasoning about the linear relations among variables thebranchstatementsfromline15toline18infigure will produce the following abstractions along the two paths abs1 dx dy dx dy diff abs2 dx dy diff since the two abstractions are joined to produce a sound overapproximationwhenpathsmergeinabstractinterpretation asevere precision loss can occur.
specifically since abs1 unionsqabs2 diff the analysis concludes that diffmay be equal to zeroandgeneratesafalsepositivedivide by zerobugforthecall at line .
thus lacking path sensitivity the numerical abstract interpretation can be imprecise for divide by zero detection.
ontheotherhand theunder constrainedsymbolicexecution performs the path by path exhaustive exploration starting from thetestedfunction move recallweassumethattheanalysisdoes nottrackthefunction top fun .theanalysisrecordsthetwopaths inthefunction movereachingline20asthefollowingexecution states s1 dx dy diff dx dy s2 dx dy diff withthepath sensitivestateencoding theunder constrainedsymbolic execution successfully proves that divide by zero cannot happen for line .
however as illustrated in due to the presence of the under constrained variables we conclude that all three calls at lines of figure 1can trigger divide by zero with two false positives.
this is because all the execution paths reaching these lineshavesatisfiableconstraintsfortriggeringdivide by zero.thus withoutfindingtheaffirmativeevidence evenapath sensitivetechnique for divide by zero detection can be imprecise when faced with under constrained variables.
to summarize conventional approaches to divide by zero detection suffer from imprecision problems because they may lack path sensitivity or do not attempt to find evidence for potential bugs.
ourapproach .
as illustrated in our work uses the criteria c1 c2 to precisely report potential bugs.
we argue that bothpath sensitivity of the analysis and finding affirmative evidenceare crucial in achieving good precision.
thus we seek to track the evidence path sensitively to achieve the precise divide by zero detection.
for this purpose the analysis needs to reason about the numerical computations path sensitively and fuse the evidence inthe analysis process.
we propose to apply a dedicated symbolic domain to track the numerical computation in the analysis pathsensitively and utilize the evidence to refine the analysis result.specifically represents the abstract state for a variable vas a guarded symbolic value set v va1 c1 ... vak ck meaningthatv vaimayholdunder thecondition ci.notethat itis nontrivialtocompute efficiently andwedeferthedetailsofthe algorithm to .
for the example in figure our analysis deduces that dx dy dx dy dx dy diff dx dy d true dz authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
precise divide by zero detection with affirmative evidence icse may pittsburgh pa usa theanalysissuccessfullyinfersthatnodivide by zerocanoccurfor line based on the path sensitive representation of diff .h o w ever itstillreportstwospuriousdivide by zerobugsforlines25 similartotheunder constrainedsymbolicexecutionapproach as the variables dx dy and dare under constrained in .
thus to further improve the pr ecision our analysis attempts to deduce the evidence for those under constrained variables.
first it attempts to find the source evidence fordx dy and dby asking are these variables tainted?
.
the tracking of the source evidence can be done by the taint analysis following the value that originatesfromabadsourceandcheckingwhereitflowsto.inthis example no such source evidence exists.
on the other hand the analysis tries to find the bound evidence to constrain the underconstrained variables.
as introduced in we generate the bound evidencev1 v2fromtheboundcheckingstatementsthatcompare v1withv2 whichrepresentthepossiblebeliefstheprogrammers may have.
for example in figure lines compares dxwith dy while line compares dxwith danddywith d causing the analysis to generate the following bound evidence dx dy dx d dy d how can we take advantage of the generated bound evidence toimprove the precision of divide by zero detection?
we treat thebound evidence as the additional constraints and propagate it to update the representation of such that the additional constraints areenforced.forthevariable dz fromtheboundevidenceabove andtheguardedvalue dx dy d true fordz wededuce that a b c true dz a b c dx dy d apparently dz and thus our analysis successfully reports line of figure 1as a divide by zero bug.
meanwhile since no evidence is inferred for dxordyto be zero i.e.
dx dy it avoids generating spurious reports at lines .
in summary our analysis encodes the possible values for the variables in the program path sensitively using a symbolic domain.
duringthenumerical inferenceprocess itattemptsto directly find the source evidence and propagate the generated bound evidencetorefinetheanalysisresult.sinceweapplystandardmethodsintrackingthesourceevidence wemainlyfocusonutilizing theboundevidenceinourmethod.therearetwomajorchallenges how to efficiently compute the guarded symbolic value set v forvariable v?anaiveapproachthatexhaustivelyenumerates all execution paths can be too expensive wasting time exploring irrelevant paths.
how to propagate bound evidence to refine the symbolic analysis result?
to address the first challenge we utilize the data dependence analysis to slice away the irrelevant control flow paths for improving theefficiency.
forthe secondchallenge weencode thebound evidence as the additional constraints for and enforce these constraints when computing the guarded symbolic value sets.program p fun function fun fun v1 ... v n r s statement s s1 s2 v e if v1cmpv2 s2elses3 cmp v g a1 ... a n v v1 ... v n expression e v c tainted e1ope2 op figure a simple programming language.
step size dz t1 t2dy dx 13diff t32 dx t1dy d t2 t3 dx dy1dx dy dx dy figure augmented data dependence graph for figure .
methodology .
preliminary definitions we formulate our analysis using a simple imperative programming language defined in figure .
the language is assumed in the static singleassignmentform inwhicheachvariablehasaunique definition andwedenotethessaphifunctionby .weusev lto denoteavariable vdefinedattheprogramlocation l.thelanguage hasstandardsemantics andweomitaformaldefinitionforbrevity.
as mentioned in we utilize data dependence analysis to compute efficiently.
specifically the analysis operates over a sparse representation of the program called the augmented data dependence graph defined as follows definition .
.
anaugmenteddatadependencegraph gisadirected graph g v e l v le where v vc vn vo vtisthesetofnodes.
vcareconstantvalues vnare variable definitions and voare nodes corresponding toanarithmeticoperation v1opv2 wherev1 v2 v vo.vt is the set of tainted input sources.
e v vis the set of edges representing data dependence relationssuchthat e v1 v2 ewhenv1isusedtodefine v2.lelabels any e ewith a condition condunder which the value flow can happen.
lvlabelseachnode n vnwith v l cond .condistheconditionforv sdefinition i.e.
forsomeexecutiontoreachline l .lvalso labelsnodes in vowith itsarithmetic expression v1opv2and nodes in vcwith its constant c. example .
.
figure4shows the augmented data dependence graphfortheprograminfigure .anarrow v1 v2indicatesthat v1isusedtodefine v2 i.e.
v1 v2 e andeacharrowislabeled with a path condition under which the flow of value can happen omitted in figure 4if it istrue .
notice that arithmetic operations arealsocompactlyencodedonthegraphbyintroducingtemporary variablest1 t2 andt3torepresentintermediatecomputationresults.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yiyuan guo jinguo zhou peisen yao qingkai shi and charles zhang thesparsegraphrepresentationisusedtotrackrelevantdata and control dependencies of the concerned variable while skipping irrelevantstatements .ithasbeenpreviouslyshowneffective indetectingnullpointerdereference useafterfree and memory leak .
we take inspiration from these works to first utilize data dependence analysis in finding divide by zero bugs.
as illustrated in to achieve precise divide by zero detection ouranalysisneedstotracknumericalcomputationspath sensitively andutilizeaffirmativeevidencetofindhighconfidencebugs.for trackingnumericalcomputations weapplyasymbolicdomain formally defined as follows definition .
.
the guarded symbolic value set domain is a mapping v p val cond where valdef c v c z v v va1opva2 va1 va2 val conddef the set of path conditions we use vto denote an unknown symbolic value for a node v. encodesthesymbolicvaluesforvariablespath sensitively.it maps a node v gto guarded value pairs of the form va c whereva valis a symbolic expression and cis the condition under which vmay have the value va. the symbolic expression invalis either a basic term i.e.
constant or unknown symbolic value or a binary operation involving other symbolic expressions.
at a high level our analysis first constructs the augmented data dependence graph gutilizing the existing method .
we then compute the guarded symbolic value set v for a divisor variable von demand.finally weusetheresult v indetectingdivide byzerobugs.specifically wecompute v bybuildingandresolvinga systemofconstraintsfor .toimprovetheprecision ouranalysisis path sensitiveandevidenceaware encodingboundevidenceasadditionalconstraints.toremainefficient weutilizedatadependence relations in constructing and resolving constraints.
.
evidence based symbolic analysis givenaprogram pandavariable v ourevidence basedsymbolic analysis shown in algorithm 1computes the guarded symbolic value set for v. we build the augmented data dependence graph gforpusing standard methods line generate a system of constraints cons on demand line and solve the constraints to obtain the guarded symbolic value set for v lines .
.
.1demonstratestheprocessofon demandconstraintsgeneration for a node n g which is the node corresponding to a given variablev.
we also generate bound evidence to produce additional constraints further refining the result and improving the precision.
.
.2discusses the procedure solvefor resolving constraints andobtainingthesolution whichmapsfromvariablestotheir guarded symbolic value sets.
.
.
symbolic constraints generation.
our analysis generates constraints for from the program s augmented data dependence graphg.
before presenting the rules for constraint generation we first define some operators for cf.
definition .
definition .
.
operators and helper functions definitions for algorithm demand driven evidence based symbolic analysis.
input a program pand a cared variable v. output the guarded symbolic value set for v. 1defsymbolicanalysis p v 2g v e buildgraph p 3n node ingcorresponding to v 4cons genconstraints g n solve cons 6return n 7defgenconstraints g n 8cons 9seq vi backward dfs order of gstarting from n 10foreachv reverse seq do apply the rules in figure 5and add the generated constraints to cons 12end 13returncons 14defsolve cons v. 16while has changed do foreach c o s cons do s prime o dotacc eval s end 21end 22return the binary operator tildewideroponp val cond is defined as gv1 tildewideropgv2 simplify va1opva2 c1 c2 va1 c1 gv1 va2 c2 gv2 thelogicalandoperation isextendedtoaddanadditional conditiontoaguardedvalueset s p val cond cond s va c cond va c s .
dotacc unionstwoguardedvaluesets s1 s2 p val cond and combinesguardingconditionsforthesamevalue s1 dotacc s2 va c1 c2 va c1 s1 va c2 s2 s1 s2 s2 s1 .
figure5liststheinferencerulesforgeneratingconstraintsfor based on g.w eu s es1 s2to denote a weak update to the guarded value set s1 i.e.
s1 s1 dotacc s2 andcond to denote data dependenceedges c.f.definition .
.thefirstfiverulesinfigure translate the data dependence relations in gto constraints for .
ruleinit varand rule init opindicate that every node n vn vo is associated with an unknown symbolic value n meaning that the valuefornisinitiallyunknown.ontheotherhand constantnodes have fixed values rule init cst .
for node encoding operations the operator tildewideropis applied to the guarded symbolic value sets for the incomingnodes rule operation .foravariablenode n vn w e aggregatetheguardedsymbolicvaluesetsforallthenodesthat nis datadependenton andtracktheappropriatepathconditions rule 1for brevity the rule only lists the case when both operand nodes are from vn.
other cases can be transformed to it by introducing temporary variables.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
precise divide by zero detection with affirmative evidence icse may pittsburgh pa usa init varn vn lv n v cond n n cond init opn vo n n true init cstn vc lv n cst n cst true operationn vo lv n v1opv2 op1 n lv op1 v1 c1 op2 n lv op2 v2 c2 n op1 tildewiderop op2 variableop1cond1 n ... op kcond k n n vn lv n v l cond vas trans n cond vas bound eviv1cmpv2occurs in the program vi v1 dotacc v2 i figure rules for generating constraints from g.s1 s2 abbreviates s1 s1 dotacc s2 andicond jabbreviates e i j e le e cond.
variable .
thetransfunction is used for this reason and defined as trans def dotacc uniondisplay.1k i ci opi finally the condition associated with ninlv n is added to n .
example .
.
forgshown in figure we can apply the above inferencerulestobuildthefollowingconstraints theconstraints for temporary variables are left out for brevity step size diff dotacc dx dotacc dy dotacc dz diff trans dx dy tildewide dx tildewide dy dx dy dz tildewide dx tildewide dy tildewide d v v true v step size dx dz diff dy d sincewe buildthe constraintsfrom theaugmented datadependencegraphshowninfigure onlyrelevantpathconditionsareencodedintheconstraintrepresentation.forinstance nobranchconditioninfigure 1canaffectthevalueof dz i.e.
dz dx dy d holdsonalleightexecutionpaths.theaboveconstraint effectivelycapturesthisfact indicatingthat dz isdependenton dx dy and d without distinguishing among different execution paths which are irrelevant in this case.
generatingboundevidence .althoughwehaveshownhow to generate constraints for according to the data dependence relationson g thepresenceof under constrainedvariables inthe analysis can still lead to imprecision as illustrated in .
the key challenge is to infer additional information for these underconstrained variables when solely relying on the data dependence relations gives imprecise results.as motivated in a bound checking statement if v1cmp v2 reveals programmer sbeliefs about the valuesof the checkedvariables acomparison between v1andv2suggests thatthe programmermaybelievethat v1 v2 whichwecalla boundevidence.bound evidence can aid in providing additional information for the under constrained variables e.g.
it is used to infer dz as discussed in .
therefore we propose to generate additional constraints on forboundevidence.specifically rule bound evi offigure 5will unifytheguardedsymbolicvaluesetsforthecomparedvariables v1andv2to v1 dotacc v2 .theseadditionalevidenceconstraints together with the data dependence constraints generated before willberesolvedlatertopropagateevidenceaccordingtothedata dependence relations.
example .
.
in our motivating example of figure the two bound checking statements at line and line will cause the analysis to generate bound evidence.
applying rule bound evi w e obtain the additional constraints dx dy dx dotacc dy dx d dx dotacc d dy d dy dotacc d weknowfromtheaboveconstraintsthatthesymbolicvaluesfor dx dy anddare unified.
as we will see later this information refines theconstraintsgeneratedinexample .2andhelpsustoinferthe evidence for dzto be zero.
on demandconstraintsgeneration .inalgorithm theproceduregenconstraints generatesasystemofconstraints cons on demand from gand a given node n. specifically we perform a backwarddepth firsttraversalon gstartingfrom n line9 .this effectivelycomputesasliceof gaffectingthevalueof n.following the reverse node order of this dfs traversal we collect constraints using the rules in figure lines and finally return these constraints at line .
the order ensures that the rules for v1come beforev2ifv1is used to define v2 s value thus speeding up the convergence ofthe solving processintroduced later similarto data flow analysis .
.
.
constraint resolution.
given a set of constraints cons the procedure solvein algorithm 1computes its solution which is a mapping from nodes to guarded symbolic value sets.
at a high level starts with an initial state mapping any node to the empty set line and is iteratively updated according to the constraints cons .noticethateachconstraintin cons isbuilt fromtherulesinfigure 5and thus hasthesyntacticform o s. for updating o we calculate the result of the set operation encoded by s denoted by eval s at line .
the calculation result is combined with the old value o using the dotacc operator c.f.
definition .
to produce the updated value set s primeforo lines since represents a weak update.
the algorithm finishes when no constraint causes an update to anymore lines .
example .
.
for the constraints shown in example .
lines of the solveprocedure compute the guarded symbolic authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yiyuan guo jinguo zhou peisen yao qingkai shi and charles zhang value set for dzas follows dz dz true dotacc true tildewide dx true tildewide dy true tildewide d true dx dy d true dz true constraints from example .3further refines the result to dz a b c true dz true a b c dx dy d since true dz wehavefoundtheevidenceforthevariable dzto trigger divide by zero.
theaboveexampleshowstheadvantageofgeneratingandresolving constraints from gaccording to the data dependence relations.ourconstraintsarecompact i.e.
resolvingtheconstraints does not require reasoning about the irrelevant control flow paths.
in contrast an exhaustive approach such as symbolic execution needstoenumeratealleightpathsinthefunction moveoffigure just to figure out the guarded symbolic value set for dz path dz c1 dx dy dx d dy d2 dx dy d c8 dx dy dx d dy d2 dx dy d theconstraintsbuiltbytheexhaustivepathenumerationwould have been overly redundant dz trans tildewide dx tildewide dy tildewide d c1 dz trans tildewide dx tildewide dy tildewide d c8 sincec1 c8 true theaboveconstraintsareequivalentto our generated constraint in example .
.
onenoteworthypointaboutthe solveprocedureisthatitcanproduce a value set s primewith a large size.
to keep the analysis tractable we join the additional values for variable vto its sound abstraction vwhen the size of v has reached a predefined threshold.
in this work we choose the threshold to be by experience.
.
divide by zero bug detection our system wit for precise divide by zero detection is shown inalgorithm .specifically givenaprogram p adivisorvariable v and the location lof the division instruction algorithm 2returnswhethera divide by zerobugmayhappen at l.wefirstcall symbolicanalysis ofalgorithm 1usingpandvasargumentstoobtain the guarded symbolic value set sforv line .
divide by zero detectionisachievedbyenumeratingeachguardedvalue va cond insto check for the bug condition.
to report a divide by zero bug we adhere to the criteria c1 c2 mentioned in .
first according to c1 the conjunction of the path condition and the error condition should be satisfiable.
in algorithm the path condition is denoted by pc consisting of the condition cfor reaching the division instruction and the guarding condition condfor the checked value va line .
the error condition is simply va .
therefore line checks the satisfiability of pc va for determining c1 .
second according toc2 theconcernedsymbolicvalue vashouldhavetheaffirmative evidence to be zero algorithm divide by zero bug detection by wit.
input a program p. input a divisor variable vand the location lfor the division instruction.
output whether divide by zero may happen at l 1defdecidebug p v l 2s symbolicanalysis p v 3c path condition for reaching l 4foreach va cond sdo 5pc c cond ifsat pc va then iftainted va then returntrue else ifunsat pc va then returntrue 11end 12returnfalse taint eviv vt vcond v prime sat cond tainted v prime true figure criteria for propagating the tainted flag.
source evidence ifvacomesfromthetaintedinput wecan reportadivide by zerobug lines7 .fortaintdetection we can apply any existing taint analysis to compute the tainted nodes on g. specifically we use rule taint evi in figure6 a node is tainted if it is data dependent on the taintedinputandtheconditionofthevalueflowissatisfiable.
bound evidence otherwise wereportadivide by zerobug ifvamust be zero under the condition pc lines .
this can happen for two reasons either the symbolic value va is literally constant zero or it is forced to be zero by thecondition pc e.g.
when pc va .
recall that theboundevidenceisencodedasadditionalconstraintsin cons duringtheanalysisandcanimplicitlyenforce vato be zero it is thus more likely to satisfy the must query.
fortheprograminfigure algorithm 1deducesthat true dz asillustratedbyexample .
.thus lines9 10ofalgorithm report a divide by zero bug for the variable dz.
evaluation weimplementwitbasedonllvm .similartopreviousworks onstatic bugdetection we unrolleachloop oncein controlflowgraphsandcallgraphs.ourexperimentalevaluation is designed to answer the following research questions rq3 the effectiveness of wit.
particularly rq3.
how does our intuition of evidence based reasoning affect the analysis precision?
rq3.
compared to the conventional evidence agnostic method how many bugs are missed by wit?
what are the reasons for missing them?
rq3.
can wit detect real world divide by zero bugs?
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
precise divide by zero detection with affirmative evidence icse may pittsburgh pa usa table selected projects for evaluation.
project loc div kloc masscan 34k .
goaccess 53k .
libuv 59k .8redis 131k .0git 226k .
vim 354k .
imagemagick 382k .6openssl 465k .1systemd 600k .0php 012k .
gdb 932k .
linux kernel 164k .
rq4 howdoeswitperformcomparedwithexistingdivideby zero detectors?
.
experimental setup subjects.
we have selected open source c c projects to performtheevaluation shownintable .ourselectioncriteriaare as follows popularity theselectedprojectsarepopular e.g.
haveat least 10k stars on github and actively maintained.
generality the projects cover different sizes ranging from tens of thousands to tens of millions of lines of code and functionalities including operating system image processing database system network library etc.
intensiveuseofdivisioninstruction theprojectsperform division operation intensively e.g.
they contain .
division instructions every 1k lines of code on average.
environment .
the experiments were performed on a computerwithtwo20coreprocessorsintel r xeon r cpue5 v4 .20ghz and 256gb physical memory running ubuntu .
.
open data .
the results of our empirical study and confirmed bugs detected by wit are available at the link yiyuaner icse wit data.
.
effectiveness of divide by zero detection to study the effectiveness of the evidence based symbolic analysis algorithm we compare wit with its variant wit .wit is the evidenceagnosticpath sensitivemethod.in wit weremoverule bound evi fromfigure 5andreportanerrorwheneverthecondition issatisfiable i.e.
wheneverthecheckatline6ofalgorithm 2passes.
all other aspects of wit are the same as wit.
table3showstheexperimentresult.wecomparethetotalnumber of bug reports the false positive rate and the analysis time for wit and wit .
for each variant on a specific project we examine its list of output reports and stop if the number of false positiveshas exceeded when this happens we use na to denote its false positive rate .
wit effectively reports divide by zero bugs of them are true positives among real world applications table divide by zero detection on real world projects.
wit represents a variant of wit unaware of evidence.
project of reports fp rate analysis time wit wit wit wit wit wit masscan 4m24s 6mgoaccess 1m38s 1m33slibuv 1m32s 1m29sredis 23m12s 23m9sgit 38m3s 34m34s vim 109m55s 109m12s imagemagick 196m39s 189m10sopenssl 31m55s 31m48ssystemd 202m8s 183m21sphp 104m38s 94m21s gdb 248m28s 299m1s linux kernel na 425m35s 452m12s table distribution of true positives reported by wit the column total into class src and class bd.
the column missed shows the number of true positives reported by wit but missed by wit.
project total src bd missed masscan 0goaccess 1libuv 0redis 0git vim imagemagick 1openssl 0systemd 0php gdb linux kernel na table divide by zero bugs confirmed by developers.
gitlinux gdbimagemagickgoaccess libuv openssl vim systemd withalowaveragefalsepositiverateof22 .incontrast wit has an average false positive rate of .
answer to rq3.
the precision of wit greatly outperforms its no evidence counterpart proving the significance of affirmative evidence for precise divide by zero detection.
table4shows the distribution of true positives reported by wit and thenumber oftrue positives detectedby wit but missedby wit.fromthetable weconcludethatbothsourceandboundevidenceareusefulinpreciselydetectingdivide by zerobugs.besides wit misses of the true positives detected by wit on average authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa yiyuan guo jinguo zhou peisen yao qingkai shi and charles zhang 1intblk mq map queues blk mq queue map qmap 2unsigned map qmap mq map 3unsigned nr queues qmap nr queues 4unsigned cpu first sibling 5unsigned q 6for each possible cpu cpu 7if q nr queues map queue index qmap nr queues q else if first sibling cpu map queue index qmap nr queues q ... 16intqueue index blk mq queue map qmap unsigned nr queues const int q 19returnqmap queue offset q nr queues figure a confirmed divide by zero bug in linux kernel.
which isrelatively low consideringits drastic precisionimprovement.
most of the missed bugs are due to the incomplete modeling ofthetaintsources i.e.
theanalysisfailstoidentifycertainapis as the taint sources thus missing the source evidence and fails toreportcertain bugs.witcurrentlymodelssome commontaint sourcesfromthestandardclibrarybuteachtargetprogrammay contain its specific taint sources that we do not know beforehand.
answertorq3.
witonlymissesasmallproportionofbugs compared with its no evidence counterpart wit mainly due to its incomplete modeling of the taint sources.
we report the detected true positives and bugs have been confirmedbythedevelopers asshownintable .figure7showsa realdivide by zerobugwitdiscoveredfromthelinuxkernel.the function queue index uses nr queues asadivisor whichcomes from the unknown input argument qmap nr queues .
since the analysisgeneratesaboundevidence q nr queues fromline7of figure7and qis assigned zero value in line it deduces that nr queues may be zero and reports a divide by zero bug.
answer to rq3.
wit is capable of detecting real divide byzerobugs ithasfound72divide by zerobugs 14ofwhich have been confirmed by the developers.
.
comparison with existing detectors we compare wit with three competing tools namely crab infer and clang static analyzer csa .
crab adopts numerical abstract interpretation infer takes the bi abduction theorem proving technique and csa performs local symbolic execution.
comparingwith crab .
we instrument the program by assertingthedivisorvariabletobenon zeroandusecrabtoverifythe inserted assertions with the interval domain .
when crab fails to verify the safety of a division instruction it emits a warning as apotential divide by zero bug.we cannot directly evaluatethe 2wehavetriedmoreexpressivedomains.thezonedomain failson6ofthe12 projectsdue totimeoutor memoryoutina 12hoursexperiment while theoctagon domain fails on of the projects.table analysis results for crab.
project warnings warning ratio time massscan 1m43s goaccess 0m34s libuv 0m15s redis 200m30s git 175m49s vim 111m29s imagemagick 389m49s openssl 5m26s systemd 68m41s php 141m30s gdb 20m10s linux kernel oom oom oom table divide by zero detection results for infer and csa.
na denotes the false positive rate when no bug is reported.
project of reports fp rate analysis time infer csa infer csa infer csa masscan na na 1m4s 4m8sgoaccess na 3m27s 10m59slibuv na na 3m13s 4m47sredis 8m47s 15m37sgit na 8m55s 15min5s vim na 24m21s 17m47s imagemagick 16m7s 25m24sopenssl na 49m2s 9m43ssystemd na 31m21s 11m45sphp na 20m23s 57m28s gdb na 41m59s 81m17s linux kernel crash crash crash 281m4s precisionofcrabbecauseitcurrentlydoesnotprovideaninterface to map its verification result to source code location for reports examination.
instead we record the number of warnings it generates and the ratio of its generated warnings over the total number of checked assertions.
intuitively a tool reporting warnings too often e.g.
consider a tool that reports a bug for half of the division instructionsintheprogram maybeunusableintheindustrialsetting .
however it should be noted that this only loosely relates to the precision and our comparison has the caveat of possibly underestimating the effectiveness of crab.
the analysis result for crab is shown in table .
on average crab produces bug reports per project failing to verify of thechecked assertions onaverage.
such alarge number ofbug reportswillimpedetheuserfromadoptingthetoolindivide byzero detection.
in contrast wit reports divide by zero bugs for the projects in total with an average false positive rate of .
comparingwithinferandcsa .
table7shows the results of infer and csa.
from the data we conclude that infer generates zero reports on six projects and fails on one project while csagenerates zeroreports onfive projects.
thus theybothhavemissedmanytruepositivesdetected authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
precise divide by zero detection with affirmative evidence icse may pittsburgh pa usa by wit.
the relatively low recall is due to practical considerations for the tools such as the limited capability fordetecting cross file bugs and inherent approximations in their algorithms.
overtheprojectswherethenumberofbugreportsisnonzero inferhasanaveragefalsepositiverateof64 andcsa has an average false positive rate of .
witrunsslowerthaninferandcsainprojectswithlarge sizes.
this is mainly because we utilize smt solving to be fully path sensitive.
however wit finishes within .
hours in all projects which is an acceptable performance given its precision improvement.
answertorq4 comparedwithexistingdivide by zerodetectors witissignificantlymorepreciseandsometimeseven detects more divide by zero bugs.
related work abstract interpretation .
in abstract interpretation many abstractdomainshavebeendesignedtoverifynumericalproperties such as the octagon and polyhedra domain .
recent workshavetriedtobalancebetweentheprecisionandcostofabstract interpretation.
oh et al .
utilize an impact pre analysis toapplycontext sensitivityselectively whilelait identifies and removes redundant constraints in numerical analysis to im prove speed without hurting precision too much.
mansur et al .
proposetoautomaticallytailortheconfigurationsofabstract interpretersaccordingtothecodeunderanalysisandresourcecon straints.ourworkimprovestheprecisionfromadifferentangleby finding the affirmative evidence for triggering the bug.
symbolic analysis for numerical bug detection .
to the bestofourknowledge wearethefirsttodesignasymbolicanalysis algorithmtargetingtheproblemofdivide by zerodetection.previousworksmainlyfocusonapplyingsymbolicanalysisinstatic bufferoverflowdetectionandintegeroverflowdetection.lietal .
adopt a simple symbolic value representation and filter out irrelevant dependencies during the symbolic value computation.marple performs on demand backward symbolic execution startingfromabufferaccessstatementandcategorizingprogram pathstoprioritizebugreports.sift utilizespreconditioninferenceincomputingsoundinputfilterstonullifyintegeroverflowerrorsassociatedwithcriticalprogramsitessuchasmemoryalloca tionorblockcopysites.theseworksadoptpath sensitivesymbolicdomainssimilartooursbutdonotdiscusstheimprecisionproblem brought by the under constrained variables or how to address it which is the key contribution of this work.
reasoning about programmer s beliefs .
engler et al .
first propose to infer from code about the programmers beliefs and detect potential bugs by spotting inconsistency of such beliefs.
dilligetal .
formalizetheintuitionof inaframeworkfor detecting semantic inconsistency where they design a null pointer dereference checker.
the belief propagation is carried out using type inference e.g.
a pointer inferred with a possibly null type should not be used in a context that requires a not null type.however divide by zero detection requires an infinite analysisdomainandexistingapproachesfortype statepropertiesarenot applicable.
inspired by the success of utilizing beliefs in previous works on static analysis we firstly introduce the use of beliefs to address theimprecisionproblembroughtbyunder constrainedvariablesin divide by zero detection.
we generalize the idea of programmer s belief inanalyzingnumericalcomputationbygeneratingbound evidence from the bound checking statements in the program.
althoughwedonotdirectlyinferinconsistency theevidencewegenerateservesasadditionalconstraints whichgreatlyimprovesthe overall precision of the analysis.
the imprecision problem caused byunder constrainedvariablesinstaticanalysisisobservedin where they tackle the problem with constraints rewriting.
since they do not consider numerical property in the constraints and assumeafiniteanalysisdomain theirapproachisnotapplicablein our scenario.
conclusion we have proposed wit a static analysis method to find divide byzero bugs with affirmative evidence.
the analysis looks for affirmativeevidence namelysourceevidenceandboundevidence to finddivide by zerobugswithhighconfidence.ithasbeenshown effectiveindetectingdivide by zerobugspreciselyinlarge scale real world software.