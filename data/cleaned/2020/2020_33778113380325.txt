securing unsafe rust programs with xrust peimingliu peiming tamu.edu texas a m university collegestation texas u.s.agang zhao zhaogang92 tamu.edu texas a m university collegestation texas u.s.ajeff huang jeff cse.tamu.edu texas a m university collegestation texas u.s.a abstract rust is a promising systems programming language that embraces bothhigh levelmemorysafetyandlow levelresourcemanipulation.
however the dark side of rust unsafe rust leaves a large security hole as it bypasses the rust type system in order to support lowleveloperations.recently severalreal worldmemorycorruption vulnerabilitieshave been discovered in rust s standard libraries.
wepresent xrust anewtechniquethatmitigatesthesecurity threat of unsafe rust by ensuring the integrity of data flow from unsafe rust code to safe rust code.
the cornerstone of xrustis a novel heap allocator that isolates the memory of unsafe rust fromthataccessedonlyinsaferust andpreventsanycross region memory corruption.
our design of xrustsupports both singleand multi threaded rust programs.
our extensive experiments on real worldrustapplicationsandstandardlibrariesshowthat xrust is both highly efficient and effective in practice.
introduction long existing system programming languages such as c c offer programmers the ability to manipulate low level resources but inerror proneways.countlessseverebugshavebeenfounddue to the unsafe nature of these languages .
rust i sa risinglanguagethattriestobridgethegapbetweenmemorysafety andlow levelsystemprogramming.withnewlanguagefeatures such as ownership borrowing and lifetime rust guarantees a program to be memory safe if it could be compiled at the absence ofunsaferust .thetypesystemofrustanditsencapsulationon low level operations have been formally proved to ensure memory safety .
however thestaticrestrictionsofrustcanbetoostricttoadmit many valid programs due to reasons including by nature static analysis is conservative and the underlying computer hardware is inherently unsafe and certain operations could not be done with safe rust .
this problem is addressed by unsafe rust which escapes from the static checks .
with unsafe rust programmers are able to manipulate raw pointers perform unprotected type casting and other dangerous operations just like in c c .
therefore a rustprogram is free of memory errors only when its unsafe code is correctly implemented and does not violate memorysafetyproperties .however requiringalltheunsaferust permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may23 seoul republic of korea 2020association for computing machinery.
acm isbn ... .
code for rust compiler and all the rust standard libraries .
loc loc unsafe unsafe collected crates .
rust lang .
codetobecorrectlyimplementedisdifficult.bugsinunsaferust codemayresultinseverevulnerabilities aswitnessedbyseveral memoryerrorsdiscoveredrecently .whatisworseisthat amemoryerrorinunsaferustmaycorruptarbitrarydatainthe whole address space i.e.
bugs in unsafe rust can be exploited to hijackfunctionpointers or steal sensitive data in safe rust.
to understand how the unsafe portion of rust is used in realworld applications we randomly selected crates from crates.io and counted the number of lines of unsafe code shown in table .
theresultindicatesthatmostreal worldrustprogramsonlyrely onaverysmallfractionofunsafecode onaverage.although in practice most memory objects in rust are statically protected by rust s type system a bug residing in unsafe rust code could simply ruin the entire effort and put the whole program at the risk of being attacked!
in this paper we present xrust a novel approach to mitigate the security threat brought by unsafe rust while imposing min imal overhead to rust programs.
while there exist several prior attempts onc c toretrofitfullmemorysafetyof the language which is often expensive our goal is not to bring memorysafetytounsaferust buttoensuretheintegrityofdata insaferust atthepresenceofmemoryerrorsinunsaferustcode .
inxrust the heap is logically divided into two mutually exclusive regions anunsaferegionandasaferegion.memoryobjectscreated and or accessed by unsafe rust referred to as unsafe objects a r e placed in the unsafe region and can be corrupted.
all other safe objectsare stored in the safe region and can never be corrupted.
the separation between safe and unsafe objects can be enforced by in process memory isolation techniques .
in this work weexploretwomethodsusinginstrumentationandmemoryguard pagesto achieve in process isolation.
as depicted in figure xrustworks as follows intheoriginalcode thetwoobjects bufandpassword are treated equally and are placed in the same heap region.
a heap based attack exploiting a memory corruption of buf inunsaferustcodecancausearbitrarywritetothewhole address space including corrupting password in the xrust protected code bufis placed in the unsafe region separated from password because bufis used in unsaferust.whenusinginstrumentation runtimechecks are inserted to prevent cross region data flows from the .
oe oufsobujpobm pogfsfodf po 4pguxbsf ohjoffsjoh 1pub fnmain letbuf vec new in unsafe letpassword string new unsafe offset is out of bound letptr buf.as ptr .offset num if !in unsafe region ptr raise error letv ptr address spaceoriginal program protected program heap stack globalbuf password address space heap stack globalunsafe region safe regionbuf password a b identify objects that are processedby unsafe rust codeacquire heap memory in a separate regionruntime checks to prevent cross region memory references1pub fnmain letbuf vec new in unsafe letpassword string new unsafe offset is out of bound letptr buf.as ptr .offset num out of bound read letv ptr instrument onunsafe objects figure a technical overview of xrust usinginstrumentation based memory isolation .
unsaferegiontothesaferegion.whenusingguardpages isolationis enforced by placing inaccessible memory pages between the two regions.
we note that xrustdoes not attempt to guarantee full memory safetyofunsaferust butthesafetyofmemoryobjectsinsaferust.
the main goal of xrustis to provide effective protection while imposing negligible overhead.
also xrustonly targets memory corruption on heap objects.
stack protection techniques such as stackcanaries andsafestack havebeendeployedwidely inrealsystems.proposals tosupportsafestackinrusthave alsobeen implemented.
toourknowledge xrustisthefirstattempttoisolatetheside effectofunsaferustautomaticallyanditachievesbotheffectiveness and efficiency by leveraging unique language features of rust.
the designofanewtypeofmulti regionheapallocatorisseamlessly incorporated into the rust framework while achieving backwards compatibility.
to support a separate memory region in xrustis also challengingandwemade extensivemodifications inthe rust compiler ranging from high level language features to the lowlevelheapallocator.insummary wehighlightourcontributionsas follows xrustisthefirstapproachtoautomaticallyprotectsaferust from memory corruption errors in unsafe rust.
a recent work fidelius charm shares a similar goal but it requires programmers to mark and restore unsafe data before and after unsafe code blocks at memory page level.
moreimportantly fc is limited usability when handling shared unsafeobjectsinsaferustcodeasdiscussedinsection5.
.
.
we design and implement a novel heap allocator that supportssafeandunsafememoryregions andefficientlychecks cross regionreferencesusinginstrumentationorguardpages.
weevaluate xrustextensivelyonreal worldrustapplicationsandmemoryerrors.ourresultshowsthat xrustincurs0.
medianoverheadontestedcrates .
onruststandard libraries and it effectively defends against attacks that exploit known real world memory vulnerabilities in rust.
overview in this section we first discuss the rationale behind the design ofxrust.
we then illustrate how xrustworks on a motivating example based on a real vulnerability in rust.
.
why xrust?
the clear separation between safe and unsafe rust naturally dividesobjects intotwo mutuallyexclusive sets the setsof safeand unsafeobjects basedonwhethertheyareusedinunsaferust.at a high level view since only unsafe objects are under the risk of being corrupted in rust programs the isolation enabled by xrust between memory regions used by safe and unsafe objects ensures that potential memory corruptions can only impact the unsafe region and can never cross the boundary to corrupt safe objects.
in this subsection we first discuss how unsafe rust is used in practice and then discuss the protection strength of xrustwith respect to both spatialandtemporal memory safety.
.
.
unsafe rust in practice.
we studied several popular opensourcerustprojectsaswellastheruststandardlibrarytounderstandtheusageof unsafe rust in the real world.
assummarized intable rust programs onlycontain lessthan unsafecode on average and unsaferust istypically usedonly forlow leveloperationsandoptimizations.thestatisticsprovide strong evidence thatmost objects are only processedby safe rust and by isolating the side effect of unsafe rust xrustis able to protect all of them.
apart from this we also conducted in depth inspectionsofthesourcecodeontheusageofunsaferust relatedto memory safety .wesummarize ourfindings into threecategories unbounded memoryaccesses.
insteadofusingobjectreferences programmerssometimesuserawpointersandunchecked pointer arithmetic to access a piece of consecutive memory.
e.g.
inbase64 instead of using a vector the developers access the encoding buffer directly through a raw pointer and iterate overthe memory by adding offsets to the pointer.
this pattern is normallyusedtoaccessaninternalbufferandtoskipdefaultbound checkings in image base64 vec etc uncheckedconversions.
thisincludesboth typeconversion as well as data format conversion e.g.
utf toutf .
this is mainly used for developing low level functionalities such as decoding encodingbinarydataandserializationasin string byteorder bytes etc.
internalstatesoverride.
when using well encapsulated safe apisfromrustlibraries theinternalstatesofanobjectisnormally maintained internally by rust e.g.
pushing an element into a vector increases the size of the vector .
however when developers access an object in unexpected ways the internal states need to bemanuallyadjusted.
e.g.
afterinitializingthebufferofavector using raw pointers the size of the vector needs to be overridden accordingly.
the operation is unsafe as programmers are responsible to provide the correct value and unmatched internal states may lead to undefined behaviors.
this is typically used for the purpose of low level optimizations as in vecdeque vec etc.
.
.
observations behind xrust.
basedontheempiricalstudies above we make two observations observation beingawarethattheunsaferustcodeisnot checked by the compiler rust programmers tend to avoid heavy usageofunsaferustinpracticeandonlyrelyonunsafefeatures to perform necessary low level operations .
this indicates that in reality it is likely that most objects in a rust application aresafe objects and critical data such as password with high level semantics is unlikely to be processed in unsafe rust.
apartfromthis wemakethesecondobservationbasedonrust s object memory model that indicates how indirect calls which is essentialto control flow integrity is handled by rust.
observation unlikec whichstoresthe virtualfunctiontable vtable pointers of an object adjacent to its data members rust stores them separately.
internally rust achieves polymorphism and dynamic dispatching by transforming objects into trait objects .
as illustrated in figure the reference to a trait object is afat pointer consisting of two pointers one points to the data members of the object and the other points to the vtable.
this implicitly puts theheap data and vtable pointers into two regions.
forunsafeobjects onlyitsdatamembersareallocatedintheunsafe heap region.
thus overflow to corrupt vtable pointers is a cross region reference and will be prevented by xrust.
.
.
protection strength of xrust.
the two observations above leadto the following properties of xrust spatial memory safety the observations imply that by preventingcross regionreferences xrustcanefficientlydefendrust programs against non control data attacks in unsafe rust code that corrupt objectsoutsidetheunsaferegion data vptr fngetx int fngety int ...structpoint intx inty ptr intgetx intgety ...structpoint intx inty vptr c rust figure memory layout of objects in c vs rust.
control oriented attacks in unsafe rust code that corrupt the vtable pointer of a trait object or raw function pointersoutsidetheunsaferegion e.g.
tohijackcontrolflowto maliciouscode.
these protections are valuable in practice because there is a high chance that most sensitive data in rust user applicationsare safe objects observation and vtable pointers of trait objects are the major source of indirect jumps in rust and they are protected by xrust observation .
temporal memory safety .xrustis able to prevent temporal memoryerrorsfromcorruptingsafeobjectsaswell.inrust tempo ralerrorscanonlyhappenonunsafeobjectsbecausesaferustcode staticallyeliminatesalltemporalerrorsbyanalyzingthe lifetimeof referencesandthe ownerships ofobjects.so whenatemporalerror e.g.
useafterfree occurs thepointerusedtoaccessmemorymust point to an unsafe object.
since our multi region allocator will not reuse memory previously used for unsafe objects to allocate any safe object section .
the freed memory of an unsafe object will only be used to hold another unsafe object.
when temporal errors occur memory accesses on the freed pointer will still be within unsafeheap regionsothat thetemporalerrors cannotescape the unsaferegion to corrupt safe objects.
.
a motivating example listing shows a code fragment simplified from the rust base64 library.
for versions before .
.
the library contains an integer overflow bug that eventually leads to a heap buffer overflow.
on line the vulnerable function first tries to reserve a buffer on theheapandthesizeofthebufferiscalculatedbythevulnerable functionencoded size thatcontainsa integeroverflow error.1a heap overflow can happen when the integer overflow leads to a smallerbuffer andthis vulnerabilitycan beexploitedto overwrite datainsaferust.forrustapplicationsdependingonthislibrary the unsafe code may only account for a small fraction of the entire code.however thisbugcanstillresultinmemorycorruptionsin theentire address space.
xrustsignificantly mitigates this vulnerability.
it first identifies bufas an unsafe object because it is used in unsafe rust line by analyzing the data flow from the safe rust to unsafe rust.
then instead of reserving heap memory for the objects normally line itreservesthememoryfor bufintheunsaferegion byrewriting 1note that rust does check integer overflows for the debugging build by default but notin the optimized release build.
1pub fnencode config buf t buf t .. reserve a large enough buffer to store the encoded string 4buf.reserve encoded size len using unsafe operation to store encoded string to buffer unsafe buf object is used in unsafe code!
let mut output ptr buf.as mut ptr whilecondition do pointer arithmetic and accessing memory directly ptr write output ptr.offset .. ... ... listing a real buffer overflow in rust base64 due to unsaferustcode cve .
thefunctiontocallanextendedapi.finally accessesto buf which is anunsafe object are restrictedto bewithin theunsafe memory region.whenusinginstrumentation thememoryreferenceonline will be instrumented as follows 1letptr output ptr.offset .. 2if !in unsafe region ptr 3raise error 5write ptr ... atruntime attemptstoaccessaddressesoutsidetheunsafeheap region are detected by xrust thus the vulnerability cannot be exploited to perform attacks on safe objects.
weobservethat evenwithinstrumentationwhichoftenimposes high overhead for other languages such as c c by other techniques xrustisstillfast .
overheadonmedian .thisisbecause xrustonly checks memory