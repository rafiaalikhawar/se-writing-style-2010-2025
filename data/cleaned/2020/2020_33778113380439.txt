burn after reading a shadow stack with microsecond level runtime rerandomization for protecting return addresses changwei zou school of computer science and engineering unsw sydney australiajingling xue school of computer science and engineering unsw sydney australia abstract return orientedprogramming rop isaneffectivecode reuseattack in which short code sequences i.e.
gadgets ending in a ret instruction are found within existing binaries and then executed by taking control of the call stack.
the shadow stack control flow integrity cfi and code re randomization are three popular techniquesforprotectingprogramsagainstreturnaddressoverwrites.
however existing runtime rerandomization techniques operate on concrete return addresses requiring expensive pointer tracking.
byaddingonelevelofindirection weintroducebarra thefirst shadowstackmechanismthatappliescontinuousruntimererandomizationtoabstractreturnaddressesforprotectingtheircorresponding concrete return addresses protected also by cfi thus avoidingexpensivepointertracking.asaniceside effect barranaturallycombinestheshadowstack cfiandruntimererandomizationinthesameframework.thekeynoveltyof barra however is that once some abstract return addresses are leaked barra will enforcetheburn after readingpropertybyrerandomizingthemapping fromthe abstract to theconcrete return addressspace in the order of microseconds instead of seconds required for rerandomizingaconcretereturnaddressspace.asaresult barracanbeusedasasuperiorreplacementfortheshadowstack asdemonstratedbycomparingbothusingthe19c c benchmarksinspeccpu2006 totalling loc and analyzing a proof of concept attack providedthatwecantoleratesomeslightbinarycodesizeincreases byanaverageof29.
andarewillingtouse8mbofdedicated memoryforholdingupto220returnaddresses ona64 bitplatform .
underaninformationleakageattack forsomereturnaddresses theshadowstackisalwaysvulnerablebutbarraissignificantly more resilient by reducing an attacker s success rate to1 220on average .intermsoftheaverageperformanceoverheadintroduced both are comparable .
barra vs. .
the shadow stack .
keywords shadowstack runtimererandomization controlflowintegrity return oriented programming thanks to allthe reviewers for theirvaluable comments.
this research issupported by an australian research council grant dp180104069 .
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn ... .
of information disclosure vulnerabilities figure1 riseofinformationdisclosurevulnerabilities .
introduction software security is becoming increasingly important due to increased reliance on computer systems.
for performance reasons c andc arestillthedefactolanguagesforimplementingoskernels browsersandwebservers.duetotheirlackofmemorysafety security vulnerabilities such as buffer overflows are frequently found in c c software applications ranging from servers to embedded systems .
this has allowed an attacker to launch control flow hijacking attacks to redirect execution to malicious code by modifying code pointers such as return addresses on thecallstack .duetothewidespreadadoptionofdataexecution prevention dep techniques such as w x code injection attacks whichrelyonmaliciouscodeinjectedintoaprogram are no longer threatening.
to circumvent dep code reuse attacks whichrelyonmaliciouscodeformedfromexistingcodefragments knownas gadgets arebecomingmoreprevalent .inparticular return oriented programming rop is an effective code reuse attack in which a return address on the call stack is modified to redirect executionto a sequence of gadgets with each ending ina ret instruction rop gadgets toperform arbitrary malicious computations.
it is thus imperative to develop mitigation techniques to protect programs against return address overwrites.
problem statement.
a shadow stack protects a function s return address on the call stack by hiding it in the shadow stack which cannot be as easily modified by a buffer overflow happeningonthecallstack.
however this mechanismreliesoninformation hiding for the shadow stack and consequently is vulnerable to information disclosure and side channel attacks .
aslr address space layout randomization which randomizes the locations of modules at load time is also vulnerable toinformation leakage attacks .
as shown in figure thenumberofinformationdisclosurevulnerabilitiesreportedon the cve website has surged in recent years.
controlflowintegrity cfi canalsobeusedtoprotectreturn addresses by limiting all rop gadgets to a set of predefined return addresses but the resulting attack surface is still too large .
ieee acm 42nd international conference on software engineering icse given that some information leaks are detected during program execution we investigate how to apply continuous runtime rerandomization to make the shadow stack significantly more secure.
challenges.
there are three challenges faced.
first how do we provide lightweight runtime rerandomization especially if it needs to be frequently performed during program execution?
second how do we minimize the instrumentation overhead thus introducedformaintainingtheshadowstack?finally howcanwemake the shadow stack significantly more secure by applying runtime rerandomization and possibly cfi at the same time?
priorwork rerandomizingconcretereturnaddresses.
existing runtime rerandomization techniques operate on concrete return addresses and consequently are applied to the call stack directly.
once a return address on the call stack has beenleaked indicating that it may soon be replaced by the address to aropgadget runtimererandomization canbeappliedso thattheaddressoftheropgadgetbecomesinvalidated thereby mitigating the impact of information leakage.
however rerandomizing concrete return addresses requires expensive and difficult pointer tracking.for example runtimeaslr astate of theartruntimererandomizer takes35secondstotrackthepointersfor thenginxwebserver.duetoitsexcessiveperformanceoverhead runtimeaslr rerandomizes a freshly forked child process only once atthetimeof fork byreusingthepointertrackingresults of its parent as the child process inherits the state of its parent just before it starts its execution .
by failing to rerandomize a child process that has executed for a while runtimeaslr avoids the costsincurredbynewtime consumingpointertrackingoperations but at the risk of being vulnerable to code reuse attacks figure .
tothebestofourknowledge cfi hasbeenappliedtoprotect forward edges i.e.
indirect calls via function pointer and virtual calls insteadofbackwardedges i.e.
returnaddresses .theresearch on forward edge cfi assumes usually that the shadow stack mechanism is used for enforcing backward edge cfi.
this work rerandomizing abstract return addresses.
by addingonelevelofindirection weintroducethefirstshadowstack mechanism barra that applies a novel runtime rerandomiza tion technique to rerandomize abstract return addresses in theshadow stack to protect their corresponding concrete return ad dresses therebyavoidingexpensivepointertrackingasrequired in runtimeaslr .
under some information leaks barra will immediately rerandomize the mapping from the abstract to the concrete return address space in the order of microseconds instead of seconds as required by runtimeaslr .
this enforces the burn after reading property whichrequiresallleaked returnaddress informationtobemadeobsoleteviarerandomization.asa result barra has made the traditional shadow stack significantly moresecurewhileincurringacomparableinstrumentationoverhead on average.
finally barra represents the first approach that protects programs against return address overwrites by combining the shadow stack cfi and runtime rerandomization altogether.
this paper makes the following two major contributions we introduce a novel shadow stack mechanism that is ca pable of applying continuous microsecond level runtimererandomization for protecting return addresses makingthe traditional shadow stack significantly more secure at comparable performance overheads sections and .
we have implemented barra as a software hardening tool and experimentally confirmed barra as a superior replacementforthetraditionalshadowstack section4 .inourevaluation we have used all the c c benchmarks in spec cpu2006 totalling2 447loc andaproof of conceptattack.
in the case of information leakage the shadow stack is always vulnerable.
however if we can tolerate slight binary codesizeincreases byanaverageof29.
andarewillingtouse8mbofdedicatedmemoryforholdingupto2 20return addresses ona64 bitplatform wecanmakebarrasignifi cantlymoreresilientthanthetraditionalshadowstackbyreducinganattacker ssuccessrateto 220onaverage.bothhave comparable average performance overheads .
barra vs. .
the shadow stack .
barra methodology wemotivateourbarramethodologybydescribinghowwecan transformatraditionalshadowstackintoasignificantlymoresecure burn after reading shadowstack.section2.1usesanexample toexplainhowabufferoverflowcanleadtoreturnaddressoverwritesonthecallstack.section2.2describeshowthisvulnerability intheexamplecanbeexploitedtolauncharopattack.continuing with the same example we describe why the traditional shadow stackmechanismis vulnerabletorop attacksinthepresence of informationleakage section2.
andhowour burn after reading shadow stack is significantly more secure section .
.
.
buffer overflow vulnerabilities figure illustrates how a buffer overflow bug can cause the return address of a function on the call stack to be modified.
high low01 void read and echo void char buf gets buf printf buf void do request while read and echo ret addr ... buf ret addr ... buf do request read and echo call stack figure a buffer overflow vulnerability.
in lines read and echo reads some user input and saves it in a local buffer buf.
as the c library function ets does not checkthecapacityof buf thereisabufferoverflowvulnerabilityin line .
in addition the c library function printf invoked in line also contains an information disclosure vulnerability exploited in a proof of concept attack in section .
by inputting more data thanbufcan hold an attacker can corrupt the return address of read and echo on the call stack with one of her choosing.
when read and echo returns the control flow will be hijacked.
.
return oriented programming figure illustrates a rop attack where three rop gadgets a b and c are chained to compute target num .
by exploiting abufferoverflowvulnerability figure2 anattackercanreplace thereturnaddressof read and echo withtheaddressofgadget a. once this victim function returns gadgets a b and c will be triggered one by one resulting in a control flow hijacking attack.
... addr of gadget c num addr of gadget b target addr of gadget a... addr of gadget c num addr of gadget b target addr of gadget a call stack03 pop rsi ret pop rdi ret05 mov rsi rdi ret gadget c gadget b gadget aret slotfake retfake ret target num figure a rop attack by exploiting say the buffer overflowvulnerabilityin read and echo offigure2 where rsi contains the value of numand rdi the value of target.
ropisturingcomplete .asaspecialcase whenagadget beginsattheentryofafunction wehaveaso called return intolibc attack .
the c library function system bin sh is thus a popular choice for hijacking the victim by launching an interactive shell in a proof of concept attack in section .
.
the traditional shadow stack tomitigatearopattackillustratedinfigure3 ashadowstackhas traditionallybeenusedtohidethereturnaddressesonthecallstack.
to prevent the return address of read and echo from being overwritten asshowninfigure4 thereturnaddressof read and echo is saved in the shadow stack at the offset offset rsp lines on entering the function and restored from the same location onleavingthefunction lines6 .byconvention rspis the standard stack pointer pointing to the top of the call stack.
for simplicity the shadow stack is assumed to have the same size as the call stack rather than as a filo stack to save space .
saved ret addr ...saved ret addr ... shadow stack01 read and echo save return address popq offset rsp subq rsp ... retore return address06 addq rsp07 movq offset rsp r1108 jmpq r11ret addr ... buf ret addr ... buf call stack figure the traditional shadow stack mechanism for protecting the return address of read and echo in figure .
asshowninfigure4 theshadowstackusuallyappearsbelowthe callstackatafixedoffset offset whichisgeneratedrandomlyat01 all ret addrs ra 0 ra 1 ... ra n mapping table bar mtable ... ra 2 ... indirect jump ret id fetch ret id jmp bar mtable ret addr ... buf ret addr ... buf call stack a the b arra stack instrumentation rand ret id ...rand ret id ... ... ... barra stack... ... gadget a204 gadget a read re rand... ... 8202attacked... ... gadget a204 non gadget a rand ret id204 non gadget a b1 b2 b3 b4 b burn after reading bar mtable barra stack b arra stack b arra stackbarra stack figure the burn after reading shadow stack for protectingthereturnaddressof read and echo infigure2against the rop attack with gadgetsa c illustrated in figure .
the beginning of program execution and then hidden subsequently say inaread onlycodesection.thismechanism whichrelieson hidingthelocationoftheshadowstack isvulnerabletoinformation disclosure and side channel attacks .
as discussed already in section several complementary or orthogonalmitigationtechniquesareineffective aslr which is still vulnerable to information disclosure and side channel at tacks cfi which still has a large attack surface and runtime rerandomization on concrete return ad dresses which is too expensive in its pointer tracking operations to be applied frequently and is thus also vulnerable .
.
the burn after reading shadow stack figure5illustratesourbarramethodology withtheunderlying shadowstacknowreferredtoasthe barrastack.unlikethecase for the shadow stack even if the location of the barra stack is leaked barracanstillpreventthecontrolflowfrombeinghijacked by modifying the return address of read and echo with a high probability resulting in a significantly stronger security guarantee.
thekeynoveltyof barraistoabstractaconcretereturnaddress witharandomizedreturnidandstoretheabstractreturnaddress thus obtained in the barra stack.
this one level of indirectionmakes it possible to apply continuous runtime rerandomizationefficiently to the barra stack to enforce the burn after reading property requiring all leaked return ids to be made obsolete .
figure a illustrates how the barra stack works.
by applying program analysis all the nreturn addresses in the program arefoundandsavedin all ret addrs lines1 .duringprogram execution a table named bar mtable of sizem wherem greaterorequalslantn maintains a mapping from return ids to their concrete return ad dresses line .
when a barra protected function returns its returnidisfetchedfromthe barrastack line5 andanindirect jump is made to its corresponding concrete return address line .
260c c program wllvm clang barra assembly instrumentator asm codehardened programllvm ir assembler linkerinstrumented asm code figure the workflow of barra.
figure5 b illustrateshowbarramitigatestheropattackwith gadgetsa c figure where the attacker attempts to replace the return id of read and echo with the return id of gadget a. currently the return id of read and echo is figure b1 .
by performing some information leakage attacks the attacker has found the return id for gadget a to be .
on detecting this informationleak section3.
barrawillenforceimmediatelythe burn after reading propertyas illustrated infigure5 b2 .this is doneby rerandomizingthe mapping bar mtable.afterwards as shown in figure b3 the return ids for read and echo and gadgetahavebeenchangedto8202and8204 respectively.evenifthe attacker manages to replace the return id of read and echo with in the barra stack as shown in figure b4 gadget a can no longer be executed as its return id is now !
to recap from section barra has several salient properties lightweight runtime rerandomization.
rerandomizing bar mtablecanbedonesimplybymodifyingarandomlygeneratedoffsetaddedtoallthereturnids modulo m .thisrequires thereturnidsinthebarrastacktobeupdated intheorderofmi crosecondsinsteadofsecondsasrequiredbyruntimeaslr dueto its expensive pointer tracking delivering a six orders ofmagnitudespeedup.
low instrumentation overheads.
barra exhibits comparable instrumentation overheads as the shadow stack mechanism.
strong security guarantees.
as the maximum number of returnidsis m thesizeof bar mtable thechanceofguessingcorrectlythereturnidforgadgetatobe8204infigure5 b4 isonly m.ifweuse8mbofmemory ona64 bitplatform toimplement bar mtable wherem greatermuchnis possible an attacker s success rate is only1 .
finally unlike runtimeaslr barra integrates cfi by limiting all gadgets to be within all ret addrsin figure5 a withtheshadowstackandruntimererandomization.
barra design and implementation wefocusonprotectingreturnaddressesbyadoptingthesamethreat model as before .
the attacker can read any readable memory or write any writable memory by exploiting existing vulnerabilities in order to hijack the control flow.
wehavedesignedandimplementedbarrainthellvmcompiler tool chain as shown in figure .
given a c c program its sourcefilesarecompiledandlinkedbythellvmtoolchaininto a single llvm ir known as bitcode .
we use a compiler wrap per wllvm to build a whole program llvm bitcode file.
the barra assembly instrumentator which is added in this paper generates instrumented assembly code that is amenable to lightweight runtime rerandomization on abstract return addresses.
finally theinstrumentedassemblycodeisassembledandlinked into a hardened binary by the assembler and linker respectively.as is standard every function is assumed to have at most one return instruction with jumps added where appropriate .
belowweuseanexamplegiveninfigure7toillustratetheinstrumentationaddedbybarra.forthemotivatingexamplerepeated infigure7 a barramaintainsthe unused concretereturnaddressesinthecallstack forcompatibilityreasons figure7 b andtheirabstractreturnidsinthebarrastack figure7 c .figure7 d figure e gives the instrumented code data section.
.
data instrumentation figure e lists an instrumented data section added consistingof a read only table all ret addrscontaining all the return addressesintheprogram lines24 arandomlygeneratedvalue bar randval lines and our mapping table bar mtable lines .
both bar randvalandbar mtablereside in the .bss sections and thus take no actual space in the object file.
in this example all ret addrsof sizen contains five return addresses.
bar randval which is a byte value is stored in a byte page on page aligned boundaries such that the entire page can be set as read only after bar randvalhas been generated after each round of runtime rerandomization.
bar mtable of sizem wherem greaterorequalslantn will be initialized at load time such that lessorequalslanti n bar mtable all ret addrs and n lessorequalslanti m bar mtable address of a rop catcher .
when an attacker tampers with the barra stack with a stale return id mapped into the rop catcher a warning message can be issued.
in our approach bar mtableis disclosed to the attacker.
however on detecting information leaks or at the program startup every return id i will be changed randomly to i bar randval modm so that the burn after reading property is enforced.
to provide strong security guarantees bar mtableshould be reasonablylarge.itissuggestedtoallocate8mbofmemory ona64 bitplatform for bar mtablesothatitcanholdupto m 0x100000 i.e.
1m returnaddresses.this way anattacker ssuccess ratefor guessing the return id of a gadget correctly is only1 m .
.
code instrumentation figure d shows how to instrument a call instruction and its corresponding return instruction.
we need to add instrumentation codebeforethecallfor read and echo butafterallitsparameterpass instructions if any in do request line .
we also add instrumentation code to replace the return instruction not shown explicitly in read and echo whose concrete returnaddressis bar retaddr 2 i.e.
0x401296 and abstract return id is .
unlike the shadow stack mechanism that instruments a call instruction by adding its instrumentation code at the beginning of allthe calleefunctions figure4 barra instrumentsall thecalls separately in order to also protect their return edges using cfi .
void read and echo void char buf gets buf printf buf void do request void while read and echo void all ret addrs n is .
.section .rodata .type all ret addrs object .globl all ret addrs28 all ret addrs .quad bar retaddr 0 .quad bar retaddr 1 .quad bar retaddr 2 .quad bar retaddr 333 .quad bar retaddr 4 .size all ret addrs int bar randval random value type bar randval object .globl bar randval .bss .p2align bar randval .zero .size bar randval void bar mtable m is 0x100000.
.type bar mtable object .globl bar mtable .bss .p2align bar mtable .zero .size bar mtable do request ... c7 c0 mov 0x rax 40127b e0 add bar randval rax ff ff 0f and 0xfffff rax f8 ff ff fe mov rax bar offset rsp e8 2a callq read and echo bar retaddr 2 ... read and echo ... 4c 8b 9c ff mov bar offset rsp r11 4c 2b 1c e0 sub bar randval r11 e3 ff ff 0f and 0xfffff r11 c4 add 0x8 rsp 40132c ff dd jmpq bar mtable r11 a source code d instrumented code section e instrumented data section 0x401296 ...0x401296 ... bar randval ... bar randval ...ret addr ret id c b arra stack b call stack figure barra s instrumentation illustrated for an example program.
.
.
call instructions.
for the call to read and echo our instrumentationcode lines12 insertsitsrandomizedreturnid bar randval modminto the barra stack at its location bar offset rsp wherethemodulooperationisrealizedin line14.here rsp 8pointstothereturnaddress bar retaddr 2 onthecallstack.asinthecaseoftheshadowstack section2.
the barra stack appears below the call stack at a fixed distance of bar offset.inline16 bar retaddr 2willstillbepushedinto the call stack even it is not used for compatibility reasons .
.
.
return instructions.
to replace the return instruction in read and echo we rely on some instrumentation code again lines .
in lines we retrieve its return id saved after un the rerandomization as bar randval line bar randval line modm line 2from the barra stack.
in line we adjust rspby skipping the unused return addressbar retaddr 2in the call stack for compatibility reasons.
.
runtime rerandomization ondetectinganinformationleak orattheprogramstartup barra willstartanewroundofruntimererandomization fortheabstract returnaddresses byinvoking rerandomize infigure8.insteadof rerandomizing bar mtabledirectly weachievethesameeffect as validated easily by inspecting lines and in figure d more efficiently by modifying bar randval randomly.torandomizebar randval asshowninfigure8 a weincrementitbyarandomlygeneratedoffset curdelta lines13 .we then callupdate barra stack rbp to add this offset to the return idsinthebarrastack lines16 .inline16 rbp get rbp isinitializedtopointto thebeginning ofthelist ofthe framepointers rbps saved on the call stack as illustrated in figure b .
by traversingthislist lines5 wecanlocatethereturnidsforall the callers stored in the corresponding barra stack.
there are general approaches to detecting information leaks in a program .
in our evaluation we monitor whether some input output functions such as ets in figure are called as in and invoke rerandomize as soon as this has happened.
specifically every input output function can be hooked so that rerandomize willbealwaysexecutedjustbeforeit.onarrivingat the server where a barra protected programis running froma remoteattacker amaliciouspacketwillbehandledbysuchhooked functions resulting in burn after reading via rerandomization .
.
an example werevisitourmotivatingexamplebyrefiningfigure5 b tofigure9 toseehowbarramitigatestheropattackinfigure3 inwhich theattackerattemptstoreplacethereturnidof read and echo with the return id of gadget a in the barra stack.
at timet0 we have two return ids for read and echo and for gadget a. at the program startup t1 bar randval is generated.
just before read and echo is called lines in ... return address prev frame pointer ... return address prev frame pointer... return address prev frame pointer ... return address prev frame pointer call stackget rbp bar offset sizeof unsigned long return id ... return idreturn id ... return id barra stack01 void all ret addrs all return addresses void bar mtable b arra mapping table int curdelta void update b arra stack unsigned long rbp while rbp !
stack end unsigned long pretid unsigned long rbp sizeof unsigned long bar offset pretid pretid curdelta m rbp unsigned long rbp void rerandomize srandom time curdelta random m bar randval bar randval curdelta m unsigned long rbp get rbp update b arra stack rbp bar randval circular queue0 n 1m a algorithm for runtime rerandomization b stack layout figure barra s runtime rerandomization with the police icon representing the return ids mapped to a rop catcher .
init read attacked re turn t0 t1 t2 t3 t4 t5 t6 t7 curdelta bar randval re turn id m first rop gadget id figure9 barra smitigationfortheropattackinfigure3 by protecting the return id of read and echo in figure .
figure7 d itsrandomizedreturnid202isinsertedintothebarra stack.
the randomized return id for gadget a has been changed to whichisdiscoveredbytheattackerat t2.toenforceburn afterreading barracalls rerandomize att3 sothatbar randval curdelta .at t4 therandomizedreturnid ofread and echo on the barra stack has been changed to andthereturnidofgadgetahasbeenre randomizedto8204.withtheattackcomingat t5 therandomizedid8202onthebarrastack will be overwritten with a malicious but stale gadget id .
when the attacked function returns the instrumented code in lines in figure d will generate a return id m which is not gadgeta.
if mrepresents ourrop catcher then the attack will be flagged at t7 marked by the police icon .
evaluation we have implemented barra in c c in the llvm compiler toolchain.currently barrasupportsboth32 bitand64 bitx86 assembly code.
to ensure that barra is compatible with closed source i.e.
unprotected binaries we have also implemented a simple static analysis on top of svf an open source pointer analysis framework toidentifythefunctionsinasoftwareapplicationthatmay be called from closed source binaries.
these functions will be protected by the traditional shadow stack mechanism as their callinstructionscannotbeinstrumented.infuturework wewillconsider binary instrumentation and disassembly t o provide full barra protection for all the functions in the program.
our evaluation demonstrates the efficiency and effectiveness of barra in protecting return addresses in real world applications with the shadow stack as the baseline .
we have selected all the c c programs in spec cpu2006 totaling loc including functions and call instructions .
we have also developed a proof of concept attack which works byexploitingsomeformatstringvulnerabilities suchascve 20197715andcve 7712onthecvewebsite .weshowthat undersomeinformationleakageattacks theshadowstackisalways vulnerable but barra is substantially more secure.
we address the following three research questions rqs rq1.is barra s runtime rerandomization lightweight?
rq2.does barra have low instrumentation overheads?
rq3.is barra effective in protecting return addresses in the presence of information disclosure vulnerabilities?
our platform consists of a .
ghz intel xeon r e5 v4 cpu with gb memory running the bit ubuntu os.
all the spec cpu2006 programs are compiled under the optimization flag o2 .whenrunningaprogram thecallstackusedis8mb by default and its corresponding shadow barra stack is also 8mb.
the time measurement for each metric is the average of runs.
to enforce the burn after reading property barra uses 8mb of memory to implement its bar mtableas illustrated in figure .
however this is not needed by the traditional shadow stack.
.
rq1 lightweight rerandomization accordingto rerandomize infigure8 thetimespentineachround of runtime rerandomization depends on the depth of the call stack.
byreading proc pid stackforallthe19speccpubenchmarks the depths of their call stacks are found to be all under .
to covermorecases wehavewrittenarangeoftestprogramswith 263table the times spent for barra to perform runtime rerandomization under different call stack depths.
call stack depth time microseconds table comparing runtimeaslr and barra.
runtimeaslr barra address space concrete abstract randomization timing fork any timecoverage all pointers return addresses pointer tracking check burn after reading check overhead seconds microseconds differentcallstackdepths.theruntimererandomizationoverheads under different call stack depths are listed in table .
it is worth emphasizingthatnomorethan3microsecondsareneededwhen the call stack depth is below .
elsewhere the average call stackdepthobservedismuchsmaller.ingeneral thetimetakenbyrerandomize is linearly proportional to the depth of the call stack.
table2summarizesthemajordifferencesbetweenbarra operatingonanabstractaddressspace andruntimeaslr astateof the artruntimererandomizeroperatingonaconcreteaddress space as already discussed in section .
runtimeaslr rerandomizes all the pointers in the program.
in contrast barra rerandomizes only the return addresses i.e.
backward edges while leaving theprotectionoftheforwardedgestocfi .byoperatingona concreteaddressspace runtimeaslrmustperformexpensiveand difficultpointertracking.duetoitsexcessiveoverheads e.g.
secondsfor soplex runtimeaslroptstoapplyruntimererandomizationtoachildprocessonlyatthetimeof fork thusfailingto enforcetheburn after readingpropertyinthepresenceoffrequentinformationleakageattacks.incontrast barraislightweight mak ingitsuitabletoenforcetheburn after readingpropertywhenever some information leaks are detected.
insummary barraperformsruntimererandomizationinthe order ofmicroseconds while runtimeaslr operatesin theorder ofseconds.forthecallstackscontaininglessthan256calls barra turns out to be six orders of magnitude faster .
.
rq2 low instrumentation overheads table 3lists thestatisticsfor the19 c c spec benchmarks.for eachbenchmark loc text funsand callsgiveitssourcecode size its binary code size the number of its functions and the number of its calls respectively.
under inst overheads columns weseetheinstrumentationoverheadsintroducedbythetraditionalshadowstackandbarra.under codesizeincreases columns we see the code size increases under two approaches.
belowwecomparebothapproachesintermsoftheirinstrumentation overheads introduced and code size expansion incurred.
.
.
instrumentation overhead.
despite significantly stronger guaranteesprovided section4.
barraexhibitscomparableinstrumentationoverheadsastheshadowstack .
fortheshadow stack vs. .
for barra on average as revealed in columns6 .
these results correlate well with a similar number of instrumentation instructions executed under the shadow stack figure and barra figure .
to instrument a call barra introduces a memory read for bar randval in line and a memory write in line15 figure7 .incontrast theshadowstackaddstheinstrumen tationcodeatthebeginningofeachofitscalleefunctions figure4 .
itspopinstruction line consists of essentially a read on the call stackandawriteontheshadowstack.asthepagethatcontains bar randvalisaccessedfrequently itscachehitrateisexpected tobehigh reducingitsmemoryreadoverhead.inaddition barra uses two additionalnon memory access instructions lines and in figure while the shadow stack uses only one line in figure .
a similar analysis applies to the instrumented code for a return instruction.
therefore barra is expected to have similar instrumentation overheads as the shadow stack.
.
.
code size expansion.
in order to protect return addresses betterthantheshadowstack section4.
barrageneratesslightly larger binaries across the benchmarks .
for the shadow stack vs. .
for barra on average as revealed in columns .
for aprogram theextracodeaddedbybarraconsistsof atable all ret addrscontainingitsreturnaddresses figure7 e the instrumentation code for its call instructions lines in figure7 d and theinstrumentationcodeforitsreturninstructions lines19 23infigure7 d .thetotalcodesizeincreasein and isproportionaltothenumberofcallinstructionswhilethecode sizeincreasein isproportionaltothenumberoffunctionsinthe program.incontrast thenumberofinstrumentationinstructions added by the shadow stack to a program is always proportional to the number of its functions figure .
as a program has usually more calls than functions barra is expected to generate slightly larger binaries than the shadow stack but in return for stronger security guarantees provided as discussed below .
in our actual implementation the three instrumentation instructions lines in figure d shared at all calls to a function are factorized and moved to the beginning of the function.
.
rq3 strong security guarantees firstofall barrahasmadeaprogram sattacksurfacesubstantially smallerthantheshadowstack.duetothecfipropertyenforced by barra the attack surface is limited to the set of potential gadgetsfallinginto all ret addrs figure7 e .
fortheshadowstack however any gadget found in the program can be exploited.
in figure we demonstratevia a proof of concept attack that theshadowstackisalwaysvulnerablebutbarraissignificantly more secure in the presence of information leakage attacks.
weassume a bit platform with byte addresses.
in figure a we have implemented a multiple process echo server on ubuntu 264table the statistics for the c c spec benchmarks.
benchmark loc text funs callsinst overheads code size increases shadow stack barra shadow stack barra bzip2 .
.
.
.
gcc .
.
.
.
gobmk .
.
.
.
h264ref .
.
.
.
hmmer .
.
.
.
lbm .
.
.
.
libquantum .
.
.
.
mcf .
.
.
.
milc .
.
.
.
perlbench .
.
.
.
sjeng .
.
.
.
sphinx .
.
.
.
astar .
.
.
.
dealii .
.
.
.
namd .
.
.
.
omnetpp .
.
.
.
povray .
.
.
.
soplex .
.
.
.
xalan .
.
.
.
total average .
.
.
.
table read and write primitives by exploiting format strings in printf .
read write primitive format string example semantics absolute write primitive ku hn printf 65535u hn val cnt write two bytes 0xffff to cnt absolute read primitive s printf s str read the content at str relative read primitive 08x printf 08x 08x 08x 08x 08x read the first five anonymous arguments relative read primitive k u printf u read the 3rd anonymous argument lines1 whichreceivesamessagefromaclientandsendsthe message back to the client via a socket connection.
the code for creating socket connections has been elided.
the system call fork in line creates a child process and dup2 in line redirects the standardi ooftheservertothesocketconnection sothat ets in line will read a message from a remote client and printf in line4willsenditbacktotheclient.thesourcecodeinlines1 is the same as that in the motivating example in figure .
theattackerwillexploittheformatstringvulnerabilityin printf in line .
some read and write primitives at his her disposal are listedintable4.asillustratedinfigure10 b therearetwointernal pointersmaintainedin printf fmtinitiallypointstothebeginning of the format string line and pargis initialized to point to the first anonymous argument on the stack line .
for a variadicfunction like printf its number of anonymous arguments is determined by parsing the format string pointed by fmt lines .
all the format specifiers substringsstarting with are handled inthenormalmanner.inthespecialcasewhentheformalspecifier is 08x lines the anonymousargument pointedby parg isprintedasasequenceof8characters withleading0 saddedifnecessary .
afterwards pargis made to point to next anonymous argument.onceanattackerhascontrolledtheformatstring the attacker can inspect the content in the call stack by printing some anonymous arguments never passed explicitly to printf .
letusexplainfirsthowthisechoserver protectedbytheshadow stack will be smashed by a formal string attack launched fromprintf in line .
we then discuss briefly why barra provides significantly stronger security guarantees under the same attack.
.
.
attacking the traditional shadow stack.
in figure c a shadow stack hardened echo server server ssis listening on port .
due to some information disclose attacks by experiment ing with different probing format strings sent to the server the attackerhassucceededinobtainingthefollowingvaluableinformationabouttheechoserver thereturnaddressof read and echo is 0x08048ea7 stored at 0xffc2c7cc in the call stack and also at0xfec2c7d0 in the shadow stack the c library function system resides at 0xf7e26da0 and the string bin sh starts at 0xf7f47a0b.
the attacker is now in action.
in figure e the attacker sends a packet that contains a malicious format string to server ss.
for 265table barra s three in one approach for protecting return addresses.
mechanism strengths weaknesses shadow stack reducing buffer overflow attacks vulnerable to information leakage attacks control flow integrity backward reducing available rop gadgets still permitting illegal return addresses runtime rerandomization concrete alleviating information leakage attacks problematic pointer tracking barra abstract all the above but without pointer tracking probabilistic protection clarity we have split it into multiple lines lines .
the objective asindicatedintheinlinecomments lines45 isto overwrite the return address of read and echo in the shadow stack by 0xf7e26da0 the address of system as shown in figure g and restore the return address of read and echo as 0x08048ea7inthecallstack foragracefulexitwithoutleavingany trace andinject0xf7f47a0b theaddressof bin sh intothecall stack as the argument of system as shown in figure h .
whenread and echo returns system bin sh will be executed.
the format string vulnerability at printf in line on the serverhasresultedinacontrol flowhijack leadingtoaninteractive shell environment that the attacker can control remotely as showninlines55 56offigure10 e .inline55 theattackerentersa command date the reply in line from the server ssindicates that the attacker has succeeded in hijacking the remote server.
below we explain briefly how the format string vulnerability at printf inline4isexploitedtolaunchthisattack.inline3 ets reads the malicious format string prepared in lines by theattacker figure e into bufstored in the call stack depicted in figure g .
just before printf starts its execution its two internalpointers fmtandparg pointtothisformatstringandfirst anonymous argument on the call stack respectively.
as there may besomegapbetween bufandfmt dueto e.g.
registerspilling the attackermayhavetoexperimentwiththerightnumberof 08x s used in the malicious format string.
let us focus on describing how 0xf7e26da0 the address of system is written into the shadow shadow as a fake return addressforread and echo asillustratedinfigure10 g .theformat stringparserusedinternallyby printf parsesthefirst16 3regular charactersinlines48 whichareprinteddirectlyinlines35 .
then in line a sequence of five format specifiers 0x8 are encountered.
after having handled all these five formal specifiers in lines28 witheachprintedasasequenceof8chars pargwillbe liftedtopointto buf.atthispoint printf hasprinted16 characters after having processed lines .
next printf parses 27976u in line causing the current anonymous argumenton the call stack i.e.
0x41414141 to be printed as characters.
on encountering the first hn in line printf has printed i.e.
0x6da0characters whicharethelowertwo bytes oftheaddress ofthe function system i.e.
0xf7e26da0.this value will be written to the shadow stack at 0xfec2c7d0 pointed by thecurrentanonymousargumentonthecallstack.afterhaving handled the remaining string 35394u hn in line the higher twobytesoftheaddressof system .i.e.
0xf7e2willbewrittento theshadowstackat0xfec2c7d2.byparsinglines53 theremaining of the format string in a similar manner the return address of read and echo i.e.
0x08048ea7and the address of bin sh will be written into the call stack as shown in figure h .
.
.
attacking the burn after reading barra stack.
our barrahardened echo server server barra listening on port as shown in figure d will be significantly more secure.
the attacker can obviously attempt to smash the server in a similar way byexploitingaformatstringvulnerabilityasshowninfigure10 f .
according to line the attacker would like to replace the return id of read and echo currently stored in the barra stack by 0x000000cc i.e.
in line as per the comment in line sothat the corresponding gadget say gadget a in figure will be executed when read and echo returns.
in order to discover this gadget some information leakage attacksmustbemade.asillustratedearlierinfigure9 thiswilltrigger barra s rerandomize torerandomize bar mtablebychanging randomly into say defeating effectively the attack asshown in figure d .
in our evaluation bar mtableis of size m .
the chance for guessing a gadget id correctly is very low i.e.
m 220only.
due to the enforcement of cfi by barra system may no longer be used as a gadget as its address is not in bar mtable.
asshowninfigure7 e bar mtableofsizemcontainsonly n return addresses in its first nslots where m greaterorequalslantn.
all the other slots are mapped to a rop catcher.
the possibility for the attacker to be caught immediately by our rop catcher is given bym n m. if we are to forgo this instant attack catching capability as demonstrated in figure d the slots filled with our rop catcher can be omitted to save memory.
in this case only a large virtual rather than physical memory region needs to be allocated to bar mtableto achieve a high entropy.
only when part of the virtualmemoryregion containingnoreturnaddresses isaccessed attacked willweneedtoallocateitscorrespondingphysicalpages.
.
.
discussions.
therefore barra represents a three in one solution that combines naturally shadow stack control flow integrity and runtime rerandomization together to protect return addresses against control flow hijacks as summarized now in table .
intheabsenceofinformationleakage barraprovidesthesame levelofsecurityguaranteesasthetraditionalshadowstackmechanism in mitigating buffer overflow attacks.
in the presence of informationleakage however theshadowstackbecomesbypassable but barra will still provide strong security guarantees albeit probabilistically.
there are two reasons.
first barra restricts a gadgettostartonlywithanaddressmaintainedin all ret addrs figure e due to thecfi thus enforced.in contrast theshadow stackmechanismallowsagadgettostartfromanyaddress.second barra invokes immediately rerandomize figure to modify the mapping maintained in bar mtable on detecting an information leakage reducing significantly the chances for the attacker to hijack the control flow successfully as shown in figure .
u ubuntu echo .
client ss .
.
.
write 0xf7e26da0 to memory at 0xfec2c7d0 write 0x08048ea7 to memory at 0xffc2c7d0 write 0xf7f47a0b to memory at 0xffc2c7d4 x41 x41 x41 x41 xd0 xc7 xc2 xfe x41 x41 x41 x41 xd2 xc7 xc2 xfe x41 x41 x41 x41 xd0 xc7 xc2 xff x41 x41 x41 x41 xd2 xc7 xc2 xff x41 x41 x41 x41 xd4 xc7 xc2 xff x41 x41 x41 x41 xd6 xc7 xc2 xff 08x 08x 08x 08x 08x 27976u hn 35394u hn 38597u hn 31069u hn 29191u hn 32233u hn date56 fri aug e attack on the echo server hardened by the shadow stack01 void read and echo char buf gets buf 04printf buf void do request while read and echo void service int status pid t pid fork if pid child io redirection16 dup2 ... do request exit else if pid waitpid ... return ... ... 0xfec2c7d2 0x41414141 0xfec2c7d0 0x41414141... ... 0xfec2c7d2 0x41414141 0xfec2c7d0 0x41414141 08x 08x 08x 08x 08x 27976u hn 35394u hn ... int printf char fmt ... fmt return address ... pargfmt return address ... pargbuf 0xfec2c7d0 08x 08x 08x 08x 27976u hn 35394u hn 0xf7e26da00xf7e26da0 call stackshadow stack 08x0xf7e26da0 is the address of the c library function system 0xf7f47a0b 0x08048ea7 0x08048ea70xf7f47a0b 0x08048ea7 0x08048ea7 int system char command fake ret slot of system command bin sh call stacksaved ret 0xffc2c7d4 0xffc2c7d016 0x6da0 0xf7e2 g anal ysis of the malicious format strin g in e u ubuntu echo .
client b arra .
.
.
write 0x000000cc to memory at 0xfeb9a46c write 0x080493bf to memory at 0xffb9a470 write 0xf7e4ba0b to memory at 0xffb9a474 x41 x41 x41 x41 x6c xa4 xb9 xfe x41 x41 x41 x41 x6e xa4 xb9 xfe x41 x41 x41 x41 x70 xa4 xb9 xff x41 x41 x41 x41 x72 xa4 xb9 xff x41 x41 x41 x41 x74 xa4 xb9 xff x41 x41 x41 x41 x76 xa4 xb9 xff 08x 08x 08x 08x 08x 116u hn 65332u hn 37823u hn 29765u hn 45575u hn 15833u hn date the connection is closed by the remote server .
f attack on the echo server hardened by b arra h the call stack when hijacked in e system bin sh int printf char fmt ... char parg char fmt sizeof char format string parser while fmt if fmt parameter28 if is equal fmt 08x int value int parg output hex value parg sizeof int fmt strlen 08x else others ... else regular character output char fmt fmt a echo server b pseudo code of printf u ubuntu echo .
server b arra server is running ...... rop attack detected d echo server hardened by b arra barra c echo server hardened by the shadow stack u ubuntu echo .
server ss server is running ...... 0xffc2c7cc ret slot of read and echo figure echo server hardened by barra and shadow stack.
267tolauncharopattackbyexploitingavulnerability theattacker needs to chain together a number of rop gadgets in the same payload and then replace a legitimate return id with the returnid of the first gadget in the chain as illustrated in figure .
withruntime rerandomization in barra the probability of guessing suchacorrectreturnidtouseisextremelylow.ifweuse m 8mb of memory on a bit platform to store bar mtablecontaining nreturnaddresses where m greatermuchn theattacker ssuccessratein guessing a correct return id to use as a gadget is only1 m .
barra applies runtime rerandomization by using the hooked input outputfunctionsasbefore .byavoidingexpensivepointer trackingasinruntimeaslr barracanstartanewround ofitsmicrosecond levelrerandomizationatanyothertimewhen needed.
to further reduce memory accesses in the instrumented code adedicatedregistercanbeallocatedforstoring bar randval.
.
limitations to enforce burn after reading and consequently provide stronger securityguaranteesthantheshadowstack barraneedstoconsumeextramemoryformaintaining bar mtabletoachieveahigh entropy figure e .
with 8mb on a bit platform we can reduce an attacker s success rate to1 as discussed above .
in addition barra also generates slightly larger binaries .
one policy for handling a multiple threaded program is to let every thread maintain a separate barra stack protected by a thread localversion of bar randval say inthe threadlocal storage fs bar randval tpoff on x86 .
while avoiding the crossthread synchronization issue this simple solution does not guarantee that all thread specific versions of bar randval are updated simultaneously leadingtopotentialcross threadstack smashing attacks .
a more secure solution would be to maintain only onesinglebar randvalforallthethreadsandmodifythethread dispatchertosuspendallthethreadsinthecurrentprocesswhen runtime rerandomization occurs.
we leave this to our future work.
currently we do not consider just in time code generation which can already be handled by some cfi techniques .
in thiscase barracanbeextendedtoinstrumentthedynamically generated code and update bar mtableappropriately.
related work low levellanguages like c c trade securityguarantees forperformance advantages.
the absence of bounds checking leads to memory errors in c c programs.
stackguard inserts a canary inevery stack frame andthen tests whetherthe canary on thecallstackhasbeencorruptedornotwhenthecorresponding function returns.
despite its lightweightness stackguard is not secure as the attacker is still able to circumvent it by exploiting some information disclosure vulnerabilities .
safestack as a part of the code pointer integrity project takesadvantageofprogramtransformationandinformationhiding tohideallthecodepointersofaprograminthesaferegion.the memory errors arising in the unsafe region do not compromise the safety guarantees made for safe region.
thus the integrity of code pointerscanbeguaranteed.however thesaferegionforaprogram is too large and thus vulnerable to side channel attacks .softbound enforces spatial memory safety for c programs.
by applying compile time program transformations softbound worksbymaintainingandreasoningaboutthemetadata baseaddresses and bounds for all the pointers in the program.
later softboundisaugmentedorthogonallytoenforcealsotemporalmemory safety .
to provide both types of memory safety however the combined instrumentation overhead is as high as .
aslr randomizesthebaseaddressesofcodeanddatasections of a program at load time.
in particular asr performs fine grained rerandomization for the minix microkernel.
ccfir appliescoarse grainedcfiandrandomizationforbinary executables but was shown later to be bypassable .
by exploiting information disclosure attacks jit code reuse reduces the effectiveness of code randomization .
protection mechanisms that use secret memory regions to hide infor mation such as cpi and aslr guard can also be bypassed .
in readactor all the code sections are hidden but the code pointers in data sections are still exploitable.
runtime rerandomization that operates on a concrete address space requires expensive and difficult pointer tracking in a program .
for complex c c programs existing pointer tracking techniques are inadequate in discovering all kinds of pointers reliably.
with the support of a customized compiler tasr which applies to c rather than c can rerandomize thecodesectionsofacpr ogramatruntime butitdoesnotwork properly when function pointers are treated as data pointers.
runtimeaslr has reduced its false positive rate to a negligible level but still too costly as discussed in section .
.
in their seminal research on control flow integrity cfi abadi et al observed that the control flow graph of a program is an inherent property of the program and all runtime programexecution paths should be constrained to be within the controlflow graph.
their work has spurred a great deal of research onenforcingcfi andavoidingtype confusing errors inthepastdecadeorso.tothebestofourknowledge cfi hasbeenappliedtoprotectforwardedges i.e.
indirectcalls viafunctionpointerandvirtualcalls insteadofbackwardedges i.e.
return addresses .
the research on forward edge cfi assumes usually that the shadow stack mechanism is used for enforcing backward edge cfi .
however the shadow stack is vulnerable to information leakage attacks as demonstrated in our proof of concept attack section .
.
in contrast barra provides a significantly more secure mechanism for protecting return addresses byenforcingburn after readingvialightweightruntime rerandomization on abstract return addresses.
conclusion in this paper we introduce a novel shadow stack mechanism barra that applies continuous lightweight runtime rerandom ization whenever some information leaks are detected therebyenforcing the burn after reading property and making the tradi tional shadow mechanism significantly more secure.
enforcing burn after readingisessentialforbarratomitigateinformation disclosurevulnerabilitieseffectively.performinglightweightruntime rerandomization on abstract return addresses with one level of indirection is the new enabling technology proposed here.
268references mart n abadi mihai budiu ulfar erlingsson and jay ligatti.
.
control flow integrity.
in proceedings of the 12th acm sigsac conference on computer and communications security.
acm new york ny usa .
erick bauman zhiqiang lin and kevin w hamlen.
.
superset disassembly statically rewriting x86 binaries without heuristics.
in network and distributed system security symposium.
sandeep bhatkar r. sekar and daniel c. duvarney.
.
efficient techniques forcomprehensiveprotectionfrommemoryerrorexploits.in proceedingsofthe 14thconferenceonusenixsecuritysymposium.usenixassociation berkeley ca usa .
david bigelow thomas hobson robert rudd william streilein and hamed okhravi.
.
timely rerandomization for mitigating memory disclosures.
in proceedingsofthe22ndacmsigsacconferenceoncomputerandcommunications security.
acm new york ny usa .
tyler bletsch xuxian jiang vince w. freeh and zhenkai liang.
.
jumporiented programming a new class of code reuse attack.
in proceedings of the 6th acm symposium on information computer and communications security.
acm new york ny usa .
nathan burow xinpingzhang and mathias payer.
.
sok shining lighton shadowstacks.in proceedingsofthe40thieeesymposiumonsecurityandprivacy.
.
nicolascarlini antoniobarresi mathiaspayer davidwagner andthomasr.
gross.
.
control flowbending ontheeffectivenessofcontrol flowintegrity.
inproceedings of the 24th usenix conference on security symposium.
usenix association berkeley ca usa .
stephen checkoway lucas davi alexandra dmitrienko ahmad reza sadeghi hovav shacham and marcel winandy.
.
return oriented programming without returns.
in proceedings of the 17th acm conference on computer and communications security.
acm new york ny usa .
karlchenanddavidwagner.
.
large scaleanalysisofformatstringvulnerabilitiesindebianlinux.in proceedingsofthe2007workshoponprogramming languages and analysis for security.
acm new york ny usa .
james clause ioannis doudalis alessandro orso and milos prvulovic.
.
effective memory protection using dynamic tainting.
in proceedings of the 22nd ieee acm international conference on automated software engineering.
acm new york ny usa .
crispin cowan calton pu dave maier heather hintony jonathan walpole peat bakke steve beattie aaron grier perry wagle and qian zhang.
.
stackguard automaticadaptivedetectionandpreventionofbuffer overflow attacks.
in proceedings of the 7th conference on usenix security symposium.
usenix association berkeley ca usa .
stephen crane christopher liebchen andrei homescu lucas davi per larsen ahmad reza sadeghi stefan brunthaler and michael franz.
.
readactor practicalcoderandomizationresilienttomemorydisclosure.in proceedingsof the ieee symposium on security and privacy.
.
cve.
.
common vulnerabilities and exposures.
accessed jan .
michael dalton hari kannan and christos kozyrakis.
.
raksha a flexible informationflowarchitectureforsoftwaresecurity.in proceedingsofthe34th annual international symposium on computer architecture.
acm new york ny usa .
lucas davi ahmad reza sadeghi daniel lehmann and fabian monrose.
.
stitching the gadgets on the ineffectiveness of coarse grained control flowintegrity protection.
in proceedings of the 23rd usenix conference on security symposium.
usenix association berkeley ca usa .
i.evans s.fingeret j.gonzalez u.otgonbaatar t.tang h.shrobe s.sidirogloudouskos m.rinard andh.okhravi.
.
missingthepoint er ontheeffectiveness of code pointer integrity.
in proceedings of the ieee symposium on security and privacy.
ieee san jose ca usa .
xiaokang fan yulei sui xiangke liao and jingling xue.
.
boosting the precisionofvirtualcallintegrityprotectionwithpartialpointeranalysisforc .
inproceedings of the 26th acm sigsoft international symposium on software testing and analysis santa barbara ca usa july .
.
cristiano giuffrida anton kuijsten and andrew s. tanenbaum.
.
enhanced operatingsystemsecuritythroughefficientandfine grainedaddressspace randomization.
in proceedings of the 21st usenix conference on security symposium.
usenix association berkeley ca usa .
enesgoktas angelosoikonomopoulos robertgawlik benjaminkollenda elias athanasopoulos georgios portokalidis cristiano giuffrida and herbert bos.
.
bypassing clang s safestack for fun and profit.
in black hat europe.
salvatoreguarnieriandvbenjaminlivshits.
.
gatekeeper mostlystatic enforcement of security and reliability policies for javascript code.. in usenix security symposium vol.
.
.
j. hiser a. nguyen tuong m. co m. hall and j. w. davidson.
.
ilr where d my gadgets go?.
in proceedings of the ieee symposium on security and privacy.
ieee san jose ca usa .
hong hu chenxiong qian carter yagemann simon pak ho chung william r. harris taesookim andwenkelee.
.enforcinguniquecodetargetpropertyfor control flow integrity.
in proceedings of the acm sigsac conference on computer and communications security.
acm new york ny usa .
yeongjinjang sangholee andtaesookim.
.
breakingkerneladdressspace layout randomization with intel tsx.
in proceedings of the acm sigsac conference on computer and communications security.
.
yuseokjeon priyambiswas scottcarr byoungyounglee andmathiaspayer.
.
hextype efficient detection of type confusion errors for c .
in proceedingsofthe2017acmsigsacconferenceoncomputerandcommunications security.
acm .
gauravs.kc angelosd.keromytis andvassilisprevelakis.
.
countering code injection attacks with instruction set randomization.
in proceedings of the 10th acm conference on computer and communications security.
acm new york ny usa .
chongkyungkil jinsukjun christopherbookholt junxu andpengning.
.
addressspacelayoutpermutation aslp towardsfine grainedrandomization of commodity software.
in proceedings of the 22nd annual computer security applications conference.
ieee san jose ca usa .
volodymyr kuznetsov l szl szekeres mathias payer george candea r. sekar and dawn song.
.
code pointer integrity.
in proceedings of the 11th usenix conferenceonoperatingsystemsdesignandimplementation.usenixassociation berkeley ca usa .
kangjielu wenkelee stefann rnberger andmichaelbackes.
.
howto makeaslrwintheclonewars runtimere randomization.in networkand distributed system security symposium.
kangjie lu chengyu song byoungyoung lee simon p chung taesoo kim and wenkelee.
.
aslr guard stoppingaddressspaceleakageforcodereuse attacks.
in proceedings of the 22nd acm sigsac conference on computer and communications security.
.
chi keungluk robertcohn robertmuth harishpatil arturklauser geoff lowney steven wallace vijay janapa reddi and kim hazelwood.
.
pin building customized program analysis tools with dynamic instrumentation.
inproceedingsofthe2005acmsigplan conferenceonprogramminglanguage design and implementation.
acm new york ny usa .
microsoft.
.
data execution prevention.
cution prev ention.
accessed jan .
kenneth miller yonghwi kwon yi sun zhuo zhang xiangyu zhang andzhiqiang lin.
.
probabilistic disassembly.
in proceedings of the 41st international conference on software engineering.
ieee press piscataway nj usa .
santosh nagarakatte jianzhou zhao milo m.k.
martin and steve zdancewic.
.
softbound highly compatible and complete spatial memory safety for c. inproceedingsofthe30thacmsigplanconferenceonprogramminglanguage design and implementation.
acm new york ny usa .
santosh nagarakatte jianzhou zhao milo mk martin and steve zdancewic.
.
cets compiler enforced temporal safety for c. in acm sigplan notices vol.
.
acm new york ny usa .
nicholasnethercoteandjulianseward.
.
valgrind aframeworkforheavyweightdynamicbinaryinstrumentation.in proceedingsofthe28thacmsigplan conference on programming language design and implementation.
.
ben niu and gang tan.
.
rockjit securing just in time compilation usingmodularcontrol flowintegrity.in proceedingsofthe2014acmsigsac conferenceoncomputerandcommunicationssecurity.acm newyork ny usa .
benniuandgangtan.
.
per inputcontrol flowintegrity.in proceedings of the 22ndacm sigsac conference oncomputerand communications security .
acm new york ny usa .
angelos oikonomopoulos elias athanasopoulos herbert bos and cristianogiuffrida.
.
poking holes in information hiding.
in proceedings of the 25th usenixconferenceonsecuritysymposium.usenixassociation berkeley ca usa .
kaan onarlioglu leyla bilge andrea lanzi davide balzarotti and engin kirda.
.
g free defeating return oriented programming through gadget less binaries.in proceedingsofthe26thannualcomputersecurityapplicationsconference.
ieee san jose ca usa .
alephone.
.
smashingthestackforfunandprofit.
issues .html.
accessed jan .
tristan ravitch.
.
whole program llvm.
whole program llvm.
accessed jan .
gera riq.
.
advances in format string exploitation.
issues .html.
accessed jan .
julian seward and nicholas nethercote.
.
using valgrind to detect undefined value errors with bit precision.
in proceedings of the annual conference on usenixannualtechnicalconference.usenixassociation berkeley ca usa .
hovav shacham.
.
the geometry of innocent flesh on the bone return into libc without function calls on the x86 .
in proceedings of the 14th acm conference on computer and communications security.
.
kevinz.snow fabianmonrose lucasdavi alexandradmitrienko christopher liebchen andahmad reza sadeghi.
.
just in timecode reuse on theeffectivenessoffine grainedaddressspacelayoutrandomization.in proceedings of the ieee symposium on security and privacy.
ieee san jose ca usa .
yuleisuiandjinglingxue.
.svf interproceduralstaticvalue flowanalysisin llvm.in proceedingsofthe25thinternationalconferenceoncompilerconstruction.
acm new york ny usa .
yuleisui dingye yusu andjinglingxue.
.
eliminatingredundantbounds checks in dynamic buffer overflow detection using weakest preconditions.
ieee trans.
reliability .
laszloszekeres mathiaspayer taowei anddawnsong.
.
sok eternalwar inmemory.in proceedingsofthe2013ieeesymposiumonsecurityandprivacy.
ieee san jose ca usa .
the pax team.
.
address space layout randomization.
grsecurity.net docs aslr.txt.
accessed jan .
caroline tice tom roeder peter collingbourne stephen checkoway lfar erlingsson luis lozano and geoff pike.
.
enforcing forward edge controlflow integrity in gcc llvm.
in proceedings of the 23rd usenix conference on security symposium.
usenix association berkeley ca usa .
richardwartell vishwathmohan kevinw.hamlen andzhiqianglin.
.
bi narystirring self randomizinginstructionaddressesoflegacyx86binarycode.
inproceedings of the acm conference on computer and communications security.
acm new york ny usa .
xiaoyang xu masoud ghaffarinia wenhao wang kevin w hamlen andzhiqiang lin.
.
confirm evaluating compatibility and relevance ofcontrol flow integrity protections for modern software.
in proceedings of the 28th conference on usenix security symposium .
.
ding ye yu su yulei sui and jingling xue.
.
wpbound enforcing spatial memorysafetyefficientlyatruntimewithweakestpreconditions.in proceedings of the 25th international symposium on software reliability engineering.
.
chao zhang chengyu song kevin zhijie chen zhaofeng chen and dawn song.
.
vtint protecting virtual function tables integrity.
in network and distributed system security symposium.
chao zhang dawn song scott a carr mathias payer tongxin li yu ding and chengyu song.
.
vtrust regaining trust on virtual calls.
in network and distributed system security symposium.
chaozhang taowei zhaofengchen leiduan laszloszekeres stephenmccamant dawnsong andweizou.
.
practicalcontrolflowintegrityand randomizationforbinaryexecutables.in proceedingsofthe2013ieeesymposium onsecurityandprivacy.ieeecomputersociety washington dc usa .
ruizhao chuanyue andqingyi.
.
automaticdetectionofinformationleakage vulnerabilities in browser extensions.
in proceedings of the 24th international conference on world wide web.
.
changwei zou yulei sui hua yan and jingling xue.
.
tcd staticallydetecting type confusion errors in c programs.
in proceedings of the 30th international symposium on software reliability engineering.
.