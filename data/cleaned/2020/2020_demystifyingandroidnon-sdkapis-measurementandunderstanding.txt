demystifying android non sdk apis measurement and understandingshishuai yang1 rui li1 jiongyi chen3 wenrui diao1 letter and shanqing guo1 21school of cyber science and technology shandong university shishuai leiry mail.sdu.edu.cn diaowenrui guoshanqing sdu.edu.cn 2key laboratory of cryptologic technology and information security of ministry of education shandong university3national university of defense technology jiongyi chen .comabstractduring the android app development the sdk is essential whichprovides rich apis to facilitate the implementations of functional ities.
however in the android framework there still exist plentyof non sdk apis that are not well documented.
these non sdkapis can be invoked through unconventional ways such as javare f lection.
on the other hand these apis are not stable and maybe changed or even removed in future android versions providingno guarantee for compatibility.
from android api level google began to strictly restrict the use of non sdk apis andthe corresponding checking mechanism has been integrated intothe android os.in this work we systematically study the use and designof android non sdk apis.
notably we propose four researchquestions covering the restriction mechanism the present usagestatus malicious usage and the api list evolution.
to answer thesequestions we conducted a large scale measurement based on over200k apps and the source code of three recent android versions.as a result a series of exciting and valuable ndings are obtained.for example google s restriction is not strong enough and canstill be bypassed.
besides app developers use only a tiny part ofnon sdk apis.
our work provides new knowledge to the researchcommunity and can help researchers improve the android apidesigns.ccs concepts software and its engineering software reliability.keywordsandroid non sdk apis api design and evolutionacm reference format shishuai yang rui li jiongyi chen wenrui diao and shanqing guo.
.demystifying android non sdk apis measurement and understanding.in44th international conference on software engineering icse may21 pittsburgh pa usa.acm new york ny usa pages.
to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor pro t or commercial advantage and that copies bear this notice and the full citationon the rst page.
copyrights for components of this work owned by others than theauthor s must be honored.
abstracting with credit is permitted.
to copy otherwise orrepublish to post on servers or to redistribute to lists requires prior speci c permissionand or a fee.
request permissions from permissions acm.org.icse may pittsburgh pa usa copyright held by the owner author s .
publication rights licensed to acm.acm isbn ... .
introductionas the most popular mobile operating system android occupiesmore than of the global smartphone market share .
at theend of close to .
million apps are available for users todownload in google play .
such a large number of apps bene tfrom the android sdk provided by google.
developers can quicklybuild their apps through the rich apis provided by the sdk andthen distribute them on the app market.during the app development the apis invoked by developers arederived from theandroid.jarlibrary.
on the other hand at the appexecution stage the apis referred by apps are dynamically linkedto the implementations of theframework.jarlibrary a runtimelibrary located in the android os.
though bothandroid.jarandframework.jarare constructed based on the source code ofaosp android open source project a large proportion of apis inframework.jardo not exist inandroid.jar callednon sdk apis.non sdk apis are not documented in the android frameworkpackage index and they could be internal apis restricted apis or hidden apis see section .
for details .
these apis are not stableand may be changed or even disappear in future android versions providing no guarantee for compatibility.
therefore by design non sdk apis cannot be invoked by developers directly.
in practice thewell known programming tricks for accessing them are using thejava re f lection mechanism or replacing the o cialandroid.jarwith a custom one containing the non sdk apis.
inevitably usingthe unstable non sdk apis will cause compatibility issues like appcrashes and unexpected behaviors .obviously the widespread use of non sdk apis is not a goodphenomenon.
therefore from android api level googlebegan to strictly restrict the invocations of non sdk apis andencouraged developers to use the public apis provided by thesdk to build apps .
on the os level a new api invocationchecking mechanism was introduced and restricted non sdk apilists were provided for reference o cially.
the current solutiontries to push app developers to drop non sdk apis gradually andthe ideal situation is blocking the use of any non sdk apis in apps.however such an ultimate aim cannot be easily reached and thereis still a lack of up to date knowledge on the evolution of androidnon sdk apis.
their usage in the wild and the e ectiveness ofgoogle s restriction have not been systematically evaluated.our work.in this work we systematically investigate howdevelopers use non sdk apis and the evolution of non sdk apis inthe android framework.
notably we seek to answer the followingresearch questions ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
usage of developers rq1 can google s restriction on non sdk apis be bypassed?
rq2 what is the present status of using non sdk apis in apps?malware vs. benign apps rq3 what are the differences in using non sdk apis betweenmalicious and benign apps?evolution of non sdk apis rq4 how did non sdk apis evolve in the android framework?to answer these proposed research questions we collected226 apps from multiple app markets to analyze how and whydevelopers use non sdk apis.
we also constructed a malwaredataset based on virustotal to analyze the di erences in usingnon sdk apis between malicious and benign apps.
in addition through analyzing the source code of recent android versions and we studied the evolution of non sdk apis in the androidframework.
also to facilitate the measurement we built a series oftargeted lightweight analysis tools such asveridex for scanningnon sdk apis used in apps.contributions.here we list the main contributions of this paper large scale measurement.based on over 200k apk lesand the source code of three recent android versions weconducted a multi dimension large scale measurement onthe android non sdk apis in the wild.
systematic study.we systematically studied the androidnon sdk apis from the aspects of developers malware andsystem design.
in particular we proposed four signi cantresearch questions and answered them with enough support ing evidence.
here we give the corresponding short answers.
the restriction of google still can be bypassed through thedouble re f lection and call stack breaking techniques.
non sdk apis are widely used in apps.
the usage purposeis to achieve some app features not supported by the sdk.
non sdk apis have been abused by malicious apps forexample to dynamically load malicious code.
the adjustment of non sdk apis is mainly for securityconcerns and f ine grained functionality control.both os designers and the software engineering research com munity can bene t from this work.
for os designers google canfollow our guidelines to reformulate the policy of restricting accessto non sdk apis and change risky apis with secure alternativeones.
for the research community we provided multi dimensionlarge scale measurement data on the android non sdk apis.
itre f lects how app developers use apis and the analysis results couldhelp design usable apis in the future.roadmap.the rest of this paper is organized as follows.
section 2provides the necessary background information to allow readers tounderstand this work better.
section presents the experimentalsetup of this work.
section details our empirical research toanswer the above research questions.
section discusses somemitigation measures to reduce the use of non sdk apis and thelimitation of this work.
section introduces related work andsection concludes this work.
backgroundin this section we provide the necessary background of androidapis and focus on non sdk apis.
.
android apisapi is short for application programming interface which is apre de ned function.
developers only need to call the correspond ing api according to the convention de ned by the interfacewithout accessing the source code or understanding the detailsof the internal working mechanism.
android apis provide de velopers with the ability to access system resources of androiddevices.
for example they can access external storage through thegetexternalstoragedirectory api.
the collection of theseapis constitutes the sdk.
the android sdk is almost completelyclosed and interacts with developers through apis.when developing apps the apis used by app developers areoriginated fromandroid.jar1which is a library in the devel opment environment.
corresponding toandroid.jarused fordevelopment there isframework.jar2 a runtime library in theandroid system that contains more apis including non sdk apis.the relationship betweenandroid.jarandframework.jarisillustrated in figure .
non sdk apis exist widely in the sourcecode usually in the following three forms as shown in listing .internal apis are not planned to be open to the outside world andare only for internal use by the system.
restricted and hidden apisare to prevent developers from using some unstable apis.
theseapis may be removed from the android framework or becomepublic apis in a speci c android version.
internal api2packagecom.android.internal.telephony.cdma 3public classsmsmessageextendssmsmessagebase unsupportedappusage5public staticsmsmessage createfrompdu byte pdu restricted api8public classactivityextendscontextthemewrapper 9private voidinitwindowdecoractionbar hidden api12public classtelephonymanager !
!returns a constant indicating the stateof the card apps on the default sim card.
!
hide!
systemapi16publicsimstateintgetsimapplicationstate listing example of non sdk apis.
internal apis.these apis are usually in thecom.android.internalpackage.
the source code of all classes under thispackage is invisible and only can be used by system apps.1location sdk dir platforms android x android.jar xis the api level.2location system framework framework.jar648authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
apis in android.jarnon sdk apisframework.jardevelopment environmentruntime environment figure relationship ofandroid.jarandframework.jar.this package provides the core functions of the androidsystem and can be used to access some sensitive resources.
restricted apis.these apis are labeled by the java quali ersprivateordefault.
hidden apis.these apis are usually clearly marked with hidein the java doc.as the android os evolves and new versions are released eachversion is assigned a unique integer identi er called the api level.each android device runs at exactly one api level which preciselyindicates the version of the api set that can be invoked by theapps running on the device.
when an app is built it contains thefollowing api level information minsdkversion the minimum api level required for theandroid device to run this app.
if the api level of the device is lowerthan the value speci ed byminsdkversion t h ed e v i c ew i l lp r e v e n tthe user from installing this app.
targetsdkversion the api level of the android deviceat which this app expects to run.
this information indicatesthat the app developer has tested this app against the targetapi level and the system should not enable any compatibilitybehaviors to maintain this app s forward compatibility with thetarget version .
.
restricted non sdk apisaccess method.non sdk apis cannot be accessed directlythrough the sdk provided by google.
before android whendeveloping an app the non sdk apis could be accessed throughthe following three ways sdk replacement.developers can use a customandroid.jar containing the non sdk apis implementations to replace thedefaultandroid.jar.
java reflection.through java re f lection developers cancall the methods and properties of any object at runtime evenif these methods and properties are labeled by the java quali erprivate.
java native interface jni .in the java layer developers cancall the native code by de ning jni functions.
further they canaccess sdk and non sdk apis through speci c apis provided byndk in the native code .however in android google realized the problem of refer encing a large number of non sdk apis in apps and began torestrict the use of non sdk apis .
the purpose of limitingthe use of non sdk interfaces is mainly to improve apps stabilityfurther prevent apps from crashing during runtime and improvethe experience of users and developers .table apk dataset.typesourceamount total amount f iltered benign appsapkpure f droid anzhi baidu huawei xiaomi ... 493malwarevirustotal10 029non sdk api lists.to minimize the impact of non sdk apisrestrictions on development work f low google classi ed all apisin the android framework into four di erent lists and targeteddi erent lists to enforce di erent restrictions as follows blacklist blocklist.
regardless of thetargetsdkversionof the app once the app tries to access the apis in this list aruntime crash will be triggered.
greylist max x conditionally blocked.
the apis in this listare usually expressed in the form ofgreylist max x andxis the code name of android.
for example greylist max pmeans that if thetargetsdkversionof the app is no morethan android p i.e.
api level the app can still accessthe non sdk apis.
however if thetargetsdkversionisgreater than android p a runtime crash will occur when theapp accesses the non sdk apis.
greylist unsupported.
the apis in this list are currentlynot restricted and can still be used in apps.
whitelist sdk apis.
the apis in this list can be freelyused and are now supported as part of the o cially docu mented android framework.the apis in the rst three lists i.e.
non sdk apis are noto cially supported and may be changed at any time without notice.
methodology and datasetto answer the proposed research questions in this section weillustrate our measurement approach and constructed datasets.
.
methodologyas illustrated in figure on a high level our measurement containsthree main steps as follows apk dataset construction.first we constructed the apkdataset used in the study including benign apps and mali cious ones.
api list generation.based on the source code of aosp webuilt an automated app scannerveridex and generatedthe non sdk api lists.
multi dimension analysis.to answer the proposed researchquestions we designed multiple kinds of targeted analysisbased on the data constructed in the previous steps.
.
app dataset constructionin this work the dataset used in our research is divided into twotypes as shown in table .
benign apps.since google play did not provide the appbulk downloading apis anymore we selected popularapp markets including 9apps anzhi apkpure baidu downloadpcapk f droid gfan huawei laptoppcapk 649authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
apk dataset ...apk filtering apk analysis testrq1 rq4rq2rq3source code veridex app scanner combined analysisdifferential analysisnon sdk apis in frameworkfigure overview measurement f low.lenovo leplay leyou flyme pc6 yingyongbao uptodown and xiaomi.
after de duplication a total of apps wereobtained.
malware.
we requested access to the virustotal dataset and obtained a total of malicious samples.
virustotalclaims that their provided malicious apps have been markedas malicious by at least anti virus engines.since we focus on the change before after the launch ofgoogle s restriction on non sdk apis from api level we ltered the apps withtargetsdkversion 27and later versions.
the lter implementation is based on androguard .
note that we didnot lter malicious apps because most of theirtargetsdkversionattributes are less than28.
.
api list generationveridex .starting from android in order to help developersdetect non sdk apis used in their apps google provided astatic detection tool veridex .
this tool can be built bycompiling the source code of aosp.
to suit apps with di erenttargetsdkversionattributes we built three versions ofveridexbased on the source code of android and correspondingto api level and .in addition we integrated these three versions ofveridexintoone tool and added the support of parallel execution for large scale app scanning calledveridex .
we utilized this tool to scanapps to obtain the used non sdk apis.
to further re f lect the realintention of developers using non sdk apis we excluded the non sdk apis in the o cial libraries used by apps.
these librariesare support libraries required to run apps usually containingspeci c characteristics such as beginning withcom.google.!
com.android.!
androidx.!
andandroid.
!.non sdk api lists.based on the source code of aosp throughexecuting the corresponding source code compiling command3 w eobtained all non sdk apis corresponding to android and api level and .
for android api level the sourcecode is currently not available but google provides independentnon sdk api lists for the android developer preview version.3command m out soong hiddenapi hiddenapi flags.csv3.
multi dimension analysisto answer the proposed four research questions we designedtargeted analysis solutions.
to rq1 we tested various bypass ap proaches to validate their e ectiveness and explored the restrictionimplementation.
to rq the analysis is mainly based on comparingdi erent versions of non sdk lists.
to rq and we combinedmultiple data sources to measure the status.
the detailed analysismethods are given by research questions in section .
note that datameasurement is only a part of our study and we also investigatedthe fundamental causes behind these statistics results.
findingsin this section we summarize our empirical research results on theresearch questions proposed in section .
lightbulbrq1.
can google s restriction on non sdk apis bebypassed?as mentioned in section .
there exist some approaches sdkreplacement java re f lection and jni to access the non sdk apis.through developing multiple android apps on google pixel 2with android and we tested the e ectiveness of theseapproaches before after google launching the restriction.current restriction.based on our tests the execution results ofthe mentioned bypassing methods on theblacklistare listed intable .
we can nd that before google launching the restriction these approaches can achieve access successfully.
the di erence isthat only the java re f lection approach can access restricted apis theprivateanddefaultapis because such an approach can accessany object.
after google launching the restriction all approachescannot work and will trigger a runtime crash.the execution results on thegreylistand thegreylist max xare consistent with google s claim as mentioned in section .
.that is there is no accessing restriction to the apis on thegreylist.when we tried to access the apis on thegreylist max x ifthetargetsdkversionof the app is less than or equal to therestricted level these apis can be accessed successfully.
whenthetargetsdkversionof the app is greater than the restrictedlevel it will cause a runtime crash.principle of restriction.it seems that google s strategy ofrestricting non sdk apis works well in android and later versions.we further investigated the implementation of such a restriction.
it650authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table the effectiveness of accessing non sdk apis on theblacklist.approachesbefore google launching restrictionafter google launching restrictioninternal apisrestricted apishidden apisinternal apisrestricted apishidden apisnormal invocation sdk replacement java re f lection java native interface is deployed on the android runtime level.
inside the art virtualmachine each api has a set ofaccess flags f lag bits to expressthe attributes of the api .
for example settingaccess flagsas0x2is to indicate that the api isprivate.
there are some reservedbits inaccess flags which were not fully utilized before android9.
in android these reserved bits can be used to identify which listeach api belongs.
when an api call triggered by an app at runtimeenters the art virtual machine the art virtual machine will rstidentify the caller s identity.
if the api call is made by system apps it will not be restricted.
if not this api s restriction level i.e.
thelist that this api belongs to will be identi ed according to the valueofaccess flagsto restrict non sdk api calls.in the above restriction the art virtual machine performs twochecks to prevent non sdk api invocations check the caller sidentity system or third party app .
check the restriction levelof the invoked api.bypass restriction.since the execution logic of google s re striction needs to check the api caller s identity it can still bebypassed by destroying the integrity of the caller s identity.there are two ways for developers to achieve this goal double reflection.this is a java way.
using the systemclass to re f lect we can change the caller s identity to be thesystem .
we rst leverage re f lection to obtain the re f lectionapi called the meta re f lection api.
this meta re f lection api isloaded by the system class.
then we use this meta re f lectionapi to re f lect the call to the non sdk api.
at this time thecall to the non sdk api will be considered a system call.
inaddition there is asethiddenapiexemptions api a non sdkapi under thevmruntimeclass that can be used to exempt a non sdk api from the restriction.
combining the double re f lectionwithsethiddenapiexemptions all non sdk apis can still beaccessed through the previous approaches i.e.
sdk replacement java re f lection and jni .
call stack breaking.this is a jni way.
by breaking the callstack of the api the art virtual machine cannot identify thecaller .
speci cally through creating a new native thread andthen attaching the new thread to the art virtual machine thisnew thread will be on a new call stack.
therefore within this newthread when invoking an api this api call will occur within thenew call stack and the art virtual machine will recognize thatthis call is made by a system component not a third party app.rq1 findingin android and later versions app developers can still usedouble re f lection and call stack breaking to bypass google srestriction and access non sdk apis.table statistics of apps using non sdk apis.target sdkversiontotal appsapps usingnon sdk apispercentage27 android .
.
android .
android .
android .
table statistics of average non sdk apis usage per app.target sdkversionapps usingnon sdk apisused non sdkapis amountaverageusage app27 android .
.
android .
android .
android .
lightbulbrq2.
what is the present status of using non sdkapis in apps?next we measured the usage of non sdk apis in the wild.
asmentioned in section .
we obtained the usage of non sdk apis inapps utilizingveridex .
through comparing the usage in di erentapp versions we analyzed the reaction of developers to google srestriction.
note that since there is no o cial non sdk apis listsfor api level before google launching the restriction we usedveridex con gured for the api level to analyze apps withtargetsdkversion .overall statistics.as listed in table using non sdk apis isquite common with over of apps.
also the usage percentagesin apps with di erenttargetsdkversionare stable from .
to89.
with a slight increase.
table re f lects that to a single app more and more non sdk apis are used a f ter google launchingthe restriction.
on average the apps withtargetsdkversion27use .
non sdk apis and this number increases to .
ontargetsdkversion .to explore the causes behind the above statistics results weconducted reverse analysis on various apps especially thosewith multiple versions.
speci cally we decompiled them usingapktool and performed di erential analysis on their smali les.finally we discovered three main reasons with the evolution of the android os some apis used inapps were adjusted to non sdk api lists but developers did notreplace these apis used in their apps in time.
for example someapps end the call by using theendcall api.
this api is a publicapi in android and was moved to thegreylistin android .651authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
wdujhw6gn9huvlrq wdujhw6gn9huvlrq wdujhw6gn9huvlrq juh olvw juh olvw pd eodfnolvwfigure distribution of non sdk apis referenced by apps.table statistics of unique non sdk apis used in apps.target sdkversiontotal non sdkapis in listsunique usednon sdk apispercentage28 android .
android .
android .
some apps integrated third party libraries containing non sdk apis.
these libraries are updated with app updates whichmay introduce new non sdk apis.
for example the appoperaintegratesmintegral a third party library for advertising sdkaggregation.
its updated version fortargetsdkversion 29usesthegetbatterycapacity api a non sdk api that does notexist in its previous versions.
to increase the competitiveness of apps the developerprovides some unique functions through non sdk apis.
forexample some developers utilize the non sdk apis under thebatterystatshelperclass to monitor the battery usage of apps.usage by lists.next we investigated what types of non sdk apisare used by app developers.
we counted the number of non sdkapis referenced by apps on thegreylist greylist max x andblacklistwithtargetsdkversion and30 as plotted infigure .
it shows that most of the used non sdk apis belong to thegreylistbecause thegreylistapis have not been totally blockedand will not trigger runtime crashes.
some apps still use the apison theblacklist and the proportion is gradually increasing.as listed in table the proportion of non sdk apis used inapps accounts for a small part of the whole non sdk apis space .
.
which means thatdevelopers are only interested insome speci f ic functions of non sdk apis.usage by purposes.to further explore the developers intentionsof using non sdk apis we located the belonged packages of thesefrequently used non sdk apis.
according to the core keywords inthe package names extracted by the nlp techniques we lteredthe top belonged packages as shown in figure .
app.
this package contains high level classes encapsulatingthe overall android application model .
for example developers can obtain theactivitythreadclass instancethroughcurrentactivitythread greylist us ing times in apps which is the main thread of the currentapp.
then they can further obtain the context package name and other app information throughactivitythread.
os.
this package provides essential system services messagepassing and inter process communication .
for example developers can usegetvolumelist greylist 0247kh qxpehu ri xvhg qrq .
vfigure top belonged packages of non sdk apis.using time to return the path of all sd cards mounted on thedevice.
however thegetexternalstoragedirectory api provided in the sdk can not achieve this.
view.
this package provides the classes that expose the basicuser interfaces handling screen layout and interaction withthe user .
for example the developer can count the num ber of user clicks in apps by hookingmonclicklistener greylist using times under themlistenerinfo greylist using times object.
content.
this package contains the classes for accessing andpublishing data on the device .
for example if developersneed to implement the hot patch function they can invokeaddassetpath greylist using times to achievethe dynamic resource loading.
widget.
this package contains mostly visual ui elementsto use on the app screen .
for example when devel opers retrieve the width and height of a picture if thispicture does not set the width and height values the valuesofmmaxwidth greylist max p using times andmmaxheight greylist max p using times will bereturned by default.
net.
this package assists network access beyond the normaljava.net.
!apis .
for example developers can judgethe current gprs status throughgetmobiledataenable greylist using times .
if gprs is turned on theycan perform the network tra c transmission tasks.
telephony.
this package provides apis for monitoring basicphone information .
for example developers can obtainthe neighboring cell information of the device throughgetneighboringcellinfo greylist using times to locate the current device location.
graphics.
this package provides low level graphics tools such as canvases color lters points and rectangles .for example developers usually use custom fonts in apps and they need to load the font les and create fonts throughcreatefromfamilieswithdefault greylist us ing times .
util.
this package provides common utility apis .for example suppose developers need to enable apps toadapt di erent device screens.
in that case they can use652authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
noncompatwidthpixels greylist using times andnoncompatheightpixels greylist using times toobtain the device screen resolution.
media.
this package provides the classes that managevarious media interfaces audio and video .
for example if developers want to keep audio and video in sync theyusually need to usegetlatency greylist usingtimes to obtain the track s estimated latency.in summary many popular app features cannot be supported bythe android sdk apis developers have to use non sdk apis.rq2 findingusing non sdk apis is very common in app developments even after google launching the restriction.
app developersare only interested in a small part of non sdk apis and thepurposes are using unique features not supported by the sdk.
lightbulbrq3.
what are the differences in using non sdkapis between malicious and benign apps?thetargetsdkversionattributes of all malicious apps in ourdataset are less than so we usedveridex con gured for apilevel to scan them for generating the usage list of non sdk apis.the result shows that the usage of non sdk apis is widespread.
intotal of malware used at least one non sdk api.following the same approach we scanned the benign appswithtargetsdkversion .
we compared the results and selectedthe top non sdk apis used in two kinds of apps for furtheranalysis as shown in figure .
it shows that the non sdk apisused by benign apps and malicious apps are quite di erent and onlyfour apis currentactivitythread status bar height noncompatwidthpixels andnoncompatheightpixels ex ist in both bar charts.
further checking showsmalicious appsabuse non sdk apis to achieve malicious purposes.
here wegive two concrete cases.case study .getservice is the most frequently used non sdk api in malicious apps which is designed for obtaining speci csystem services.
in some usage cases the malicious app invokes thisapi to obtain theiphonesubinfointerface mainly responsiblefor querying sim card information.
further withiphonesubinfo this app can use the hidden method getsubscriberid intsubid to obtain the imsi international mobile subscriber identity of the sim card4according tosubid.
finally this app can guessthe pin personal identi cation number code of the sim cardbased on the imsi.
by default it is usually the last six digits ofthe imsi or .
the pin code is essential and protects manysigni cant functions of the sim card like network billing andinternal information modi cation.
with the pin code the maliciousapp can deduct fees without the user s consent.
part of the exploitcode is listed in listing .1public staticstring getpaypassword string str context context 2if !textutil.notnull str 3str simutil.getimsi2 context 4if the current device is a dual mode phone it will return the imsi of the main card.5returntextutil.notnull str ?str.substring str.length str.length listing exploit case of pin throughgetservice .case study .even if both benign and malicious apps use thesame non sdk api their purposes are di erent.
for example currentactivitythread can be used to obtain the hiddenactivitythreadclass instance.
after an app getsactivitythread all apis belonging to this class can be invoked by re f lection likethe apis for obtaining the process name and the app package name.for the malicious usage as demonstrated in listing an app canfurther obtain thempackagesinstance inactivitythreadthroughthe re f lection and set itsmclassloaderparameter to a customdexclassloaderobject referring to a malicious dex le line .when this malicious dex le is loaded the app achieves dynamicmalicious code loading to bypass the anti virus detection.for benign usage the primary purpose is to improve theuser experience.
in android if an app uses non sdk apis adialog box will pop up at runtime to indicate that there existsan api compatibility problem.
as a solution the app can set themhiddenapiwarningshownparameter inactivitythreadtotrueto prevent displaying this warning dialog box.1public voidattachbasecontext context context ...3class ?
cls class.forname android.app.activitythread 4method method cls.getmethod currentactivitythread newclass ...6dexclassloader dexclassloader newdexclassloader string.valueof absolutepath2 code.dex a b s o l u t e p a t h data data c o n t e x t .
g e t p a c k a g e n a m e lib context.getclassloader .getparent 7field declaredfield2 class.forname android.app.loadedapk .getdeclaredfield mclassloader 8declaredfield2.setaccessible true 9declaredfield2.set weakreference map declaredfield.get invoke .get getpackagename .get dexclassloader listing malicious usage ofcurrentactivitythread .rq3 findingnon sdk apis have been abused for malware to achievemalicious purposes.
even for the same apis the usages ofmalicious and benign apps are usually di erent.
lightbulbrq4.
how did non sdk apis evolve in the androidframework?the above analysis shows there are still a large number of appsusing non sdk apis and intrusive changes to non sdk apis willcause extensive app crashes.
therefore it is essential to understand653authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
qxpehu ri xvlqj wlphv e hqljq ssvqxpehu ri xvlqj wlphv d 0dolflrxv ssvfigure top non sdk apis used by malicious and benign apps.7kh qxpehu ri vfigure changes in the amount of non sdk apis.the evolution of non sdk apis in the android framework.
asmentioned in section .
we obtained the non sdk api lists ofandroid and api level and .
further weconducted a series of api list evolution analyses.restricted apis amount.the number of apis in each list of thefour versions is shown in figure .
it shows that android hasfewer restricted apis than other versions especially the apis on theblacklist.
however the apis on theblacklisthave increasedsigni cantly in later versions especially from android to which has increased by about times.
the number of apis inother lists has remained relatively stable.
since android is the rst version that google began to implement restrictions on ifmany apis are directly added to theblacklist it will cause apicompatibility issues for a large number of apps.api list adjustments.to characterize the evolution of non sdkapi lists we recorded the changes in the number of apis in theselists between the adjacent android versions as shown in table .in the adjustment of restricted api lists if a new non sdkapi is added to the android framework it will be highly likelyadded to theblacklistdirectly.
the reason is that these newlyadded apis have not been used by any apps which can directlyserve the purpose of restricting developers access.
the apis ontheblacklistandgreylist max xare more likely to be removedfrom the android framework than thegreylist.
it is because thesetwo types of non sdk apis are used relatively infrequently.
also their functions are more relevant to user privacy.
for example notifylocationchanged is on theblacklistin android 10and was removed in android .
using this api can notify the celllocation change of the device.
only a few apis will be movedto the list with lower restriction levels or become public apis.
theapis are usually moved to the list with the adjacent restrictionlevel.
for example more apis on thegreylistare moved to thegreylist max xrather than theblacklist.
since the apis onthegreylistare still used by apps moving them directly to theblacklistwill cause numerous app crashes at runtime.
movingthem to thegreylist max xnot only ensure that apps using theseapis can still run on old devices but also achieve the purpose ofrestricting the use of these apis on the latest version of devices.reasons of adjustments.we further explored that in the listadjustment why some apis are further restricted e.g.
greylist greylist max x and some apis are loosened to the lowerrestriction lists e.g.
greylist whitelist .
as a preliminary we rst investigated which kinds of non sdk apis were adjusted.through ltering the keywords of names of packages that eachnon sdk api belongs to we obtained the most frequently adjustedfeatures packages and the number of associated apis in the processof list adjustment as shown in table .
it shows that the apisbelonging to the android telephony framework are more likely tobe a ected.
telephony is related to various system core services such as call services sms services and apn access points.for the case of enhancing the restriction the rst reason is thesecurity concern.
these apis may bypass privacy protection andinfringe user privacy.
for example deletemessagefromicc ison thegreylistin android and was moved to theblacklistinandroid .
text messages are stored on the sim card by default noton the android device.
using this api can delete all text messagesstored on the sim card causing permanent loss of user data.
also for the same reason various newly added telephony related apisare directly added to theblacklist.besides adding some apis to the restricted list can achieve amore f ine grained access control of the api s functions.
forexample finish is an overloaded function in theandroid.app.activityclass used to close the activity and has two declarations654authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
table changes of the amount of non sdk apis by list type between adjacent android versions.list changesandroid android 10android android 11android android 12new blacklist145 954new greylist max x52728new greylist16 96612630blacklist remove1 790greylist max x remove15 573greylist remove1 478488506blacklist greylist max x000blacklist greylist0236blacklist whitelist011997greylist max x blacklist117greylist max x greylist12140greylist max x whitelist1118323greylist blacklist16885314greylist greylist max x7918953 098greylist whitelist1979810whitelist blacklist1511whitelist greylist max x000whitelist greylist46770 newrepresents the number of apis newly added to the list andremoverepresents the number of apis removed from the list.table the most affected features during the list change process and the number of related apis.list changesandroid android 10android android 11android android 12new blacklist telephony telephony telephony new greylist max x telephony app view new greylist apache telephony libcore blacklist remove media telephony telephony greylist max x remove media net app greylist remove util telephony provider blacklist greylist max xn an an ablacklist greylistn a telephony bluetooth blacklist whitelistn a telephony telephony greylist max x blacklist system telephony media greylist max x greylist os telephony n agreylist max x whitelist media telephony graphics greylist blacklist hardware app graphics greylist greylist max x telephony r telephony greylist whitelist media util media whitelist blacklist os os telephony whitelist greylist max xn an an awhitelist greylist util provider n a n a means that no features are a ected.
with parameters or not as shown in listing .
note thatfinish is a publicly accessible api.
however finish int finishtask belongs to thegreylistbefore android and was moved to thegreylist max xin android .
in fact the internal implemen tation offinish callsfinish int finishtask and passes ina default parameter dont finish task with activity line4 which means closing the activity without closing the stack.when the activity to be closed is not at the bottom of the stack ifthe app callsfinish int finishtask rather thanfinish andpasses in thefinish task with root activitparameter thisapp will exit unexpectedly.1public static final intdont finish task with activity 2public static final intfinish task with root activity 3public static final intfinish task with activity 4public voidfinish 5finish dont finish task with activity 7private voidfinish intfinishtask ... listing example of the api being further restricted.655authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
the restriction onfinish int finishtask and other similarapis is bene cial to less experienced developers preventingthem from passing in wrong parameters and causing unexpectedconsequences.the main reason for loosening restrictions may be the requestsfrom app developers.
since some developers must use the restrictedapis to implement speci c functions they applied to google forreleasing some apis through the android issue tracker .
onthe other hand it is also related to the new features added in thenew versions of the android os.
for example from android to many media related apis under theandroid.media.tvpackagewere moved from thegreylisttowhitelist.
the correspondingis that in android google brought many improvements andchanges to the android tv including security privacy media graphics dynamic partitions and energy consumption doze .rq4 findingin the evolution of android os the non sdk api lists wereadjusted frequently.
the reasons for enhancing api restrictionsare mainly for security concerns and ne grained control.the reasons for loosening api restrictions are mainly due todeveloper requests and newly added features.
discussionsin this section we discuss some limitations of this work and givesuggestions for reducing the use of non sdk apis and improvingthe e ciency of malware detection.limitations.in this study our basic data of non sdk apis usedin apps relies on theveridextool provided by google.
however veridexcannot detect jni calls and the detection of re f lection isnot accurate.
on the other hand dynamic analysis is not asuitable solution for the massive number of apps in our datasetdue to e ciency and coverage issues.
therefore compared withthe dynamic analysis approach we developedveridex based onveridex a static analysis solution for the large scale app scanning.we usedveridex con gured for api level to scan appswithtargetsdkversionattributes less than .
it may cause falsepositives because for some non sdk apis in api level whenthese apps used them these apis might still be sdk apis.
for thetop non sdk apis used by malicious apps we manually excludedsuch false positives.the number of apps withtargetsdkversion 30is relativelysmall i.e.
because it is the latest android api level whenconducting this work and the mainstream android devices on themarket are still android api level .
therefore consideringthe future versions of released apps some basic data may f luctuate like table table and table .
also to further understandthe developers intentions of using non sdk apis large scalesurveys interviews on developers could be conducted.restriction suggestions.according to the above analysis mostdevelopers may ignore google s restriction resulting in an increasein using non sdk apis in recent versions of apps.
here we proposesome suggestions for balancing the requirements of developers andapp compatibility.
for app development when developers invoke non sdkapis android studio should prompt a reminder about theconsequence of accessing the api or provide an alternativeto the public apis with similar functions.
also an integritycheck mechanism of sdk should be added to android studio.so it can detect whether theandroid.jarlibrary has beenreplaced and resets it to the o cial version.
for app runtime google needs to further cut o the wayto access non sdk apis such as adding a mechanism toidentify double re f lection calls.
also at the native layer appsshould be prohibited from creating new native threads toprevent them from bypassing the restriction by breaking thefunction call stack.
for api design the widely used non sdk apis should bereleased or redesigned for public usage.
google could usethe api usage data and the developer requests as