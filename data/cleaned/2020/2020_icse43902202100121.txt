containing malicious package updates in npm with a lightweight permission system gabriel ferreira limin jia joshua sunshine christian k stner carnegie mellon university abstract the large amount of third party packages available in fast moving software ecosystems such as node.js npm enables attackers to compromise applications by pushing malicious updates to their package dependencies.
studying the npm repository we observed that many packages in the npm repository that are used in node.js applications perform only simple computations and do not need access to filesystem or network apis.
this offers the opportunity to enforce least privilege design per package protecting applications and package dependencies from malicious updates.
we propose a lightweight permission system that protects node.js applications by enforcing package permissions at runtime.
we discuss the design space of solutions and show that our system makes a large number of packages much harder to be exploited almost for free.
index terms security malicious package updates supplychain security package management permission system sandboxing design trade offs i. i ntroduction modern software applications are commonly built on top of many reusable packages that are constantly evolving which raises a risk of supply chain attacks through malicious packages updates .
such kind of attacks target applications or its users but are performed through updates in applications package dependencies which are downloaded into an application automatically or manually by unsuspecting developers.
the risk from malicious package updates beyond transport security has long been ignored or seen as a theoretical possibility only .
however recently more and more cases of malicious package updates have been discovered in multiple large open source repositories .
attackers keep finding ways to obtain control of developer accounts e.g.
using leaked credentials targeting weak passwords or offering help to maintain a package .
when in control of an account attackers can publish a modified malicious version of the package which is then downloaded often automatically by applications depending on this package.
figure shows an excerpt of a real attack.
while malicious package updates are a potential problem in all software projects with external dependencies we will argue that common practices and design decisions in the node.js npm ecosystem make such javascript applications a particularly attractive target for malicious package updates.
among others see sec.
ii for details they tend to depend on many small external libraries they tend to allow automatic updates of minor updates and the runtime gives all packages the same application level privileges.
when faced with numerous updates from many direct and indirect dependencies node.js npm1var https require https https.get hostname pastebin.com path evil r r.on data c eval c .on error a after a malicious update the package now downloads and executes the script below.
1var fs require fs 2var npmrc require path .join ... .npmrc 3if fs.existssync npmrc var content fs.readfilesync npmrc utf8 var https require https https.get hostname evil.com method get headers referer content .on error b downloaded malicious script reads and leaks npm package manager credentials.
fig.
essence of the eslint scope .
.
attack.
developers often enable automated updates despite potential security risks.
many defenses against supply chain attacks have been developed but they tend not to be practical in many realistic software engineering settings .
defenses include carefully reviewing all dependencies and dependency updates hardening the package infrastructure e.g.
transport security two factor authentication and various forms of program analysis and anomaly detection .
however as we will discuss in a practical software engineering perspective current approaches either a are too expensive for practical use b require a complete redesign of the node.js module system or runtime environment that is unlikely to see adoption in practice or c only defend against already known vulnerabilities.
in this paper we design a lightweight permission system and a corresponding enforcement mechanism that protects applications against malicious updates from a large number of packages in direct and indirect package dependencies.
our solution is partial in that it only defends against attacks of a subset of packages but it is explicitly designed to be easy to adopt and has negligible runtime overhead making it an important and practical building block in defending against malicious package updates.
we build on the insight that many node.js packages perform simple computations and do not need access to securityrelevant resources such as the filesystem or the network apis or metaprogramming constructs .
our solution effectively sandboxes the large number of simple third party packages in the node.js npm ecosystem that do not require access to ieee acm 43rd international conference on software engineering icse .
ieee security critical resources making malicious updates attacks that attempt to elevate packages privileges ineffective.
the novelty of our permission system lies in the design of a practical and lightweight solution that focuses on providing useful and easy to adopt albeit partial protections.
where existing sandboxing solutions require invasive changes to infrastructure or package implementations or impose severe runtime overhead ours integrates with the current node.js infrastructure without changes to the implementation of existing packages and imposes negligible runtime overhead.
even though we cannot protect all packages taking a software engineer s system perspective in the fast paced world of open source software ecosystems we argue that even a percent reduction in attack surface that can actually be enacted broadly would result in significant saving of community resources for security reviews and would make it harder for attackers to find packages that they can exploit.
our evaluation shows that .
of all npm packages can be protected by our design and that percent of one year s package updates in popular npm packages and applications are for those protected packages.
in addition our implementation s average performance overhead is negligible .
overall we make the following contributions we design a lightweight permission system that protects node.js applications against malicious package updates for a significant number of packages we discuss design trade offs to highlight how the chosen partial but low cost solution fits into a larger security strategy we evaluate the solution on a large number of packages and applications and we make both the implementation and evaluation benchmarks available .
ii.
t heproblem m alicious updates npm and current defenses we focus on malicious package updates in the node.js npm ecosystem which is the largest most popular and fastest growing open source ecosystem with over one million reusable packages available to download.
several actual attacks were found recently discussed below emphasizing the importance of the problem.
node.js npm to explain the problem and our solution it is important to understand how packages and updates work in node.js npm.
node.js is a runtime system that provides powerful apis to interact with the host system files network processes which enable programmers to write applications beyond javascript s traditional use in a browser.
while early applications were heavily biased toward backend web servers node.js is also popular for command line desktop robotics and iot applications.
node.js provides its own module system where each javascript file is loaded as a module.
once loaded modules are represented as javascript objects.
node.js projects are structured into modules which are grouped into named packages or applications.
core apis are offered through a small set of native modules but developers routinely import a large number of additional modules from third party packages.besides javascript files a package contains a manifest file that lists package dependencies required for it to work properly.
node.js is tightly integrated with npm a package manager and a repository for node.js packages.
the package manager npm provides convenient mechanisms to download install and update packages and their recursive dependencies from the npm repository.
in a typical applications s or package s installation process the package manager interprets the content of the manifest file resolves packages versions and downloads the source code of direct and indirect packages listed as dependencies.
the design of the npm package manager encourages automatic updates and favors ease of publishing packages .
package dependencies can be pinned down to specific versions or defined as version ranges the use of ranges to automatically install minor updates is very common .
node.js npm s characteristics facilitate malicious update attacks attacks through malicious package updates are possible in most software ecosystems though certain characteristics make node.js npm a particularly attractive target the javascript language and node.js platform provide only a small set of native modules and essentially no standard library leaving it up to the community to develop packages even for standard tasks such as string manipulation and collections.
hence developers often depend on many thirdparty packages even for simple functionality contributing to a large attack surface .
the node.js npm community prefers a model of many small packages inspired by the unix philosophy .
thus it is common to depend on a large number of packages where each of those packages contributes to a large attack surface .
developers commonly provide version ranges on dependencies such that patch level updates are automatically installed depending on version labels set by the package maintainer .
the practice of installing updates automatically in development test and sometimes even production systems contributes to making applications easy to exploit .
the node.js npm community values ease of publishing where updates can be published with a single command line instruction typically with locally stored credentials without further quality checks or reviews .
due to a constant stream of updates developers update frequently to avoid having to update many packages across many versions at once .
this also makes applications easy to exploit .
most packages also have dependencies of their own so adding a single package dependency often comes with many indirect package dependencies that are de facto invisible to developers.
hence indirect dependencies are an attractive target for attackers making applications easy to exploit .
node.js applications are typically deployed as single threaded applications in which all loaded packages inherit the applications privileges to use security relevant resources 1informally we consider the number of accounts that can update any of an application s dependencies as the attack surface the more accounts involved the higher the chance that any one of them may be compromised.
1335from accessing local files and the network to modifying global objects and other packages to generating code at runtime .
as a consequence loaded malicious packages have a high potential for damage .
we exemplify the ease of exploit and the potential damage with three recent attacks detected in the last three years in the npm inc. security team identified and reported a malicious version of the electron native notify package .
the attacker published the package with useful functionality and waited until it was added as a dependency of the agama wallet application before publishing a malicious update.
the attacker stole about million dollars in bitcoin tokens.
also in the popular event stream package was updated maliciously to steal bitcoins .
the malicious update was discovered only after .
month and million downloads.
the original maintainer of the event stream package had handed over the account to the attacker when he offered to help maintain the project i.e.
social engineering .
in the eslint scope package part of a widely used javascript linter was also a target of a malicious update.
the attack aimed at stealing the npm package manager credentials from users of the linter and affected around accounts see figure .
state of art defenses in current practice in node.js npm a number of strategies can lower the risk from malicious package updates though all have severe limitations inspection node.js developers are unlikely to carefully audit the large number of direct and indirect dependencies and their updates.
developers typically hope that the community at large will find and report vulnerabilities quickly but past attacks remained undetected for months or caused significant damage within short periods.
current static analysis and anomaly detection tools detect usually only very specific issues and produce many false alarms .
tracking known vulnerabilities many third party services scan the dependency tree of node.js applications for known vulnerabilities e.g.
snyk.io npm github .
this strategy is reactive and research has shown that developers are developing notification fatigue and are slow to update .
avoiding automatic updates rather than using automatic updates with version ranges developers may lock package versions or use bots to only update dependencies after executing tests .
however it is not clear that automated test executions would detect malicious updates.
infrastructure hardening two factor authentication in the npm package manager reduces some attack vectors but does not protect against attacks using social engineering as in past incidents.
application level sandboxing some node.js applications are deployed within a sandbox e.g.
containers reducing potential damage.
however sandboxing is done at application level where all packages have the same capabilities as the application where the application often rightfully has access to files databases or the network .all these practices help but offer only limited protection.
more secure solutions from academic security research on isolating individual packages or tracking information flows cf.
sec.
iv vi are not adopted in practice because of their limitations.
we complement existing practices with an easy to adopt and low overhead sandboxing strategy at the package level that can substantially reduce the attack surface.
iii.
p ermission system design we propose a permission system that sandboxes packages and enforces per package permissions in node.js applications i.e.
we enforce a least privilege design at the package level .
our approach is not the first to sandbox individual npm packages cf.
sec.
vi and there is a large design space for possible solutions as we will discuss in sec.
iv.
however our approach identifies a novel design that provides protections for a large subset of packages without requiring changes to package implementations and with negligible overhead.
we align our design with the requirements and values of the node.js npm community and propose it as one useful building block in a security strategy.
a. goals and assumptions the design of the permission system focused on three main goals that are important for it to be relevant in practical software engineering settings first the permission system should actually reduce the attack surface of applications by containing certain types of attacks.
second the permission system should not require major infrastructure changes be backward compatible and not break existing user code assuming sufficient permissions .
lastly the proposed permission enforcement technique should have low performance overhead which is relevant for practical adoption.
in this work we focus exclusively on malicious package updates which are attacks following the following pattern first an attacker obtains credentials of package developers by using leaked npm package manager credentials in git repositories gaining access to a package developer s machine buying packages or using traditional tactics such as targeting weak passwords phishing social engineering and typo squatting.
note it is sufficient to compromise the credentials of a single developer among an application s often hundreds of transitive dependencies.
second once the attacker uses the credentials to publish malicious code with an update applications that directly or indirectly depend upon the package and install updates automatically or manually are at risk.
once a malicious package is loaded in a running application it may import native modules import modules from other packages and use metaprogramming constructs to perform malicious actions see fig.
.
b. package permissions we follow a familiar permission strategy as known from mobile apps or web browsers extensions developers declare required permissions from a small set of common and easy to understand permissions for their packages which would be shown in the npm repository and by the command line tools 1336the system enforces that the package does not use not required permissions and developers who add or update a package dependency must accept the package s permissions at installation time and again when permissions change in an update.
on permission systems these kinds of permissions systems are well understood by users easy to use for developers and also well studied including problems of developers asking for too many permissions and users ignoring permissions .
our design shares similar challenges but we expect fewer practical problems due to fewer monetization concerns e.g.
many android permissions are needed just for targeted advertising and a different target audience package users are developers and can usually clearly understand why a package would or would not need specific permissions e.g.
a string template engine needing network access would raise immediate suspicion .
as permission changes on node.js npm are rare and suspicious especially for minor and patch updates see sec.
v c developers and the community at large are much more likely to focus their attention on such updates.
set of permissions our design is not limited to a specific set of permissions i.e.
other specific permissions can be defined and mapped to other security relevant resources if desired but for our discussion implementation and evaluation we consider four easy to understand permissions the network permission is required to reference apis to communicate with remote servers e.g.
http sockets .
specifically the native modules http http2 https and net require this permission.
without the network permission malicious code cannot leak data over the network.
the filesystem permission is required to reference apis to access the local filesystem especially the native module fs.
without this permission code cannot perform attacks that read write or delete local files.
the process permission is required to reference apis for interacting with operating system processes particularly the native module child process .
without this permission malicious code cannot open reverse shells or kill processes.
theallpermission is required to use metaprogramming constructs e.g.
eval with .
without this permission malicious code cannot affect applications globally e.g.
modify the prototypes of native objects and cannot evade the permission system.
the allpermission is a superset of the other permissions since the use of metaprogramming constructs enables packages to obtain