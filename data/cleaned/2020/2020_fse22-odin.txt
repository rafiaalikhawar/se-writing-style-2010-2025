detecting non crashing functional bugs in android apps via deep state differential analysis jue wang juewang591 gmail.com state key lab for novel software technology and department of computer science and technology nanjing university chinayanyan jiang jyy nju.edu.cn state key lab for novel software technology and department of computer science and technology nanjing university chinating su tsu sei.ecnu.edu.cn shanghai key laboratory of trustworthy computing east china normal university china shaohua li shaoli ethz.ch department of computer science eth zurich switzerlandchang xu changxu nju.edu.cn state key lab for novel software technology and department of computer science and technology nanjing university chinajian lu lj nju.edu.cn state key lab for novel software technology and department of computer science and technology nanjing university china zhendong su zhendong.su inf.ethz.ch department of computer science eth zurich switzerland abstract non crashing functional bugs of android apps can seriously affect user experience.
often buried in rare program paths such bugs are difficult to detect but lead to severe consequences.
unfortunately very few automatic functional bug oracles for android apps exist and they are all specific to limited types of bugs.
in this paper we introduce a novel technique named deep state differential analysis which brings the classical bugs as deviant behaviors oracle to android apps as a generic automatic test oracle.
our oracle utilizes the observations on the execution of automatically generated test inputs that there can be a large number of traces reaching internal app states with similar gui layouts and only a small portion of them would reach an erroneous app state and when performing the same sequence of actions on similar gui layouts the outcomes will be limited.
therefore for each set of test inputs terminating at similar gui layouts we manifest comparable app behaviors by appending the same events to these inputs cluster the manifested behaviors and identify minorities as possible anomalies.
we also calibrate the distribution of these test inputs by a novel input calibration procedure to ensure the distribution of these test inputs is balanced with rare bug occurrences.
corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
implemented the deep state differential analysis algorithm as an exploratory prototype odin and evaluated it against popular real world android apps.
odin successfully identified noncrashing functional bugs five of which were previously unknown of various root causes with reasonable precision.
detailed comparisons and analyses show that a large fraction of these bugs cannot be detected by state of the art techniques.
ccs concepts software and its engineering software testing and debugging .
keywords software testing mobile apps non crashing functional bugs acm reference format jue wang yanyan jiang ting su shaohua li chang xu jian lu and zhendong su.
.
detecting non crashing functional bugs in android apps via deep state differential analysis.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
.
introduction background and motivation .
non crashing functional bugs of android apps caused by program logic errors seriously affect user experience .
being buried in rare program paths such bugs may not be captured in the quality assurance testing procedure and may lead to severe consequences .
despite the rapid development of automatic test input generation for android apps very few automatic functional bug oracles for android apps exist .esec fse november singapore singapore jue wang yanyan jiang ting su shaohua li chang xu jian lu and zhendong su aut execution traces gui modelmay belief anomaly behavior clusters bug reports gui modelcalibrating generated test inputs section .
extended test inputsmanifesting app behaviors section .
mining may beliefs section .
merge abstract abstract abstract abstract figure workflow of odin normally view content uncompressed folderclick folderclick folderclick folderclick zip zip filenon empty folder inside a zip fileempty folder inside a zip filenormally view contentnormally view contenttrigger the apk installer figure a motivating bug example specifically metamorphic relations can be established by comparing independent executions genie or with injected neutral ui system events thor and setdroid .
however these metamorphic relations all place a strong emphasize on the independence of two event fragments and are fundamentally limited in identifying programming errors that occurred in dependent event fragments.
for instance genie s authors acknowledged that only .
of the non crashing functional bugs in an empirical study falls into the scope of genie .
a natural question then arises can we exploit the massive automatically generated test inputs to expose potential logic errors?
this paper demonstrates that it is possible to mine behavioral specifications for detecting non crashing functional bugs without supervision .
specifically we observed that automatically generated test inputs can reach comparable states of an app from which we can differentiate its behaviors to find non crashing functional bugs.
mining may beliefs as test oracle .
this paper introduces deepstate differential analysis a novel generic and automatic oracle for android apps that brings the classical bugs as deviant behaviors oracle to automatically generated gui test inputs of android apps.
specifically we mine may beliefs1 expected app behavior specifications from execution traces and use such beliefs to identify anomalies as deviant behaviors likely caused by bugs.
our mined beliefs are based on the following two observations there can be a large number of traces test inputs that end up with a similar gui layout.
suppose that the app is mostly functionally correct then only a small portion of them could possibly end up with an erroneous state since developers would already notice bugs on frequent program paths.
1the original paper also defines a set of must beliefs of formal specifications a system must satisfy.
a few existing techniques proposed manual must beliefs assertions concerning specific system behaviors and are out of our scope.
android apps are designed with the least surprise principle that performing the same sequence of actions on similar gui layouts should trigger only a few limited behaviors of the app.
therefore if we append the same event sequence to all these test inputs ending up with similar gui layouts their triggered app behaviors should fall into only a few behavior clusters the majority becomes our belief oracle .
a corollary is thus any small cluster should be considered potentially buggy .
there are two main challenges to porting this idea to android.
first beliefs bugs as deviant behaviors should be established over balanced traces of rare bug occurrences.
however existing coverage directed test input generators often fail to provide such traces which are necessary for mining reliable beliefs.
our approach addresses this challenge by a novel input calibration procedure that generates additional test inputs by repeatedly approximating random walks on a mined gui model of the app so that for each gui model state representing a group of similar gui layouts there are a set of sufficiently balanced test inputs reaching it with which we can safely mine reliable beliefs.
second the may beliefs are extracted from the clustered majority behaviors .
android apps are gui centered and thus using the corresponding gui layout sequence as a representation of the app s behavior is a common practice .
however gui layouts often contain rich but redundant or even non deterministic information which hinders precise clustering and majority extraction.
to mitigate this challenge our approach performs a gui abstraction based hierarchical clustering on the gui layout sequences.
specifically starting with each sequence in its own cluster with no abstraction on the gui layout our approach iteratively selects one more rule from a pool of gui abstraction rules commonly adopted by existing work further abstracts each gui layout accordingly and merge clusters that containdetecting non crashing functional bugs in android apps via deep state differential analysis esec fse november singapore singapore similar abstracted gui layout sequences.
it attempts to detect outliers which are accordingly identified as anomaly behaviors while others as may beliefs by calculating and comparing z scores of the clusters size after each round of merging.
theodin prototype tool .
we implemented the deep state differential analysis algorithm as an exploratory prototype odin and evaluated it against popular real world android apps.
odin successfully identified non crashing functional bugs five of which were previously unknown.
we reported these unknown bugs to the developers and all have been confirmed.
detailed comparisons and analyses show that a large fraction of these bugs cannot be detected by the state of the art technique genie the input calibration and gui abstraction based hierarchical clustering can indeed improve odin s effectiveness and odin can identify non crashing functional bugs of various root causes with reasonable precision.
in summary this paper makes the following key contributions we proposed deep state differential analysis and brought the bug as deviant behaviors idea to android apps as a novel generic and automatic test oracle.
we implemented the prototype tool odin and will make it public2.
we evaluated the tool against real world android apps and the results are encouraging that odin well complements state of the art techniques.
the rest of this paper is organized as follows.
section provides an overview of our approach with a motivating example.
details of our approach are discussed in section .
in section we introduce the implementation of odin and in section the evaluation is conducted.
related work is discussed in section and finally section concludes the paper.
overview it is non trivial to port the bugs as deviant behaviors idea to android despite its simplicity.
this section describes the overview of our approach illustrated in figure and discusses the challenges and their mitigation.
our approach takes the app under test and a set of its gui execution traces a gui execution trace is an event sequence combined with the gui layout sequence obtained by sending the event sequence to the app as input and outputs bug reports.
first to provide balanced gui execution traces of rare bug occurrences with which we can mine reliable beliefs our approach constructs a gui model from the traces and preforms an input calibration procedure for each gui model state representing a set of similar gui layouts and then extends calibrated inputs ending up at the gui state for manifesting normal and anomaly app behaviors.
next to find a deliberate abstraction that is simultaneously effective in distinguishing anomaly behaviors and resistant to noises it adopts a gui abstraction based hierarchical clustering algorithm to cluster the manifested behaviors mines may beliefs and detects anomalies from the behavior clusters.
anomalies are reported as potential non crashing functional bugs.
motivate our approach by a previously unknown bug found by our deep state differential analysis in the amaze file manager app figure .
a user can use amaze to view folders on the device and select a folder to view its content by clicking its icon.
there is a subtle bug that amaze sometimes erroneously identified an empty folder inside a zip file as an apk.
clicking such a folder triggers the system s installer while the expected behavior is displaying an empty folder.
this is a typical non crashing functional bug.
state of the art automated test input generators can occasionally trigger this erroneous behavior.
we explain below how do we establish the belief that clicking an folder should not open an app installer .
.
calibrating generated test inputs may beliefs assume that traces are sufficiently diverse i.e.
each internal app state has a considerable portion of traces reaching it and buggy traces are rare.
however automatically generated test inputs are drawn from a highly skewed probability distribution in which dominant inputs can only reach shallow app states with limited diversity.
this is due to the coverage directed nature of automatic test input generators .
first to maximize covered internal states or app code within a limited time automatic test input generators tend to stick to a profitable trace for long term exploration producing a skewed distribution of test inputs.
if such a profitable trace is accidentally erroneous it cannot be identified as rare and buggy.
furthermore deeper internal states are generally more difficult to reach.
consequently test inputs that reach deep states are also rare and deep states lack sufficient traces for deriving strong beliefs on majority behaviors.
challenge how to effectively generate massive balanced test inputs that provide all explored app guis shallow or deep with sufficiently many traces of behavioral diversity?
to mitigate this challenge our approach calibrates the generated test inputs by approximating a random walk on a mined gui model of the app.
first our approach mines the app s gui model from the gui execution traces of massive automatically generated test inputs by grouping similar gui layouts as gui model states3and adding transitions according to the input event between each pair of gui layouts in the execution traces.
note that our approach ensures that no non deterministic transitions i.e.
an event can trigger two different transitions from the same gui model state in the gui model.
given any gui model state no matter shallow or deep our approach simulates a random walk on the gui model i.e.
finding a random path terminating at .
the random walk forces all outgoing transitions from the same gui model state the same probability.
specifically suppose that the random walk is at gui model state i and there are transitions i j in the gui model j i j .
then our approach selects each j with probability1 1and i terminating at the same state with1 to obtain the next state iin the random walk.
in each step of the random walk our approach also randomly selects an event that can manifest the transition i i yielding a test input event 3we consider two gui layouts similar if they handle the same set of events i.e.
events are interchangeable for both states.esec fse november singapore singapore jue wang yanyan jiang ting su shaohua li chang xu jian lu and zhendong su sequence that can potentially terminates with gui model state .
by repeating this procedure our approach generates sufficiently many and diverse test inputs for each gui model state.
note that the goal of our calibration is to generate for each gui model state no matter whether it is shallow or deep that has been covered by some given test inputs a set of diverse traces reaching .
it does not guarantee to cover all deep states of the app which is a challenge for any test input generation approach .
gui modeling inevitably losses information and test input obtained from a random walk may not terminate at a designated in real execution.
to enable a practical approximation when such an inconsistency occurs our approach re mines the gui model from the original execution traces and the newly obtained ones causing inconsistency.
in the motivating example automatic test input generators can provide massive execution traces reaching the same gui model state with folders listed on similar gui layouts the first gui page of each gui page pair in figure .
however the generators are likely to stick to an erroneous one reaching a gui page displaying the empty folder inside a zip file and extend it for long term exploration because they can cover extra pieces of code that are incorrectly executed to display an apk file leading to a skewed distribution in which the erroneous traces are no longer rare.
nonetheless our input calibration procedure is able to calibrate the skewed distribution by generating additional test inputs for the gui model state most of which reach the correct app states.
.
manifesting app behaviors given sufficiently balanced test inputs that reach a gui model state we can reasonably assume that only a small fraction of the inputs terminate with an erroneous internal state.
however it is difficult to directly cluster internal states which consist of low level representation of data like serialized heap objects.
alternatively we leverage the observation that an internal state scan be characterized by its future behaviors.
specifically for a test input whose execution terminates with an internal state s we can extend the test input by appending various event sequences to the test input and all observable triggered behaviors gui layouts of the appended events depend on s. manifested anomaly gui layouts indicate a buggy s. unfortunately appending all inputs with exhaustively enumerated event sequences yields an intractable search space.
therefore our second challenge concerns efficient manifestation of diverse behaviors challenge .
how to efficiently extend inputs to manifest both normal and deviant app behaviors for establishing beliefs?
this challenge is mitigated by the observation that appending only one event to the inputs suffices for manifesting abnormal gui layouts and establishing beliefs.
suppose that an input terminating with an internal state s0is extended to yield a state transition sequence of s0e1 s1e2 ...ek sk 1ek sk in whichsk displays an anomaly gui layout.
then our calibrated inputs should contain sufficiently many test inputs that terminate with a similar gui layout with sk and only a minority of them hit an erroneous state.
thus appending only one event ekto such inputs of similar gui layout and thus ekcan be applied to all of them will establisha may belief that the less frequently occurred gui layout of sk indicates a bug.
in the motivating example for the gui model state representing app states in which a folde can be selected to view its content our approach appends different single events to the inputs reaching it.
when appending one click event on the folder our approach manifests both normal and anomaly gui layouts illustrated in figure for belief mining.
.
mining may beliefs as test oracle finally the may beliefs are extracted from the majority behaviors of gui layouts.
the one event we append to each input yields an internal state transition se s connecting a pair of gui layouts l l that can be clustered.
however gui layouts often contain rich but redundant or even non deterministic information like dynamic web contents.
it is a challenge to find a deliberate abstraction that is simultaneously effective in distinguishing anomaly behaviors and resistant to noises challenge how to cluster gui layout pairs for establishing correlations between anomaly behaviors and minority?
to mitigate this challenge a gui abstraction based agglomerative hierarchical clustering is performed by our approach.
based on the common abstraction criteria adopted by existing techniques we design a set of abstraction rules e.g.
abstracting away all texts in the gui layout that can be applied individually or combined.
with each gui layout pair in its own cluster with no abstraction our approach iteratively selects one more abstraction rule and further abstracts all gui layouts.
after applying a new rule our approach merges similar clusters.
our approach measures the similarity between two clusters by comparing the fingerprints of their contained gui layout pairs.
specifically it uses the differential between the abstracted gui layouts in each layout pair as its fingerprint denote by the tree editing distance of abstracted gui layouts which enables the clustering algorithm to focus on the instantaneous rate of change e.g.
a newly added button or a piece of unchanged text and ignore the accumulated non determinism over test input execution like the first order differential of continuous functions.
after each round of abstraction and cluster merging our approach conducts a z score based may beliefs mining on the merged clusters in which outliers if any are considered anomalies while others may beliefs.
such an iteration terminates when all abstraction rules are applied or any anomaly is found and thus may beliefs are mined .
in the motivating example in figure for the majority of gui layout pairs the second layout displays a list of different files.
however for the erroneous ones obtained by clicking an empty folder inside a zip file the second layout displays a dialog asking permissions to install the folder.
with a deliberate abstraction the majority is grouped in one cluster the may beliefs while the erroneous ones in another the anomalies and the non crashing functional bug is detected.detecting non crashing functional bugs in android apps via deep state differential analysis esec fse november singapore singapore algorithm gui model mining 1function minemodel tl l1 l2 ... ln 2v e foreachl l0e1 l1e2 ...em lm tldo 4v v li i m initially no state is merged 5e e ei i m 6 li ei li i m foreach i j v vand i jdo in the bluefringe ordering v merge recursive i j v if v then v v return v e 12function merge recursive 1 2 v if l1 1 l2 2.similar l1 l2 then 14v v 1 2 1 2 foreach 1 e k 1 e t and k tdo v merge recursive k t v if v then return merge failed return v return merge failed deep state differential analysis .
notations and definitions android apps are gui centered and event driven.
at runtime the gui layout snapshot of the app p s current internal state s l l s is represented as a tree in which each node lis a gui widget e.g.
a button or a text field object .
a set of attributes are associated with each node for instance .type refers to s widget type e.g.
a button or a text field and .text refers to s displayed text .text if no text is displayed .
when pis inactive closed or paused to background no gui layout exists and l .
an gui event e t r is a record in which e.tande.rdenote e s event type and receiver widget respectively.
an event type can either be click long click orswipe4 and the receiver r l denotes the widget lto whichecan be delivered r l if this event cannot be delivered to any widget of l .
executingpwith an event sequence i.e.
a test input yields an execution trace s0e1 s1e2 ...en sn in whichs0 is the initial internal app state and sending event ei 1to statesi yields a new state si i n .
its corresponding gui execution trace isl l0e1 l1e2 ...en ln whereli l si i n .
.
calibrating generated test inputs we calibrate the automatically generated test inputs by simulating a random walk on an automatically mined gui model.
mining a gui model .
the gui model is mined from the gui execution traces of massive automatically generated test inputs.
4our approach does not limit and assume the event types in the given test inputs.
gui events such as text input or pinch can be modeled as combinations of these three types of events.
for example a text input event can be modeled as a series of click events on the soft keyboard.algorithm calibrating over gui model g v e 1function calibrate t 2t repeat 4 arg min v t 5p random walk 0 ifp then t t to input p until sufficiently many traces are collected returnt t 10function random walk p 0 1 ... i if p max limit then return e e. i e if i then i terminate at the designated gui model state foreach i shuffle do if i iand i then p p else p random walk 0 1 ... i ifp then returnp return given the execution trace set t 1 2 ... n whose corresponding gui execution trace set is tl l1 l2 ... ln its corresponding gui model is a tuple g v e in whichvis a set of gui model states v is a partition of all gui layouts in l tl l l l eis the set of events sent to the app on some l tl and v e vare the transitions in g. to mine a minimal gui model we adopt the existing algorithm algorithm in swifthand that groups similar gui layouts together and ensures transitions in the model are deterministic5.
we consider two gui layouts l1andl2are similar if and only if they can handle the same set of events i.e.
e e.e.r l1 e.r l2 .
specifically if we have witnessed in tlthat an event eis sent to a widget l1 we compute the tree editing distance betweenl1andl2using the classic zhang shasha algorithm and find the shortest editing operation sequence each editing operation inserts removes or modifies a widget that transforms l1to l2.
if is not removed during the transformation there must exist a unique correspondence l2.
we thus let e.r l2 .
otherwise e.r l2 and we consider l1andl2not similar.
we discuss the editing operation sequence in more details in section .
.
random walk simulation .
with the gui model g v e we calibrate automatically generated test inputs by a random walk simulation with the algorithm presented in algorithm .
given a set of traces t we select the least balanced gui model state v i.e.
has the fewest traces reaching it line .
reaching a gui model state is defined by visiting one or more 5all transitions in a gui model g v e are deterministic if and only if for each v e e such that 1 2.esec fse november singapore singapore jue wang yanyan jiang ting su shaohua li chang xu jian lu and zhendong su times reach s l s then we try to find a path pon the model reaching the least balanced via a simulated random walk starting at the initial gui model state 0 line and obtain the corresponding test input line .
the initial gui model state 0is the state containing gui layout of the app at the initial app state.
such a procedure is repeated until sufficiently many traces are obtained lines .
during a simulated random walk when at a gui model state i we first obtain the set of gui model states that an outer transition from ican reach line .
moreover if iis the target gui model state we also add it to lines .
we then iteratively select each i with a uniform probability1 in turn line and continue the random walk on i lines .
such an iteration terminates when all i have been selected or a transition path to is found lines .
to reduce the search space we also limit the number of steps in one random walk lines .
the feedback loop .
gui modeling inevitably losses information and the test input we obtained by a simulated random walk may not actually yield the same transitional path in real execution.
to reduce the occurrence of such inconsistencies after we obtain a transitional path p 0 1 ... p and its corresponding test input we send the input to the app and record the actual execution trace and its corresponding transitional path p ... p in the gui model.
if an inconsistency occurs i.e.
for a transition i i i p inp the corresponding transition i i inp has i ibut i i we add s gui execution trace to tlfrom which the gui model g v e is mined and re mine a new minimal gui model g v e which will be used for future calibration and belief mining.
.
manifesting app behaviors given any test input trace that terminates with gui model state can be obtained by selecting a trace reaching and removing all subsequent events after reaching we extend it by exactly one event to manifest potentially buggy behaviors.
specifically given a gui model state l s allsrespond to the same set of events due to our similarity criteria.
therefore the belief mining is conducted on the per event basis.
suppose that all states s where l s responds to e. we enumerate all inputs reaching and append eto yield a new execution trace s0e1 s1e2 ...en sne sn and the layout pair of the last state transition l sn l sn represents the manifested app behavior from which we mine may beliefs.
.
mining may beliefs hierarchical behavior clustering .
given a set of gui layout pairsb l1 l l2 l ... ln l n obtained by sending a same event to inputs terminating with a same gui model state we conduct a agglomerative hierarchical clustering .
as shown in algorithm initially each layout pair starts with no abstraction in its own cluster lines .
next we iteratively select one more abstraction rule to apply line .
we study existing start of theart techniques concerning gui layout abstraction andalgorithm hierarchical behavior clustering 1function cluster b l1 l l2 l ... ln l n 2r initially no abstraction rule applied 3c l l l l b each layout pair in its own cluster while not all abstraction rules are applied and c 1do 5r select one rule c r r r foreach c1 c2 c c andc1 c2do 1 fingerprint c1 r 2 fingerprint c2 r if 1 2then c c c1 c2 c1 c2 11cerror detect anomaly c ifcerror then return c cerror return 15function fingerprint c l1 l2 r l1 l2 random choice c 17l abstract l1 r 18l abstract l2 r tree edit l l return design a set of abstraction rules that can be applied individually or combined.
there are three abstraction rules that can be applied namely sets the value of a specific attribute attr of all widgets e.g.
.text in a gui layout lto i.e.
for all l set .attr removes all widgets in a gui layout lthat are not the receiver of any event i.e.
remove each widget lif e e.e.r l and removes duplicate sub trees of each widget in a gui layout l if it displays a list on the gui e.g if .type listview .
for each iteration we select one more rule that has not been applied and leads to minimal cluster merging i.e.
fewest clusters can be merged after applying this rule and add it to the rule set r line .
with r we enumerate each cluster pair c1 c2 to determine whether they can be merged by comparing their new fingerprints line .
after merging all clusters with identical fingerprint we try to detect anomalies and mine may beliefs on the merged clusters line .
such an iteration terminates when all abstraction rules are applied only one cluster remains or we have found an anomaly lines .
fingerprint extraction .
as algorithm shows to extract fingerprint of a cluster c we randomly select one layout pair in l1 l2 c line apply the currently selected abstraction rules onl1andl2 and calculate the differential between the abstracted layoutsl 1andl 2asc s fingerprint lines .
we denote the differential of two abstracted gui layouts land l as a tree editing operation sequence transforming ltol .
each operation is a tuple o t wheretis its type addition deletion or modification is the target of o and is the widget after the operation is applied.
for an adding operation we add as s leftmost child.
for an deleting or modification operation we replace with for deleting operations .
specifically for a modification operation o t if for an widget attribute attr e.g.
text we have .attr .attr we set .attr and .attr to to reduce noises.detecting non crashing functional bugs in android apps via deep state differential analysis esec fse november singapore singapore we randomly select one layout pair in cand use its asc s fingerprint because all layout pairs start in their own clusters we only merge clusters with identical fingerprints and for any two layout pairs in one cluster applying one more abstraction rule may only remove identical operations in their s. therefore we can safely assume that all layout pairs in a cluster share the same .
anomaly detection and may beliefs mining .
given a set of clustersc c1 c2 ... cm we conduct a z score based analysis to identify anomaly clusters.
ideally the z score of a cluster c cis zc c c sc where cis the average sizes of clusters in candscis the standard deviation.
however c can be quite small and the anomaly clusters can largely affect candsc.
therefore we replace candscwith c andsc respectively where the majority subset c c is the smallest subset such that c c c c c c .
following the common practice a cluster c c is considered anomaly ifzc 3and c c .
other clusters are accordingly considered as may beliefs.
implementation we implemented the deep state differential analysis algorithm as a prototype tool odin consisting of lines of kotlin code.
we extensively used open source tools in the implementation and odin is also open source available bootstrapping automatically generated test inputs traces are obtained using ape and combodroid .
such a mixed bootstrapping is also inspired by existing work .
ape is also used to execute test inputs and obtain execution traces gui layout dumps at app states regarded quiescent by ape after launching and sending each event .
all implementation is consistent with the descriptions in section .
for performance considerations during the calibration procedure algorithm if the trace of a generated input for does not reach odin still keeps it in the calibrated input set but does not count it when checking the number of test inputs for termination.
moreover for each gui model state and appended event pair may beliefs are mined and multiple anomalies can be detected.
odin outputs a single report containing all corresponding execution traces and clusters for further manual examination.
evaluation our evaluation aims to answer the following research questions rq1 bug finding section .
how effective does odin automatically find non crashing functional bugs in real android apps comparing with state of the art techniques?
rq2 test input calibration section .
how beneficial is input calibration in establishing beliefs and finding noncrashing functional bugs?
rq3 may belief mining section .
how beneficial is our may belief mining algorithm in identifying non crashing functional bugs?
rq4 false positives section .
how precise does odin report non crashing functional bugs?
rq5 bug types section .
what types and characteristics of non crashing functional bugs can odin find?
.
experimental subjects and setup evaluated apps .
we first collected apps latest version used in the evaluation of existing android testing oracle work as group randoms .
we selected the top three largest in loc among all available subjects wikipedia antennapod and ankidroid and eight random subjects with at least 10k downloads and loc.
these subjects are listed as the first group in table .
to conduct a full comparison with the state of the art work genie we also include allexperimental subjects in the evaluation of genie excluding two non functional apps radiodroid andskutube due to unavailable web services.
for ankidroid anymemo markor and transistor their latest versions are included in the first group of subjects.
the remaining six subjects are listed as the second group named group comparisons in table .
if an app s major functionalities cannot be accessed without a proper initial setup e.g.
user login we provided the app a script to complete the setup.
all evaluated techniques received exactly the same script which runs automatically once the initial setup gui is reached to ensure a fair comparison.
this is a common practice in android testing .
we did not mock any further functionality other than the initial setup script.
experimental setup .
to answer rq1 we compared odin with the state of the art automated oracle genie on all selected apps.
genie was configured with its default settings same in its evaluation one hour for mining a gui transitional model and generating initial test inputs with up to events.
then it mutated the test inputs at most mutated test inputs from one initial test input executed them on parallel android emulators and detected non crash functional bugs.
the exploration is terminated if accumulated wall clock time exceeds hours.
odin is given a same hour time limit.
since odin requires massive test inputs to establish beliefs we divide the hour into hours of test input generation hours each for ape and combodroid each test input is event long and hours for test input calibration and behavior manifestation on parallel emulators.
runtime cost for anomaly detection is negligible.
the calibration process terminates when odin obtains the same number of test inputs as the automatically generated ones and the steps of a simulated random walk is also limited to .
for each gui model state odin keeps random inputs reaching .
we compared the numbers of bug reports true positive ones and detected distinct non crashing functional bugs of odin and genie.
we manually analyzed the gui execution traces and related code of true bugs to determine their distinctness.
to answer rq2 andrq3 we compared odin with two of its variants namely odin nocalib andodin simple on the subjects of the randoms .odin nocalib does not conduct test input calibration but directly samples inputs for each gui model state from automatically generated test inputs.
on the other hand odinsimple adopts a simple clustering and anomaly detection strategy.
specifically for clustering it uses a fixed abstraction criteria thatesec fse november singapore singapore jue wang yanyan jiang ting su shaohua li chang xu jian lu and zhendong su table experimental subjects and comparison results with genie id subject version downloads loc genie odin comparison tp report input state cov tp report genie common odin group random random apps latest version wikipedia .
.
10m 50m .
.
.
antennapod .
.
100k 500k .
.
.
ankidroid .
.
5m 10m .
.
.
amaze .
.
100k 500k .
.
.
and bible beta .
100k 500k .
.
.
anymemo .
.
100k 500k .
.
.
markor .
.
50k 100k .
.
.
materialistic .
50k 100k .
.
.
transistor .
.
10k 50k .
.
.
skytube .
100k 500k .
.
.
aard2 .
10k 50k .
.
.
group comparisons other genie evaluated apps genie s evaluated version activitydiary .
.
1k 5k .
.
.
tasks .
.
100k 500k .
.
.
unitconverter .
.
1m 5m .
.
.
simpletask .
.
10k 50k .
.
.
fosdem .
.
10k 50k .
.
.
myexpense .
.
.
500k 1m .
.
.
summary .
.
.
1column subjects lists the information of each subject.
for genie and odin column tp reports displays the numbers of true positive all reports for each subject and the tp rate in the brackets and column displays the numbers of detected distinct bugs.
for odin the number of automatically generated test inputs and the number of gui states in the mined model along with the state coverage a state is considered covered if odin finishes mining may beliefs for it are displayed in column inputs and state cov respectively.
finally column comparison plots the venn diagrams of the sets of bugs detected by genie alone odin alone and both respectively.
removes all non interactive widgets and sets the values of all attributes except type to for all remaining widgets in the gui layout.
this is a common abstraction criteria adopted by existing techniques .
moreover for anomaly detection odin simple directly uses the mean and standard deviation of all clusters instead of the ones of the majority subset to calculate z scores.
for odin nocalib we let it use the same automatically generated test inputs as odin and gave it hours for behavior manifesting and anomaly detection.
for odin simple we let it mine may beliefs and detect anomalies on all the gui layout pairs produced by odin with no time limitation.
we compare the reports and detected distinct non crashing bugs of these variants on the randomly selected subjects of group randoms .
to answer rq4 andrq5 we further analyzed odin s reports and detected bugs the corresponding execution traces and the related code of the apps to determine the root causes of false reports and the bugs respectively.
all experiments were conducted on a server running ubuntu .
lts with core amd ryzen 2990wx cpu 128g ram and android .
.
emulators.
.
evaluation results bug finding bugs found .
the overall results in table show that odin complements genie in finding non crashing functional bugs.
considering that only traces are used in the experiments due to the time limit odin would have potential to reveal even more non crashing functional bugs given truly massive traces.after eliminating false and duplicated reports we found that odin and genie reported and distinct non crashing functional bugs respectively.
of the bugs are overlapping.
the venn diagrams in the last column of table displays the detailed results.
in the subjects of the randoms and the comparisons genie reported and functional bugs respectively while odin reported and respectively.
on average genie output bug reports for each app .
of which were true while odin output reports for each app .
of which were true.
odin reported more duplicated reports because there can be multiple gui model states representing semantically similar gui layouts that respond to slightly different sets of events and from these gui model states odin identifies the same non crashing functional bugs and reports each individually.
previously unknown bugs .odin and genie are also complementary to each other in detecting previously unknowns non crashing functional bugs.
among all true positive bugs reported by odin in the apps of the randoms group we reported five previous unknown bugs listed in column new in table by excluding bugs already in the issue tracking system.
genie reported four previously unknown bugs two in amaze and two in skytube two of which were also reported by odin .
developers confirmed all these previously unknown bugs.
discussions .
for rq1 bug finding we argue that odin complements genie and the major limitation of odin is the unavailability of truly massive traces that thoroughly manifests app behaviors for all gui model states.
for the bugs detected by both odin and genie we found that they indeed fall into the scopes of both tools.
specifically we founddetecting non crashing functional bugs in android apps via deep state differential analysis esec fse november singapore singapore table comparison results between different variants of odin on the randoms id subjectinputs odin odin nocalib odin simple input state cov tp report new cov tp report tp report wikipedia .
.
.
.
.
antennapod .
.
.
.
.
ankidroid .
.
.
.
.
amaze .
.
.
.
.
and bible .
.
.
.
.
anymemo .
.
.
.
.
markor .
.
.
.
.
materialistic .
.
.
.
.
transistor .
.
.
.
.
skytube .
.
.
.
.
aard2 .
.
.
.
.
summary .
.
.
.
.
1column idlists the id of each subject in table .
the numbers of generated test inputs and gui model states in the mined model are displayed in column input and state respectively.
for the three variants odin with calibration odin nocalib and odin simple column cov lists the state coverage of the gui model odin simple shares the same number as odin column tp report displays the numbers of true positive all reports for each subject and the tp rate in the brackets and column displays the numbers of detected distinct bugs.
for the standard version of odin column new additionally lists the number of detected previously unknown bugs.
that these bugs are rare of occurrences and lead to violations of metamorphic relations utilized by genie.
for the bugs detected by odin but not genie we found most of them are beyond genie s independent assumption.
two comparable gui layout sequences can be obtained by executing a single functionality of the app and executing it sequentially after executing another functionality independent from it.
genie designs metamorphic relations between these sequences and identifies violations of these relations caused by the incorrect inference between executing the two independent functionalities.
though effective many bugs does not concern such incorrect inferences and thus may escape genie s detection.
for instance genie failed to detect the motivating bug example in figure .
on contrast odin successfully reported this previously unknown functional bug.
the other three functional bugs missed by genie require complex event sequences to manifest which genie failed to generate.
for the bugs reported by genie but not odin many of them were due to the corresponding gui model states were not covered.
a gui model state is covered if odin finishes manifesting behaviors and mining may beliefs for it.
as table shows even with emulators and hours odin could only cover a small portion of the gui model states .
because executing a test input is extremely time consuming .
as a qualitative and supplementary experiment we gave odin sufficient time hours to cover all gui model states on activitydiary a relatively small app among all experimental subjects and three of four missed bugs were correctly identified by the belief mining.
therefore efficient test execution mechanisms could be a potential research direction for enhancing odin .
there are also missed bugs because test input generators failed to manifest them.
therefore more effective test input generators also benefits odin in bug finding.
finally we found a fraction of bugs missed by odin were manifested by a considerable fraction of test inputs reaching the corresponding gui model states because calibration procedure did not generate enough additional inputs for these models which hidedeep in the gui model.
these bugs were thus regarded as normal behaviors instead of anomalies.
this suggests that the calibration procedure may be further improved in the future.
.
evaluation results test input calibration as shown in table if the calibration procedure is disabled odinnocalib bugs are missed and we do not observe significant changes to the gui model state coverage and true positive rate.
all these missed bugs are are due to the skewed distributions of automatically generated test inputs the erroneous gui model states occurred too frequently in the traces to be identified as deviant behavior.
.
evaluation results may belief mining as shown in table bug finding capability is significantly reduced if we adopt a trivial clustering algorithm odin simple that adopts a fixed abstraction criteria and uses the mean and standard deviation of all clusters to calculate z scores indicating that our hierarchical clustering and anomaly detection algorithm is effective in mining may beliefs and detecting anomalies.
specifically bugs are missed because either odinsimple over or under abstracted the gui layouts and incorrectly clustered normal and anomaly behaviors together or put similar behaviors into different clusters or the clusters were too few and the anomaly ones largely affected the z scores.
.
evaluation results false positives and duplicated bug reports false positives .
as shown in table approximately of odin s bug reports are false positives.
furthermore there may also be duplicated bug reports on the same root cause.
the root causes of false positives are imprecise gui layout model .
we adopted the swifthand s algorithm for gui state model construction and semantically dissimilar states may be erroneously groupedesec fse november singapore singapore jue wang yanyan jiang ting su shaohua li chang xu jian lu and zhendong su together.
this is a fundamental limitation for any gui layoutbased approach and this limitation may be alleviated by developer provided models.
rare but normal behaviors .
some functionalities of an app are hidden deep and require a complex input to exercise making our test input calibration procedure insufficient.
increasing the runtime of test calibration will yield more balanced test inputs for these states.
unstable replay .
how to stably replay an execution trace is another open challenge .
operations such as network accessing can have non deterministic latent effect on the app s execution leading to rare but correct behaviors.
this can be tackled with more advanced trace replay techniques.
duplicated reports .
we manually analyzed the gui execution traces and related code of true reports to determine whether they are duplicated.
as shown in table odin can produce duplicated reports bug reports revealing .
distinct bugs per app .
discussions .
despite the relative high false positive rates and the existence of duplicated reports we believe that they do not significantly hinder the practical benefits of odin for finding otherwise hard to detect bugs.
first in our evaluation odin has already significantly narrowed down the scope for manual examination by filtering out .
of the traces traces were generated for each app and there were reports .
we manually examined all the remaining traces several hours for each app resulting in .
bugs per app.
considering that we found previously unknown bugs in well tested apps such an effort is worthwhile and reasonably moderate.
for example the file managing app amaze has manually written regressions test cases which evolved over time.
nonetheless odin detected a previously unknown bug shown in fig in its frequently used functionality which can severely affect user experience.
the developers quickly fixed the bug in the first revision after confirming our report and explicitly documented it in the changelog for v3.
.
.
furthermore there are opportunities to further reduce human labor for practical usage one can first fix a bug detected by odin and then eliminate its duplicates by checking the remaining traces against the patched app.
as bug duplication for noncrashing functional bugs is still a challenging open issue this is the typical process currently adopted in practice .
better visualization of test cases odin used a simple visualization and test case triaging can reduce the time for checking a trace.
checking a trace often takes less than one minute for a developer familiar with the app.
such limitations may also be alleviated by future research on reducing false positives and duplication.
.
evaluation results bug types the bugs found by odin are categorized as follows incorrect inferences between event handlers .
an app can be exercised in different scenarios in some of which multiple dependent or independent event handlers that may incorrectly affect each other s execution can be invokedsimultaneously or sequentially.
for example transistor provides search suggestions if more than three characters are entered in the search bar.
however a race condition incorrectly results in app denial of service without a crash if a user quickly deletes the characters before search suggestions are returned.
improperly handled data format .
an app can have functionally similar reactions to different data formats and some case handler code may be buggy.
for example antennapod cannot properly process a subscribed podcast when its metadata is in a less popular csv format and incorrectly recognizes audios in the podcast as videos.
general coding mistakes some non crashing functional bugs are the results of general coding mistakes e.g.
third party library misuse or incorrect program logic.
incompletely implemented functionalities .
due to tight development schedule some rarely used functionalities of an app may leave unimplemented e.g.
untranslated texts on rarely used languages.
.
discussions finding non crashing functional bugs .
finding hidden noncrashing functional bugs in an app is far from trivial.
many bugs including the five previously unknown ones are from well maintained apps some are even from apps with extensive manual test cases e.g.
ankidroid contains over manually written ui unit test cases with assertions for correctness checking .
considering the challenges even for experienced developers to find such non crashing functional bugs the runtime overhead for generating and calibrating massive traces and false positives could be acceptable for developers.
existing non crashing functional bug oracles .
before odin non crashing functional bugs can be automatically detected by differential based metamorphic relations.
thor and setdroid perturb a trace by injecting neutral event sequences.
genie extends this idea by injecting a likely independent in app operations.
metamorphic testing is a fundamentally different scope compared with odin and thus we compared only with the state of the art technique genie .
threats to validity .
the representativeness of selected test subjects can affect the fidelity of our conclusions.
to mitigate this threat we selected additional evaluation subjects from popular benchmarks evaluated in existing work.
these subjects are large in size around kloc on average well maintained containing thousands of revisions and hundreds of issues on average popular all have 10k downloads and diverse in categories.
moreover we selected the exact same versions of subjects used to evaluate genie to provide a direct comparison.
the evaluated techniques including odin involve randomness and subjects may be non deterministic.
to mitigate this threat the bootstrapping test input generation tools for both genie and odin were given sufficient time to cover almost all states they can explore.
moreover we manually analyzed the reported bugs and identified that most odin unique bugs are due to fundamental limitations of genie thus unlikely to be found by genie on independent runs and many genie unique bugsdetecting non crashing functional bugs in android apps via deep state differential analysis esec fse november singapore singapore might be found by odin because the specific gui states were not explored no clustering performed and thus no bug reports before odin s timeout.
therefore we believe that randomness is not a primary threat to validity and odin and genie are indeed complementary to each other.
the bug reports of odin and genie were manually analyzed to determine whether they are true positives.
moreover we manually identified distinct detected bugs and their root causes.
this may incur imprecision.
to mitigate this threat three authors of this paper conduct independent examination on all the reports and cross check to ensure correctness.
related work detecting non crashing functional bugs in android apps .
a few pieces of work proposed for fully automatically detecting non crashing functional bugs in android apps without given oracles.
inspired by metamorphic testing both genie and setdroid design heuristic metamorphic relations between app execution results and cross check for relation violations to detect non crashing functional bugs.
for instance setdroid utilizes the metamorphic relation that if one changes the system settings and immediately changes them back the follow up execution of the app should not be affected.
though effective these metamorphic relations all have a strong emphasize on the independence of two event fragments and many functional bugs fall out of these oracles scopes.
as our evaluation results show genie missed many bugs because they do not lead to relation violations.
diffdroid on the other hand is inspired by differential testing and cross checks for execution inconsistencies on different devices.
similarly bugs with consistent consequences across devices would escape diffdroid s detection.
our deep state differential analysis does not rely on these symptomatic features of non crashing functional bugs in android apps.
inspired by the bugs as deviant behaviors idea it captures thestatistical features of the bugs.
therefore it can detect bugs with various symptoms and root causes.
as our evaluation results demonstrate our approach well complements existing techniques.
most existing techniques still require manually written oracles and mainly focus on enhancing these oracles detecting abilities.
thor and executes test suites in adverse conditions and check if the manually written assertions still hold.
quantum utilizes manually provided gui models as oracles and accordingly examines app behavior under specific user interactions.
appflow and acat utilize machine learning techniques to combine test inputs and oracles from manually written ones for testing complex app functionalities.
farlead android accepts guilevel formal specifications as manually written linear time temporal logic formulas as oracles.
finally apptestmigrator and craftdroid migrate test inputs and oracles from other apps to examine the functional correctness of the app under test.
these techniques require tremendous manual efforts to provide required oracles or specifications while odin requires no manual guidance.
in conclusion most existing techniques heavily rely on manually provided oracles and specifications to detect non crashing functional bugs while a few fully automated ones detect specific types of non crashing bugs.
this motivates the design of odin .detecting non crashing functional bugs in traditional guibased softwares .
for traditional gui based programs such as web applications and desktop programs manually provided oracles also play an essential role for detecting non crash functional bugs.
for instance memon et al.
proposed a series of work that derive oracles for desktop programs from manually provided gui models or specifications.
these techniques cannot be directly applied to android apps and they still require manual guidance.
the must may belief .
the classic must may belief was proposed by engler et al.
for detecting functional bugs in operating systems as deviant behaviors.
be a generic methodology the must may belief has been utilized in various research topics including specification mining race detection fault localization etc.
a few techniques infer must beliefs from manually written oracles for detecting non crashing functional bugs in android apps.
for instance thor infers must beliefs that if a test case passes the manually written assertions inserting a neutral action e.g.
rotating the screen and back into the test case should not change the outcome.
to the best of our knowledge we are the first to fully automatically infer may beliefs for detecting non crashing functional bugs in android apps without given oracles.
conclusion leveraging the insight that a large number of traces obtained by executing automatically generated test inputs can reach a similar gui layout and only a small portion of them reach erroneous app states this paper presents a generic novel and automatic oracle named deep state differential analysis for detecting non crashing functional bugs in android apps by manifesting both normal and deviant app behaviors via extending calibrated test inputs and clustering them to mine may beliefs and detect anomalies.
we implemented our technique into a exploratory prototype odin and the evaluation results demonstrate that odin can effectively detect non crashing functional bugs in real world android apps a considerable portion of them cannot be detected by existing techniques.
as a first exploratory work the deep state differential analysis technique provides an new direction for detecting non crashing functional bugs.
based on the proof of concept prototype a diverse range of technologies can be applied in the future enhancement of this technique.
promising research directions include utilizing information in the traces beyond gui layouts such as app logs and method invocation sequences to calibrate automatically generated test inputs and mine may beliefs and human in the loop approaches to filter out false positive results.