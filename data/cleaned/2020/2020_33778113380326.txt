revealing injection vulnerabilities by leveraging existing tests katherine hough1 gebrehiwet welearegai2 christian hammer2and jonathan bell1 1george mason university fairfax va usa 2university of potsdam potsdam germany khough2 gmu.edu welearegai uni potsdam.de hammer cs.uni potsdam.de bellj gmu.edu abstract codeinjectionattacks liketheoneusedinthehigh profile2017 equifaxbreach havebecomeincreasinglycommon nowranking 1onowasp slistofcriticalwebapplicationvulnerabilities.static analysesfordetectingthesevulnerabilitiescanoverwhelmdevelopers with false positive reports.
meanwhile most dynamic analyses relyondetectingvulnerabilitiesastheyoccurinthefield whichcan introduce a high performance overhead in production code.
this paper describes a new approach for detecting injection vulnerabilitiesinapplicationsbyharnessingthecombinedpowerof human developers test suites and automated dynamic analysis.
our new approach rivulet monitors the execution of developerwritten functional tests in order to detect information flows that may be vulnerable to attack.
then rivulet uses a white box test generationtechniquetorepurposethose functionalteststocheck if any vulnerable flow could be exploited.
when applied to the versionofapachestrutsexploitedinthe2017equifaxattack rivulet quicklyidentifiesthevulnerability leveragingonlytheteststhat existedinstrutsatthattime.wecomparedrivulettothestate ofthe artstaticvulnerabilitydetector juliaonbenchmarks finding thatrivuletoutperformed juliainbothfalsepositivesandfalse negatives.
we also used rivulet to detect new vulnerabilities.
ccs concepts securityandprivacy vulnerabilitymanagement web application security software and its engineering software testing and debugging.
keywords injection attacks vulnerability testing taint tracking acm reference format katherinehough gebrehiwetwelearegai christianhammerandjonathan bell.
.
revealing injection vulnerabilities by leveraging existing tests.
in42nd international conference on software engineering icse may seoul republicofkorea.
acm newyork ny usa 13pages.
introduction inthehigh profile2017 equifaxattack millionsofindividuals private data was stolen costing the firm nearly one and a halfbilliondollars in remediation efforts .
this attack leveraged acode injection exploit in apache struts cve and is permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
one of over similar code injection exploits discovered in recentyearsinpopularsoftware .codeinjectionvulnerabilities havebeenexploitedinrepeatedattacksonuselectionsystems in the theft of sensitive financial data and in the theft of millions of credit card numbers .
in the past several years code injection attacks have persistently ranked at the top of the open web application security project owasp top ten most dangerous web flaws .
injection attacks can be damaging evenforapplicationsthatare nottraditionallyconsideredcritical targets such as personal websites because attackers can use them as footholds to launch more complicated attacks.
in a code injection attack an adversary crafts a malicious input that gets interpreted by the application as code rather than data.theseweaknesses injectionflaws aresodifficulttodetectthat rather than suggesting testing as a defense owasp suggests thatdeveloperstrytoavoidusingapisthatmightbetargetedby attackersaltogetheror enforcesite wideinputfiltering.consider againtheequifaxhack theunderlyingweaknessthatwasexploited was originally introduced in and sat undetected in production aroundtheworld notjustatequifax for sixyears .while someexpertsblameequifaxforthesuccessfulattack apatchhadbeenreleasedtwomonthspriortotheattack butwasnotapplied one really has to ask how is it possible that critical vulnerabilities go unnoticed in production software for so long?
withtheexceptionofsafety criticalandsimilar high assurance software generalbestpracticescallfordeveloperstoextensively testtheirapplications toperformcodereviews andperhapstorun staticanalyzerstodetectpotentiallyweakpartsoftheirsoftware.
unfortunately testingisanever endingprocess howdodevelopers knowthatthey vetrulytestedallinputscenarios?tocatchcode injectionexploitsjust in time researchershaveproposeddeployingdynamictainttracking frameworks whichtrackinformationflows ensuringthatuntrustedinputsdonotflowintosensitivepartsof applications e.g.
interpreters .
however these approaches have prohibitive runtime overheads even the most performantcanimposeaslowdownofatleast10 andoftenfar more .
although black box fuzzers can be connected withtainttrackingtodetectvulnerabilitiesinthelab itisdifficultto use these approaches on stateful applications or those that require structured inputs .
while some static analysis tools have seen recent developeradoption statically detecting code injection vulnerabilities is challenging since static analysis tools must perform interprocedural data flow analysis .
our key idea is to use dynamic taint tracking before deployment toamplifydeveloper writtenteststocheckforinjectionvulnerabilities.theseintegrationteststypicallyperformfunctionalchecks.ourapproachre executestheseexistingtestcases mutating values thatarecontrolledbyusers e.g.
partsofeachofthetest shttp requests and detecting when these mutated values result in real ieee acm 42nd international conference on software engineering icse attacks.
to our knowledge this is the firstapproach that combines dynamic analysis with existing tests to detect injection attacks.
key to our test amplification approach is a white box contextsensitiveinput generation strategy.
for each user controlled value state of the art testing tools generate hundreds of attack strings to testtheapplication .byleveragingthecontextof how that user controlled value is used in security sensitive parts of the application wecantriviallyruleoutmostofthecandidateattack stringsforanygivenvalue reducingthenumberofvaluestocheck by orders of magnitude.
our testing based approach borrows ideas from both fuzzing and regression testing and is language agnostic.
weimplementedthisapproachinthejvm creatingatoolthatwe callrivulet.rivuletrevealsinjectionvulnerabilitiesbyleveragingexistingtests anddoesnotrequireaccesstoapplicationsource code and runs in commodity off the shelf jvms integrating directly with the popular build automation platform maven.
likeanytesting basedapproach rivuletisnotguaranteedto detect all vulnerabilities.
however rivulet guarantees that every vulnerability that it reports meets strict criteria for demonstrating an attack.
we found that rivulet performed as well as or betterthan a state of the art static vulnerability detection tool o n severalbenchmarks.rivuletdiscoverstheapachestrutsvulnerability exploited in equifax hack within minutes.
when we ran rivulet with the open source project jenkins rivulet found apreviouslyunknowncross sitescriptingvulnerability whichwasconfirmedbythedevelopers.ontheeducationalproject itrust rivuletfound5previouslyunknownvulnerabilities.unlikethe state of the artstaticanalysistoolthatweused julia rivulet did not show anyfalse positives.
using dynamic analysis to detect injection vulnerabilities before deployment is hard and we have identified two key challenges that have limited past attempts unlike static analysis dynamic analysis requires a representative workload to execute the application under analysis and for each potential attack vector there may be hundreds of input strings that should be checked.
rivulet addressesthesechallenges makingthefollowingkeycontributions a technique for re using functional test cases to detect security vulnerabilities by modifying their inputs and oracles context sensitivemutationalinputgeneratorsforsql ognl and xss that handle complex stateful applications embedded attack detectors to verify whether rerunning a test with new inputs leads to valid attacks rivulet is publicly available under the mit license .
background and motivating example injectionvulnerabilitiescomeinavarietyofflavors asattackers may be able to insert different kinds of code into the target application.perhapsthemostclassictypeofinjectionattackis sql injection sqli whereattackerscancontrolthecontentsofansql statement.
for instance consider this java like code snippet that is intendedtoselectandthendisplaythedetailsofauserfromadatabase execquery select from users where name name .
ifanattackercanarbitrarilycontrolthevalueof thenamevariable thentheymayperformasqlinjectionattack.
forinstance theattackercouldsupplythevalue name bob or which whenjoinedtothequerystringwillproduce wherename bob or whichwouldresultin allrowsin this user table being selected.
sqli attacks may result in data breaches denial of service attacks and privilege escalations.
remote code execution rce vulnerabilities are a form of injectionvulnerabilitieswhereanattackercanexecutearbitrarycode on an application server using the same system level privileges as the application itself.
command injection attacks are a particularly dangerous form of rce where an attacker may directly execute shellcommandsontheserver.otherrceattacksmaytargetfeatures of the application runtime that parse and execute code in other languages such as j2ee el or ognl .
cross sitescripting xss vulnerabilitiesaresimilartorce but resultincodebeingexecutedbyauser sbrowser ratherthanon theserver.xssattacksoccurwhenausercancraftarequestthat inserts arbitrary html javascript code or both into the response returnedbytheserver sideapplication.
suchanattackmighthijack a user ssession allowingthe attackerto impersonatethe useron that website steal sensitive data or inject key loggers.
server side xssattacksmaybe reflectedorpersistent.reflectedxssattacksare typically used in the context of a phishing scheme where a user is sent a link to a trusted website with the attack embedded in the link.
persistent xss attacks occur when a payload is stored in the host system e.g.
in a database and is presented to users who visit the compromised site.
developersdefendtheirsoftwarefrominjectionattacksthrough input validation and sanitization.
broadly validation is a set of whitelistingtechniques suchas onlyacceptinputsthatmatcha limited set of characters while sanitization is a set of transformations that render attacks harmless such as escape all quotationmarks in user input.
ideally each user controlled input also referred to as a tainted source that can reach critical methods that may result in code execution also referred to as a sensitive sink willbeproperlysanitized validated orboth.reachingsuchanideal stateisnon trivial .hence thekeychallengeindetectingthese vulnerabilitiesistodetectflowsfromtaintedsourcestosensitive sinks that have not been properly sanitized.
listing1showsasimplifiedexampleoftwogenuinecross site scriptingvulnerabilities.lines9and10showaparameterprovidedbytheuserflowingintotheresponsesentbacktothebrowser withoutpropersanitization.inthefirstcase line9 thevulnerability occurs despite an attempt to sanitize the user s input using the apachecommons languagelibraryfunction escapehtml4 and in the second case line there is no sanitization at all.
override 2public void doget httpservletrequest request httpservletresponse response throws ioexception 3string name request.getpa rameter name 4response.se tcontenttype text html 5string es caped stringescapeutils.
escapehtml4 name 6string co ntent a href s hello a 7try printwriter pw response.
getwriter 8pw.println html body 9pw.println st ring.format con tent escaped 10pw.println st ring.format con tent name 11pw.println body html listing1 twoexamplexssvulnerabilities.
anuntrusteduser inputfromanhttprequestflowsintotheresponsetothebrowser on lines and .
.
attack detection .
candidate test detection ... ... .
warning!
execute test with dynamic taint tracking !
!
.
rivulet request interceptor !
!
.
app under test2.
rerun generation 2rerun config http response value 2run original test suite with taint tracking and collect resultspotentially vulnerable tests and flows rerun each test with substitutionssource sink values and flows from reruns source .
sink http response value vulnerability not confirmed contained in a comment vulnerability confirmed by rerun!
vulnerability reproduction script figure high level overview of rivulet.
rivulet detects vulnerabilities in three phases.
key to our approach is the repeated execution of developer provided test cases with dynamic taint tracking.
first each developer provided test is executed using taint tracking to detect which tests expose potentially vulnerable data flows.
http requests made during a test are intercepted and parsed into their syntacticelementswhicharethentaintedwithidentifyinginformation.then source sinkflowsobservedduringtestexecutionarerecorded and passed with contextual information to a rerun generator.
the rerun generator creates rerun configurations using the supplied flow and contextual information and executes these reruns swapping out developer provided inputs for malicious payloads.
source sink flows observedduringtestre executionarepassedtoanattackdetectorwhichverifiessource sinkflowsthatdemonstrategenuinevulnerabilities.
in either case providing the input string javascript alert xss for the parameter name will result in javascript code executing in the client s browser if they click on the link.
the chosen sanitizer escapes any html characters in the input string i.e.
preventing an injection of a script tag but isinsufficient forthiscase asanattackerneedonlypasstheprefix javascript intheirpayloadtocausecodetoexecutewhentheuserclickson this link many xss attack payloads do not include brackets or quotes for this reason .
tofix thisvulnerability thedeveloperneedsto applyasanitizingfunctionthatpreventstheinsertionofjavascriptcode.static analysistools suchasthestate of the artjuliaplatform typicallyassumethatlibrarymethodspre definedassanitizersfora class of attack e.g.
xss sanitizers eliminate vulnerabilities for the dataflowsthattheyare appliedto.inourtesting basedapproach sanitizer methods do not need to be annotated by users.
instead we test whether a flow is adequately sanitized by attempting to generate a counterexample i.e.
a malicious payload that produces a successful injection attack .
approach overview generatingteststhatexposetherichbehaviorofcomplicated statefulwebapplicationscanbequitedifficult.forinstance consideravulnerabilityinahealthrecordsapplicationthatcanonly be discovered by logging in to a system submitting some health data and sending a message to a healthcare provider.
fuzzers have longstruggledtogenerateinputsthatfollowamulti stepworkflow likethisexample .instead rivuletbeginsbyexecutingthe existing ordinary test suite that developers have written whichdoesnotneed to have any security checks included in it in this healthcaremessaging example an existing testmight simplycheck that the workflow completes without an error.
as we showin our evaluation even small test suites can be used by rivulet to detect vulnerabilities.
figure shows a high level overview of rivulet s three step processtodetectinjectionvulnerabilitiesinwebapplications.first rivulet uses dynamic taint tracking while running each test toobserve data flows from sources untrusted system inputs controlledbyapotentiallymaliciousactor to sinks sensitivepartsof anapplicationthatmaybevulnerabletoinjectionattacks.these source sink flows do not necessarily represent vulnerabilities it is possible that a sanitizer function correctly protects the application.
hence when a source sink flow is observed rivulet generatesmalicious payloads based on contextual information of the sinkmethod.
then tests are re executed and those untrusted source valuesarereplacedwithgeneratedpayloads probingforweakor missing sanitizers.
lastly specialized logic based on the type of vulnerability e.g.
xss is used as an oracle to determine whether a re execution demonstratesa successfulattack thereby transforming a functional test into a security test.
in thisway source sink flowsare verifiedas vulnerable onlyif asuccessfulattackcanbedemonstratedusingaconcreteexploit.
this standard produces few false positives.
test reruns enable our technique to consider input sanitization and validation without requiringsanitizationandvalidationmethodstobeexplicitlyspeci fiedormodeled.verifyingwhetherasanitizerorvalidatoriscorrect in all cases is a hard problem and beyond the scope of this work.
however if a system sanitizes or validates input improperly before it flows into a sink method then one of the malicious payloadsmay be able to demonstrate a successful attack causing the flowto be verified.
our implementation of rivulet described in automatically detects sql injection remote code execution and cross site scripting vulnerabilities developers do not need to specifyanyadditionalsourcesorsinksinordertofindthesekindsof vulnerabilities.section4describes indetail thespecificstrategy that rivulet uses to find these kinds of vulnerabilities.
.
detecting candidate tests rivuletco optsexisting functionaltestcasestotestforsecurity properties by mutating user controlled inputs and adding securitybasedoraclestodetectcodethatisvulnerabletoinjectionattacks.
we assume that developers write tests that demonstrate typical applicationbehavior andourapproachreliesonautomatedtestingtodetectweakormissingsanitization.thisassumptionisgroundedin 286bestpracticesforsoftwaredevelopment weassumethatdevelopers willimplementsomeformofautomatedfunctionaltestingbefore scrutinizingtheirapplication forsecurityvulnerabilities.
rivulet detects candidate tests by executing each test using dynamic taint tracking identifyingteststhatexposepotentiallyvulnerablesourcesink flows each of whichwe refer toas a violation.
byleveraging developer tests our approach can detect vulnerabilities that can only be revealed through a complex sequence of actions.
these vulnerabilities can be difficult for test generation approaches to detect but are critical when dealing with stateful applications .
in this model developers do notneed to write test cases that demonstrateanattack instead theyneedonlywritetestcases that expose an information flow that is vulnerable to an attack.
for instance consider a recent apache struts vulnerability cve thatalloweduser providedwebforminputtoflowdirectly into the object graph navigation language ognl engine.
struts includes a sample application for keeping track of the names of differentpeople thisapplicationcanbeusedtodemonstratethis vulnerability by placing an attack string in the save person form.
todetectthisvulnerability wedo notneedtoobserveatestcase thatusesanattackstringintheinput instead weneedonlyobserveanytestthatsaves anystringthroughthisforminordertoobserve the insecure informationflow.
once this isdetected rivulet can thenre executeandperturbthetestcase mutatingthevalueofthe form field eventually demonstrating the exploit.
.
rerun generation and execution the next phase in rivulet s vulnerability detection process is to re execute each test perturbing the inputs that the serverreceivedfromthetestcaseinordertoaddmaliciouspayloads.a significantchallengetoourapproachisinthepotentiallyenormous number of reruns that rivulet needs to perform in order to test each potentially vulnerable source sink flow.
if an application has thousands of tests each of which may have dozensof potentially vulnerableflows itiscrucialtolimitthenumberoftimesthateach test needs to be perturbed and re executed.
unfortunately it istypical to consider over 100different malicious xss payloads for eachpotentially vulnerable input and other attacks may still call for dozens of malicious payloads.
instead rivuletusesawhite box insituapproachtopayload generation in order to drastically reduce the number of reruns needed to evaluate a source sink flow.
successful injection attacks oftenneedtomodifythesyntacticstructureofaquery documentorcommandfromwhatwasintendedbythedeveloper .bylooking at the placement of taint tags representing each source within structuredvaluesthatreachsinkmethods i.e.
thesyntacticcontext intowhichuntrustedvaluesflow thenumberofpayloadsneeded totestaflowcanbelimitedtoonlythosecapableofdisruptingthat structure from the tainted portions of the value.
for instance when an untrusted value reaches a sink method vulnerabletosqlinjectionattacks developersusuallyintendfor thevalue tobetreated asastring ornumericliteral.
considerthe followingsqlquery select fromanimals wherename tiger wheretheword tigerisfoundtobetainted.inorder to modify the structure of the query a payload must be able to end the single quoted string literal containing the tainted portion of the query.
payloads which do not contain a single quote would beineffective in this context e.g.
payloads that aim to end doublequotedstringliterals anddonotneedtobetestedwhenevaluating this flow.
rivulet uses a similar approach for generating payloads for other kinds of attacks as we will describe in .
.
.
attack detection theattackdetectorcomponentprovidestheoracleforeachmodifiedtest removinganyexistingassertions determiningifthenewinputresultedinasuccessfulattackonthesystemundertest.thereisanaturalinterdependencebetweenpayloadgenerationandattackdetection.attackdetectionlogicmustbeabletodeterminethesuc cess of an attack using any of the payloads that could be generated by rivulet.
likewise generated payloads should aim to trigger a successfuldeterminationfromthedetectionlogic.thisrelationshipcanbeusednotonlytoguidepayloadgeneration butalsotoenable stricter andsimplertoimplement criteriafordeterminingwhat constitutes a successful attack.
specifically it is not necessary torecognize all possible successful attacks but instead only those generatedbythesystem.furthermore thisreducesthedifficulty of formulating an appropriate detection procedure particularly for certaintypesofattacks.rivulet sattackdetectorsinspectboththe taint tags and concrete values of data that reaches sensitive sinks.
implementation our implementation of rivulet for java is built using the phosphor taint tracking framework and automatically configures thepopularbuildandtestmanagementplatform maventoperform dynamic tainttracking during the executionof developer written tests generatemaliciouspayloadsbasedonsource sinkflowsobservedduring testexecution andexecute testreruns.developers can use rivulet by simply adding a single maven extension totheir build configuration file rivulet and maven automatically configuretherest.outofthebox rivuletdetectscross sitescript ing sql injection and ognl injection vulnerabilities without any additional configuration.
phosphor propagates taint tags by rewriting java bytecode using the asm bytecode instrumentation andanalysis framework and does not require access to application orlibrary sourcecode.
we chose phosphorsince itis capable ofperformingtainttrackingonalljavadatatypes ensuringthat rivuletisnotlimitedinitsselectionofsourceandsinkmethods to only methods that operate on strings.
.
executing tests with dynamic tainting rivulet s approach for dynamic taint tracking within test cases is key to its success.
taint tracking allows data to be annotated with labels or taint tags which are propagated through data flows as the application runs.
it is particularly critical to determine wherethese tags are applied the source methods and how they correspondtotheactualinputthatcouldcomefromauser since itisatthesesamesourcemethodsthatrivuletinjectsmalicious values when rerunning tests.
manyapproachestoapplyingtainttrackingtohttprequests in the jvm use high level java api methods as taint sources such asservletrequest.getparameter for parameters or for cookies httpservletrequest.getcookies .however theseapproachescanbebrittle ifasinglesourceismissedoranew version of the application engine is used which adds new sources 287theremaybefalsenegatives.moreover sinceapplicationmiddleware between the user s socket request and these methods performs parsing and validation mutating these values directly could resultinfalsepositiveswhenreplayingandmutatingrequests.if rivulet performed its injection afterthe middleware parses the http request from the socket i.e.
as a user application reads a value from the server middleware rivulet might generate somethingthatcouldneverhavepassedthemiddleware svalidation.for instance ifperformingareplacementonthemethod getcookies rivulet might try to generate a replacement value name alert string.fromcharcode whichcould neverbeavalid returnvaluefromthismethodsource sincehttpcookiesmaynot contain commas .
instead of using existing java methods as taint sources rivulet uses bytecode instrumentation to intercept the bytes of http requestsdirectlyastheyarereadfromsockets.interceptedbytesare then buffered until a full request is read from the socket.
requests readfromthesocketareparsedintotheirsyntacticelements e.g.
querystring entity body andheaders.eachelementthenpasses throughataintsourcemethodwhichtaintsthecharactersofthe element with the name of the source method the index of the characterintheelement andanumberassignedtotherequestthat was parsed.
the original request is then reconstructed from the taintedelementsandbrokendownbackintobyteswhicharepassed totheobjectthatoriginallyreadfromthesocket.thistechnique allowsataintedvaluetobetracedbacktoarangeofindicesina syntacticelementofaspecificrequest.thus thistaintingapproach enables precise replacements to be made during test re executions.
we have integrated rivulet with the two most popular java http servers tomcat andjetty using bytecodemanipulation.rivuletmodifiescomponentsintomcatandjettywhich make method calls to read bytes from a network socket to instead passthe receiverobject i.e.
thesocket andargumentsofthecall to the request interceptor.
the interceptor reads bytes from anysocket passed to it parses the bytes into a request and taints the bytesbasedontheirsemanticlocationwithintheparsedrequest.
itwouldbeeasytoaddsimilarsupporttootherjavawebservers however tomcat and jetty are the most popular platforms by far.
.
rerun generation rivuletusesaneasy to reconfigure predefinedsetofsinkmethods whichweenumeratebyvulnerabilitytypebelow.whenasink methodiscalled theargumentspassedtothecallarerecursively checked for taint tags i.e.
arguments are checked the fields of the arguments are checked the fields of the fields of argumentschecked and so on until to a fixed maximum checking depth isreached.
if a tainted value is found during the checking process a source sink flow is recorded.
when rivulet finishes checking theargumentsofthecall itpassescontextualinformationandflow information to a generator that handles the type of vulnerabilityassociated with the sink method that was called.
the contextual information consists of the receiver object of the sink method call and the arguments of the call.
the flow information consists of the sourceinformationcontainedinthelabelsofthetaintedvaluesthat were found and a description of the sink method that was called.
rerun generators create rerun configurations identifying the testcasethatshouldbererun thedetectorthatshouldbeusedtodetermine whether a successful attack was demonstrated by the rerun theoriginalsource sinkflowthatthererunistryingtoverify andatleastonereplacement.replacementsdefineareplacement value information used to identify the source value that should be replaced targetinformation andpossiblya strategy forhowthe source value should be replaced.
a replacement can either be built as a payload replacement or a non payload replacement.
payload replacements are automatically assigned target informationandsometimesastrategybasedonflowinformation.for example thelabelsonataintedvaluethatreachedsomesinkmight show that the value came from indices of the second call tothesource getquerystring .onepayloadreplacementbuilt off of that flow information would direct that the second time getquerystring iscalledthatitsreturnvalueshouldbereplaced usingastrategythatreplacesonlyindicessixthroughtenwithare placementvalue.payloadreplacementsarehowmaliciouspayloadsarenormallyspecified thuseveryrerunisrequired tohaveatleast oneofthem.non payloadreplacementsareusefulforspecifying secondary conditions that an attack may need in order to succeed such as changing the content type header of a request.sqlinjection.
thererungeneratorforsqlinjectionusesall java .sql.statement andjava.sql.connection methods that accept sqlcodeassinks andconsidersthreeprimarysqlquerycontexts in which a tainted value may appear literals comments likeclauses.
tainted values appearing in other parts of the query aretreated similarly to unquoted literals.
tainted values appearingin like clauses are also considered to be in literals thus causeboth the payloads for tainted literals and tainted like clauses to begenerated.ifataintedvalueappearsinaliteral thegenerator first determines the quoting for the literal.
a literal can be either unquoted likeanumericliteralmightbe single quoted doublequoted orbacktick quoted usedfortableandcolumnidentifiersin mysql .payloads fortaintedliterals areprefixedby astringthat is based on the quoting of the literal in order to attempt to end the literal.thequotingcanalsobeusedtodetermineanappropriate endingforpayloads.ifataintedvalueappearsinacomment the generator first determines the characters used to end and startthe type of comment the value appears in.
payloads for tainted comments are prefixed by the end characters for the comment and ended with the start characters for the comment.
if a tainted value appearsinalikeclause thegeneratorcreatespayloadscontaining sql wildcard characters.
rivulet generates sql injection payloads for a tainted valueinaparticularcontextoutof20uniquepayloadsthatcould begeneratedforthesametaintedvalueacrossallofthecontexts consideredbythesqlinjectionrerungenerator.ifwildcardpayloads for like clause are not generated then only payloads aregeneratedpercontext.thisisareductionfromkie un etal.
s ardilla which uses sql injection patterns and does not consider tainted backtick quoted values comments or like clauses .cross sitescripting.
rivuletusesspecialsinkcheckinglogicfor xss checkingdataasitissentover the wiretothebrowser.the overloadedvariantsof socketchannel.write areusedassink methodsforxssattacks.inordertogivethexssgeneratorallof thehtmlcontentforasingleresponseatonce rivuletstoresthe byteswrittentoasocketuntilafullresponsecanbeparsedfrom thebytes.iftheparsedresponsecontainshtmlcontentandthe 288html in the response s entity body contains a tainted value then that html is passed to the xss rerun generator.
thexssrerungeneratorparseshtmlcontentintoanhtml document model using the jsoup library .
this model is traversed generatingpayloadsforeachtaintedvalueencountered.the xssrerungeneratorconsiders5primaryhtmldocumentcontexts inwhichataintedvaluemayappear tagnames attributenames attribute values text or data content and comments.
different payloadsarecapableofintroducingascript triggeringmechanisminto the document s structuredepending on the context.
rivulet also addressescontext specificissueslikethequotingofattributevalues or whether content is contained in an element which causes the tokenizer to leave the data state during parsing .
thexssgeneratoralsoconsiderswhetherataintedvaluewas placedinacontextthatwouldalreadybeclassifiedasanembedded script or the address of an external script.
furthermore if a tainted value appears in a context that would be classified as an embedded scriptthenthegeneratoralsodetermineswhetherthetaintedvalue is contained within a string literal template literal or comment.
rivulet generates xss payloads for a tainted value in a particular context out of over unique payloads that could begenerated for the same tainted value across all of the contexts consideredbythexssrerungenerator.bycomparison owasp s xss filter evasion cheat sheet features152 unique payloads for cross site scripting attacks and ardilla uses patterns for creating cross site scripting attacks .command and ognl injection.
the command injection rerun generator creates payloads with common unix commands like ls considering java.lang.processbuilder andjava.lang.runtime methods as sinks.
theognlinjectionrerungeneratorcreatespayloadsthatfacilitateattackdetection.itcanbedifficulttospecifygenericcriteriafordetectinganyognlinjectionattackbecausethelanguageisdesigned to allow users to execute non malicious code.
ognl expressionscanmodifyjavaobjects properties accessjavaobjects propertiesandmakemethodcalls .applicationsusingognl can limit the code that user specified expressions can execute by whitelisting or blacklisting certain patterns .
the evaluation of improperly validated ognl expressions can enable a user to executearbitrarycode.theognlrerungeneratorusespayloads that we collected from the exploit database and simplified to integrate more tightly with rivulet s attack detection mechanism.
rerunexecution.
rerunconfigurationscreatedbythererungenerators specify test cases that should be re executed.
values arereplaced when they are assigned a label at a source method andthe information on the label being assigned to the value meetsthe criteria specified by one of the current rerun configuration sreplacements.
replacements may dictate a strategy for replacingthe original value strategies can specify ways of combining anoriginal value with a replacement value a way of modifying the replacementvalue orboth.forexample astrategycouldspecify that only a certain range of indices in the original value should be replaced that the replacement value should be percent encoded orboth.rivuletautomaticallyconvertsvaluestoensurethatthe typeofareplacementvalueisappropriate e.g.
convertingbetween a string and a character array .
.
attack detection rerun configurations specify which vulnerability specific attack detector should be used to check flows during a test re execution.sql injection.
our approach for detecting sql injection attack builds on halfond et al.
s syntax aware evaluation model which calls for checking that all parts of sql queries except for string and numeric literals come from trusted sources .
we determine a sql injection attack to be successful if a tainted sql keyword not contained in a literal or comment is found within a query that reached a sink vulnerable to sql injection.
alternatively an attackisdeemedsuccessfulifasink reachingquerycontainsa likeclause with an unescaped tainted wildcard character i.e.
o r a st h e system could be vulnerable to a sql wildcard denial of serviceattack .theattackdetectorforsqlinjectionusesantlr a parser generation tool and jsqlparser a sql statement parser thatsupports multiple sqldialects to parsesqlstatements that reach sink methods vulnerable to sql injection attacks.cross sitescripting.
theworldwidewebconsortium s w3c s recommendationforhtml5.2specifiesmechanismswhichcan trigger the execution of embedded or external scripts processing of script elements navigating to javascript urls event han dlers processing of technologies like svg that have their own scriptingfeatures .onlythesyntacticcomponentsofanhtml document that are capable of activating a script triggering mechanism are vulnerable to script injections.
as such we determine the successofanxssattackbycheckingthesevulnerablecomponents.
rivulet intercepts and buffers the bytes of http responses untilafullresponsecanbeparsedfromthebytes.then theparsed documentischeckedforcomponentsthatcouldactivateascripttriggeringmechanism.dependingonthemechanismpotentially activated by the component a portion of the component is then classifiedaseitheranembeddedscriptortheaddressofanexternalscript.thefollowingrulesareusedtoidentifyembeddedand external scripts in the response the inner content of every script tagisclassifiedasanembeddedscript.
thehtmlentity decoded value of every src attribute specified for a script tagis classified as an external script s address.
the html entitydecoded value of every href attribute specified for a base tag is classified as an external script s address because of its potential impactonelementsinthedocumentusingrelativeurls.
the htmlentitydecodedvalueofeveryeventhandlerattribute e.g.
onload specifiedforanytagisclassifiedasanembeddedscript.
thehtmlentitydecodedvalueofeveryattributelistedashavingaurlvalueinw3c srecommendationforhtml5.
e.g.
the href attribute isexamined.ifthedecodedvaluestartswith javascript thentheportionofthedecodedvalueafter javascript is classified as an embedded script.
embeddedscriptsarecheckedforvaluessuccessfullyinjected into non literal non commented portions of the script.
to do so theportionsofthescriptthatarenotcontainedinjavascriptstringliterals templateliterals orcommentsarecheckedforapredefined targetstring.thistargetstringisbasedonthemaliciouspayload being used in the current test re execution e.g.
alertis an appropriate target string for the payload script alert script butotherpayloadsmayhavemorecomplicatedtargetstrings.ifthe targetstringisfoundinthenon literal non commentedportions 289of the script and it is tainted then the attack is deemed successful.
sincethetargetstringmustbetaintedtobedeemedasuccessful attack a vulnerability will be reported only if an attacker could inject that target string into the application.
externalscriptaddressesarecheckedforsuccessfullyinjected urls that could potentially be controlled by a malicious actor.
the startofeachaddressischeckedforapredefinedtargeturl.the target url is based on the malicious payload being used in the currenttestre execution.ifthetargeturlisfoundatthestartof an address and is tainted then the attack is deemed successful.
thexssattackdetectorstoresbyteswrittentoasocketbycallsto socketchannel.write untilafullresponsecanbeparsed using jsoup from the bytes stored for a particular socket.
the rules described above are then applied to the document model parsedfrom the entity body.
the embedded script checks are also performed using antlr and a simplified grammar for javascript to identify string literals template literals and comments.command and ognl injection.
a command injection attack is determined to be successful if any tainted value flows into asink vulnerable to command injection such as processbuilder.
command andruntime.exec .additionally ifacallismadeto processbuilder.start the detector will deem an attack successfulifthe command fieldofthereceiverobjectforthecallis tainted.
this relatively relaxed standard is a product of a lack oflegitimate reasons for allowing untrusted data to flow into thesesinks and the severity of the security risk that so presents.
this approach could be fine tuned to perform more complicated argumentparsing similartothexssdetector however inpractice wefounditsufficient producingnofalsepositivesonourevaluationbenchmarks.weuseasimilartactictotestforsuccessfulognl injectionattackssincetheognlpayloadsgeneratedby rivulet are crafted to perform command injection attacks.
.
limitations ourapproachisnotintendedtobecomplete itisonlycapableof detectingvulnerabilitiesfromsource sinkflowsthatareexposedby atestcase.hence rivuletrequiresapplicationstohaveexisting testcases althoughwebelievethatthisisafairassumptiontomake andinourevaluation showthatrivuletcandetectarealvulnera bilityevenwhenpresentedwithaverysmalltestsuite forapache struts .
this limitation could be mitigated by integrating our approachwithanautomatictestgenerationtechnique.vulnerabilities causedbyanondeterministicflowarehardfor rivulettodetect eveniftheflowoccursduringtheoriginaltestrun becausetheflow may fail to occur during the re execution of the test.
rivulet does not detect xss attacks which rely on an open redirection vulnerability .moregenerally rivuletcanonlydetectattacksthatwe have constructed generators and detectors for but this is primarily a limitation of rivulet s implementation and not its approach.
we note thateven static analysistools can only claimsoundness to the extent that their model holds in the code under analysis in our empirical evaluation of a sound static analysis tool we found that the static analyzer missed several vulnerabilities .
.
sincephosphorisunabletotracktainttagsthroughcodeoutside ofthejvm rivuletisalsounabletodoso.asaresult rivulet cannotdetectpersistentxssvulnerabilitiescausedbyavaluestored in an external database but it can detect one caused by a valuestored in java heap memory.
we plan to propose extensions to phosphor to overcome this limitation building off of work demonstrating the feasibility of persisting taint tags in databases in the android based taintdroid system .
at present rivulet can only detect vulnerabilities that result from explicit data flow and notthroughimplicit control flows orside channelssuchastiming alimitationsharedbymostothertools includingjulia .
experimentalsupportforimplicitflowtrackinginphosphormay lift this limitation in the future.
despite these limitations we have found rivulet to be effective at detecting injection vulnerabilities.
evaluation weperformedanempiricalevaluationof rivulet withthegoal of answering several research questions rq1 how does rivulet perform in comparison to a state of theart static analysis tool?
rq2 does rivulet scale to large projects and their test suites?
rq3 howsignificantlydoesrivulet scontextualpayloadgeneration reduce the number of reruns needed?
to answer these questions we applied both rivulet and the state of the art static analysis tool julia to several suites of vulnerabilitydetectionbenchmarks.thesecuratedbenchmarksare intentionallyseededwithvulnerabilities allowingustocompare rivuletandjuliaintermsofbothprecisionandrecall.wewerealso abletouseoneofthesebenchmarkstocomparerivuletagainst six commercial vulnerability detection tools.
these benchmarksallow us to evaluate the efficacy of rivulet s attack generatorsanddetectors butsincetheyaremicro benchmarks theydonot provide much insight into how rivulet performs when applied to real developer provided test suites.
to this end we also applied rivulet to three larger applications and their test suites.
weconductedallofourexperimentsonamazon sec2infrastructure using a single c5d.4xlarge instance with .0ghz intel xeon series cpus and of ram running ubuntu .
xenial andopenjdk1.
.0 222.weevaluatedjuliabyusingthejuliacloud web portal using the most recent version publicly available asofaugust16 .whenavailable forjuliet sqli juliet xss and all of owasp we re use results reported by the julia authors .whenweexecuteditourselves weconfirmedourusage of julia through personal communication with a representative of juliasoft and greatly thank them for their assistance.
.
rq1 evaluating rivulet on benchmarks inordertoevaluatetheprecisionandrecallof rivuletandjulia we turn to third party vulnerability detection benchmarks specifically nist s juliet benchmark version .
owasp s benchmark version .
livshits securibench micro and the application vulnerability scanner evaluation project s wavsep version .
.
each of these benchmarks contains test cases with vulnerabilities that are representative of real vulnerabilities found invariousapplications.fromthesetests wecancollectthenumber of true positives and false negatives reported by each tool.
the benchmarksalsocontaintestcaseswithvariantsofthosevulnerabilities that are notvulnerable allowing us to also collect the number of false positives and true negatives reported by each tool.
each benchmark consists of a series of web servlets and in some cases also non servlet applications that are tests well suited 290table1 comparisonof rivuletandjulia onthird partybenchmarks.
foreachvulnerabilitytypeineachbenchmarksuitewe show the total number of test cases for both true and false alarm tests .
for rivulet and julia we report the number of true positives false positives true negatives false negatives and analysis time in minutes.
times are aggregate for the whole benchmark suite.
test cases rivulet julia suite type true alarm false alarm tpfp tn fn time tpfp tn fn time rce juliet sql xss rce owasp sql xss securibench microsql xss sql 1320100wavsepxss for analysis by a static analyzer like julia.
however rivulet requires executable junit style test cases to perform its analysis.each servlet is designed to be its own standalone application to analyze and they are not stateful.
hence for each benchmark we generatedjunittestcasesthat requestedeachservletoverhttp passingalongsomedefault non maliciousparametersasneeded.
wherenecessary wemodifiedbenchmarkstoresolveruntimeerrors mostly related to invalid sql syntax in the benchmark.
we ignoredseveraltestsfromsecuribench microthatwerenotatall suitabletodynamicanalysis somehadinfiniteloops whichwould notresultinapagebeingreturnedtotheuser andotherwiseincluded only tests for the vulnerabilities targeted by rivulet rce sqli and xss .
most of these benchmarks have only been analyzed by static tools and not executed and hence such issues may nothavebeennoticedbypriorresearchers.fortransparencyand reproducibility allbenchmarkcodeisincludedinthispaper saccompanying artifact .
table1presentsourfindingsfromapplyingbothrivuletand julia to these benchmarks.
rivulet had near perfect recall and precision identifyingeverytruealarmtestcaseasatruepositive but one and every false alarm test case as a true negative.
in three interesting securibench micro test cases the test case was nondeterministicallyvulnerable withsomerandomprobabilitythetestcouldbevulnerableornot.intwoofthesecases rivuleteventually detected the vulnerability after repeated trials the vulnerability was exposed with a probability and was revealed after just several repeated trials .
ho wever in the case that we report a false negative simplified andpresented in listing the probability of anyattacksucceedingonthetestwasjust1 andrivuletcould not detect the vulnerability within a reasonable time bound.
we note that this particularly difficult case does not likely represent a significant security flaw since just like rivulet an attacker cannot control the probability that their attack would succeed.
this testcase likelyrepresentsthe worst casepathologicalapplication that rivulet could encounter.
in comparison julia demonstrated both false positives and false negatives.
many of the false positives were due to julia s lack ofsensitivityformultipleelementsinacollection resultinginovertaintingallelementsinacollection.weconfirmedwithjuliasoft that the tool s false negatives were not bugs and instead generally duetolimitationsinrecoveringexactdynamictargetsofmethod callswhenthereceiverofamethodcallwasretrievedfromtheheap causing it to incorrectly assume a method call to not be a sink.
listing shows an example of one such case where julia reports a vulnerabilityonline3butnotonline6sinceitisunabletopreciselydeterminethedynamic targetofthesecond println.unlike theverytrickynon deterministiccasethatrivuletstruggledto detect wenotethatthisformofdataflowisnotuncommon and thislimitationmaysignificantlyimpactjulia sabilitytodetectxss vulnerabilities in applications that pass the servlet s printwriter between various application methods.
we also collected execution times to analyze each entire benchmark for both tools.
for rivulet we report the total time needed toexecuteeachbenchmark includinganynecessarysetup such as starting a mysql server and for julia we report the execution time from the cloud service.
despite its need to execute thousands of junit tests rivulet ran as fast or faster than julia in all cases.
voiddoget httpservletrequest req h ttpservletresponse resp random r newrandom if r.nextint resp.getwriter .
println req.getpara meter name listing simplified code of the vulnerability rivuletmisses.r.nextint returns one of the 32integers randomly.
1private printwriter writer 2voiddoget httpservletrequest re q httpservletresponse resp 3resp.getwriter .pri ntln req.ge tparameter dummy xss reported on line above 5this.writer resp.getwriter 6this.writer.println req.ge tparameter other no xss reported on line above listing example of a false negative reported by julia 291table2 comparisonbetweenrivuletanddifferentvulnerability detection tools on the owasp benchmark.
for each vulnerabilitytype wereportthetruepositiverateandfalsepositive rate for the tool.
each sast tool is one of checkmarx cxsast coverity code advisor hp fortify ibm appscan parasoft jtest and veracode sast.
rce sql xss tool tpr fpr tpr fpr tpr fpr sast sast sast sast sast sast rivulet most of rivulet s time on these benchmarks was spent on the false positive tests which act as a worst case scenario for its executiontime if rivuletcanconfirmaflowisvulnerablebasedona singleattackpayload then itneednottryotherre runconfigurationsforthatflow.however onthefalsepositivecases rivulet must try every possible payload in the case of xss this is up to although it may also try different encoding strategies for each payload depending on the source .
unfortunately it is not possible to report a direct comparison between rivulet and anycommercial tools except for julia due tolicensingrestrictions.however the ow aspbenchmarkisdistributed with anonymized results from applying six proprietary tools checkmarxcxsast coveritycodeadvisor hpfortify ibm appscan parasoftjtest andveracodesast tothebenchmark and we report these results in comparison to rivulet.
table presents theseresults eachcommercialtoolisanonymized showingthe true positive rate and false positive rate for each tool.
rivulet outperforms each of these commercial static analysis tools in both true positive and false positive detection rates.
.
rq2 rivulet on large applications whilethebenchmarksevaluatedin .1areusefulforevaluating the potential to detect vulnerabilities they are limited in that they are micro benchmarks.
they help us make general claims about how rivulet might perform when applied to an arbitrary application.however sinceeachmicro benchmarkisdesignedtobeeasily executed and indeed we automatically generated tests to execute them itisnotpossibletojudgehowrivuletperformswhenusing existing developer written test cases on real applications.
toprovidemoredetailedresultsonhowrivuletperformson larger realapplications weappliedittothreedifferentopen source java web applications and their existing junit test suites.
itrust is an electronic health record system iteratively developed over25 semesters by students at north carolina state university .
we evaluated itrust version .
the most recent version of itrust1 a newer itrust2 is under development but has far less functionalitythanitrust1 .apriorversionofitrustwasalso usedintheevaluationofmohammadi etal.
sxssattacktestingtool althoughtheauthorswereunabletoprovideadetailedlistofthe vulnerabilitiesthattheydetectedorthespecificversionofitrustused .
we also assessed a recent revision 8349cebb o fjenkins a popular open source continuous integration server using itstestsuite.
strutsisanopen sourcewebapplicationframework library which is used to build enterprise software .
struts is distributed with sample applications that use the framework as wellasjunittestsforthoseapplications.weevaluatedrivuletwith onesuchsampleapplication rest showcase usingstrutsversion .
.20 1 which is known to have a serious rce vulnerability.
table3presentstheresultsofthisexperiment showingforeach projectthenumberoftests andthenforeachinjectioncategorythenumberofvulnerableflows rerunsexecuted rerunsthatsucceededin finding a vulnerability and the number of unique vulnerabilities found.
rivulet reported no false positives.
we briefly discuss the vulnerabilities that rivulet detected in each application below.
initrust rivuletdetectedfivepageswithxssvulnerabilities where a user s submitted form values were reflected back in the page.
while these values were in only five pages each page had multiple form inputs that were vulnerable and hence rivulet reportedatotalof289differentrerunconfigurationsthatdemonstrate these true vulnerabilities.
there were no flows into sql queries in itrust while itrust uses a mysql database it exclusively accesses it through correct use of the preparedstatement api which is designed to properly escape all parameters.
we reported all five vulnerabilities to the itrustdevelopers and submitted a patch.
wealsosubmitteditrusttothejuliacloudplatformforanalysis which produced xss injection warnings.
we did not have adequateresourcestoconfirmhowmanyofthesewarningsarefalse positives but did check to ensure that julia included all of the xss vulnerabilitiesthatrivuletreported.wedescribeoneexamplethat weclosely investigatedand foundto bea falsepositive reportedby julia.thevulnerabilityconsistsofapagewithaformthatallows the user to filter a list of hospital rooms and their occupants byfiltering on three criteria.
after submitting the form the criteria submittedbytheuserareechoedbackonthepagewithoutpassing throughanystandardsanitizer hencejuliaraisesanalert.while rivuletdidnotalertthattherewasavulnerabilityonthispage itdidobservethesamepotentiallyvulnerabledataflow andgeneratedandexecutedrerunconfigurationstotestit notfindingit to be vulnerable .
we carefully inspected this code to confirm that rivulet s assessment of these flows was correct and found that the filtercriteria would only bedisplayed onthe pageif therewere any rooms that matched those criteria.
the only circumstancesthat an exploit could succeed here would be if an administratorhad defined a hospital or ward named with a malicious string inthatcase thatsamemaliciousstringcouldbeusedinthefilter.
while perhaps not a best practice this does not represent a serious risk anuntrustworthy administratorcould easilydo evenmore nefarious actions than create the scenario to enable this exploit.
injenkins rivulet detected a single xss vulnerability but that vulnerability was exposed by multiple test cases and hence rivulet created distinct valid test rerun configurations thatdemonstrated the vulnerability.
we contacted the developers of jenkins who confirmed the vulnerability assignedit the identifier cve andpatchedit.jenkinsdoesnotuseadatabase and hence had no sql related flows.
we did not observe flows fromuser controlledinputstocommandexecutionapis.jenkins 292table3 resultsofexecutingrivuletonopen sourceapplications.
foreachapplicationweshowthenumberoflinesofjavacode as measuredby cloc thenumberoftestmethods andthetimeittakestorunthosetestswithandwithoutrivulet.foreachvulnerability type weshowthenumberofpotentiallyvulnerableflowsdetectedbyrivulet flows thenaivenumberofrerunsthatwouldbeperformed withoutrivulet scontextualpayloadgenerators reruns n theactualnumberofreruns reruns thenumberofrerunssucceedingin exposing a vulnerability crit and the number of unique vulnerabilities discovered vuln .
there were no sql related flows.
time minutes rce xss application loc tests baseline rivulet flows reruns nreruns crit vuln flows reruns nreruns crit vuln itrust jenkins strutsrest showcase .
slowerperformancewascausedprimarilybyitstestexecutionconfiguration whichcallsforeverysinglejunittestclasstoexecutein itsownjvm withitsowntomcatserverrunningjenkins.hence for each test a web server must be started and jenkins must be deployedonthatserver.thisprocessisgreatlyslowedbyload time dynamic bytecode instrumentation performed by rivulet s underlying taint tracking engine phosphor and could be reduced by hand tuning phosphor for this project.
instruts rivuletdetectedacommandinjectionvulnerability cve thesameusedintheequifaxattack thisvulnerabilitywasknowntoexistinthisrevision .again multipletests exposedthevulnerability andhencerivuletgeneratedmultiple rerunconfigurationsthatdemonstratethevulnerabilities.inthis revision of struts a request with an invalid http content type header cantrigger remote codeexecution since thatheader flows into the ognl expression evaluation engine cve and rivuletdemonstratesthisvulnerabilitybymodifyingheadersto includeognlattackpayloads.thestrutsapplicationdoesn tusea database and hence had no sql related flows.
the runtime for rivulet varied from minutes to about hours.
it is not unusual for automated testing tools i.e.
fuzzers to run for a full day or even several weeks and hence we believethateveninthecaseof jenkins rivulet sperformanceis acceptable.
moreover rivulet s test reruns could occur in parallel dramatically reducing the wall clock time needed to execute it.
.
rq3 reduction in reruns thisresearchquestionevaluatesrivulet sreductioninthenumber of reruns needed to test whether a given source sink flow is vulnerabletoanattackcomparedtoanaiveapproach.todoso we considered the number of payloads that a more naive attack generatorsuchasardilla ornavex mightcreateforeachclassof vulnerability andthenestimatethenumberofrerunsneeded.to estimate the number of payloads used for xss testing we referred to the owasp xss testing cheat sheet which has distinct payloads .
we assume that for rce testing the naive generator would generate the same payloads that rivulet uses rivulet does not use context in these payloads .
we assume that the naive generator will also consider multiple encoding schemes for each payload asrivuletdoes .hence toestimatethenumberofreruns created by this naive generator we divide the number of rerunsactually executed by the total number of payloads that rivulet couldcreate andthenmultiplythisbythenumberofpayloadsthat the naive generator would create e.g.
reruns for xss .table shows the number of reruns generated by this naive generator as reruns n. as expected rivulet generates far fewer reruns particularly with its xss generator where it generated x fewer reruns for jenkins than the naive generator would have.
furthermore giventhatrivulettook19hourstocompleteonjenkins prior approaches that do not use rivulet s in situ rerun generationwouldbeinfeasiblefortheproject.hence weconcludethat rivulet s context sensitive payload generators are quite effective at reducing the number of inputs needed to test if a source sink flow is vulnerable to attack.
.
threats to validity perhapsthegreatestthreattothevalidityofourexperimentalresults comes from our selection of evaluation subjects.
researchers and practitioners alike have long struggled to establish a reproduciblebenchmarkforsecurityvulnerabilitiesthatisrepresentative of real world flaws to enable a fair comparison of different tools .
thankfully in the context of injection vulnerabilities there areseveralwell regardedbenchmarks.tofurtherreducethethreat of benchmark selection we used four such benchmarks juliet owasp securibench microandwavsep .nonetheless itispossible that these benchmarks are not truly representative of real defects perhaps we overfit to the benchmarks.
however we are furtherencouraged because thesebenchmarksincludetest cases thatexposetheknownlimitationsofbothrivuletandjulia for rivulet thebenchmarksuite containsvulnerabilitiesthatareexposedonlynon deterministically andforjulia thebenchmarksuite containsteststhatarenegativelyimpactedbytheimprecisionof the static analysis.
to aid reproducibility of our results we have made rivulet and scripts to run the benchmarks available under the mit open source license .
to demonstrate rivulet s ability to find vulnerabilities using developer written tests we were unable to find any appropriate benchmarks and instead evaluate rivulet on several open source projects.
it is possible that these projects are not representativeof the wider population of web based java applications or their tests.however theprojectsthatweselecteddemonstrateawide range of testing practices jenkins topping in with tests and struts with only showing that rivulet can successfully find vulnerabilities even in projects with very few tests.
we are quite interestedinfindingindustrialcollaboratorssothatwecanapply rivulet to proprietary applications as well however we do not have any such collaborators at this time.
related work dynamictainttrackinghasbeenproposedasaruntimeapproach to detect code injection attacks in production applications as a sort of last line of defense .
however these approachesaregenerallynotadoptedduetoprohibitiveruntime overhead even the most performant can impose a slowdown ofat least and often far more .
although prior work has used the term test amplification to refer to techniques that automatically inject exceptions or system callbacks in existing tests we believe that rivulet is the first to use dynamic taint tracking to amplify test cases.
avarietyofautomatedtestingtoolshavebeenproposedtodetect injection vulnerabilities before software is deployed.
thesetools differ from black box testing tools in that they assume thatthe tester has access to the application server allowing the toolto gather more precise feedback about the success of any givenattack.
kie un et al.
s ardilla detects sql injection and xss vulnerabilities in php based web applications through a white box testingapproach .ardillausessymbolicexecutiontoexplore different application states then for each state uses dynamic taint tracking toidentify whichuser controlled inputs flowto sensitive sinks generatingattackpayloadsforthoseinputsfromadictionaryof over attack strings.
similar to ardilla alhuzali et al.
snavex automaticallydetectsinjectionvulnerabilitiesinphpcodeusing concolic execution to generate sequences of http requests that reach vulnerable sinks .
rivulet improves on these approaches byleveragingthecontextofthecompletevalueflowingintoeach vulnerablesink allowingittofocusitspayloadgenerationtoexcludeinfeasibleattackstrings.thenaivererungeneratorthatwe used as a comparison in our experiments roughly represents the numberofattackstringsthatardillawouldhavetested showing that rivulet provides a significant reduction inputs tested.
unlike thesesystems automatedinputgenerators rivuletusesdeveloperprovided functional tests to perform its initial exploration of theapplication s behavior a technique that we found to work quite well.
if a more robust concolic execution tool were available for java it would be quite interesting to apply a similar approach to rivulet whichcouldreduceourrelianceondeveloper provided test cases to discover application behavior.
othertoolstreattheapplicationundertestasablack box testing forvulnerabilitiesbygeneratinginputsandobservingcommandsastheyaresenttosqlservers orhtmlasitisreturnedtobrowsers.mohammadi etal.usedagrammar basedapproachtogenerateover xss attack strings however our context sensitive approach considers the location of taint tags within the resulting document allowingrivulettoselectfarfewerpayloadsfortesting .simos et al.combined a grammar based approach for generating sql injectionattackstringswithacombinatorialtestingmethodologyfortestingapplicationsforsqlinjectionvulnerabilities .thom et al.
sevolutionaryfuzzergeneratesinputstotriggersqlinjection vulnerabilities using a web crawler .
others have considered mutation based approaches to detect sql injection and xml injectionvulnerabilities .incontrast rivuletusesdataflow information to target only inputs that flow to vulnerable sinks.
while our work considers injection vulnerabilities that are triggered throughcode that runson aweb server otherwork focusesoninjectionvulnerabilitiesthatexistentirelyincodethatrunsin clientbrowsers.lekies etal.deployedatainttrackingengineinside ofawebbrowser tracedwhichdatasourcescouldflowintovulner ablesinks andthengeneratedxssattacksbasedonthehtmland javascriptcontextsurroundingeachvalueatthesink .rivulet also uses taint tracking to generate attack payloads expanding this approach to generate sql and rce injection attacks and uses existing test cases to expose non trivial application behavior.
avarietyofstatictaintanalysisapproacheshavealsobeenused to detect injection vulnerabilities .
the most recent and relevant is julia which uses an interprocedural flow sensitive and context sensitivestatic analysis to detectinjection vulnerabilities .
compared to a dynamic approach like rivulet static approaches have the advantage of not needing to execute the code underanalysis.however inthepresenceofreflection deepclass hierarchies anddynamiccodegeneration allofwhichareoftenpresentinlargejavawebapplications statictoolstendtostrug gle to balance between false positives and false negatives.
in our benchmark evaluation we found that rivulet outperformed julia.
while rivulet uses specialized input generation and attack detectiontofindcodeinjectionvulnerabilities avarietyoffuzzersuse tainttrackingtoinsteadfindprogramcrashes.forinstance buzzfuzzusestainttrackingtotargetinputbytesthatflowtoasinkandreplace those bytes with large small and zero valued integers .
vuzzer takes a similar approach but records values that inputs are compared to in branches and uses those same values as inputs e.g.
ifitsees if tainteddata ... itwouldtryvalue105 intainteddata byte49 .similarly taintscope usesfuzzingto detect cases where fuzzed inputs flow through checksum like routines and uses a symbolic representation of these checksum bytes when generating new inputs in order to pass input validation .
rivulet s key novelties over existing taint based fuzzers are itscontext sensitive input generation whichenables the creation ofcomplex relevant attacks and its attack detectors which report injection vulnerabilities rather than just program crashes.
conclusion despite many efforts to reduce their incidence in practice code injectionattacksremaincommon andarerankedas 1onowasp s most recent list of critical web application vulnerabilities .
we havepresentedanewapproachtoautomaticallydetectthesevulnerabilitiesbeforesoftwareisreleased byamplifyingexistingapplication tests with dynamic taint tracking.
rivulet applies novel context sensitive inputgeneratorstoefficientlyandeffectivelytestapplicationsforinjectionvulnerabilities.onfourbenchmarksuites rivulet had near perfect precision and recall detecting every true vulnerability except for one pathological case and raising no false alarms.
using developer provided integration tests rivulet found sixnewvulnerabilitiesandconfirmedoneoldvulnerabilityinthreelargeopen sourceapplications.rivuletispubliclyavailableunder themitlicense andanartifactcontainingrivuletandthe experiments described in this paper is also publicly available .