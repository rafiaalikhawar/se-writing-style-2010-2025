why do developers remove lambda expressions in java?
mingwei zheng jun yang ming wen hengcheng zhu yepang liu bardbl hai jin sharp hubei engineering research center on big data security school of cyber science and engineering huazhong university of science and technology wuhan china national engineering research center for big data technology and system services computing technology and system lab huazhong university of science and technology wuhan china school of electronic information and communications huazhong university of science and technology wuhan china sharpcluster and grid computing lab school of computer science and technology hust wuhan china dept.
of computer science and engineering the hong kong university of science and technology hong kong china bardbldept.
of computer science and engineering southern university of science and technology shenzhen china zmw12306 claudeyangjun mwenaa hjin hust.edu.cn hzhuaq connect.ust.hk liuyp1 sustech.edu.cn abstract java has introduced lambda expressions a core feature of functional programming.
since its introduction there is an increasing trend of lambda adoptions in java projects.developers often adopt lambda expressions to simplify code avoid code duplication or simulate other functional features.however we observe that lambda expressions can also incurdifferent types of side effects i.e.
performance issues andmemory leakages or even severe bugs and developers alsofrequently remove lambda expressions in their implementations.consequently the advantages of utilizing lambda expressions canbe significantly compromised by the collateral side effects.
in thisstudy we present the first large scale quantitative and qualitativeempirical study to characterize and understand inappropriateusages of lambda expressions.
particularly we summarized sevenmain reasons for the removal of lambdas as well as seven commonmigration patterns.
for instance we observe that lambdas usingcustomized functional interfaces are more likely to be removedby developers.
moreover from a complementary perspective weperformed a user study over developers to seek the underlyingreasons why they remove lambda expressions in practice.
finally based on our empirical results we made suggestions on scenariosto avoid lambda usages for java developers and also pointed outfuture directions for researchers.
index terms lambda expression empirical study i. i ntroduction lambda expression is an important functional feature which has been widely applied in functional programming languages such as standard ml haskell and so on.
plentifulmainstream object oriented languages such as java c and c also support lambda expressions to parameterizefunctionality with time evolves.
since the introduction oflambda expressions in java 1there is an increasing trend of lambda adoptions in open source java projects as revealedby a recent study .
utilizing the features of lambdas developers have migrated from anonymous classes to lambda expressions and fromenhanced for loops to streams.
unfortunately with a wider ming wen is the corresponding author.
1we use lambdas and lambda expressions interchangeably for simplicity.1synchronized documentswriterdeletequeue advancequeue int maxnumpendingops ... return new documentswriterdeletequeue infostream generation seqno nextseqno.get listing memory leak caused by inappropriate usage oflambda expression lucene range of the adoptions of lambda expressions in java we also observe an increasing number of misuses of them inpractice.
in this study we denote a misuse of lambda expression as the case where a lambda expression is used inappropriately which causes side effects or even inducesbugs.
listing shows an issue i.e.
lucene from apache lucene a large scale and open source project.
in thisexample documentswriterdeletequeue is implemented to advance the queue to the next one on flush which uses alambda expression as one of its parameters.
however thereare bytes of memory leakage on each full flush due tothe inappropriate usage of lambda expression.
this is becausethe lambda expression maintains an implicit reference to theenclosing instance the current queue object at runtime inorder to access variable nextseqno which is not defined in the lambda body.
therefore on each flush the new queue willunfortunately keep a reference to the outdated queue whichis no longer needed thus preventing it from being garbagecollected.
consequently memory leaks were observed by de velopers.
such an issue is reported on jira for discussion andmarked as the type of bug with the priority of blocker which reflects the significance of this issue.
to fix it developershave removed such a lambda expression in this context andreplaced it with an invocation to a static method.
we observe it is pervasive that developers change a lambda expression back into a conventional implementation afterintroducing it in large scale open source projects.
for instance 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee figure the trend of lambda removals.
the number is computed on open source projects as described in section iii a. in project apache camel we found that lambda expressions have been removed during the last year.
such a number is in project apache geode which indicates that more than two lambdas have been removed in this projecteach day on average.
meanwhile we found that the behaviorof developers to delete lambdas is increasing year by yearas shown in figure .
worse still we observe that lambdaexpressions can often be misused in which case lambdas willeither induce bugs or cause side effects such as efficiencyissues or memory leaks.
therefore it arouses our great interestto investigate the characteristics of the lambda expressions thatare inappropriately used and removed by developers.
despite its significance and pervasiveness little is known about the misuse of lambda expressions in java.
in particu lar there is still limited empirical knowledge towards what lambdas are often removed by developers why do developers remove lambdas and the migration patterns adopted by developers to remove them.
the lack of such knowledgeimpacts negatively for java developers to correctly use lambdaexpressions in practice.
this study aims to bridge this gap.specifically we performed a quantitative and a qualitative study to investigate the above mentioned questions.
in thequantitative study we conducted a large scale empirical studybased on apache projects to understand the characteristicsof those lambda expressions that were removed by developers.specifically we collected real cases of such lambdas andanalyzed their characteristics quantitatively.
we then comparedthe characteristics with those of lambdas that have been keptin a project from beginning to end.
our qualitative analysisaims to answer the following research question rq1 what lambda expressions are more frequently removed by developers?
we found that lambdas built on top of customized functional interfaces passed to self definedmethod invocations are more likely to be removed.
in addition non empty argument lambdas with more complex bodies aremuch more likely to be refactored.
in the qualitative study we performed two separate experiments with in depth analysis.
first we collected real issuescaused by lambda misuses from large open source projects and then analyzed such issues manually to characterize theremoval reasons impacts and code migration patterns of thoseinappropriate lambdas.
second we designed and conducted asurvey with experienced github contributors from a comple mentary perspective to further understand the insights whydevelopers remove lambdas and got additional issues intotal.
with these two experiments we aim to answer thefollowing research questions intx returnx x x functionalinterface public interface intop intapply int value figure lambda expressions and the corresponding functional interface rq2 why do developers remove lambda expressions in practice?
what are the reasons behind and impacts?
we found seven common reasons for lambda removals includingbut not limited to performance degradation poor readability serialization issues and lazy evaluation issues.
rq3 what are the migration patterns of the inappropriate usages of lambda expressions?
we summarized seven major migration patterns and analyzed the relationship with removalreasons.
our results show that there are common migrationpatterns for most kinds of lambda misuses which can facilitatedevelopers to fix those issues caused by inappropriate lambdas.besides in order to help developers avoid lambda misuse fromthe beginning we summarized five pieces of actionable advicefor utilizing lambda expressions appropriately.
the usefulness of this study is well recognized by developers.
as mentioned by one developer from apache calcite awesome work you are meanwhile our empiricalresults are anticipated by some developers i would be appre ciated if you can share your findings of the subject thanks for the question and for pointing out the issue where willi be able to read about your results .
hence we believethis study can shed light on the better utilization of lambdaexpressions for java developers in practice.
in summary thisstudy makes the following major contributions originality to our best knowledge we are the first to comprehensively study the inappropriate usages oflambda expressions in java.
quantitative analysis we collected cases of removed lambdas and compared their characteristics with31 kept ones and found that lambda expressionsthat are large in their sizes built on top of customized functional interfaces passed to self defined method invocations are more likely to be removed.
qualitative analysis we collected real world issues and conducted a user study to explore the reasons im pacts and migration patterns of lambda removals.
wealso generate actionable advice to guide java program ming with lambda expressions.
dataset we open sourced our collected datasets and the experimental results to facilitate future concern ing researches which is available at github https github.
com cgcl codes lambdamisuse.
ii.
b ackground and motiv a tion a. lambda expressions to support functional programming java has introduced several functional idioms.
for instance it re designs the interface introduces lambda expression retrofits the collection 68framework and introduces the stream api.
this evolution enables developers to embrace various advantages from both object oriented programming and functional programming.consequently there is an increasing trend in the adoptionof such functional idioms in open source java projects.
theusage of certain new java api methods especially thestream api heavily relies on the usage of lambda expressions.for instance most stream operations accept parameters that describe user specified behaviors which are often in the formof lambda expressions .
therefore according to an existingstudy lambda expression is the most accepted functionidiom being accepted by of the investigated projectswhile the other features such as the stream api are acceptedby no greater than of the investigated projects.
due to sucha high accept ratio of lambdas and their significance we putour focus mainly on lambda expressions in this study.
a lambda expression is composed of three parts parameter list the arrow token i.e.
and a lambda body.
the parameter lists are similar to the formal parameters of a regularmethod except that the type information can be omitted ifit can be inferred by the compiler and the parentheses canbe omitted when there is exactly one parameter.
the lambdabody should be either an expression or a code block similarto the body of a regular method.
in java a lambda expressioncan be assigned to a variable or be passed to a method as anargument if the corresponding type is a functional interface which contains only a single abstract method.
figure showsan example of lambda expressions that doubles the giveninteger and their corresponding functional interface.
there are several studies trying to understand the usages of lambda expressions in java.
specifically mazinanian etal.
presented the first large scale empirical study on howdevelopers use lambda expressions in java since its introduc tion .
they observed an increasing trend in the adoption oflambdas in java.
specifically developers often employ lambdaexpressions to simplify source code avoid code duplicationand simulate lazy evaluations.
matsumoto et al.
conducted astudy to explore the current use status of functional idioms injava .
their statistical results show that lambda expressionsare more widely utilized than stream and optional in java programming.
especially they discovered that most developerswrite lambda expressions for good readability and betterperformance while refusing them due to the complicationswhen handling exceptions and compatibility issues.
althoughit is common wisdom that refactoring a legacy code to alambda expression might simplify code and enhance pro gram comprehension lucas et al.
made contradictory ob servations .
specifically they found no evidence that theintroduction of lambda expressions can improve program com prehension via qualitative and quantitative analysis.
gyori etal.
implemented lambdaficator to enable automatic refactors anonymous classes to lambda expressions for loops that iterateover collections to functional operations that use lambda expressions .
alqaimi et al.
designed lambdadoc to automatically generate documents for lambda expressions tohelp readers better understand their functionalities .
be sides tsantalis et al.
investigated the applicability of lambdaexpressions for the refactoring of clones with behavioraldifferences and found that lambda expressions enablethe refactoring of a significant portion of clones that couldnot be refactored by any other means.
b. misuse of lambda expressions with an increasing number of lambda expressions adopted in java we also observe that the usages of them might cause side effects or even induce bugs.
listing shows an example.actually similar issues can be frequently observed amongpopular open source projects.
for example in apache myfaces core we observed excessive object allocations around1 object instances caused by inappropriate usage oflambda expressions that are invoked many times .
besides we also notice several serialization issues in apache flink caused by lambda expressions .
unfortunately thereis no systematic study that has comprehensively investigatedand understood the inappropriate usages of lambda expressionsin java.
this study aims to bridge this gap.
be noted that lambda expression is just a type of syntactic structure which is often used under certain contexts withother code structures such as the stream api.
therefore the side effects of lambda expressions can be collectively affectedby their structures and contexts.
actually we also tried toinvestigate the misusages of lambda expression itself excludingits contexts.
however most of the incorrect usages caused byitself more than are syntactic issues which are oftenmanifested as compilation errors.
specifically we collected186 issues from stack overflow related to the inappropriateusages of lambda expressions without considering their con texts and found that .
of them led to compilation failures.
2such syntactic compilation failures are relatively easier for developers to debug and resolve and thus the researchvalue is limited.
besides it is rare to observe such issuesin real open source projects since they are often guaranteedto be compiled successfully when released to the market.therefore we take the contexts of lambda expressions intoconsideration especially the usages of other functional idioms i.e.
stream api collections api etc.
this enriches our research scope and enables us to understand the side effectsof lambda expressions with respect to their semantics.
italso can provide more in depth guidance for developers tobetter use lambda expressions under certain scenarios.
we alsoconsidered conducting a comprehensive study on all the javafunctional idioms.
however collecting such data is not aneasy task which often contains too many noises.
for instance while searching the keyword stream on jira most itemsreturned are related to the java process streams instead ofthe stream api.
therefore in this study we put our focus onthe side effects caused by lambda expressions as well as theircontexts including the functional apis that rely on them.
inthe following parts of this paper we will clearly distinguish 2we provide the details of such empirical results over stack overflow on 69lambda expressions and the functional apis while explaining our findings.
iii.
c haracterizing the removed lambdas in this section we aim to answer rq1 by characterizing the lambda expressions that have been removed by devel opers.
specifically we constructed two datasets containingthe lambda expressions that are respectively removed andkept by developers.
by comparing the characteristics of thelambda expressions in the two datasets we can answer rq1by presenting the potential factors that make the developersprone to remove a lambda expression.
a. data collection in order to characterize the lambda expressions that were removed by developers we need to first collect a dataset containing the removed ones which is denoted as follows removed lambda expressions.
includes lambda expressions that were removed by developers in order to addresscertain issues.
be noted that removal of lambda expressions due to simply functional deletion is excluded from our scope.our aim is to collect a set of lambda expressions that arerepresentatives of those misused by developers.
to enable a comprehensive understanding of the characteristics of those removed lambdas we also collect the followingdataset for comparison.
kept lambda expressions.
includes lambda expressions that have been kept in the project for a long term which aremore likely to be those used correctly by developers.
by comparing the lambda expressions in the above two sets we can draw a picture of what kind of lambda expressionsare likely to be misused and thus should be removed from theprojects.
next we present the data collection process in detail.
project selection we select projects from the apache software foundation asf because they are well maintained they follow a rigorous project management strategy so that wecan extract more useful information about the code changes inthe commit messages.
specifically we selected activelymaintained java projects that contain at least commitsand committers from the asf project list .
on theone hand a sufficient number of commits guarantees enoughcode changes for our empirical study.
on the other hand therequirement towards the committers ensures diversified codepractices in the projects.
such diversities are important toguarantee the generality of our dataset.
as shown in figure our selected projects have commits ranging from .0k to .8k .71k on average and have different committers rangingfrom to on average which shows that they arelarge and diversified sufficient.
collecting removed lambda expressions to identify the removed lambda expressions by developers we utilizedgumtree an ast based code differencing tool to ana lyze those commits that modify java source files.
since therecan be multiple changes to a file in a single commit whenanalyzing a commit we further looked into the edit hunks of the code diff and extracted the removed lambda expressions a of commits b of committers figure commits and committers of the selected projects at the hunk level which enables us to apply the following rulesto improve the soundness of our dataset.
we excluded those commits modifying more than sourcefiles since they are likely to be tangled with multiple inten tions thus introducing noises of irrelevant changes.
we keep only the commits that either contain an issue id or have keywords that may describe an issue e.g.
bug fix in its commit message.
such commits are likely to be madeto fix an issue.
the complete list is available on our page.
merge commits are excluded as they aggregate multiplechanges from other branches and are considered redundant.
we ignored the hunks in which more than of the mod ified lines are irrelevant to the removed lambda expressionsince they may not focus on lambda expressions.
instead thelambda might be deleted in collateral with other changes.
we ignored the hunks that only delete source code since theintention of such changes is more likely to be functionalitydetection instead of removing misused lambda expressions.
be noted that rigorous rules have been adopted here to collect removed lambdas since our goal is to collect a datasetof high quality which contains lambda expressions removedby inappropriate usages.
noises can still be inevitable whilewe have made our best efforts to collect such a dataset.
finally we collected cases of removed lambda expressions.
collecting kept lambda expressions in addition we collected lambda expressions in our selected projects that arekept by developers which are considered as representatives ofthe correctly used ones.
specifically we applied the followingrules to filter such lambda expressions.
it must still exist in the latest version of the code repository.
it must have stayed in the project for a sufficiently longtime since its introduction.
in this paper we consider 24months to be sufficiently long since it has been revealedthat bugs can be usually exposed and repaired within 24months .
besides most of the removed lambdaexpressions .
collected by us have stayed in theproject for less than months as shown in figure 4a.
lambda expressions introduced in commits that modifymore than files are excluded since they are usuallyintroduced by large scale refactoring.
by adopting the above process we obtained a dataset containing kept lambda expressions.
b. methodology to answer rq1 we first inspect the lifetime of the removed lambda expressions.
specifically for each case we calculated 70the time period it has stayed in the project.
additionally we extracted several features of lambdas that may relate to theremoval of it from the following three different perspectives the usages of functional interfaces.
there are functional interfaces introduced into jdk providing plentiful in put output parameter combinations and covering a wide rangeof functionalities.
besides developers can also implement theirown customized functional interfaces to enable throwing ex ceptions or extending other interfaces.
we investigated whetherthose lambda removals are related to the usages of differentfunctional interfaces.
the complexity of lambda expressions.
from our dataset we observed that some lambda expressions are removed due tothe poor readability caused by their large sizes.
therefore weare motivated to explore whether complexity can be a factorrelated to the removal of a lambda expression.
specifically wemeasure the complexity of a lambda expression with respectto four different aspects number of parameters lines of code the height of the ast of the lambda body and the number ofvariables accessed in the lambda body.
the contexts of lambda expressions.
we investigated whether a lambda expression is likely to be removed undercertain contexts such as the locations and the type of codestructures where lambda expressions are used.
we foundthat both kept and removed lambda expressions are mostlyused in method invocations.
specifically the ratio of methodinvocation is .
for removed lambdas and .
forkept ones.
therefore we are motivated to analyze the methodapis which invoke the lambda expressions and see whetherthe utilized apis are different over removed and kept lambdas.
note that when extracting features such as the fully qualified name of functional interfaces we need to compile the wholeproject to resolve the type information and method binding.however some of the revisions may fail to compile.
therefore for certain features the analysis is performed on the revisionsthat can be compiled including removed lambdas and17 kept ones which is our best effort.
c. empirical results lifetime of removed lambdas we investigated the lifetime of the removed lambdas .
out of of the lambdas have survived no longer than one month.however .
out of of the lambdas areremoved after more than one year.
especially we found onelambda has lived as long as months before its removal.such results reveal that inappropriate usages of lambdas canbe removed as quickly as certain side effects are observed.however some lambdas can be long lived in the project continuously affecting the project until it is discovered bydevelopers for example performance degradation.
the usage of functional interface as shown in figure .
of the removed lambdas are implemented on top of customized functional interfaces i.e.
functional interfaces thatare defined by developers while that ratio is only .
among kept ones.
such a high ratio difference indicates thatcustomized functional interfaces are more likely to be misused.a chi square test of independence was performed toexamine the relation between the removal of lambda expres sions and usage of customized functional interface whichreveals that the relation was significant at the significance levelof .
n .
p .
.
the effect size was .
indicating that the magnitude of the effect is small.
this is because customized functionalinterfaces mostly define more complex functionalities that arenot implemented by the current built in functional interfaces and thus are much easier to introduce bugs.
besides built infunctional interfaces are defined with specific functionalitiesand usually used together with built in apis e.g.
stream api with lambdas.
therefore using such well defined interfaces isless likely to introduce issues.
finding lambda expressions built on top of customized functional interfaces are more likely to be removed.
the complexity of lambda expressions we measure the complexity of lambda expressions from four perspectives asmentioned above.
the measure of parameter number is shownin figure while the statistics of the other three are depictedin figure clipped down outliers exceeding 3 .
it shows that removed lambdas .
have a higher percentageofempty argument lambda lambda expressions that do not receive any argument than kept ones .
.
similarly weapplied the chi square test and observe the relation issignificant at the significance of .
with a small effect size of0.
.
besides for empty argument lambdas we observed that removed lambdas have significantly fewer lines and smallerbody depth than kept ones as shown in figure 4c and figure 4dwith a p value of .
16and8.
28respectively by the mann whitney u test .
one possible reason isthat empty argument lambdas with terse bodies can always beeasily refactored to method reference for code simplification.
as for non empty argument lambdas removed lambdas occupy more lines of code than kept ones as shown in figure4b p value .
12at the significance level of by the mann whitney u test .
in other words for such lambdas occupying more lines of code or having a more complex bodytend to exhibit a higher probability to be removed.
that isnot a surprise because lambda expressions aim at providinga lightweight mechanism to deliver functionalities whilelambdas with complicated structures violate such a philosophy.
we also investigated the number of variables inside lambda bodies.
as shown in figure 4e kept lambdas contain .89variables on average while removed lambdas contain .49variables.
the mann whitney u test reveals that keptlambdas have significantly fewer variables in their body thanremoved lambdas at the significance of p value .
.
finding empty argument lambdas has a larger possibility to be removed while non empty argument lambdas withmore complex bodies are more likely to be refactored.
the contexts of lambda expressions we inspect the contexts of lambda expressions as follows.
first we investigate .hsw 5hpryhg1xpehu a life time of kept and removed lambda expressions .hsw 5hpryhg1xpehu b line number of removed and kept lambdas with parameters .hsw 5hpryhg1xpehu c line number of lambdas without parameters .hsw 5hpryhg1xpehu d lambda body depth of lambdas without parameters .hsw 5hpryhg1xpehu e v ariable number of kept and removed lambdas figure comparison between removed and kept lambdas figure comparison between removed and kept lambdas figure parameter numbers of kept and removed lambdas what specific apis lambdas are often passed to.
figure shows that lambda expressions passed to self defined methodsare more likely to be removed by developers i.e.
.
vs50.
.
a chi square test reveals that the removal of lambda expressions is significantly correlated with whetherthe invoked method is self defined or not with a p value ofp .
46and a small effect size of .
.
one possible reason is that apis defined in jdk are a safer contextfor lambdas.
for those lambdas passed to built in apis wefurther dissect the distributions of specific apis and show ourresult in table i. we found that lambdas passed to apis ofmap computeifabsent and optional ifpresent are more likely to be removed than those passed to other apis.
on thecontrary lambdas passed to stream map and stream filter are less likely to be removed.
it is because that the stream api was designed to mainly work with lambdas.
the manner towrite lambdas in stream api methods is also well defined.
on the contrary optional was not designed with the functional programming style instead although it was also introduced injava .
meanwhile implementing with optional is sometimes more complex than that with conventional if else for branch logic processing .
for the same reason map which was introduced since jdk1.
is not as compatible withlambda expressions as stream api.
therefore if developerstable i apis that lambda expressions are passed to api removed kept difference iterable.foreach .
.
.
stream.map .
.
.
map.computeifabsent .
.
.
optional.ifpresent .
.
.
stream.foreach .
.
.
stream.filter .
.
.
collectors.tomap .
.
.
map.foreach .
.
.
executorservice.submit .
.
.
optional.map .
.
.
intstream.foreach .
.
.
intend to call lambda expressions within jdk built in methodsin the functional programming style stream api is a better choice and thus lambda expressions used in stream api are less likely to be removed in practice.
finding lambda expressions that are built on top of customized functional interfaces passed to self definedmethod invocations are more likely to be removed.
iv .
c oncerns and actions of developers in this section we investigated the concerns of the developers when removing a lambda expression and the migration pat terns afterwards.
specifically we analyzed the issue descrip tions from the issue trackers and commit messages to figureout the reason why developers remove a lambda expression.on the other hand we also looked into the code changes offixes to explore how developers fix the problem induced bythe improper usages of lambda expressions.
to have a deeperunderstanding of the reasons behind the removals of lambdaexpressions we also communicated with some developers whoremoved lambda expressions in our subjects.
finally we foundseven common reasons for removing lambda expressions andseven major migration patterns.
we present the details of theempirical results as follows.
a. data collection we collect a dataset of issues from the following sources to understand the reason behind the removal of a lambda expression and the action taken by developers after the removal.
apache jira.
most apache open source projects track their issues on the jira issue tracker.
therefore we searchthe issues on jira using the following query to collect theissue related to lambda expressions.
72status in resolved closed and text lambda the query returned items.
we further filter out issues in which the keyword lambda only appears in stack traces and those associated with python lambda.
we obtained 175issues afterwards and manually validate them to see whetherthey contain sufficient information for us to understand thebehind reasons.
finally issues are kept.
code commits.
not all the fixes for improper usage of lambda expressions are tracked in apache jira.
meanwhile the associated issues may not use the keyword lambda inthe issue summary or description thus escaping from ourqueries.
in this study we also search the commit messagesof the commits that remove a lambda expression and containscertain keywords i.e.
lambda bug fix issue fixup problem abuse error optimize etc .
such commits are likely to fix a problem by removing a lambda expression.
we finally kept 60of such collected commits after manual validation.
github issues.
apart from jira part of the issues in our subjects are tracked on github for discussion.
therefore we searched the github issues of our subjects with keywordlambda and then manually selected the issues containing sufficient information.
we obtained seven issues in this step.
user study.
we further communicated with developers asking for the details about the removal of lambda expressions.specifically we discussed with developers who have recentlyremoved lambdas in open source projects we automaticallymined such information via monitoring the commit historiesof the projects on the reason for removing the lambdaexpression the impacts caused by the lambda expression andscenarios in which they would avoid using lambda expressions.specifically we sent emails to the developers which haverecently removed lambda expressions and got in touch with38 of them with a response rate of .
.
we retained thoseresponses with clear descriptions and got issues included.
in total we collected issues for exploring the concern and actions of the developers while removing lambda expres sions including from apache jira from code commits seven from github issues and from user study.
b. analysis approach for the collected data collection we performed a process similar to open coding to identify common reasons for removing lambda expressions as well as the migration patterns.for data collected from apache jira code commits and github issues we read the descriptions of the issues orcommit messages to understand the reason for the removal.for data collected in the user study we extract the removal reasons from email replies.
besides we read the code difffor all the data to find common migration patterns.
in theclassification process two authors inspected and labeled thedataset independently and they discussed with each other toreach a consensus when there is a conflict.
after the analysis we summarized the results of our qualitative study in this section from two perspectives the reasons why such lambdas are deemed as misused and the associatedimpacts and the migration patterns adopted by developers to !
!
!
!
figure reasons of removing lambda expressions replace such removed lambdas.
we present our results in thefollowing two subsections.
c. reasons for misusing lambda expressions we summarized seven major reasons with over five cases for each reason that why lambdas are deemed as misused by developers and the associated impacts.
figure shows thestatistics and we present the details as follows performance degradation .
performance degradation is one of the most crucial reasons that why developersremove lambda expressions.
specifically nearly of thelambdas in our study are removed since their usages intro duced performance issues.
such lambdas will be removedif such side effects are significant and perceived by devel opers.
the most common inappropriate lambda usages thatcause performance issues is invoking lambdas in computation critical code especially for captured lambdas which accessvariables outside the lambda body.
for captured lambdaswith multiple invocations although the lambda class is onlycreated once on the first invocation each invocation willcreate a new lambda instance.
this may introduce excessiveobject allocations and bring significant pressure to the garbagecollector.
therefore a developer in apache lucene removedsuch lambdas to avoid memory allocation for each invocationofcollectvalfirstphase .
furthermore as shown in listing the lambda expression will hold a reference to theirenclosure instance when it accesses the enclosing instance snon static fields and methods thus causing memory leaks.
actually the new java api methods i.e.
collections stream and optionals can also introduce performance differences when they are used with lambdas.
although it isstill controversial whether the performance of using lambdaswith such java api methods is worse than their counterpartimplementations in diverse scenarios .
there are many realissues which refactor these usages into conventional ways i.e.
for loop do while enhanced for loops if else etc due to the excessive cpu cycles and non trivial memoryallocation overhead based on performance test results .
poor readability .
poor readability is another important reason for lambda removals in our dataset.
suchlambda expressions usually have a long body or containcomplex logic setting obstacles for developers to understandthem.
worse still lambda expressions are anonymous andthus the intention of a lambda expression is far more difficultto understand than a method.
besides the syntax of lambdaexpressions looks less compact than that of method reference.
.collect collectors.groupingby url ... .collect collectors.groupingby this judgecategory private string judgecategory url url the same as the lambda body listing replacing a lambda with a method to improve readability commit 9e9517d project dubbo .apply o collections.emptylist .apply new multimapview override public iterable get ... override public iterable get object o ... public interface multimapview k v iterable k get iterable v get nullable k k listing switching from lambda to anonymous class for better extensibility pr project beam therefore developers sometimes tend to remove lambda expressions to improve readability as well as make the codemore compact.
for example in listing developers in projectdubbo replaced a lambda containing more than lines of code with a method to make it more readable as shown in thedescription simplify collect body to make it more readable.
our finding is also confirmed by developers in the user studyas a developer in project apache calcite mentioned that i generally dislike long lambdas due to bad readability.
serialization issues .
there are lambda expressions in our dataset that are removed due to serialization issues.since java one can make a lambda expression serializableby extending serializable in its corresponding functional interface.
serializing lambdas can be used for persisting configuration or as a visitor pattern to remote resources .
however this is strongly discouraged according to the javalanguage specification because the serialization behaviorof synthetic class what will be created when compiling alambda expression can vary among jvm implementations which can cause compatibility issues when the bytes serializedon one jvm are shipped to another jvm to deserialize andvise versa.
for instance a developer successfully serializeda lambda and shipped the byte code via remotegraph to aremote server but can not deserialize it on the new server .
poor extensibility .
during code evolution functional interfaces can be evolved to accept no lambda anymore.
in this case a lambda expression is no longer acceptedwhen an object implementing such interfaces is required.therefore developers need to switch from lambda expressionsto anonymous classes for better extensibility.
listing showsan example in project beam.
as shown in the code change a new method get is added to inference multimapview and thus it is no longer a functional interface.
to this end developers replaced the lambda expression with an anonymousclass to make the code syntactic correct.
similarly suchcases are observed in our dataset.
type inference failure .
we observed cases1 hasdisplaydata subcomponent builder builder.include b builder1 builder1.add ... hasdisplaydata subcomponent new hasdisplaydata override public void populatedisplaydata builder builder builder.include b new hasdisplaydata override public void populatedisplaydata builder builder ... listing replacing lambda expressions with anonymousclasses commit aedb4c8 project beam groovy.transform.compilestatic 2java.lang.classcastexception thistest m lambda1 cannot be cast to thistest at thistest m lambda1 lambda2.docall ts4.groovy at thistest m lambda1.docall ts4.groovy at thistest.m ts4.groovy at thistest m.call unknown source listing stack trace related to lambdas in groovy in our dataset where lambda expressions are removed toresolve type inference failures.
as mentioned in section ii the type information in a lambda expression can be omittedand inferred by the compiler.
however there are cases wherethere is no sufficient contextual information for the compilerto infer the type thus causing a compilation error.
listing 4shows an example in project beam where developers replaced two nested lambda expressions with anonymous classes to fix of some call sites where lambdas mess up coder inference as mentioned in the commit message.
maintenance issues .
apart from technical issues lambda expressions can also be removed due to human fac tors i.e.
causing maintainability issues or inconsistent codestyles .
listing shows a stack trace when debugging a codesnippet with lambda expressions in project groovy.
the names of the stack frame related to lambda expressions are hardfor developers to recognize which makes debugging coderelated to lambda expressions difficult.
besides the stacktraces for those lambdas used together with the new java api 8methods are even more complex.
for instance as mentionedby a developer in our user study they are often annoyingwhen debugging step by step inside an ide compared toimperative programming.
especially in cases like this col lection.stream .flatmap ... .filter ... .map ... .collect ... .
.
lazy evaluation .
one key feature of lambda expressions is that they are not evaluated when they are defined andare actually evaluated when they are called instead.
therefore lambda expressions are usually used for implementing lazyevaluation which is delaying the evaluation of an expressionuntil its value is needed thus avoiding needless calculationsand reducing memory footprints.
however some developersignored the nature of lazy evaluation and used lambda expres sions in the cases where lazy evaluation is not desired andthus introduced unexpected behaviors into the program.
forinstance the code change in listing shows an inappropriateimplementation of lazy evaluation with lambda expressions.since supplier does not have memorization cache the result of a function call and return the cached value for the final supplier blackboard bb rexnode sourceref rexbuilder.makerangeref scan return createinsertblackboard table sourceref table.getrowtype .getfieldnames final rexnode sourceref rexbuilder.makerangeref scan final blackboard bb createinsertblackboard table sourceref table.getrowtype .getfieldnames ... list.add ief.newcolumndefaultvalue table f.getindex bb.get list.add ief.newcolumndefaultvalue table f.getindex bb listing remove the lazy initialization logic for the blackboard instance commit 22c76fb project calcite following calls to save computation costs each access to the generated blackboard instance needs to call method get ofsupplier again thus increasing repeated computations.
besides the evaluations of intermediate operations in stream such as map filter etc can also be lazy.
applying these stream apis with lambda expressions performs no operations until the terminal operation is executed.
consequently ignor ing the lazy nature of intermediate operations in stream may also introduce problems i.e.
cassandra .
others .
other issues are too specific to be summarized into a single category.
for instance lambda expres sion misuse leads to an ambiguous method call unhandledexceptions and so on.
these problems are rare because mostof them can be found at compilation time and easily solvedbefore commit.
to summarize we make the following finding with respect to why developers removed lambdas.
finding performance degradation and poor readability are the most common reasons why developers removelambdas.
lambdas can also be removed due to the natureof lazy evaluation.
besides they might cause extensibilityand maintenance issues thus being removed by developers.
d. common migration patterns we further identify how developers migrate those inappropriate usages of lambda expressions.
for the collected 117cases we drop those cases whose corresponding commitsare unavailable and finally obtained unique cases forfurther classification.
via investigating the available associatedcommits we observed seven major code migration patterns with over five cases for each pattern which are summarizedin table ii.
be noted that there may be more than one patternfor each issue.
we also analyzed the relationship betweenthe reasons why lambdas got removed and the correspondingmigration patterns which is shown in figure .
our majorobservations are described as follows we observed that the most common migration pattern is to change new java api methods with lambdaexpressions back to conventional methods.
according to ourstatistical results of such cases are for performanceimprovement.
it is because the compiler has well exploredhow to optimize old fashioned code while the support of !
!
!
!
figure correlation between lambda removal reasonsand migration patterns.
the number denotes the migrationpattern id as shown in table ii performance optimization for new language features such as stream api is insufficient.
therefore when performance is of significant concern developers should be careful when usingthese new java api methods with lambda expressions.
we observed that it is also common to replace lambda expressions with method