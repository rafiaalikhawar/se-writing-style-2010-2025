slemi equivalence modulo input emi based mutation of cps models for finding compiler bugs in simulink shafiul azam chowdhury computer science and engineering department university of texas at arlington arlington texas usasohil lal shrestha computer science and engineering department university of texas at arlington arlington texas usa taylor t. johnson eecs department vanderbilt university nashville tennessee usachristoph csallner computer science and engineering department university of texas at arlington arlington texas usa abstract finding bugs in commercial cyber physical system development tools or model based design tools such as mathworks s simulink is important in practice as these tools are widely used to generate embedded code that gets deployed in safety critical applications such as cars and planes.
equivalence modulo input emi based mutation is a new twist on differential testing that promises lower use of computational resources and has already been successful at finding bugs in compilers for procedural languages.
to provide emi based mutation for differential testing of cyber physical system cps development tools this paper develops several novel mutation techniques.
these techniques deal with cps language features that are not found in procedural languages such as an explicit notion of execution time and zombie code which combines properties of live and dead procedural code.
in our experiments the most closely related work slforge found two bugs in the simulink tool.
in comparison slemi found a super set of issues including confirmed as bugs by mathworks support.
ccs concepts software and its engineering software testing and debugging compilers model driven software engineering general and reference reliability verification performance.
keywords cyber physical systems differential testing equivalence modulo input model mutation simulink acm reference format shafiul azam chowdhury sohil lal shrestha taylor t. johnson and christoph csallner.
.
slemi equivalence modulo input emi based mutation of cps models for finding compiler bugs in simulink.
in 42nd international permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
.
.
.
on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
.
introduction commercial cyber physical system cps development tools or model based design tools are complex software systems that may contain bugs.
finding such bugs is hard as the cps development tools do not have complete formal specifications and the tools source code is not available either.
while state of the art cps tool bug finding approaches such as slforge have had some initial success they also have two key limitations i.e.
they are a fundamentally slow and b limited to synthetic cps models.
finding bugs in commercial cyber physical system development tools efficiently is important however as the correctness of cps development tools is crucial in practice.
for example mathworks s cps development tool simulink is a de facto industry standard in several safety critical domains including automotive aerospace and health care .
engineers widely use simulink to design model simulate and generate embedded code from cps models and deploy the generated code in safety critical applications .
so a simulink tool bug may lead to compile errors or inject subtle unexpected behaviors into safety critical applications e.g.
in cars or planes .
to side step the lack of cps tool specifications state of the art cps tool bug finding approaches such as slforge perform differential testing on the cps tool.
by invoking two configurations of the same cps tool that are expected to produce the same result on the same generated model slforge may trigger a cps tool bugif the two configurations yield different results.
but generating a valid synthetic cps model turns out to be computationally expensive.
for example due to incomplete cps language rules slforge may require several feedback directed iterations to automatically fix remaining simulink compile errors.
a recent differential testing twist promises to address these limitations.
mutating a given program in a way that preserves its execution semantics on the given inputs has proven effective in finding bugs in c compilers .
these equivalence modulo input emi based mutation schemes perform a small program modification which may be computationally cheaper than generating a program from scratch.
besides speeding up program generation and enabling the use of existing models emi based mutation also enables finding ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea shafiul azam chowdhury sohil lal shrestha taylor t. johnson and christoph csallner compiler bugs by comparing two identically configured compiler executions on equivalent input programs .
recent work has laid the groundwork for evaluating cps mutation approaches.
evaluating such approaches requires input cps models and traditionally such models were not easy to obtain in sufficient numbers.
for example in the case of simulink random simulink model generators and a corpus of public simulink models only became available recently .
while prior work has reported promising results on emi based mutation for finding bugs in c compilers it is not straight forward to apply the existing emi based mutation schemes to cps tools.
as a case in point the only existing approach described as emi based mutation for cps models slforge does not really follow the equivalence modulo input paradigm.
instead of preserving behavior for a single given input slforge performs a static mutation that preserves equivalence for all possible inputs by using the simulink compiler to remove all dead code .
while the resulting mutation is also emi since maintaining equivalence on all inputs implies maintaining equivalence on the given input it is a severely restricted approach and in the case of slforge only yields one mutant per input model.
specifically slforge does not leverage model runtime data does not delete or modify any model elements the compiler does not remove and does not insert any model elements.
given these limitations it is perhaps not surprising that slforge s emi component has only found one bug.
the core challenge of emi based mutation of cps models is that cps languages are quite different from procedural languages e.g.
cps languages have an explicit notion of execution time.
cps languages also have a different notion of when code is dead which gives raise to zombie blocks section .
in cps models that do not exist in procedural code.
to address these challenges this paper reviews several key differences between cps models and procedural code.
specifically we describe novel techniques for mutating cps models that use an explicit notion of execution time and zombie code i.e.
code that has properties of both dead and live procedural code.
we implement these techniques in the new slemi tool and empirically evaluate their effectiveness for finding bugs in the simulink tool.
slforge the state of the art approach for finding bugs in the simulink tool via emi has found one bug.
in contrast slemi has to date found unique issues confirmed as bugs by mathworks support in simulink versions r2017a and r2018a.
to summarize this paper makes the following major contributions.
the paper describes novel techniques for emi based mutation of cps models including techniques for dealing with language features that do not exist in procedural languages.
via the novel slemi tool these techniques found confirmed bugs in the widely used cps development tool simulink.
within set time and computational resources slemi found more simulink bugs than its closest competitor slforge.
all slemi code and evaluation data are open source1.
1available background this section contains necessary background information on key features of cps modeling languages model based design mbd tools such as simulink how their data propagation control flow and dead code notions differ from those in procedural programming our resulting notion of zombie code and state of the art approaches for finding bugs via emi based mutation and differential testing.
.
block diagrams and cps tool chains while in depth descriptions of cps languages are available elsewhere the following are the key concepts.
in a cyber physical system cps development tool e.g.
simulink a user designs a model mof the cps as a diagram that consists of blocks and their connections.
a block may accept data through its input ports typically performs on the data some operation defined by a discrete or continuous function and may pass output through itsoutput ports to other blocks along directed connection edges.
more formally each connection c m.cis a tuple bs ps bt pt of source block bs its output port ps target block bt and its input port pt .
since a typical cps tool supports a wide range of modelling styles we do not further detail the connection semantics here.
for example in a tool s dataflow semantics a connection c1takes its source block s output data d1and eventually delivers d1toc1 s target block.
however a cps tool may at the same time support other semantics in which for example a source block may overwrite data d2on a connection c2before c2 s target block can read d2.
a model mtypically acquires its inputs from sensors whose values it samples at a user defined frequency e.g.
times per second .
each sample yields a new input vector i containing one value per sensor that the model processes in the execution order defined by the model s connection edges .
to affect its environment a model typically has a set of output blocks or sinks moutsuch as figure s out1andout2blocks which can emit model output values to a display another model or a hardware actuator.
figure example valid simulink model while action 1is on a false branch when b1receives non zero positive input action s values can still affect the outside world making action 1a zombie block.
commercial cps tools specify the datatypes each port of each block supports e.g.
either double or uint32 .
if the user does not explicitly configure a port s datatype then the cps tool infers and assigns a concrete datatype e.g.
double .
if the user has under constrained the blocks datatypes the tool may heuristically 336slemi emi based mutation of cps models for finding compiler bugs in simulink icse may seoul republic of korea break best datatype match ties.
we define the tdt b p function to retrieve the resulting datatype of a given block b s port p. tools such as simulink are also known as model based design mbd tools and have become popular in several domains including automotive and aerospace engineering.
a key reason for their wide use is that these tools allow non software engineers to design complex software systems and compile them to low level code.
when creating a model users can re use and customize standard blocks from built in libraries supplied by the tool chain.
most blocks have user configured parameters that may affect the block s output values.
the user may also create new custom blocks from scratch via segments of procedural code e.g.
in c or matlab .
commercial cps tool chains such as simulink and labview do not have a publicly available specification that is complete formal and up to date.
besides partial informal descriptions certain tool chain semantics are often defined in their code base .
let validl m indicate if tool chain laccepts model m i.e.
compiles mwithout error.
as an example for a model to be valid simulink must be able to infer consistent datatypes for each port left unspecified by the user.
simulink uses several heuristic rules to infer and propagate datatypes e.g.
forward backward and block internal propagation .
after compilation users simulate models where the tool chain uses configurable solvers to iteratively solve the model s network of mathematical relations via numerical methods yielding for each output block a sequence of outputs.
commercial tool chains typically offer different simulation modes.
for example simulink normal mode only simulates blocks accelerator mode speeds up simulation by emitting native code and rapid accelerator mode produces a standalone executable for simulation2.
besides flat models cps development tools offer hierarchical models e.g.
via simulink s subsystem andmodel referencing where the parent to child model relation is acyclic.
a tool chain may permit a loop in the model s connection relation such as a feedback loop if it can numerically solve it.
.
zombies output data from a false branch how to best deal with conditional execution in block diagrams has been an open research question for decades e.g.
in the dataflow literature .
while well understood in procedural programming conditional execution differs significantly in block diagrams which complicates the dead vs. live code distinction and therefore emi.
for example while impossible in procedural code the valid simulink model of figure simultaneously returns values from both its true and false if then else branches.
specifically assume that in the current model execution the user provides via block b1a constant value of 5as input to the model and thus to the control flow conditional if.
given this input in all simulation steps of this execution the conditional will thus select action 1as the falsebranch.
unlike in procedural programming such a false branch still has a user configured default output value for action 1this default value is zero .
the subsequent increment modeled by the add 1block causes out1to constantly emit which can affect the outside world.
2simulink s embedded code generation worfklow for deployment on target platforms is distinct from these simulation modes and is outside the scope of this paper.in a procedural setting action 1would be dynamically dead code and we could delete it for this execution trace.
but in our block diagram setting action 1is not dead.
instead a block bisdead and can be removed only if there is no path from bto any output block and neither bnor its successor blocks can produce other sideeffects .
simulink has built in tools to remove such dead blocks.
unlike in procedural programming this no path exists notion does not depend on runtime data so for block diagrams we do not distinguish between statically and dynamically dead.
a block may never be activated e.g.
because it is on an alwaysfalse branch such as action .
we call such a block a zombie as in live dead hybrid as it has properties of both procedural live code it has program values and procedural dead code no computations take place .
a static zombie is a zombie in all possible model executions.
a dynamic zombie is a zombie in the current model execution e.g.
action .
action 1is atop level zombie its default value can reach the outside world.
in contrast a nested zombie such as figure s gain block is nested inside a top level zombie.
a nested zombie cannot influence the outside world as its top level zombie never processes the nested zombie s default value.
a nested zombie is thus conceptually similar to procedural dead code.
finally a block is live if it has both a path to an output block or another side effect and gets activated.
a dynamically live block is live in the current model execution.
it may be a zombie but not dead during other executions.
a statically live block is live in all possible executions.
.
differential testing emi and slforge differential compiler or cps tool chain testing compares two execution traces that compile and execute a program or model .
by design these two traces are supposed to be equivalent i.e.
are expected to produce the same result values.
if the results differ we have likely found a compiler bug.
more formally for programs m andn and program parameters pandq based on our understanding of the programming language semantics j k we expect equal execution results i.e.
jm p k jn q k. we expect to have found a bug if two compiler configurations canddfor this language instead produce different results i.e.
c m p d n q .
one way to instantiate this framework is to fix a program plus parameter combination m n p q and only differ the tool configuration c d .
indeed well known differential testing approaches such as csmith have found many compiler bugs by running randomly3generated programs under varying compiler configurations i.e.
c m p d m p .
in the cps world existing approaches for simulink similarly have varied compiler optimization levels numerical solvers simulation modes and code generators .
equivalence modulo input emi based differential testing has typically instantiated this framework by fixing a tool configuration plus program parameter combination c d p q .
in other words emi based approaches use a program mand one of its mutants n that is expected to be functionally equivalent to mon the given input p i.e.
m nand jm p k jn p k. again different results suggest a compiler bug i.e.
c m p c n p .
while there has 3as common in the literature in this paper by random we mean pseudo random .
337icse may seoul republic of korea shafiul azam chowdhury sohil lal shrestha taylor t. johnson and christoph csallner been recent interest in emi for testing c compilers besides slforge we are not aware of emi based testing work for block diagram or cps model languages.
random program generators have significantly improved the bug finding capability of both types of differential testing instantiations .
existing random simulink model generators include cyfuzz and its successor slforge .
besides comparing traces of different tool configurations slforge also performs a very restricted form of emi based mutation and is thus the approach most closely related to slemi.
specifically after generating a random valid simulink model slforge optionally runs simulink s static block reduction tool to delete all dead blocks.
slemi cps tool chain testing via emi existing emi based compiler testing approaches focus on procedural programs .
cps models are different in several ways e.g.
they may emit output from several parts of the model at the same time.
they are also typically simulated over a finite number of simulation steps where at each step sthe model consumes a separate input vector i amounting to a sequence iof input vectors.
we adapt the framework of section .
to cps models.
to keep our definition simple we represent block bof model mat simulation step s after mhas processed sinput vectors from input vector sequence i asm i s.b.
since commercial cps tool chains support floating point datatypes we compare block outputs via a tolerance.
in other words we consider xandyequivalent i.e.
x y if x y where is configurable 16by default .
we thus consider two cps models mandn nobtained by mutating m i.e.
n m equivalent modulo a common sequence iof input vectors i.e.
m in if both models are valid have the same output blocks and the cps tool chain semantics j kat all time steps sprescribes equivalent values for all blocks bthat are common to both models as follows.
m in valid m valid n mout nout b m n s jm i s.bk jn i s.bk figure outlines our approach.
slemi takes as input real world and randomly generated cps models together with their input values.
we first filter out invalid models as they are not suitable for differential testing and then execute each seed model on its inputs to collect block level coverage information on all model hierarchy levels via simulink coverage .
then slemi performs several one time base mutations listing and stores data in a persistent cache.
we then mutate a model by removing and adding blocks.
given the lack of a full formal specification of simulink we had to revert to an iterative approach for developing mutation operations that maintain equivalence modulo input.
in other words we expect that each of our mutations converts a model mintom such thatm im holds.
if via differential testing slemi determines thatm im did not hold we report the issue to mathworks.
mathworks confirming a bug increases our confidence in the mutation s emi property.
a feedback of false positive tells us our mutation was not emi gives us a better understanding of the tool s otherwise undocumented semantics and we have to adapt or abandon the mutation operation accordingly.compared to model simplifications performed by optimizing compilers including profile guided optimizers trace compilers etc.
our below model mutation strategies are more general.
optimizing compilers rewrite programs toward a concrete goal such as increasing execution speed or minimizing power consumption .
for example while optimizing compilers would not consider adding complex extra execution logic into live or dead code we are interested in all emi mutations in our bid to find additional cps tool chain bugs.
.
base mutations annotate seed models slemi s base mutations deal with two challenges that did not occur in earlier work on emi based differential testing i.e.
datatype inference and sample time inference.
.
.
annotating seed models with port datatypes.
the first challenge is introduced due to datatype inference.
instead of enforcing datatypes to be fully specified on every single port on each block which can get cumbersome on large scale models simulink infers unspecified datatypes based on data dependencies and optional partial specifications.
for models with under constrained datatypes even a small slemi induced mutation that may intuitively seem like it should be emi can trigger vastly different inferred datatypes which could create false warnings during differential testing.
good examples of this problem are model regions that are dynamically zombie.
simulink s datatype propagation rules may rely on these zombie regions and mutating them may severely affect the datatypes simulink infers in the surrounding regions.
to give slemi more emi mutation choices we therefore first want to annotate the seed model with the datatypes simulink infers.
the seed s types thus remain available for compilation even after extensive mutations that may otherwise alter simulink s datatype inference results.
as a concrete instance of this challenge in the figure 3a child model excerpt of a larger seed model omitted for brevity simulink propagates type double from block b2to blocks b3 and b1.
when we replace the nested zombie b2with a typecast block data type conversion in simulink yielding figure 3b then simulink counterintuitively propagates inttob3andb1 which is not compatible with b1 yielding a compile error.
listing base mutations to preprocess seed musing set b p t which fixes output port p s datatype to t. besides changing to a fixed step solver section .
.
base mutations are emi.
preprocess m i returns m change to fixed step solver not emi execute musing input i for each block b m collect inferred properties collect execution coverage collect inferred datatype and sample time annotate sample time if bis a source block for each connection c m add types set c.bs c.ps tdt c.bs c.ps source output port d new typecastblock for target input port set d tdt c.bt c.pt d s only output port connect c.bs dand d c.bt rewire 338slemi emi based mutation of cps models for finding compiler bugs in simulink icse may seoul republic of korea store seed modelslforge 3rd partybase mutations collect coveragecacheemi mutation dead live zombie regionsdifferential testing if not m im bug candidatem i m s i s i m im i c ctool chain vendorbugm feedback figure overview slemi first obtains seed model swith input vector ifrom a real world corpus or a random generator e.g.
slforge performs one time base mutations to yield model m and collects m s coverage c oni .
an emi based mutation then yields a valid equivalent on i model m for finding tool chain bugs via differential testing.
a b figure example seed model excerpt without explicit type specifications a where simulink propagates double viab2.
replacing nested zombie b2with a convertdata type conversion block b may yield different type inference results.
inferring the datatypes of all seed model blocks and explicitly specifying these types in the model is an emi mutation as it does not change the outcome of model compilation or subsequent simulation.
simulink offers two options for specifying types and slemi uses both.
first some but not all4 blocks have a parameter that sets the block s output port datatypes.
second typecast blocks such asdata type conversion have a defined output type.
placing one of them before a block blets one define b s input port datatype.
the lower half of the listing pseudo code summarizes these type annotation steps.
first for each block bsthat has this option slemi sets the block s output type to the simulink inferred type.
second slemi adds a fresh typecast block dbefore each block bt to annotate bt s input type.
even combining both annotation strategies does not fully specify all types as the output port parameters do not cover all blocks and typecast leaves its input port unspecified.
however this combination has been sufficient and did not create any false warnings in our experiments.
.
.
dealing with sample time inference.
the second challenge not found in earlier emi based testing for procedural languages is that in a cps model each block has a sample time.
at a high level this challenge is similar to the previous datatype inference issue.
as a concrete example commercial cps tool simulink encourages the user to specify the sample time only for a subset of the blocks and then let the tool infer the sample time for the remaining blocks using forward and backward propagation .
again a small mutation that at first glance seems like it may be emi can trigger the cps tool to infer vastly different sampling times for large portions of the model which in turn yields different model outputs yielding a false bug warning.
4for example simulink s discrete transfer function block does not support specifying double datatype at its output port via block parameters.
one can achieve this effect only by controlling the block s input port datatype.as an extreme example some blocks directly expose their blockspecific sampling frequency such as counter free running which plainly returns as its output the number of times it has been sampled .
the tool chain inferring different sample times for such a block in a seed and a mutant model yields different results.
similar to datatype inference before we mutate the seed model we want to preserve the sample time inference results from the seed model to give slemi more options for emi mutations.
however different from the datatype issue attempting to annotate each block proved to be a dead end.
the simulink documentation encourages users to only annotate either the source blocks or the sink blocks and our initial bug reports that contained blanket sample time annotations for all blocks were rejected for that reason.
based on this feedback slemi now only adds inferred sample time annotations to the seed model s source blocks.
a key feature of cps development tools is their support for simulation of continuous time models via variable step numerical integration .
in other words at each simulation step the tool s output includes the next simulation step s length aka the next simulated execution time point .
by varying time steps the tool may thereby vary simulation efficiency and simulation precision.
from slemi s perspective this again may cause a seemingly small mutation to trigger non emi model changes.
to side step this and related continuous time issue slemi currently performs one base mutation that is not emi.
in the listing pseudo code this mutation appears as the first step of switching the seed model from a variable step to a fixed step solver the latter being widely used in practice .
for such models slemi also disables the related zero crossing detection feature.
while it restricts slemi s bug search space this non emi base mutation does not impact the correctness of the overall workflow since for differential testing slemi only uses preprocessed models.
.
mutating nested zombie regions at a high level this mutation is similar to mutating dead code regions in procedural languages .
slforge generated models do not use simulink s default value inheritance option .
in such a model a top level zombie ignores any values including defaults coming from its nested zombie region.
for such models this mutation hence changes the nested zombie region freely without being observable from the outside world.
due to preprocessing this mutation is easy to implement as during preprocessing slemi has added extensive typecast nodes throughout the model.
this means that even removing a random block within a nested zombie region only has a relatively small 339icse may seoul republic of korea shafiul azam chowdhury sohil lal shrestha taylor t. johnson and christoph csallner chance of introducing a compile error.
this contrasts with procedural languages where for example removing a local variable definition likely causes a compile error in subsequent variable use.
so while existing emi tools tend to remove an entire dead region slemi removes individual blocks from nested zombie regions.
listing create emi mutant from preprocessed m. mutate m i if randomly chosen block b mis nested zombie delete b randomly wire all of b s successors to b s predecessors else if bis top level zombie replace bbydsuch that dmimicks b s output ensure dhasb s sample time else mutate live hierarchy or fork new connection with the per block coverage from preprocessing slemi identifies nested dynamic zombies.
for example in figure block gain 1is a nested zombie as it is nested inside the top level zombie action .
after deleting a nested zombie block slemi randomly reconnects its predecessor blocks to its successor blocks top of listing .
this may leave some of the deleted zombie s predecessor blocks unconnected when the number of incoming connections from predecessors to the deleted zombie block is greater than the number of outgoing connections to successors .
by default slemi ensures that such unconnected predecessor blocks do not get treated as dead code as simulink may otherwise remove them.
.
mutating zombie and live regions since prior work has found mutating live code more effective than mutating dead code we adapt live mutations to cps models and generalize them to also cover top level zombie blocks.
compared to the earlier work s mutation based on program synthesis slemi currently focuses on the mutations of the lower part of listing .
first slemi s live hierarchy extraction mutation extracts a live region and promotes it to its own child model section .
.
slemi then applies standard simulink constructs model reference to reference the new model from the original model following modeling rules to preserve equivalence.
while simulink does not propagate datatypes and other block attributes across such modelreference boundaries slemi again leverages its datatype inference and annotation database from preprocessing.
second slemi s live fork mutation forks an existing live connection to feed the same data to a new signal path.
the new path is live as it terminates in a new sink.
however this path is generated to be not observable as the sink is an assertion block that is designed to be always true.
concretely before the new assertion block slemi currently adds a sequence of simulink math operations blocks.
these additions are emi and have no effect on the produced traces.
finally slemi s live path mutation currently focuses on the special case of replacing a top level zombie block within a live path with another block that is expected to constantly produce the top level zombie s default value.
for example in the figure 4a a b a figure example live path mutation b that replaces a toplevel zombie block action in the b1tob2live path with a live saturation block that mimics the default behavior of the replaced top level zombie block.
example model5 slemi replaces the top level zombie action block with a live saturation block yielding figure 4b.
the saturation block constantly feeds the replaced block s default value to its live successor block b2.
.
keeping mutations emi preserving beyond designing individual mutation operations to preserve emi slemi applies additional rules across mutations.
besides mutations maintaining standard type rules the following focuses on rules specific to cps models.
.
.
avoid algebraic loops.
a slemi mutation should not introduce an algebraic loop i.e.
a circular data dependence path on which all blocks are direct feed through .
on such a loop simulink would need a block b s output value to compute b s input value.
while simulink can solve some algebraic loops so is computationally expensive so slemi avoids algebraic loops.
specifically slemi avoids replacing blocks that are not direct feed through with direct feed through blocks to not turn a benign data dependence loop into an algebraic loop.
for example the figure 5a model contains a benign loop between add anddelay where the latter delays returning its input as an output to the next sample time.
since delay is not direct feed through slemi will not replace it with a direct feed through block such as another add.
a b c b figure example benign data dependence loop a .
adding b4to b yields an invalid execution order priority in c .
5for brevity figure and subsequent figures omit the typecast blocks added by preprocessing.
340slemi emi based mutation of cps models for finding compiler bugs in simulink icse may seoul republic of korea .
.
avoid invalid execution order priority.
during compilation cps tool chains determine the order in which to compute block outputs according to the model s data dependencies optional userrequested block execution priorities and language semantics.
for example simulink orders all block output computations within one block priority level before the blocks of the next level.
for example an ifblock s action subsystems branches receive the same exclusive priority.
since the ifblock explicitly controls the execution of all of its action subsytems they all execute together as an atomic unit whenever the ifblock executes.
this rule disallows placing a block in a path between ifblock s action subsystems.
in the valid figure 5b example model the b2 andb3action subsystems receive the same execution order as that of the ifblock.
adding the b4block outside these subsystems in figure 5c results in a compile error.
whereas the data dependencies call for b4being computed after b2and before b3 blocks b2andb3 must execute at the same time as the ifblock so there is no way to order the execution between b2andb3 resulting in an expected compile time error.
evaluation to evaluate our emi based mutation strategies in terms of their runtime and bug finding capabilities we explore the following research questions.
rq1 how does slemi s runtime compare to slforge?
rq2 can slemi find new cps tool chain bugs?
rq3 does slemi find bugs that slforge misses?
.
seed models and their input values the first potential source of seed models is a large corpus of some 1k user created publicly available simulink models .
of these 1k models given our toolbox licenses we could run models with our simulink installation.
of these models are interactive i.e.
they halt to wait for user input through a terminal or gui and thus we discarded them.
if a non interactive corpus model accepts inputs we used default 0values.
other corpus models have a long simulation duration including infinity which is also not desirable so we limited their simulation duration to seconds since most of the models have this default duration .
only of the corpus models we were able to run had top level zombie or nested zombie blocks.
in contrast slforge generated models had more top level zombie and nested zombie blocks.
slforge generates model plus corresponding inputs which can be readily used together.
in a sample of some models that is representative of the slforge generated models we used in our experiments each model except three had at least one top level zombie or nested zombie block median value .
of the blocks in a model are such blocks .
besides enabling a variety of slemi mutations slforge generated models are attractive for differential testing as they have deterministic outputs by construction.
as a result all of our experiments only used slforge generated i.e.
synthetic models as seeds for evaluating the research questions.
in some sense this is a strength as using slforge generated models enables a fair comparison with slforge.
recall that the research questions all revolve around comparing this paper s techniqueswith slforge.
beyond the research questions in the paper it is too early to tell how this paper s techniques will scale beyond slforge generated models.
.
evaluation setup the slemi prototype tool for finding bugs in simulink is implemented in matlab on top of the parallel computing toolbox.
while in production mode the model mutation and caching jobs run in parallel for debugging one can also configure slemi to mutate models sequentially in an interactive mode pausing after desired mutation operations and highlighting the changes.
slemi and all experimentation data are open source and freely available at github .
for our experiments we used the latest slforge version in its default configuration and matlab releases r2017a r2018a and r2018b .
to evaluate slforge and slemi side by side we ran them separately in two otherwise idle machines each with four intel i74790 cpus at .
ghz bit ubuntu .
and gb ram .
to isolate emi s impact from differential testing for slemi we only compared mutant with seed on a single configuration normal mode with optimization off .
in contrast since slforge emphasizes differential testing for slforge we used all four of its differential testing configurations on each model normal optimization off accelerator optimization off normal optimization on accelerator optimization on .
.
issue reporting and mathworks feedback we reported slemi identified issues via mathworks s bug reports website6 which required a free mathworks account .
while this website listed earlier bug reports this list was not comprehensive and did not mention the corresponding technical support case tsc numbers.
in contrast open source projects often list all bug reports a project has received regardless of issue classification and severity.
for each report except one we eventually received email from mathworks support that classified the issue into new known nonbug pending.
mathworks support usually responded within one business day and interacted further to understand our issue reports.
we did not get further feedback from mathworks support on their assessment of issue significance or severity.
.
mutating is faster than generating rq1 to explore slemi s runtime characteristics we measured both how slemi s runtime scales with model size measured as number of model blocks and how long each slemi phase takes.
for this experiment we used our valid representative generated seed models of various sizes from to some 3k blocks average .
based on earlier work these models are similar to the nontoy models in the largest public corpus of open source simulink models .
from these seed models we then generated mutants by sampling uniformly from the seeds creating some .
mutants per seed on average.
when reporting mutant creation results we report the mean of all mutants generated for a seed.
during initial experiments we realized that individual simulink tool chain phases may produce conflicting results.
for example 341icse may seoul republic of korea shafiul azam chowdhury sohil lal shrestha taylor t. johnson and christoph csallner 24000200400600runtime sec mutations mean run seed coverage datatype mutant gen run mutant diff.
test avg.
mutation figure cumulative runtime of slemi s three seed preprocessing and three per mutant phases data point single seed and its mutants average mutation operations that led to a seed s mutants x axis blocks per seed model data points bars ordered by x value and into correct block seed bin but beyond that not shown on precise x axis location to improve readability stacked bar shows slemi phases from running seed bottom to differential testing top .
a model that failed simulink compilation when collecting block attributes successfully compiled for simulation.
one such issue led to a confirmed bug report case .
to catch such bugs the slemi implementation performs several tasks separately that could conceptually be combined into one phase such as compilation to infer datatypes and execution for coverage collection.
figure shows the number of mutation operations per model which is a user configurable fraction of the number of model blocks available for mutation less blocks not mutated to keep the mutant emi preserving along with slemi phases runtime.
the average phase runtimes in seconds were running the seed .
collecting coverage .
addressing datatype and sample time inference .
generating on average .
mutants .
average mutant runtime .
and average differential testing the seed with one of its mutants .
.
overall differential testing was the longest running phase average of total runtime in each experiment while mutant generation on average consumed only .
.
while the last three phases mutant generation to differential testing run once per mutant all mutants of a seed share the first three phases up to inferring the seed s datatypes and sample times .
in contrast the state of the art random simulink model generator slforge on average took about seconds just to generate a single valid model.
for this experiment slforge generated models that were very similar to the models used as seeds in the slemi experiment.
in other words mutating an existing model in slemi was much faster than generating a fresh model with slforge.
.
slemi found new bugs in simulink rq2 table summarizes our reports.
to date we have reported unique issues to mathworks support who confirmed as a bug of which were already known to mathworks we re discovered them independently .
similarly mathworks support told us when they considered a report a non bug.
the corresponding false positive rate was between and since cases are still pending .
the mutations that contributed to finding the new known bugs were the data type annotation base mutation bugs sample time annotation base mutation nested zombie removal top level zombie removal live fork mutation and live hierarchy mutation .
a bug may be impacted by several mutations.
following are details of some reports.case live hierarchy extraction compile error new bug .
after mutating a seed by moving one of its blocks to a separate model file and then referencing the new model from the seed simulink inherited a different sample time for the block resulting in an error.
however this is not expected since the block supports sample time inheritance for model referencing per documentation.
case live mutation block output mismatch known bug .
having independently re discovered a known issue in the simulink unary minus block where its output diverges for very small floating point inputs between normal andaccelerator mode we implemented mutation by adding such math operation blocks in live signal paths followed by assertion logic to validate the added blocks characteristics.
this emi based mutation also reproduced the bug without entailing differential testing varying tool chain configurations i.e.
simulation modes .
r2019a fixes this bug.
case nested zombie mutation compile error likely new bug .
figure shows condensed versions of the seed model left and the mutant model right .
this mutation replaced the nested zombie blocks inport and transfer1 with a ground block that supports the output datatype double.
however after adding it simulink back propagated uint32 to its predecessor a discretestatespace block that does not accept this type consequently yielding a compile error.
mathworks considers addressing this issue in a future release.
case disconnecting block compile error known bug .
in this mutation we disconnected a nested zombie action subsystem from its predecessors successors and its driving ifblock.
simulink did not remove the block resulting in a compilation error in version r2017a.
this error was unexpected since no ifblock was connected to the subsystem meaning the block would never get executed and the block was also dead so the dead block reduction optimizer should have eliminated the subsystem.
upon further investigation mathworks support identified not explicitly specifying the block datatypes of the blocks in the action subsystem as the root cause and suggested explicitly specifying the types as a workaround for the datatype inference limitations.
accordingly to minimize datatype inference we now preprocess the models and annotate datatypes for all of the blocks in a seed section .
.
we independently re discovered this bug.
simulink r2018a fixed it.
342slemi emi based mutation of cps models for finding compiler bugs in simulink icse may seoul republic of korea table slemi discovered issues tsc technical support case number from mathworks mw feedback from mathworks on bug report n new confirmed bug k known bug f false positive ?
under investigation c bug reported when compiling mutant r bug reported at mutant runtime e emi independently discovers t differential testing independently discovers s missing or hard to find specification e.g.
if only specified in a block configuration gui wizard .
all bugs exist in r2018a except r2017a .
tsc summary mw kind incorrect type inference after replacing block with type compatible ground block n e t c after mutation simulink does not eliminate dead action subsystem k e c valid model stops compiling when collecting inferred properties n e t c invalid data dependency loop for action subsystem after mutation undocumented specification ?
e s c output discrepancy for discrete integrator block due to using different datatype in the mutant ?
e r output discrepancy for sinblock after zero crossing detection f e r datatype inconsistency after enabling signal logging due to complex type inference heuristics n e t c when annotating sample time getsampletime api does not return correct sample time n e c during type annotation discrete transfer function does not accept a valid type.
only way to specify type is through controlling its input signal.
the rule is specified in a gui wizard.f e s c block does not respect sample time inference diagnostic command inheritedtsinsrcmsg k e c signal editor block errors out due to unrelated configuration when specifying sample time n e c behavior difference for unary minus operator when feeding small floating point number k e t r incorrect sample time inference after live mutation by moving blocks via model referencing n e c figur e case condensed removes dead blocks inport andtransfer1 in the seed model left and replaces them with the type compatible double ground right where simulink failed to infer correct datatypes for all of the blocks i.e.
it inferred uint32 at delay s input and propagated it back to the output port of statespace which does not accept it.
figur e case condensed simulink infers different output types for fir filter across different tool chain settings double in normal mode vs. uint32 when compiling to collect the inferred block properties.
case nested zombie mutation mismatch in different tool chain configurations likely new bug .
the excerpted model in figure compiled and ran without errors using simulink s normal mode.
but it produced a compilation error when we attempted collecting block properties after nested zombie block mutation which is unexpected as models that simulate without errors should not raise errors when compiling for collecting these properties.
mathworks support confirmed that these two different workflows use two different heuristics for datatype propagation and would consider making the results consistent in future releases.
.
slemi finds bugs missed by slforge rq3 to compare the emi based mutation in slemi to plain differential testing in slforge on bug finding efficiency we also ran slforge with similar resources.
specifically while our slemi experiments used under cpu hours we gave slforge s default configuration over cpu hours to find bugs.
of these slforge spent on model generation and on differential testing.
compared to slemi s unique bugs in this experiment slforge found two unique new bugs which are a subset of the bugs slemi found with fewer resources.
in addition to the two bugs slforge found upon manual inspection we observed that slforge could have hypothetically found an additional two bugs slemi initially identified via emi if given additional time.
based on our experience with the slforge implementation and its differential testing options the remaining bugs seemed out of reach for slforge.
specifically given the simulink options slforge uses and the simulink language constructs it uses in the models it generates it seems unlikely that slforge can find these bugs.
for example using sample time analysis and annotation slemi discovered a bug tsc .
slforge does not perform similar analysis and annotation so it missed this bug.
.
threats to validity both slforge and slemi are prototype tools that only support a subset of the simulink language and libraries.
from a bug finding 343icse may seoul republic of korea shafiul azam chowdhury sohil lal shrestha taylor t. johnson and christoph csallner perspective it is encouraging that these tools were still able to find several confirmed bugs in a widely used and tested commercial cps tool chain.
a key threat to the validity of our tool comparisons is that the results just represent a particular implementation of the underlying bug finding techniques for one particular cps language evaluated with models produced by a single seed model generator.
different implementation and evaluation choices could influence the tools bug finding abilities significantly.
so without more tool implementations and experiments it would be premature to rule one tool chain testing technique superior to the other.
in any case the common best practice in software validation applies also to finding cps tool chain bugs i.e.
to use all available bug finding tools.
since complete specifications for commercial cps tools are not publicly available and our experiments only involved slforgegenerated models that cover a subset of the simulink functionalities the emi approaches may not generalize to other cps models.
although our approach has already found bugs covering widely used simulink libraries from we consider experimenting with other libraries user created models and other cps tools future work.
related work following is related work on mutating cps models emi based mutation for finding bugs in compilers for procedural languages i.e.
c and opencl finding cps development tool bugs without using model mutation and finding bugs in cps models.
.
mutating cps models as discussed throughout the paper the most closely related work is slforge.
while it mostly focuses on how to create random valid simulink models for differential testing slforge also contains a very restricted version of simulink model mutation.
specifically for a given seed model slforge performs a single mutation operation which statically deletes all dead blocks.
in contrast slemi takes into account model profiling data and performs several novel emibased mutation techniques that address cps modeling challenges not found in procedural code including zombie regions and sample time inference.
overall slemi s was more effective and efficient than slforge.
besides slforge we are not aware of other work performing emi based mutation in cps.
however the more restricted class of static equivalence maintaining mutation has been of interest for several cps related tasks.
for example partial evaluation tries to minimize model size or simulation runtime while maintaining the model s execution behavior .
while partial evaluation produces a class of emi mutants we consider them less promising for finding bugs in cps tool chains since modern tool chains likely already perform some forms of partial evaluation and thus resulting bugs are likely already known to the tool chain developers.
a concrete example is mathworks s simulink design verifier which among others has an option to detect and remove dead logic aka static nested zombie blocks.
static equivalence maintaining mutation is further interesting for model refactoring.
for example tran et al.
present an approach for composing elementary simulink mutation operators into largerrefactorings .
users have to take care to ensure that a composed refactoring preserves model behavior.
also available are more specialized tools that are designed to preserve model behavior while improving a model s layout.
for example the auto layout tool can flatten a hierarchical model by inlining a child model directly into its parent .
other recent work transforms simulink models with the goal that the mutant approximates the seed model s behavior.
these mutations are often more restrictive as they are done statically and they have not yet been applied for differential testing or finding tool bugs.
model clones can have the same or different behavior as their seed.
a recent taxonomy of simulink model mutations for evaluating clone detection techniques was found to capture the manual edits performed on three simulink projects .
mutation testing aims at introducing small semantic changes to check if an existing test suite can detect the mutant s different execution behavior.
in some sense mutation testing is the inverse of emi based mutation.
for example zhan and clark trace all paths from a change to outputs to ensure that a change can be observed .
to select mutants efficiently he et al.
define an equivalence relation on models .
this equivalence notion is much coarser than ours as it will consider equivalent two mutants whose execution behaviors differ widely as long as both mutants are killed detected by the same test case.
.
emi based mutation for procedural code to complement existing schemes for differential compiler testing recent work has developed emi based mutation for c programs and opencl programs .
overall these approaches have found in production level compilers hundreds of previously unknown bugs many of which the compiler developers have already fixed .
while early emi based mutation work focused on mutating dynamically dead program regions through both dead element removal and addition recent work also mutates live program paths .
these previous approaches have in common that their mutations target procedural languages c and opencl that have a complete specification.
in contrast this paper targets a flexible block diagram language that is widely used in cps development which a does not have a publicly available full formal specification and b has several key features not found in c or opencl such as explicit notions of time datatype inference and zombie code.
.
finding cps development tool bugs earlier work has explored several avenues for finding bugs in cps development tools.
most closely related is random model generation with plain differential testing without emi based mutation as implemented in cyfuzz and slforge .
closely related to slforge is a random model and differential testing tool by nguyen et al.
.
the tool first generates random hybrid automaton models and then hyst translates the automaton models to a variety of cps modeling languages including simulink.
other testing and analysis schemes target selected parts of a cps development tool.
for example st rmer et al.
test optimization rules of code generators utilizing graph grammars .
feh r et al.
model the data type inferencing logic 344slemi emi based mutation of cps models for finding compiler bugs in simulink icse may seoul republic of korea of simulink blocks .
in subsequent work we have implemented one more novel emi based mutation technique finding one more simulink bug in version r2018a which is available in shafiul azam chowdhury s doctoral dissertation .
.
finding bugs in cps models finally while this paper looks for compiler bugs in cps tools a complementary line of work analyzes and looks for bugs in cps models .
for example mathworks s simulink design verifier uses static analysis to identify design errors in simulink models such as array access violations division by zero static integer overflow and static nested zombie blocks.
similarly dsverifier applies symbolic model checking based on sat and smt solvers to find design errors in digital systems.
related work generates or evaluates the quality of test cases for cps models e.g.
via mutation testing of simulink models .
other related work synthesizes controllers that are correct by design .
while these directions are important they are distinct from our work which focuses on finding compiler bugs in cps development tools rather than analyzing and testing the cps models.
conclusions finding bugs in commercial cyber physical system development tools or model based design tools such as mathworks s simulink is important in practice as these tools are widely used to generate embedded code that gets deployed in safety critical applications such as cars and planes.
equivalence modulo input emi based mutation is a new twist on differential testing that promises lower use of computational resources and has already been successful at finding bugs in compilers for procedural languages.
to provide emi based mutation for differential testing of cyber physical system cps development tools this paper has developed several novel mutation techniques.
these techniques deal with cps language features that are not found in procedural languages such as an explicit notion of execution time and zombie code which combines properties of live and dead procedural code.
in our experiments the most closely related work slforge found two bugs in the simulink tool.
in comparison slemi found a super set of issues including confirmed as bugs by mathworks support.
future work includes adopting slemi to closely related cps modelling languages including stateflow and the simulink stateflow subset targetlink .