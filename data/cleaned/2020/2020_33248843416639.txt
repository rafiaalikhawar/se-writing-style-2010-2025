er catcher a static analysis framework for accurate and scalable event race detection in android navid salehnamadi abdulaziz alshayban iftekhar ahmed and sam malek school of information and computer sciences university of california irvine usa nsalehna aalshayb iftekha malek uci.edu abstract android platform provisions a number of sophisticated concurrencymechanismsforthedevelopmentofapps.theconcurrency mechanisms while powerful are quite difficult to properly master by mobile developers.
in fact prior studies have shown concurrency issues such as event race defects to be prevalent among real worldandroidapps.inthispaper weproposeaflow context and thread sensitive static analysis framework called er catcher for detection of event race defects in android apps.
er catcher introduces a new type of summary function aimed at modeling theconcurrentbehaviorofmethodsinbothandroidappsandlibraries.
in addition it leverages a novel statically constructed vector clock for rapid analysis of happens before relations.
altogether thesedesign choices enable er catcher to not only detect event race defects with a substantially higher degree of accuracy but also in afractionoftimecomparedtotheexistingstate of the arttechnique.
ccs concepts software and its engineering software testing and debugging.
keywords program analysis android concurrency event race detection introduction modern mobile frameworks promote the development of highlyconcurrentsoftwareapplications or apps forshort.inthecase of android concurrency is ingrained in all facets of app behavior an app s components run within their own threads components can simultaneously interact with components within and outsideoftheappbyexchangingintentmessages thecomponents at any point in time may receive lifecycle e.g.
onstart andonpause andsystem e.g.
locationchange batterylow callbackswithoutanyguaranteesastotheorderinwhichtheymay occur.toaidthedeveloperswithdevelopmentofconcurrentsoftware androidprovisionsseveralnewconcurrencyconstructsinthe form of libraries such as asynctask andlooper.
nevertheless concurrencyisamajorsourceofconfusionfordevelopers and remains among the top reasons for defects in android apps .
ase september virtual event australia copyright held by the owner author s .
acm isbn .
.
.
.
in java such as data race defects are not readily applicable for android .
they neither explicitly consider the event driven model ofapp behavior nor supportthe newconcurrency constructs in android.
more recently researchers have investigatedbothdynamic andstatic analysis techniquesfordetectionofconcurrencyissuesinandroid.dynamicanalysistechniquesproposedsofararelimitedintheircapability as they miss true event races due to their limited coverage of the app behavior .
existing static analysis techniques fail to accuratelyidentifymanyeventracesdueto imprecisemodeling of concurrency behavior in android and adoption of analysesthatareinnatelyflow context thread insensitive.moreover theexistingstaticanalysistechniquesareslow e.g.
nadroid takes about minutes on average to analyze an app.
besides that theseworkssupportonlyasmallandfixedsetofconcurrencylibraries e.g.
sard onlyconsidersasynchronousinvocations byhandler activity andthread apis andcannotbeeasily extendedtosupportotherlibraries.furthermore thetoolsrealizing these techniques are either unavailable or closed source .
inthispaper weintroduceercatcher astaticanalysisframework foreffective detectionof event race defectsin androidapps thataimstoovercometheshortcomingsofpriorworks.threenovel conceptssetourworkapartfromthepriortechniquesandallow us to succeed where others have failed.
first er catcher relies on a new type of summary function calledconcurrency awaresummaryfunction csf formodeling theconcurrentbehaviorofmethodsinbothandroidappsandlibraries.the csfforeachappmethodisautomaticallyextracted whilethesetof csfsrepresentingconcurrentbehaviorofmethods comprising a library are manually constructed as a one time effort.
ercatcherprocessesmethodsinanapp scallgraphinareverse topologicalorder therebyimprovingtheperformanceof analysis i.e.
eliminating the need to reanalyze the same method multipletimes.furthermore bymodelingeachlibrary e.g.
asynctask handler as a set of csfspecifications the implementation of er catcher is completely separated from its support of android libraries.this inturn allowsone toadd supportfor newor modified android libraries by simply providing er catcher with theproper csfspecifications and without requiring changes to the er catcher s implementation.
second ercatcherbuildsitsanalysisonanabstractionrepresentation of app called context and concurrency aware call graph c3g .i nc3g each method call is represented in terms of its three execution states invocation start and end.thestatesareconnected 35th ieee acm international conference on automated software engineering ase this work is licensed under a creative commons attribution international .
license.
325326327for each app method the csfnodes and edges are extracted using the control flow graph of its body.
next for each invocation nodeofaconcurrencylibrarymethodencounteredintheapplogic the correspondinghelper function determinesthe attributes such asrtandtt.
finally to capture the order of calls more accurately we change the source of call graph edges to invocation nodes.
we model the concurrent behavior of android components i.e.
activity service andbroadcastreceiver usingcsfs as well.
an artificially created entrypoint method emulates the invocation of a component s callback methods according to the lifecycle of the corresponding component type.
we automaticallygeneratethe csfofentrypoint methodssimilartoapp methods except the callbacks are invoked asynchronously in main thread.
currently er catcher supports the following concurrencyrelated constructs in android thread looper handler asynctask intentservice serviceconnection and lifecycle methods of activity service and broadcastreceiver .
note that er catcher analyzes both app code written by the app developers and app libraries e.g.
anadvertisement library.
h owever if a library introduces its own concurrency mechanism er catcher requires its corresponding csfforpreciseanalysis.formoredetailsontheimplementation of library csf please visit the er catcher s website .
.
event race candidate detection in parallel to the construction of fine grained models representing the concurrent behavior of an app er catcher analyzes the app to identifyalistofallcandidateeventraces recallfigure2 .thecrudeeventracesidentifiedatthisstagearethenfilteredinthesubsequent steps.
an event race is defined as a triplet stmt1 stmt2 f where stmt1andstmt2are executing in methods m1andm2 andfis afield representingamemorylocationstatically .thesetriplets havetosatisfythefollowingproperties stmt1andstmt2have accesstomemorylocation f andatleastoneoftheaccessesisa write and there is no happens before relation between stmt1 andstmt2 for example theillustrative app of figure1a has two potential event races involving the memory location elapsedtime inittime onpostexecute elapsedtime onpostexecute onpostexecute elapsedtime in this component we do not have any information about the context of methods therefore we use a conservative approach and presume no happens before relation exists between the statements.
we use an off the shelf points to analysis technique spark todeterminethestatementsintwomethodsareaccessingthesame memory location.
.
context augmentation for precise event race detection we need to account for the execution context recall section .
to that end we need to augment c2gwithcontextualinformationtoresolvetheunknownentries suchasunk rtandunk ttincsfs.onenaiveapproachfordeterminingthecontexts ofallmethodsis totraversethecallgraph alongtheedges startingfromtheentrypoint.however suchan approachdoesnotscale becausethenumberofpotentialpathsiso 2n wherenisthenumberofmethods.toaddressthischallenge we use dynamic programming together with two filters race involvement andsynchronoussubstitution whichsubstantiallyprune the analysis and memory space.
once the contexts are determined the remaining parts running and task threads can be determined by simply propagating threading information through the invo cation caller sites.
the result of this component is context and concurrency aware call graph called c3g.
figure depicts the process of determining the contexts for a subset of the illustrative example.
for brevity only the csfnodes involvedinthecontextaugmentationareshownhere.theedges annotated with sare synchronous call graph edges.
weprocessthemethodsof c2g showninfigure4a inareverse topological order.1during this process a method can be in the visited visiting ornon visited stages.foreachvisitingmethod m wefirstapply raceinvolvement filter ifneither mnoranyof m s descendants are involved in an event race we do not process m e.g.
method findviewbyid in figure 4b is pruned.
this filter reducestheanalysisspacedrastically.theevent racecandidate detectioncomponent discussedearlier providesuswithalistof methods that may be involved in an event race.
ifmpassesthisfilter foreachincomingedgetoitsstartnode we makeacopyof mandallofitsdescendantstomakeitsincoming edges unique.
we then connect each edge to the start node ofits corresponding copy making the incoming edge of m s start nodeunique .forexample infigure4b thestartnodeofmethod onpost has only one incoming edge therefore there is only one copy of onpost in figure 4c.
if the invocation of a method is synchronous e.g.
oncreate executeonexecutor it does not impact the concurrent behavior of the app.
in this situation we apply synchronoussubstitution filterby removingthecalleemethod connecting the outgoing edges of caller method to the callee method s children annotating these edges with the caller to maintainthesequenceofinvocations.forexample figure4cshows synchronous substitution ofexecuteonexecutor .
the method executeonexecutor is eliminated and replaced with two annotated edges representing alternative execution contexts.
this filtersubstantiallyimprovestheutilizedmemoryandprocessing time of subsequent steps.
note that since we are processing themethods in the app call graph in a reverse topological order all descendants of mare already visited.
figure 4d shows the final stage of context augmentation.
as mentionedearlier foreachincomingedgeof interm s startnode theedgesfrom oncreate andonclick acopyof interm anditsdescendants onpost iscreated making the incoming edge of each node unique.
once the contexts of all methods are determined the remaining two parts running and task threads can be determined by propagatingthethreadinformationstartingfromtheentrypoint.
the thread of the entry point is already known since it runs on theuithreadandthereisnotaskthread asdepictedinfigure3 .
using the c3gedges we propagate these information.
for example in figure once the caller sites of executeonexecutor are resolved to be oncreate andonclick the specific thread 1ifc2gis cyclic we apply unrolling procedure and eliminate cycles.
328329330methods.
method m1happens before method m2if all end states of m1happen before start states of m2.
we remove all event races in which there is a happens before relation between their method calls.
for example we filter out the eventrace inittime onpostexecute elapsedtime because as depicted in figure there is a happens beforerelation between all end states of inittime and start states of onpost inittime.e onpost .s and inittime.e onpost .s .
however for the event race onpostexecute onpostexecute elapsedtime there is neithera happens before relation between onpost .s and onpost .e nor between onpost .e and onpost .s.
we thus report it as a possible event race.
to further prune the false event races two filters if guard and null at end are designed for use after free uf defects.
a uf defect is a harmful event race where one memory access makesa memory location free writes null and another access uses reads it resultingina nullpointerexception tobethrown.
if guardremovestheufdefectswherethereadaccessisguardedby a null checking condition e.g.
in if f!
null f.use thefield fwillnotbeaccessedifitis null.inaddition null at end filtersufdefectswherethememorylocationisnotreassignedwith avalueotherthan nullafterbecomingfreee g .in f null f new f the field fis not null.
in addition to the above mentioned filters that are sound we alsoprovideseveralheuristicsthatareunsound butinpracticecan significantly reduce the false warnings as described next.
.
prioritization the reported event races by the previous component include all possible event races that need to be reviewed by developers.
to facilitatethismanualprocess weprioritizethedetectedeventraces by our confidence in their existence.
our confidence is inversely relatedtothedegreeofover approximationinthestaticanalysis i.e.
lessover approximationindetectinganeventraceleadstomore confidenceaboutitsexistence.duetotheover approximationof staticanalysisandourconservativeapproach wedonotfilterevent races for which we have incomplete information.
we prioritize event races according to the number of satisfied over approximationproperties.
reachability weprioritizeevent races that are reachable i.e.
there are paths in the call graph from the entry point to both methods of a reachable event race.
the thread sensitive filters are not applied on unreachable event races because their thread information is unknown.
must alias event racesthatinvolvestatementsaccessing must alias fieldshavepriority over may alias fields.
two fields are must alias if they always pointtothesamememorylocation.
known thread eventraces where the threads of their methods are known have more priority than others.
for example when we are not certain about the corresponding looper ofahandler whichcanbethemainthread looper or a custom thread looper we assume its messages are handled in an unknown thread that dispatches messages in parallel.
evaluation thissectiondiscussesourexperimentalevaluationtoanswerthe following research questions rq1how accurate is er catcher in detecting true event races?
rq2how fast does er catcher analyze real world apps?
rq3how effective is er catcher in filtering false event races?
rq4whatistheimpactofmodelingconcurrencyinimproving the overall accuracy of static analysis?
we evaluate er catcher using three different datasets.
first we useasetofbenchmarkappscontainingevent racedefects called bencheroid .
for these apps the ground truth is known allowing us to report the precision recall and f1 score of er catcher.second we use a curated dataset of real world apps withevent race defects that have been confirmed through either dynamic analysis or code commit messages.
we collected these apps byreviewingthepriorliterature andcrawlingtheopensource repositories.
finally we evaluate the scalability and effec tiveness of er catcher using randomly selected apps from f droid .
table summarizes the datasets used for evaluation.
we compare er catcher with nadroid the state of the art staticuse after free uf event race detectorthatisavailablepublicly butnotentirelyopen source.sincenadroiddetectsonlyuf event races to make the comparison fair between er catcher and nadroid we configure er catcher to report only uf event races.
wealsotriedtoempiricallycompareercatchertoseveralother tools namely sierra sard asyncclock and eventracer .
since none of these tools are available we contacted the corresponding authors.
unfortunately despite multiple attempts theauthorseitherdidnotrespondtousorconfirmedtheir inabilitytoreleasetheirtool.weprovideaqualitativediscussion of thedifferences betweener catcherand theseother techniques in section .
table properties of datasets used in our experiments.
dataset apps criteria average median minmax bencheroid dataset34 methods .
components size kb curated dataset31 methods components size kb f droid dataset500 methods components size kb .
rq1 accuracy we ran er catcher and nadroid on the apps provided by bencheroidtomeasuretheirrespectiveaccuracy.theresultsare shownintable2.theactualnumberofeventracesinthebenchmarkappsareshownincolumn2.nadroidusestwodifferentfilters soundandunsound forreducingfalseeventraces wereportboth ofthemincolumns3and4 respectively.wereporttheeventracesidentifiedbyercatcherincolumn5andtheprioritizedeventraces recallsection3.
incolumn6.wecategorizetheappsprovidedby 331bencheroidintofourgroups.thefirstgroupisnon ufeventraces.
we do not consider them in comparing the accuracy of er catcher withnadroid sincenadroiddoesnotreportnon ufeventraces.
thesecondandthirdgroupsconsistofappscontainingufevent races related to flow and thread sensitivity respectively.
the rest of the apps are placed in the other uf category.
table benchmark result.
the general event races highlighted rows were not considered for the accuracy metrics.
circlecopyrttrue positive circlecopyrtfalse negative false positive.
app name ground truth event races nadroid sound nadroid unsound er catcher er catcher prioritized non uf event races singleactivity7 circlecopyrt circlecopyrt circlecopyrt circlecopyrt singleactivity8 circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt service5 circlecopyrt circlecopyrt circlecopyrt circlecopyrt asynctask5 circlecopyrt circlecopyrt circlecopyrt circlecopyrt asynctask6 flow sensitive uf singleactivity2 singleactivity5 circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt singleactivity6 circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt asynctask2 looper1 thread sensitive uf singleactivity3 circlecopyrt circlecopyrt circlecopyrt circlecopyrt asynctask1 circlecopyrt circlecopyrt circlecopyrt circlecopyrt asynctask3 circlecopyrt circlecopyrt circlecopyrt circlecopyrt thread1 circlecopyrt circlecopyrt circlecopyrt circlecopyrt thread2 circlecopyrt circlecopyrt circlecopyrt circlecopyrt looper2 circlecopyrt circlecopyrt circlecopyrt circlecopyrt service3 circlecopyrt circlecopyrt circlecopyrt circlecopyrt service4 other uf multicomp1 circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt receiver circlecopyrt circlecopyrt circlecopyrt circlecopyrt service1 service2 circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt lifecycle1 circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt lifecycle2 lifecycle3 circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt lifecycle4 circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt circlecopyrt singleactivity1 circlecopyrt circlecopyrt circlecopyrt circlecopyrt singleactivity4 asynctask4 circlecopyrt circlecopyrt circlecopyrt circlecopyrt executor1 circlecopyrt circlecopyrt circlecopyrt circlecopyrt executor2 circlecopyrt circlecopyrt circlecopyrt circlecopyrt timertask1 circlecopyrt circlecopyrt circlecopyrt circlecopyrt timertask2 circlecopyrt circlecopyrt circlecopyrt circlecopyrt looper3 circlecopyrt circlecopyrt circlecopyrt circlecopyrt total circlecopyrt higher is better total circlecopyrt lower is better total lower is better precision recall f1 overall er catcher is significantly more accurate than nadroid.
er catcher achieves precision and recall compared to nadroid s precision and recall.
due to its flow sensitivity er catcher is able to filter all of the false positives reported by nadroidundertheflow sensitiveufcategory.duetoitsthreadsensitivity ercatcherisabletoidentifyadditionaltrueeventraces compared to nadroid under the thread sensitive uf category.althoughercatcherismoreaccuratethannadroid ithasits ownlimitations.ercatcherispath insensitive thereforeitreports falsepositiveufeventracesthatresideonexecutionpathsthatwillnotexecute e.g.
service1 .duetotime insensitivity ercatcher reports false positives in cases where the statements execute atspecific times e.g.
singleactivity4 .
er catcher fails to filter one false positive event race in singleactivity1 due to incomplete reachability information however it is removed in er catcher prioritized .
the imprecision in the off the shelf points to analysisusedbyercatcherleadstoafalsenegativein service2 .
we also ran er catcher and nadroid on the curated dataset consisting of real world apps with confirmed event races.
er catcherwasabletoanalyzeallofthe31apps whilenadroidcouldonlyanalyze27ofthem.ercatcherachieved100 recall detecting all of the event races in these apps while nadroid achieved recall.
since not all of the event races in these apps are known we are unable to report the recall using this dataset.
.
rq2 scalability we analyzed all three datasets using er catcher and nadroid to compare the scalability of these techniques.
table summarizes the results.
for the first two datasets i.e.
bencheroid and curated datasets we did not set a timeout.
however due to the large number of apps in the third dataset f droid we set a timeout of minutes.onaverage ercatcheranalyzedeachappinthecurated dataset within seconds while nadroid required seconds minutes .
overall er catcher finished the analysis between to times faster than nadroid for the first two datasets.
forthef droiddataset ercatcheranalyzed459outof500apps morethan within thedesignated timeof 5minutes two apps couldnotbeanalyzedbecauseflowdroidcouldnotgeneratethe call graph for them .
however nadroid could only analyze apps withintheallottedtime.furthermore nadroidcrashedduring analysis of apps more than indicating nadroid isunable to complete the analysis irrespective of time.
table analysis time summary analyzed apps average median min max bencheroid datasetnadroid 29217s145s131s372s er catcher 2918s20s7s35s nadroid er catcher1x12x7x18x10x curated datasetnadroid 273134s786s83s22690s er catcher 31231s29s4s5548s nadroid er catcher0.87x 13x27x21x 4x f droid datasetnadroid 30153s152s108s285 s er catcher 53s29s4s296 s nadroid er catcher0.06x 3x5x27x0.96x .
rq3 effectiveness of filters toevaluatethedegreetowhichercatcherfiltersoutfalseevent races in real world apps the number of uf event races in threestages of analysis are reported in table .
the first row shows the number of event race candidates identified by the event race candidate analysis component recall section .
.
the second 332rowshowsthenumberoffilteredufeventracesreportedbythe thread sensitivefilter component recallsection3.
.thefourth row reports the number of prioritized uf event races recall section .
.
the reduction rates achieved for the curated and f droid datasetsare 77and respectively.thisresultsinprioritizing 37and23ufeventracesthatrequiremanualinvestigationbydevelopers.inpractice manyofthedetectedeventracesarecaused bythesamedefectincode i.e.
onedefectincodecauseseventrace conditions under multiple execution contexts.
as a result developers can often confirm the presence of a defect without having to review the complete list of reported event races.
table effectiveness of filters and prioritization criteria average median minmaxcurated dataset uf candidates filtered ufs filtered candidates50 prioritized ufs prioritized candidates23 f droid dataset uf candidates filtered ufs filtered candidates45 prioritized ufs prioritized candidates14 .
rq4 impact of modeling concurrency a byproduct of modeling the concurrent behavior of android apps and libraries in the form of c2gis that er catcher can discover a number of additional methods that are invoked indirectly i.e.
through the library callbacks.
this enables er catcher to compute reachability of methods in ways that are more accurate than other state of the art techniques such as flowdroid .
to evaluate this facetofourwork weranbothercatcherandflowdroidonthe f droid dataset.
we identified additional reachable methods in of these apps.
compared to flowdroid er catcher was able to detect on average more reachable methods per app and up to more reachable methods in one app.
thisisnotablegiventheextensivenumberoftools e.g.
thatrelyonflowdroidforanalysisofandroidapps particularlyforsecurityassessment.consider forinstance aninformation leakage vulnerability caused by flow of data from a private source e.g.
camera to a sink e.g.
network.
if the sink is located in a methodthatisdeterminedtobeunreachablebytheanalysis the vulnerability cannot be discovered.
according to our results numerous android security analysis tools built on top of flowdroid would fail to discover vulnerabilities or malicious behaviors that reside in such locations in code.
related work ourworkbuildsuponthreemajorthreadsofresearch concurrency analysis event racedetection andsummary basedstaticanalysisinandroid.weprovideabriefoverviewoftherelevantresearch for each of these threads in this section.
analysis of concurrent behaviors researchers have investigated concurrent behaviour of traditional programminglanguages such as c or java primarily focusing on data races deadlocks happens before relation sequential ornonsequentialconcurrencyerrors andtesting .noneof these however hasinvestigatedtheconcurrentbehaviorofandroid apps.
the most relevant work is that of zhou et al.
that introducestheconceptofstaticvectorclocktoanalyze may happenin parallel relation betweeninstructions inc c however their realization of this concept is not applicable to event based systems likeandroid.ercatcheraddressesthislimitationbyintroducing event based properties e.g.
same task queue order.
researchershavealsoanalyzedtheconcurrentbehaviorofandroidapps mostlyfocusingondynamicanalysessuchastestgeneration manipulating the code execution and detecting happens beforerelations .noneofthesetechniquesisableto detect event races in android.
event race detection in android although android has traditionaljavathreadconstructs toolsdevelopedforjavacannotreadily detecteventracesinandroidsinceexistingtoolsareunawareofrelations between events.
to meet this gap researchers have devised dynamic and static event race detection approaches for android.
dynamicevent racedetection approachesgather executiontraces of android apps either manually or automatically usinganappcrawlersuchasmonkey .thentheexecutiontraces are analyzed off line to detect happens before relations betweenevents either by graph analysis or leveraging vector clock .thesetechniquesfailtoidentifyeventracesduetotheir limited coverage of the behaviors of apps .
static event race detection techniques address the problem of missingtruedefectsbyanalyzingthewholeprogram.deva detects event anomalies where two events access the same memorylocation andoneoftheaccessesisawrite.sincedevadoesnot considerhappens beforerelations itproducesalargenumberof false positives.
sierra considers happens before relation and haslimitedcontext sensitivity capturingonlyoneasynchronous actionas the context but it is not aware of other threads except for the main thread which may result in failure to identify bugs weaddressedthisissuebyourthread sensitiveanalysismodeled inc3g.
nadroid uses an existing traditional race detection techniquetoidentifyuse after free uf bugs.duetotheimprecisethreadificationmodelofnadroid itreportsalargenumberof false positives we extensively explained and empirically evaluated the limitations of nadroid in comparison to er catcher earlier.
sard similar to nadroid detects uf bugs using a flow and context sensitive model of looper.
sard applies an exhaustive contextcreationstrategymakingitunscalable.weaddressthescal abilityissuebyusingsummary basedanalysistechniquestoreduce the space complexity.
inallofthementionedtechniques thesupportforvariousandroid concurrency libraries is hardcoded in the implementationof tools making it difficult to revise the tools to support new or modified android libraries.
er catcher addresses this limitation by separating the implementation of tool from the library csfs representingtheconcurrentbehaviorofandroidlibraries.providedwith 333new or modified library csfs er catcher can be readily extended to support new or modified android libraries without requiring changestoitsimplementation.
summary basedstaticanalysisin android another research thrust has investigated summary based approachesforpreciseandfastanalysis .these techniquesmostlyuseinter proceduraldistributedenvironment ide framework for modelling the inter procedural data flow of the code however to the best of our knowledge no prior work has leveraged ide frameworks to model concurrent behavior of codelikehappens beforerelations.moreover noneofthesetechniquescaptureinter threadcommunicationprecisely.asafuture work it would be interesting to see if ide frameworks or nondistributive summary based analyses such as can improve thescalabilityofcreatingthe c3gmodel.ercatchertakesastep towards addressing this issue by introducing ways of summarizing concurrency behavior in android.
conclusion concurrency induced defects such as event race are one of the most frequently encountered types of defect in android apps .
we presented er catcher a fast novel and accurate static analysis framework for event race detection in android.
experiments using benchmarkappsshowthatercatcherisaccurate capableofdetectingeventraceswith80 precisionand93 recall.compared to the only other publicly available tool for event race detection in android ercatcherissubstantiallyfaster byafactorof12 and moreaccurate higherf1 measure .resultsfurthercorroborate itseffectivenessindetectingalloftheeventracesconfirmedtoexist in a set of real world apps.
in our future work we plan to expand the applications of er catcher to other concurrency related analyses.
we believe the efficienthappens beforeanalysisofercatchercanbeusedasaplugin in android studio to provide real time feedback to developers duringthedevelopment.furthermore sinceconcurrencyisthemain cause of flaky tests we aim to study the application of er catcher in the detection of such tests.
ercatcherandresearchartifactsarepubliclyavailablefordownload from the companion website .
acknowledgment thisworkwassupportedinpartbyawardnumbers1618132and 1823262fromthenationalsciencefoundation.wewouldliketo thank the anonymous reviewers of this paper for their detailed feedback which helped us improve the work.