enhanced compiler bug isolation via memoized search junjie chen college of intelligence and computing tianjinuniversity china tianjin junjiechen tju.edu.cnhaoyang ma college of intelligence and computing tianjinuniversity china tianjin haoyang 9804 tju.edu.cnlingming zhang university of illinois at urbana champaign usa il urbana lingming illinois.edu abstract compiler bugs can be disastrous since they could affect all the softwaresystemsbuiltonthebuggycompilers.meanwhile diagnosing compiler bugs is extremely challenging since usually limited debugginginformationisavailableandalargenumberofcompiler filescanbesuspicious.morespecifically whencompilingagiven bug triggering test program hundreds of compiler files are usu ally involved and can all be treated as suspicious buggy files.
tofacilitate compiler debugging in this paper we propose the first reinforcementcompiler bugisolationapproach viastructuralmutation called recbi.
for a given bug triggering test program recbi first augments traditional local mutation operators with structural ones to transform it into a set of passing test programs.
sincenot all the passing test programs can help isolate compiler bugs effectively recbi further leverages reinforcement learning to intelligentlyguidetheprocessofpassingtestprogramgeneration.then recbiranksall thesuspiciousfilesbyanalyzingthe compilerexecution traces of the generated passing test programs and the given failingtestprogramfollowingthepracticeofcompilerbugisolation.
theexperimentalresultson120realbugsfromtwomostpopularc open sourcecompilers i.e.
gccandllvm showthatrecbiisabletoisolateabout23 bugswithintop top top 10compilerfiles andsignificantlyoutperformsthestate of the artcompiler bug isolation approach by improving .
.
.
isolationeffectivenessin terms of top top top results.
ccsconcepts software and its engineering software testing and debugging compilers theory of computation reinforcement learning .
keywords compilerbugisolation faultlocalization reinforcementlearning bothauthorscontributed equally to this paper.
junjiechenis the corresponding author.
permissionto make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia 2020association for computing machinery.
acm isbn ... .
reference format junjie chen haoyang ma and lingming zhang.
.
enhanced compilerbugisolationviamemoizedsearch.in 35thieee acminternational conference on automated software engineering ase september virtual event australia.
acm new york ny usa pages.
introduction compilers are one of themost fundamental software systems since almost all software systems ranging from operating systems web browsers to script code written by end users are compiled by them.
although dedicated efforts have been devoted to ensuring their quality compilers are still error prone due to their extremely large scaleandcomplicatedcodebases .inpractice compilerbugsareveryharmful andcanpotentiallyaffectallthe software systems compiled by the buggy compilers.
therefore it is essentialto detect isolate and fix all possible compiler bugs.
in the literature many approaches have been proposed to automaticallydetectcompilerbugs but there is limited research efforts dedicated to automated debugging of compiler bugs such as bug isolation and fixing.
that is compilerbugisolationandfixingarestillarathertediousandtimeconsumingprocessformoderncompilers.inparticular compiler bugisolationisamorefundamentalproblemsinceitalsodirectly helpswitheffectivecompilerbugfixing.althoughmanyautomated bug localization approaches such as spectrum based slicing based mutation based andtherecent program repair based approaches have beenproposed for commonsoftwaresystems theseexistingapproachescanhardly isolate compiler bugs due to either extremely high costs or pooreffectiveness please refer to the extensive discussion in a recent work for more details.
to facilitate compiler bug isolation chen et al.
proposed the first approach named diwi which transforms the problemofcompilerbugisolationtotheproblemofpassingtestprogramgeneration.
more specifically given a failing test program diwi first generates a set of passing test programs by traditional local mutationoperators whichchangeminimalprogramelementssuch as modifiers and constants and then leverages existing bug localization techniques to identify the compiler buggy files by comparingtheexecutiontracesbetweenthegeneratedpassingprograms andthe givenfailing testprogram.
althoughthe generated passing test programs via diwi has been demonstrated to perform better thanbothdeveloper written test programsand the testprograms generated by the widely used compiler fuzzing technique i.e.
csmith for compiler bug isolation diwi still suffers fromtheeffectivenessissue.
forexample asdemonstratedbythe ui .
oufsobujpobm pogfsfodf po vupnbufe 4pguxbsf ohjoffsjoh ase september virtual event australia junjie chen haoyang ma and lingming zhang existingwork andourstudy tobepresentedinsection4.
developersusingdiwistillneedtocheckabout15innocentfiles beforefindingthereallybuggyoneonaverage about62.
studied bugs cannot be successfully isolated after checking most suspicious files recommended by diwi please note that in practice most developers tend to abort the automated debugging tools if they cannot localize buggy elements within top positions .
to further advance state of the art compiler bug isolation in this paper we propose an enhanced compiler bug isolation approachvia memoized search andstructural mutation called recbi reinforcement compilerbugisolation .
more specifically since compiler bugs tend to occur in the components of compiler optimizationsthattendtodependontestprogramstructure foragiven compiler bug with a failing test program recbi first augments the traditional localmutationoperatorsusedbydiwiwith structural mutationoperators whichchangethetestprogramstructurebyinserting some control flow alerting statements such as branch andloopstatements toeffectivelygeneratesimilartestprograms thatcanflipthecompilerexecutionresults i.e.
from failingto passing .
this is because traditional local mutation operators usually have small influence on program structure due to its minor modification while structural mutation operators can augment the ability of changing program structure by effectively altering the control flow of test programs and in the meanwhile optimizations areofteninvolvedincompilerbugsandstructuralmutationisgood atskippingthebuggyoptimizations.however notallthegenerated passing test programs can facilitate isolating compiler bugs and thus casually or simply heuristically performing mutations on the given failing test program may not be effective.
thus recbi further incorporates reinforcement learning a kind of memoized search which can effectively learn both historical and future knowledge tointelligentlyguidehowtoconductmutationinorder to generate a set of more effective passing test programs during agivenperiod.finally similartotheexistingwork recbi ranksallthesuspiciousfilesaccordingtotheirsuspiciousscoresby comparing the compiler execution traces between the generated passing test programs and the given failing program.
in a word the novelties of recbi are twofold it opens a new dimension for compiler bug isolation via structural mutation it leverages reinforcement learning for more intelligent compiler bug isolation.
toevaluatetheeffectivenessofrecbi weconductedanextensive studybasedon120realcompilerbugsfromgcc andllvm whichare the most widely used c compilers in both industry and academia .ourexperimentalresultsshowthatrecbi isabletoisolate27 107bugs outof120compilerbugs within top top top and top files respectively.
that is about and bugs can be isolated successfully within top top top and top files through recbi respectively.
in particular recbi substantially outperforms the state of the art approachdiwi.forexample theimprovementsofrecbioverdiwi are up to .
.
in terms of top top results .
in terms of mfr mean first rank measuring the effectiveness in detectingthe first buggyfile for eachbug and .
in terms of mar meanaveragerank measuringtheeffectivenessindetecting all the buggy files for each bug .
furthermore we investigated the contributionsofbothmajorcomponentsinrecbi i.e.
structural1intprintf const char ... 2inta b 3intmain 4inti 5for i i i for a a 8int c b 9if c c unsigned int c printf d n b return a failing program1intprintf const char ... 2inta b 3intmain 4inti 5for i i i for a a 8int c b while a if c c unsigned int c printf d n b return b passing program figure gcc bug mutation and reinforcement learning for passing test program generation as well as the impacts of different recbi configurations.
to sum up this paper makes the following main contributions this work opens a new dimension of compiler bug isolation via structural mutation i.e.
leveraging carefully designed structural mutation operators for generating passing test programs to boost compiler bug isolation.
this work brings reinforcement learning to the compiler bug isolation area for the first time i.e.
leveraging stateof the artreinforcementlearningtointelligentlyguidethe structural mutation based compiler bug isolation process.
theproposedtechniquehasbeenimplementedasapractical compiler bug isolation system named recbi based on mature tools and libraries i.e.
clang libtooling library gcov and pytorch .
this work conducts an extensive study based on real compiler bugs from two most widely used c compilers i.e.
gcc and llvm to evaluate the effectiveness of recbi.
the results reveal the effectiveness of recbi significantly out performing the state of the art diwi the contribution of eachmajorcomponentinrecbi andtheimpactsofdifferent recbi configurations.
background .
test program mutation for compiler bug isolation to solve the problem of compiler bug isolation chen et al.
transformsthisproblemtotheproblemofpassingtestprogramgeneration.accordingtotheideaofspectrum basedbuglocalization alsocalledsbfl allthecompilerfilestouchedbyagiven failingtestprogramduringcompilationaresuspectsandpassing test programs are helpful to reduce the suspicion of innocent files.
if a passing test program has similar execution trace except the buggy files with the given failing test program the buggy filesare more likely to be isolated by comparing the execution tracebetween the passing test program and the given failing test program.therefore diwidesignsthreecategoriesoflocalmutation operators to produce such similar passing test programs by changing three minimal program elements i.e.
variables constants and operators of the given failing test program.
although these traditional local mutation operators in diwi cangeneratesomepassingtestprogramsasdemonstratedbythe enhanced compiler bug isolation via memoized search ase september virtual event australia existing work their effectiveness actually is restricted.
this is becausecompilerbugstendtooccurinthecomponentsofcompiler optimizations which tend to depend on test program structure onthecontrary traditionallocalmutationoperatorsusuallyhave small influence on program structure due to their minor modificationandthuscouldomitmanyeffectivepassingtestprograms.
therefore incorporatingnovelmutationoperatorsthatcaneffectively altering program structure is necessary for compiler bug isolation.
in this work we introduce the notion of structural mutation whichaugmentstheprogram structure alteringabilityby inserting some control flow alerting statements such as branch and loop statements .
weusefigure1toillustratetheeffectivenessofstructuralmutation.
figure 1a shows a failing test program which triggers a gcc bug id when using o2and above of gcc revision tocompileit.thisbugliesinthefile combine.c andtherootcause isthatan isns thertlrepresentationofthecodeforafunction in gcc sets a wrong notefor a pseudo register after the correct notehasbeendistributed.whenusingtraditionallocalmutation in diwi to isolate this bug during the given period i.e.
one hour passingprograms are generated andthe buggy file isranked at the 30thposition.
however when introducing structural mutation there are passing programs generated by structural mutation.
figure1bshowsoneofthe20passingprograms.byinsertingthe statement while a in line the buggy optimization can be effectively avoided leading to passing execution.
with the help of structuralmutation the buggyfile is ranked at the7thposition.
.
reinforcementlearning to more efficiently generate effective passing test programs we aimtoincorporatereinforcementlearningtoguidetheprocessof passing test program generation and thus we briefly introduce somebackground of reinforcement learning.
reinforcement learning aims to learn how an agent should take actionsinanenvironmentinordertomaximizecumulativereward inalongrun .anagenthasmanystatesandactions and duringthelearningprocess itperformsanactionatastate then measurestherewardobtainedbythisaction andmovestothenext state.
through such a process the agent gradually learns to select a better action at the next state in order to obtain more reward.
in general reinforcement learning can be divided into two categories value based algorithms e.g.
deep q learning algorithm and policy basedalgorithms e.g.
policygradientsalgorithm .the former is a deterministic strategy that approximates the optimal valuefunctiontoselectthebestactionateachstateandtendsto be efficient and steady while the latter is a probabilistic strategythat learns the probability distribution i.e.
policy of actions to obtainthemostreward andtends tofit continuousandstochastic environmentsand have faster convergence.
withthedevelopmentofreinforcementlearning thealgorithms mergingbothvalue basedandpolicy basedstrategies calledactorcritic algorithms ac are proposed .
in ac the actor controls howtheagentbehavesbylearningthebestpolicyviaanactorneuralnetwork ann whilethecriticpredictstherewardachievedby the action by calculating the value function via a critic neural network cnn .
subsequently the improved versions of acdeveloper provided test programs ingredient pool seed test program mutated test program ppp ggg gg figure overview of structural mutation are proposed i.e.
advantage actor critic a2c and asynchronousadvantageactor critic a3c .insteadofthevalue function a2clearnstheadvantagevaluefunctionbyevaluating both how good the action is and how much better it can be which incorporatesfutureknowledge whichcanreducehighvariances of neural networks.
a3c further incorporates the asynchronous mechanism to improve the learning efficiency.
in this work we utilize the framework of a2c to solve the problem of compiler bug isolation since it is both effective compared with ac and suitable to single thread and multi thread systems compared with a3c .
approach in this section we present our reinforcement compiler bug iso lation approach via structural mutation named recbi.
given a compiler bug with a failing test program recbi first generates a set of effective passing test programs by mutating the given failing testprogramthroughareinforcementlearningbasedmutationprocess.
second based on the given failing test program and the set ofgeneratedpassingtestprograms recbileveragesoff the shelf sbfltoidentifythecompilerbuggyfiles.themaincontribution of recbi lies in the first step.
during the process of passing test program generation besides changing minimal program elements viatraditionallocalmutation recbifurtherincorporatesstructural mutation to change the structure of the given failing test program whichcould enlargethemutationspace toincludemore effective passing test programs.
however not all the passing test programs can facilitate to isolate compiler bugs as demonstrated by the existing work and thus casually conducting mutation on the given failing test program may not be effective.
therefore recbi further incorporates reinforcement learning which could effectively learnboth historical and future knowledge to learn how to intelligentlyconduct mutation on the given failing test program so that a set of more effective passing test programs can be generated.
in the following we introduce our structural mutation in section3.1andpresentourreinforcement learningbasedtestprogram generation in section .
.
although we do not propose any new sbflformulatocalculatethesuspiciousscoreofeachcompilerfileinthesecondstepofrecbi westillbrieflyintroducetheapplication of sbfl in recbi in section .
to make the paper self contained.
ase september virtual event australia junjie chen haoyang ma and lingming zhang 1volatile 2inta b c 3unsigned d 4intmain 5inte 6d 7for d d for e b if c break e a return a failing1volatile 2inta b c 3unsigned d 4intmain 5inte d for d d for e b if c break e a return b locations1volatile 2inta b c 3unsigned d 4intmain 5inte if long a a 7d 8for d d for e b if c break e a return c mutant figure example of structural mutation .
structuralmutation thegoal ofmutationisto flipthecompilerexecution result from failing topassing by transforming a given failing test program.
aspresentedinpriorwork mostofcompilerbugs occur in the components of compiler optimizations while the triggering of compiler optimizationstends to depend on the structure of test programs.
therefore transforming the structure of a given failing test program is helpful to generate effective passing test programs.
however the existing local mutation operators in diwi usually have small influence on program structure due to its minor modification and thuswe furtherexplore structuralmutation in recbi.
more specifically we design four structural mutation operators whichinsertfourdifferenttypesofstatementstoagiven failing test program respectively to change the control flow of the failingtestprogram.thefourtypesofinsertedstatementsare1 branch statements loop statements function calls and gotostatements since they are recognized to be effective to changethe control flow of a program .
exceptgotostatements theother three types of statements require additional ingredients i.e.
conditions in a branch or loop statement aswellasthecalledfunctionanditsparametersinafunction call to complete insertion.
however it could be inefficient to casually construct these ingredients.
as demonstrated by the existing work although the state of the art compiler bug isolation approach diwi outperforms the approach using the developerprovidedtestprogramstoisolatecompilerbugs thelatterisable to perform no worse than the former in some cases.
therefore it may be promising to adapt the ingredients already within the developer providedtestprogramsforourstructuralmutation.in thisway theuniquevalueofthedeveloper providedtestprograms embodied in the existing work can be incorporated by recbi.
figure2showstheoverviewofourstructuralmutation which consists of three steps.
first recbi extracts all the branch condi tions loop conditions declared functions and the corresponding functioncalls inthedeveloper providedtestprogramsforthecompiler under test as an ingredient pool.
second recbi randomlyselects an ingredient from the ingredient pool according to thetype of the statement to be inserted and randomly selects an insertablelocationintheseedtestprogram.itwouldproduceinvalid test programs or fake passing test programs i.e.
the generatedpassingtestprogramsarenotreallypassingandjustremovetable summary of mutation operators in recbi iddescription 1inserta branch i.e.
if statement 2inserta loop i.e.
while statement 3inserta function call 4insertagotostatement 5insert remove a qualifier i.e.
volatile const and restrict 6insert remove a modifier i.e.
long short signed and unsigned 7replacea variable with another valid one 8replacea constant with another valid one 9replace remove an unary operator 10replacea binary operator with another valid one.
thetestoracles when insertingastatementtoanimproper loca tion.
there are three types of non insertable locations in recbi the locations outside functions the locations before declarations for the sake of maintaining the identifier scope and the locations before the statements used as test oracles such as printf builtin abort return statements .
third recbi performsinsertion andthenconductsrefactoringfornewvariables in the selected ingredient i.e.
renaming the new variable to those withintheseedtestprogramwithcompatibletypes tomakethe mutated test program valid.
figure shows an illustrative example forstructuralmutation wherefigure3aisafailingtestprogram figure 3b identifies all the insertable locations denoted as in the failing test program and figure 3c is a generated passing test programvia ourstructuralmutation by inserting abranch statement .
localmutationoperators.
besidesthesestructuralmutationoperators recbialsoincorporatesthetraditionallocalmutationoperators targeting the minimal program elements which have been studiedbytheexistingworkforcompilerbugisolation .thereason is that the generated test programs via these local mutation operators have been demonstrated to outperform the developer provided test programs and the test programs generated via the widely usedcompilerfuzzingtechnique i.e.
csmith and for the compiler bugs in the front end component although the number of this type of compiler bugs is rare local mutation could be very useful.
therefore recbi has mutation operators in total which are summarized in table .
testoracles.
after mutation it is also required to check whether thegeneratedtestprogramispassingorstillfailing .according to the types of compiler bugs i.e.
crash bugs and wrong code bugs recbi considers two types of test oracles accordingly.
regarding crash bugs i.e.
the compiler crashes whenusing some compilation options to compile a test program theusedtestoracleiswhetherthecompilerstillcrasheswhenusing the same compilation options to compile a generated test program.
regarding wrong code bugs i.e.
the compiler mis compiles a test programwithoutanyfailuremessages causingthetestprogram tohaveinconsistentexecutionresultunderdifferentcompilation options theusedtestoracleiswhetherageneratedtestprogram still produces inconsistent execution results under the compilation optionsproducing inconsistencies before.
enhanced compiler bug isolation via memoized search ase september virtual event australia .
test program generation via reinforcementlearning sincenotallthepassingtestprogramsarehelpfultoisolatecompiler bugs as demonstrated by the existing work it could be ineffective to randomly perform mutation on a given failing test program.
in particular different compiler bugs have different characteristicsandrootcauses andthustheeffectsofthesemutation operators on different compiler bugs can be different.
therefore itisnecessaryforeachspecificcompilerbugtolearntheeffectof each mutation operator in order to generate more effective passing test programs efficiently during the given time period.
as presented in section .
reinforcement learning is a wellrecognized strategy to guide an agent to behave better in an environmentsoastoobtainthemostreward whichhighlymatches ourproblem i.e.
learningtogeneratemoreeffectivepassingtest programs.therefore toachieveourgoal weleveragethepowerof reinforcement learning in recbi where reward refer to the quality ofgeneratedpassingtestprograms tobeexplainedinsection3.
.
.
morespecifically anagenthasmanystatesandactions andduring the iterative process of reinforcement learning the agent learns moreandbetterbyconductinganactionatastateandthenmeasur ingtherewardofthisaction.inrecbi a statereferstoastateofthe set of mutation operators i.e.
the number of times that each mutation operator has been selected to generate passing test programs while an actionrefers to selecting and then applying a mutation operator to a given failing test program.
here recbiadoptstheframeworkofa2c tolearntheeffects of these mutation operators in order to guide the generation ofeffective passing test programs for a given compiler bug.
this isbecause it has been demonstrated to be effective and efficient in practiceandperformstablywithlowvariance .moreover a2cconvergesfasterthanthetraditionalacalgorithm.figure4 illustratestheoverviewofthereinforcementlearningbasedstrategy inrecbi.followingtheframeworkofa2c recbiconstructstwo neuralnetworks i.e.
ann actorneuralnetwork andcnn critic neural network .
ann aims to predict the probability distribution ofactionsbasedon historicalknowledge andthenchooseanactionto beperformed whilecnnaimstopredictthepotentialrewardtobe accumulatedfromthecurrentstatetoafuturestateafterperforming the selected action which incorporates future knowledge.
based onthepredictedpotentialrewardand theactualrewardobtained by performing the selected action recbi adopts an advantage loss function tobeintroducedinsection3.
.
toupdatebothannand cnn in order to make them learn more and better.
in particular following the practice of a2c both ann and cnn in recbi contain only one hidden layer in order to be light weightand converge fast.
the process is repeated until the terminating conditionisreached anditsoutputisasetofgeneratedeffective passing test programs.
in the following we introduce the actual rewardmeasurement section3.
.
andtheadvantagelossfunction section3.
.
in detail.
.
.
actualrewardmeasurement.
animportantaspecttothesuccessofthea2cbasedapproachishowtomeasuretheactualrewardafterapplyingamutationoperatortothegivenfailingtestprogram.
inspired by the existing work a set of effective passing test programs should satisfy both similarity and diversity criteria.
the ann action passing test program actual reward potential reward advantageloss function cnn state figure overview of our reinforcement learning based test program generation strategy former refers to that each passing test program should share a similarcompilerexecutiontracewiththegivenfailingtestprogram.
in this way according to the idea of sbfl the suspiciousness of morebuggy freefilescanbereduced.thelatterreferstothatdifferent passing test programs should have diverse compiler execution traces between each other in order to reduce the suspiciousness of different buggy free files.
in this way aggregating a set of passing mutated programs is helpful to effectively isolate the really buggyfilesby avoiding bias.
given a set of generated passing test programs denoted as p p1 p2 ... p n and the failing test programdenotedas f wedefinethesimilarityanddiversitymetrics achieved by the set of passing test programs on average as shown in formulae and respectively sim summationtext.1n i dist pi f n div summationtext.1n i summationtext.1n j i 1dist pi pj n n dist a b cova covb cova covb wheredist isthecoveragedistancebetweentwo testprograms and is measured by jaccard distance cov aandcov brepresent the set of statements in the compiler covered by test programs aandb respectively nis the number of generated passing test programs.
atatimestepdenotedas t aftergeneratingapassingtestprogram recbi measures the quality of the current set of passing test programs by linearly combining the achieved similarity and diversityasshowninformula4.then recbidetermineswhetherornot to accept the generated passing test program according to whether itcanimprovethe qualityofthepassingprogramsetcomparedwith thelasttimestepdenotedas t .formula5presentsthecalculation of the improved quality compared with the last time step.
qt n divt sim t qt qt qt n div sim divt sim t divt divt divt sim t sim t sim t where is the coefficient for the linear combination between diversityandsimilarity.formula4alsohasacoefficient n thesize ase september virtual event australia junjie chen haoyang ma and lingming zhang of the current passing test program set due to the following intuition whenthesizeofthepassingtestprogramsetissmall it ispreferableforrecbitoacceptanewpassingtestprogrameven though it may decrease the diversity and similarity because when nis smaller the actual delta is less important but with the size ofthepassingtestprogramsetincreasing wehavelessinterests to generate such low quality passing test programs with recbi.
therefore we incorporate nto reflect such intuition in recbi.
however at each state only one mutation operator is selected to generate a passing test program and a mutation operator could perform extremely differently due to various mutated locations which could lead to slow convergence for a2c.
moreover it means thattheimprovedqualityofthepassingprogramsetinthecurrenttimestepcannotpreciselyreflecttheeffectoftheselectedmutation operator.therefore toreducetheinfluenceofvariousperformance of a mutation operator recbi combines the improved quality at thecurrenttimestepandthehistoricallyimprovedqualityby the current mutation operator as the actual reward obtained at the current timestep instead of directly using the improved quality reward t summationtext.1t i 1 qi t mi where qi if the selected mutation operator is not miat the ithtime step otherwise qiis calculated by formula and t mi referstothenumberoftimesthat mihasbeenselectedtomutate the given failing test program.
.
.
advantage lossfunction.
after obtainingthe actualreward at the current time step recbi further uses cnn to obtain thepredicted potential reward.
to better take the future factors into account a2cdesignsanadvantagelossfunctioninordertoreduce thehighvarianceofthetwoneuralnetworksandavoidfallinginto the local optimal which is shown in formula a t t u summationdisplay.
i t i t reward i u 1prt u prt where urepresentsthatcnnconsidersthefuture uconsecutive states and actions when predicting the potential reward is the weight of the actual future reward prt uandprtare the predicted potentialrewardsatthe t u thandtthtimestepsbycnnrespectively.inparticular recbirepeatstheprocessinatimestepfor u timesand getthe approximation of the actual future reward.
based on the loss calculated by the advantage function in formula7 recbiupdatestheweightsofbothannandcnnaccording to formula .
logp at st a t where standatarethecurrentstateandaction p at st refersto the probabilitythat atis performedat stbased onthe parameters in ann and cnn is the learning rate.
.
compilerbuggyfile identification based on the set of generated passing test programs and the given failingtestprogram recbileveragestheideaofsbfltoidentifythe buggy compiler files via comparing the coverage of failing andpassingtests .morespecifically followingpriorworkon compilerbugisolation recbifirstadoptsstate of the artsbflformula i.e.
ochiai as shown in formula to calculate the suspiciousscore of each statement score s efs radicalbig efs nfs efs eps whereefsandnfsrepresentthenumberoffailingteststhatexecute and do not execute statement s andepsrepresents the number of passing tests that execute statement s. since in recbi there is only one givenfailing test program efsis .
moreover recbi only considersthestatementsexecutedbythegivenfailingtestprogram and thus nfsis .
therefore in recbi the ochiai formula can be simplified as score s eps after obtaining the suspicious score of each statement recbi furthercalculatesthesuspiciousscoreofeachcompilerfile.followingpriorwork recbiaggregatesthesuspiciousscoresofthe statementsexecutedbythegivenfailingtestprograminacompiler file as the suspicious score of the compiler file score f summationtext.1nf i 1score si nf wherenfisthenumberofstatementsexecutedbythefailingtest programinthecompilerfile f.accordingtothedescendingorderof thesuspiciousscoreofeachcompilerfile recbiproducesarankinglistofcompilerfiles wherethehigheracompilerfileisranked the higherpossibility the file has to be buggy.
evaluation in this study we aim to address the following research questions rq1 how does recbi perform on compiler bug isolation?
rq2 how does each main component contribute to recbi?
rq3 how does different recbi configurations impact the effectivenessof recbi?
.
compilersand bugs inthestudy weusedbothgccandllvmassubjectstoinvestigatethe effectiveness of recbi covering almost all popular open sourceccompilersusedintheexistingwork .regarding thesubjectbugs weusedthereleasedbenchmark including120 real compiler bugs gcc bugs and llvm bugs including all bugsfrompriorcompilerbugisolationwork .eachcompiler bugcontainsthefollowinginformation thebuggycompilerversion the failing test program the compilation options to reproduce the bug and the buggy files served as the ground truth in our study .
onaverage agccbuggyversionhas1 758fileswith1 447ksource linesofcode sloc whileallvmbuggyversionhas3 265files with 723ksloc.
.
implementationandparameters we implemented our proposed approach recbi based on clang libtooling library gcov and pytorch .
they are used toparseatestprogramtoanast abstractsyntaxtree collect compilercoverageinformation andprovidetheframeworkofa2c respectively.followingthedefaultsettingintheexistingwork wealsoset and ina2ctobe0.9and0.
respectively.in enhanced compiler bug isolation via memoized search ase september virtual event australia recbi the default settings of anduare .
and respectively.
note that we investigated the impacts of such main parameters on recbi in rq3.
following the existing work we set the terminatingconditiontobeonehourlimit.thatis wecomparedall thestudiedcompilerbugisolationapproachesunderthesametime limitforfaircomparison.toreducetheinfluenceofrandomness we repeatedly ran all the approaches for times and calculated themedianresults.ourstudyisconductedonaworkstationwith core cpu 120g memory and ubuntu .
operating system.
we have released our tool and experimental data at our project homepage .
independentvariables .
.
comparedapproaches.
wecomparedrecbiwiththestate ofthe art compiler bug isolation approach diwi to answer rq1.
diwi isolates compiler bugs via local mutation and the traditional mh metropolis hasting algorithm which depends on the mostrecentbehaviorofeachmutationoperatortodeterminethe nextmutation operator.
moreover intraditionalsbfl developerprovided tests are always used as the passing tests to reduce the suspicion of innocent program elements.
thus in rq1 we also investigated whether the generated passing programs via recbi outperformthedeveloper providedpassingtestprogramsforthe compiler under test.
we call the approach using the latter dev whichusesthesamestrategytorankallthecompilerfilesasrecbi presented in section .
but uses the developer provided passing programs instead of the generated passing programs via recbi.
inrq2 weinvestigatedthecontributionsoftwomaincomponents in recbi including newly designed structural mutation and the reinforcement learning based test program generation strategy.
therefore we designed the following variants of recbi.
recbimhreplacesthereinforcementlearningbasedtestprogramgenerationstrategywiththetraditionalmhalgorithm used in diwi.
that is recbi mhadoptsthe same strategyto guide the process of test program generation as diwi.
recbirandremoves the reinforcement learning based test program generation strategy from recbi.
that is recbi rand does not have any guidance to generate test programs by randomlyselectinga mutation operator in each time step.
recbifilterremoves the reinforcement learning based test program generation strategy from recbi but keeps the part ofmeasuringthequalityofageneratedpassingtestprogram sincethemeasurementmethodisthebaseofthereinforcement learning based test program generation strategy.
that is recbi filterrandomlyselectsamutationoperatorineach time step then measures the quality of a generated passing test program in the same way as recbi and finally filters the low quality passing test program qt .
actually recbifilteris an updated version of recbi randby adding a measuringcomponent.
we compared recbi mhand diwi to investigate the contribution of our designed structural mutation operators.
we then compared recbi recbi rand and recbi mhto investigate the contribution of our proposed reinforcement learning based test program gener ation strategy.
besides we compared recbi randand recbi filterto investigatethe effectivenessof our designedmeasurement for thequalityof a generated passing test program which is the base of our reinforcement learning based test program generation strategy.
.
.
differentrecbiconfigurations.
in rq3 we investigateddifferentconfigurationsofrecbi.here wediscussedtwomainparam etersinrecbi including usedtocombinesimilarityanddiversity asshowninformula4 and u thenumberoffuturetimestepsthat recbi takes into account in formula .
regarding we studied .
.
.
.
and1 respectively.here 0meansthat recbi only considers similarity while means that recbi only considers diversity.
regarding u we studied u a n d respectively.
.
measurements each compiler bug isolation approach produces a ranking list ofsuspicious compiler files and thus we measured the position of eachbuggyfileintherankinglisttomeasuretheeffectivenessof each approach.
regarding the tie issue i.e.
multiple compiler files have the same suspicious scores we adopted the worst ranking followingtheexistingwork .morespecifically wecalculated the following metrics which are widely used by the existing work in the area of bug localization .
top nmeasures the number of bugs that are isolated successfullywithin thetop n position i.e.
n in our study in the ranking list.
the larger the top n value is the more effective the approach is.
meanfirstranking mfr measuresthemeanoftherank ofthefirstbuggyfileintherankinglistforeachbug.mfr focuses on isolatingthe first buggy element fastin order to facilitate debugging.
the smallerthe mfr value is themore effective the approach is.
meanaverageranking mar measuresthemeanofthe averagerankofallbuggyfilesintherankinglistforeachbug.
mar focuses on isolating all buggy elements precisely.
the smallerthemarvalueis themoreeffectivetheapproachis.
.
resultsand analysis .
.
rq1 overalleffectivenessofrecbi.
weillustratedthecomparisonresultsamongvariousapproachesintable2.overall recbi is able to isolate compiler bugs out of compiler bugs within top top top and top files respectively.
thatis nearly23 and89 bugscanbeisolatedsuccessfully withintop top top and top 20files throughrecbi respectively.
we further analyzed the effectiveness of recbi on differentsubjectcompilers andsurprisinglyfoundthatalthough there are a larger number of compiler files in llvm compared withgcc recbiachievesbetterresultsonllvmthangcc.for example the mfr and mar values of recbi on llvm are .77and .
respectively while those of recbi on gcc are .
and9.
respectively.
moreover we found that the other approaches indeedperformworseonllvmthangcc.theresultsdemonstrate that theeffectivenessofrecbiisnotaffectedwhenfacinglarger compilersystems indicatingitsscalability.
we then compared recbi with the state of the art compiler bug isolation approach diwi.
from table recbi performs better than diwiintermsofallthemetricsandonbothofsubjectcompilers.
ase september virtual event australia junjie chen haoyang ma and lingming zhang table compiler bug isolation effectiveness comparison sub approach top top 1top top 5top top 10top top 20mfr mfr mar mar llvmrecbi .
.
diwi .
.
.
.
.
.
.
.
dev .
.
.
.
.
.
.
.
recbimh .
.
.
.
.
.
.
.
recbifilter .
.
.
.
.
.
.
.
recbirand .
.
.
.
.
.
.
.
gccrecbi .
.
diwi .
.
.
.
.
.
.
.
dev .
.
.
.
.
.
.
.
recbimh .
.
.
.
.
.
.
.
recbifilter .
.
.
.
.
.
.
.
recbirand .
.
.
.
.
.
.
.
allrecbi .
.
diwi .
.
.
.
.
.
.
.
dev .
.
.
.
.
.
.
.
recbimh .
.
.
.
.
.
.
.
recbifilter .
.
.
.
.
.
.
.
recbirand .
.
.
.
.
.
.
.
columns present the improvement rates of recbiover a compared approach in terms of various metrics.
the overall improvements of recbi over diwi in terms of top top top top are .
.
.
and .
respectively.inparticular asdemonstratedbytheexistingwork the top metric is more important in practice since most developerstendtoaborttheautomateddebuggingtoolsiftheycannot localizebuggyelementswithintop 5positions andthusrecbi is more practical than diwi by largely improving the effectiveness of compiler bug isolation in terms of top .
the mfr and mar values of recbi are .
and .
respectively while those of diwi are .
and .
respectively demonstrating .
and .
improvements of recbi over diwi respectively.
that demonstrates that recbi indeed significantly outperforms the state of the art approach diwifor compilerbug isolation.
we also compared recbi with the approach using the developerprovided passing test programs dev.
from table recbi signif icantly outperform dev in terms of all the metrics and on both gcc and llvm.
the overall improvements of recbi over dev are .
.
.
and .
in terms of top top top10 and top respectively.
also the overall improvements of recbioverdevare72.
and71.
intermsofmfrandmar respectively.theresultsdemonstratetheapparentsuperiorityof recbi compared with dev.
qualitative analysis.
we further performed qualitative analysis on recbi with two examples.
figure shows two programs where the left one is the given failing test program and the right one is a passingtestprogramgeneratedviaourdesignedstructuralmutation i.e.
inserting a whilestatement .
this bug is triggered when compilingthefailingtestprogramusinggccrevision228291at o2and above.
the root cause lies in the compiler file ifcvt.c which incorrectly uses bit registers for optimization instead of bitones.
by inserting a whilestatementwith a false predicate a passing test program is generated as shown in figure 5b since it invalidates the statement c b e that triggers the buggy optimizations.wefurthercalculatedthesimilaritybetweenthetwo1intprintf const char ... 2inta 3intb 4charc 5intmain 6chard 7inte 8for a a a e c b e d c e?c c e printf d n d return a failing program1intprintf const char ... 2inta 3intb 4charc 5intmain 6chard 7inte 8for a a a e while e a c b e d c e?c c e printf d n d return b passing program figure gcc bug 1inta 2voidfn1 3charb 4for b!
b for a a a if unsigned int b return 9intmain fn1 if a!
builtin abort return a failing program1inta 2voidfn1 3charb goto label 5for b!
b for a a a label if unsigned int b return 11intmain fn1 if a!
builtin abort return b passing program figure llvm bug test programs following formula which is .
.
that demonstrates the power of our structural mutation that guarantees the generatedpassingtestprogramtoshareasimilarexecutiontrace withthegivenfailingtestprogram.inparticular recbiranksthe buggyfile at the 2ndposition.
enhanced compiler bug isolation via memoized search ase september virtual event australia figure6showsanotherexample whichpresentsapassingtest program shown in figure 6b by inserting a gotostatement to the failingtestprogram showninfigure6a .thisbugistriggeredwhen compilingthefailingtestprogramat o1andaboveusingllvm revision .
the buggy file is scalarevolution.cpp which causesthatline6isdirectlyexecutedafterline4byskippingline due to incorrect optimization.
by inserting a gotostatement the programstructureavoidtriggeringthebuggyoptimization leading topassingexecution.thesimilaritybetweenthetwoprogramsis .
furtherconfirmingtheeffectivenessofrecbi.inparticular recbi ranks the buggy file at the 5thposition.
.
.
rq2 contributionsofmaincomponents.
toanswerrq2 we investigatedthecontributionsoftwomaincomponentsinrecbi i.e.
structuralmutationandreinforcementlearningbasedtestprogram generationstrategy.
contributionofstructuralmutationinrecbi .weinvestigated the contribution of structural mutation by comparing diwi and recbimhshown in table .
we found that recbi mhperforms better thandiwiintermsofallthemetricsonbothgccandllvm.more specifically recbi mhsuccessfully isolates and bugs within top top top and top files respectively while diwi only isolates and bugs respectively.
the overall improvementsofrecbi mhoverdiwiare28.
and27.
interms of mfr and mar respectively.
the experimental results demonstrate that incorporating structural mutation indeed improves the effectivenessofcompilerbugisolation confirmingthecontribution of structural mutation in recbi.
wefurtheranalyzedthecontributionofeachstructuralmutation operatortoisolatecompilerbugs.wefoundthatforeachstudied bug there exist the passing test programs generated by our designed structural mutation operators.
more specifically the fourstructural mutation operators i.e.
inserting branch statements loop statements function calls and gotostatements generated passing test programs for and bugs respectively.
that is all the four structural mutation operators are indeed useful to generate passing test programs during compiler bug isolation.
inparticular theoperatorinsertingloopstatementsmakethemost contributions while that inserting function calls make the least contributions among them.
this phenomenon is as expected since theoperatorinsertingfunctioncallstendtomorelargelychange the program structure than the other three operators leading to muchlesssimilaritybetweenthegeneratedpassingtestprogram and the given failing test program i.e.
a more low quality passing testprogram .then duetothequalitymeasurement formulae4 and5 inrecbi suchlow qualitypassingtestprogramsaremore likely to be filtered.
contributionofreinforcementlearningbasedtestprogram generation strategy .
we then investigated the contribution of our reinforcement learning based test program generation strategy bycomparingrecbi recbi rand andrecbi mhshownintable2.
we found that among the three approaches recbi performs the best while recbi randperforms the worst.
more specifically the improvements of recbi over recbi randin terms of top top top top mfr andmarare285.
.
.
.
.
and71.
respectively andthoseofrecbioverrecbi mh a gcc b llvm figure similarity between the given failing test programand generated passing test programs a gcc b llvm figure diversity among generated passing test programs are17.
.
.
.
.
and23.
respectively.
that is our reinforcement learning based strategy outperforms both the random strategy andthe mh based strategy used by the state of the art approach diwi demonstrating the contribution of ourreinforcement learning based test program generation.
we further analyzed the reason why our reinforcement learning based strategy outperforms the other two strategies by calculating the similarity formula and diversity formula for the generatedpassingtestprogramsviathethreestrategies respectively.
figure7presentstheaveragesimilaritybetweenthegeneratedpassing test programs and the given failing test program across all the bugsforthethreestrategiesrespectively whilefigure8presents theaveragediversityamongallthepassingtestprogramsacrossallthebugs.inthetwofigures theviolinplotsshowthedensityatdifferent values and the box plots show the median and interquartile ranges.fromfigures7and8 bothsimilarityvaluesanddiversity values for recbi are distributed more intensively than those for recbimhandrecbi rand indicatingthatthequalityofthegenerated passingtestprogramsthroughourreinforcementlearningbased strategyismorestable.ingeneral thesimilarityachievedbyrecbi is larger than that achieved by both recbi mhand recbi rand and recbi does not have the low quality passing test programs withlittle similarity.
moreover we found that the diversity achievedby recbi does not have superiority compared with recbi mhand recbirand.
this phenomenon is as expected since both similarity and diversity actually contradict each other to some degree.
theresults indicate that when staying high similarity enlarging the diversity would facilitate effective compiler bug isolation.
wethencomparedrecbi filterwithrecbi randtoinvestigatethe contribution of our designed measurement for the quality of a generatedpassingtestprogram whichisthebaseofourreinforcement learning based strategy.
from table we found that recbi filtersignificantly outperforms recbi rand although performing worse than recbi.
more specifically the mfr and mar values of recbi rand areonly29.76and30.08respectivelywhilethoseofrecbi filterare .
and .
respectively.
that is incorporating our designed ase september virtual event australia junjie chen haoyang ma and lingming zhang a impact of b impact of u figure the impact of different parameter settings qualitymeasurementintotherandomstrategyisabletolargelyimprove the effectiveness of the random strategy demonstrating the necessity of filtering low quality passing test programs in recbi.
.
.
rq3 impactofdifferentrecbiconfigurations.
weinvestigated the impact of two main parameters in recbi i.e.
andu.
figure9ashowstheeffectivenessofrecbiatdifferent valuesin terms of top and top metrics.
as demonstrated by the existing work top and top results are more important in practical andthusweusedthetwometricsastherepresentativestoevaluate the impact of different recbi configurations.
in figure 9a the xaxis represents the values while the y axis represents the metric valuesonbothgccandllvm.fromthisfigure wefoundthatour default setting i.e.
.
is better than the other settings in terms of bothtop 1andtop 5metrics especiallybetterthanthesettingsof 0and1 indicatingthatcombiningbothsimilarityanddiversityoutperforms individual similarity or diversity for generating effective passingtest programs.
figure9bshowstheeffectivenessofrecbiatdifferent uvaluesin terms of top and top metrics.
from this figure we found that the best setting ranges from to including our default setting i.e.
.thisisasexpectedsincewhenthevalueof uissmall there is little future knowledge considered in recbi leading to worse effectiveness while when the value of uis large the prediction for the future potential reward could become more inaccurate leading to worse effectiveness of recbi.
discussion .
threatsto validity theinternalthreattovaliditymainlyliesintheimplementationsof ourapproachrecbiandthecomparedapproachdiwi.toreduce this threat regarding the implementation of diwi we adopted the implementationreleased bythe existingwork .regarding the implementation of recbi we implemented it based on mature libraries as presented in section .
and carefully checked the code.
theexternalthreats to validity mainly lie in the used compilers and bugs.
regarding the used compilers following the existing workofcompilerbugisolation wealsousedtwomostpopular c open source compilers i.e.
gcc and llvm.
regarding the used bugs we used real compiler bugs including all bugs from prior compilerbugisolationwork .tofurtherreducethesethreats we will collect more real compiler bugs from more compilers to evaluate the effectiveness of recbi.
theconstruct threats to validity mainly lie in the settings of parameters randomness andtheusedmeasurements.regarding the settings of parameters we have presented our specific settings in section .
and investigated the influence of main parameters in section .
.
.
regarding the involved randomness in our study werepeatedly ran all the approaches for times and calculated the medianresults.regardingtheusedmeasurements wehaveused several widely used measurementsin thearea ofbug localization.
to further reduce this threat we will try to apply recbi to the industry and collect feedback from developers to evaluate recbi.
.
future work wediscussthefollowingextensionsofrecbiasourfuturework.
first recbi doesnotspeciallydeal withundefinedbehaviors i.e.
thesemanticsofcertainoperationsareundefinedintheprogramming languages standards .
similar to the existing work our mutation may also introduce undefined behaviors to a test program causing that the compiler may produce uncertain results for the test program with undefined behaviors.
however undefined behaviors tend to affect bug detection since different results of a failing test program may be caused by real bugs or undefined behaviors.
recbi only keeps the passing test programs with the same results to isolate compiler bugs and thus undefined behaviors may notaffect recbi.as demonstratedby theexisting work it ischallengingtoidentifyundefinedbehaviorsincompilerresearch inthefuturewewilltrytorelievethisproblembyadoptingexisting efficienttechniques .second wewillfurtherextendrecbito isolate compiler bugs at more fine grained levels e.g.
methods by calculatingthe suspiciousscores at the corresponding levels.
related work recbi is based on both mutation and reinforcement learning for compilerbugisolation andthusweintroducethreecategoriesof relatedwork includingcompilerdebugging mutation basedbug isolation and learning based bug isolation.
compilerdebugging.
besidesthemostrelatedworkdiwi describedbefore zeller proposedtoproduceanentirecauseeffect chain from input to result in gcc to facilitate debugging.
actually recbiiscomplementarytothecause effectchain the latter produces bug diagnosis information at the program state level while the former does this at the source code level the latter manipulatesin memory and may not handle external states the former is more lightweight.
besides incompilerdebuggingtherearemanyworkfocusingon providingdebuggingmessagesandvisualization .
someworkalsofocusedonsimplifyingthetestprogramstriggering compiler bugs in order to facilitate debugging .
inourwork thefailingtestprogramsarecollectedfromcompiler bug reports and all of them have already been the simplified ones as required by compiler developers .
some work focused on identifying the test programs triggering the same compiler bug for efficientdebugging .differentfromthem ourworkfocuses oncompilerbugisolation bygeneratingpassingtestprogramsvia reinforcement learning and mutation.
mutation basedbuglocalization.
mutation basedbuglocalization considers the actual impacts of code elements in the software systemsundertestontestoutcomestolocalizebugsthroughmutation testing .
more specifically it injects mutation bugs to each code element to simulate the actual impact of each codeelement.forexample papadakisetal.
proposedthe firstmutation basedbuglocalizationapproach named metallaxis.
enhanced compiler bug isolation via memoized search ase september virtual event australia its basic insight is that if mutating a code element can change theoutcomeofsomefailingtests thecodeelementmayhavepotentialimpactonthefailingtestsandthusmayhavebeenbuggy.
meanwhile zhang et al.
independently proposed fifl the first mutation based bug localization approach for evolving systems.
the basic insight is that regression bugs can be simulated and localized via mutating corresponding code elements on the oldprogram version.
more recently moon et al.
proposed another mutation based bug localization approach named muse based on the idea that mutating faulty code elements may cause more failed teststo pass than mutating correct elements.
different from these traditional mutation based bug localization approaches which aim to mutate the software systems under test our approach recbi aimstomutatethefailingtestcases i.e.
testprograms togenerate passingtest programs for compiler bug isolation.
learning basedbuglocalization.
inrecentyears alotoflearningbased bug localization approaches have been proposed .
for example xuan and monperrus proposed to utilize the learning to rank algorithm to localize bugs by combining different suspiciousscorescalculatedbysbfl.leetal.
furtherconsidered both the suspicious scores calculated by sbfl and program invarianttolocalize bugsthroughthelearning to rank algorithm.
recently li et al.
proposed to use deep learning techniques to localize bugs by considering the suspicious scores calculated by sbfland mutation basedbug localization aswell as staticfeaturesextractedfromthedefectpredictionarea andinformation retrievalarea .differentfromtheselearning basedbuglocalizationapproaches whichuselearningtechniquestorankallthe suspiciouscodeelements ourapproachrecbiutilizesthe reinforcement learning algorithm i.e.
a2c to guide the process of passing test program generation for compiler bug isolation.
conclusion inthispaper weproposeareinforcementcompilerbugisolation approach via structural mutation which is called recbi.
recbi first augments traditional local mutation operators with structural ones in order to generate a set of effective passing test programs for a given compiler bug with a failing test program.
in particular recbi incorporates reinforcement learning to intelligently guide the process of passing test program generation.
based on the set ofgeneratedpassingtestprogramsandthegivenfailingtestprogram recbiranksallthesuspiciousfilesbycomparingtheexecutiontrace between them.
we conducted an extensive study to evaluate recbi based on two most popular c open source compilers i.e.
gcc and llvm and real bugs from them.
the experimental results demonstratetheeffectivenessofrecbi significantlyoutperforming the state of the artcompilerbugisolationapproach.