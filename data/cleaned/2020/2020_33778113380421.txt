ankou guiding grey box fuzzing towards combinatorial difference valentin j.m.
man s csrc kaist daejeon korea valentinmanes outlook.frsoomin kim kaist daejeon korea soomink kaist.ac.krsang kil cha kaist daejeon korea sangkilc kaist.ac.kr abstract grey box fuzzing is an evolutionary process which maintains and evolvesapopulationoftestcaseswiththehelpofafitnessfunction.
fitnessfunctionsusedbycurrentgrey boxfuzzersarenotinforma tiveinthattheycannotdistinguishdifferentprogramexecutionsas longasthoseexecutionsachievethesamecoverage.theproblem is that current fitness functions only consider a union of data but not their combination.
as such fuzzers often get stuck in a localoptimumduringtheirsearch.inthispaper weintroduceankou the first grey box fuzzer thatrecognizes different combinations of executioninformation andpresentseveralscalabilitychallenges encountered while designing and implementing ankou.
our experimental results show that ankou is .
and .
more effective in finding bugs than afl and angora respectively.
ccs concepts software and its engineering software testing and debugging security and privacy software security engineering.
keywords fuzz testing guided fuzzing grey box fuzzing software testing principal component analysis acm reference format valentin j.m.
man s soomin kim and sang kil cha.
.
ankou guiding grey box fuzzing towards combinatorial difference.
in 42nd international conferenceonsoftwareengineering icse may23 seoul republicofkorea.
acm newyork ny usa 13pages.
.
introduction fuzzing has recently gained popularity thanks to its proven record and its ease of use .
it has identified thousands of real world vulnerabilities from a variety of software and it has been developed by numerous security practitioners as well as academic researchers.furthermore itdoesnotnecessitatemuchinformation from the analyst beyond the entry point setup and optionally an initial set of test cases so called seeds.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn ... .
provide initial starting points for fuzzing.
a seed correspondstoaprogramexecution andfuzzerscanexploreprogram paths mostly around this execution.
therefore seeds need to be dynamically added or removed from the initial seed pool during a fuzzing campaign in order to efficiently explore the program state space.grey boxfuzzers performsuchaprocessbyusinga fitness function which decides the quality of a given test case.
as the seed poolevolves fuzzerstendtogeneratemoretestcasesthatmeetthe fitness criteria enforced by the fitness function.
the current consensus is to leverage code coverage such as branchcoverage astheirfitnessfunction.forinstance ifatestcase coversanewbranchintheprogramundertest thenweadditto thepoolasitmeetsthefitnesscriterion.theactualimplementation variesforeachfuzzer buttheysharethesameidea theyprefertest cases that achieve new code coverage.
despiteitswideuse thecurrentstrategyofusingcodecoverage as a fitness function suffers from critical information loss.
sincecode coverage only considers a unionof information if any one ofthetestedexecutionsexercisesabranch forinstance thenthe branch is regarded as visited.
as such fuzzers can easily disregard testcasesthatdonotimprovecodecoverageeveniftheyallowour fuzzerstoexercisevaluableexecutionpaths.however bugsoften manifest when we exercise a specific execution path but not when we visit a specific code snippet.
for example buffer overflow bugs do not occur when we visit the buggy loop but they show up only when we exercise the loop more than a certain threshold.
unfortunately handing the aforementioned issue is challenging for the following three reasons c1 our fitness function should beinformative in that it can quantify difference between program executions c2 ourfitnessfunctionshouldbecomputationally fast whilestillbeinginformative and c3 ourfitnessfunctionshould not accept too many seeds in the seed pool to be able to handle them in a practical manner.
first our fitness function should be able to sensitively quantify program executions.
that is given two program executions weneed to be able to decide which one fits better for future fuzzing.
supposewewanttousepathcoverageasafitnessfunction.that is if a test case exercises an unseen path we consider it to meet thefitnesscriterion.inthiscase thefitnessfunctionitselfcannot judgetherelativeimportancebetweentestcasesbecausethefitnessfunctioncanonlymakeabinarydecision.thesameproblemexists for any coverage based fitness function.
second computing informative fitness itself can be too costly.
sinceprogramexecutionsnaturallyincorporatemillionsofinstruc tionsalongwithcomplexsemantics extractingtheircomprehensive information from an execution is typically an expensive process.furthermore the time complexity of a fitness function is critical ieee acm 42nd international conference on software engineering icse for grey box fuzzing as we will have to invoke the fitness function for every test case generated during a fuzzing campaign.
third merely employing an informative fitness function can quicklymake grey boxfuzzingunproductiveas ourfuzzerwould admit too many seeds in the seed pool.
for instance one may produceaseedforeverysinglepathifweusepathcoverageasa fitness function.
in this case it may not even be possible for the fuzzer to give a trial for every seed in the pool.
inthispaper wetackle alltheabovechallengesbyintroducing anovelfuzzingtechniquethatwerefertoas distance basedfuzzing.
itleveragesaninformativefitnessfunctionthatwecalldistancebased fitness function to deal with c1 .
it also employs a novel dimensionalityreductiontechniquethatwecalldynamicpcato handle c2 .lastly itmanagesitsseedpoolwithatechniquecalled adaptive seed pool update for c3 .
distance based fuzzing employs an informative fitness function that we refer to distance based fitness function to handle c1 .
it measures thebehavioral similarity betweentwo executionsby examining the combinations of exercised branches.
the key intuition is to expand our view from a set of program elements such as branches to a set of combinations of program elements.
by changing our perspective we can easily identify the uniqueness of anexecution in contrast to other executions even if the executiondoes not achieve novel code coverage.
note our fitness function onlyleveragesreadilyavailableinformationinmoststate of the art fuzzers namely branch coverage see .
.
althoughtheideaofdistance basedfitnessfunctionintegrates well with grey box fuzzing it is still challenging to adopt it in practiceascomputingthefitnessitselfiscomputationallyexpensive.
this is mainly because we need to deal with a higher number of statesas ourfitness functiongets moreinformative.
accordingto our study fuzzing with our distance based fitness function makesfuzzers .
slower.
totacklethischallenge c2 wepresentdynamicpca which is inspired by a well known statistical approach called principal componentanalysis pca .pcareducesthedimensionality of a data set while guaranteeing to preserve the maximum amount ofinformationfromtheoriginalset.however pcaitselfiscomputationally too expensive to be used with fuzzing.
we cannot run pcaforeveryfuzzingiterationforthesamereasonthedistancebased fitness cannot be directly used for fuzzing.
to the best of our knowledge none of the existing pca variations suits our needs.
therefore wepresentanovelandpracticaldimensionalityreduction technique that we call dynamic pca.
the core idea is to make the pca computation to be incremental so that we do not need to recompute pca from scratch.
our empirical study demonstrates that dynamic pca can efficiently reduce the computational cost of the distance based fitness function while introducing only of information loss on average.
finally we introduce adaptive seed pool update to effectively managethesizeoftheseedpool c3 .thecruxofourapproachisto dynamicallyadjustthesensitivityofourpoolupdatefunctionbased ontherelativedifferencebetweenprogramexecutions.sinceour distance basedfitnessfunctioncanquantifydifferencesbetween program executions by its design we can compare test cases basedon their fitness to actively decide the sensitivity of the pool update function.inourstudy ankouwithoutadaptiveseedpoolupdatewas not functioning due to the excessive memory requirement and fitness computation cost.
todemonstrateourideas wedesignedandimplementedankou our prototype fuzzer which leverages distance based fitness function dynamic pca as wellas adaptiveseed poolupdate totackle allthethreechallenges.weperformedathoroughevaluationfor ankouon24real worldapplicationpackagesbyspendingatotal of cpu days.
the results are promising ankou is .
and .
better in finding unique crashes compared to afl and angora respectively.moreover ankoufoundalarge variety of previously unknown software bugs in real world software.
in summary our contributions are as follows.
we present an informative fitness function for grey box fuzzing that we call distance based fitness function.
we introduce dynamic pca which is a novel approach to dynamicallyreducethedimensionalityofthedistance based fitness computation.
we design and implement ankou the first fuzzer prototype for distance based fuzzing.
we create our own benchmark which consists of realworld application packages and we make it public.
we make our source code along with our benchmark publicongithubtosupportopenscience softsec kaist ankou.
background thissectionpresentsfundamentalconceptsrequiredtounderstand theproposedidea anddefinesseveralnecessaryterminologiesthat we use throughout the paper.
.
fitness and local optimum problem currentgrey boxfuzzersprimarilyusecodecoverageastheirfitness function we add a test case to the seed pool if it achieves new code coverage.
however coverage guided fuzzing strategies can missoutcriticaltestcasesthatmayguidefuzzerstowardsunseen executionpathswhilenotnecessarilyimprovingthecodecoverage per se.
we say we have reached a local optimum as we cannot obtain any more test cases that fulfill our fitness criterion even though we have not yet tested all possible executions of the put.
this is certainly the case for fuzzing because some bugs can onlybetriggeredwhenaspecificexecutionpathisexercised.for example traditional buffer overflow bugs trigger when we exercise a loop more than a certain threshold but not when we simply visited the loop both the node and the branch coverage would remain the same.
tomitigatethisproblem afl anditsdescendants employ a modified version of branch coverage which takes account of a hit count for each unique branch in the put.note that the modified coverage can represent a greater numberof program states compared to branch coverage two executionsmay hit branches for different number of times while achieving thesamebranchcoverage.wecallsuchinformationgatheredfrom every program execution by afl as branch hit count state1.
1notethataflintroducesanotherapproximationintheiractualimplementation it bucketizes hit counts by powers of two to roughly measure how often each branch is branchhit count for branch 1branchhit count for branch figure1 ahypotheticalexampleshowingbranch hit count statesof30uniqueprogramexecutions.eachdotrepresentsa branch hit count state vecx.
definition .
branch hit count state .
given a program pand an inputt the branch hit count state p t is a vector p t x ... xn vecx wherenis the number of branches in p andxiis the number of hits for branch iin the execution.
for simplicity we let the branchhit count state with a vector notation vecx.
we note however that the fitness functions using branch hitcount states still suffer from the local optimum problem.
for example letusconsiderasimpleprogram pthathasonlythreebranches and assume that three test cases t1 t2 andt3respectively produce the branch hit count states p t1 p t2 and p t3 .
suppose t1is firstly given and t2andt3are producedwhilefuzzingtheprogram.inthiscase currentfuzzers includingaflwillfavor t1asitcansolelycoverallthebranches and thus t2andt3will be considered redundant and will not be included in the population.
indeed this is the key observation that motivates our research.
.
principal component analysis principal component analysis pca is a way of reducing the dimensionality of a dataset while preserving as much information aspossible.tounderstandthebasicprocessofpca letusconsider ahypotheticalexamplewherethereisaprogram pwithonlytwo branches.
each execution of the program will produce a branchhit count state vecx x1 x2 which contains two hit count numbers for each branch.
suppose our fuzzer has produced test cases which exercise30 unique programexecutions.
figure 1illustrates thisexample.eachdotrepresentsabranch hit countstateobtained byanexecution andthex andy axisrepresentthehitcountfor branch and respectively.
thegoalofpca inthisexample istoobtainan1 dplotfrom the2 dplotinsuchawaythatallthepointsintheresultingplot have the largest variance.
for example the dashed line in figure showssuchanaxis.ifweprojectallthepointsontothenewaxis i.e.
thedashedline thenweobtainthemaximumpossiblevariance between dots in the resulting d plot.
exercised.
we intentionally omit such details for brevity but we note that it does not impact our analyses.in this paper we let pca be a function that takes in a space representation asinput andreturns anupdated spacerepresentationas output.a spacerepresentation isa tupleof abasis banda covariance matrix .
that is pca is a function of type pca b b prime prime .
the returned space representation has a reduced dimensionality andeachaxis i.e.
eachcolumnvectorof b prime islinearlyindependent to the other ones.
inthecontextofpca thetupleofabasismatrixandacovariancematrixeffectivelydescribesallthenecessaryinformation.a covariance matrix is a symmetric matrix representing how each datacomponentareaffectedbyeachother.sincetheexampleplotis ona2 deuclideanspace wecanrepresentitsbasisasa2standard basis matrix.
b bracketleftbigg1001 bracketrightbigg .
to represent the relationship between the two components of figure1 weconsidera2 2covariancematrix ofthespace.each element in the i j position is the covariance between the i th and j th components.
bracketleftbigg6.
.
.
.
bracketrightbigg .
the element in represents the covariance between the first componentanditself whichmeansthevarianceofthefirstcompo nent.theelementsin and arethesameasthecovariance between two components is the same regardless of their order.
in the perspective of linear algebra pca is equivalent to an eigendecomposition process on the given covariance matrix whichreturnsadiagonalmatrix primeandabasismatrix b prime.thebasis b primecontainseigenvectorsasitscolumnvectors whichrepresents the axes of a new coordinate system.
primehas the eigenvalues on its diagonalentries whicharethevariancesofthecorrespondingnewaxes.specificallywhenappliedto above weobtainthefollowing covariance matrix and basis matrix.
prime bracketleftbigg8.
.
bracketrightbigg andb prime bracketleftbigg0.
.
.
.
bracketrightbigg .
inordertomaximizethevarianceofthelowerdimensionality space we chose the axes with the highest variances.
in this case sinceit hasa varianceof .
we select thevector whichcorrespondstothedashedlineoffigure1.thisbecomesour new axis of the desired d plot.
distance based fuzzing fitness the key challenge that we address here c1 is designing an informative fitness function for grey box fuzzing which can sensitively quantify the difference between test cases and their corresponding executions on the put.
remarkably we found that the branch hitcountstatesusedbycurrentfuzzersalreadyprovidejustenough informationabouttestcases forjudgingtheir potential tobeused asafutureseed.theideaistoconsidereachbranch hit countstateas avector as defined in .
which enables us to compute relative distances between them.
since we are dealing with relative distances two distinct executions that achieve the same coverage but produce different branch hit count states would represent two unique vectors in the 1026space andwecan naturallyquantifytheirdifferencecomparedto the other vectors in the space.
indeed this is the key intuition of our distance based fitness function.
.
fitness as distance between vectors inourmodel abranch hit countstatecorrespondstoavectorin a space that we call the branch hit count state space p which is formally defined as follows.
for any test case t we can obtain a branch hit count state p t in pby executing pwitht.
definition3.
branch hit countstatespace .
givenaprogram p thebranch hit count state space ofp p is the set of all possible branch hit count states we can obtain by executing p. withthis wenowintroducetheconceptof executiondistance whichmeasurestherelativedistancebetweentwobranch hit count states therebydeterminingthedifferencebetweentheirtwoexecutions.
note that the distance between two vectors is dependent on whichspacewearein.thus ourdefinitionofexecutiondistance takes a basis binto account.
definition .
execution distance .
given a program pand a basisb anypairofbranch hit countstatesin phaveanexecution distance bonthespacedefinedby b whichissimplydefinedas the euclidean distance vecx vecy 2 p b vecx vecy bardbl vecxtb vecytb bardbl.
intuitively two executions are similar to each other when their executiondistanceissmall andviceversa.forexample suppose there is a program with only three branches and there are three executions of the program which result in the branch hit count states vecx vecy and vecz respectively.inthis case wecanreadilydeterminethat vecxand vecyaresimilartoeachother asthefirstbranchisexercisedthreetimesinbothcases unlike vecz.althoughbranchhitcountsdonotcompletelyreflectthesemanticsofthe program executions we can still extract meaningful distinction between executions.
since a test case produces an execution for a given put we can comparetwotestcasesfortheputbyleveragingtheirexecution distances.
that is the execution distance allows us to computethe difference between given test cases with respect to the put.
therefore we devise a new fitness function to quantify the novelty of a given test case compared to the current population i.e.
test cases in the seed pool.
let t1 t2 tm beaseedpoolof m testcases the distance basedfitness ofa newlygenerated tisthen theminimumexecutiondistancebetween tandalltheseedsin .
as execution distance can vary depending on the current space we arein thedefinitionofdistance basedfitnessfunctionalsotakes the current space b into account.
definition .
distance based fitness function .
given a programpandabasis b thedistance basedfitness b t ofatest casetwithregard toaseedpool istheminimum executiondistance between p t and a set i p i on the space defined byb.
formally the distance based fitness function is b t min i b p t p i .
withthedistance basedfitnessfunction wecannowquantify the difference between a test case and a pool of test cases.
forexample let us consider the test cases with the following states p t1 p t2 p t3 and p t4 .
assume the current seed pool contains the first two seeds t1 t2 and our fuzzer has generated the test case t3andt4.w e can now compare the two test cases decide which is the fittest and include it in the pool.
using the standard basis as b we obtain b t3 t1 t2 and b t4 t1 t2 .
.
since t4execution is further away from the seed pool its inclusion in the pool brings more novelty than t3would.
hence t4is a better fit.
although neither test cases bring new coverage this is representative of howthecombinationoftheirbranch hit countdiffers.
t3executiononly differs from t1on the second branch while t4differs from t1on all the branches.
.
impracticality of distance based fitness ourdistance basedfitnessfunctionisindeedinformative itprovides a way to effectively quantify the fitness of generated test cases but such benefit comes with a price.
although it does notrequire any new coverage metric to be introduced it is not fea sible to apply the idea directly to current fuzzers due to its high computational cost.
since we have to compute the fitness for every generated test case the performance of fitness computation is critical.
unfortunately itstimecomplexityisroughly o mn wheremisthenumber ofseedsinourseedpool and nisthenumberofbranchesinthe put.notethattherecanbeeasilythousandsofseedsinthepopula tionaswellasthousandsofbranchesintheput.thisisindeedthechallenge c2 thatweaddressinthepaper.tomakeourapproach practical we need to reduce one of the terms.
oneplausiblewaytoimprovetheperformanceistoemploya specialized data structure designed for efficient distance queries such as m tree .
it allows us to reduce the number of seeds tolookforwithoutanylossofinformation.however itdoesnot guaranteeanypracticallowerbound.inapreliminarystudyweperformed we only observed about of performance improvement withm tree whichwasfarfromenoughtomakethedistance based fitness function practical for fuzzing.
therefore we address this impracticality challenge by reducing thedimensionalityofthebranch hit countstates whicheffectively reducesn the number of branches to consider.
recall that pca asintroducedin .
isawell knownmethodologyforreducing the dimensionality of a dataset while minimizing the loss of in formation.
the goal here is to reduce the dimensionality of thebranch hit count state space which can drastically improve the performanceofourfitnessfunctioncomputation.nevertheless thisnewintermediarystepintroducesitsownchallengesaswedescribe in the following section.
dynamic pca the high computational demand of distance based fitness function naturally leads us to the second challenge c2 .
to tackle the challenge we introduce dynamic pca a noveltechnique for reducing the dimensionality of the branch hit count states.
as the name implies dynamic pca is inspired by pca but pca itselfdoesnotperfectlymeetourneedsforseveralreasons.first 1027pcaitselfiscomputationallyexpensive ithasacubic timecomplexity in the number of samples and dimensions .
second the underlying probability distribution we are sampling from changes everytimeastheseedpoolvaries grey boxfuzzingcreatesadynamicenvironment.thismeanswewouldneedtocomputepca every time we add a new seed to our pool but its cost would becomeextremelyhigh.aswewillexplainin severalvariationsof pca havebeen introduced none ofthem suitsour case.dynamic pca overcomes these challenges by presenting an efficient approximation ofpca which eventually enablesthe practical use ofthe distance based fitness for grey box fuzzing.
.
algorithm overview atahighlevel dynamicpca achievesitsperformanceimprovement by reducingthenumberoftimeseigendecompositionisrun and limitingthenumberofaxesinthespacetoperformeigendecompositionon.dynamicpcaperiodicallyrunseigendecomposition i.e.
the standard pca for every time interval we choose which is oneminute inthe currentimplementation.
itmaintains areduced covariance matrix and incrementally updates the matrix.
when we performeigendecomposition werunitonlyonthereducedmatrix.
thedynpcafunctioninalgorithm1describesthemainalgorithm which roughly takes in a space representation b and returnsanupdatedone.theinitialspacerepresentationisobtained by runningthe standard pcafor the seedsin the initialseed pool given by the user.
unlike the standard pca we described in .
though it also takes in three more parameters as input vecxis the branch hit count state obtained by executing the currently generatedtestcase whichisrequiredtoupdatethespaceinformation sisthenumberofgeneratedtestcases and expisavariableautomatically set by our algorithm whose initial value is the infinity .
dynamic pca operates with three major functions expandbasisifinteresting updatecovmatrix and periodicdecompose.
expandbasisifinteresting checks whether the branchhit countstate vecxsuffersalarge informationlosswhenprojected on b. if it does then we consider vecxas an interesting vector and add it to our basis bas an extra axis see .
.
updatecovmatrix updates the current covariance matrix withregardtothegivenbranch hit countstate vecx see .
.
note that effectively summarizes the branch hit count states of all the test cases the fuzzer observed so far.
periodicdecompose periodicallyreadjuststhebasis bevery minute by running the standard pca.
the current time intervalisempiricallychosen butitisauserconfigurableparameter in our implementation.
note that this function needs to handle only a reduced space returned by the previous steps.
that is the number of axes in bis several orders ofmagnitudesmallerthanthetotalnumberofbranchesin the put.
this is indeed the key to our approach.
information lossdue to dynamic pca.
although dynamic pca makes itefficient to computethe principalcomponents of agiven space representation it loses the guarantee of maximizing the variance of the reduced space.
nonetheless our empirical result shows that the information loss caused by dynamic pca is or less in most subjects we tested see .
.
therefore dynamic pca can be a practical alternative to standard pca.algorithm dynamic pca expis globally given and initially set to .
1function expandbasisifinteresting b vecx loss radicalbig bardbl vecx bardbl2 bardbl vecxtb bardbl2 by pythagoras ifloss expthen b append b vecx b gramschmidt b 6 exp updateloss exp loss returnb 8function periodicdecompose b ifisoneminutepassed then b pca b returnb the main function 12function dynpca b vecx s 13b expandbasisifinteresting b vecx 14 updatecovmatrix b vecx s 15b prime prime periodicdecompose b returnb prime prime .
incremental basis expansion in expandbasisifinteresting the information loss caused byprojecting the execution on bis quantified by lossin line .
in line theloss is consideredsignificant if above thethreshold exp.
then inline4 thenewbranch hit countstate whichisavector by definition is appended to the basis and the covariance matrix isexpanded byonerow andonecolumn.the newbasis bisthen orthonormalized by gram schmidt in line .
to get a better understanding let us consider the previous exampleillustratedinfigure1.thereareonlytwobranchesinthe programandwehave30initialseeds oneforeachpointintheplot.
the initial band are set using the standard pca on the initial seeds.notethat thisisanexpensiveoperationasthebranch hitcountstateislikelytohavemanydimensions.wecanonlyaffordit once at the initialization.
now let us assume that the first test case wegeneratemanifeststhebranch hit countstate vecx .w e pass the state to dynpca and we reach the expandbasisifinterestingfunction.thebranch hit countstateisindeedalargeoutlier whichwillpassthetestinline3of expandbasisifinteresting.
therefore this vector will be appended to b and then orthonormalized into bracketleftbig .
.
bracketrightbig by the gram schmidt procedure.
thefollowingtestcasesandtheirbranch hit countstateswillbe projected onto the new d basis until the call to the pca function in periodicdecompose will reconsolidate binto a single vector.
additionally expandbasisifinterestingupdatestheexpansion threshold expinline6.updatelossrecordsallthe lossvaluesin the past minute and sets expto the maximum of the held data.
in our experiments this was enough to make dynamic pca maintain a sufficient number of new axes while keeping the computational costlow.optimizingupdatelossisbeyondthescopeofthispaper.
.
dynamically updating covariance matrix as we generate test cases we should also incrementally update our covariance matrix to take account of newly sampled test cases 1028added to our space.
however there is an issue to be addressed for updatingourcovariancematrix.pcaassumesthatoursampling processisperformedonaconstantprobabilitydistribution butthis isnotthecaseforgrey boxfuzzerswhereachangeintheseedpool implies a change in the sampling process.
toaddressthisproblem weimplementupdatecovmatrixto include a discount factor in order to favor newer test cases rather thanolderones.particularly everytimeweupdate wegivehigher weights to newer test cases by progressively decreasing weights to the previous covariance matrix.
formally given the s th generated test case which produces vecx the updatecovmatrix operates by updating primeas follows.
prime vecxtb vecxtb t ws ws wherews 2 s .
if issetto0 thenwecompletelyignorethehistory andweendup solely using the latest test case to construct prime.
on the other hand when the term wsbecomes s and the resulting formula simplyrepresentsanincrementalmeanwhere sisthetotalnumber ofelements.when isbetweenzeroandone weeffectivelygive a weight of wsto the old covariance matrix in order to give the decreasing influence to it as time passes.
the lower is the more we forget about the past.
note that the old covariance matrix represents stotaltestcasesgeneratedsofarwherethefirsttestcase hasaweight s .weempiricallyset to1 6inourcurrent implementation.althoughnotexplicitlymentionedforbrevity the branch hit count state vecxis centered before being projected on b. distance based fuzzing inthissection wefirstshowawaytodynamicallyadjustthesensi tivityofourfitnessfunctiontohandle c3 .theprimaryissuehere isthataninformativefitnessfunctionsuchasourdistance based fitness function would accept too many seeds in the pool.
to set thesensitivityofthefitnessfunction weintroduceadaptiveseed pool update a novel population update mechanism that dynamically changes its fitness criterion.
with this we present the design andimplementationofankou ourfuzzerprototypethatenables distance basedfuzzingbyaddressingallthreechallenges c1 c2 andc3 .
ankou leverages the distance based fitnessfunction see to obtain informative feedback and employs the dynamic pca see toefficientlycomputethedistance basedfitnessfunction.
italsousesadaptiveseedpoolupdatetodynamicallychangesits fitness criterion.
.
adaptive seed pool update the distance based fitnessof atest casecharacterizes itsnovelty compared to the current population but having a way to measure novelty or fitness does not tell us when should we add our testcase to the seed pool.
of course we can add our test case to the pool when its distance based fitness is above a threshold but what should be the value of the threshold then?
note that the choiceof this threshold is critical as it sets the sensitivity of a fuzzer tonewbehaviorsoftheput.ifitisinfinitelyhigh theseedpoolis constant and the population does not evolve.
on the other hand if the threshold is set to zero any test case will be added to the pool which can quickly pack the seed pool.algorithm adaptive seed pool update.
the space information b is globally given.
fitis globally given and initially set to zero.
1function poolupdate t s 2b dynpca b p t s if b t fitthen prime addtopool t fit mini prime b i prime i return prime else return thus wepropose adaptiveseedpoolupdate anoveltechnique that dynamically selects the threshold to adaptively control the sensitivity of our fuzzer.
the poolupdate function in algorithm describes the overall algorithm which takes in a newly generated testcaset thetotalnumberoftestcasesgeneratedsofar s andthe seedpool asinput.itthenoutputsanupdatedseedpool prime.in line2 weperformdynamicpcainordertomakeourfitnessfunction computation befficient.
we then check if the distance based fitness is bigger than the fitness threshold fit which is initially givenaszero.ifso weupdateboththeseedpoolandthethreshold inline4and5.theaddtopoolfunctioninline4firstpopsout theseedwiththelowestdistancetothepopulation andthenadd our test case tto the pool.
that is we remove the least fit test case from the pool while adding a new one.
to maintain a sufficientamount of seeds addtopool will only remove a test case when the pool has or more seeds in our current implementation.
inline5 wecomputethedistance basedfitnessforalltheseeds inthepool andsetthecurrentminimumfitnessasanewthreshold.
the intuition here is that in order for a test case to be useful it shouldbeatleastfurtherawayfromthepoolthanthesmallestgap between the seeds.
more formally we set the next threshold fitby fit min i b i i min i1 i2 2 i1 nequali2 b p i1 p i2 .
practicalimpactofadaptiveseedpoolupdate.
tounderstandthe impactofadaptiveseedpoolupdate weperformedapreliminary studywhereweranankouwithoutadaptiveseedpoolupdateona subject in our benchmark.
as a result ankou was killed by the os duetoitsexcessivememoryuseafterafewminutes.duringitsrun ankouwasmostlyspendingitstimecomputing binline3.since therearetoomany seedsinthepool itscomputationalcost even with dimensionality reduction became too extreme to be able to run inpractice.
thus we concludethat adaptiveseed poolupdateis an essential piece of distance based fuzzing.
.
ankou architecture ankou follows the general architecture of grey box fuzzing which consists of three major components seed scheduler pool manager and tester.
figure illustrates the overall design of ankou.
the seed scheduler selects a seed for fuzzing and passes it to the tester module.
the tester then generates inputs by mutating the given seedandrun theput.upontheputexecution thetesterpasses the execution trace to the fitness function of the pool manager which computes its fitness value.
the poolupdate function in the figure ankou architecture.
pool manager module then updates this value with the adaptive seed pool update technique.
note that the only difference between existing grey box fuzzers andankouisinthedesignofthepoolmanagermodule.particularly ankou uses the adaptive seed pool update for pool update and the distance based fitness function enabled by the dynamic pca.
any grey box fuzzers can easily benefit from distance based fuzzing.
.
implementation ankouisbuiltuponourownaflimplementationingo .itis asimplifiedversionofafl whichimplementsmostoftheafl s features but not all.
for instance our implementation does not include culling since ankou performs it on the fly in line of algorithm .
ankou does not implement the seed prioritization heuristicsemployedbyafl whereseedshavingfastthroughput and high coverage are likely to get a higher priority.
since our goal in this paper is on designing a new fitness function for grey box fuzzing we intentionally omitted such heuristics in our implementation to effectively measure the impact of our fitness function.instead ankou chooses seeds from the seed pool at random and generates test cases for a constant time interval which is currently one second in the current implementation.
our current implementation of ankou consists of 8k lines of go as measured by cloc .
we used the gonum numeric library in order to implement the pca function.
ankou employs the same instrumentation module provided by the vanilla afl .
therefore ankou can easily support asan and afllafintel .wemakeourprototypeimplementationaswellasour benchmark publicly available on github .
evaluation we evaluated ankou on the following research questions.
howmuchwasthe speedgainenabledb ydynamicpcaand what was its impact on bug discovery?
candynamicpcaeffectivelyreducespacedimensionality without significant information loss?
how does the distance based fitness function compare to coverage based fitness function?
howmuchisthecomputationalcostofdistance basedfuzzing?
how does ankou compare to other grey box fuzzers?
.
experimental setup basicsetup.
weperformedourexperimentsontwoservermachines each of which is equipped with intel xeon e5 v4 coresand512gbofram.foreveryfuzzingcampaign weuseda dockercontainerassignedtoasinglecore.unlessstatedotherwise all the reported numbers are the average of six repeated fuzzing campaigns eachofwhichwasperformedfor24hours.weusedthe mann whitneyu test with .05todeterminethesignificance ofeach experiment.when we reportthe numberof unique crashes wefollowafl sdefinition iftwocrashesachievethesame branch coverage we count them as one.
measuring throughput.
in rq1 rq3 and rq4 the test case generation throughput the number of test cases the fuzzer produced persecond isusedasaproxytomeasurethecostoftheanalysis eachfuzzerperforms.whenafuzzerperformsatimeconsuming operation in the case of ankou the dynamic pca it is at the expense of the test case that could have been generated and run in the same amount of time.
thus the lower the throughput is the higher the cost of the analysis the fuzzer is performing.
fuzzers to compare.
since ankou is a source based fuzzer it cannotbefairlycomparedtobinary basedfuzzerssuchaseclipser or redqueen .
recentsource based fuzzerssuch as steelix and collafl were not made available for comparison.
libfuzzer requiresacustomlibrarycallertobemadetorunexperiments.hence wecompareankouagainstafl2.52b thelatest version at the time of writing and angora .
when we run afl we used the d option which essentially enables aflfast .
ourbenchmark.
tocreateourbenchmark wecollectedallthe programs but with the latest versions used by collafl .
this benchmarkincludesatotalof24differentprogrampackages constitutingmorethan5mloc seetable1 .whenaprogrampackagecontainsmorethanoneexecutable weconsiderallofthemasaseparatesubject.forexample libtasn1 isalibrary whichhasthree distinct wrapper program executables in its source distribution.
in this case we regard each executable as a distinct subject2.a sar e sult weobtained150differentsubjectsfromthe24packages.since the authors of collafl have not opened their benchmark to the public weobtainedinitialseedsbygatheringtestcasesprovided byeachpackage andwedidnotperformanyadditionalprocessing.
we make our benchmark public along with the source code.
hoursofexperiments.
weranankouandafloneachsubject of our benchmark suite for hours and repeated this experiment for6times.wedidthesameforangora butonlyonthesubjectsit wassuccessfully compiledfor see .
.to answerrq1and rq3 weselected24subjectsfromthebenchmarkbyrandomlychoosing one executable per package.
we then ran hour fuzzing for each of the subjects of the selected subset times.
in total all our experiments constitute cpu days.
.
rq1 impact of dimensionality reduction doesdynamicpca reallyhelpimprovetheefficiency ofdistancebasedfitnessfunction?to answerthisquestion werunankouin two modes mode ankou with the distance computed using the 2the term subject is widely used in practice by libfuzzer .
subjectscrash ratio in log throughput ratio in log crashes throughput figure comparison between distance based fitness functionwithandwithoutdynamicpcaintermsofthenumberof crashes found and test case generation throughput.
dynamicpca and mode2 ankouwithdistance basedfitnessfunction but without dynamic pca.
meaning the distance is computed using definition .
without any dimensionality reduction.
figure illustrates our experimental results after hours of fuzzing on each of the selected subjects.
the line with circles shows the ratio between the number of crashes found with mode and .
the line with squares shows the ratio between the test generation throughput of ankou with mode and .
the first five crash points circles have the ratio of one as we found no crash in bothcases.thelastsixpoints witharatioof1 arethecases where ankou in mode found crashes while mode did not.
in allcases thecrashratiowashigherthanone meaningthatusing dynamic pca always produces better results than using defintion .
.
ankou found .
more unique crashes and generated .
more test cases with dynamic pca than without it.
the 3uvalue andthe 4uvalue columnsoftable1 describe the result of the mann whitney u test on the experiment.
a value written in bold and with a grey background means the experiment was successful.
if the value is close to .
it means the hypothesisisvalidated e.g.
.ontheotherhand ifthevalue isclose0.
itmeanstheoppositeisvalidated e.g.
.forthose subjects that show statistical significance dynamic pca gave considerablybetterresultsintermsofbothbugfindingandthroughput.
these results confirm the necessity of our dynamic pca to enable the practical usage of the distance based fitness function.
.
rq2 effectiveness of dynamic pca although dynamic pca allows us to efficiently generate test cases itcomesataprice.sincedynamicpcaisanapproximationprocess it may suffer from a loss of information.
if so how much would be the loss?
in other words do the identified basis from dynamic pca successfully maximize the variances of branch hit count states?
to answer the question we measured the effectiveness of dynamicpcaonallthefuzzingcampaignsagainstthe150subjects in our benchmark.
the effectiveness is quantified by the variances i.e.
eigenvalues appeared in the resulting covariance matrix prime.
bycomputingtheportionofthevariancesoftheselectedaxesin prime wecanquantifyhowmuchinformationislostbyrunningthe dynamicpca orstandardpca process.forinstance ifwelook back at the example in .
the effectiveness of pca was about .
.
.
.
the closer this number is to the less loss of information in the pca computation will be.
figure is the histogram showing the effectiveness of dynamic pcaforallthe150subjects.for80 ofthesubjects theeffectiveness0510152025 effectivess of dynamic pca frequency figure the effectiveness of dynamic pca represented by the percentage of preserved information on subjects.
the green dashed line represents the median effectiveness.
.
.
.
.
.
.
subjectscrash ratio in log throughput ratio in log crashes throughput figure comparison between distance based fitness and coverage based fitness function in terms of the number ofcrashes found and test case generation throughput.
was above .
and for of the subjects the effectiveness was above72.
.inotherwords dynamicpcawasabletokeep80 of the information obtained from program executions in most of thesubjects.thisresultindeedhighlightsthekeycontributionof our paper dynamic pca can effectively reduce the dimensionality of program state space without losing much information which enables the practicality of distance based fuzzing.
.
rq3 distance vs. coverage based fitness recall from one of the key motivations of distance based fit ness function was that coverage based fitness functions do not providesufficientinformationtofuzzersforfindingbugs.toconfirm the value of distance based fitness function we ran ankou with and without distance based fitness function.
when disabling thedistance basedfitnessfunctionforankou weonlyusedbranch coverage as its fitness criterion.
figure shows our results after hours of fuzzing on the same subjects as in rq1.
overall distance based fitness functionfound1.
moreuniquecrashes andproducedmorecrashes in60 ofthesubjects excludingthe5subjectswherenocrashes werefound.atbest thedistance basedfitnessfunctionfound4 more unique crashes than without it.
as the right most columnsof table describe for those subjects that manifest statistic sig nificance distance based fitness function gave better results for ofthecases 5outof6 .however fortheothersubjectsthat were not found to be statistically significant the distance based fitnessfunctionwasusuallystillanimprovementoverthetraditional coverage based fitnessfunction in termsof thenumber of crashes found.
otherwise the difference was negligible.
since the expectedlossisslimwhilethepotentialgainislarge weshouldbenefitfrom choosing the distance based fitness function a priori.
1031table detailed experimental results for rq1 and rq3.
we show the mann whitney u test results along with the detailed numbers for every experiment we performed.
the shared areas indicate statistically significant results.
no pca vs. dynamic pca rq1 .
coverage vs. distance based fitness rq3 .
package name version kloc1ankou crashes2ankou throughput3no pca crashes1 u value4no pca throughput2 u value5cov based crashes1 u value6cov based throughput2 u value binutils .
.
inf .
.
.
.
.
.
.
bison .
.
.
.
.
.
.
.
.
.
catdoc .
.
.
.
.
.
.
.
.
.
.
.
.
.
cflow .
.
.
.
.
.
.
.
.
.
.
clamav .
.
.
.
.
.
.
.
.
.
.
graphicmagick .
.
.
.
inf .
.
.
.
.
.
.
.
jasper .
.
.
.
.
.
.
.
.
.
.
libav .
.
.
.
.
.
.
.
.
.
.
.
.
dwarf b4f198 .
.
.
.
.
.
.
.
.
.
libexiv2 .
.
.
.
.
.
.
.
.
.
.
.
.
.
libgxps .
.
.
.
.
.
.
.
.
.
.
.
.
liblouis .
.
.
.
.
.
.
.
.
.
.
libming .
.
.
.
.
.
.
.
.
.
.
.
mpg123 .
.
.
.
.
.
.
.
.
.
libncurses .
.
.
.
.
.
.
.
.
libraw .
.
.
.
.
inf .
.
.
.
.
.
libsass .
.
.
.
inf .
.
.
.
.
.
libtasn1 .
.
.
.
.
.
.
.
.
libtiff .
.
.
.
inf .
.
.
.
.
.
.
libtorrent .
.
.
.
.
.
.
.
.
nasm .
.03rc2 .
.
.
inf .
.
.
.
.
.
pspp .
.
.
.
.
.
.
.
.
.
.
tcpdump .
.
.
.
.
.
.
.
.
.
vim .
.
.
.
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
subjectsthroughput ratio in log figure6 comparisonoftestcasegenerationthroughputbetween ankou and afl.
on the other hand ankou using distance based fitness function had a test case generation throughput lower because of thetime spent on computing its fitness function.
thus even if the distance based fitnessincurs a significantlyslower throughput it allows ankou to find more unique crashes.
remarkably the difference in branch coverage was insignificant it was under .
on average.
this result coincides with our observation softwarebugsdonotmanifestwhenweachievecertaincode coverage butwhenweexerciseaspecificexecutionpath.therefore we conclude that distance based fitness function benefits grey box fuzzing in terms of finding software bugs in an effective manner.
.
rq4 distance based fuzzing cost in this subsection we evaluate the practicality of distance based fuzzingwith thefollowingtwoquestions isthedynamic pca necessary?
how slow would it be if we were to use the standardpca instead?
and how much performance overhead can weobserve by enabling distance based fuzzing assisted by dynamic pca instead of a coverage based approach?
the answer to the first question is indeed simple our initial fuzzerprototypewiththestandardpcawasnotusableasitspendsmost of its time on computing the pca.
on our machine it took aboutanhourtocomputethe pcafor5 000seedfiles.giventhat fuzzerstypicallyrunthousandsoftestcasespersecond itwould not be possible to use the standard pca in practice.
toanswerthesecondquestion wecomparedthetestcasegeneration speed of b oth ankou and afl.
we chose afl because it is a highly optimized fuzzer in terms of its fuzzing speed .
figure6showsthetestcasegenerationthroughput whichisagood measureforthecostofadditionaloperations asdiscussedin .
.
weobservedthatankouwas35.
slowerthanaflonaverage with89 ofthe experimentsbeingsignificant.however thisdoes notmean that ankou is a worse fuzzer than afl.
although ankou is slow in generating test cases it produces more meaningful ones and thus finds twice more bugs than afl as we will see in .
.
unexpectedly ankou showed abetter throughput than afl on of the subjects.
we thought this could be caused by ankou achievinglowercodecoverage makingexecutionsfaster.however thecorrelationbetweenthecoverageandthethroughputratioswas only .
.
we believe ankou found new regions of the programs thatquickly terminate while afldid not.overall distance based fuzzingsignificantlydecreasesthethroughput butitisworthwhiletoperformmoreinformed hencemoreeffective seedpoolupdates.
.
rq5 comparison against other fuzzers although dynamic pca is costly it can enable higher software bug finding.
to understand thepractical impact of distance based fuzzing weanswer thefollowing two questions howeffective ankou is in terms of the number of unique crashes found?
how fast can ankou find a crash?
.
.
number of crashes.
we ran ankou afl and angora on each subject.
we then measured how many crashes were found for each subject along with the achieved branch coverage.
.
.
subjectscrash coverage rat io in log crashes coverage a ankou vs. afl.
subjectscrash coverage rat io in log crashescoverage b ankou vs. angora.
figure comparison between ankou and other fuzzers in termsofthenumberofcrashesfoundandbranchcoverage.
figure 7a presents the result against afl.
in total ankou found 3kmoreuniquecrashesthanafl whichis1 .
moreonaverage.
ankoufoundmorecrasheson75 ofthesubjects onwhich66 oftheexperimentswheresignificant.ontheotherhand thetwo fuzzersachievedmoreorlessthesamebranchcoverage onaverage ankoucovered1.
morebranchesthanafl.notethatankou was able to find twice more crashes even though there was no big differenceintermsofcodecoverage.thisresultindeedalignswith ourkeyintuition softwarebugsoftenmanifestwhenweexercise a particular execution path but not when we reach a node.
figure 7b presents the result against angora.
unlike afl and ankou angora requires dfsan instrumentation to perform tainttracking whichmakesitdifficulttocompileourbenchmark.
asaresult wewereonlyabletocompileabouthalfofthepackages.amongthese angorafoundcrashesin22subjects.here wereport results only on those.
on average ankou found .
more crashes than angora.ankou prevailedon most subjects and halfof them showed strong statistical significance.
these results confirm using the distance based fitness function leads to better crash finding.
.
.
time to exposure of crashes.
we also measured how much time each fuzzer spends to find the first crash.
on the subjects where bothafl and ankoufound crashes ankouwas faster in finding the first crash.
similarly on the subjects where both angoraandankoufoundcrashes ankoufoundthem68 earlier.
thisresultalsoconfirmstheeffectivenessofankouagainststateof the art fuzzers in terms of its bug finding ability.
.
examination on bugs found in .
rq5 wereportedtheaveragenumberofcrashesfoundfor six repeated fuzzing experiments.
during the whole experiment ankoufound93 754crashesonthe150subjectsfor21 600hours .
although this number has its own value we analyzedfurthertounderstandhowmanyuniquebugseachfuzzerankou afl a ankou vs. afl.ankou angora b ankou vs. angora.
figure comparison of bugs found.
table comparison between fuzzers by the number of unique bugs when triaged with stack hash.
of bugs found of bugs found package name ankou afl ankou angora binutils bison catdoc cflow clamav dwarf graphicsmagick jasper libav libexiv2 libgxps liblouis libming libncurses libraw libsass libtasn1 libtiff libtorrent mpg123 nasm pspp tcpdump vim total as mentioned in .
.
we were not able to compile angora on all the packages.
for fair comparison we report bugs found by ankou only on the subjects that angora was able to run on.
found.
this is important as noted by klees et al.
because multiple unique crashes may be due to the same bug.
unfortunately manual inspection was not an option as there weresimplytoomanycrashes.weoriginallytriedtorunasan to triage the crashes but it failed to detect the root cause of many crashes.therefore wedecidedtousesafestackhash instead whichworksthesameastheclassicstackhash withoneexception whenthereisanunreachablereturnaddressinthestack trace itstopstraversingthestack.inourexperiment wecomputedthe safe stack hash of the top five stack trace entries of each crash.
although there are advanced crash triaging algorithms it is beyond the scope of this paper to adopt such techniques.
figure8andtable2representsthenumberofuniquebugsfound after running the safe stack hash on all the crashes found.
overall ankoufound1.
and4.
moreuniquebugsthanaflandangora respectively.
there were overlaps but there were a higher number of bugs that only ankou was able to find.
all these results confirm the practicality of ankou in terms of bug finding.
discussion first we define the execution distance definition .
as the eu clidean distance in the branch hit count space p. although we 1033believethechoiceofeuclideandistanceisintuitive onemayconsideradifferentdistancemetricsuchasmanhattandistance.furthermore the fitness function is defined as the minimum distance fromatestcase executiontotheseedpoolexecutions.whilethis isintuitivelytheamountofdiscoverymadebythisnewtestcase there may be a more optimal way of setting the fitness function.
we see improving this area as promising future work.
in our experiment the dynamic pca was always able to reduce thestatespacewithanacceptableinformationloss.however there is no guarantee that it will be the case for all programs.
we leave it as future work to prove a theoretical bound of its information loss.
with the adaptive seed pool update the fitness threshold fitis adaptivelysettotheminimumexecutiondistancebetweenanytwo seeds.however theremaybeopportunitiestochooseamoreappropriate threshold by not limiting ourselves to the contents of the seed pool.
for example refused test cases even though they were notincludedinthepool maybeabletoprovideusefulinformation to help this choice.
designing an optimal strategy for updating the seed pool is beyond the scope of this paper.
related work fuzzing.fuzzinghasshownremarkablesuccessinvariousareas .
in the context of fuzzing usage of the evolutionary algorithm was first introducedbysidewinderin2006 andpopularizedbyafland libfuzzer .
ankou is also a grey box fuzzer built upon the evolutionary framework.
however its uniqueness is its leverage of an informative fitness function that we call distance based fitness which deals with the considerably high dimensionality of the program state space compared to the existing fitness functions.
improving fitness function .therehavebeenseveralresearch papers on improving the information given to and the objective of the fitness function.
collafl improves information quality by avoidinghashcollisions thusindirectlyenhancesthefuzzerfitness function.althoughitgainsbyavoidingimprecision itsfitnessis still based on branch hit count states so it suffers from the local optimum problem.
perffuzz leverages multi dimensional feedbackconsideringbothcodecoverageandexecutioncountstotacklethelocaloptimumproblem.eclipser usesbranchdistances to guide their search towards solving linear and monotonic constraints.
angora augments its fitness function by considering the calling context when calculating branch coverage.
however noneoftheseapproacheshandlesthehigh dimensionalityproblem ofemploying aninformative fitnessfunction.our distance based fitness function is complementary to them.
distance between test cases .feldtet al.
proposed a distance quantifying the difference between test cases.
unlike executiondistance seedefinition3.
whichisbasedontheexecutionofaprogram thisoneisbasedontheinputcontentsalone.itcouldstill have been used in complement to bif it was not for its high computational cost.
pinilla l pez et al.
compute pca on the most recently discovered seeds to bias the seed scheduling.
although theirworksharesthesameintuitioninconceptualizingthestate space ourapproachdiffersbothingoalaswellasintheunderlying technique.ourgoalisguidingafuzzingcampaignusingafitnessfunction whiletheirsismodifyingtheseedschedulingalgorithm.
moreover scheduling algorithms can only be informed by seedsalready chosen by their fitness function.
however our approach recognizes information from all the generated test cases.
seed scheduling .starting from woo et al.
seed scheduling has been a popular topic for improving fuzzers.
aflgo and hawekeye combine fuzzing with information extracted from static analysis to direct fuzzers.
aflfast suggests power scheduling whichassignsmoreenergytoseedsthatachievehigher code coverage.
cerebro enhances seed schedulingbased on a variety of objectives such as code complexity and code coverage ofseeds.suchimprovementhasthebenefitoffocusingonatiny subset of test cases already selected by the user or the fitness function i.e.
the seed pool.
unfortunately we cannot directly apply these techniques to a fitness function due to its harsh performance requirement it needs to run for every single test case.
advanced pca .roweis suggestsanexpectationmaximization algorithm for computing pca.
it does not need the covariance matrix and only calculates the desired number of principal com ponents.
however this approach requires all the samples to be givenatthebeginningofthealgorithm whichdoesnotmeetour needs since fuzzers generate samples throughout the fuzzing campaign.
on the other hand the online pca aims to compute principalcomponentsonthefly whenevernewdataisacquired itupdatesthecurrentprincipalcomponents.thissolutionisnotsuitable for grey box fuzzing as each of the online pca updateshas a complexity of o n2 wherenis the number of dimensions of the original space i.e.
the number of branches.
whereas the timecomplexity ofdynamicpcaislinear in n.otherapproaches such as random projection based online pca and stochastic pca havealinearcomplexity.thisisachievedbydiscarding muchoftheavailabledata unlikethedynamicpca whichincludes most of the data by updating the covariance matrix and its basisimprovement mechanism.
furthermore none of the approaches above includes a discount factor described in .
.
conclusion wedesignedandimplementedankou thefirstgrey boxfuzzerthat operates with a high dimensionality representation of the program state space.
ankou employs distance based fitness function which provides too much information about program executions to consume in practice.
however we transform the information obtained by the fitness function with our novel dimensionality reductiontechniquethatwerefertoasdynamicpca.asaresult wewereable to greatly improve the current state of grey box fuzzing in terms of its bug finding ability.
we made both our source code and benchmark public to support open science.