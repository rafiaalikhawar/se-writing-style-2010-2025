jst ar javascript specification type analyzer using refinement jihyeok park school of computing kaist daejeon south korea jhpark0223 kaist.ac.krseungmin an school of computing kaist daejeon south korea h2oche kaist.ac.krwonho shin school of computing kaist daejeon south korea new170527 kaist.ac.kryusung sim school of computing kaist daejeon south korea yusungsim kaist.ac.krsukyoung ryu school of computing kaist daejeon south korea sryu.cs kaist.ac.kr abstract javascript is one of the mainstream programming languages for client side programming server side programming and even embedded systems.
various javascript engines devel oped and maintained in diverse fields must conform to the syntaxand semantics described in ecmascript the standard specifica tion of javascript.
since an incorrect description in ecmascriptcan lead to wrong javascript engine implementations checkingthe correctness of ecmascript is critical and essential.
however all the specification updates are currently manually reviewed bythe ecma technical committee tc39 without any automatedtools.
moreover in late the committee announced the yearlyrelease cadence and open development process of ecmascript toquickly adapt to evolving development environments.
because ofsuch frequent updates checking the correctness of ecmascriptbecomes more labor intensive and error prone.
to alleviate the problem we propose jstar a javascript specification type analyzer using refinement.
it is the firsttool that performs type analysis on javascript specifications and detects specification bugs using a bug detector .
for a given specification jstar first compiles each abstract algorithm written in a structured natural language to a corresponding function inir es an untyped intermediate representation for ecmascript.
then it performs type analysis for compiled functions withspecification types defined in ecmascript.
based on the resultof type analysis jstar detects specification bugs using a bug detector consisting of four checkers.
to increase the precision of the type analysis we present condition based refinement for type analysis which prunes out infeasible abstract states using conditions of assertions and branches.
we evaluated jstar with all versions in the official ecmascript repository for therecent three years from to .
jstar took .
seconds on average to perform type analysis for each version and detected157 type related specification bugs with .
precision outof bugs are true bugs.
among them bugs are newlydetected by jstar and the committee confirmed them all.
index t erms javascript mechanized specification type analysis refinement bug detection i. i ntroduction javascript is one of the most popular programming languages.
according to the state of the octoverse1 the annual report of github the most dominating programming language in github repositories was javascript since to .
while javascript was initially designed for client side programming in web browsers it is now widely used in server side programming and even in embedded systems developers in diverse fields build and maintain javascriptengines conforming to ecmascript the javascript standardspecification which describes the syntax and semantics of javascript in a natural language.
the correctness of ecmascript is critical because an incorrect description in the specification can lead to wrong im plementations of javascript engines in various fields.
however all the specification updates are currently manually reviewedby the ecma technical committee tc39 without any automated tools.
such a manual review process is inherently labor intensive and error prone making ecmascript vulnera ble to specification bugs.
besides in late the committee announced the yearly release cadence and open development process of ecmascript to quickly adapt to evolving devel opment environments.
according to park et al.
the average number of updated steps of abstract algorithms between consecutive releases from ecmascript es7 to es10 is .
.
in the official ecmascript repository pull requests and commits exist in the master branch.therefore manually checking all the frequent specification updates is a challenging task.
unfortunately no existing tools can automatically detect bugs in rapidly evolving javascript specifications writtenin english.
thus the ecmascript committee has pursued various manual annotations in abstract algorithms to reducespecification bugs.
first the committee has introduced two kinds of annotations assertions to denote assumptions at specific points of abstract algorithms and two prefixes ?and !to represent whether the execution of an abstract algorithm completes abruptly or not.
for example assert type o i s object denotes that the variable oalways has an object value at the point of the assertion and ?
getv v p denotes that the execution of getv v p may complete abruptly.
such annotations help readers understand specifications clearly andthey are also helpful for specification based tools 2such as javascript engines debuggers static analyzers and verification tools .
second the committee has started internal discussions on type annotations for variables parameters and return values of abstract 36th ieee acm international conference on automated software engineering ase 36th ieee acm international conference on automated software engineering ase .
ieee .
ase51524.
.
.
ieee algorithms3.
however any kinds of manual annotations are labor intensive and error prone and they do not provide any automatic mechanism to detect specification bugs.
to alleviate this problem we propose a novel tool jst ar ajavascript specification type analyzer using refinement.
the main challenge of ecmascript type analysis to stati cally detect type related specification bugs automatically is that ecmascript describes abstract algorithms in a natural language english.
while researchers have formallydefined various javascript semantics for different versions of ecmascript by hand manual formalization is not suitable for automatically detecting bugs in rapidly evolving javascriptspecifications.
thus recent approaches in diverse fields such as system architectures network protocols and language specifications have utilized informationdirectly extracted from specifications written in a natural language to lessen such burdens.
among them jiset compiles ecmascript abstract algorithms written in a structured natural language to functions in ir es an untyped intermediate representation for ecmascript.
therefore jst ar leverages jiset to mechanically handle javascript specifications.
jst ar takes mechanized javascript specifications from jiset and performs a type analysis of compiled functions using specification types defined in ecmascript.
ecmascript contains not only javascript language types but also specifica tion types such as abstract syntax trees asts internal listlike structures and internal records including environments completions and property descriptors.
we define their typehierarchies based on subtype relations.
for records and ast types we also define their fields.
using such type information jst ar performs a type analysis and detects specification bugs using a bug detector consisting of four checkers a reference checker an arity checker an assertion checker and an operand checker.
jst ar also uses a condition based refinement for type analysis which prunes out infeasible parts in abstract states by using conditions of assertions and branchesto improve the precision of type analysis.
we evaluated jst ar with all versions in the official ecmascript repositoryfor the recent three years from to .
the experimentsshowed that the refinement technique could reduce the number of false positive bugs caused by spurious types inferred by imprecise type analysis.
the main contributions of this paper are as follows we present jst ar the first tool that performs a type analysis on ecmascript written in a natural language to check the correctness of javascript language specifications.
jst ar automatically detects type related specification bugs such as unknown variables duplicated variables missing parameters assertion failures ill typed operands and unchecked abrupt completion bugs.
we present a condition based refinement for type analysis of ecmascript to reduce the number of false positivebugs by enhancing the analysis precision.
we show that the refinement technique increases the analysis precision fig.
jst ar a type analyzer and a bug detector for mechanized specifications extracted from ecmascript by jiset from .
to .
by removing false bugs anddetecting one more true bug.
we demonstrate the practicality of jst ar .
it takes .
seconds on average to perform a type analysis for eachversion of ecmascript and detected type related specification bugs with .
precision out of bugs are true bugs.
among them jst ar newly detected bugs and the ecmascript committee confirmed themall.
ii.
o verview in this section we demonstrate the overall structure of jst ar depicted in figure .
it consists of three components specification extraction type analysis and bug detection.
a. specification extraction jst ar extracts the javascript syntax and semantics using jiset and extracts specification types from ecmascript.
a syntax and semantics ecmascript describes the javascript syntax in an ebnf notation and the semantics using abstract algorithms written in a structured natural language.
from ecmascript jiset synthesizes ast structures for syntax and compiles the abstract algorithms to ir esfunctions with parameters and local variables for semantics.
for ex ample the algorithm step is compiled to an ir esinstruction let baseobj toobject v.base .
to make it suitable for type analysis we modify ir esas formally defined in section iii a. b types in addition to javascript types jst ar represents three kinds of specification types.
first because asts are values in abstract algorithms they can be stored invariables and passed as function arguments.
for asts we use their production names as their types and automatically link their corresponding syntax directed algorithms to theirfields.
second ecmascript supports various record types and fields whose possible values are defined in their corresponding tables.
for example table completion record fields in the latest ecmascript describes the fields of the completion records.
thus we manually model the fields of record typesbased on the tables in the latest version and use them in a type analysis.
third for list like structures we define the empty list type and parametric list types .
607fig.
an example javascript program with related previous specification bugs and their bug fixes b. type analysis jst ar performs a type analysis with flow sensitivity and type sensitivity for arguments.
each function is split into multiple flow and type sensitive views and an abstract state stores mapping from views to corresponding abstract environments.to handle views separately we use a worklist algorithm.
the type analyzer consists of two sub modules an analysis initializer and an abstract transfer function.
a analysis initializer it defines the initial abstract state and the initial set of views for a worklist.
ecmascript provides three kinds of abstract algorithms normal syntaxdirected and built in.
as for entry points of type analysis we use syntax directed algorithms and built in algorithmsbecause they have their parameter types.
for each entry point the initializer defines its abstract environment with parameter types and adds the flow and type sensitive views of the entry point to the worklist.
b abstract transfer function for each iteration the abstract transfer function gets a specific view from the worklistand updates the abstract environments of the next views based on the abstract semantics.
it adds the next views to the worklistif it changes their abstract environments and the iteration finishes when the worklist becomes empty.
to increase the analysis precision we perform a condition based refinement for an abstract environment when the current control point is a branch or an assertion as described in section iii c. c. bug detection to detect specification bugs utilizing the type analysis we develop four checkers in a bug detector.
we explain the targets of the checkers with an example javascript program that contains related previous specification bugs and their bug fixes as shown in figure .
a reference checker the example javascript program first defines a variable fwithout initialization which has the value undefined .
it then assigns an anonymous function to f using the operator ?
?
.
while the corresponding evaluationalgorithm in figure a originally used the getreferencedname algorithm to get a reference name on line .a a contributor removed the getreferencedname algorithm and replaced all its invocations with accesses of the field on october .
however the contributor missed several cases including the semantics of ?
?
which was fixed by another contributor on november .
thus the unknown variable bug for getreferencedname lasted for days which the reference checker can detect.
b arity checker the program finally calls fwith an argument true .
during the initialization of the function call iteratorbindinginitialization in figure b is executed with additional parameters iteratorrecord and environment to assign argument values to parameters.
however a contributor missed passing additional arguments to them on line in iteratorbindinginitialization ofarrowparameters on september .
it caused an arity mismatch bug which lasted for 533days until another contributor fixed it on february .
the arity checker can detect such arity mismatches.
c assertion checker during the initialization of the function call iteratorbindinginitialization off ormalparameter in figure c contains another bug.
even though the additional environment parameter may contain undefined a contributor did not consider it on line in the initial commitof the open development process on september .it caused an assertion failure bug which lasted for days until another contributor fixed it on april .
the assertion checker can detect such assertion failures.
d operand checker after the function call initialization the parameter xhas the value true and math.round in figure d is invoked with the argument true .
the math.round built in library first converts the given parameter xto its corresponding number value nusing tonumber and performs the remaining steps using n. however a contributor mistakenly used xinstead of non lines and on september .
this bug caused the algorithm to compare theboolean value true with the numeric value .
or in the 608fig.
fields of completion records in ecmascript example code.
this bug lived for two days until another contributor fixed it and the operand checker can detect them.
in the remainder of this paper we explain the details of how to perform type analysis for ir esfunctions and how to increase the analysis precision using the condition based refinement section iii and how to detect type related specification bugs section iv .
after we evaluate jst ar section v we discuss related work section vi and conclude section vii .
iii.
t ype analyzer this section formally defines a modified ir esand its type analysis and presents a condition based refinement of the typeanalysis to improve the analysis precision.
a. intermediate representation ir esis an untyped intermediate representation for ecmascript .
we modify it as a label based language to make it suitable for type analysis as follows functions f ownerf def x x l instructions i owneri let x e x ee asserte ifell returne r e