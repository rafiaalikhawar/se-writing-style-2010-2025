libkit detecting third party libraries in ios apps daniel dom nguez lvarez imdea software institute madrid spain university of verona verona italyalejandro de la cruz imdea software institute madrid spain alessandra gorla imdea software institute madrid spainjuan caballero imdea software institute madrid spain abstract we present libkit the first approach and tool for detecting the name and version of third party libraries tpls present in ios apps.
libkit automatically builds fingerprints for 86k library versions available through the cocoapods dependency manager and matches them on the decrypted app executables to identify the tpls name and version an ios app uses.
libkit supports apps written in swift and objective c detects statically and dynamically linked libraries and addresses challenges such as partially included libraries and different compiler versions and configurations producing variants of the same library version.
on a ground truth of open source apps libkit identifies libraries with a precision of .
and a recall of .
.
libkit also significantly outperforms the state of the art crios tool for identifying tpl boundaries.
when applied to apps from the itunes store libkit detects library versions identifying popular apps that contain old library versions.
ccs concepts software and its engineering software libraries and repositories security and privacy mobile platform security .
keywords mobile apps ios third party libraries acm reference format daniel dom nguez lvarez alejandro de la cruz alessandra gorla and juan caballero.
.
libkit detecting third party libraries in ios apps.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
introduction there exist many scenarios where entities other than the developer may need to know the third party libraries tpls a mobile app uses.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
include i a company selecting among different proprietary apps wants to know whether those apps contain vulnerable tpls ii a malicious library has been identified and users want to know whether the apps they use contain it iii an app is observed to perform some privacy violating behavior and market auditors need to establish if the behavior comes from the app or a tpl it uses and iv regulators need to measure the prevalence of advertisement libraries to determine if a merger of ad companies may create a dominant market position .
in both ios and android ecosystems most mobile apps and many tpls are closed source so tpl identification approaches need to operate on released app packages ipas for ios apks for android and should be able to identify tpls even if the library source code is not available.
tpl identification comprises three problems.
the goal of boundary identification is to split the code of an app e.g.
mach o executable for ios dex bytecode for android into components where one component corresponds to the app s code and there is one additional component for each tpl.
the goal oflibrary identification is to output the names of all tpls an app uses.
finally the goal of library version identification is to output the name and version of all tpls an app uses.
in this paper we present the first tpl detection approach that can identify the name and version of libraries present in an ios app and a tool called libkit that implements it.
a few works have proposed ios tpl identification approaches .
however those approaches either use clustering based techniques that only address the boundary identification problem i.e.
crios tang et al.
or are specific to tpls that are available both in android and ios .
libkit follows prior android tpl identification approaches that operate in two phases library fingerprint generation andlibrary detection .
the main advantage over ios clusteringbased techniques is that our approach can name a library and identify its version beyond identifying the boundaries between the app s and tpl s code.
at a high level our approach works as follows it takes as input the library repository of cocoapods one of the major dependency managers for swift and objective c projects used by over 3m ios apps .
it generates a library version fingerprint for each library version in the cocoapods repository.
a library version fingerprint is a distinctive set of features that capture the unique properties of a library version.
in our approach a library version fingerprint comprises a set of class fingerprints each capturing syntactic features about a class that is part of the library version.
the fingerprints are extracted statically from theesec fse december san francisco ca usa daniel dom nguez lvarez alejandro de la cruz alessandra gorla and juan caballero library version s binary code.
the generated fingerprints are then stored in a database.
given an app libkit decrypts the app s binary code analyzes its binaries to obtain the class features and produces a set of class fingerprints one for each class in the app.
then it looks for matching app s class fingerprints in the library class fingerprints in the database.
libkit outputs the list of library names and versions identified in the app.
steps and only need to be performed once for each library version.
libkit can incorporate new library versions as soon as they appear in cocoapods repeating and only for new versions.
existing fingerprint based android tpl identification approaches cannot be easily ported to ios because they rely on android s package structure which does not exist in ios.
the reliance on package structure has been identified as a main limitation of android tpl identification approaches by a recent independent evaluation .
the only android fingerprint based approach that does not leverage the package structure is orlis .
however orlis does not support library version identification and it performs worst among publicly available android tpl identification tools .
we design an automated build pipeline for cocoapods libraries which allows us to produce fingerprints for tpl versions belonging to tpls.
this is the largest library database in tpl identification works seven times larger than the largest 12k versions used in android tpl identification .
we design our fingerprints to work on class information available in ios native code regardless if the native code comes from compiling objectivec or swift source code and despite the class information not being as rich as that in android s bytecode.
our fingerprints leverage a similarity hash for matching class fingerprints that are similar but not identical.
the matching algorithm aims for the highest possible coverage of app classes and allows for partial library coverage i.e.
identifies tpls even when due to dead code elimination only part of the tpl code makes it into the app s native code.
we evaluate libkit according to its ability to identify the correct name and version of libraries included in a set of ios apps.
for this we have created two ground truth datasets one with the name of libraries included in at least one of open source apps available in github gt95 and another one with library versions name and version that appear in at least one of open source apps gt43 .
for library identification on gt95 libkit achieves aprecision of .
recall of .
and f1 score of .
.
when considering all libraries in our ground truth including those not present in our database it achieves a precision of .
recall of .
and f1 score of .
.
we also evaluate the accuracy of libkit for identifying not only the correct library name but also the correct version.
for library version identification on gt43 libkit achieves aprecision of .
recall of .
and f1 score of .
.
we also evaluate libkit against the state of the art.
since libkit is the first tool for library identification and library version identification in ios there is no perfect baseline to compare with.
the closest ios work is crios because it is generic i.e.
targets any tpl but it only addresses the problem of boundary identification.
we obtained the original crios source code from its authors and spent significant work updating it so that it could handle recent ios apps.
we compare libkit against crios for the boundary identification problem.
libkit significantly outperforms crios for this task achieving an f1 score of .
compared to .
.
as explainedabove fingerprint based tpl identification tools for android rely on package structure or do not address the problem of library version identification.
we tried porting libscout to ios but the required changes were so significant that it no longer represented the original approach and could not be used as a representative baseline.
comparing libkit s accuracy with that reported in the recent independent evaluation by zhang et al.
is the best we can do in this situation.
in their evaluation libscout was the bestperforming tool for both library identification and library version identification and libkit achieves higher f1 scores on ios apps than those reported by zhang et al.
for libscout on android apps.
finally we apply libkit on apps from the itunes store for which we do not have a ground truth.
this experiment simulates how libkit could support the work of a security analysis that needs to identify which tpls a set of applications include to either identify apps that include known malicious libraries or known vulnerable library versions.
libkit detects library versions with a median of .
libraries per app.
we report the top libraries identified and show that popular apps contain old library versions.
to allow future work on ios tpl identification to use libkit as a baseline we have released the code database and ground truth required to replicate this research .
this paper makes the following contributions it presents the first library identification and library version identification approach for ios apps.
it automatically builds fingerprints for versions of tpls available in the cocoapods repository.
it builds a ground truth of apps with their libraries and apps with their library versions.
we release libkit our fingerprint database and our ground truth datasets .
background this section first explains how ios apps are developed in section .
and then details how developers can integrate tpls using the cocoapods package manager in section .
.
.
ios app development the original official language for developing ios apps was objectivec a superset of the c language that adds an object oriented layer and runtime.
in apple released swift a new programming language to replace objective c. swift was designed to maintain compatibility with objective c. for this reason even a pure swift app contains parts of the objective c runtime and each swift class is also an objective c class.
building.
ios app developers typically use the official xcode ide as development environment.
xcode handles all steps for building an app including compilation linking and post build steps like signing and packaging.
all executable code produced in the build process is in mach o executable files.
these include the app s code dynamic libraries statically linked libraries and vendored libraries i.e.
open source libraries whose source code is directly copied into the app s source base.
dynamic libraries are distributed as frameworks comprising of the library code in a mach o executable and any resources the library requires.
frameworks typically containlibkit detecting third party libraries in ios apps esec fse december san francisco ca usa their name in the path to their executable making their identification easier.
however the framework files may not be named with the known library name and the version is not disclosed.
the binary code of statically linked libraries and vendored libraries will instead be included into the main app executable.
nowadays ios apps typically contain multiple mach o executables one executable for the main app including the app s code vendored libraries and statically linked libraries and one executable for each framework that is not a system library pre installed in ios.
packaging.
ios apps are distributed as ipa containers which are zip files with a specific structure.
at its top level an ipa file has apayload folder that contains all files necessary to run the app with the exception of system libraries.
the payload folder contains one or more app bundles i.e.
.app subfolders .
each app bundle contains an info.plist configuration file an executable associated resources e.g.
translations assets images and its frameworks.
apps needs to be digitally signed.
ios will refuse to run apps not properly signed.
an alternative is to use a jailbroken device that circumvents signature checks.
distribution.
to publish an app through the official itunes store a developer must create a developer account.
apps in the itunes store are signed by apple.
the fairplay drm protection used by apple will encrypt the executable code using a developer specific key before publishing it in the store leaving other files e.g.
resources unencrypted.
.
cocoapods ios developers may use a package manager pm to handle their app s dependencies e.g.
download third party libraries and add them to the app s project.
there exist three ios pms cocoapods carthage and swift package manager swift pm .
all three support libraries distributed as source code or precompiled.
a key difference between them is that cocoapods uses a central repository to store specifications called podspecs of the available library versions.
this central repository allows library developers to make their tpls visible to app developers who can easily find tpls to use.
in contrast carthage and swift pm do not have a central repository and thus app developers must find libraries on their own.
when a developer wants to publish in cocoapods a new library or a new version of an already available library it submits a podspec file to the public repository.
cocoapods assumes semantic versioning for library versions major.minor.patch .
figure shows an excerpt of the podspec of firebase a popular google library.
the podspec first contains general information about the library such as its name version and the source from where the library can be downloaded e.g.
url to a repository or an archive .
then it lists dependencies broken into modules or subspecs in the cocoapods jargon.
in the example the library has two subspecs core admob but only the default core subspec will be installed by default.
the firebase core subspec depends on two other libraries firebaseanalytics firebasecore .
the admob subspec depends on the firebase core module and the library google mobile ads sdk.
to include libraries in an app the developer generates a podfile that states the libraries that the app depends on.
cocoapods uses thepodfile to automatically download the specified libraries and its dependencies and to incorporate them into the app s xcode project name firebase version .
.
source http default subspecs subspecs name core dependencies firebaseanalytics .
.
firebasecore .
.
name admob dependencies firebase core google mobile ads sdk .
.
figure simplified podspec for firebase .
.
.
platform ios .
target test do use frameworks!
pod firebase .
.
pod objection pod ssziparchive .
end figure podfile for a test app requiring three libraries.
so that they are compiled if distributed as source code and linked when building the app.
figure shows an example podfile for a test app which requires three libraries or pods .
in this case the app developer requests through the use frameworks!
statement that the libraries are built if possible as separate frameworks.
this causes the app to contain four mach o binaries one with the test app code and one for each library.
for firebase the developer requires version .
.
.
since the podfile does not specify any firebase subspec only the default firebase core subspec will be included.
for objection since the developer did not specify any version cocoapods will install the latest version.
for ssziparchive the developer used the optimistic operator .
which is equivalent to range .
.
.
.
.
since developers may not specify a library version or may provide a range of valid versions cocoapods decides which library versions are included among those satisfying the constraints.
the cocoapods installation produces a podfile.lock file that resolves the dependencies into concrete library versions.
in the example the podfile.lock file will specify that firebase .
.
objection .
.
and ssziparchive .
.
were included into the app s project.
unfortunately the podfile.lock file is not part of the built app.
thus it is only available when building the app from source code and cannot be used for tpl detection in our scenario where the input is the app s binary code.
approach the key idea behind any fingerprint based identification technique lies in representing an analyzed artifact e.g.
a malware sample a tpl a whole binary file or a single compiled class in a fingerprint capturing the unique features present in such artifact.
such fingerprint can then be used for reliable identification based on these distinctive features in other artifacts.
libkit is a fingerprint based technique to identify tpls is ios apps and therefore comprises two phases described in figure library fingerprint generation andlibrary detection .
library fingerprint generation takes as input a large collection of known tpls to generate a database of library fingerprints.
libkit can automatically collect and build fingerprints for libraries in the cocoapods repository although its modular design allows to analyze tpls from other sources with some manual work.
specifically library fingerprint generation retrieves a library by getting its cocoapodsesec fse december san francisco ca usa daniel dom nguez lvarez alejandro de la cruz alessandra gorla and juan caballero figure libkit comprises two phases the library fingerprint generation phase at the top builds the database of fingerprints of a set of known tpls.
in the second phase library detection at the bottom the information in the database is used to analyze an app with unknown tpls.
libkit builds fingerprints for each component of the app and aims to match them in the database of known libraries in an attempt to identify the name and the version of each library.
podspec and builds it with all its dependencies.
taking the firebase library in figure as an example libkit would retrieve the firebase source code from the specified location and then would retrieve all the dependencies i.e.
firebase core firebaseanalytics firebasecore google mobile ads sdk recursively from cocoapods.
libkit resorts to a template app that solely includes the firebase library as dependency to produce the executable macho binary files of the library.
we use a template application because cocoapods is meant to be integrated with an application project and this process can produce the binary files to be analyzed regardless of whether the library or any of its dependencies is distributed as source code or pre compiled as dynamic or static library.
each macho binary file is then analyzed by the feature extraction module which employs an automated lightweight static analysis to extract syntactic code features.
such features are then used to produce a fingerprint of the library to be stored in the database.
when extracting the features libkit uses a blacklist to discard features that may negatively effect the quality of fingerprint section .
provides more details on this aspect .
libkit resorts to simhash to compute the fingerprints of the extracted features.
the advantage of simhash is that it uses a probabilistic method to generate similar fingerprints for similar objects.
therefore thanks to simhash the fingerprints of two consecutive minor versions e.g.
firebase .
.
and firebase .
.
of the same library are expected to have fingerprints closer in similarity than two versions of the same library separated by a major release e.g.
firebase .
and firebase .
or two different libraries e.g.
firebase and protobuf .the library fingerprint generation phase only needs to be done once for each library version contained in the cocoapods repository.
libkit already comes with a database of 86k library version fingerprints that we produced for our evaluation.
in the library detection phase bottom part of figure libkit analyzes a closed source ios apps aiming to identify any of the known tpl fingerprints in the app binaries.
to this end it first needs to decrypt the executable code that comes encrypted due to apple policies as explained in section .
.
it then analyzes each binary file with the same lightweight static analysis component used to extract features and build fingerprints for libraries in the library fingerprint generation phase.
libkit searches for tpl candidates having their fingerprint matching the features found in the app.
this step is not as trivial as looking for exactly matching tpl fingerprints in the database.
the executable code of a tpl in an app may have been produced following a different compilation process which may include dead code elimination and other optimizations.
this leads to have different fingerprints even for exactly the same library version.
thanks to simhash though fingerprints of the same library version are supposed to be at least similar and therefore would match anyway given a similarity tolerance threshold.
all the details of how libkit searches and matches app features with candidate tpls are further explained in section .
.libkit detecting third party libraries in ios apps esec fse december san francisco ca usa .
library fingerprint generation the top part of figure describes the architecture of the library fingerprint generation.
it takes as input the cocoapods library repository and produces a database of library version fingerprints.
given the podspec file of a specific version of a library in cocoapods libkit follows three steps for generating its library version fingerprint building feature extraction and fingerprinting .
building.
given a target library version in cocoapods libkit builds a template app that includes it.
the template app contains the bare minimum code to include the target library version with all its dependencies and build a stand alone app without any real functionality.
using a template app is needed because cocoapods does not build stand alone libraries but rather includes them into an app s project.
using a template app also allows us to produce the binary files of the library to be analyzed regardless of whether the library or any of its dependencies is distributed as source code or pre compiled as dynamic or static library.
to build the template app libkit creates a new xcode project and produces a podfile for the template app that requires the target library version.
the following code shows the podfile created for the crashlytics .
.
library.
platform ios .
target templateapp do use frameworks!
pod crashlytics .
.
end thepodfile sets ios as the target platform.
the use frameworks!
line tells cocoapods to try to build the app dependencies as frameworks.
however some libraries such as crashlytics are distributed as pre compiled .aarchives forcing xcode to link them statically into the app s main binary.
libkit then uses cocoapods to install the target library version in the podfile into the app s project.
cocoapods includes the target library version and all its dependencies into the build script of the template app project.
the cocoapods installation produces a podfile.lock file that resolves the dependencies in the podspec of the target library version into concrete library versions to be included into the app s project.
next libkit leverages xcode to build the template app.
since the template app only includes the library but does not really use it libkit uses xcode s debug mode to build it which disables dead code elimination.
this guarantees that the produced template app contains the complete target library version and its dependencies.
if the building process is successful the template app will comprise of a main mach o binary templateapp and another binary for each library built as a framework.
as a last step the built binaries and thepodfile.lock file are processed to generate a build log which captures a mapping from each executable to the library versions it corresponds to.
it also includes a dependency tree with the dependencies of the target library version declared in the podspecs of all installed libraries.
the dependency tree will miss vendored libraries since those are not declared in the podspecs .
feature extraction.
the feature extraction process takes as input the built binaries and the build log.
for each mach o binary it uses the dsdump parser for extracting the list of classes it contains.
during this process it filters out the skeleton classes that are known to belong to the template app using a static class blacklist.
for each interface nsduck nsobject bool flying void quackwithvolume int volume end a objective c source class.class name nsduck class language objective c methods method name quackwithvolume method type class method method interface void int variables objc ivar name flying objc ivar type bool b extracted features.
figure objective c feature extraction example.
remaining class properties are extracted class name class language swift or objective c the list of instance variables only for objective c classes and the list of class methods .
for each class method properties are extracted method name method type class or instance method and its interface for objective c methods for swift methods the interface is encoded in the name .
the interface of a method is a mangled string that defines the return type and thetype of its parameters .
for each objective c instance variable properties are extracted name andtype.
figure 4a shows a sample objective c class nsduck with one method named quackwithvolume.
figure 4b shows the features extracted for that class.
class fingerprints.
a class fingerprint is a bit simhash value .
simhash is a similarity hash used in many fingerprint based detection techniques because of its ability to generate similar fingerprints for similar objects.
specifically it takes as input a set of hashes and produces a fixed size hash value with the property that similar inputs produce similar hash values i.e.
with low hamming distance .
simhash can approximate the jaccard index between two sets of hash values a small hamming distance between two simhash values indicates a high jaccard index and a large hamming distance indicates a low jaccard index.
in our case the input to the simhash function is variable number of bit fnv1a hashes.
one hash covers the concatenation of the class name class language number of instance variables and number of methods.
an additional hash is produced for each objective c method for each swift method and for each objectivec instance variable.
the hash of each method and instance variable includes the class name to avoid spurious matches with unrelated classes that may have similarly named methods and variables.
in figure the class fingerprint for the nsduck class would be the bit simhash of three hashes one for the class name nsduck language objective c number of methods and number of instance variables another one for the quackwithvolume method and a final one for the flying instance variable.
class fingerprints capture class and method metadata.
they do not consider the code of the methods.
the advantage of this design is that it can identify the same class regardless of code changes due to different compiler configurations.
this is important because libkit generates the class fingerprints using compiler settings that may not match those used by the developers of the apps that use the library.
one disadvantage is that two versions of the same class with identical metadata but containing code differences e.g.
a patch that only adds a null pointer check in one method will have the same class fingerprint and thus cannot be differentiated.
another disadvantage is that our fingerprints are not resilient to symbol renaming.
however wang et al.
identified only .
esec fse december san francisco ca usa daniel dom nguez lvarez alejandro de la cruz alessandra gorla and juan caballero of one million ios apps collected from the official itunes store as being obfuscated using symbol renaming.
while obfuscation is an important problem it is not an urgent issue in today s ios landscape and thus we plan to address it in future work.
the use of simhash allows us to identify the same class despite small changes in its metadata.
the kind of changes that we want to allow are those we would normally expect between minor versions of a library.
for example the addition removal or renaming of methods or attributes of a class would not greatly impact the class fingerprint while large changes like heavy refactoring class renaming or the addition of a large number of methods would produce significantly different class fingerprints.
this is important because the generated database of libraries may not be complete.
for example the database may include some versions but not all versions of a library.
in this scenario libkit should still identify that the app contains the library.
while it cannot identify the correct library version since it is not in the database it aims to identify the closest version of the library that is in the database.
we evaluate library version identification in section .
.
library version fingerprint.
a library version fingerprint comprises of a set of class fingerprints one for each of the library classes.
more specifically the library version fingerprint comprises of the set of class fingerprints for all classes in all binaries produced when building the template app.
for example if the template app for a target library version comprises of two binaries the main templateapp binary and a framework then the library version fingerprint of that library version would comprise a set of simhashes whose size is the sum of the number of classes in both binaries minus those classes in the blacklist .
it is possible for multiple library versions to have the same fingerprint which makes them indistinguishable from each other.
this happens for two main reasons i close versions of the same library that have identical class metadata and only differ in their code ii libraries that are forks or exact clones of each other.
once the database has been populated libkit identifies the library versions with the same fingerprint and puts them in an equivalence class.
for each equivalence class it identifies a leader .
the role of the leader is to be the library version output in the results.
the leader selection counts how many times a library version depends on another in the equivalence class.
the library with the highest number of dependants is selected as the leader.
an alternative would be to output all library versions in the equivalence class.
.
library detection the bottom part of figure describes the library detection architecture.
it takes as input an app s ipa and outputs the list of library versions the app uses.
the first step is decrypting the app which is explained in section .
.
after decrypting the app the next step is for each decrypted binary to parse it extract the class and method features and generate the class fingerprints as described in section .
.
the class fingerprints are input to the candidate search whose task is to find for each class fingerprint in the app a set of similar class fingerprints in the database which we call candidates.
candidates that do not pass certain selection criteria are removed.
depending if the binary being processed is the main app binary or a framework the candidate filtering orframework filtering takecare of the removal.
the candidate selection then identifies the best matching candidate libraries.
finally the dependency inclusion adds the dependencies between the detected library versions selects a leader for each equivalence class and produces the final list of library versions identified.
candidate search.
each binary in the app ais composed of a set of class fingerprints.
for each class fingerprint cin the app s binary the candidate search function sreturns as candidate vlany library in the database containing at least one class fingerprint fmore similar than a similarity threshold tsto the class fingerprint cin the app.
s c vl vl f d simil c f ts the simil function is the normalized similarity between two class fingerprints one coming from the app c and the other from a library in the database f .
since candfare bit simhash values libkit computes their similarity based on the hamming distance of their bitstrings thus simil c f hamming c f .
the similarity threshold tscaptures the minimum similarity for two class fingerprints to be considered a match.
in section we empirically determine that ts .8gives optimal results.
candidate filtering.
the candidate search selects any library version that has at least one class in common with the app.
thus it may return hundreds or even thousands of candidates.
it makes little sense though to consider a library if the number of classes found in the app is a very small ratio of the whole library e.g.
the app contains only class of the in the candidate library .
this case is more likely a fingerprint collision which might happen for very small classes with very few features.
the second step therefore filters out from this list of candidates the libraries that do not match a significant part of the classes.
for each vlidentified during the previous step libkit keeps only the ones that satisfyl vl m vl l vl tm beingl vl the number of class fingerprints the library version has and m vl the number of classes in vlthat could not be found in aby name.
this filtering removes library versions that match very few classes of the total classes the app lib contains since it is unlikely that dead code elimination would remove the majority of the classes.
in section we empirically evaluate different tmvalues and select tm .
.
thus the candidate filtering function as follows f vl vl s c c a l vl m vl l vl tm framework filtering.
libraries compiled as frameworks have their name in the path of the application bundle.
for all library versions distributed as source the database keeps a mapping between the library version and the framework binaries produced during its processing in the library fingerprint generation.
when the binary under analysis is a framework libkit thus directly extracts its name from the path and matches it against the mapping.
libkit keeps infonly those library versions that match.
if no library candidate matches instead libkit does not remove any library versions fromf and keeps it as is.
thus if a framework was renamed no library candidate will match it and the detection will proceed without this optimization.libkit detecting third party libraries in ios apps esec fse december san francisco ca usa candidate selection.
fcontains library version candidates that may cover class fingerprints in common with other candidates.
however at the end of the library detection phase each class fingerprint found in the app should be assigned to at most one library version candidate.
keeping in mind that frameworks contain only one library per binary while the main binary may contain many statically linked libraries beside the app code libkit resorts to two different algorithms to select the best match.
in both cases libkit first ranks the list of filtered library version candidatefaccording to a score p vl .
this score is computed as a multiplication of three values.
the first value is the coverage score defined as the number of classes the candidate matches times the ratio of classes the candidate matched in app aand the total number of classes in the library version fingerprint.
the second value is the average normalized similarity of the classes matched by the candidate.
the last value is the number of different versions of the library the candidate contained in f which we call the popularity of the library.
the intuition behind this popularity score is that since close versions of a library do not differ much they will have similar library version fingerprints.
thus it is common that many versions of the libraries that most likely are the best matching ones appear in f. p vl c vl l vl simil vl pop vl in the case of the main binary libkit solves the set cover problem in a greedy fashion as shown in algorithm .
covat line is initialized with all the classes in the app that need to be covered by a library candidate in f. starting from the candidate with the highest p vl libkit removes from covthe classes that vlcovers it adds vlto the selected libraries and finally removes from fthe libraries that do not cover any remaining class in cov.
this process continues until the list in fis empty.
when the binary is a algorithm algorithm for selecting candidates in the main binary procedure solvemainbinary f fis sorted byp vl cov c c a s c removed selection forvl fdo ifvl removed then continue ignorevl end if ifcov then break we are out of classes to cover end if selection selection vl cov cov c vl forc c vl do removed removed s c end for end for returnselection end procedure framework instead libkit first picks the candidates with the best coverage score .
from this subset it picks the candidate with the best average normalized similarity and adds it to the list of selected libraries.table library database summary.
item count libraries library versions classes objective c classes .
swift classes .
methods dependency inclusion.
finally for each selected library libkit reports all its dependencies in the final list of libraries found in the app since these are implicitly included in the bundle.
datasets to evaluate our approach we need libraries and apps as well as ground truth to evaluate accuracy.
in section .
we describe how we build fingerprints for a large number of libraries available through cocoapods.
in section .
we describe how we collect popular apps from the itunes store.
finally in section .
we describe how we build a ground truth for a small number of apps to evaluate the library detection.
.
library database the seeds for the library database construction were the library versions belonging to libraries targeting ios or later available in the cocoapods repository on april 28th .
ios is the lowest sdk our xcode version supports.
we managed to compile .
of those library versions.
the most common compilation failures were that a dependency targeted ios and that the library used an old swift version e.g.
swift that our xcode version no longer supports.
we were able to extract fingerprints from .
of the compiled versions of the original seeds .
the most common failure to build a fingerprint was pure c libraries because they do not contain classes.
table summarizes the produced library database which contains library versions belonging to libraries.
the total number of classes is of which .
are objective c classes and .
swift classes.
those classes contain methods an average of .
methods per class.
.
app collection our app collection pipeline replicates the one proposed by crios .
it downloads apps by instrumenting the itunes windows client installs them on an iphone device and dumps the memory using frida after decryption has completed.
we use the app collection pipeline to download and decrypt randomly chosen apps from the list of popular apps in the italian market of the itunes store.
the download took .
days using a single windows vm and the decryption rate was apps hour using two devices.
.
ground truth we have created two ground truth datasets one with apps for which we have identified the library versions they use gt43 andesec fse december san francisco ca usa daniel dom nguez lvarez alejandro de la cruz alessandra gorla and juan caballero another with apps for which we have only identified the names of the libraries they use but not their version gt95 .
gt43.
to build our ground truth datasets we started by searching github for open source ios apps which yielded apps.
to obtain the desired ground truth for an app we need to obtain its podfile.lock file which states the library versions that cocoapods included when building the app.
for example if the app s podfile defines a range of compatible library versions the podfile.lock file will state the specific version cocoapods chose in that range i.e.
the one libkit should detect .
unfortunately podfile.lock is only available when building the app from source or if the developers commited it to the app s source repository after building the app.
it is not available for proprietary apps in the itunes store even if they were built using cocoapods.
compiling an ios open source app is most often a painful process due to limited documentation and the need to set up required dependencies.
thus we only managed to compile of the apps.
in addition another apps disjoint from the we managed to compile had their podfile.lock file available in their repository.
for these apps we know the library versions cocoapods included in the app.
however the app could also include some vendored libraries i.e.
the library source was copied into the app s source and thus is compiled as part of the app.
podfile.lock does not contain vendored libraries since cocoapods is not aware of those.
to identify vendored libraries we manually examined the app s source code in the repository.
overall the apps contain library versions belonging to libraries with a total of classes.
we use gt43 to measure how accurately libkit detects library versions.
gt95.
among the apps there were apps the with a podfile.lock in their repository and another not in gt43 that were available in the itunes store.
this allowed us to download the most recent app version at the time from the itunes store.
for these apps we cannot get the library versions used as we do not have access to their podfile.lock.
however we can parse the podfile in the source repo to identify the names of the tpls the app uses.
since the podfile is needed to build the open source app the developers generally add it to the repository in contrast to the optional podfile.lock.
note that the podfile is only available for open source apps using cocoapods but not for proprietary apps in the itunes store.
thus it cannot be used for library detection.
for these apps we only know the names of the libraries the apps use but not the library version.
we use gt95 to measure how accurately libkit detects libraries.
the apps contain libraries with classes.
this process shows that building a ground truth of library versions an app uses is challenging even for open source apps.
unfortunately we could not select the apps we wanted for the ground truth but rather the gt datasets include all apps for which we could obtain data.
however we believe the resulting datasets are representative as they contain apps of different sizes ranging from small e.g.
keepassium to very large e.g.
firefox .
evaluation our evaluation addresses the following research questions rq1 what is the accuracy of libkit for detecting libraries?
rq2 howdoes libkit compare to the state of the art?
rq3 what is the accuracy of libkit for detecting library versions?
rq4 what libraries does libkit detect on apps from the itunes store?
.
rq1 library identification to evaluate the accuracy of libkit for detecting libraries we run libkit on gt95 multiple times using different parameters.
for each run we compare the identified libraries ignoring the identified version with the list of libraries in the gt.
in particular we compute the number of detected libraries in the gt true positives the number of detected libraries not in the gt false positives and the number of undetected libraries in the gt false negatives .
we split the false negatives into those due to libraries present and not present in our library database so that we can separate database coverage from the accuracy of the detection.
from these values we derive three standard metrics precision recall and f1 score .
library detection has two parameters the similarity threshold ts and the coverage threshold tm .
to identify optimal values for these parameters we run the library detection varying their values in the ranges .
ts .95and .
tm .
in increments of5 .
the best results are achieved using a similarity threshold ts .
.
interestingly the tmcoverage threshold does not affect the results within these value ranges.
this is due to the greedy algorithm selecting candidate libraries that cover the most so the coverage threshold only applies to whatever remains after high coverage classes have been selected.
based on this evaluation we select ts .8andtm .35as parameter values for the rest of the evaluation.
using those parameter values we first measure the accuracy excluding the impact of the library database i.e.
excluding fns of libraries not in our database.
the library detection results are precisionof .
recall of .
and f1 score of .
.
we next estimate the impact of the library database coverage.
in gt95 of the libraries are not in cocoapods.
these libraries are distributed through other means.
to cover such libraries we could incorporate other library sources such as github.
another libraries are in cocoapods but libkit could not generate a fingerprint for them.
covering these libraries would require improvements to our automated build pipeline e.g.
supporting older ios frameworks.
if we include fns from missing libraries the library detection results are precision of .
recall of .
and f1 score of .
.
the impact of database coverage is significant despite our library database being the largest of its kind with 86k library versions.
in contrast the largest database in android tpl detection works contains 12k library versions .
even when including these fns the results from libkit are comparable to the best android tools.
in particular zhang et al.
evaluated the accuracy of android tpl detection tools observing that most tools achieve high precision i.e.
above .
but all have low recall i.e.
below .
.
in their evaluation the best library identification tool was libscout with a precision of .
recall of .
and f1 score of .
slightly worse than libkit.
false negatives.
next we analyze the false negatives where the library is present in our database.
more than half of these fns are limitations on our gt that does not capture dependencies due to vendored libraries.
for example one app includes the userexperiorlibkit detecting third party libraries in ios apps esec fse december san francisco ca usa library which embeds ssziparchive as a vendored library.
our gt generation correctly identified the vendored library and both libraries are in the gt but the gt does not capture the dependency between them.
libkit correctly identifies userexperior but does not identify ssziparchive because it is correctly considered part of userexperior.
thus ssziparchive is counted as a fn despite the detection being arguably correct.
adding dependencies to the gt is in our future work plan but it requires significant manual work.
the similarity threshold is behind of the fns.
in these cases the highest similarity between a class from the library in the app and the corresponding library class in the database is below .
.
one explanation for these cases is that our database contains far away versions of the library compared to the version the app uses so the similarity is low.
reducing the similarity threshold could help remove some of these fns but it would introduce fps and hamper scalability by largely increasing the number of candidates.
the coverage threshold is behind of the fns.
these are cases where the library in the app does not cover at least of the full library in the database.
these may be due to aggressive dead code elimination while building the app or again to low coverage of the library versions in our database.
false positives.
a common reason for false positives are actually false negatives what we call fn fp pairs.
it often happens that when libkit misses a library it introduces a fp by selecting a different library that contains the missing library.
for example one app uses the reachability library.
libkit misses reachability and instead flags geeksdk which vendors reachability.
in this case libkit is correctly capturing reachability but the fact is hidden in the results introducing both a fn and a fp.
another case responsible for of fps are small libraries in the database that may contain very few classes often only one .
apps may contain similar small classes creating collisions that make the small library to be included in the results.
we also found a handful of cases caused by the usage of other languages in app development.
for example there are two react native apps that contain the react native runtime which is not in our database.
instead libkit identifies a particular library that contains the react native runtime.
this case is analogous to a fn fp pair but with a fn due to a library not in the database.
our analysis confirms results by zhang et al.
that identified library dependencies as one of the most challenging aspects of tpl detection.
.
rq2 comparison with state of the art we compare libkit against crios which we consider the state of the art in ios tpl detection.
the approach by tang et al.
is specific to network libraries and also requires dynamic analysis.
and the approach by chen et al.
only applies to libraries released for both android and ios.
we do not try porting any android approach to ios because most use the android specific package structure.
orlis is the only android approach that operates solely on classes but it has been shown to perform worst amongst publicly available android tools so it does not seem worth the porting effort.
crios is a clustering based approach that takes as input a set of apps and identifies groups of classes that appear together in more than one app share a name prefix and have class cohesion.
for eachtable comparison between libkit and crios for identifying the class boundaries of tpls on the gt95 apps.
all apps pure objective c apps tool prec.
recall f1 prec.
recall f1 crios .
.
.
.
.
.
libkit .
.
.
.
.
.
app it outputs the unlabeled clusters of apps where each cluster supposedly represents a tpl.
since crios does not output library names and versions the comparison focuses on the identification of the class boundaries between the tpls and the app classes.
gt95 contains the tpls in each app and the list of app classes belonging to each tpl which can be used as a reference clustering.
we can compare this reference clustering to the clustering produced by crios using external clustering validity metrics which compare the input clustering to the reference one based only on the cluster agreement without considering the cluster labels.
in particular we use a version of precision recall and f1 often used in malware clustering approaches .
other external validity metrics like rand statistic jaccard coefficient and folkes and mallows index could equally be used.
we can similarly compare libkit to the reference clustering since its output includes the list of app classes belonging to each identified tpl.
since the release of crios many changes have happened in ios which cause crios to fail on of the gt95 apps apps that contain swift and apps using newer objective c versions .
to address this issue we modified crios to replace its class dump mach o parser with the dsdump parser libkit uses.
with this fix we could run crios on all apps in gt95.
table reports the comparison results over all apps in gt95 as well as only on the pure objective c apps since crios was not designed to support swift.
the results show that libkit beats crios in both datasets in all metrics.
the recall for crios is very low as it misses swift libraries libraries that only appear in one app and classes that appear in one library version but not in another version of the same library.
when removing apps that use swift crios results improve but the f1 score of libkit remains points higher.
thus libkit clearly improves on crios for identifying tpl boundaries in an app.
furthermore libkit is able to automatically label the libraries and versions in the app.
we also run crios on the apps collected from the itunes store.
crios outputs clusters in two applications.
in one app it outputs clusters that correspond to the crashlytics firebase and answers libraries.
in the other app it outputs clusters that correspond to the fabric and admob libraries.
for the other it outputs no clusters i.e.
it does not identify any tpls.
in contrast section .
shows that on the same apps libkit identifies library versions.
the results indicate that as the number of apps increases it becomes increasingly hard for crios to identify tpls in the input apps.
.
rq3 library version identification to evaluate the detection of library versions we run libkit on the gt43 dataset using the parameter values determined in rq1.
libkit detects library versions that exactly match the oneesec fse december san francisco ca usa daniel dom nguez lvarez alejandro de la cruz alessandra gorla and juan caballero table top most prevalent libraries detected among the different library versions identified library publisher apps ver.
google mobile ads sdk google googleutilities appdelegateswizzler google fbsdkcorekit facebook promisesobjc google protobuf google crashlytics google firebaseinstanceid google googledatatransport google alamofire alamofire googleanalytics google in the gt tps and that differ from the gt fps .
it misses library versions fns .
thus the accuracy metrics for library version detection are precision of .
recall of .
and f1 score of .
.
zhang et al.
evaluated three android tools for library version identification observing that the best one was libscout with an f1 score of .
in a dataset of similar versions and .
on another dataset where versions had higher differences.
thus libkit achieves a higher f1 score on version identification than the bestperforming android tool.
.
rq4 library detection on store apps we run the library detection on the apps collected from the itunes store.
libkit detects library versions across all apps.
of those are statically linked or vendored while the remaining are frameworks.
this highlights the utility of libkit for the analysis of ios apps.
simply examining the name of the framework files in the app bundles would miss two thirds of the libraries.
in addition for the frameworks libkit is able to provide the version which is not part of the framework name.
among the detections there are unique library versions i.e.
.
of those in our db and unique library names .
of those in our db .
each app has a median of .
libraries mean of .
with an standard deviation of .
.
in apps libkit did not detect any libraries and the largest number of libraries detected in one app is .
table shows the top most prevalent libraries identified on the apps.
of those are published by google one by facebook and another one by the alamofire software foundation.
the table highlights google s efforts to have a wide presence in the ios advertisement ecosystem since ios has a mobile os market share .
the most popular library is google s admob advertising library present in apps second is the appdelegateswizzler subspec of the googleutilities library present in apps.
third comes fbsdkcorekit which allows to integrate facebook into an ios app and is found in apps.
the rightmost column in table shows that the apps contain a large number of versions for the same library.
except for googleanalytics the number of unique versions for each library ranges from in alamofire up to for admob.
given that the apps were collected within .
days this indicates that many apps were running old versions of the libraries.
one example is the documents office docs app by savy soda with .6k ratings in the italian market.
the version we crawled was .
released on august 28th .
however among the library versions libkit detects five were released between and .
for example libkit detects firebaseinstanceid .
.
which was released on two years earlier than the app release.
libkit also detects onedrivesdk a library that microsoft has recently deprecated and has not received code updates since february .
none of the recent app releases latest from february mention the deprecation of the library in their release notes.
furthermore the app only gets updates each year over the last five years and stayed .
years without an update around our collection date.
these results highlight that old library versions are common among popular apps in the itunes store and how libkit can be used to identify apps with such outdated dependencies.
runtime.
on average libkit takes minutes to detect the libraries in an app.
zhan et al.
measured the runtime of five publicly available android tpl detection tools.
compared with those libkit would be slower than libradar seconds on average per app and libscout .
minutes but faster than orlis minutes libpecker .
hours and libid .
hours .
similar to our number those numbers do not include the clustering time for libradar or the library generation time for the other tools.
note that zhan et al.
used a database of libraries and library versions for all tools except libradar.
in contrast libkit s database is times larger comprising of libraries and library versions.
this negatively affects libkit in the comparison as the detection time for all tools is at least linear on the size of the database .
related work tpl detection approaches for mobile apps can be split between clustering based approaches that infer libraries by identifying code components shared by multiple input apps e.g.
and those that build a database of library fingerprints directly from the library code e.g.
.
clustering based approaches have the advantage that they can identify previously unknown tpls but they cannot name the specific library or library version a cluster represents unless a separate mapping is built typically manually .
also they may fail to identify niche or emerging tpls.
furthermore they have been shown to have problems separating versions of the same library and identifying partially included libraries e.g.
due to dead code elimination .
to avoid those limitations our approach builds fingerprints from known libraries.
to address the problem of library database coverage we leverage the repository of the cocoapods pm unique to the ios ecosystem which allows us to build the largest library version database so far with 86k libraries versions from 14k libraries.
the majority of tpl identification approaches focus on android apps and cannot be applied to ios because they leverage the android specific package structure.
the only android tpl detection work that operates at the class level is orlis but previous work has shown orlis to perform worst amongst publicly available android tools .
a few works address tpl identification on ios apps.
crios first proposed a clustering based approach that groups classes with the same name prefix and class cohesion into libraries.
as part of their approach to identify vulnerabilities in ios network services tang et al.
proposed a clustering based technique that dynamically obtains the callstack of an app when itlibkit detecting third party libraries in ios apps esec fse december san francisco ca usa invokes the bind function and identifies the tpl wrapping bind by grouping similar callstacks.
however their approach only applies to network libraries.
a different approach was used by chen et al.
who applied tpl detection to android apps and then built constant string invariants of the android tpls to identify them in ios apps.
unfortunately their approach only applies to libraries available both in android and ios.
the limitations of clusteringbased approaches and the fact that the only android approach that could be ported to ios had low accuracy motivated us to design a novel ios tpl detection approach.
several works have proposed ios analysis techniques for other applications.
pios statically identifies the methods used by an objective c binary to detect privacy violations.
joorabchi and mesbah apply image recognition for detecting when the user interface of an ios app has changed during execution.
other works identify vulnerabilities in ios apps such as those introduced by the misuse of cryptographic apis and credentials .
other works study ios dependencies in cocoapods .
another research line compares the android and ios platforms.
some studies focus on the development model .
others compare the security and privacy features and issues of both platforms .
discussion this section discusses limitations and avenues for improvement.
fingerprint uniqueness.
library versions with the same fingerprint i.e.
same class metadata cannot be differentiated and are added to an equivalence class.
those cases are largely due to consecutive library versions with roughly two thirds due to consecutive patch level versions and another due to consecutive minor versions.
we also observe our fingerprints producing higher collisions in swift libraries compared to objective c libraries.
this is due to compiled swift code containing less information than compiled objective c code e.g.
it does not contain instance variables which are only included in our fingerprints for objective c. to make the fingerprints more unique we could add more features extracted from the binary code e.g.
from functions and variables that do not belong to classes and from the code of the methods and functions.
there are two main reasons why we left such features for our future work.
first there is limited tooling for analyzing ios native code.
popular binary analysis platforms such as angr have little support for ios and mach o binaries e.g.
to enable disassembly function identification cfg reconstruction and type inference.
we may need to implement much of that analysis ourselves a very significant endeavor on top of the work we already performed.
second some problems where code analysis would be very useful such as handling obfuscation are still not prevalent in ios i.e.
wang et al.
showed only .
of apps in the itunes store are obfuscated.
it is also worth noting that additional code features would not solve all collisions since we observe consecutive library versions with identical code where changes happen only in data files or in auxiliary code not included in the app.
database coverage.
while code analysis would help to distinguish some close library versions our results show that low recall is mostly due to limited coverage in the library version database.
this happens even if our library version database comprises 86klibrary versions seven times larger than those used in android tpl detection.
the limited coverage is due to multiple reasons including libraries not distributed through cocoapods library versions that we could not compile and limitations of the analysis e.g.
lack of support for old swift versions .
in future work we plan to increase the coverage of our library database by incorporating github projects that use other package managers like carthage and swift pm and examine if they use any libraries not present in cocoapods.
we also plan to improve our automated compilation pipeline to increase the successful compilation rate.
ground truth size.
one threat to the validity of the library version identification results is the limited size of gt43 with tpls present in open source apps.
it is possible that a larger ground truth would reveal harder cases that would lower the overall library version identification accuracy.
as explained in section building library version ground truth is painful since it requires successfully compiling the apps and manually examining their source code to identify vendored libraries.
we are releasing our ground truth to foster future work in the area and plan to explore approaches to automate the ground truth construction in future work.
conclusion we presented libkit a fully automated tpl identification tool that is the first to identify the name and version of tpls present in ios apps.
libkit supports apps developed in swift objective c or a combination of both detects statically and dynamically linked libraries and addresses the challenges of partially included libraries and that different compiler versions and configurations can produce different outputs for the same library.
libkit automatically builds fingerprints for 86k library versions available through cocoapods and matches them on the decrypted app executables.
we evaluate libkit for the problems of library identification and library version identification showing that its accuracy positively compares with the best performing android tools.
libkit also significantly outperforms crios the previous state of the art tool for ios apps for the problem of detecting tpl class boundaries in ios apps.
as future work we would like to address some of the limitations of libkit such as adding support for code written in other languages e.g.
c c strengthening the fingerprints against obfuscation by incorporating instruction level or cfg level features increasing the coverage of our library database and increasing the success rate of the compilation pipeline e.g.
by supporting older ios versions .
we would also like to perform a user study to quantify the benefits for human analysts when using libkit.