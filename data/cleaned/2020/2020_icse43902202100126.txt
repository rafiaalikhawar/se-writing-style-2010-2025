raicc revealing atypical inter component communication in android apps jordan samhi alexandre bartel y tegawend e f. bissyand e and jacques klein snt university of luxembourg firstname.lastname uni.lu ydiku university of copenhagen ab di.ku.dk abstract inter component communication icc is a key mechanism in android.
it enables developers to compose rich functionalities and explore reuse within and across apps.
unfortunately as reported by a large body of literature icc is rather complex and largely unconstrained leaving room to a lack of precision in apps modeling.
to address the challenge of tracking iccs within apps state of the art static approaches such as e picc iccta and a mandroid have focused on the documented framework icc methods e.g.
startactivity to build their approaches.
in this work we show that icc models inferred in these state of the art tools may actually be incomplete the framework provides other atypical ways of performing iccs.
to address this limitation in the state of the art we propose raicc a static approach for modeling new icc links and thus boosting previous analysis tasks such as icc vulnerability detection privacy leaks detection malware detection etc.
we have evaluated raicc on benchmark apps demonstrating that it improves the precision and recall of uncovered leaks in state of the art tools.
we have also performed a large empirical investigation showing that atypical icc methods are largely used in android apps although not necessarily for data transfer.
we also show that raicc increases the number of icc links found by .
on a dataset of real world malicious apps and that raicc enables the detection of new icc vulnerabilities.
index terms static analysis android security i. i ntroduction android apps heavily rely on the inter component communication icc mechanism to implement a variety of interactions such as sharing data triggering the switch between ui components or asynchronously controlling the execution of background tasks.
given its importance the research community has taken a particular interest in icc reporting on various studies that show how icc can be exploited in malicious scenarios icc can be leveraged to easily connect malicious payload to a benign app leak private data or perform app collusion .
these scenarios are generally executed by passing intent objects which carry the data and information about explicitly implicitly targeted components .
tracking information across intents to link components that may be connected via icc thus becomes an important challenge for the analysis of android apps.
the resolution of icc links identification of the source and target components type of the components etc.
is a wellstudied topic in the literature.
approaches such as epicc coal ic3 sparta or droidra have contributed with analysis building blocks in this respect.
the icc links also called icc models generated by these tools are key and even mandatory for several android app analysistasks.
in the case of data flow analysis icc poses an important challenge in the community icc indeed introduces a discontinuity in the flow of the analysis since there is no direct call to the target component life cycle methods in the super graph aggregation of control flow graphs of caller and callee methods in the absence of a single main method .
several tool supported approaches such as a mandroid iccta and d roid safe have been proposed in the literature to cope with this issue.
to overcome the discontinuity in the flow of the analysis all these three tools rely on an inferred icc model to identify the target component and the icc methods in order to artificially connect components.
in the case of android malware detection a tool such as iccd etector leverages the icc model generated by epicc to derive icc specific features that are used to produce a machine learning model in order to detect new type of android malware.
in the case of vulnerability detection epicc leverages its own icc model to detect icc vulnerabilities defined in as the sending an intent that may be intercepted by a malicious component or when legitimate app components e.g.
a component sending sms messages are activated via malicious intent.
in all these cases the proposed tools rely on a comprehensive modeling of the icc links.
however a major limitation in icc resolution relates to the fact that state of the art approaches consider only well documented icc methods such asstartactivity .
indeed we have discovered that several methods from the android framework can also be used to implement icc although the official android documentation does not specifically discuss it .
actually icc can also be performed by leveraging android objects e.g.
pendingintent orintentsender that have been little studied in the literature and through framework methods that can atypically be used to launch other components.
we have initially observed an atypical icc implementation during the manual reverse engineering of an android app that we identified as part of research on logic bomb detection.
this app uses the method set int long pendingintent of the alarmmanager class for triggering a broadcastreceiver which in turn is used to launch aservice component.
such an implementation appeared suspicious since it seems artificially complex it is possible to directly call the sendbroadcast method instead of leveraging an alarmmanager.
we further performed extensive investigations and found that several dozens of methods of ieee acm 43rd international conference on software engineering icse .
ieee the android framework can atypically start a component with objects of type pendingintent and or intentsender .
we use the term atypical to reflect the fact that according to the method definitions their role is not primarily to start a component as icc methods typically do but to perform some action e.g.
set an alarm or send an sms .
unfortunately with such possibilities an attacker could rely on such methods to perform icc related malicious actions.
existing state ofthe art approaches because they do not account for atypical methods in their models would miss detecting such icc links.
our work explores the prevalence of atypical icc aicc methods in the android framework as well as their usages in android apps.
we then propose an approach for resolving those aicc methods and an instrumentation based framework to support state of the art tools in their analysis of icc.
in summary we present the following contributions we present findings of a large empirical study on the use of aicc methods in malicious and benign apps.
we propose a tool supported approach named raicc for resolving aicc methods using code instrumentations in order to generate a new apk with standard icc methods.
we demonstrate that this instrumentation boosts state of the art tools in various android analysis tasks.
we improve d roid bench with new apps using aicc methods for assessing data leak detection tools.
the rest of the paper is organized as follows.
first we present how state of the art performs with icc in section ii.
then in section iii we give an example and explain why we are studying atypical inter component communication.
in section iv we detail raicc our tool supported approach.
we evaluate raicc and present our results in section v. in section vi we present the limitations of the approach.
finally we discuss the related work in section vii and conclude in section viii.
ii.
h ow do state of the art analyzers handle icc?
android apps are composed of components that are bridged together through the icc mechanism.
the activity component implements the ui visible to users while service components run background tasks and content provider components expose shared databases.
an app may also include a broadcast receiver component to be notified of system events.
the manifest file generally enumerates these components with the relevant permission requests.
components are activated by calling relevant icc methods provided in the android framework.
these icc methods are also used to pass data through an intent object which may explicitly target a specific component or may implicitly refer to all components that have been declared through intent filters capable of performing the intent actions.
the icc mechanism challenges static analysis of apps.
indeed consider listing in which the mainactivity component launches the targetactivity component.
the discontinuity in the control flow is clear since there is no direct method call between mainactivity andtargetactivity .
off the shelf java static analyzers that analyze normal1public class mainactivity extends activity protected void oncreate bundle b ... intent i new intent this targetactivity .class this .startactivity i 7public class targetactivity extends activity protected void oncreate bundle b listing an example of how icc is performed between two components.
method calls would not be able to detect the link between the icc method startactivity and the targetactivity component.
hence if a data flow analysis is performed none of the data flow values can be propagated correctly.
this is since icc methods trigger internal android system mechanisms which redirect the call to the specified component.
therefore android static analyzers have to preprocess the application in order to add explicit method calls.
that is what state of the art tools like i ccta d roid safe and a man droid do with different techniques.
if we take the example of i ccta it first relies on ic3 to infer the icc links.
among other information ic3 identifies the icc methods e.g.
startactivity in listing and resolves the target components e.g.
targetactivity in listing .
then i ccta replaces any icc method call with a direct method call that passes the correct intent .
thus the discontinuity disappears and the link to the target component is directly available in the super graph see figure of iccta paper .
the idea that we reuse in this paper is the code instrumentation that allows preprocessing an app for constructing the missing links to be processed by any analysis.
nevertheless in this paper we will see that state of theart approaches only rely on well documented methods for performing inter component communication.
we aim at improving their precision by revealing previously un modeled icc links.
iii.
a typical icc m ethods static analysis of android applications is challenging due to the specificity of the android system s inter component communication icc mechanism.
therefore as we have overviewed in section ii researchers have to come up with approaches for considering and resolving icc.
in this section we show that one developer can perform atypical icc by taking advantage of specific methods of the android framework.
we define an atypical icc method aicc method as a method allowing to perform an inter component communication while it is not its primary purpose.
these aicc methods rely on pendingintents andintentsenders .
pendingintents objects are wrappers for intents .
they can only be generated from existing intents and describe those latter.
they can be passed to different components and especially to different applications.
when so the receiving app is granted the right to perform the action described in thependingintent with the same permissions and identity of the source app.
this introduces a security threat in which a component could perform an action for which it does not have the permission but it is granted this latter through the 1399pendingintent .
this security threat has been studied by gro et al.
.
an important fact is that pendingintents are maintained by the system and represent a copy of the original data used to create it.
the pendingintents can thus still be used if the original app is killed.
intentsenders objects are encapsulated into pendingintents .
they can be retrieved from a pendingintent object via the method getintentsender .
basically they can be used the same way than pendingintents and represent the same artifact.
the abstract representation of aicc methods is shown in figure .
the upper part of the figure shows how standard icc methods behave.
they communicate with the android system viaintents to execute another component.
the lower part represents how aicc methods behave.
they perform the action they are meant to do through the android system and at the same time the pendingintent or the intentsender is registered in a token list in the android system .
the action may or may not influence the decision for the system to launch the component depending on the aicc method.
for example a pendingintent could only be launched in case of the success of the action.
also the android system can receive a cancellation of a token from the app.
e.g.
cancel an alarm .
in that case the target component would not be launched.
the tokens represent the original data used for generating apendingintent or an intentsender .
it means that if the application modifies the intent used to construct the pendingintent it does not affect the token as it is a copy of the original data.
more importantly if the application is killed the list is maintained in the android framework and the components can still be executed.
iccm android system target component aiccm action android systemtarget component list of tokensintent intent pendingintent intentsenderintent fig.
difference between normal icc method and aicc method.
tokens represent pendingintents andintentsenders .
action represents the primary purpose of the aicc method e.g.
send an sms .
an action might influence the list of tokens in the android system which will later process the list and send intents .
the dotted line indicates that the triggering of the target component may depend on the result of an action.
a concrete example as described in section i while manually analyzing a malicious application we noticed that it used the alarmmanager for performing icc.
the interesting piece of code of this malicious app is presented in listing .
we can see a pendingintent created from anintent targeting the component alarmlistener .
the latter simply launches the service component responsible for retrieving external commands via http.
for launching the class alarmlistener the developer could haveused the method sendbroadcast alarmlistener extends broadcastreceiver but instead it used the aicc method set int long pendingintent .
1public void reconnectionattempts calendar cal calendar .getinstance cal.add this .elapsedtime intent i new intent this alarmlistener .class intent .putextra alarm message wake up dude !
pendingintent pi pendingintent .getbroadcast this i !
alarmmanager am alarmmanager getsystemservice alarm !
am.set cal.gettimeinmillis pi listing a simplified example of how the method set of thealarmmanager class is used in a malware.
when we focus more on the way pendingintent works we understand why the developer used this technique.
indeed in this example the alarm is set up to go off after or minutes.
but what happens if the user closes the app before it goes off?
in fact the alarm will go off anyway and execute the target component.
this is due to the fact that when setting an alarm the pendingintent is maintained by the android system until it goes off or gets canceled.
we can see the power of such a method to perform icc.
it could be used in different scenarios by an attacker to perform its malicious activities.
furthermore aicc methods carry information in intent objects that are also embedded in pendingintent or intentsender objects.
therefore they can carry different types of information leading to potential sensitive data leaks.
our benchmark includes examples scenarios for such leaks.
iv.
a pproach in this paper we aim at resolving those aicc methods through app instrumentation .
the goal for the new app is to be analyzable by state of the art android static analyzers.
we first introduce in section iv a how we gather a comprehensive list of aicc methods.
then in section iv b we describe how we leveraged this list of methods to improve the detection of inter component communications leading to the increase of precision metrics of existing android specific static analyzers.
a. list of atypical icc methods as explained in previous sections during the reverseengineering of android applications we stumbled upon a malicious app making the use of the set method of the alarmmanager class with a pendingintent as parameter to stealthy perform an icc in this case to start a broadcastreceiver .
thanks to this example we realized that intent and method such as startactivity are not the only main starting points of icc other objects e.g.
pendingintent and other methods e.g.
alarmmanager.set can play a similar role.
motivated by this discovery we were eager to check if this atypical mechanism is restricted to this set method and this pendingintent object.
in other words are there other atypical methods in the android framework?
are there other classes such as pendingintent ?
to answer these 1400questions we performed a comprehensive analysis of the android framework.
we retrieved from the android framework from sdk version to versions and being unavailable all the methods that take as a parameter an object of type pendingintent .
we obtained a list of unique methods.
the next step was to manually analyze all of them in order to only keep those allowing to perform icc.
the list reduced to methods indeed some methods have a pendingintent as a parameter but cannot perform icc e.g.
android.bluetooth.le.bluetoothlescanner.stopscan pendingintent .
to identify classes similar to pendingintent we followed a simple heuristic.
we search for all class names containing the string intent .
this search yielded classes that we manually checked.
finally we identified one new class intentsender which according to the android documentation has the same purpose as pendingintent .
we scanned again the android framework to retrieve all the methods that take as a parameter an object of type intentsender and we discovered new methods for performing atypical inter component communication.
to improve the confidence in our list of aicc methods we performed further analyses.
in particular we downloaded the source code of android and studied the implementation of some of the aicc methods we gathered.
this approach aimed at finding patterns that we used to find similar usage in the android framework we assumed that other aicc methods use the same patterns.
we also made some assumptions e.g.
considering the subclasses of those studied.
unfortunately we were not able to uncover additional aicc methods.
at this stage our list reached a length of methods.
it was all without counting the methods of pendingintent andintentsender classes that directly allow launching a component.
for example the send method of the pendingintent class allows to directly communicate with a targeted component likewise for method sendintent of class intentsender .
finally our list reached methods.
in listing we illustrate the usage of four aicc methods chosen for their brevity .
on the first lines objects necessary to the aicc methods are instantiated.
an intent is instantiated at line .
at lines a sensitive information the device unique identifier is retrieved and stored in the imei variable.
at line the imei is added as an extra information in the intent.
at line the pendingintent is instantiated with the intent containing the imei.
then from line we present four ways of launching the targetactivity component through aicc methods.
we gathered a comprehensive list of methods called aicc methods allowing to perform atypical intercomponent communication.1public class mainactivity extends activity override protected void oncreate bundle b ... intent i new intent this targetactivity .class telephonymanager tm telephonymanager getsystemservice context .telephony service !
string imei tm.getdeviceid i.putextra sensitivedata imei pendingintent pi pendingintent .getactivity this i !
.a pi.send .a intentsender s pi.getintentsender .b s.sendintent this null null null .a alarmmanager am alarmmanager getsystemservice alarm !
.b am.setexact system .currenttimemillis pi !
.a locationmanager l locationmanager getsystemservice location !
.b l.requestlocationupdates new criteria pi !
listing examples of how aicc methods inyellow can be used to perform inter component communication.
b. tool design general idea the o vervie w of our open source tool called raicc is depicted in figure .
the general idea is to instrument a given android app to boost it by making it aware of icc links.
for instance if apendingintent is used with an aicc method to start an acti vity raicc will instrument the app s source code by adding a method startactivity with the right intent as parameter .
this method is added at a point of interest in the app i.e.
just after the aicc method call.
toperform this instrumentation raicc needs to infer the possible v alues targets of icc objects e.g.
intent resolve the type of the target component in order to instrument with the right standard icc methods e.g.
startactivity if the target component is an activity startservice if the target component is a service etc.
.
transform into jimple2 infer tar get component types collect intents5 new apk generated4 code instrumentation fig.
overvie w of our open source tool r aicc.
concrete example weillustrate the result of our approach with listing .
it sho ws the transformation that the jimplecode under goes sho wn as java code for readability .
the aicc method program point of interest appears at line .
after inferring the tar get component type wi th the help of coal ic3 raiccgenerates a new standard icc method call right after the aicc method i.e.
at line corresponding to this type i.e.
startactivity .
indeed thependingintent has been generated with the method getactivity thus the tar get component type in the inferred values is defined as a incoal ic3 i.e.
activity .
also 1401raicc is able to recover the intent used to create the pendingintent for using it as a parameter for the new standard icc method call.
intent i new intent this targetactivity .class pendingintent p pendingintent .getactivity this i !
locationmanager l locationmanager getsystemservice location !
criteria c new criteria program point of interest l.requestsingleupdate l.getbestprovider c false p startactivity i listing how raicc would instrument an app.
lines with represent added lines details of each step involved in raicc step the app is transformed into jimple the internal representation of the soot framework using dexpler .
step raicc leverages ic3 which is able to infer all possible values of icc objects using composite constant propagation at specific program points.
to this end we created model files using the coal declarative language to query each of the aicc methods during program analysis and retrieve the values of the parameters we need i.e.
pendingintent andintentsender .
given that they are built from intent objects ic3 is able to identify all subparts which compose the objects e.g.
action category extras uri etc.
.
the most important artifact for our instrumentation is the types of potential target components.
it is inferred by coal given its specification i.e.
it is able to get the target component type by recognizing methods for creating pendingintents e.g.
getactivity .
indeed one can easily see the difference between a conventional icc method and an aicc method standard icc methods explicitly describe the type of component that will be launched e.g.
startactivity for an activity startservice for a service sendbroadcast for broadcastreceiver etc.
whereas with aicc method we cannot statically directly know the type of those components e.g.
the signature of theset method gives no information about the type of the target component and it is the same for most of the aicc methods such as sendtextmessage requestlocationupdates etc.
.
depending on the control flow of the program during execution the target component can change hence its type too.
consequently we have to take into account all possible types for different components.
the main idea of our instrumentation approach is to add as many new standard icc method calls as there are target components types and intent objects for creating pendingintent andintentsender right after the program points of interest.
the type is represented by a single character in the coal specification for a given class.
for example the target type of a pendingintent can take the following values a for an activity r for a broadcastreceiver and s for a service .
step after retrieving the possible target component types of the aicc methods raicc has to recover the right intent that has been used for creating the pendingintent or the intentsender which will be the parameter of the generatedstandard icc method s .
to tackle this issue raicc first recovers the pendingintent orintentsender reference used in the aicc method.
note that it can be used as a parameter in the aicc method e.g.
sendtextmessage or as the caller object e.g.
send we annotated each aicc method for having this information and in the case it is a parameter the index in the list of parameters.
afterwards raicc interprocedurally searches for the intent used for creating the pendingintent .
in the case of intentsender raicc interprocedurally searches for the pendingintent then recursively apply the previous process for retrieving the intent .
of course different intent objects could be used in the code not shown in listing .
therefore for correctly propagating the context information among components for further analysis they should all be taken into account as raicc does.
step at this point for each point of interest aicc method raicc leverages the list of potential target component type and the list of potential intents .
the source code modification of the app to explicitly set the icc methods is straightforward.
after each aicc method raicc generates as many invoke statements as there are combinations of potential target types and potential intents recovered.
the new generated invoke statements will depend on the type s inferred at step i.e.
startactivity for a startservice for s andsendbroadcast for r .
intent objects are used as parameters of the new method calls.
note that some of the aicc methods likewise startactivityforresult expect a result returned if the target component type is an activity .
we have carefully annotated the corresponding aicc methods therefore raicc generates the right method call in this case i.e.
startactivityforresult .
step finally raicc packages the newly generated application and any existing tool dealing with standard icc methods can be used to perform further static analysis.
note that although instrumentation can lead to non runnable apps in this study apps are not meant to be executed after being processed by raicc.
indeed raicc acts as a preprocessor for other static analyses.
v. e valuation we address the following research questions rq1 do aicc methods deserve attention?
in other words are aicc methods often used in android apps?
rq2 are aicc methods new in the android ecosystem?
rq3 can raicc boost the precision of icc based data leak detectors on benchmark apps?
rq4 does raicc reveal previously undetected icc links in real world apps?
if so are these newly detected icc links security sensitive?
rq5 what are the runtime performance and the overhead introduced by raicc?
1402a.
atypical icc methods deserve attention in section iv a we described how we build a list of atypical icc methods .
we used this list to conduct empirical analyses assessing the use of aicc methods in the wild.
in a first study we randomly selected malicious apps and benign apps from the androzoo dataset .
for qualifying the maliciousness of the apps we used the virustotal score number of antivirus products that flag an app as malicious available in the metadata of the app in androzoo.
every app of our malicious set has a virustotal score strictly greater than those from the benign have a score equal to .
library code vs. developer code it has been shown than libraries present in android apps can seriously impact empirical investigation performed on android apps.
indeed code related to libraries is often larger than the code written by the developers of the apps.
for this reason in this study we perform two experiments we count the number of aicc methods present in each collected app by considering the entire code i.e.
including library code we count the number of aicc methods only present in the developer code.
in practice to exclude library code we rely on soot which can discard third party libraries from a given list in our experiments we use the list from and system classes with simple heuristics e.g.
discard if the signature starts with androidx.
or org.w3c.dom.
etc.
table i shows our findings.
we can see that among the benign apps considering only the developer code apps use at least one aicc method and overall aicc methods are used.
if we take into account the libraries it is no less than apps using in total aicc methods.
clearly in benign apps the large majority of aicc methods are leveraged by libraries.
in the malicious set we face a different situation.
the reported figures considering libraries or not are much closer.
finally if we compare both datasets we note that overall benign apps tend to use much more aicc methods than malicious apps but when considering only the code written by the developers of the apps the situation is reversed i.e.
developers use much more aicc methods in malicious apps than in benign apps.
without libs with libs dataset aiccm apps ratioy aiccm apps ratioy 50k benign12422624884 app app 50k malicious40246834710 app app ythe ratio is computed by considering apps with at least one aicc method.
table i number of apps using at least one aicc method in different datasets aiccm aicc method .
table ii presents for both datasets the top used aicc methods in developer code excluding libraries .
we notice common aicc methods in this table i.e.
set setrepeating andsetlatesteventinfo .
regarding the malicious apps we can see that the methods from the class smsmanager are present twice.
it could be explained by the fact that malicious apps tend to activate components via sms.
we also note that method setlatesteventinfo isused an order of magnitude more than all other methods.
this method is actually related to the notification mechanism of android.
we postulate that malicious apps tend to be much more aggressive in terms of notifications and advertisements resulting in a high number of usages of this method.
methods counts benigns android.app.alarmmanager .set android.widget.remotev iews.setonclickpendingintent android.app.notification.setlatestev entinfo android.app.alarmmanager .setrepeating android.app.acti vity.startintentsenderforresult malicious android.app.notification.setlatestev entinfo android.app.alarmmanager .set android.telephon y.smsmanager.sendtextmessage android.app.alarmmanager .setrepeating android.telephon y.smsmanager.senddatamessage table ii most used atypical icc methods in benign malicious android apps without considering libraries.
number of occurences aicc methods names omitted of occurence of each aicc method in benign set of occurence of each aicc method in malicious set fig.
occurence of aicc methods in benign and malicious applications excluding libraries finally figure presents the number of usages of each of the aicc methods in the developer code in both benign and malicious datasets.
for each dataset the methods are ranked by their number of occurrences.
for the sake of readability we have truncated the first two bars of the malicious datasets.
indeed as shown in table ii the number of occurrence of the top methods are 238k 53k and 39k respectively.
thanks to figure we note that only a fraction of the aicc methods is largely used by developers methods are even not used at all malicious developers tend to use a less diverse set of aicc methods but the aicc methods that are used are more frequently used.
rq1 answer aicc methods are prevalent in android apps and thus definitely deserve attention.
they are used in both malicious and benign apps but significantly more by malicious developers.
only a fraction of the aicc methods are regularly used.
b.atypical icc methods e xist since the be ginning tothe best of our knowledge state of the art approaches do not consider aicc methods.
one of the reasons could be the fact that aicc methods ha veonly been introduced recently in the android frame work.
tovalidate this h ypothesis we further check the use of aicc methods o vertime.
f or this purpose we considered sets of benign apps from androzoo ordered by the creation date of the dex file and sets of malicious apps.
androzoo only contains a few 1403malicious apps from and no malicious app from .
thus the malicious set is reduced compared to the benign one and there is no malicious set.
the sets their content and the results of the analyses are provided in table iii.
first overall these results confirm the results of table i. for instance in benign apps aicc methods are mostly used in libraries.
malicious developers still use more aicc methods in their code even if the difference between with or without libraries is less pronounced.
regarding temporal evolution we note that in both datasets the metrics are pretty stable except maybe in malicious set which seems to be an outlier weak ratio and high of number of apps .
this could be explained by the low number of apps collected for .
withtout libs with libs dataset aiccm apps ratioy aiccm apps ratioy benign sets app app app app app app app app app app malicious sets app app app app app app app app ythe ratio is computed by considering apps with at least one aicc method.
table iii temporal evolution of the usage of aicc methods in benign and malicious apps.
to deepen our investigation about temporal evolution we also study the introduction time of the aicc methods.
to that end we count the number of aicc methods introduced in each android api level.
the results are presented in figure .
new aicc methods have been added at almost each api level often between and per api level .
we can see two peaks one at api level corresponding to the creation of the android framework and one at api level corresponding to the introduction of androidx a new set of android libraries.
it is noteworthy that only two aicc methods have been removed from the android framework.
20number of methods api level of new methods per api among our set of methods fig.
api levels in which aicc methods have been added.
rq2 answer aicc methods are not new in the android framework they indeed exist since the very beginning.
c.precision impro vement after applying raicc rq3 aims at in vestig ating the efficienc y of state of theart icc data leak detector i cctaand a mandroidafter applying r aicc.
to do so we launched the tools before and after e xecuting raicc ag ainst new apps that we plan to integrate into d roidbench an open test suite containingmore than hand crafted android apps for e valuating the efficienc y of taint analyzers.
d roidbenchis used as a ground truth by the research community in order to assess the efficienc y ofstatic and dynamic analyzers.
it contains different types of leaks e.g.
intra component inter component inter app etc.
howe ver among the icc leaks none of them uses aicc methods.
thus our idea is to extend d roidbench with additional test cases focusing on icc leaks concrete application of taint tracking performed via aicc methods.
note that to detect false positi ves we included apps without leak among the apps i.e.
only apps contain a leak .
benchmark construction todevelop those apps we considered the most representati veaicc methods for both malicious and benign apps identified in section v a. more specifically we considered the top aicc methods in terms of occurrences in both datasets leading to aicc methods duplicates .
wealso randomly picked additional aicc methods to reach the final number of aicc methods aicc methods ha vebeen used twice which represent .
and .
of the aicc methods occurrences in our datasets of benign apps and malicious apps respectiv ely.
the implementation of most of our bench apps was straightforward as well as the triggering of the under lying inter component communication.
excerpts of such bench apps are similar to the ones presented in listing .
howe ver some aicc methods have required more sophisticated code e.g.
those manipulating notification objects for instance theaddaction aicc method.
another e xample of more comple x bench app is related to the aicc method setonclickpendingintent of the android.widget.remoteviews class.
the pendingintent set as parameter of this method is triggered after the user clicks on a widget appearing in the home screen of the device.
the widget declared in the androidmanifest.xml file has to be insta lled on the home screen before the user can click on it to trigger the tar get component.
note that beside de veloping applications using aicc methods we combine multiple aspects of the w ay icc can be performed.
f or example in several apps we considered the data flo w within three dif ferent components or a data flo w looping back into the first component to check the beha vior or r aicc.
table iv lists the bench apps.
forthe sak e of space we cannot gi vemore details about this benchmark b ut we invite the interested reader to refer to the project repository1which contains the source code of each bench app.
results table iv sho ws the results of our e xperiment.
since icctaand a mandroidare not designed to detect icc data leaks via aicc methods it is not surprising to see that the y performs v ery badly without applying raicc precision and recall of .
indeed icctaand a mandroidare not able to construct the links between the components for the rustworth y software raicc ?
true positive ?
false positive false negative c components ui user interaction test case c. leak ui iccta amandr oid sendt extmessage1 ?
?
setsenddatamessage ?
?
sendt extmessage2 ?
?
addaction1 ?
?
addaction2 ?
?
requestnetw ork ?
?
requestlocationupdates ?
?
startintentsenderf orresult ?
send ?
sendintent setrepeating ?
?
setonclickpendingintent ?
?
setlatestev entinfo ?
?
setine xactrepeating ?
?
setexact ?
?
setexactandallo wwhileidle ?
?
setw indow ?
?
setdeleteintent ?
?
setfullscreenintent ?
?
setpendingintentt emplate ?
?
sum precision recall ?
higher is better ?
lower is better lower is better precision p ?
?
?
.
.
recall r ?
?
.
f1 score 2pr p r .
.
table iv additional d roid bench apps and results of applying i ccta and amandroid before and after raicc.
a more complete table is available in the supplementary material document.
apps containing a leak.
however for the apps which do not contain any leak they do not raise any alarm as expected.
after instrumenting the apps with raicc the performance of i ccta and a mandroid is improved.
they can reveal and construct previously hidden icc enabling the detection of the leaks present in this benchmark.
regarding i ccta it is able to reveal all the leaks after applying raicc.
however we can see false positives.
the first one in app sendtextmessage2 is due to i ccta which cannot correctly parse extra keys added into intent objects cf.
startactivity7 of d r o i d be n c h .
the second one is due to raicc which cannot for the moment differentiate atypical inter component communication made asynchronously.
what we mean is that in addaction2 the notification is never shown to the user hence the component targeted by the pendingintent will not be executed through the notification.
therefore the leak cannot happen during execution.
even if declaring a notification and not showing it to the user is not likely to happen in practice it is a good example to show that modeling an app behavior is not trivial and demands more effort for certain methods.
we can notice that i ccta behaves correctly with apps send and sendintent by not raising an alarm.
amandroid performance is also boosted.
indeed it can reveal almost all the leaks false negative .
we can notice that the same false positives appears for i ccta and a mandroid for apps sendtextmessage2 and addaction2 .
a man droid reveals an additional false positive for app send .
as a result the precision of i ccta combined with raicc reaches .
true positives and false positives and its recall true positives and false negative .
as for amandroid combined with raicc its precision reaches .
true positives and false positives and its recall93.
true positives and false negative .
i cctaf1score reaches .
and a mandroid .
.
rq3 answer raicc boosts both the precision and the recall of state of the art data leak detectors.
d.experimental r esults on real world apps in this section we first in vestig ate to what e xtent r aicc discov ers pre viously undetected icc links in real w orld apps.
then we perform tw o checks on these newly detected icc links we check if the y are used to transfer data across components or even to perform some privacyleaks we check if they lead to icc vulnerabilities.
re vealing ne w icc links in this section we study the capacity of raicc in revealing ne w icc links in real world apps.
t o that end we extract from androzoo two datasets of5000 randomly selected apps containing respectiv ely only benign and malicious apps.
then for each app we count the number of icc links discov ered without raicc by relying on the results yielded by i c3 as well as the number of additional icc links disco vered by r aicc.
note that we only consider the developer code in this study i.e.
we e xclude the libraries .
t able v presents our results.
ic3 raicc increase component types counts counts benign set activity broadcastrecei ver service total malicious set activity broadcastrecei ver service total table v number of icc links resolved by ic3and number of additional icc links discov ered by raicc.
among benign apps new icc links were revealed by r aicc corresponding to an increase of more than in comparison with ic3.the most used tar get component type is activity with of the new links.
ho wever while for ic3 the large majority of icc links are related to activity the distribution among the types of component is more balanced with raicc.as re gards to malicious apps while the number if icc links revealed by ic3 is relativ ely close to the number of icc links re vealed in the benign dataset vs. the number of icc links revealed by raicc is much higher almost twice as much as benign apps vs. .
ov erall r aiccincreases the number of icc links by in malicious apps.
all three types of components are impacted by raicc.
howe ver the increase of the number of icc links is impressiv e forbroadcastreceiver for benign apps and almost for malicious apps.
this suggests that developers tend to use aicc methods m ore than traditional icc methods to broadcast an e vent.
through manual inspection we indeed notice that for instance an aicc method attached to an alarm is often used to trigger abroadcastreceiver .
1405finally note that we also randomly picked benign and malicious apps to manually verify if raicc had correctly instrumented the real world apps.
the standard icc methods are correctly added right after the aicc methods allowing other tools to correctly model icc.
atypical icc methods are largely used in real world apps although not to transfer or leak data for this study we only consider a set of malicious apps the underlying intuition is that malicious apps tend to leak more data than benign apps .
we first run raicc on this dataset to resolve the atypical icc links and then we leverage i ccta to perform the detection of icc leaks i ccta uses a set of well defined sources i.e.
sensitive information and sinks to perform the detection .
overall i ccta was able to detect intracomponent data leaks i.e.
leaks inside a single method and icc data leaks.
we manually inspect all icc data leaks to check if the data is transferred via aicc methods or standard icc methods such as startactivity .
we did not find a single case where sensitive information is leaked via aicc methods.
we manually analyzed apps to verify how aicc methods were used.
in the majority of cases the target component is used likewise a callback method i.e.
this mechanism is used to activate a given component.
actually when data is put inside the intent used for constructing the pendingintent or the intentsender it is generally non sensitive data most of the time simple constants .
let us consider a concrete example for instance the m1 trafik app from the google playstore.
in method setalarm of class com.m1 trafik.alarmmanagerbroadcastreceiver an intent is created with an extra value representing the boolean false value.
information attached to this intent also informs us that the target component is the current class itself i.e.
the class alarmmanagerbroadcastreceiver .
apendingintent is then retrieved from this intent using method getbroadcast .
afterwards the aicc method setrepeating of class alarmmanager is leveraged for setting an alarm.
when this alarm goes off the method onreceive of the target component in our case the same class is executed.
when analyzing this method we can see no use of the extra value put in the intent .
when applying raicc we can see the new method call sendbroadcast right after the call to setrepeating .
although it helps i ccta constructing the link between the components the data transferred is not sensitive.
in this example we see that aicc methods are mostly used to leverage the powerful token mechanism explained in section iii i.e.
the target component will be launched even if the application is closed.
raicc epicc revealing new icc vulnerabilities epicc is a state of the art icc links resolver able to detect icc vulnerabilities.
such vulnerabilities are defined by chin et al.
in .
examples include when an app sends an intent that may be intercepted by a malicious component or when legitimate app components e.g.
a component sending sms messages are activated via malicious intent .
inthis section we aim at showing that raicc boosts epicc by enabling the detection of previously unnoticed icc vulnerabilities.
to this end we considered a dataset of randomly selected benign apps and a dataset of randomly selected malicious apps.
we ran epicc on those two datasets before and after applying raicc results are available in table vi.
benign apps malicious apps before raicc after raicc impro vement .
.
table vi number of icc vulnerabilities found by epicc before and after applying raicc besides the significant difference between benign and malicious apps we can see that after applying raicc i.e.
modeling previously unrevealed icc links epicc is able to detect more icc vulnerabilities with an increase of .
for benign apps and .
for malicious apps.
this experiment shows that raicc boosts state of the art tool epicc by modeling new icc links and revealing new icc vulnerabilities.
rq4 answer raicc significantly increases the number of resolved icc links in real world apps compared to the state of the art approach.
while aicc methods seem to not be used to leak sensitive information they are used to activate components and thus potentially trigger malicious payloads .
raicc boosts epicc by allowing to reveal new icc vulnerabilities.
e.runtime performance ofraicc in this section we evaluate the runtime performance of raicc.wealso e valuate the o verhead introduced by our tool by considering a typical usage of raicc for instance when raicc is used to boost the results of iccta.
since iccta leverages itself ic3 we in vestig ate the runtime performance of ic3and i cctabefore and after applying raicc on the benchmark apps used in section v c. the results are presented in figure .
first we can see that the r aiccexecution time does not exceed seconds.
since raicc allo ws i c3and i cctato resolv e more additional icc links we e xpect that the analysis time of both tools will increase.
w e indeed note that the tw o box plots on the right are higher confirming the overhead caused by r aicc.
on average the overheads for ic3 and icctaare13 3seconds and 10seconds respecti vely and overhead respectiv ely .
raicc ic3 iccta r ic3 r icctatime s raicc ic3 iccta r ic3 r icctatime s fig.
runtime performance of raicc ic3 and iccta with r means with r aicc and without aiccm preprocessing.
left on droidbench right in the wild .
1406to confirm the results obtained on the benchmark apps we perform the same study but on a set of real world apps.
the results are reported in figure .
overall we can see that the performances in time reported on both figures are quite similar.
however slight differences can be noticed.
first the runtime values are more scattered in figure than with the benchmark apps.
this could be explained by the fact that real world apps are more diverse.
second the average performances of the three tools are closer.
regarding the overhead introduced by raicc we again notice that this overhead exists.
this is expected since the constant propagation of ic3 has to process more values methods.
likewise i ccta has to build more links and to consider more paths for the taint analysis.
on this dataset on average the overheads for ic3 and i ccta are 8seconds and 8seconds respectively and overhead respectively .
rq5 answer the runtime performance of raicc is higher than ic3 and i ccta but still in the same order of magnitude.
on average raicc requires less than minutes to analyze and instrument a real world application.
vi.limitations the core component of our approach liesin the list of aicc methods that we compiled during our research.
ev en though we follo wed a systematic approach for retrie ving a maximum of aicc methods we might ha vemissed some of them in the android framew ork.
there are potentially other w ays to perform such icc ne vertheless our study is reproducible and provides insight for future research in this direction.
by le veraging ic3 to infer the values of icc objects raicc inherits the limitations of ic3.
moreov er like most of the static analysis approaches r aiccis subject to falsepositiv es.
currently raicc does not handle nati vecalls reflectiv e calls nor dynamic class loading though some stateof the art approach could be integrated .
besides although inter app communication iac is performed using the same mechanisms as icc we did not in vestig ate in this direction.
furthermore obfuscation is aconfounding f actor impacting studies based on apks .
therefore r aicc seffectiveness is impacted by obfuscated code especially if aicc method calls are disguised e.g.
using reflection .
vii.relatedwork tothe best of our knowledge we ha vepresented the first approach taking into account aicc methods for connecting android components.
howe ver as explained in a systematic literature re view the research literature has proposed a large body of works focusing on statically analyzing android apps.
one of the most popular topics is the use of static analysis for checking security properties and in particular for checking data leaks.
the pioneer tools such as flowdroid scandal and others ha vestarted to focus on the detection of intra component data leaks.
they all face the limitations of not being able to detect icc leaks.several approaches have been developed to perform data leak detection between components.
wewill present these approaches in the follo wing.
iccta le verages ic3 to identify icc methods and theirs parameters and then instruments the app by matching and connecting icc methods with their tar get components.
the identification of icc methods and the instrumentation part rely on a list of icc methods that only contain well documented icc methods .
by considering additional icc methods i.e.
aicc methods our tool complements a tool s uch as iccta.
in the same way droidsafe transforms icc calls into appropriate method calls to the destination component.
likewise i ccta the icc methods considered by d roidsafeare only the well documented icc methods.
as a result both d roidsafe and i ccta share the same limitation i.e.
the y miss the aicc methods.
unlike the pre viously described tools amandroid constructs an inter component data flow graph idfg and a data dependence graph ddg in which it can run its analysis.
ag ain it only considers documented icc methods manipulating intents .
other tools leverage icc links to detect malicious apps.
iccdetector for instance uses machine learning ml to detect android malw are.
the ml model is built by using icc related features e xtracted with epicc .
as it relies on epicc to extract icc features it is dependent on epicc for the considered icc methods.
yet epicc just as ic3only considers documented icc methods for inter component communicati on.in the same w ay li al.
set up a ml approach for detecting malicious applications.
the feature set used is based on potential component leaks pcl in android apps.
pcls are defined using components as entry and or e xit points.
again they consider traditional icc methods as exit points for transferring data through components.
iccmatt aims at conceptually modeling icc in android apps to generate test cases.
the purpose is to identify components vulnerable to malicious data injection and pri vacy leaks.
the approach of the researchers takes into account pendingintent objects b ut only at the conceptual le vel.
they describe them asintent wrappers able to be shared between components mainly used in notificat ions and or alarm services as we ha veseen throughout this paper .
the y do not directly refer to methods for performing inter component communication atypically withpendingintent objects.
in the same w ay enck et al.
describe the overall functioning ofpendingintents for inte gration with third party applications.
nevertheless the y do not e xplain as in the security threats that it poses as well as the difficulty it induces for icc modeling in static analyzers.
pianalyzer models specific vulnerabilities where other apps can intercept broadcasted pendingintents.
in contrast raicc generically models icc links where pendingintent as well as intentsender a re in volved.
the goals of pianalyzer and r aicc are thus different.
hence r aicc was not compared to pianalyzer in this study .
besides static analysis approaches dynamic analysis solu1407tions have also been studied for the detection of icc data leaks.
for example copper droid is able to reconstruct the app behavior by observing interactions between the app and the underlying linux system.
taint droid dynamically tracks sensitive information with a modified dalvik virtual machine.
monitoring the behavior of an android app is also popular in dynamic data leak detection .
depending on the taint policy set up for propagating tainted data a dynamic analysis could consider and therefore detect atypical icc data leaks.
nonetheless precise methods exist for bypassing taint tracking leading to false negatives as well as more general approaches for tackling icc related security issues .
viii.
c onclusion we addressed the challenge of precisely modeling intercomponent communication in android apps.
after empirically showing that android apps can leverage atypical ways for performing icc we discuss the implications for state of the art icc modeling based analysis.
we contribute towards using methods not primarily made for this purpose.
we have developed and open sourced raicc which reveals aicc methods and further resolves them into standard icc through instrumentation.
we demonstrate that raicc can boost existing analyzers such as a mandroid and i ccta enabling them to substantially increase their data leak detection rates.
ix.
d ata availability we provide a complete set of artefacts for reproducibility purposes.
in particular we provide the datasets used in our study third party tools used as well as scripts to run them.
we also provide the entire source code of our tool raicc.
all artifacts are available online at x. a cknowledgment this work was partly supported by the luxembourg national research fund fnr under projects characterize c17 is onniv a and the afr grant by the sparta project which has received funding from the european union s horizon research and innovation program under grant agreement no and by the luxembourg ministry of foreign and european affairs through their digital4development d4d portfolio under project luxways.