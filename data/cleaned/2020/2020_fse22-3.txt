pyter effective program repair for python type errors wonseok oh korea university republic of korea marinelay korea.ac.krhakjoo oh korea university republic of korea hakjoo oh korea.ac.kr abstract we present pyter an automated program repair apr technique for python type errors.
python developers struggle with type error exceptions that are prevalent and difficult to fix.
despite the importance however automatically repairing type errors in dynamically typed languages such as python has received little attention in the apr community and no existing techniques are readily available for practical use.
pyter is the first technique that is carefully designed to fix diverse type errors in real world python applications.
to this end we present a novel apr approach that uses dynamic and static analyses to infer correct and incorrect types of program variables and leverage their difference to effectively identify faulty locations and patch candidates.
we evaluated pyter on type errors collected from open source projects.
the result shows that pyter is able to fix .
of them with a precision of .
.
ccs concepts software and its engineering automated static analysis software testing and debugging .
keywords program repair program analysis debugging acm reference format wonseok oh and hakjoo oh.
.
pyter effective program repair for python type errors.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
introduction python has become one of the most popular programming languages.
according to the ieee spectrum s ranking of the top programming languages python is clearly the dominant language used in a wide variety of applications including web enterprise and embedded domains.
in particular python s popularity has skyrocketed in recent years driven by its use in artificial intelligence and data science applications.
corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore association for computing machinery.
acm isbn .
.
.
.
top runtime exceptions in python.
we counted the number of stackoverflow posts and github issues in the repositories used in section containing the keyword error .
below are the top built in exceptions i.e.
typeerror attributeerror valueerror keyerror importerror and their relative proportions.
type attribute value key import stackoverflow .
.
.
.
.
github .
.
.
.
.
in a day .
more than a day less than a week .
more than a week less than a month .
more than a month29.
figure statistics on the time period between reporting and patching a type error.
for bugs in our benchmarks section it took days on average and about took more than a month.
the worst case took days more than three years.
as a dynamic language however python suffers from an important class of run time errors namely type error exceptions.
in python a type error occurs when an operation is performed on a value of an unsupported type.
for example applying primitive arithmetic operations on an integer and a string e.g.
two is undefined in python and hence raises a run time exception.
python developers struggle with such type errors.
table shows that they appear most frequently among all built in exceptions in python.
more importantly type errors are difficult and time consuming to fix correctly fixing a type error requires not only avoiding the given fault but also anticipating other potential risks in advance see section .
in practice type errors commonly get fixed weeks or months after they are reported figure .
pyter .in this paper we present pyter1 the first technique that can automatically fix python type errors.
despite the importance no techniques or tools are readily available for fixing type 1python t ype e rror r epairesec fse november singapore singapore wonseok oh and hakjoo oh 1def main x y z 2if z return foo x z y 4if y return foo y x z 6return y 8def foo a b c 9d b c e a d typeerror return a c e a buggy code1def main x y z 2if z return foo x z y 4if y return foo y x z 6return y 8def foo a b c 9d b c if isinstance a str a int a e a d pass return a c e b fixed code figure example to illustrate how pyter works errors in dynamically typed languages such as python.
instead existing work focused on either detecting type errors in dynamic languages or repairing compile time type errors in statically typed languages .
also as our evaluation in section implies domain unaware apr automated program repair techniques are unlikely to be effective for real world type errors.
the key novelty of pyter is its type aware apr technique that leverages type information to boost fault localization and patch generation.
pyter aims to fix a type error by handling the incorrect type of a variable with a correct type.
to do so pyter first collects candidate program variables from error traces and uses dynamic and static analyses to infer the incorrect and correct types that candidate variables may have in erroneous and successful program executions.
the difference of those types is then used to accurately localize erroneous program locations and to prioritize candidate patches that are likely to fix the given error correctly.
we prove the effectiveness of pyter with various type errors in real python applications.
since there is no benchmark dedicated for python type errors we created a new benchmark called typebugs that includes type errors collected from open source projects.
in total pyter successfully fixed .
of those bugs with a precision correct patches plausible patches of .
.
we also checked that our type aware apr technique is essential for the performance the baseline of pyter which uses a conventional generate andvalidate approach without our type aware enhancement was able to fix .
of bugs with a precision of .
.
contributions .our contributions are summarized as follows we present pyter the first technique for fixing diverse type errors in real world python applications.
the key technical contribution is the type aware apr technique that leverages the different of correct and incorrect types of program variables to enhance fault localization and patch generation.
we make that the tool and benchmarks publicly available.
in particular we provide a new benchmark for python type errors which consists of programs .
.
kloc and type errors collected from open source repositories.
overview in this section we illustrate how pyter works with an example.
figure a shows a buggy program where a type error may occur at line .
figure b shows the program fixed by pyter where lines and are added to handle the type error.
pyter is a test based repair technique it assumes that negative and positive test cases denoted tnandtp respectively are given together with a buggy program.
for the example program in figure a suppose the following test cases are given tn tp .
a negative test e.g.
consists of an error triggering input to the entry function main and the corresponding expected output i.e.
the return value of main .
note that when the value of zis it is considered true at line in python.
therefore foois called at line with a string and two integer values being passed to a b and c respectively.
thus addition at line is performed on unsupported values i.e.
and raises a type error exception.
in the second negative test the value of y is considered as true in the condition statement at line .
thus foo is called at line and the same type error exception is raised at line .
the positive test case also consists of an input and an expected output but is used to specify the functionality of the program when it is run successfully without any run time errors.
step collecting candidate variables .in python type errors typically occur when a variable is used with an incorrect type.
then developers fix a type error for example by converting the erroneous type of the variable to a proper one.
in figure b the patch at lines and changes the type of variable ato integer when it has the string type.
thus the first step of pyter is to collect such candidate program variables.
we collect candidate variables from the traceback of the type error exception.
a traceback is an error triggering a call chain that begins with the entry function and ends with a run time exception.
such a call chain is obtained by running the program with negative test cases.
for example figure shows the two tracebacks generated from the negative tests in our running example.
given the tracebacks in figure we collect all program variables that appear in the nodes and edges up to the error location resulting in candvars x y z a b c d for the program in figure a we do not collect variable ethat is defined after the type error occurs .
main x y z foo a b c typeerror3 foo x z y e a d a for input main x y z foo a b c typeerror5 foo y x z e a d b for input figure traceback examples step inferring negative and positive types .the second step of pyter is to infer the types of candidate variables.
specifically we infer both negative types types that variables havepyter effective program repair for python type errors esec fse november singapore singapore negative types positive types difference ranking x int str int str y int str int str z int int a str int str int b int int c int int d int int figure type analysis example when type errors occur and positive types types that variables have when type errors do not occur .
figure shows the result of type inference for the program in figure a .
the result shows that variable a for example has the string type in the buggy execution but has the integer type in the normal execution.
we compute negative types using a dynamic analysis that observes variable types while running the program with negative test inputs.
for example when we execute the example program with the inputs and we find out that variables have types as shown in the second column of table .
to obtain positive types we perform both dynamic and static analyses.
running the program with the positive test input skips the function calls at line and hence we cannot infer the types of variables a b c anddusing a dynamic analysis alone.
thus pyter makes predictions for those variables using a static analysis specially designed to infer positive types dominantly used in the program section .
.
step fault localization .pyter s fault localization is done in two stages.
we first perform a function level fault localization that chooses the function containing the most suspicious candidate variable.
we compute the suspicious scores of candidate variables by defining a metric to quantify the difference between negative and positive types.
in our example the most suspicious variable isabecause its negative types str and positive types int are completely different.
thus we attempt to fix function foofirst where variable ais used.
once a function is selected we identify the most suspicious line by running an existing spectrum based fault localization sbfl technique inside the function.
we assume that line is selected for our example program.
we use this two staged method because existing sbfl is not accurate enough to localize type errors.
for example when we apply sbfl based onfailed failed passed where failed andpassed denote the numbers of failing and passing test cases respectively we have to equally suspect functions main andfoo lines and of main and all lines of foohave the same suspicions score.
however it is not possible to fix the bug by repairing main .
step patch generation .after fault localization the following information is available foo a str int which means that the most suspicious function line and candidate variable are foo and a respectively and the negative and positive types of aare str and int respectively.
to fix line of function foo pyter uses the standard generate and validateapproach with a set of predefined repair templates designed for type errors and accelerates the procedure by ranking the templates based on the negative and positive types of the candidate variable.
in the running example we note that both str and int are singleton sets and first try to use a type casting template that converts the negative type str of the candidate variable a to the positive type int generating the conditional statement at lines of figure b .
this patch is accepted by pyter as it satisfies all test cases intnandtp.
3pyter algorithm in this section we describe each step of our approach in detail.
programs .we consider a small language to describe pyter so that its core idea is generally applicable to other languages.
a program p pgm is a sequence of function declarations i.e.
p f1 f2 ... fn.
a function declaration f fdecl is a tuple f x s of a function name f function parameter x and body statement s .
we consider statements and expressions below s x e returne s1 s2 e n s b x e1 e2 f e1 ... en wheren s andbare constant values of integer string and boolean types respectively.
we write fefor the entry function the starting point ofp.
we assume program variables are uniquely named and all functions explicitly return a value upon termination.
let valbe the set of values that programs manipulate e.g.
integers strings.
let p val valbe the evaluator that takes an input value i.e.
an argument value of the entry function and produces an output value.
p is a partial function and we write p vi when it is undefined for input vi we treat as a special value not included inval i.e.
val .
we assume p vi produces only when it causes a type error.
in other words we assume no other run time errors can occur for simplicity.
moreover we assume there is only a single type error in the buggy program.
problem definition .assume a program pwith a sett val valof test cases are given where a test case is a pair vi vo t of input and output values of the program.
we assume that for some vi vo t p vi .
we dividetinto negative tests tn and positive tests tp t tn tp wheretn vi vo t p vi andtp vi vo t p vi vo .
our goal is then to fix the program by transforming pintop such that for all vi vo t tn tp p vi vo.
.
collecting candidate variables traceback .we collect candidate variables from the traceback error trace that is available in python when a run time exception is raised.
when p vi for some error triggering input vi we write traceback p vi for the associated traceback.
a traceback tis a sequence of function calls made at an error location t f1 s1 f2 s2 ... fn sn wherefiis a function declaration i.e.
fi f x s sia statement andf1the entry function fe .
for i n siis a statementesec fse november singapore singapore wonseok oh and hakjoo oh that includes a function call to fi .snis the statement where the error occurs.
candidate variables .we collect program variables appearing in error traces as candidate variables.
we run negative test cases in tnto generate the set tof all tracebacks for the given type error t traceback p vi vi vo tn .
given a traceback t letvar t be the set of variables appearing in t var t f x s tvar s x where var s denotes the set of variables used in statement s. we define the set candvars of candidate variables as follows candvars t tvar t .
inferring negative and positive types next we infer the negative and positive types of candidate variables.
we compute negative types via dynamic analysis by observing the types of variables while running the program with negative test inputs for all x candvars we compute negtypes x type x p vi vi tn where type x p vi denotes the type that variable xhas whenpis executed with input vi for simplicity we assume a variable has a single type per program execution .
for positive types we use both dynamic and static analyses postypes x postypesdynamic x postypesstatic x where postypesdynamic x andpostypesstatic x denote the types inferred by dynamic and static analyses respectively.
the former obtained from positive test cases and is defined as follows postypesdynamic x type x p vi vi tp .
when the given positive test cases are not enough to infer the positive types of some candidate variables i.e.
postypesdynamic x is undefined for some x candvars pyter predicts those types using static analysis.
however note that using a conventional type inference algorithm is unlikely to produce useful information in our case because variables often do not have ground truth types in dynamic languages.
for example if we perform conventional type inference on the program in figure 2a then postypesstatic would include all the possible types e.g.
int str bool etc for all candidate variables.
in particular it would contain all negative types i.e.
x candvars.negtypes x postypesstatic x which is undesirable because our aim is to leverage the difference of types that variables have in normal and erroneous executions.
to address this issue of standard type inference we present a new type analysis tailored for finding the intended positive types of the program variables.
our type analysis is based on the intuition that when a type error occurs a specific buggy variable has an incorrect type while other variables typically have correct types.
for example when we execute program in figure a with negative tests the type str of the buggy variable ais incorrect but other variables such as b c and dare of the correct types.
based on this observation our type analysis infers the intended positive type of each candidate variable x candvars as follows we assume xis the buggy variable and initialize a type environment x init candvars 2typesby assuming all variables butxhave the negative types x init y candvars.
y x negtypes y otherwise run a consistency based type inference algorithm denoted infer w.r.t.
x initto predict the intended positive types x types ofx x infer x x init .
when the prediction is not deterministic i.e.
x we select one dominantly used in the program.
writing dom type for this procedure we can define postypesstatic x as follows postypesstatic x dom type x .
we apply the above steps for all variables x candvars .
now we explain the second and third steps infer anddom type in detail.
consistency based type inference .to infer the intended type of a specific variable from the initial type environment we propose a consistency based static type analysis.
as typical in type inference our algorithm begins with generating type constraints.
we generate a set cof constraints from statements in tracebacks c t t s t s where extracts constraints from statements and expressions as follows s s1 s2 s s1 s2 e x e s x e e s returne e e1 e2 e1 e2 e e1 e2 i ei e f e1 ... en otherwise where constraint e1 e2 indicates that e1ande2should have equivalent types in order to satisfy type consistency.
example .
.
let us generate constraints from the buggy program in figure 2a.
in case of the statement e a d at line we can extract constraints such as e a d a d e a d a d e a d .
the generated constraints for statements in fooare as follows d b c e a d return a c e d b c b c e a d a d a c e c e after collecting constraints c we solve them to create the final solution type environment candvars 2types.
given a 3in practice we distinguish constraints by their labels program locations which is necessary to find dominant types when constraints are not unique.pyter effective program repair for python type errors esec fse november singapore singapore current solution the following function updates by iterating over constraints in c c c c c c c c where processes a single constraint of the form e1 e2 e1 e2 x1 var e1 x2 var e2 where 1and 2are the results of e1ande2w.r.t.
the current solution i.e.
e1 1 e2 2. the operator is defined to merge two maps in the pointwise manner.
the typing rules are fairly standard such as n int s str b bool x x f castfuns f e f f castfuns f e1 ... en e1 1 e2 2 e1 e2 1 2 where castfuns denotes the set of built in casting functions e.g.
castfuns int str ... our analysis is intra procedural that ignores return values of functions except for built in casting functions.
in we assume that xi and iare defined for i .
otherwise we define e1 e2 .
given we can define infer as follows infer x x init fix x init c x where fix x init ccomputes the following until a fixed point is reached x x init x i c x i i note that the fixed point computation begins with the initial type environment that assumes variables have positive types except for the variable xcurrently assumed to be buggy.
example .
.
to infer the intended type of variable ain figure 2a we begin with the following type environment 0 a a b int c int ... iterating over the constraints in starting from 0converges to the following a int b int c int ... from which we conclude that the desired type of aisint.
finding dominant types .let xbe the solution of .
when the inferred type of xis not deterministic i.e.
x x our algorithm goes into the next step where we select the type of x dominantly used in the program.
example .
.
consider the following code 1def main seq to append if isinstance to append list to append seq to append elif isinstance to append tuple to append to append seq to append typeerror else 4in python type casting is done with functions whose names equal types e.g.
int .
to append 9return to append where we assume seqhas a list value and to append has a tuple value.
then a type error occurs at line because addition between list and tuple is undefined in python.
by assuming to append is a buggy variable our algorithm described so far infers from lines and that the positive types of to append can be both tuple and list respectively resulting in a non singleton set list tuple .
in this case however we would like to predict the type of to append aslist since it is the intent of the developer and to append is dominantly used as list over the program e.g.
lines and .
to find out the dominant type we maintain information candvars types n which counts the number of times types are associated with variables during the fixed point computation.
we update whenever the type environment is updated.
that is is updated to the following whenever is applied in 2 1 where x is initially for all x candvars and types .
let xbe such count information generated when xis computed.
then we can define dom type as follows dom type x argmax x x x .
.
type aware fault localization pyter uses the type information to identify the program location to be fixed.
suppose the negative and positive types of candidate variables are given from the previous step negtypes postypes candvars 2types function level fault localization .the main difference from traditional fault localization is that our approach is staged and the most suspicious function is identified first.
to do so we compute the suspicious scores of candidate variables based on the difference of the negative and positive types.
we define the score of a variable xas a pair of integers as follows score x 1 2 a x 1 2 1 2 a x 1 2 wherea x is the cartesian product of negtypes x andpostypes x .
the first and second elements measure how similar and differentnegtypes x andpostypes x are respectively.
here a smaller score is given when the types are similar and a higher score is given when the types are different.
with score we find out the most suspicious candidate variable x candvars x argmax x candvarsscore x where we use the lexicographic total order between scores a b a b a a a a b b .
then we treat the function fas most suspicious that uses the selected variable x.esec fse november singapore singapore wonseok oh and hakjoo oh line level fault localization .once the suspicious function fand variable xare chosen we compute the suspicious scores of program locations in fby running a traditional spectrum based fault localization sbfl .
we simply define the score of a program location line las follows scoref l t t. f sl t failed sl failed sl passed sl otherwise whereslrepresents the statement at line l failed sl andpassed sl denote the numbers of failing and passing test cases that execute statementsl respectively.
when the function fand the statement sl appear in some error trace t we give the highest score.
otherwise we run sbfl to compute a score based on the numbers of failing and passing test cases.
.
type aware patch generation now we explain the patch generation step of pyter .
we are currently given the suspicious function line and variable line as well as the positive and negative types of x f l x negtypes x postypes x .
letslbe the suspicious statement at line l. repair templates .we extensively studied developer patches available in open source programs5 and concluded that most of the patches for fixing single variable type errors can be categorized into the templates in table which are divided into three main categories based on their strategies to fix type errors typecasting templates insert a casting statement that converts a negative type of the suspicious variable x to a positive type.
handling templates handle the type error by replacing the suspicious statement sl or an expression in it by new one.
guard templates are used when the suspicious statement sl is a conditional statement.
the guard of the statement is strengthened by adding a type check to avoid the error.
a template contains holes of five types nindicates a negative type in negtypes x pa positive type in postypes x c a casting expression sa statement and ean expression.
table shows examples of buggy statement sl template applied to sl denoteds l and candidate patch denoted s l .
thus templates with prefix negative is to check if the suspicious variable x has a negative type in negtypes x .
likewise templates with prefix positive is to check whether the variable xhas a positive type in postypes x .
prioritizing templates .to fix the bug in sl we first need to select a template.
basically we enumerate all templates but pyter prioritizes appropriate ones based on the type information negtypes x andpostypes x of the suspicious variable x .
we first decide one of the main categories.
we choose the guard category if slis a conditional statement because it can be only applied when the condition is satisfied.
otherwise we prioritize either typecasting or handling categories based on the number of positive types i.e.
postypes x .
we expect postypes x to be 5for this study we used not only our benchmarks typebugs but also others that do not meet our benchmark selection criteria in section .one for synthesizing the hole cin typecasting.
thus we select typecasting instead of handling when postypes x .
once a main category is chosen we prioritize sub categories with the number of negative types i.e.
negtypes x .
it is easy to synthesize n when negtypes x .
hence we first select sub templates with prefix negative when negtypes x .
otherwise we choose other sub templates firstly except for templates with prefix negative .
then we enumerate the rest of sub categories in increasing size.
template instantiation .once a template s l is chosen we need to synthesize holes in it to produce candidate patches.
this synthesis procedure is defined by the transition system i f where is a set of states is a transition relation i is a set of initial state and f is a set of final states.
a state is a pair s of a partial statement with holes and the information from fault localization.
the initial state i iis the pair s l wheres ldenotes the selected template.
the goal of template instantiation is to find a final state s l fthat makes the program work correctly vi vo t p sl s l vi vo.
wherep sl s l denotes the program pwith the statement sl replaced by s l. given f l x negtypes postypes figure presents the transition relation for synthesizing holes in partial programs.
we write dv for the default value of e.g.
dvint dvstr etc .
in python the expression isinstance x int str bool means whether a type of xis one of int str bool .
we use this expression when synthesizing p.returnexps f andreturntypes f return a set of the expression of return statements used and the output types of the function f respectively returnexps f e returne returnstmts f returntypes f e returntypes f postypes e where the returnstmts f denotes the set of all return statements infand we use postypes as a type environment in returntypes .
.
final algorithm putting it all together algorithm shows the final algorithm of pyter .
we first collect candidate variables from error traces line and perform dynamic and static type analysis line .
let be the result of type analysis phase which contain information about negative and positive types of candidate variables.
by utilizing we run fault localization to rank candidate faulty locations and iterates over the results line where consists of function f line l variable x negative types negtypes and positive types postypes .
we generate a ranked list of candidate patches line and apply a patch to the original buggy program line .
next we execute the candidate patched program on test cases tp tn at line and obtain failed test cases t n. ift nis empty then we return that candidate program as output.
otherwise we check if t nis a subset oftn which means that some of tnpasses.
then we continue to refine the current patch by invoking the algorithm witht n line .pyter effective program repair for python type errors esec fse november singapore singapore table repair templates with examples.
to illustrate we assume the suspicious variable is x negtypes x str and postypes x int .sl buggy statement.
s l template for sl.s l candidate patch without holes.
main sub sl buggy stmt s l template for sl s l candidate patch type castingnegative typecastingreturn x yif isinstance x n x c return x yif isinstance x str x int x return x y positive typecastingreturn x yif not isinstance x p x c return x yif not isinstance x int x int x return x y typecasting expressionreturn x y return c y return int x y handlingnegative handling stmtreturn x yif isinstance x n s return x yif isinstance x str return return x y negative handling exprreturn x y return eif isinstance x n else x y return if isinstance x str else x y positive handlingreturn x yif not isinstance x p s return x yif not isinstance x int return return x y exception handlingreturn x ytry return x y except stry return x y except return guardnegative guardif x return x else return 0if not isinstance x n and x return x else return 0if not isinstance x int and x return x else return positive guardif x return x else return 0if isinstance x p and x return x else return 0if isinstance x int and x return x else return postypes x s x dv returntypes f s return dv e returnexps f s returne postypes x e dv postypes x 1 2 ... n p 1 2 ... n negtypes x n postypes x c x i ... n ei e i f e1 ... en f e ... e n e1 e 1e2 e e1 e2 e e 2e e x e x e e e returne returne s1 s 1s2 s s1 s2 s s figure transition relation for instantiating templates evaluation in this section we experimentally evaluate pyter to answer the following research questions effectiveness of pyter how effectively can pyter fix real world python type errors?
impact of techniques how important are the major techniques used in pyter ?
limitations of pyter what limitations does pyter have?
when is pyter likely to fail to fix type errors?
.
setup we implemented pyter in about lines of python code v. .
.
.
we implemented dynamic type analysis and fault localization on top of pyannotate a framework to instrument python source code.
our implementation of pyter supports the full languageof python including object oriented features and user defined types.
an exception is sub types the current implementation of pyter ignores sub types because we observed they are rarely used in real world programs.
all experiments were done on a linux machine ubuntu .
with cpus and 128gb memory powered by the intel zeon silver processor.
benchmarks .we used two benchmark sets typebugs and bugsinpy .
we constructed a new benchmark set typebugs because there is no benchmark dedicated to repairing type errors although datasets for type inference exist .
we first collected popular open source projects from github that have more than stars.
we then searched for pull requests with the keyword typeerror in their messages over the past years since up to .
among them we considered type errors that include both error triggering test cases and a correct patch written by aesec fse november singapore singapore wonseok oh and hakjoo oh algorithm thepyter algorithm input a buggy program p test casestnandtp tracebacks t output a correct program p satisfying all test cases in tn tp function repair p tp tn t c candidatevariables t section .
typeanalysis p c tp tn t section .
for faultlocalization t do section .
fors l patchcandidates do section .
p p sl s l apply the patch t n execute p tp tn t n failed tests ift n then returnp else ift n tnthen p repair p tp t n t ifp failthen returnp return fail developer.
for each bug typebugs includes the repository snapshot of the bug fixing commit with the developer patch removed.
in total we collected bugs from open source projects comprising of small to large scale projects .
.
kloc on various domains such as machine learning e.g.
scikit learn data analysis e.g.
pandas and scientific computing e.g.
numpy .
on average typebugs includes .
negative test cases per bug.
we used positive test cases in the file containing the negative test cases resulting in .
test cases per program on average.
we did not use the full set of positive tests provided by each project because running all of them was prohibitively expensive.
for example the pandas project contains about tests and running them takes more than hours.
we also evaluate pyter onbugsinpy an existing bug benchmark for python.
bugsinpy is a python version of defects4j containing bugs of diverse types.
among them we extracted bugs that raise type error exceptions.
success criteria .we manually checked whether the generated patches are correct or not where a patch is considered correct if it is semantically identical to a developer patch ignoring i o side effects e.g.
printing a value .
we also checked the developer s comments to consider their implicit intention when checking semantic equivalence.
in all experiments we set the time budget for tool execution to seconds per bug.
.
results results on typebugs .table shows the performance of pyter ontypebugs andbugsinpy .
to see the effectiveness of pyter we compare it with baseline the baseline of pyter that uses a conventional generate and validate approach without our type aware enhancement and static type analysis.
more precisely baseline uses existing sbfl without our type aware fault localization and patch prioritization.
baseline uses the same set of templates as pyter .
when synthesizing holes in the templates baseline uses negtypes andpostypesdynamic but it does not use postypesstatic that requires our static analysis technique.1def foo out data out out data typeerror out out.encode data 4return out 6def goo module ... for obj in module.values for obj in module.itervalues ... figure a developer patch example in bugsinpy simplified from scrpay in total pyter generated plausible patches which pass all test cases out of bugs.
among those plausible patches were correct equivalent to developer patches leading to a fix rate of .
and a precision of .
.
on the other hand baseline generated plausible patches of which were correct achieving a fix rate of .
and a precision of .
.
these results confirm that our type aware apr technique is essential for fixing real world type errors.
results on bugsinpy .on average pyter fixed .
of bugs with a precision of .
.
by contrast baseline was able to fix .
with a precision of .
.
pyter is less effective on bugsinpy than typebugs .
vs. .
because bugsinpy was not constructed with type errors in mind.
we found that many of those bugs were not originally reported as type errors e.g.
the error reports do not contain the keyword typeerror .
therefore although they raise type error exceptions their root causes often involve other kinds of bugs as well.
figure shows an example that includes a type error at line but also involves another non type error at line .
in this case pyter succeeds to fix the type error at line but the resulting patch does not pass test cases as the bug at line still remains.
this is why we newly created typebugs a collection of bugs originally reported as type errors to solely evaluate the ability of pyter for fixing type errors.
impact of techniques .pyter features three new techniques type aware fault localization section .
type aware patch prioritization section .
and static type analysis section .
.
to evaluate the impact of these techniques we compared the performance of the following variants of pyter baseline the baseline of pyter without our fault localization patch prioritization and static type analysis.
baseline baseline with our patch prioritization baseline baseline with our fault localization pyter baseline with our static type analysis we evaluate these variants in terms of the number of solved benchmarks including both typebugs andbugsinpy and the cumulative repair time.
note that to our knowledge no existing apr tools are readily available for fixing real world python programs except for those for fixing student programs e.g.
.
thus we tried to indirectly compare pyter with general apr tools by includingpyter effective program repair for python type errors esec fse november singapore singapore table evaluation results.
b the number of bugs for each projects.
g the number of plausible patches.
c the number of correct patches.
fixrate c b .
prec precision c g .
avg.
time average running time sec per bug.
program bavg.
klocnegtest postest baseline pyter avg.
numavg.
timeavg.
numavg.
time g cfix rateprecavg.
time g cfix rateprecavg.
timetypebugsairflow .
.
.
.
.
.
.
.
.
.
.
beets .
.
.
.
.
.
.
.
.
.
.
core .
.
.
.
.
.
.
.
.
.
.
kivy .
.
.
.
.
.
.
.
.
.
.
luigi .
.
.
.
.
.
.
.
.
.
.
numpy .
.
.
.
.
.
.
.
.
.
.
pandas .
.
.
.
.
.
.
.
.
.
.
rasa .
.
.
.
.
.
.
.
.
.
.
requests .
.
.
.
.
.
.
.
.
.
.
rich .
.
.
.
.
.
n a .
.
n a .
salt .
.
.
.
.
.
.
.
.
.
.
sanic .
.
.
.
.
.
.
.
.
.
.
scikit learn .
.
.
.
.
.
.
.
.
.
.
tornado .
.
.
.
.
.
.
.
.
.
.
zappa .
.
.
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
.
.
.2bugsinpyansible .
.
.
.
.
.
n a .
.
n a .
fastapi .
.
.
.
.
.
n a .
.
n a .
keras .
.
.
.
.
.
.
.
.
.
.
luigi .
.
.
.
.
.
.
.
.
.
.
matplotlib .
.
.
.
.
.
n a .
.
n a .
pandas .
.
.
.
.
.
.
.
.
.
.
scrapy .
.
.
.
.
.
.
.
.
.
.
spacy .
.
.
.
.
.
.
.
.
.
.
tornado .
.
.
.
.
.
.
.
.
.
.
tqdm .
.
.
.
.
.
n a .
.
n a .
youtube dl .
.
.
.
.
.
.
.
.
.
.
total .
.
.
.
.
.
.
.
.
.
.
benchmark solved02000400060008000repair time s pyter baseline baseline baseline figure impact of techniques baseline that can be considered as representing a typical apr tool that is not specifically designed for type errors.figure shows the results.
the difference between pyter and baseline shows how useful our static type analysis is.
while baseline fixed programs pyter fixed more bugs which had insufficient positive test cases.
the gap between baseline and baseline shows the impact of our type aware fault localization using it increased the number of correct patches from to .
moreover the results show that our patch prioritization technique is also important.
without it baseline was only able to repair bugs as opposed to that baseline can fix.
.
discussion strength of pyter over manual patches .because real world type errors are nontrivial to fix we found that pyter often generates patches of higher quality compared to developer patches which also include all the intended behaviors of the developer patch.
figure shows an example simplified from scikit learn.
the original code in figure a has a type error at line .
we assume that function fooat line only receives string values as its argument and otherwise raises a type error exception.
suppose we are given test cases such that when main is called the value of sis false andkhas a value of the bytes type.
then the program executesesec fse november singapore singapore wonseok oh and hakjoo oh table statistics on patch patterns pyter failed in typebugs andbugsinpy .
typebugs bugsinpy group a group b group c group d others function dense and the type error occurs at line because kis not a string value.
figure b shows the patch written by a developer where s he fixed the type error by inserting the conditional typecasting statement at lines and .
the developer patch correctly fixed the type error at line .
however it is overfitted to the given test cases as a potential error still remains at line .
when kis a bytes value the expression str list.index k at line raises an exception valueerror because str list does not contain bytes values.
thanks to our type aware fault localization pyter was able to insert the type casting statement at lines and and avoided the future risk by always converting the bytes type of kinto str before invoking functions sparse ordense at line .
limitations of pyter .our evaluation also identified limitations of pyter .
in experiments pyter failed to fix bugs.
we investigated why pyter failed and classified those bugs into four groups based on the patterns of desirable patches a patches that convert incorrect type to correct b patches that need conversion for both types and values c patches that introduce new argument values d patches that insert statements not related to types the frequencies of these groups are shown in table where others are unclassified bugs that require more complicated repair strategies.
bugs in group a are within the scope of pyter while other groups are not.
so we further investigated bugs in the a group to see why pyter failed bugs needed multi line patches bugs required more advanced type inference bugs required for complex type conversion and bug required more effective patch prioritization.
for example pyter failed to produce the patch in figure that fixes two type errors at lines and at the same time.
currently pyter focuses on fixing single line bugs.
also to fix the type error at line we need to infer the type of the user defined function to bytes .
our static type analysis currently exploits types of built in casting functions such as intandstr.
related work apr techniques are commonly classified into special purpose and general purpose approaches.
special purpose techniques aim to fix specific yet important classes of bugs.
for example techniques have been proposed to fix memory errors in c programs null pointer exceptions in java error handling bugs concurrency bugs dependency errors and integer buffer overflow .
to our knowledge pyter is the first technique specialized for fixing type errors inpython programs.
furthermore we are not aware of apr techniques applicable to python except for introductory programming assignments .
general purpose approaches aim to fix any kinds of bugs instead of focusing on specific types of bugs.
these techniques are further classified into generate andvalidate and semantic based approaches .
generate and validate approaches explore a predefined search space to generate candidate patches until a patched program which passes the given test cases is found.
semantics based techniques derive constraints on correct patches and synthesize patches by using smt solvers.
technically pyter belongs to the generate and validate approach but enhances it with techniques specialized for type errors such as type aware fault localization and patch prioritization.
a number of analyses have been proposed for type inference in dynamic languages such as python javascript and ruby .
for example cannon et al.
perform analysis to infer atomic types of local variables.
typepete and druby are constraint based type inference algorithms.
these approaches have a limitation they require user type annotations or assume variables have single types .
neural type inference techniques were also presented but they need extra learning steps with a large amount of data.
typedevil and rubydust dynamically analyze types by running test cases.
to address shortcomings of dynamic and static analyses a hybrid approach has been proposed for javascript.
note that our type analysis in section .
crucially differs from the works described above our goal is not to infer all the possible types of program variables which are typically useless for type error repair but to predict the intended types when variables are incorrectly used.
conclusion type errors are common yet difficult to fix in dynamic languages such as python.
however no existing techniques or tools are readily available for use.
in this paper we presented pyter the first technique for automatically fixing real world type errors in python applications.
to this end we proposed a new apr technique that leverages the difference between negative and positive types of program variables to perform type aware fault localization and patch generation.
experimental results demonstrated that pyter can repair diverse type errors effectively it was able to fix .
of type errors from popular open source projects with .
precision.