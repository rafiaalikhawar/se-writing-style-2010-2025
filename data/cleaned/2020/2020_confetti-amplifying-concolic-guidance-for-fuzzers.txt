confetti amplifying concolic guidance for fuzzers james kukucka1 lu s pina2 paul ammann1 and jonathan bell3 1george mason university fairfax va usa 2university of illinois chicago chicago illinois usa 3northeastern university boston ma usa jkukucka gmu.edu luispina uic.edu pammann gmu.edu j.bell northeastern.edu abstract fuzztesting fuzzing allows developerstodetectbugsandvulnerabilitiesincodebyautomaticallygeneratingdefect revealing inputs.
most fuzzers operate by generating inputs for applications and mutating the bytes of those inputs guiding the fuzzing processwithbranchcoveragefeedbackviainstrumentation.whitebox guidance e.g.
tainttrackingorconcolicexecution issometimesin tegratedwithcoverage guidedfuzzingtohelpcovertricky to reachbranches that are guarded by complex conditions so called magic values .
this integration typically takes the form of a targeted input mutation e.g.
placing particular byte values at a specific offset of some input in order to cover a branch.
however these dynamic analysis techniques are not perfect in practice which can result in thelossofimportantrelationshipsbetweeninputbytesandbranch predicates thus reducing the effective power of the technique.
we introduceanew surprisinglysimple buteffectivetechnique global hinting which allows the fuzzer to insert these interesting bytesnot only at a targeted position but in any position of any input.
we implemented this idea in java creating confetti which uses both targeted and global hints for fuzzing.
in an empirical comparisonwithtwobaselineapproaches astate of the artgreybox java fuzzer and a version of confetti without global hinting we foundthatconfetticoversmorebranchesandfinds15previously unreportedbugs including 9thatneitherbaseline couldfind.by conductingapost mortemanalysisof confetti sexecution we determined that global hinting was at least as effective at revealing new coverage as traditional targeted hinting.
acm reference format jameskukucka lu spina paulammann and jonathanbell.
.confetti amplifyingconcolicguidanceforfuzzers.
in44th international conference on software engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
https introduction software is at the core of critical electronic systems.
to avoid introducingfaults whichcanleadtosignificanterrorsandsecurity vulnerabilities developers test their applications before deployment by generating diverse inputs that exercise as many behaviors as possible attempting to catch bugs and vulnerabilities before permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
sofartowardsgeneratingdiverse andunexpected inputs.many recent advances in greybox fuzzing such as the popular american fuzzylop afl afl libfuzzer andhongfuzz are based on coverage guided fuzzing.
coverage guided fuzzers use branch coverage as feedback to guide mutation of a set of manuallyprovided seed inputstowardsnewinputsthatexplorenew programpaths.thesefuzzersmightexecutethousandsofinputs persecond butareunlikelytogenerateinputsthatsatisfyhighly constrained branches which require some so called magic bytes .
acomplementaryapproach concolicexecution discoversthose magic values by recording exactly which input bytes are used in which branches in the program s execution .
then with the aid of an smt solver the concolic execution engine generates inputs that forceadifferentbranchchoice .priorworkhasobserved that full blown concolic execution is often unnecessary to handle typicalmagicbytecomparisons turninginsteadtodynamictaint tracking .
dynamic taint tracking is an analysis that associates taint tags with values and then propagates those tags duringprogramexecutionsuchthatwhenanewvalueisderived through data flow from a tainted value that same taint tag is associated with the new value.
whiletainttracking guidedfuzzerslikevuzzer angora and buzzfuzz have been shown to be more effective than a typical greybox fuzzer we believe that they have only begun to leverage the power of taint tracking in fuzzing.
in particular taint trackingcanonlyguidethefuzzertoexplorebranchesforwhich thereisa dataflowrelationship betweenthebranchpredicateand the input bytes.
consider the code snippet in listing in which theinputstrings s1ands2arecomparedagainstsomeparticular string with that comparison stored into a boolean variable.
1public void magic string s1 string s2 2boolean v1 s1.equals abc 3boolean v2 s2.equals s1.c oncat def 4if v v 5throw new illegalstateexception bug listing example code in which taint tags from inputs s1 and s2do not flow to a branch that they indirectly control.
ideally the taint tracking tool could report to the fuzzer that to cover the true side of the branch on line the fuzzer must mutate s1ands2 and even better to generate the concrete values abc andabcdef respectively .however thetainttrackingtoolwillnot report any relationship between the input and the branch on line because v1iscontrol dependenton s1 butnotdata dependent and similarly between s2andv2 .evenworse whileinthisexample thereisadataflowrelationshipbetweentheinputstrings s1and s2and the magic strings abcandabcdef in real code the taint ieee acm 44th international conference on software engineering icse icse may pittsburgh pa usa james kukucka lu s pina paul ammann and jonathan bell tags on s1ors2might also be lost through implicit flows.
for example one common pattern is to build a map from input strings to a tokenized representation of each string if the same input string is encountered more than once the parser returns the same tokenized version ofthe string effectively losing trackof the input.
whilesomedynamictainttrackingtoolsdosupport controlflow propagation which would detect this relationship these analyses have too many false positives to be useful in practice .
how else can we help the fuzzer to explore this branch?
one typical approach is to simply scrape the application binary for all strings creating a dictionary of interesting strings to use when fuzzing inthiscase abcanddef .unfortunately thistrickonlyworksif the magic values are statically defined in the codebase values generated dynamically will not be included in the dictionary.
in this case because s2must be the value abcdef the dictionary will not help the fuzzer explore this branch.
this paper presents confetti concolic fuzzer employing taint tracking information a system that combines fuzzing with taint trackingandconcolicexecution.confettiamplifiesthereach of concolic guidance allowing the fuzzer to effectively generate inputsthatexplorebranchesliketheoneinlisting1 andlonger more complex examples where taint tags quickly become lost through implicit flows.our keyinsight isthat theprecise targetingof past tainttracking guidedgreyboxfuzzersunnecessarilyrestrictsthe fuzzer s ability to reveal tricky to reach branches.
as with stateof the art fuzzers confetti executes each input in its population with taint tracking collecting constraints on the input bytes.
confetticangeneratenewcoverage revealinginputsthroughconcolicexecution by negating and solving those constraints in the style of existing work .
confetti snovelapproachtoguidethefuzzer globalhinting is based on the insight that although taint tags might be lost for parts of an input magic values derived for otherparts of the input canbere targeted andappliedelsewhere.when confettifinds thatapartoftheinputflowsintoacomparisonwithadynamically computed value confetti records that value as a global hint.
we createandevaluateanewfuzzingmutation whichinsertsglobal hintsanywhere inanyinput not only at the targeted location of the specific input from which the hint was derived.
weevaluatetheefficacyofthisnewmutationstrategy considering both system level metrics i.e.
branches covered and bugs found andunit levelmetrics i.e.
mutationsuccessrate .ourresults clearly demonstrate that global hinting is roughly as effective inrevealingnewcoverageastraditional targetedhinting andmost importantly that this strategy reveals differentcoverage and bugs thatcould not be reported by using targeted hinting alone.i no u r evaluation the baseline jqf zest fuzzer detected bugs whereas confetti with only targeted hints detected and confetti with both global and targeted hints detected bugs.
our opensource implementation of confetti represents a significant improvementinfuzzertechnologyforjvm basedsoftware providingbenefitstosoftwareengineeringresearchersinventingnewfuzzing approaches and to professional software engineers searching forbugs in their software.
while our implementation is limited to asingle language java and a single greybox fuzzer zest we believethatourresultsarecompellingenoughtohaveasignificantimpactonthefieldofsoftwareengineering warrantingfuturework exploring global hinting in other fuzzing domains.
the key contributions of this paper include anewapproachtocombineconcolicexecutionandtainttracking with fuzzing global hinting.
an open source implementation of confetti for java whichcombines traditional targeted hinting with our novel global hinting strategy .
an evaluation of confetti demonstrating the efficacy of its novelglobal hinting basedguidanceoverabaselinestate of theart greybox java fuzzer zest and against a baseline version of confetti without global hinting.
background before describing how confetti effectively guides a greybox fuzzerusingwhiteboxinformation wefirstbrieflysummarizegrey boxfuzzing andinparticular parametricgreyboxfuzzing.considerfuzzinganapplicationthattakesxmlfilesasinput.figure1shows two fuzzing loops one that represents the behavior of a traditional coverage guidedfuzzerlikeafl orlibfuzzer blueline and one that represents the behavior of a parametric fuzzer like crowbar fuzzchick orjqf zest orangeline .the traditional fuzzer blue executes a loop where it starts with some well formed seed input selected from a pool of seeds.
the fuzzer thenusesa mutatortotransformthatinput typicallyusinganevolutionary algorithm .
then the fuzzer executes the new input and capturesbranchcoveragethatmaybiastheevolutionaryalgorithm mutator onfutureexecutionsofthefuzzingloop.ifthenewinput isdeemed interesting typicallydefinedasrevealingcoverageofa newbranch orgreatlyincreasingthehitcountsofthosealready covered thentheinputissavedintothefuzzer spopulation to be selected again later for further fuzzing.
however inthecaseofthetraditionalcoverage guidedfuzzer blue line the mutator is unaware of the input syntax expected by the system under test so most of the generated inputs are likely to haveashallowreachinthecode.thatis mostoftheseinputseither fail some early stage syntactic parsing e.g.
the xml fragment xml xml oratbest findabuginthatsyntacticparser perhaps xml xml causes a crash .
system under test semantic logic syntactic parsermutator parametric generatorguidance x coverage biases xml name value name xml name value xml xml 0001seeds concrete input parametric input concrete input xml xml figure comparing a fuzzing loop for a traditional coverage guided fuzzer blue and parametric fuzzer or ange .
the traditional fuzzer uses an evolutionary algorithm to mutate concrete program inputs directly.
the parametric fuzzer mutates the parametric input the sequence of decisions made by a generator function that ultimately creates concrete inputs.
439confetti amplifying concolic guidance for fuzzers icse may pittsburgh pa usa in contrast the parametric fuzzer orange and green lines in figure has a seed pool that consists of parametric inputs which are thesequencesofdecisions madebytheparametricgeneratorthat result in some input.
whereas property based testing tools employ randomgeneration parametricfuzzersguidethegenerationofnew inputs by controlling each random decision made by the generator.
the parametric input in this example represents the set of decisions made by the generator function to create the concrete input xml xml .theparametricfuzzeralsousesamutatorto transformaseedinput butoperatesonthisparametricinput orangeline .bymutatingparametricinputs correspondingmutations occuratthe objectlevelandnotattheinputbytelevel.aone bit mutationto 0011mightresultinamoresemanticallyinteresting change tothe concrete input creating xml name value name xml in the example.
hence the key insight behind parametric fuzzing is that the structure of inputs is often more constraining thanthesetofvaluesinsertedintothatstructure.priorexperiments show that parametricfuzzing is more effective whencompared to traditionalpropertytesting andtotraditionalcoverage guided fuzzing of java programs .
since we target java applications we chose to integrate confetti with a parametric fuzzer.
confetti confettigeneratescomplexinputsthatcanexposehiddenbugs in a program s logic by using concolic execution and taint tracking as forms of guidance for parametric fuzzing.
the traditional approachtointegratewhiteboxguidancewithfuzzingistoprovidetargetedguidance instructingthefuzzertoplaceparticularbytesat aparticularlocationinaparticularinput.werefertoeachsuchsuggestion as a targeted hint.
confetti employs targeted hints but alsointroducesthenotionof globalhints whichallowconfettito overcometheinadequaciesofdynamictainttracking.althoughour approach is language agnostic we implement confetti in javaand target applications written in languages that target the jvm such as java scala kotlin groovy and clojure.
.
example beforeexaminingconfetti sarchitectureindetail shownin figure we provide a brief example to demonstrate how confetti works in tandem with the fuzzer to generate concrete inputs that explore otherwise hard to reach code.
figure shows con fetti s hinting process to bias an example xml generator in this example it is the generatexml function called in line .
as statedpreviously aparametricinputcanbethoughtofasaseriesofchoicesthataremade wehavecolor codeddistinctchoicepoints with the xml generator along with their associated parametric inputandresulting concretevalues.function generatestring isa black box that consumes a parametric input and generates a string.
we present the minimalset of program executions that reaches line but in practice confetti applies a variety of mutators to support both targeted and non targeted hints described further in section3.
.initially thegeneratorcreatesarandomseedinput circlecopyrt infigure3 input whichrandomlyselectsthestring groupid perhaps from a dictionary and the random boolean false.
being the first input of the fuzzing run this is guaranteed to obtain new coverage namelylines2and3.thisinputisdeemed interesting by thefuzzer asit leadsto increasedbranch coverage and issent totheconfetticoordinatorforwhiteboxanalysis circlecopyrtinfigure3 .
xmldocument doc parse generatexml if !
expected .equals doc.
element .name throw new error if !
version .equals doc.
element .attr .name throw new error interesting logic we want to fuzz follows bellow b simple parametric xml tag generator that uses random choicesstring generatexml string tagname generatestring if generateboolean return tagname generatestring generatestring tagname return tagname tagname a example code to fuzz the immediate goal is to pass both branches c visualization of fuzzer execution with hints.
the first input is generated randomly later inputs are mutated by the fuzzer or hinted by confetti hint underlined .
confetti generates hints from coverage revealing inputs only.
expected true version a groupid false package false expected false expected true groupid a seed mutationhintmutationhint source generator choices new coverage 912345parametric input 01101figure example fuzzer execution.
a parametric fuzzer can easily create an input that is parsable by the black box function on line but may struggle to reach line due to lines and .
as the parametric fuzzer records the sequence of random choices made in the generator a and mutates those choices to generate new inputs confetti proposes values for some of those choices thus guiding fuzzer through these branches with ease.
the confetti coordinator dispatches the input to a whitebox analysisprocess circlecopyrttoperformtaint trackingandcollectconstraints which are circlecopyrtreturned to the confetti coordinator which circlecopyrt negatesandsolvesthem circlecopyrtpossiblyresultinginnewparametric inputs.
meanwhile circlecopyrtthe fuzzer mutates inputs independently changing groupid to package in input .
oncethefuzzerdecidestomutateanewinput itcontactsthe confetticoordinatorforhints whichthe circlecopyrtconfetticoordinator returns in the form of the modified parametric input derived from input hinting the first generated string should be expected derivedfromtainttrackingbetweentheinputstringand thestring.equals call .
with the hint input results in new coverageonline4 anexceptionisthrownimmediatelyuponhitting line due to the absence of attributes input is then sent to the confetti coordinator for whitebox analysis.
meanwhile thefuzzermutatesinput 3into 4bychangingthebooleanchoice totrue followed by a random string for an attribute name and value.input 4resultsinnewcoverageonline5 andisalsosent to the confetti coordinator.
input is generated in a similar manner to input using confetti s hint mechanism forstrings by instrumenting as the call to attrto obtain the hint version.
while the parametric fuzzer couldcreate these inputs by chance it becomes a certainty with confetti.
.
architecture figure3showsahigh leveloverviewof confetti sarchitecture.
confetti consists of three key processes that run in coordination thefuzzer responsibleforinputgenerationandexecutionof 440icse may pittsburgh pa usa james kukucka lu s pina paul ammann and jonathan bell confetti coordinatorwhitebox analysis knarr greybox fuzzer smt solver2 interesting input analyze new input constraints taint flows solve negated constraints6new inputs7 new input s hints for original input 1generate and execute inputs figure3 overviewof confetti sapproachtoprovidewhiteboxhintingtoagreyboxfuzzer.
thefuzzerrepeatedlygeneratesand executes inputs considering any hints that hit has received so far to guide its generation circlecopyrt.
for each input that the fuzzer creates that is deemed interesting for generating new coverage it circlecopyrtsends that newly generated input to the confetti coordinator which in turn circlecopyrtsends the newly generated input to the knarr client in order to circlecopyrtperform a whitebox analysis and collect constraints.
if there are constraints theconfetticoordinator circlecopyrtnegatesconstraintsandsendsthemtothesmtsolverto circlecopyrtgeneratenewinputs.regardlessofthe smt result the confetti coordinator also extracts taint tracking derived hints from string comparisons in the constraints.
the coordinator circlecopyrtreturns the hints and any new smt derived input s to the fuzzer and the cycle continues.
thetargetprogram theknarrprocess responsiblefordynamic taint trackingand constraintcollection on interestinginputs and the confetti coordinator responsible for transmitting inputs between the two aforementioned processes and for using an smt solver tofeedconcolic execution.this designhastwomainbenefits.first itusesseparateprocessesforcomponentsthatexecute the program under test with different incompatible instrumentations collect taint and constraints knarr or simple branch coverage fuzzer .second itallowsthewhiteboxanalysistotake placewithoutdelayingthefuzzer whichcontinuestomutateinputs unimpeded by constraint collection and analysis.
the confetti coordinator thus acts as a broker for inputs being passed between knarr and the fuzzer receiving interesting inputs from the fuzzer andforwarding themto knarrforfurther analysis.similarly the confetti coordinator manages constraints that are computed by knarr negating and solving them in the smt solver.
similar to prior work such as angora the confetti coordinatorisnotnotifiedofeachmutation executionthatthefuzzer performs but instead only of each input that the fuzzer finds interesting e.g.
each input that reaches new coverage .
focusing on interestinginputshastwoimportantconsequences.first knarr executes a small number of inputs and does not lag behind thefuzzer.
second this mitigates the path explosion problem since knarr executes concretely paths known to reach new coverage andthefuzzerultimatelyselectswhichhintstotake.inthisway confetti leverages the speed of the fuzzer at generating inputs and the power of the whitebox analysis.
our implementation of confetti extends the jqf zest parametric fuzzer and extends our phosphor dynamic taint tracking engine for constraint collection.
our prototype interfaces uses the green library as a bridge to constraint solvers allowingittobeagnosticofthesolverused.inpractice we use the mature z3 theorem prover which worked well in our experiments.
future workmight consider other constraint solvers perhaps using newer java apis like javasmt3 .
.
knarr collecting whitebox guidance knarruses dynamictainttracking totracehoweachbyteofthe parametricinputflowsthroughthegeneratorintoageneratedconcrete input and then through the application under test.
dynamictaint tracking is an automated analysis that allows tools to taint somevariable s andthen at anypointintheprogramexecution identifyifavariableisderivedthroughdataflowfromthatoriginal tainted input.
knarr instruments the system under test including the generator that drives the application to perform this analysis.
recallfromsection2thataparametricfuzzerrepresentseachinputasaseriesofrandomchoicesconsumedbyageneratorprogram.
totaintthegeneratedinput wemodifythefuzzertotainteachbyte oftheparametricinputthatisconsumedbythegenerator.by this we are able to propagate taint tags through the parametric inputtotheconcretegeneratedinputandbeyond.mostgenerators require no changes the only modifications that confetti may requiretothegeneratorareforstringgeneratorsthatselectinga randomitemfromapre defineddictionary.forexample suchagenerator might have logic along the lines of result dict choice dict.length where choiceis a random integer and dictis a pre defined list of strings.
confetti requires these generators to berewrittentocallahelperfunction alongthelinesof result confettihelper.stringfromlist choice dict .
this helper function will propagate the taint tag from choicetoresult since array indexing is an implicit flow and will allow confetti to decidetouseahint whichmaynotbedefinedinthedictionary or to choose an item from the dictionary.
knarr tracks taint tags for each variable and for strings tracks taint tags at a per character level.
knarr tracks common stringoperations like equalsandstartswith so that it can represent theseoperationstothesolver.whenexecutingthegeneratorand theconcreteinput knarrrecordsthetainttagofvaluesusedin branch predicates.
knarr sends this data to the confetti coordinator that can then connect individual bytes in a given parametric input to conditions guarding branch edges not yet covered.
instead of using a simple traditional taint tag of tainted or nottainted knarrenhancesthetainttrackingenginetobuildan abstract expression for each variable to use as the taint tag again a technique inspired by angora .
for instance given the code int x y z and assuming that yandzwere tainted inputs an off the shelf taint tracking tool would typically set x s taint tag to betheunionof yandz stags.instead knarrtrackstheabstract expression that generated the value in this case that x y z .
in this way x s taint tag becomes the symbolic expression y z.
441confetti amplifying concolic guidance for fuzzers icse may pittsburgh pa usa when a tainted input reaches a branch the taint tag of the branch condition is then the complete symbolic expression that relates the parametric input byte to the branch condition.
whenknarrdetectstainteddatabeingusedinabranch itadds theconstraintsinthetainteddatatothecurrent pathcondition.the pathconditionisthustheconjunctionofalltheconstraintsobserved tocontrolbrancheswhileexecutingoneinput.afterexecutingeach input knarrcollectsallconstraints inthecurrentpathcondition and sends them to the confetti coordinator which uses those constraints to generate new inputs and hints for the fuzzer.
.
confetti coordinator and hints using the constraints collected by knarr confetti coordinator derives three kinds of targeted hints smt solver derived hints stringcomparison derivedhintsandcharactercomparisonderivedhints.confetticoordinatorprovidesthesetothefuzzer as targeted hints and as explained in the following section thefuzzer will derive a set of global hints from these targeted hints.
confetti coordinator leverages an smt solver in the style of concolic execution in order to generate new inputs that are likelytorevealnewbranchcoverage.whileinprinciple confetti coordinatorcouldattempttonegateandsolvealluniquebranch conditionsinordertoattempttoexploreallpaths inpracticewe foundthatconcolicexecutionwasmostusefultotargetbranches that could not be covered by the fuzzer.
as knarr executes inputs andcollectspathconstraints confetticoordinatorkeepstrack of which branches have not been fully explored.
confetti s concolic execution thread works by first selecting a branchtotarget onethatisnotfullycoveredandwhosepredicate includes at least one value from the input.
then confetti selects oneoftheinputsthatreachesthebranchandnegatestheconstraints applied by that branch s predicate.
confetti drops constraintsfromthe inputthatoccurredafterthisbranchexecution sinceit mightbeunsatisfiabletoretainthemwhilealsonegatingthetargetbranch sconstraints.then confettiusesansmtsolver z3 to generate a new parametric input that takes the other side of the branch.
if satisfiable the solution is then translated into a new hinted input that can be immediately executed by the fuzzer.
if thesolverdeemstheconstraintstobeunsatisfiable ortimes out confetti marks that combination of input and branch as already tried and moves on to the next target branch.
after attempting to generate inputs for all uncovered branches once confetti loops around to try each uncovered branch again this time picking a new input.
confetti records solver related statistics howoftenabranchwastargetedforsolvinghowoften each input was tried to solve for that branch and the result of that solvercall.somebranchesmayneverbesatisfiable duetolimitations in constraint tracking or solving e.g.
usage of floating point operations and perhaps become a waste of solver time.
we found thatmostbranchesthatcouldbesolvedforwereoftensolvedon oneofthefirstfewinputsattempted andaddedauser configurable threshold to blacklist particular branches that repeatedly were not satisfiable defaulting to attempts.
sinceconfetti sgoalistoprovide guidance toafuzzer andnot necessarily perform complete concolic execution it also provides very lightweight taint tracking derived hints to the fuzzer.
confettiextractscomparisonsbetweeninputvaluesandvariousstringvalues regardlessofwhetherthosecomparisonscontrolbranches arecovered.foreachofthesestringcomparisons confettiprovidesthefuzzerwithatargetedhinttosettherelevantbytesofthe input to the value that was compared to.
sinceknarrtrackstainttagsoneach character ofeachstring itisalsopossibleforconfettitoderivehintsfromcomparisons between individual characters of strings.
to mitigate the explosion ofhintsresultingfromsuggesting everypossiblecharacterthata given input is compared against confetti limits the total number of character hints suggested for each targeted branch to .
.
parametric fuzzer guidance confetti s core novelty over prior work is in how it integratesthose results with the fuzzer.
state of the art fuzzers that integrateguidancefromdynamictainttrackingand orpathcon straint solving like angora driller vuzzer and others provide targetedguidancetothefuzzer.for instance taint tracking might be used to determine which bytes of theinputcontrolbranchesthatarenotyetcovered andthenthe fuzzer might be guided to generate a particular input to cover that branch.confettiusesseveraltargetedhintingstrategiesbasedon prior work in addition to its novel globalhinting strategy.
when mutating an input confetti extends the fuzzer with the following new mutations apply a single targeted hint applymultipletargetedhints simultaneously or3 performnormal mutation which might apply global hints targeted hints represent the state of the art approach to integrate taint tracking and constraint solving with fuzzing if knarr determinesthatthereisaparticularvaluethatshouldbetriedat a particular positionin an input then thatvalue is applied to that offset.
targeted hints are always applied withoutfurther mutation of the input since the hints were collected on the original input beingmutated anarbitrarychangetotheinputmightinvalidate the usefulness of those hints.
when the fuzzer selects an inputformutation andtherearetargetedhintsthathavenotyetbeen applied withacoinflip oneofthosetargetedhintsisapplied.afteran input is selected for mutation repeatedly eventually all targeted hintswillbetried andthenthismutationwillnolongerbeavailable for this input.
if a single hint isn t applied then the fuzzer might apply multiple targeted hints simultaneously.
in either case confetti inserts instructions in the input to use the hinted value rather than whatever value would have otherwise been chosen by the generator at that targeted position.
each time that a targeted hint is applied to an input that hint valueissavedinaglobalhintset enablingconfetti spowerful globalhintingmechanism.thisglobalhintsettracksallstringsthat any input string was compared to during the fuzzing campaign.
at anycallinthegeneratorthat couldconsumeatargetedhint weadd a coin flip to determine whether the global hint set should be used orthegenerator snormallogicshouldbeused.bymutatingthebits that control this decision the fuzzer can control the application of global hints at each position.
in our evaluation we found that this seemingly simple strategy was very effective at generating new coverage revealing inputs and in revealing new bugs.
a key aspect of confetti s hinting implementation is that it ensuresthathintsare inheritable ifaninputwithtargetedorglobal hintsisdeemeduseful saved andfuzzedlater assumingthatthe 442icse may pittsburgh pa usa james kukucka lu s pina paul ammann and jonathan bell choices to generate those hinted values aren t mutated then the same hints will be applied in the same position.
this allows thefuzzer to make progress towards generating increasingly morecomplex inputs by stacking multiple hints together.
we did not perform any hyper parameter tuning to optimize the probabilities ofapplyinghintsbasedontheiroverallperformance althoughin section .
we report on the success rate of each mutation strategy.
evaluation in order to empirically evaluate confetti and in particular its novel global hinting strategy we measured its effectiveness across asuiteofbenchmarkprograms.ourevaluationisprimarilyfocused on answering the following research questions rq1 how does confetti compare to the baseline fuzzers in terms of branches explored?
rq2 does confetti find bugs that the baseline fuzzers cannot?
rq3 howusefuliseachof confetti shintstrategiesfordiscovering new coverage revealing inputs?
rq4 caninputswithconfetti sglobalhintsbereplacedwith statically derived values and still yield the same coverage?
weevaluateconfettiincomparisontothestate of the artparametricfuzzerjqf zest andusethesamesuiteofbenchmark programs giventhatwebuiltconfettiontopofjqf zest.where possible we used the latest version of the target software that still contained the bugs detected by jqf zest in the original work.
following best practices we study both confetti s ability to explore programbranches e.g.
coverage incomparisontojqf zest and its ability to find new and previously known bugs .
in order to precisely evaluate the efficacy of confetti s global hintingstrategy wealsoevaluateconfetti scoverageandfault finding ability in comparison to a baseline confetti tgt which is exactly the same version of confetti but with global hints disabled.however there maybea varietyof confoundingfactors thatalsoimpactconfetti tgt soverallperformanceinthisheadto head evaluation.
for instance the fuzzer s scheduling algorithm thatallocatesmutationtimetoandchoosesthemutationstoapply on inputs likely interacts with factors that influence the coverage of each input like hints.
to isolate the impact of global hints we also analyzed each of the coverage revealing inputs that confetti generated looking to determine whether or not those inputs could have been generated without global hints.
weconductedallofourexperimentsonamazon sec2infrastructure using r5.xlarge instances with .1ghz intel xeon platinum8000cpusand32gbofram runningubuntu16.
xenial and jdk .
.0 241. following best practices we conducted each experimentfor24hoursandrepeatedthis20timesaveragingthe results .
the input generators used in our evaluation are extensionsoftheopensourceinputgeneratorsthatwerepublishedby thejqf zestauthorswithinjqfitself .themodificationsmade to the generators for constrainttracking and hinting are minimal amounting to approximately two lines of code in the xml document generator approximately four lines of code in the javascript code generator and approximately ten lines of code in the java classfile generator.wealsomodified themavenpom.xml generator thecodeprovidedbythejqf zestauthorswasmisconfigured and hence unable to generate high coverage pom.xml files.
ourmodification to the maven pom.xml generator was merged intothe upstream codebase .
otherwise we used the generators as provided by the jqf zest authors without modification.
.
rq1 evaluating fuzzer coverage most fuzzers including jqf zest and afl consider coverage of allcode inboththeapplication scodeanditslibraries todetermine whichinputstosave sinceaninputthatcoversnewlibrarycode might be closer to covering new application code.
following the methodology of padhye et al.
s jqf zest we analyze and report coverage overall and also for application code specifically.
figure visualizes the branch coverage of allcode not only thesystemundertest ofeachofthe20executionsofeachofthe benchmarkprogramsforeachfuzzerduringthedurationofeach hour campaign.the solidline representsthe averagecoverage across each of the executions and the shaded area represents thecompleterangeofcoverage.wealsocalculatedthe totalbranch coverage for each fuzzer over all of its runs this time usingthestandardcodecoveragetooljacoco andreportingonly branches in the program under test covered by any input from any a apache ant15002000 b apache maven c google closure20002500300035004000 d mozilla rhino campaign time minutes branch probes covered e apache bcel figure rate of new branch discovery for each fuzzer jqf zest shown in red confetti in blueand confettinoglobalhintsin black.
the solid line shows the average coverageacrossall20runs andtheshadedareashowstheentirerange.
all charts have the same axis labels as bcel.
443confetti amplifying concolic guidance for fuzzers icse may pittsburgh pa usa table summary of results for rq1 and rq2 branch coverage and bugs found.
coverage in this table includes onlycoverage of applicationcode nolibrarycoverage .totalbranchesshowsthenumberofbranchesconsidered branchcoverageisshownaggregated acrossall20runsforconfetti thebaselinejavafuzzerjqf zest andconfetti tgt confettiwithtargetedhintsbutwithoutglobalhints .
total branch coverage bugs found benchmark program version total branches confetti jqf zest confetti tgtconfetti jqf zest confetti tgt apache ant .
.
apache maven .
.
apache bcel .
google closure mozilla rhino .
.
of the runs.
table shows the total branch coverage of each fuzzer along with the number of branches considered for coverage.
for all fuzzing targets confetti s average branch coverage surpassedthatof confetti tgt whichsurpassedthatofjqf zest.
rhino scomparisongraphismuchtighterthantheothergraphs withagreatdealofvarianceforboth confettiandconfetti tgt whencomparedwiththatofjqf zest andthemaximumcoverage ofjqf zestwasgreaterthanconfetti.diggingdeeperintorhino wecanseefromtable1that intotal jqf zestexplored13more application branches than confetti.
this variance is likely due to theadditionalchoicesthatconfettiintroducesinthegenerators namelybyincreasingthesizeoftheglobaldictionary orbyhavingseveralhintstochoosefromattargetedbytepositions.withfurther andlonger trials wesuspectthatthisvariation anddiversity may helpconfettitoultimatelyachievehighercoveragethanjqf zest.
we also believe that future work could improve the efficacy of the generator for rhino.
for maven bcel and closure confetti s improvement in branch coverage over jqf zest was quite notable.
it is interesting to note that in the case of coverage bcel our baseline without global hints confetti tgt slightly outperformed confetti.
howev er confettioutperformedconfetti tgtboth in terms of total coverage figure and bugs found supporting ourhypothesisthatglobalhintsareausefulstrategyforcombiningconcolicguidancewithgreyboxfuzzing.webelievethelimitedvariability in bcel is due to jqf zest s java class file generator which wedeliberatelydidnotmodify.inparticular itgeneratesmethod bodieswithveryfewinstructions greatlylimitingthechancesof exercising complex behavior in the target.
nonetheless confetti still outperforms jqf zest on this target which shows that even with restrictive generators confetti still improves performance.
.
rq2 bugs found we analyzed each failure detected in all twenty hour runs and reported each unique program crash as a bug in table .
in order tode duplicate bugs weutilize aheuristic ofexamining the first lines in a stack trace to identify a unique bug as well asmanual analysis after applying this heuristic.
this methodology clusters more bugs together than prior work of stack hashing as the higher levels of the stack tend to isolate the locality of aparticular bug.
using this methodology we replicated the same 10bugsthatpadhye etal.reportedinjqf zest withevengreater frequencyinsomecases plusoneadditionalbuginclosure likelyfoundduetoperformanceimprovementsthatwemadetojqf zest described in section .
ofthose11bugsthatjqf zestfound confettifoundallbutone initstwenty24 hourruns issueb1inthetable .again weattributethistoadditionalchoicesthatconfettiintroducesinthegenerator which clearly can result in a diversity of paths explored.
this is evident in bcel particularly as confetti finds four additional bugsthatjqf zestdoes not.theadditionofthesechoicesmakes bugsthatarerepeatablewithlowfrequencyevenlesslikelytobe triggered within a single run.
we suspect that tuning the rate at whichhintsareselectedcouldincreasethelikelihoodthatconfetti detects bugs like this but leave such investigation for future work.
ofthose25bugsthatconfettifound werepreviously unknown theresthadbeenfoundpreviouslybyjqf zestorothers.
table shows that of the bugs that confetti detects there is a clear range of detectability with some bugs detected on mostfuzzing runs and four detected at the i.e.
level.
this distribution supports our hypothesis that supplying global hints table bug detectability rate from executions of each fuzzer.if multiple unique bugs had the same repeatability rates they are included in the same row c14 c15 and r1 r2 r3 r4 .
unreferenced issues were not reproducible in latest version of software.issuesreferencingjqf zest werepreviouslyfoundand reported by the authors of jqf zest.
program issue jqf zest confetti confetti tgt ant a1 bcel b1 bcel b2 bcel b3 bcel b4 bcel b5 bcel b6 closure c1 closure c2 closure c3 closure c4 closure c5 closure c6 closure c7 closure c8 closure c9 closure c10 closure c11 closure c12 closure c13 closure c14 c15 rhino r 444icse may pittsburgh pa usa james kukucka lu s pina paul ammann and jonathan bell to the fuzzer can pay off even though many of the hints tried at eachpositionofeachinputmaybeirrelevantfordetectingabug someofthemdo.giventhatthedesignofthefuzzeristoexecute as many inputs as quickly as possible a diversity of hints can lead to a greater diversity in coverage and a diversity in bugs found.
wefoundthat6ofthe16newlydiscoveredbugshadalreadybeen foundandpatchedinthemostrecentdevelopmentversionofthe respectivefuzzingtargets anencouragingsignthatdevelopers care about the kinds of bugs that confetti can find.
we reported theremaining10bugstothedevelopers andattimeofwriting4 bugs in closure have been fixed by developers and have been acknowledged bugs in bcel are awaiting acknowledgment.
the closuredevelopersfoundthebugsdiscoveredbyconfettitobe quiteinteresting andintheirinvestigationofissuec11 founda separate butrelated bugthattheyhavealreadyfixed .thisisa testamenttoconfetti sabilitytofindtrulyunexpectedbehaviors thereby revealing latent software errors and contributing to the betterment of software quality.
we describe several of the newly foundbugsheretoprovidesomemoreintuitionintoconfetti s performance.
inmanycases confettifoundthesebugsthankstotainttracking finding special strings like arguments jscomp.reflectpropertyandgoog.reflect.objectproperty .
it is likely that these strings would trigger these bugs in both the confetti and confetti tgtruns.thisisshownintheresultsintable2 inwhichthere are a subset of bugs that confetti and confetti tgtdo find with similar frequency that jqf zest was not able to find issues c4 c5 c8 .
bugs c4 and c5 are interesting but technically could have also been detected at the same frequency if the strings arguments and goog.reflect.objectproperty were in the fuzzer s dictionary.
issue c7 presents an example that could not be detected with a dictionary.
jscomp isusedasaninternalconstantthatclosure compiler uses to construct internal aliases for arguments to functions.bysupplyingboth inner jscomp andinnerasarguments to a function the compiler throws an exception because it tries to constructamapofargumentnamesandif inner jscomp issuppliedasthefirstargument itwillfailtoinsertthesecondargument name leadingtoa runtimeexception .notethat inthiscase no dictionary based approach could detect this bug as the bug is only triggerediftwoargumentsarespecified withthefirstargument matching the second argument plus the suffix jscomp .
several bugs were detected only by confetti s global hinting strategy c6 c8 c11 c15 .
for example consider issue c11 which confetti was able to find in of runs while confetti tgtand jqf zest were unable to find it.
a simplified input exercising this bug is goog dom tagname 88a .length this .
the string goog dom tagname 88a was extracted via taint tracking and added to the global dictionary.
later in the fuzzing run the generator decided to use it as the left handexpression of an addition assignment operator.
during an opti mization pass the compiler is unable to satisfy the preconditionthat goog dom tagname 88a .length matches the type ofthisandthrowsanexception.exercisingthisbugwouldnotbe possible without the decoupling of string hints to their respective parametric byte input positions.
in closure this proves to be very successful in finding new bugs.in bcel global hints led to the discovery of two bugs that only confettiwasabletofind issuesb3andb4 .ofthebugsthatonlyconfetti and confetti tgtfound b5 and b6 confetti was able to find them with repeatability across the experimental runs.
this suggests that global hinting is a powerful technique for revealing bugs with a high rate of repeatability within bcel.
.
rq3 efficacy of hint strategies whileconfettiruns italsocollectsbasicstatisticsontheinputs generated whichstrategieswereusedwhengeneratingeachinput and which inputs were saved to the fuzzing population.
recall thatjqf zest likemanyothergreyboxfuzzers savesaninputto its population for later fuzzing if the input reveals new branchcoverage or if it increases the hit count of a previously coveredbranch by an order of magnitude.
since inputs are derived from existing inputs it s possible that a single input has benefited from multiple hints and multiple kinds of hints.
the left side of table shows the total number of inputs generated acrossall20runs alongwiththesuccessrateforthetargeted hint strategies smt char string for the global hint strategy andoverall for random mutation.
some observations from this portion ofthetablearethatsmtandcharmutationsarerelativelyeffective thatis theyareseveralordersofmagnitudegreaterintheirsuccess.
however despite this these strategies are rarely employed com pared to the other mutation strategies due to smt solving beingexpensive and or finding certain paths to be unsatisfiable or in thecaseofcharhints simplybeingencounteredinfewerplaces thanstringcomparisons.theothermutationstrategies string global and random generate several orders of magnitude more inputs as they leverage the throughput of the underlying greybox fuzzing framework upon which confetti is built.
string mutation strategiesareparticularlyeffectiveingoogleclosure andglobal mutationstrategiesareanorderofmagnitudemoresuccessfulin closure than in any other target application.
however simply considering the success rate of each hint strategy does not adequately capture its overall efficacy.
for example if coverageisquicklysaturatedduring thefuzzingrun aswefound inthecaseofmaven nomutationstrategywillbesuccessful since there is no new coverage to find.
success rates can also be misleading because they do not capture how frequently a kind of hint isavailable to be tried again particularly notable for smt inputs nor how often a hint is inherited by multiple derived inputs.
therightsideoftable3presentsananalysisofeachoftheinputs thatweresavedbyconfetti.thismetriccapturesbothhowoften a hint is available and also how often a hint is inherited by a child input.notethatsinceasingleinputmighthavemultiplehints andmultiplekindsofhints thesumofthenumberofsavedinputswith each form of hint may be greater than the total number of savedinputs or fewer in the case of rhino where some saved inputs hadnohints .ofthetargetedhintstrategies wecanseethatwhile smt and char targeted hints had the highest success rates they are represented by only a relatively small proportion of the saved inputs.
since the fuzzer can generate and test inputs extremelyquickly running up to several thousand inputs per second it spossible that inputs that couldhave been generated by the smt solver were instead first generated by chance perhaps thanks to a differenthint.thereisaninterestingexceptiontothisinthecase 445confetti amplifying concolic guidance for fuzzers icse may pittsburgh pa usa table hint information for each new saved coverage revealing or hit count increasing input aggregated across runs.
theleftsideshowsthesuccessrateofeachmutationstrategyincreatinginputsthatrevealnewcoverage.eachsavedinputmighthave multiple hints the right side reports on the number of saved inputs with each kind of hint including inherited hints .
total inputs generatedsuccess rate of mutation strategy total inputs savedwith targeted hints with global hints program smt char string global random smt char string ant .
.
.
.
.
bcel .
.
.
.
.
closure .
.
.
.
.
maven .
.
.
.
.
rhino .
.
.
.
.
of bcel as the number of saved inputs for smt targeted hints and string targeted hints are the same magnitude.
bcel is unique among the applications that we studied in that its input java class files isaformatthatcontainsbothstrings andbinarydata.smttargetedhintsparticularlyexcelatcoveringnewbranchesthatrely on specific magic bytes as opposed to strings.
perhapsthemostinterestingtakeawayfromthesestatisticsisthe enormousproportionofsavedinputsthatcontainglobalhints.this isencouragingevidencethatsupportsourhypothesisthatglobal hints are a useful form of guidance for fuzzers.
however simply becauseaninputwassavedwithaglobalhintdoesn tmeanthat this input needed that hint in order to produce the same coverage and be saved it is possible that the hint is coincidental to the coverage and that another string could have also resulted in the same coverage.
we investigate this idea in greater depth in rq4.
.
rq4 analysis of inputs with global hints rq1andrq2showthatusingglobalhintscoversmorebranches andfindsmorebugs.rq3showsthekindsofhintsininputsthat are saved i.e.
are coverage revealing showing that most of those savedinputsincludeglobalhints.however itishardtoconclude thattheglobalhintsarenecessary maybea randomly generated input could have revealed that same coverage how do we know thattheglobalhintwasrelevanttorevealingthiscoverage?with rq4 werq4examinethisconcerndirectly studyingthelikelihood that a random fuzzer that also benefits from targeted hints could generate an input that reveals the same coverage as the input that confetti generated using global hints.
foreachinput iacrossallofconfetti srunsthatrevealednew coverage andhadglobalhints wetooktheparentinput p thatwas mutated by confetti into i and fuzzed it times using both randomgenerationandtargetedhints observingthecoverageof thoseinputs.
000iterationsisanorderofmagnitudemorefuzzing iterationsthanzestwouldapplyinasinglecycle whichwebelieve providesareasonableupper boundofthelikelihoodofthefuzzer withoutglobalhintsgeneratinganinputthatrevealedthatsame coverage.
if the fuzzed input never produces the same coverage then we may have some confidence in the hypothesis that for that input global hints were necessary to achieve the same coverage.
thisallowsustodistinguishbetweenglobalhintsthatareclearly unnecessaryandthosethatmighthavebeenusefulforrevealing new behaviors during the fuzzing campaign.
table4showsthenumberandpercentageofsavedinputsthat haveglobalhintsthatcouldbereplicatedwithoutthoseglobalhintstrivially onthefirsttry eventuallywithinthe1 000runs andneverwithin the runs.
on ant bcel maven and rhino the majority of saved inputs can be replicated without global hints trivially.
thisindicatesthat intheseapplications formostoftheglobal hintcontaining inputs that revealed new coverage the global hint s were definitely not necessary to produce that same coverage.
however wenotethatthesurvivinginputsinthe never columnare still roughly comparable to the number of targeted hints shown in table .
this is perhaps evidence that global hints are at leastas effective ofa strategyas targetedhints inrevealing newcoverage.
closure is the one exception to this trend in which over ofsavedinputscannotbereplicatedwithoutglobalhints.thisis likely due to the high rate of implicit flows within closure itself.
a commonpatternthatwefoundinclosureisthatalloccurrencesofthesameidentifiernameinaninputaremappedtothesameobject inside of the compiler losing the precise mappings from eachoccurrence of that identifier in the input.
many of the bugs that only confetti was able to find in closure have similar properties.
our overall conclusion from this analysis is that confetti s novel combinationofbothglobalandtargetedhintsismoreeffectivethan using only targeted or only global hints.
.
data availability ourartifactcontainsthesourcecodeanddependenciesforconfetti our scripts to run experiments our modifications to jqfand jacoco and all data produced by our experiments .
to encourage re use confetti is released under the bsd clauselicense and our github repository has a continuous integration workflow to run performance evaluations of pull requests .
table4 post mortemanalysisofallsavedinputswithglobal hints.for each input we remove all global hints and attempt to replicate the same coverage by replacing the global hints with random strings from the fuzzer s dictionary.
we show the number ofthoseinputswithcoveragereplicabletrivially onthefirsttry eventually within tries and never within those tries.
saved inputs replicated without global hints program trivially eventually never ant .
.
.
bcel .
.
.
closure .
.
.
maven .
.
.
rhino .
.
.
446icse may pittsburgh pa usa james kukucka lu s pina paul ammann and jonathan bell discussion and threats to validity reliablyevaluatingfuzzersisdifficult sincetheprocessisnondeterministic.
we mitigated this risk by following best practices we ran our experiment times and reported in table only bugs found at least once in those runs .
confetti might have different performance on other programs we used a benchmark offuzzingtargetsusedbypriorwork .ourtoolsanddataare available for others to replicate and expand on.
while our approach should be language agnostic we have only implementedittargetingprogramsthatruninthejvm.webelieve that the confetti s approach could even be used for programs writteninc asshownbyrecentsourcecodeinstrumentation based approachestoconcolicexecution .whilewearehopefulthat global hinting will be as significant of a hint strategy for other fuzzers like afl or libfuzzer it is possible that there is hidden couplingbetweenthesuccessofglobalhintingandthedesignof the particular fuzzer that we extended jqf zest .
like most other fuzzers itwillbedifficulttoapplyconfettitostatefulapplications in which separate inputs are related.
pairing confetti with a checkpoint rollback system could ensure high fidelity fuzzing.
itisinterestingtoconsiderwhypriorgreyboxfuzzersthatleveraged taint tracking or concolic execution used it only for targeted guidance.
onehypothesis is that inother languages itis difficult toidentifybytesthatareusedtorepresentstrings versusbinary data.
however popular fuzzers afl and libfuzzer both already leveragestatically deriveddictionaries .hence perhapsitis more likely that our approach of global hinting simply hasn t been tried yet due to the concern that the global hint set would growto such a large size to become unmanageable.
our experimental results seem to support the idea that including more strings in the global hint set including those that may not be useful is more beneficial than only considering targeted hints.
even if our results do not generalize to other languages we note that confetti is theonlyconcolic guidedjvm basedfuzzer andhenceourfindingsstillhaveasignificantimpactforanysoftwareengineersorresearchers interested in fuzzing jvm based code.
we did not carefully explore the configuration space for confetti and it is possible that its performance could increase or decreaseonsomeorallfuzzingtargetsbasedontunableparameters suchasthefrequencyatwhichhintsareapplied.webelieve that this could be interesting future work but feel that such an evaluation is outside of the scope of this paper.
like jqf zest confetti assumes the availability of generators to exercise the programs under test.
we do not see this as a significant limitation however due to the popularity of generator based testingtoolslikejqf scalacheck andjunit quickcheck .
furthermore our evaluation used only the pre existing generators that were used in the original evaluation of jqf zest .
one hypothesis for the success of global hinting in our experimentsis that the pre existing generators were overly restrictive in the values that they could generate and global hints provided a means togeneratemorediverseinputs.inthislight confettimightbe seen more as an approach to automatically improve the quality of existing generators bypassing these restrictions.
while we havenot yet been able to design an experiment to confirm this result we now believe quite strongly that future research in fuzzing jvmbasedapplicationsshouldfocusoneitherapproachestoevaluate and improve developers existing generators and property tests or to design new approaches that do not rely on those generators.
while we have very carefully tested our prototype implementation of confetti it is possible that our evaluation is affected by bugs that remain in confetti or any of the other systems that we used including jqf zest jacoco and phosphor .
we analyzed thefuzzing resultsof both confettiandjqf zest quitecarefully conducting thousands of short debugging runs using jacoco to analyzethecoverage orlackthereof ofparticularbranches.we note that in addition to our own implementation bugs that we foundandpatchedinconfetti wealsofoundseveralbugsinjqfzest and jacoco.
for example we found that jqf zest s coverage implementation did not correctly distinguish between the multiple cases of a single switch statement and was generally prone to frequent collisions where multiple branches used the same coveragecounter.theseissuesresultedinjqf zestdiscardingmany coverage revealinginputs ratherthansavingthemandmutating them further.
weimplemented a newbranch coverageinstrumentation and runtime for jqf zest that eliminated these collisions while also improving the fuzzer s execution speed by 10x.
we used this enhanced coverage in our evaluation of jqf zest and submittedthischangeasapullrequesttothejqf zestmaintainers who are excited to merge it in to their next release .
as part of this jqf zest debugging we also found a bug in jacoco that could cause branches to appear uncovered if the first statement enclosed by the branch was a method invocation which threwanexception.tracingprecisebranchcoverageinthepresenceofexceptionalflowrequiresplacingprobesbeforeandafter anyinstructionthatmightthrowanexception whichcandecrease performance and hence this may not be desirable as a general feature.afterconsiderablereflection wedeterminedthatthisbehavior was acceptable within the scope of what jacoco aims to detect and did not submit these changes to the jacoco developers.
however ourbranchofjacocowiththepatchforthisissueisin our artifact .
to help support future research and development of confetti jqf zest andrelatedfuzzers wehavecreatedandsharedagithub actionsworkflowthatautomaticallyexecutestheentireevaluation that is described in this paper.
we have found this workflow to be extremelyusefulinourdevelopment.forexample whendebugging amemoryleakinconfetti wecouldeasilylaunchmanyparallel experiments collect metrics andcompare performance across branches.
this workflow was also quite useful in our development of the faster collision free coverage implementation for jqf zest whichallowedustoeasilycreateandshareperformanceevaluation results in our pull request .
related work inclassicdynamicsymbolicexecution forinstance asproposed byklee orjpf se programsareexecutedsymbolically by a special purpose interpreter.
concolic execution executes a programconcretely butusesruntimesupporttocollectpathconstraintsastheyrelatetotheinput thenlaternegatessomeofthese constraints solves them using an smt solver and executes thenewly generated input .
hybridizing concolic execution 447confetti amplifying concolic guidance for fuzzers icse may pittsburgh pa usa andrandomtesting fuzzingwasfirstproposedbymajumdarand sen .thisworkshowedthatoncefuzzingsaturatescodecoverage concolic testing can help to discover new program states that randomtestingdidn totherwisefind.morerecentworkhasalso exploredhybridizingconcolicexecutionwithfuzzing but confetti is the first work to use the global hinting strategy to integrate concolic guidance with fuzzing.
fuzzing parsers for well structured human readable input is challenging.
one line of research aims to guide a fuzzers with a grammar that describes the input structure .
for instance skyfireusedgrammarstogeneratewellformedinputs as seeds for afl and superion integrated the grammar with afl .
such input grammars are required to be context free whichlimitstheirapplicability.
toaddressthislimitation previous work focused on learning tree models or probabilistic contextsensitivegrammars fromacorpusofvalidseeds.incontrast confetti s generators are small programs that can generate sophisticatedinputs e.g.
anyvalidjavascriptprogram withoutthe restrictions of context free grammars.
manyothersystemsalsocombinesymbolicorconcolicexecution with fuzzing .
perhaps most similar to confetti is angora which like confetti also uses taint tracking to collect path constraints .
confetti differs from these prior systems in that it records strings generated by concolic executionas globalhints allowingthesemagicvaluestobeusedin elsewhere in the same or other inputs.
in our evaluation we found that this strategy accounted for most of the coverage revealing inputs found by our fuzzer.
these global hints are effectively a dynamicallygenerated fuzzingdictionary fuzzerslikeafl libfuzzer andjqf zest allallowdeveloperstospecifya pre defineddictionaryofstringsthatmightbeinterestingtouseinfuzzing.inourevaluation allfuzzerswereseededwithdictionaries by jqf zest s original authors providing a realistic representation of the dictionaries that a developer would create.
similarly confetti is not the first approach to combine taint trackingwithfuzzing.likeconfetti vuzzercombinestainttracking with fuzzing in order to target the fuzzer and determine magic bytes .
buzzfuzz uses taint tracking to identify which input bytes that flow into targeted branches and then modifies thosebytes directly .
similarly taintscope uses taint tracking to identify inputs that flow through checksum like routines and attemptstouseasymbolicrepresentationtoensurethatthefuzzed inputs still pass those checksums .
again confetti differs from all of this prior work in that it also introduces the notion ofglobal hints whichrepurposevaluesdetectedfromtainttracking particular bytes of one input to be used when fuzzing otherinputs.
there have also been numerous advancements in fuzzer seedselectionandscheduling mostofwhicharecomplementary to confetti and combinations of the approaches could be studied in future work.
for instance directed greybox fuzzing guides a traditional greyboxfuzzer bycasting guidanceas anoptimization problem and hence does not require whitebox guidance at all .
confetti ameliorates the implicit flow problem by loosening the coupling between values detected by taint tracking or concolic execution and the part of a particular input where that magic value should be applied.
mathis et al.
s lfuzzer addresses tainttaglossthroughimplicitflowsininputtokenizationbyautomaticallyidentifyingroutinesthatparseinputcharactersintotokens and propagating taint tags along those conversions .
like confetti lfuzzer also adds these tokens to a global dictionary to useinfuzzing.inourevaluation wefoundthatconfetti shints revealed bugs in program logic aftertokenization and parsing for instance in the optimization phase of the closure compiler outsideofthetokenizationroutinesthatlfuzzerwouldtarget.
other taint tracking based fuzzersattempt toaddress theimplicit flow problem by inferring control dependencies between branches and input bytes by comparing coverage results while mutatinginputs .
however these systems can only detect that relationship afterthe fuzzer succeeds in covering the branch.
we demonstratedthatconfetti sglobalhintscanbeusedtoreveal branchesthatthefuzzercouldnototherwise.futureworkmight combineconfettiwithheuristicsforselectivelypropagatingtaint tags through implicit flows .
whilepopularfuzzerslikeafltargetx86binaries thereremains aneedforfuzzerstargetinghigherlevellanguageslikejava.java pathfinder jpf is a model checker for java programs that usesacustom builtinterpretertocollectandsolvepathconstraints in order to explore different program states.
jpf has been a sig nificant resource for the java testing community and has been extended in many ways to support various forms of dynamic symbolic execution .
prior concolic execution tools for java like jcute catg and cinger used instrumentationbased approaches to track constraints in a limited subset of classes.
in contrast confetti uses a dynamic taint tracking system totrack path constraints and does so in all classes.
to our best of ourknowledge confettiisthefirstsystemthatsupportsconcolic execution of real world java programs like those in our evaluation.
conclusion confettiisaconcolic guidedfuzzerforjvmsoftwarethatgenerates inputs covering more branches and revealing more bugs than the existing state of the art jvm fuzzer.
through our empiricalstudies wehaveidentifiedthatconfetti snovel globalhinting mechanism yields a significant improvement in coverage and bug finding compared to the state of the art approach of targeted hinting.
although we have only explored global hinting in the context of a single fuzzer jqf zest and a single language java we believethat thereis strongevidence thatthisapproach willbe quite successful inother fuzzing domains too.based on our analysisof thefailuresthatcouldbedetectedonlybyconfetti andnotby thevariantwithoutglobalhints wehaveastrongintuitionthat thesamekindsofprogrammingpatternsthatrestricttheefficacy of targeted hints in our experiments occur in other applicationsand languages as well.
we hope that our open source release ofconfetti and its ci workflow will help to support the growingcommunity of practitioners and researchers engaged in fuzzing jvm based software .