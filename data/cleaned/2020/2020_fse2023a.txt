enhancing coverage guided fuzzing via phantom program mingyuan wu southern university of science and technology shenzhen china the university of hong kong hong kong china mail.sustech.edu.cnkunqiu chen qi luo jiahong xiang mail.sustech.edu.cn mail.sustech.edu.cn mail.sustech.edu.cn southern university of science and technology shenzhen chinaji qi the university of hong kong hong kong china jqi cs.hku.hk junjie chen college of intelligence and computing tianjin university tianjin china junjiechen tju.edu.cnheming cui the university of hong kong hong kong china heming cs.hku.hkyuqun zhang southern university of science and technology shenzhen china zhangyq sustech.edu.cn abstract for coverage guided fuzzers many of their adopted seeds are usually ineffective by exploring limited program states since essentially all their executions have to abide by rigorous dependencies between program branches while only limited seeds are capable of accessing such dependencies.
moreover even when iteratively executing such limited seeds the fuzzers have to repeatedly access the covered program states before uncovering new states.
such facts indicate that exploration power on program states of seeds has not been sufficiently leveraged by the existing coverage guided fuzzing strategies.
to tackle these issues we propose a coverageguided fuzzer namely miragefuzz to mitigate the dependencies between program branches when executing seeds for enhancing their exploration power on program states.
specifically miragefuzz first creates a phantom program of the target program by reducing its dependencies corresponding to conditional statements while retaining their original semantics.
accordingly miragefuzz performs dual fuzzing i.e.
the source fuzzing to fuzz the original program and the phantom fuzzing to fuzz the phantom program simultaneously.
then miragefuzz generates a new seed for the source fuzzing via a taint based mutation mechanism i.e.
updating the target conditional statement of a given seed from the source mingyuan wu is also affiliated with the research institute of trustworthy autonomous systems shenzhen china.
yuqun zhang is the corresponding author.
he is also affiliated with the research institute of trustworthy autonomous systems shenzhen china and guangdong provincial key laboratory of brain inspired intelligent computation china permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
with its corresponding condition value derived by the phantom fuzzing .
to evaluate the effectiveness of miragefuzz we build a benchmark suite with projects commonly adopted by recent fuzzing papers and select nine open source fuzzers as baselines for performance comparison with miragefuzz .
the experiment results suggest that miragefuzz outperforms our baseline fuzzers from .
to .
averagely.
furthermore miragefuzz exposes previously unknown bugs where of them have been confirmed and have been fixed by the corresponding developers.
ccs concepts software and its engineering software testing and debugging .
keywords fuzzing coverage guidance phantom program acm reference format mingyuan wu kunqiu chen qi luo jiahong xiang ji qi junjie chen heming cui and yuqun zhang.
.
enhancing coverage guided fuzzing via phantom program.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
introduction fuzzing refers to automatically generating invalid unexpected or random test inputs i.e.
seeds to expose unexpected program behaviors e.g.
crashes and memory leaks which can be further analyzed to detect vulnerabilities bugs of target programs.
in particular many existing fuzzers have widely adopted code coverage as guidance of their fuzzing strategies to advance bug vulnerability exposure.
typically based on an initial collection of seeds a coverage guided fuzzer develops its fuzzing strategy to iteratively generate new seeds often via mutation for increasing optimizing code coverage.
albeit many coverage guided fuzzers have been shown effective in terms of code coverage and bug exposure their esec fse december san francisco ca usa mingyuan wu kunqiu chen qi luo jiahong xiang ji qi junjie chen heming cui and yuqun zhang coverage guided strategies are still somewhat restricted to hinder their further performance improvement.
in particular the existing coverage guided fuzzing strategies typically require complete execution on each seed i.e.
exploring program states bounded by rigorous dependencies between program branches referred to as program dependencies in the rest of the paper for simplicity .
it has been widely shown that in this way many seeds are executed to only result in the limited state exploration of target programs indicating that a large number of such seeds are ineffective in exposing new program states.
furthermore even for the limited number of seeds which can effectively explore program states their iterative executions are still subject to rigorous program dependencies i.e.
incrementally exploring program states in order.
as a result the fuzzers have to repeatedly access the covered program states before uncovering new program states under each iterative execution.
such facts indicate that the seedwise exploration power on program states has not been sufficiently leveraged by the existing coverage guided fuzzing strategies.
in this paper we attempt to tackle the aforementioned limitations of the seed wise exploration power for the existing coverage guided fuzzing strategies.
our key insight is that instead of only using a limited number of effective seeds for incrementally exploring program states under iterative executions we seek to exploit more effective seeds as well as the exploration on separate program states by reducing their inter dependencies so as to enhance the efficacy of coverage guided fuzzing.
accordingly we propose miragefuzz the first fuzzer which attempts to mitigate the rigorous compliance with all inter dependencies between program states when executing coverage guided fuzzing strategies for enhancing the exploration power of all seeds.
to this end for a given target program we first derive its control flow graph and identify the conditional instruction in each basic block and all the instructions affecting it in the intermediate representation ir level .
then we relocate such instructions to their farthest dominator while preserving the original semantics of the conditional instruction i.e.
reducing program dependencies as forming a phantom program.
next miragefuzz performs dual fuzzing i.e.
fuzzing the original program and its phantom program simultaneously namely source fuzzing and phantom fuzzing .
more specifically after the source fuzzing upon a given seed s we collect the unexplored program branches adjoining the explored program states and search for any seed generated by the phantom fuzzing which can be executed to explore any of such branches.
if such a seed s exists we then identify the byte offset of scorresponding to the conditional instruction of the unexplored branch via taint analysis and further update it using the corresponding condition value derived by s to form a new seed for further source fuzzing .
eventually executing the resulting new seed can advance the exploration of the program states bounded by the corresponding conditional instruction and thus enhances the seed effectiveness on exploring program states.
to evaluate the effectiveness of miragefuzz we first collected real world projects which were frequently adopted in recent fuzzing research as our benchmark suite.
we further collected nine open source coverage guided fuzzers as our baselines for performance comparison with miragefuzz .
our evaluation results suggest that miragefuzz outperformed the baseline fuzzers significantly by13.
to .
on average in terms of the edge coverage.
moreover miragefuzz exposed previously unknown bugs where of them have been confirmed and have been fixed by the corresponding developers.
in summary our paper makes the following contributions idea.
to the best of our knowledge we are the first to propose the concept of phantom program which reduces program dependencies and perform dual fuzzing to synergize the source fuzzing and the phantom fuzzing to enhance coverage guided fuzzing.
technique.
we have implemented the proposed idea as an opensource practical tool namely miragefuzz as released in our github page .
evaluation.
we evaluate miragefuzz upon a real world benchmark with open source projects compared with nine baseline fuzzers.
the evaluation results indicate that miragefuzz outperforms all baseline fuzzers averagely from .
to .
in terms of edge coverage.
moreover miragefuzz exposed previously unknown bugs where of which have been confirmed and have been fixed by the corresponding developers.
motivation in this section we use a sample code snippet following prior work as in figure 1a to motivate miragefuzz .
specifically the functionorigin takes a character array user as input and processes it in nested branches.
note that many existing coverage guided fuzzers incrementally increase code coverage under each iterative execution.
therefore to trigger the crash on line of function origin first given an initial seed successfully exploring line it is ideal to generate a mutant which can be executed to successfully explore line under controllable effort with the resulting mutant retained as the new seed.
the above operation is then repeated for the subsequent statements until line can be successfully explored.
however the mutation space for each statement is essentially vast e.g.
for line user can be assigned with possible values while it has to be m only to successfully access its scope.
thus we can derive that the chance of a seed to explore consecutive similar statements could be rather trivial resulting in many underused seeds for fuzzing.
to summarize the exploration power on program states of a seed can be somewhat limited by applying many existing coverage guided fuzzing strategies.
we consider the key factor limiting the effectiveness of coverageguided fuzzing strategies is that they require the seeds to rigorously abide by the program dependencies i.e.
being thoroughly executed until exposing a bug vulnerability.
specifically in figure 1a the execution on one seed has to satisfy all the dependencies of line i.e.
lines to before exposing the relevant crash.
moreover the program states subject to such program dependencies even have to be repeatedly accessed under iterative executions e.g.
line has to be explored by all the iterative executions until exploring line .
therefore in this paper we attempt to enhance the effectiveness of coverage guided fuzzing strategies by mitigating the rigorous compliance with all inter dependencies between program states on performing coverage guided fuzzing strategies.
in particular a straightforward insight is to reduce program dependencies for preventing the aforementioned executions.
we can observe from figure 1a that actually the conditional statements of lines to 1038enhancing coverage guided fuzzing via phantom program esec fse december san francisco ca usa 1voidorigin char user 2user if user m if user a if user z if user e crash else ... other code return a the original code1 voidphantom char user 2user if user m if user a if user z if user e crash if user !
m ... other code return b the phantom code figure a motivation example code for miragefuzz are not related to one another i.e.
each of them can be satisfied independently the operands of line are irrelevant with line .
therefore it is unnecessary to form nested dependencies among such conditional statements.
instead we could reduce their dependencies as in function phantom of figure 1b where their respective executions are independent from each other.
for example the executions on all the seeds can easily access line to check whether the runtime value of user is e .
thus we can infer that the chance to expose the crash in line can be significantly enhanced compared with figure 1a.
such an example can be rather inspiring for how to enhance the power of exploring program states of the mutants.
specifically suppose a fuzzing campaign is halted upon line in figure 1a i.e.
it satisfies line but fails to satisfy line .
we can attempt to obtain the byte offset of the running seed corresponding to line i.e.
the branch condition user e via taint analysis.
if we could also identify a seed which can be executed to explore the same branch condition in figure 1b we could then apply taint analysis again on that seed to obtain the operand value and use it to update the byte offset of the seed running in figure 1a.
at last the resulting mutant can be executed to satisfy line in figure 1a and thus trigger the crash indicating that the power of exploring program states of the original seed is improved.
accordingly in this paper we are inspired to propose a technique which aims at reducing program dependencies for enhancing the exploration power of seeds on program states.
note that our mission in figure is seemingly close to advance the exploration of program states which many existing fuzzers attempt to tackle by proposing diverse techniques e.g.
recording the auxiliary states for program exploration depth or integrating constraint solver .
however due to the aforementioned limitation of the well adopted coverage guidance they still generate massive ineffective seeds i.e.
only limited seeds are effective to explore program states.
to illustrate that essentially is the issue we attempt to address in this paper.
approach figure shows the overall workflow of miragefuzz which consists of three components.
first miragefuzz creates a phantom program to reduce dependencies in the target program via a dependency reduction mechanism marked as in figure section .
.
next miragefuzz performs dual fuzzing the source fuzzing to fuzz the original program and the phantom fuzzing to fuzz its corresponding phantom program simultaneously section .
.
specifically during iterative executions of the source fuzzing under a given seeds miragefuzz obtains the unexplored program branches adjoining the explored program states and searches for whether any of them has been explored by a seed or multiple seeds generated from the phantom fuzzing .
at last if such a seed s exists we then update the corresponding branch condition of swith the value derived by s to form a new seed for future source fuzzing section .
.
.
dependency reduction mechanism we first derive the control flow graph cfg of the given target program and then identify all the branch instructions in the intermediate representation ir level .
next for the conditional instruction in each basic block and all the instructions affecting it we attempt to relocate them to their farthest dominator in this paper we follow prior work that in a control flow graph a block ais a dominator of a block bif every path from the entry block tobmust go through a .
in this way we essentially reduce the dependencies among program branches.
here we use the code snippets from a real world project jhead in figure with the cfg generated by llvm dot cfg pass for illustration.
in particular figure presents a total of basic blocks where trepresents that the corresponding condition is evaluated as true and frepresents otherwise.
for instance by relocating the conditional instruction bool cmp3 !strcmp arg proc of block 4in its farthest dominator i.e.
entry block their original dependency can thus be reduced.
as a result the execution on a seed can directly explore block4without exploring its original dependency with entry block 1in advance.
obviously the chance to explore block 4can be increased indicating the exploration power of seeds can be increased.
inspired by section we realize that by preserving the entry condition of each branch in the target program we can utilize the dependency reduced program to facilitate the exploration of new program states in the original program.
however relocating instructions can easily violate the semantics of the original program branches i.e.
the entry condition of a program branch .
for instance in figure relocating instructions from block 5to entry block1can violate the original semantics of block .
in particular by executing the instruction sscanf argv d po of block5in entry block 1after instruction relocation the value of variableretcalculated via instruction sscanf argv d fq of block 2is changed since its variable nhas already been updated in entry block .
accordingly the semantics of conditionbool cmp2 ret !
for block 3would be violated.
note that while it is essential to preserve the semantics of branch conditions for correctly exploring their covered program states by executing seeds it is unnecessary to preserve the semantics of other statements since changing them exerts no impact in accessing the updated blocks i.e.
for an operand not in a branch condition its value is allowed to be changed after branch relocation if it is irrelevant to the operand value s of any branch condition .
in this paper we propose a dependency reduction mechanism to reduce program dependencies by relocating conditional instruction and the instructions affecting it while preserving original semantics of each conditional instruction as shown in algorithm .
for a given cfg of the target program we first obtain all the basic blocks represented as blocks with the conditional instruction of each basic block represented as branchcon lines to .
next for each block 1039esec fse december san francisco ca usa mingyuan wu kunqiu chen qi luo jiahong xiang ji qi junjie chen heming cui and yuqun zhang figure the workflow of miragefuzz figure a simplified real world example from jhead we identify all the basic blocks with the instructions affecting its conditional instruction i.e.
sharing variable usage via program slicing .
note that for the function slicingbasicblocks we perform the program slicing which extracts the dependent instructions ofbranchcon by applying the use def chains in both llvm ir and memory ssa to obtain their associated blocks collectedblocks line .
furthermore we filter out the dominators ofbranchcon whose semantics can be possibly violated by relocating the conditional instruction and the instructions affecting it line .
if there is no remaining basic block after filtering we can infer that all the instructions can be relocated in the entry block lines to .
otherwise we identify the farthest dominator in cfg to which all the instructions can be relocated without violating semantics on the conditional instruction lines to and perform the instruction relocation lines to .
after the iterative executions on all the collected conditional instructions we obtain a phantom program for miragefuzz line .
note that foralgorithm dependency reduction mechanism input source output phantom function reducedependencies blocks getbasicblocks source foreach block inblocks do branchcon getbranchexpression block collectedblocks slicingbasicblocks branchcon remainblocks b collectedblocks violatesemanticsafterrelocating b istrue isdominator b branchcon is true ifremainblocks is then entrance getentryblock blocks else entrance randomchoice remainblocks foreach b inremainblocks do entrance entrance dominates b ?
b entrance instructions getrelatedinstructions collectedblocks move instructions to entrance phantom reconstruct blocks return phantom the phantom program we only preserve semantics for conditional instructions as in the original program such that its adopted seeds can be used to advance program state exploration when fuzzing the original program illustrated later while the semantics of the rest instructions does not matter for building our phantom program.
accordingly in figure the conditional instructions located in 2and5cannot be relocated since nviolates the semantics of the branch conditions where nis an operand.
on the contrary the conditional instructions in 6and4are relocated to 5and1since the semantics of all involved branch conditions can be preserved after relocation more details are presented in our github page .
.
dual fuzzing given the phantom program by applying the dependency reduction mechanism miragefuzz performs dual fuzzing i.e.
the source fuzzing to fuzz the original program and the phantom fuzzing to fuzz the phantom program simultaneously under the identical initial 1040enhancing coverage guided fuzzing via phantom program esec fse december san francisco ca usa algorithm dual fuzzing input initialseed budget output none function fuzzingsourceprogram seeds initialseed while fuzzing time notexceed budget do foreach seed inseeds do mutant aflmutation seed ifmutant has new edges then seeds seeds mutant edges getunexplorededges seed phantomseeds requestseedsfromphantom edges taintseeds generateseedwithtaint seed phantomseeds foreach tseed intaintseeds do iftseed has new edges then seeds seeds tseed return none function fuzzingphantom seeds initialseed edgedic while fuzzing time notexceed budget do ifhas requests from source fuzzing then resp foreach edge inrequests do resp resp edgedic send resp to source fuzzing foreach seed inseeds do mutant aflmutation seed ifmutant has new edges then seeds seeds mutant foreach edge inmutant do edgedic edgedic mutant return none seed corpus and execution time budget.
during the source fuzzing miragefuzz collects the unexplored program branches adjoining the explored program states.
then miragefuzz searches for any seed executed to explore such collected branches in the phantom fuzzing for later generating new seeds to advance the source fuzzing .
algorithm presents the details for the dual fuzzing.
in particular for the source fuzzing we first adopt the afl mutation strategy to generate mutants out of our initial seed corpus lines to .
if any mutant is executed to explore new edges it is added into the seed corpus for further iterative executions lines to .
meanwhile we derive the unexplored program edges adjoining the explored program states by executing the given mutant and check whether they can be explored by executing any of the seeds generated from thephantom fuzzing lines to .
if such a seed exists we then adopt the taint based mutation mechanism illustrated later to generate a new seed for the future source fuzzing lines to for the phantom fuzzing we create a dictionary edgedic to store the information of the explored edges with their corresponding executed seeds lines to .
for each iterative execution we first check the real time unexplored edges from the source fuzzing lines to .
then we iterate each unexplored edge to find whether it has been already explored by executing any seed generated by the phantom fuzzing lines to .
similar to the source fuzzing wealgorithm taint based mutation mechanism input sourceseed phantomseeds output taintseeds function generateseedwithtaint taintseeds explorededges getallexplorededgesfromsource foreach mseed inphantomseeds do foreach edge inmseed s execution path do ifedge not in explorededges then taintpos taintposition edge sourceseed value taintcontent edge mseed mutant sourceseed mutant value taintseeds taintseeds mutant return taintseeds also adopt the afl mutation strategy to generate mutants lines to .
if executing any mutant explores new edges it is added to the seed corpus where edgedic is updated lines to .
in figure assume a seed is executed to explore the path for the source fuzzing .
then we can derive the unexplored edges adjoining the explored path i.e.
and which are further collected in edgedic for the phantom fuzzing .
for each edge miragefuzz searches for any seed executed to explore it in the phantom fuzzing .
at last all the collected seeds from the phantom fuzzing are used to generate new seeds for future source fuzzing via the taint based mutation mechanism.
.
taint based mutation mechanism we develop the taint based mutation mechanism to derive the byte offset corresponding to the conditional instruction of the given seed from the source fuzzing with its value derived by the phantom fuzzing via taint analysis .
specifically in our adopted taint analysis the input stream i.e.
the seed is referred to as the sole taint source.
in order to trace the tainted labels at runtime we define taint propagation rules to map the tainted input labels and output labels e.g.
add store andload instructions at a particular level of the operation hierarchy.
accordingly given a specific branch condition we can collect its corresponding label for its operand or the relevant byte offset of such a operand in the seed.
algorithm illustrates the details of the taint based mutation mechanism which is initialized with the seed to be mutated by the source fuzzing denoted as sourceseed and the collected seeds from the phantom fuzzing which can be executed to explore the identified unexplored edges from the source fuzzing denoted as phantomseeds .
we first obtain all real time explored edges line .
next for each seed in the phantomseeds we iterate its explored edges lines to .
if the edge is not explored by the source fuzzing we then derive the byte offset taintpos corresponding to the conditional instruction by taint analysis in the sourceseed lines to .
subsequently we also obtain the corresponding condition value by taint analysis in the given mseed fromphantomseeds line .
to illustrate note that to prevent the misallignment between the byte offset of mseed corresponding to the condition value and taintpos we activate two taint analysis processes for sourceseed andmseed respectively.
specifically we first apply taint analysis in the source fuzzing for obtaining the byte offset of the seed i.e.
1041esec fse december san francisco ca usa mingyuan wu kunqiu chen qi luo jiahong xiang ji qi junjie chen heming cui and yuqun zhang sourceseed corresponding to the given unexplored branch condition from the source program.
if we could identify a seed i.e.
mseed which can be executed to explore such a branch condition in the phantom fuzzing we then apply taint analysis again on that seed to obtain values of the involved operand corresponding to the branch condition.
accordingly we generate a mutant by updating taintpos with the corresponding value from the seed generated by the phantom fuzzing and then store it in the set taintseeds lines to .
at last the resulting taintseeds is used for advancing the future source fuzzing .
we take the same seed sexploring path mentioned in section .
as an example.
suppose we have another seed s generated by the phantom fuzzing which has satisfied the conditional instruction for block .
next by performing taint analysis on s we identify its byte offset impacting the value of pothat determines the transition 6or5 .
we further figure out that the value of poins is via taint analysis on s .
eventually we replace the value of poinswith to generate a new seed for exploring the new edge 6for the source fuzzing .
implementation we implement miragefuzz using c c .
specifically we perform instrumentation via llvm pass to obtain runtime information of target programs.
accordingly we build miragefuzz via the afl implementation.
furthermore we modify the taint analysis library libdft to implement the taint based mutation mechanism.
we encounter three main challenges when implementing miragefuzz .
first it is challenging to identify the unexplored edges adjoining the explored program states via instrumentation.
second adapting the existing taint analysis tool for the taint based mutation mechanism in miragefuzz potentially leads to non negligible engineering effort.
at last implementing phantom fuzzing tends to cause unexpected crashes which terminate the execution on the phantom program early to prevent it from exploring deep program states.
we then illustrate how we address the challenges as follows.
.
instrumentation note that in the source fuzzing we aim at recognizing unexplored edges adjoining the explored program states by executing a seed.
to this end we insert an observation instruction ahead of a given branch instruction to monitor whether any of its associated edges has been explored by observing the associated sink state of such branch.
if the sink of the given branch instruction is not reached it indicates that the corresponding edge is unexplored.
therefore combining with the real time collected explored edges we can derive the unexplored edges adjoining them.
.
dynamic taint analysis we adopt libdft a stable and efficient binary level dynamic taint analysis framework adopted by many existing works to implement the taint based mutation mechanism.
although libdft implemented the taint propagation rules for instructions their default taint propagation rules still cannot cover our required instructions e.g.
bswap reversing the byte order of a register and shl shifting the bits of a register to the left .
we also analyze that multiple taint labels of instructions movzx andmovsx can cause over taint issues leading to inefficient taint tracking.
to tacklethese issues we define our own taint propagation rules to cope with new instructions and revoke the redundant taint labels for libdft to improve the taint based mutation mechanism.
.
crash handling in phantom fuzzing generating the phantom program can inevitably devastate many dependencies of the original program incurring crashes which potentially prevent the phantom fuzzing from exploring sufficient states of the phantom program.
to address this issue we design a try catch mechanism to bypass these unexpected crashes.
more specifically we first capture all crash related system signals and design their corresponding handler.
next we obtain the runtime program counter value and increase it with the length of the real time crash triggered instruction to bypass it.
as a result phantom fuzzing can proceed to explore program states instead of being halted by the unexpected crashes.
with the solutions above miragefuzz is made scalable since it can be directly adopted upon any projects built upon llvm based compiler e.g.
clang without any additional adaptation effort.
evaluation in this section we conduct a set of experiments to evaluate the effectiveness of miragefuzz upon benchmark programs compared with nine baseline fuzzers.
in particular we attempt to answer the following research questions rq1 ismiragefuzz effective compared with the baseline fuzzers?
rq2 is each component of miragefuzz effective in terms of ablation study?
we also report and analyze the bugs on our benchmark suite exposed by miragefuzz .
note that all source code of miragefuzz and the evaluation details are presented in our github pages .
.
baseline fuzzers and benchmark baseline fuzzers.
to collect the baseline fuzzers for performance comparison with miragefuzz we determine to first select the coverageguided fuzzers recently published in prestigious software engineering and security conferences e.g.
icse fse s p and ccs.
next we filter the selected fuzzers based on their source code availability and the feasibility of their execution environments.
eventually we collect a total of nine fuzzers to form our baselines.
more specifically we select six coverage guided fuzzers i.e.
the latest versions of afl afl lafintel havocmab mopt and fairfuzz .
moreover we also adopt three recent fuzzers with constraint solvers as our baselines i.e.
angora meuzz and qsym to further compare the performance of our insight which enhances the exploration power of seeds without leveraging the power of the constraint solver and the constraint solving based fuzzers on their well performed benchmarks.
benchmark.
following multiple prior works we first construct our benchmark suite by collecting the projects commonly adopted by the fuzzers recently published in the aforementioned top software engineering and security conferences.
next we also include projects from fuzzbench in our benchmark suite.
as a result our benchmark suite is formed by frequently used projects with their latest versions.
we also present the statistics of our adopted benchmarks in our github page .
1042enhancing coverage guided fuzzing via phantom program esec fse december san francisco ca usa .
environment setup our evaluations are performed on a server with core .80ghz intel r xeon r gold cpus and gib ram running on bit linux version .
.
generic ubuntu .
.
following many prior work we set the total execution time budget to hours.
meanwhile all our evaluation results are averaged out of runs.
furthermore we follow the seed selection strategy in prior work to construct the initial seed corpus for each benchmark program from either its corresponding afl seed collection or its own test suite.
in this paper we adopt edge coverage to represent code coverage as all our studied baseline fuzzers .
here an edge refers to a conditional jump between two basic blocks in the program control flow.
note that since miragefuzz enables two instances in dual fuzzing for fair performance comparison we evaluate all our baseline fuzzers in a parallel fuzzing manner i.e.
enabling one additional instance which shares the same seed corpus during the fuzzing campaign for all the baseline fuzzers except qsym and meuzz which enable three processes sharing the same seed queue by default .
.
result analysis .
.
rq1 the effectiveness of miragefuzz.
table presents the edge coverage results of our studied fuzzers upon our benchmark suite.
noticing that meuzz requires additional computation resource to analyze the target program for fuzzing we mark a benchmark as n a when meuzz fails to complete its execution after consuming all memory resource e.g.
objcopy .
overall we can observe that miragefuzz outperforms all other fuzzers significantly.
in particular miragefuzz explores edges on average which is .
more than the top performing baseline fuzzer qsym explored edges and .
more than the worst performing baseline fuzzer lafintel explored edges in our study.
additionally miragefuzz consistently outperforms all the baseline fuzzers upon each benchmark program.
to illustrate the significance of the performance we also adopt the mann whitney u test in our evaluation.
we can observe that in table where the p value of miragefuzz comparing with other studied fuzzers in terms of the average edge coverage are all far below .
which indicates that miragefuzz outperforms all selected fuzzers significantly p .
.
furthermore figure presents the edge coverage trends of all our studied fuzzers upon each benchmark program within the hour execution.
we can observe that miragefuzz dominates the baseline fuzzers under most of the execution time.
such results altogether indicate that miragefuzz is a rather powerful coverage guided fuzzer.
we also investigate the effectiveness of exploring unique edges i.e.
edges that can only be explored by a given fuzzer for all our studied fuzzers.
in our evaluation miragefuzz can achieve the best performance by exploring unique edges on top of the whole benchmark suite averagely which outperforms the top performing baseline angora by .
vs. edges .
due to the page limit we present the performance details in our github page .finding miragefuzz is a rather powerful coverage guided fuzzer which can significantly and consistently outperform the adopted baseline fuzzers.
interestingly while qsym and angora are generally more effective than other baseline fuzzers the fact that miragefuzz significantly outperforms them on all benchmark programs without applying a constraint solver indicates that its insight which enhances the exploration power of seeds via dual fuzzing only is potentially even more powerful in exploring program states.
finding the mechanisms adopted by miragefuzz are potentially more effective than applying constraint solver for exploring program states.
.
.
rq2 the effectiveness of different components in miragefuzz.
to further understand the mechanism adopted by miragefuzz in this section we perform in depth ablation studies to investigate the effectiveness of the dedicated components designed for miragefuzz i.e.
the phantom fuzzing and the taint based mutation mechanism.
effectiveness of the phantom fuzzing.
investigating the effectiveness of the phantom fuzzing formiragefuzz is essentially equivalent to investigating the effectiveness of using the condition value derived by the phantom fuzzing for mutating the corresponding condition of the given seed for the source fuzzing .
accordingly we determine to create a technique variant miragefuzz taint ofmiragefuzz which tracks the byte offset impacting the unexplored condition of a given seed and then applies random mutation on the corresponding byte offset.
meanwhile we activate another source fuzzing process to replace the original phantom fuzzing process.
table also presents the edge coverage results of miragefuzz taint .
we can observe that miragefuzz significantly outperforms miragefuzztaint by .
.
moreover we can also find that both havocmab and qsym outperform miragefuzz taint by .
and .
respectively.
such results suggest that phantom fuzzing is essential in strengthening the effectiveness of miragefuzz .
finding the phantom fuzzing is critical for miragefuzz to augment its edge coverage performance.
effectiveness of taint based mutation mechanism.
we create a technique variant miragefuzz splice which replaces the taint based mutation mechanism by randomly identifying a byte offset of a given seed in the source fuzzing and splicing the given seed and a randomly selected seed for the phantom fuzzing at the identified byte offset to generate a mutant for the source fuzzing .
table also presents the edge coverage results of miragefuzz splice where miragefuzz outperforms miragefuzz splice by .
.
such a result clearly demonstrates that applying the taint based mutation mechanism can advance the effectiveness of the phantom fuzzing by precisely positioning the byte offset associated with the unexplored condition and providing the condition value to generate a mutant which can be executed to facilitate the source fuzzing .
1043esec fse december san francisco ca usa mingyuan wu kunqiu chen qi luo jiahong xiang ji qi junjie chen heming cui and yuqun zhang table effectiveness of miragefuzz benchmark afl afl lafintel fairfuzz mopt havocmab qsym meuzz angora miragefuzz taint miragefuzz splice miragefuzz readelf nm objdump n a objcopy n a size jhead pcre2 pngfix strip n a listaction d libxml2 n a libpng n a re2 n a swftocxx jsoncpp n a lcms2 n a file libjpeg turbo n a average p value .
.
.
.
.
.
.
.
.
.
.
figure the edge exploration trends of all fuzzers finding the taint based mutation mechanism is essential for miragefuzz in facilitating its fuzzing efficacy.
we further investigate the taint analysis time in our fuzzing campaign presented in our github page due to the page limit where it ranges from to seconds averagely during 24hour runs.
notably even though it costs seconds for taint analysis on project strip miragefuzz still achieves the best edge coverage i.e.
covering edges averagely in hour run.
.
bug report and analysis in this paper we obtain all the crashes and then manually identify the buggy location through stack tracing and analyze their respectively causes.
accordingly we derive unique bugs via debugging.
we then report our exposed bugs to the developers with the essential information that can help them generate a patch.
overall applying miragefuzz exposes previously unknown bugs upon our benchmark suite where were confirmed and were fixed by the corresponding developers.
meanwhile afl afl 1044enhancing coverage guided fuzzing via phantom program esec fse december san francisco ca usa and meuzz detect out of memory bugs in project swftocxx and afl fairfuzz and qsym expose heap buffer overflow bugs in project listaction d .
note that miragefuzz can expose all the bugs exposed by all other fuzzers.
we illustrate all our bug types e.g.
a use of uninitialized value bug refers to using a variable without initialization in our github pages .
table presents the details of the previous unknown bugs exposed by miragefuzz .
table the bug information program bug type number status pcre2 infinite loop confirmed and fixed nm infinite loop reported jhead use of uninitialized value confirmed and fixed strip out of memory confirmed and fixed pngfixuse of uninitialized value confirmed and fixed infinite loop confirmed listaction dsegmentation fault reported heap buffer overflow reported swftocxxsegmentation fault reported heap buffer overflow reported allocation size too big reported out of memory reported .
.
infinite loop in pcre2test.
we have reported a bug on project pcre2 a set of c functions that implement regular expression pattern matching using the same syntax and semantics as perl .
it was assigned with an issue id and has been confirmed and fixed by developers.
this bug was exposed by running pcre2test one of the executable programs in project pcre2 with the specified input files only generated by miragefuzz .
while processing the input files an infinite loop in function pcre2test.c process data void occurred as shown in figure .
1int process data void ... p is a section from input file li is s64 i is s32 needlen and dbuffer size are u64.
5li strtol const char p endptr 6if s32overflow li return ok 7i int32 t li 8if i return ok ... 10replen cast8var q start rep 11needlen replen i 13if needlen dbuffer size ... while needlen dbuffer size dbuffer size ... ... figure infinite loop in pcre2test .
for thewhile condition needlen dbf size and the loop bodydbf size we analyze that the value of needlen potentially incurs infinite looping due to a possible integer overflow.
in fact one of our input files sets i which in turn assigns needlen with the value resulting in an infinite loop.correspondingly the developers made a simple fix i.e.
patching i asi .
they commented on this bug as follows a negative repeat value in a pcre2test subject line was not being diagnosed leading to infinite looping.
.
.
use of uninitialized value in pngfix.
we reported a use ofuninitialized value bug in project libpng only exposed by miragefuzz under the instrumentation by memorysantizer .
in particular the bug was exposed by running the generated seed from pngfix one of the executable programs in project libpng confirmed with the github issue id and fixed later.
the buggy code snippet is presented in figure where the uninitialized value reported by memory sanitizer comes from png ptr big row buf andpng ptr big prev row .
1void png read start row png structrp png ptr ... 4if png ptr interlaced !
png ptr big row buf png bytep png calloc png ptr row bytes 7else png ptr big row buf png bytep png malloc png ptr row bytes png ptr big prev row png bytep png malloc png ptr row bytes ... figure use of uninitialized value in pngfix .
the developers believed that this problem was caused by lacking the memory initialization before using the memory requested by malloc and then fixed the bug by invoking memset in the end of the code snippet in figure with the following feedback in my opinion it is due to the fact that png malloc just calls malloc but doesn t initialize the memory.
i can work on that and improve it.
it would really help to avoid similar issues in the future.
.
.
use of uninitialized value in jhead.
we reported multiple use of uninitialized value bugs of project jhead .
these bugs reported in a github issue id were confirmed and fixed.
the relevant buggy code snippet in function readjpegsections is shown in figure where data is a pointer to an allocated heap memory segment by invoking malloc .
however such a memory segment is not initialized before data is used in the subsequent procedure and thus leads to a vulnerability.
eventually the developer generated a patch by invoking memset to initialize the value of the related memory after it is allocated.
or at least that should fix it.
... but i could see how this could be triggered.
.
.
out of memory in strip.
we have reported one out of memory bug as a bugzilla issue with id when executing project strip which was confirmed and fixed by the associated developers.
1045esec fse december san francisco ca usa mingyuan wu kunqiu chen qi luo jiahong xiang ji qi junjie chen heming cui and yuqun zhang 1int readjpegsections file infile readmode t readmode ... 4uchar data ... 6data uchar malloc itemlen 7if data null 8errfatal could not allocate memory 10sections .data data ... figure use of uninitialized value in jhead .
the function exif.c rewrite elf program header in figure reveals the relevant buggy code snippet.
by using the input generated by our approach the execution on strip keeps consuming memory and causes an out of memory bug.
in our evaluation strip consumes gib memory in our server in about two minutes.
similar to malloc we found that bfd zalloc is a function that allocates memory in the heap located in the loop in line .
the loop only terminates by updating isec surrounded by a conditional code region lines to .
therefore an out of memory bug is triggered ifstrip fails to enter such code region i.e.
the condition of such a code region cannot be satisfied.
1static bool rewrite elf program header bfd ibfd bfd obfd bfd vma maxpagesize ... 5isec 6do ... if is contained by lma output section segment map p paddr opb is corefile note segment section ... isec ... if isec section count ... bfd zalloc allocates memory.
map struct elf segment map bfd zalloc obfd amt ... continue while isec section count ... figure out of memory in strip .
the developers fixed this bug by refactoring the whole function to avoid memory overflow.
they also commented the bug as follows it s important that the later tests not be more restrictive.
if they are it can lead to the situation triggered by the testcases where a section seemingly didn t fit and thus needed a new mapping.
it didn t fit the new mapping either and this repeated until memory exhausted.
threats to validity threats to internal validity.
the threat to internal validity lies in the implementation of our approach.
to reduce this threat wereused the source code of the original afl to construct our basic fuzzing framework when implementing miragefuzz .
meanwhile to implement the taint based mutation mechanism we also reuse the existing libraries for taint analysis.
moreover the first three authors manually reviewed miragefuzz code carefully to ensure its correctness and consistency.
threats to external validity.
the threat to external validity mainly lies in the benchmarks and the baselines used.
to reduce this threat we adopt projects widely used for the evaluations in many popular fuzzers published recently .
furthermore we also select nine popular baseline fuzzers including six traditional coverage guided fuzzers and three constraint solving based fuzzers to evaluate the effectiveness of miragefuzz .
threats to construct validity.
the threat to construct validity mainly lies in the metrics used.
to reduce this threat we determine to follow many prior work by using the edge coverage to represent code coverage.
furthermore we present the crashes exposed by all studied fuzzers to demonstrate the advantages of miragefuzz .
notably miragefuzz can incur quite strong performance gain under both metrics compared with other fuzzers.
related work .
fuzzing among all the coverage guided fuzzers afl is a widely used baseline by retaining the mutants which can be executed to increase code coverage as seeds for further iterative executions.
many fuzzers are implemented upon afl.
li et al.
proposed steelix to explore new coverage efficiently by observing more runtime states.
lemieux et al.
introduced the concept of rare branches and facilitated the fuzzing efficacy by focusing on rare branches.
in order to improve the fuzzing effectiveness researchers also attempt to integrate dynamic analysis techniques such as taint analysis with fuzzing e.g.
afl .
rawat et al.
proposed vuzzer to identify the input format of the target program via taint analysis for avoiding early termination in fuzzing.
liang et al.
proposed pata a more advanced taint analysis technique that can identify the loop variables efficiently during fuzzing.
du et al.
proposed windranger which leverages the power of deviation basic blocks to facilitate directed grey box fuzzing.
furthermore many researchers also propose seed scheduling techniques for improving fuzzing effectiveness.
b hme et al.
proposed aflfast to schedule seeds during fuzzing via a markov chain model to improve the performance of afl.
she et al.
introduced k scheduler which schedules seeds according to the reachable edges and potential coverage gain.
zhang et al.
utilized path constraint as the guidance function to schedule the seeds for harvesting new edges.
zhang et al.
proposed mobfuzz which models fuzzing as a multi objective problem via a multi armed bandit and then schedules the seeds based on a particular optimization goal derived from the chosen objective combination.
meanwhile chen et al.
proposed meuzz to schedule the seeds in hybrid fuzzing based on the knowledge learned from past seed scheduling decisions made on the same or similar programs.
researchers also adopt constraint solvers to explore deep program states.
cadar et al.
proposed the fundamental symbolic execution engine 1046enhancing coverage guided fuzzing via phantom program esec fse december san francisco ca usa klee for aiding the fuzzers in solving the program constraints during fuzzing via symbolic execution.
accordingly yun et al.
introduced qsym to combine a concolic executor for solving complicated program constraints in a selected coverage guided fuzzer to leverage the power of symbolic execution in fuzzing.
kukucka et al.
proposed confetti to combine taint analysis and concolic execution to fuzz java programs.
to solve the constraints more efficiently chen et al.
proposed jigsaw to evaluate the generated seeds with constraints on a native function produced by just in time compilation.
instead of adopting the smt solver as other constraint solving based fuzzers chen et al.
proposed angora to solve program constraints by a gradient descent algorithm.
in addition fuzzing is utilized to detect vulnerabilities in specific domains.
shen et al.
proposed drifuzz to fuzz wifi and ethernet drivers with concolic executor.
garbelini et al.
proposed braktooth to fuzz arbitrary bluetooth classic bt devices via constructing a protocol state machine.
shou et al.
proposed corbfuzz to fuzz the security policies of browsers by tracking the runtime behaviors of the browsers.
gao et al.
incorporated code representation learning and clustering to guide the process of program synthesis based jvm fuzzing such as javatailor .
many existing fuzzers focus on scheduling promising seeds adopting dynamic analysis techniques or utilizing an additional constraint solver to enhance code coverage.
in this paper we propose miragefuzz to enhance the exploration capacity of each seed by reducing the program dependencies for conditional statements to reduce the difficulties of accessing their program states.
.
program transformation researchers adopt program transformation for multiple purposes.
bacon et al.
proposed multiple ways to optimize programs via transformation in the compiler.
wu et al.
proposed aucs which utilized the power of program transformation to fix synchronization issues for cuda programs.
korel et al.
utilized program transformation to find program inputs on which a selected element e.g.
a target statement is executed.
harman et al.
generated new tests to improve the performance of search based testing techniques via program transformation.
chen et al.
adopted semantics preserving program transformation to facilitate the efficacy of symbolic execution.
program transformation is also a common practice for fuzzing.
peng et al.
proposed t fuzz which combines symbolic execution and program transformation to explore deep execution paths of the target program.
liu et al.
proposed instruguard which detects and fixes the errors generated by transforming the target program for obtaining coverage information via static analysis on target binaries and rewriting transformation rules.
wang et al.
introduced riff to reduce the fuzzing overhead generated by program coverage measurement transformation via static program analysis.
menendez et al.
proposed hashfuzz which utilizes hash functions for semantics preserving program transformation to target programs for generating more diverse inputs.
dinesh et al.
proposed retrowrite which utilizes static analysis to transform target programs to reduce the performance overhead incurred by sanitizers in fuzzing.
nagy et al.
introduced a new program transformationrule to eliminate the needless coverage tracing for coverage guided fuzzers.
hsu et al.
proposed a lightweight program transformation strategy to reduce the fuzzing overhead incurred by tracing the coverage information.
mutation testing is a type of software testing in which certain statements of the source code are changed mutated to check if the test cases are able to find errors in the source code.
in mutation testing test cases are expected to reject mutant i.e.
mutated program by causing the behavior of the original program to differ from the mutant.
specifically papadakis et al.
and chekam et al.
have studied the fault revelation ability of mutation testing and found that the higher mutation scores are the stronger the fault revelation ability of mutation testing is.
while mutation testing is typically adopted for evaluating the quality of test suites the adopted program transformation from mutation testing enlightens researchers on facilitating the fuzzing efficacy.
groce et al.
has shown that fuzzing the mutants of the target program can allow a fuzzer to explore more behaviors than spending the entire fuzzing budget on the original target.
qian et al.
utilized mutation scores as additional feedback to guide fuzzing for bug detection.
while many fuzzers adopt program transformation for reducing runtime overhead we leverage the power of program transformation to create a phantom program for enhancing the exploration capacity of all seeds.
conclusion in this paper we propose the concept of phantom program which is built to mitigate the over compliance of program dependencies to enhance the exploration capacity of all seeds.
accordingly we build a coverage guided fuzzer namely miragefuzz which performs dual fuzzing for the original program and the phantom program simultaneously and adopts the taint based mutation mechanism to generate new mutants by combining the resulting seeds from dual fuzzing via taint analysis.
to evaluate the effectiveness of miragefuzz we select frequently used projects to form our benchmark suite and nine popular open source fuzzers to form our baseline fuzzers.
the evaluation results show that miragefuzz outperforms the baseline fuzzers from .
to .
in terms of edge coverage averagely in our benchmark.
miragefuzz also exposes previously unknown unique bugs where of them have been confirmed and have been fixed by the corresponding developers.
data availability the source code of the miragefuzz implementation is available in ourgithub page .
all evaluation details and bug reports are also presented in the github page .
acknowlegement this work is partially supported by guangdong provincial key laboratory grant no.
2020b121201001 and national natural science foundation of china grant nos.
.
this work is also partially supported by kuaishou.
1047esec fse december san francisco ca usa mingyuan wu kunqiu chen qi luo jiahong xiang ji qi junjie chen heming cui and yuqun zhang