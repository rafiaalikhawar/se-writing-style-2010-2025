path transitions tell more optimizing fuzzing schedules via runtime program states kunpeng zhang tsinghua shenzhen international graduate school tsinghua university zkp21 mails.tsinghua.edu.cnxi xiao tsinghua shenzhen international graduate school tsinghua university xiaox sz.tsinghua.edu.cnxiaogang zhu swinburne university of technology xiaogangzhu swin.edu.au ruoxi sun the university of adelaide ruoxi.sun adelaide.edu.auminhui xue the university of adelaide jason.xue adelaide.edu.ausheng wen swinburne university of technology swen swin.edu.au abstract coverage guided greybox fuzzing cgf is one of the most successful and widely used techniques for bug hunting.
two major approachesareadoptedtooptimizecgf i toreducesearchspace of inputsby inferring relationshipsbetween input bytesand path constraints ii to formulate fuzzing processes e.g.
path transitions and build up probability distributions to optimize power schedules i.e.
the number of inputs generated per seed.
however the former is subjective to the inference results which may include extra bytes for a path constraint thereby limiting the efficiency of path constraints resolution code coverage discovery and bugs exposure the latter formalization concentrating on power schedules for seeds alone is inattentive to the schedule for bytes in a seed.
inthispaper weproposealightweightfuzzingapproach truzz to optimize existing coverage guided greybox fuzzers cgfs .
to address two aforementioned challenges truzz identifies the bytes related to the validation checks i.e.
the checks guarding errorhandling code and protects those bytes from being frequentlymutated making most generated inputs examine the functional ities of programs in lieu of being rejected by validation checks.
the byte wise relationship determination mitigates the problem ofloadingextrabyteswhenfuzzersinferthebyte constraintrelation.
furthermore the proposed path transition within truzz can efficiently prioritize the seed as the new path harvesting many newedges andthenewpathlikelybelongstoacoderegionwith manyundiscoveredcodelines.toevaluateourapproach weimplemented6state of the artfuzzers afl aflfast neuzz mopt fuzzfactoryandgreyone intruzz.theexperimentalresultsshow thatonaverage truzzcangenerate16.
moreinputsflowing intofunctionalcode inadditionto24.
morenewedgesthanthe vanilla fuzzers.
finally our approach exposes bugs in target programs and of them have not been identified by the vanilla fuzzers.
corresponding authors sheng wen and xiaogang zhu permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthe firstpage.copyrights forcomponentsof thisworkowned byothersthan the author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
icse may pittsburgh pa usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn ... .
concepts security and privacy software security engineering fuzz testing keywords fuzzing software security path transition mutation acm reference format kunpeng zhang xi xiao xiaogang zhu ruoxi sun minhui xue and shengwen.
.pathtransitionstellmore optimizingfuzzingschedules viaruntimeprogramstates.in 44thinternationalconferenceonsoftware engineering icse may pittsburgh pa usa.
acm new york ny usa pages.
introduction fuzzing is a widely used technique to expose security issues in software andhasidentifiedthousandsofbugsandvulnerabilitiesin real world programs .
coverage guided greybox fuzzing cgf is one of the most successful solutions in fuzzing .cgfusuallymaintainsaninfiniteloop wherenew inputs are generated by mutating seeds.
if a new input explores new code coverage e.g.
new edges the input will be retained as a newseedandmutatedinfurtherrounds.thisevolutionarysolution effectively guides fuzzing towards exploring more code coverage.
existing solutions to improve the efficiency of cgf are two fold.
the first category intends to reduce search space of inputs .
the state of the art solution to reduce the input space is to infer the relationships between the input bytes and the path constraints i.e.
the byte constraint relation which significantly improves the possibility of resolving path constraints.
forexample aninputincludes8bytesbutonly1byteisrelatedtoa constraint if x 0xee .
if cgfs can infer the byte constraint relation themutationcouldbefocusedontherelatedbyte x only.
as a result instead of trying 2568new inputs cgfs only needtogenerateatmost 256newinputstoresolve theconstraint.
however areal worldprogramcouldbefarmorecomplicatedas thebyte constraintrelationcouldexistbetweenmultiplebytesand multipledifferentconstraints orevennested.fromourexperience theexistinginferenceapproachescannotdistinguishbetweenthe outerconditionandtheinnerconditionofanestedone.forexample theinferredbytesarelikelyrelatedtoanentirenestedcondition e.g.
if x 0xee if x 0xff ... .thatis when the inference process intends to infer the related bytes for the inner condition i.e.
x the result will erroneously include the ieee acm 44th international conference on software engineering icse authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa kunpeng zhang et al.
bytesrelatedtotheentirecondition i.e.
x x .asaresult whenfuzzingintendstoresolvetheinnercondition fuzzingmay mutatethebyte x whichwillalterthebranchofoutercondition.
thus the generated input will never reach the inner condition if x 0xff because the mutation of x breaches the outer condition.
on the other hand another category of solutions optimizes power schedule via formulating fuzzing processes .
because cgfs aim to discover more code coverage one state ofthe art solution to optimize power schedule is to model the path transitionsasmarkovchain ormulti armedbandit .the power schedule determines the number of mutations assigned to eachseed.anewinput s prime whichexercisesthepath ps prime isgenerated by mutating a seed s which exercises the path ps.
then there is a path transition between the path psandps prime.
the models build probability distributions of path transitions and optimize power schedule based on the distributions.
a basic motivation is to assign more power to seeds that are more likely to discover new coverage i.e.
theypreferthepathtransitionsincludingnewpaths.for example based on markov chain aflfast prefers seeds that exercise less frequent paths i.e.
the seeds with lower transition probabilities.
however the existing models only focus on power schedule for seeds but ignore the power schedule for bytes.
in fact the transitions contain more information of the execution states which can be utilized to optimize power schedule for bytes.
we observe that the differences between two execution paths of a transition imply properties of programs under test puts .
specifically ifapathtransitionresultsinasignificantlyshorterpath thetransitionislikelyrelatedtoavalidationcheck.inthisresearch wefollowthedefinitioninyou etal.
ifapathconstraintguards error handling code then it is a validation check otherwise it is a non validation check.
the execution paths that examine the errorhandlingcodeareusuallymuchshorterthanthepathsthatexamine functional code.
the reason lies in the fact that the error handling code usually leads to the termination of a program.
as shown in fig.
ifaninputfailsthe validationchecki theinputwillflowinto theerror handling code i whose length is edges.
on the other hand if anotherinputpassesthe validationchecki andvalidation check ii the length of the execution path is at least edges.
moreover ifapathtransitiondiscoversanexecutionpaththat includesnewedges itislikelytoexploreanundiscoveredregion.
intuitively more new edges covered in a path may lead us to more undiscovereddescendantsasitmayhavetouchedmorenewcode areas so that we should focus more on such seeds that discovered more new edges until they have been thoroughly tested.
consideringthelimitedtimebudgetoffuzzingcampaigns theprioritization ofseedsthatexercisepathswithmoreundiscovereddescendantscanfurtherimprovetheefficiencyofcodediscovery.weshowin fig.1thatifthenewedgesinthepath acfjln arecf fj jl and ln theundiscoveredbasicblocksthatthepath acfjln canreach arei k m o andp on the other hand if another path abdg includes new edges bdanddg the undiscovered basic block that the path abdgcan reach is h. therefore the input that exercises thenewpath acfjln ismorelikelytoexplorelargerundiscovered code regions.
in this paper we propose a lightweight approach truzz t o improve the performance of cgfs.
different from other existing figure an example of validation checks and code cover age.
the execution paths containing error handling code islikely to be shorter than the paths of functionalities.
as forcode coverage a newly discovered path that includes morenewedgesislikelytohavemoreundiscovereddescendants.
cgfs ourtruzzdeterminesthevalidation relatedbyteswithout complexstaticanalysisanddynamicanalysis.concretely truzz intendstoprotectbytesrelatedtovalidationchecks andprioritizes seeds that are more likely to explore larger new code regions.
itinfers the relations between input bytes and validation checks.based on the aforementioned observation if mutation of certainbytes results in exercising a significantly shorter path then the bytes are likely related to a validation check.
in order to determine sucharelationship truzzcomputesascalar the fitness foreach byte measuringhowlikelyabyteisrelatedtoavalidationcheck.
based on the fitness score truzz then assigns lower mutationprobabilities to the validation related bytes locking them frombeing mutated.
furthermore in order to prioritize seeds truzzranks each seed based on the number of newly discovered edges when a seed is first retained.
the top seed will be selected to be mutated in the next fuzzing round.
the experimental results indicate that the integration of our approach and the existing cgfs can further improve the performanceofcgfs.ourapproachcanhelpmitigatetheaforementioned problemoftheimpreciseinferenceofbyte constraintrelations.it focusesonthefinegranularityofbyteschedule whichcanimprove the performanceof coverage discovery.meanwhile our approach steers computing resources towards functional code rather than error handlingcode.duetothelimitedtimebudget theseedprioritization in our approach further improves the performance of power schedule.
we evaluate the performance of truzz by applying it onto state of the artfuzzers i.e.
neuzz greyone afl authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
path transitions tell more optimizing fuzzing schedules via runtime program statesicse may pittsburgh pa usa mopt fuzzfactory and aflfast and conduct fuzz testingon8targetprograms.theexperimentalresultsshowthat truzz equippedfuzzersdiscovermorecodecoverageandbugsthan the vanilla fuzzers.
we summarize our contributions as follows.
wefirstpropose a lightweight generalized framework of byte scheduleandseedprioritization truzz toimprovetheperformanceofcgfs utilizingthedifferencesofpathsinpathtransitions as such differences can indicate properties of target programs e.g.
the validation checks and the undiscovered code regions.
weevaluateourapproachwithrespecttovalidinputgeneration.
theexperimentalresultsindicatethat withthehelpof truzz .
on average more inputs can pass the validation checks and flow into functional code.
we implement our framework with state of the art fuzzers afl aflfast neuzz mopt fuzzfactory andgreyone and comparetheperformancewithvanillafuzzers.onaverage24.
moreedgecoveragehasbeenidentified.moreover truzz equipped fuzzers expose bugs in target programs and of them have not been identified by the vanilla fuzzers.
related work and motivation in this section we introduce the related work of coverage guided greyboxfuzzing cgf .wethenattempttomotivateourapproach by demonstrating the weaknesses of current cgfs.
.
coverage guided greybox fuzzing thebasicideaofcgfistoexploremorecodecoveragesothatitmay triggerabughidingincertaincoderegions .
a general cgf has a seed corpus which contains the initial inputs and interesting inputsthatareretainedfromthegeneratedinputs during fuzzing.
the initial inputs are usually manually created according to the input specifications of puts or collected from the internet.the interesting inputsaretheonesthattrytodiscover new code coverage during fuzzing.
specifically during each round of fuzzing cgf selects a seed from the seed corpus and generates new inputs by performing mutations on the bytes in the seed .
most cgfs randomly select byte s to be mutated o r selectbyte s thatarerelatedtoacertainpathconstraint .
when a generated input discovers new code coverage e.g.
new edges cgf will retain the input as a new seed.
the loop that includesselection mutation andretentionensurestheeffectiveness of code coverage discovery .
mostcgfsobtainthecoverageinformationviainstrumenting a bitmap to indicate new edges.
a bitmap is a compact vectorthat records the discovered edges in the current execution.
eachedge is assigned with an identifier which is also the index of the bitmap.
when an edge is examined the corresponding element of thebitmapwillincreasethevaluebyone.asaresult ifthevalueofanelementis0 thecorrespondingedgeisnotexamined otherwise if the value of an element is non zero the corresponding edge is examined.therefore anewedgeisdeterminedifthecorrespondingelementofthebitmaphasflippedfrom0tonon zerointhecurrent execution.
.
.
path constraints.
a major roadrock of fuzzing efficiency improvement is the path constraints especially the tight constraints figure validation check.
if an input fails the validationcheck it will be trapped in the error handling code.
such as if x 0xee .
many fuzzers utilize symbolic execution toresolvepathconstraints butsufferfromsignificantlyslowexecutionspeed .becausethebytesrelatedtoapathconstraint are usually a small portion of an input some other fuzzers uti lize taint analysis to build the relationships between input bytesand path constraints .
taint tracking can identify promising input bytes that affect program s certain opera tions .
when resolving a path constraint fuzzingonlyneedstomutatetherelatedbytessothattheyimprove the efficiency of passing raodrocks.
however taint analysis stillintroduces high overhead that limits the improvement of performance.t fuzz utilizesprogramtransformationtoremovepath checks so that fuzzing can explore deep code but it requires many engineering efforts to transform programs.
more lightweight approaches areproposed to resolve path constraints whichinfertherelationshipsbetweeninputbytesandpath constraints based on the changes of execution states .
forinstance neuzz buildsupdeeplearningmodelsfortherelationships between input bytes and branch behaviors.
the branch behaviors indicate the execution states of satisfied or unsatisfiedpath constraints.
the models have a high chance to include extra bytes for a certain path constraint because they approximately build the relationships .
similarly the inference approach of greyone is that if mutation ofa byteresults in changingthe valueofavariable thenthebyteisrelatedtothevariable.when the variable is checked in a path constraint the byte is also related to the path constraint.
however the change of bytes related to the outer conditions can also influence the value of variables relatedto the inner conditions see fig.
.
therefore the related bytesfor inner conditions will include extra bytes.
due to extra bytes fuzzing may mutate the bytes related to the outer condition which will alter the branch of outer condition resulting in decreasing the effectiveness of resolving the path constraint of inner condition.
.
.
power schedule optimization.
another way to improve the performance of cgf is to optimize fuzzing schedules via formulatingfuzzingprocesses .forgeneralcgfs e.g.
afl they assign almost the same energy for each seed.
however dif ferent seeds have different potentials to discover new coverage.
therefore based on formulating fuzzing processes cgfs assignmoreenergytoseedsthataremorelikelytodiscovernew authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa kunpeng zhang et al.
coverage.aoptimizationforpowerscheduleisbasedontheformulationofpathtransitions.
cgfsbuildtheprobabilitydistributions of path transitions via observing the result of each mutation.
more energy will be assigned to the seeds that have higher probabilities to transition to an undiscovered path.
however they only focus on the power schedule for seeds but ignore the schedule for bytes.
.
motivating example truzz improves the performance of cgfs based on the differences between path transitions.
in this section we show an example that motivates this research i.e.
the requirement for the byte schedule.
as shown in fig.
line is a validation check because it guards the error handling code in line .
in order to test the functional code lines and fuzzing has to satisfy the validation checkin line .
on the other hand if a seed has already satisfied the condition in line the later fuzzing campaigns should not mutate the bytes related to the condition.
therefore some state of the art fuzzers improve the efficiency of resolving the path constraints via inferringthe byte constraint relation.
forexample the length of input in fig.
is bytes and a random mutation may generate 2565new inputs and most of them will be rejected by the validation check in line .
however if a fuzzer can infer that the first byte is the only byte related to the constraint it only needs at most mutations to bypass the constraint.
the problem is that the inference may include extra bytes for a path constraint.
the reason lies in the fact that the inference reliesonthechangesofexecutionstates andthechangesmaybe explicitlyorimplicitlyinfluencedbycertainbytes.forexample the constraint of line in fig.
is explicitly influenced by variable b and implicitly influenced by variable a. therefore for both neuzz and greyone the bytes related to line are input i.e.
the bytesrelatedtoboth aandb.asaresult fuzzersmaymutatethe byteinput whenresolvingtheconstraintofline3 andgenerate many inputs that examine the code error handler rather than the functionalities.therefore inordertoexaminethefunctionalities the byteinput that satisfies the check should not be mutated.
ourtruzzmitigatestheaforementionedproblemviaidentifying the bytes related to validation checks based on path transition.
when truzz mutates the related bytes it will protect the bytes related to the validation checks e.g.
the byte input in fig.
.
therefore mostofthegeneratedinputsexaminethefunctionalcode and avoid being trapped in the error handling code.
meanwhile the path transitions are also utilized to prioritize seeds which can further improve the efficiency of cgfs.
methodology of truzz motivated by the aforementioned observation that the differences inpathtransitionsimplyinternalstatesofprograms wedesignthe truzzasalightweightframeworktoimprovethecodecoverage andefficiencyofcgfs.ourtruzzislightweightbecauseitdoes not utilize complex taint analysis to obtain related bytes or approaches to pinpoint the error handling code regions .
asshowninfig.
truzzconsistsoftwocorecomponents byte analysis and seed prioritization.
truzzperformsbyteanalysisoneachseedtoidentifythebytes related to validation checks.
it determines the validation relatedbytesifmutation ofthosebytesresults insignificantlyshorterexecutionpaths.sincevalidation relatedbytesaresparseininputs truzzutilizesdichotomytoimprovetheefficiencyoftheprocess.
note thatthe byteanalysis isonly performedonce foreach seed whichintroducessmalloverhead.duringthemutationstage the validation relatedbytesareprotectedsothatmostofthegenerated inputsexaminethefunctionalcode insteadofbeingrejectedbythe validationchecks.then inseedprioritization truzzrankseach seed when they are added to the seed corpus.
the seeds with more newly discovered edges are tagged with higher rankings whichare utilized to prioritize seeds.
the combination of byte analysisandseedprioritizationintendstooptimizepowerschedulein fuzzingviathebalanceof exploitation vs.exploration .byteanalysisfocuses moreon the exploitation because itputs moreefforts onfuzzingfunctionalitycode.ontheotherhand seedprioritization intends to explore because it prefers seeds that have more potential to discover more code regions.
.
byte analysis inthisstage truzzbuildsupaprobabilitydistributionforinput bytes and selects bytes to be mutated based on the distribution.
the probabilities are gained based on the differences between two executionpathsinapathtransition.essentially ifabyteismore likely related to validation checks the byte will be selected with asmallerprobability.asaresult thevalidation relatedbytesare protected during fuzzing and the generated inputs are more likely to explore the functionalities of programs.
truzz first measureshow likely a byte is related to a validation check as a scalar the fitness and further assigns a mutation probability to the byte.
.
.
fitness for bytes.
in order to measure how likely a byte is related to validation checks truzz first mutates each byte andcomputes the fitnessbased on the differences in the path transition.equation1definesthefitness f i m fortheithto i m th bytes.
specifically let sbe a seed and s primebe the generated input obtainedbymutatingthe ithto i m thbytesoftheseed.suppose that the seed sexercises the path psand the input s primeexercises the pathps prime.
note that a path consists of a set of edges in this context.
in the equation ps ps primeis the subsetof edges that belong to both pathspsandps prime and presentsthenumberofedgesinaset.for example ps ps prime indicatesthenumberofedgesthatbelongtothe intersection of paths psandps prime.
recall that if an input exercises an execution path that contain error handlingcode thelength i.e.
thenumberofedges maybe significantly shorter than the path exercised by the corresponding seed.inequation1 ps ps prime ps indicateshowsignificantlythelength of path has been shortened.
further ps ps prime ps measures the intersection of the execution paths psandps prime i.e.
the edges changed in the path transition.
the reason we not only consider the length of paths is that when the difference of length and the intersection of paths are both small the two paths will be quite different but have similarlengths.insuch rare cases thebyteshavingbeenmutated are more likely to be related to a validation check and the fitness should be large.
therefore equation measures the differences inapathtransitionpertainingtothechangesofbothlengthand authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
path transitions tell more optimizing fuzzing schedules via runtime program statesicse may pittsburgh pa usa figure overview of truzz.
truzz ranks each seed and prioritizes seeds with higher ranks.
when a seed is selected truzz will perform byte analysis to identify the bytes related to validation checks.
then during the mutation stage it will avoid mutating the protected bytes with a high probability.
individual edges.
f i m ps ps prime ps ps ps prime ps ps prime ps ps prime ps ps ps prime ps ps prime here we take fig.
as an example for computing fitnessf i m .
suppose that a valid seed examines the functional code iii and explores ps edges.
if mutating the athbyte of theseedgeneratesaninputthatflowsinto error handlingcodeii theinputexplores ps prime 30edges.basedonequation1 the fitnessiscalculatedas f a .
.ifwe mutatethe bthto b c thbytesandthegeneratedinputexamines thefunctional code vi the new input explores edges.then thefitnessis f b c .
.
thus truzz infers that the athbyte is more likely to be related to validation checks than the bthto b c thbytes.
.
.
dichotomy for byte analysis.
the calculation of fitness byte by byte is time consuming especially when an input includes a large number of bytes.
fortunately validation checks are sparse in programs i.e.
only a small portion of input bytes are related to validation checks.
most of the input bytes flow into the code of functionalities.
with this in mind we utilize a dichotomy method to improve the computing efficiency.
if mutation of the bytes belongingtothecurrentsegmentresultsinafitnesslowerthanthe threshold or the size of the segment is small enough all bytes in thesegmentaresettothesamefitness otherwise truzzcontinues the dichotomy until the validation related bytes are identified.asshowninalgorithm1 truzzfirstcreatesanarray fpresenting thefitnessvalue for each byte line and initializes a set d with the left and right half intervals of a seed lines .
then the dichotomystarts.duringtheloop if disnotempty truzzobtains anintervaldenotedbythestartingandendingindexes mutatesthebytes anddeterminesthepath ps prime whichiscoveredbythemutated inputs primevia the bitmap b prime lines .
with the paths psandps prime according to equation truzz computes the fitnessfor bytes in the current interval line .
if the fitnessis smaller than a predefined thresholdor the length ofthe current interval isless than the predefined minimum length all the bytes in the interval are assigned with the value of fitness lines .
otherwise truzz continues the dichotomy by creating new intervals and appends themintotheset d lines14 .consideringthatineachroundof dichotomy truzz is able to handle at most half of the bytes within one mutated input so the assignment of fitness for bytes performs in an efficient manner.
for example as shown in fig.
the seed for the target program is03ac.
during the stage of byte analysis truzz mutates the first twobytes andgeneratestheinput 3aac.becausetheexecution pathsexercisedby 03acand3aacdonotchange truzzassigns fitnesstothefirsttwobytesas0 whichisdefinitelysmallerthan the threshold.
on the contrary when mutating the other half bytes ac the execution path is significantly shorter and the fitnessvalue is .
which is larger than the threshold so that the dichotomycontinues.
then truzz continues to split the bytes acinto two halvesaandc.
finally truzz infers that the last byte cis related to the validation check.
based on dichotomy truzz only needs toconductroughly2 log2 n mutations where nisthelength of an input.
note that a larger threshold of fitness and a larger authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa kunpeng zhang et al.
algorithm dichotomy for byte analysis input the current seed s. the path exercised by s ps.
the minimum length of interval l. the threshold of fitness t. variables a bitmap that determines code coverage b. the start index of an interval b. the end index of an interval e. a set of b e intervals d. the fitness f. output an array of ffor each byte f. 1size length s 2f 3d d size 4d d size size 5whilehas next d do b e pop d 7s prime mutate bytes s b e 8b prime execute s prime 9ps prime get path b prime 10f calculate fitness ps ps prime 11iff to re b lthen f f 13else d d b b e d d b e e thresholdofintervalsizewillreducethecomputingcostbutlead to a coarse grained result.
.
.
probability for bytes mutation.
to protect bytes related to validation checks based on the fitness truzz decides whether a byte can be mutated or not when generating a new input.
the purposeofassigningamutationprobabilitytoeachbyteistoavoid mutatingthevalidation relatedbyteswithahighprobability.truzz assigns the mutation probability according to equation .
p i m max f i m lp wheref i m isthefitnessofithto i m thbytes.alargerfitness of a byte will lead to a smaller probability to be mutated so that avalidation relatedbytecouldbeprotectedfrommutation.note that we also set a lower bound of the probability lpto ensure that fuzzingwillstillgenerateinputstofailthevalidationchecksand cover the error handling code instead of ignoring it at all.
.
seed prioritization most cgfs sequentially select seeds to be mutated i.e.
they select seeds based on the order of the seeds added to the seed corpus.
however seeds differ from their potential to explore undiscovered code regions.
due to the limited time budget thisschememaymissopportunitiestodiscovermorecodecoverage.
in order to improve the efficiency of code discovery truzzheuristically determines the potential for each seed to discover morecodecoverage.intuitively ifanewlydiscoveredpathincludes more new edges the path is likely to explore a code region withmore undiscovered code lines.
that is a new path that includes more new edges has a higher chance to have more descendants of undiscoveredblocks e.g.
theblocks i k m o p infig.
.therefore truzz ranks each seed based on the number of new edgesin a newly discovered execution path.
the larger the number ofnew edges the higher priority to select the corresponding seed.
note that truzz updates the rankings of each seed during fuzzingalgorithm seed prioritization input seed corpus s. the number of mutations energy.
variables the number of new edges n. the number of new edges found by mutating one seed nall.
a set of seed new edges tuples m. a generated input i. a bitmap that tracks code coverage b.
1boverall 2fors sdo 3b execute s 4n count map b boverall b 5ifn 0then m m s n 7boverall boverall b 8m sort m 9whiletruedo 10s select seed m 11nall 12whileenergy 0do i mutate s based on byte analysis b prime execute i n prime count map b prime boverall b prime ifn prime 0then m m i n prime energy energy boverall boverall b prime nall nall n prime 21m update s n all 22m sort m campaigns.
if a seed discovers only a few new edges after being fuzzed many times truzz decreases the ranking of the seed.
asshowninalgorithm2 truzzfirstperformsadryruntoassign rankings for initial seeds lines .
the bitmap boveralltracks all history edge coverage and is set to empty at the beginning line .
for all the initial seeds truzz tests all of them and adds the seeds to the set mif they discover new coverage lines .
along with the seed the set malso includes the number of new edges discoveredbytheseed.then truzzmergesthecurrentbitmap b intotheoverallbitmap boverall line7 .basedontherankingsof seeds truzzselectsatopseedfromtheseedcorpus line10 .after assigning the energy i.e.
the number of mutations to the selected seed line12 truzzmutatestheseedbasedonthe fitnesscomputed inbyteanalysisphaseandgeneratesanewinput line13 .afterthe programisexecutedwiththenewinput fuzzingcheckswhether the corresponding bitmap has at least a non zero element that has never been covered before lines .
if so truzz counts thenumber of such non zero elements and retains the new input asa new seed lines .
then the energy decreases by one and thecurrentbitmapismergedintotheoverallbitmap lines18 .
according to the number of new edges discovered by mutating the seeds nwill be updated with nall.
truzz sorts the seeds in the seed corpus based on the number of new edges found lines .
.
application ourapproachcanbeappliedtoothercgfswithoutmuchefforts.
theimprovementisaddedtothestageswhenfuzzingselectsaseed and when fuzzing selects a byte.
the seed corpus is ordered based on seed rankings so that other fuzzers select seeds from the topof the ordered sequence.
most cgfs randomly select bytes to be mutated or select bytes that are related to certain path constraints.
authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
path transitions tell more optimizing fuzzing schedules via runtime program statesicse may pittsburgh pa usa table target programs.
target source file input format test instruction tiff2bwlibtiff .
.
tifftiff2bw dev null tiffsplit tiffsplit dev null nm binutils .
elfnm c objdump objdump d readelf readelf a size size strip strip o tmp file djpeg libjpeg 9c jpeg djpeg a placeholder indicating that the input is a file.
after other cgfs select a byte our truzz will accept or reject the selectionbasedontheprobabilitydistributionsofbytes.inorder toobtaintheprobabilitydistributions truzzintegratesourbyte analysisintothedeterministicstageifotherfuzzershavethestage.
this stage mutates seeds byte by byte based on the determined mutation strategy.
if a fuzzer does not perform the deterministic stage truzz conducts a pre mutation to obtain probabilities.
evaluation in this section we run experiments to verify the performance of truzz and to answer the following research questions rq1 how effective is byte analysis to guide more generated inputs flow into functional code?
rq2 towhatextentcanavoidingmutatingvalidation related bytes andhow can seed prioritizationimprove the efficiency of fuzz testings?
rq3 howmanybugscanbe uniquely discoveredbytheproposed framework?
.
experimental setup in order to evaluate our truzz we implemented truzz with 6state of the art fuzzers and compared the performance with the correspondingvanillafuzzers.specifically weraneachfuzzeron 8target programsfor24 hours and thenrepeatedthe experiment for times.
all our measurements were performed on a system runningubuntu18.04withintel r xeon r gold6230rcpuand nvidia geforce rtx ti gpus.
benchmark fuzzers.
as mentioned earlier we select fuzzers to evaluate our approach.
neuzz and greyone are selected becausetheyinferbyte constraintrelationtoresolveconstraints.
we choose afl because it is a general cgf.
we also choose someextensionsofafl.aflfast improvesaflviaformulating path transitions.
mopt optimizes afl s mutation operator schedule.
fuzzfactory generalizes coverage guided fuzzing to domain specific testing goals.
neuzzmodelsrelationsbetweeninputbytesandbranchbehaviorsbyutilizingneuralnetworks.inordertoapplybyteanalysis to neuzz truzz neuzz performs a pre mutation before the mutation strategy proposed by neuzz.
greyonefti utilizes a lightweight and sound fuzzing driven taint inference fti to infer the relations between input bytesandvariablesinpathconstraints.wenamethefuzzerasgreyonefti because greyone does not release its code and we try ourbesteffortstoimplementitscoreoffti.truzz greyonefti improves greyonefti via protecting the bytes related to the outer conditions.
afl the american fuzzy lop is a widely used cgf which has discovered many bugs in real world applications.
truzz afl infers the validation related bytes during its deterministic stage andselectsbytesbasedonthebyteprobabilitydistributionduring its havoc stage.
aflfast is developed based on afl and optimizes power schedule via formulating path transitions.
as a result aflfast prefers assigningmorecomputingresourcestothepathsthatareexercisedwithlowfrequency.similartotruzz afl truzz aflfast applies byte probability to select bytes.
moptutilizes particle swarm optimization pso algorithm toachievemutationoperatorschedule.truzz mopt applies byte analysis in all types of fuzzing modes to protect the bytes relatedtovalidationchecks.wesettheparameter las60.mopt provides two types of pacemaker fuzzing modes and we choose mopt afl tmp for the experiments.
fuzzfactory savesintermediateinputsiftheymakeprogress in domain specific states.
the implementation of truzz fuzzfactory is similar to that of truzz afl .
targetprograms.
weevaluatedtruzzon8differentreal world programs as shown in table which we adopted from the evaluation of neuzz and mopt .nmlists the symbols from object files.
objdump displays informationabout object files.
readelf displaysinformationaboutelfformatobjectfiles.
sizeliststhe section sizes for each of the binary files.
stripdiscards all symbols from object files.
djpegis a widely used tool for handling jpegimagefiles.
tiff2bw convertsacolortiffimagetogreyscale.
tiffsplit splits a multi image tiff into single image tiff files.
initial seeds.
to make the comparison fair we run each fuzzer on each target application with the same initial seeds collected fromtargetprogram stestsuiteandpublicseedcorpus neuzz and mopt .
neuzz is different from other fuzzers because it requires an initial dataset.
according to the setup described in neuzz werunaflforanhourtocollectaninitialtraining set x y wherexis a set of input bytes and yrepresents the correspondingedgecoveragebitmap.theaveragesizeof8initial training set is .
.
rq1 effectiveness of byte analysis as described in the methodology truzz uses byte analysis to identify bytes associated with validation checks.
then we will mutatethevalidation relatedbytesmuchlessoftenthanotherbytes.
therefore truzzreliesheavilyontheaccuracyofbyteanalysis.
as such this subsection analyzes such accuracy of truzz s byte analysis.wemanuallyanalyzefiveprogramsutilizedintheexperimenttomarkallerror handlingpathsintheseprograms including nm objdump readelf size and strip.
for the analysis methods we adopt the manual analysis method used by fifuzz .
we scan the definition of each error function and check whether it can trigger an error by returning an error code or a null pointer.
eachtimeamutatedinputisgeneratedandexecuted wedetermine authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa kunpeng zhang et al.
table original vs. truzz equipped fuzzers on the percentage of valid input generated.
program of validation checksneuzz truzz neuzz improvement of valid ratio of inputs generated valid ratio of inputs generated valid ratio valid2invalid3total valid invalid total nm .
.
.
objdump .
.
.
readelf .
.
.
size .
.
.
strip .
.
.
1truzz neuzz an implementation of truzz framework using neuzz as the fuzzer.
2valid indicates that the inputs pass all validation checks.
3invalid indicates that the inputs flow into error handling code.
figure the edge coverage of different fuzzers running for hours.
whether the input exercises the error handling path and count the numberofthosepathsduringfuzzing.aninputisconsidered valid ifitpassesallvalidationchecksandtriggersnoerror handlingcode.
to avoid the impact of seed prioritization we implement the truzz only with byte analysis in this experiment.
finally we take neuzzandtruzz neuzz asanexampletoillustratetheaccuracyofbyteanalysis.inneuzz smutationstrategy itrandomlyselects500edgesandtakesthederivativeoftwoseedsforeachedge.then the gradient information obtained by derivation is recorded in the gradient file.
finally neuzz will mutate based on this gradient file.inordertoensurethefairnessoftheexperiment 000seeds are randomly selected and the same model is used for both fuzzers.
both neuzz and truzz neuzz mutate inputs based on the samegradientfile andbothofthemhavethesamenumberofmutations.
wecalculatetheproportionofvalidinputsintheirgeneratedmutated inputs as shown in table .
truzz neuzz generates onaverage .
more valid samples than neuzz.
especially for nmandobjdump truzz neuzz generates over more valid samples than neuzz.answer to rq1.
under the same experimental conditions truzzcangeneratemorevalidsamplesthanthevanillafuzzers.
.
rq2 code coverage discovery a bug is triggered only when the related code regions are explored.
therefore code coverage is an important metric for coverageguided fuzzers.
we run two versions of fuzzers on eight programs for hours repeated five times and leverage afl s afl showmap tool to compute the code coverage.
then we compared the average performance with respect to edge coverage.
we first evaluated the growth trend of edge coverage by two versions of fuzzers.
as shown in fig.
truzz equipped fuzzers have a steady and strongergrowthtrendonalltargetprogramsexceptfor tiff2bw andtiffsplit .
note that for neuzz as there are initial seeds involved the edge coverage at the starting point is much higher than other fuzzers with only one initial seed.
specifically truzz equippedfuzzersachievebetternewedges coverage for most of the programs than the vanilla versions as authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
path transitions tell more optimizing fuzzing schedules via runtime program statesicse may pittsburgh pa usa table original vs. truzz equipped fuzzers on the number of new edges found in hours.
program of new edges afltruzzaflfasttruzzneuzztruzzmopttruzzfuzzfactor ytruzzgreyoneftitruzz afl aflfast neuzz mopt fuzzfactory greyonefti nm .
.
.
.
.
.
objdump .
.
.
.
.
.
readelf .
.
.
.
.
.
size .
.
.
.
.
.
strip .
.
.
.
.
.
libjpeg .
.
.
.
.
.
tiff2bw .
.
.
.
.
.
tiffsplit .
.
.
.
.
.
table4 thenumberofnewedgesfoundcomparedtovanilla fuzzers in hours.
fuzzer average min.
max.
median ba equipped1neuzz .
.
.
.
sp equipped2neuzz .
.
.
.
ba equipped greyone .
.
.
.
sp equipped greyone .
.
.
.
ba equipped afl .
.
.
.
sp equipped afl .
.
.
.
ba equipped aflfast .
.
.
.
sp equipped aflfast .
.
.
.
ba equipped mopt .
.
.
.
sp equipped mopt .
.
.
.
ba equipped fuzzfactory .
.
.
.
sp equipped fuzzfactory .
.
.
.
1ba equipped use byte analysis to optimize the vanilla fuzzer only.
2sp equipped use seed prioritization to optimize the vanilla fuzzer only.
table results of vargna and delaney s a12scoring.
program truzz truzz truzz truzz truzz truzz afl aflfast greyonefti neuzz mopt fuzzfactory nm .
.
.
.
.
.
objdump .
.
.
.
.
.
readelf .
.
.
.
.
.
size .
.
.
.
.
.
strip .
.
.
.
.
.
libjpeg .
.
.
.
.
.
tiff2bw .
.
.
.
.
.
tiffsplit .
.
.
.
.
.
shown in table .
on average truzz equipped fuzzers discovered .
more new edge coverage than vanilla fuzzers.
for example truzz afl discoversmorethan20 edgesthanaflin6target programs.
however due to afl and aflfast do not infer the byteconstraint relation the reason why the code coverage decreases in some cases is still not clear.
to reveal a possible root cause we provide a case study in section ?
?.
it would be interesting to ascertain the root cause in the future work.
we further evaluate the performance of truzz using varghadelaney a measurement where a12 denotes the measure ofstochastic superiority thatpopulation 1is superior topopulation .
if the two populations are equivalent then a12 .
.
an a12largerthan0.5indicatesthatthepopulation1is stochastically larger than the population and vice versa.
for example the difference between truzz equipped fuzzer and vanilla fuzzer is determined as big when a12 .
medium when a12 .
and small when a12 .
.
specifically we test the numbers ofnewedgesandpathcoveragecollectedfromthefiveroundsofexperiments by vanilla and truzz equipped fuzzers after hours.
as shown in table the percentage of the results that a12 .
is81.
.especially .
oftheresultsachievethehighestscore of a12 .
.
therefore we conclude that the difference in new edgeandpathcoveragebetweenvanillafuzzerandtruzz equipped fuzzer is statistically large.
further we conducted separate experiments on byte analysis and seed prioritization in truzz as shown in table .
byte analysis equipped fuzzers neuzz and greyone and seed prioritization equipped fuzzers all fuzzers discovered .
.
and .
.
more new edges than vanilla fuzzers respectively.
the performance of byte analysis equipped afl aflfast mopt and fuzzfactory does not improve much.
we believe the reason is that those fuzzers randomly select mutation positions resulting in a low selection probability of mutating validation related bytes.
inference based fuzzers such as neuzz and greyone will firstly mutate interesting bytes e.g.
the bytes related to edges .
however based on their inference strategy validation related bytes are often consideredas interesting .ifvalidation relatedbytesarenot protectedduringthemutationphase mutatedinputswillflowintothe error handling code.
therefore byte analysis is more suitable for inference basedfuzzers i.e.
thefuzzersthatinfertherelationships between input bytes and path constraints.
answer to rq2.
truzz can significantly improve the coveragediscovery onaverage24.
moreedgecoverage .in out of program fuzzer pairs truzz equipped fuzzers achieve more code coverage than their vanilla fuzzers.
.
rq3 bug discovery we compare truzz equipped fuzzers with vanilla fuzzers in terms of the number of real world bugs.
weusegdbandafl collect toanalyzethenumberofbugs discovered by a fuzzer.
first we use afl collect to remove invalidcrash samples and achieve crash sample de duplication.
second weusegdbtomanuallyanalyzetheprogramlogicforeachbug removing bugs that have the same root cause.
table shows the number of unique bugs accumulated in runs found in the eight real world applications.
in total vanilla fuzzers and truzz equipped fuzzers find and 13vulnerabilitiesinfourapplications respectively.intheremaining four programs all the fuzzers do not identify bugs in hours.
specially stripis reported as vulnerable only by truzz equipped fuzzers.
for tiff2bw it converts an rgb or palette color tiff authorized licensed use limited to lahore univ of management sciences.
downloaded on august at utc from ieee xplore.
restrictions apply.
icse may pittsburgh pa usa kunpeng zhang et al.
table6 bugsdiscoveredbyvanillafuzzers orig.
andtruzzequipped fuzzers truzz .
program vulnerability type of vulnerabilities orig.
truzz readelf abortsignal sizeabortsignal destavnearnull stripabortsignal destavnearnull sourceav tiff2bwaccessviolation blockmoveav 1badinstruction 1sourceav heaperror imagetoa greyscaleimageby combiningpercentagesofthe red green and blue channels.
we discover bugs in tiff2bw.i nt h e caseof readelf wefoundonebugwhenitdisplaysinformation fromanyelfformatobjectfile.
stripdisplaysalistshowingall architectures and objectformats available and we identify3 bugs.
forthethreetruzz missedbugs twoin sizediscoveredbyafl and mopt and one in tiff2bwdiscovered by mopt we found thattheexecutions peedsofmopt in sizeandtiff2bw andafl insizedropped10 and13.
respectively whichmayleadto themissingofbugs.further therandomnessoffuzzingmayalso contributetotheresults.werepeatedexperiments5timesforeach fuzzer but the truzz missed bugs were only discovered by afl or mopt in trial.
answer to rq3.
truzz equippedfuzzersoutperformtheir vanilla fuzzers in terms of bug discovery identifying bugs in target programs and of them cannot be identified by vanilla fuzzers.
discussion complexity of programs.
our truzz infers the relations between input bytes and validation checks but the inference may erroneouslyrecognizenon validationchecksasvalidationchecks.
that is truzz may protect bytes that are related to non validation checks.
however our truzz still allows fuzzing to examine the shorter pathwithalowprobability i.e.
thecoderegionsbelonging to the shorter path are still examined.
one possible improvement is to optimally switch between the vanilla strategy and our byte analysis for selecting bytes.
anotherthreat to truzz is that some longerpathsmayhavesmallernumberofdescendants.thus the priorities of some seeds may be erroneously assigned.
truzz mitigatesthisproblemviadecreasingtherankingsofseedsifmutations of them do not identify more new edges.overhead of exe cution speed.
truzz will decrease the execution speed because it leads fuzzing to focus more on the execution of functionality code which usually cost more computational time than error handling code.
the execution speed of byte analysisequippedgreyoneandneuzzdroppedby23.
.
and .
.
separately.
the execution speedofseed prioritizationequipped afl and aflfast dropped by .
and .
respectively.specifically theexecution speedofaflfastdecreasedsignificantlyon tiff2bwandtiffsplit .
and38.
respectively .
this could be the reason why truzz aflfast discover less newcoverage.webelievethatsuchatrade offisworthybecause focusing on exploring functionality code will lead to more new code coverage and bugs finding.limitationsof truzz.
truzz has limitations in handling the scenarios that targeting input bytes that may take on a variety of constants.forexample ifthe defaultbranchof switch case branches isanerror handlingcode ourtruzzcannotdistinguishbetween differentcases.thesituationcanbemitigatedbysettingahigher lp in equation .
another way to mitigate the situation is to involve more seeds which may cover different branches in a switch case.
our truzz also has limitations when inferring bytes for checksum.
a slight change of checksum related data will fail the check of checksum andtruzzwillavoidmutatingchecksum relateddata.
this hinders the exploration of different data values for checksum.
as a future work it is interesting to investigate on how to protect a block of contiguous bytes and how to actively solve constraints.
conclusion theinferenceapproachesmayincludeextrabytesthatbelongto validation checks.
this will reduce the performance of fuzzing and assign too many computing resources to error handling code.
we mitigate the problem by inferring the validation related bytes and protect the bytes from being frequently mutated.
the inferenceis based on the observation that the difference of paths in pathtransitions imply the properties of programs.
as a result mostof the generated inputs will examine the functional code in lieu oferror handlingcode.thissolutionincreasestheprobabilityof identifying more code coverage and bugs in functional code.
we designandimplementtruzzbasedonouridea whichincreasesthe probability of generating valid inputs i.e.
the inputs that flow into functionalcodeonly.ourevaluationoneightopen sourceprograms showsthat truzz equipped fuzzerssignificantly outperformtheir vanilla versions.
we hope the optimization developed in this paper could advance the coverage guided greybox fuzzing domain.
data availability toenablereproducibility weprovideareplicationpackagepublicly available at