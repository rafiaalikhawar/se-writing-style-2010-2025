language agnostic dynamic analysis of multilingual code promises pitfalls and prospects haoranyang washingtonstateuniversity pullman wa usa haoran.yang2 wsu.eduwenli washingtonstateuniversity pullman wa usa wen.li wsu.eduhaipeng cai washingtonstateuniversity pullman wa usa haipeng.cai wsu.edu abstract analyzingmultilingualcode holistically iskeytosystematic quality assuranceofreal worldsoftwarewhichismostlydevelopedinmultiplecomputerlanguages.towardsuchanalyses state of the art approachesproposeanalmost fully language agnostic methodology andapplyittodynamicdependenceanalysis slicingofmultilingual code showing great promises.
we investigated this methodology through a technical analysis followed by a replication study applying it to real world multilingual projects of diverse language combinations.
our results revealed critical practicality i.e.
having the levels of efficiency scalability precision and extensibility to various language combinations for practical use challenges to the methodology.basedontheresults wereflectontheunderlying pitfallsof the language agnostic design that leads to such challenges.
finally looking forward to the prospects of dynamic analysis for multilingual code we identify a new research direction towards better practicality and precision while not sacrificing extensibility much as supported by preliminary results.
the key takeaway is that pursuing fully language agnostic analysis may be both impractical and unnecessary and striving for a better balance between languageindependenceand practicality may be more fruitful.
ccsconcepts software and its engineering dynamic analysis .
keywords multi language software multilingualcode dynamic analysis acm referenceformat haoran yang wen li and haipeng cai.
.
language agnostic dynamic analysis of multilingual code promises pitfalls and prospects.
in proceedingsofthe30thacmjointeuropeansoftwareengineeringconferenceand symposiumonthe foundationsofsoftware engineering esec fse november14 18 singapore singapore.
acm newyork ny usa 6pages.
introduction softwarefailures areconsequentialandcostly.afundamentalapproach to assuring software quality hence mitigating these failures haipeng caiis thecorresponding author.
esec fse november 14 18 singapore singapore copyright held bytheowner author s .
acm isbn978 .
to verify program behaviors via dynamic analysis .
for instance among other such analyses dynamic dependence analysis includingoneofitsspecialforms dynamicslicing hasempoweredarangeofapplicationsinsoftwarequality assurance e.g.
faultdiagnosis securitytesting .
meanwhile most real world software today is multilingual i.e.
the program is written in multiple languages according to recentstudiesregardlessofthesamplesize e.g.
around1 or over and data sources e.g.
at major companies or inthe open source world .
the latest studyconfirmed the status quo only of the studied systems use one language .
in this context holisticanalysis of multilingual code is key to systematicqualityassuranceofreal worldsoftwaresystems .
to understand this critical need consider a few specific cases.
in severalsamplesofandroidmalware themainapplogicinone languageinvokedmaliciouscodeinanotherlanguage.forinstance thegamemalware com.tinker.gameone retrievestheuser s facebook credential through its c code and passes the private datatoanuntrustworthyremoteserverinitsjavacode.suchissues alsohavebeenfoundintheandroidframeworkitself.forexample asreported incve the framework called fromits javacodeviathejavanative interface jni the qualcomm wi fi gbk2utfmodule in c which hadgbkencodingerrors.
yet cross languagebugs are not limited toone language combination e.g java c or oneinterfacing mechanism e.g.
jni albeit the onlyfewprior relevant worksavailable all targeted that particularcase i.e.
java cwithjni .forinstance recently li et al.
demonstrated multiple cases of high severity securityvulnerabilitiesofdifferentkindsthathappenacrosspython andc code in popularopen source projects such as numpy .
while these examples are about security defects cross language correctness defectswouldhappenthesameway.therootcauseis common thedefectsoriginatedinthecodewritteninonelanguage i.e.
onelanguageunit propagatedtoandwereonlyexhibitedina differentlanguageunit .itwouldbedifficultforsingle languagetechniques tools tofindthesedefectsastheirunderlying analysesarenotholistic theydismisscross languagedependenciesandbehaviors.manualapproaches e.g.
codereview arenot always practical because humans can get easily lost in complex large codebases like that of numpy one million sloc .
to addressthischallenge thestate of the artapproach orbs andits follow upworks proposeandpromote language agnostic dynamic analysis for multilingual code focusing on dynamic programslicingasademonstratingcase.herebeinglanguage agnostic means total language independence the analysis is designed without assuming i.e.
independently of any specific knowledge about the particularlanguages usedin the multilingualsoftware.
thiswork islicensedunderacreativecommonsattribution4.0international license.
esec fse november14 18 singapore singapore haoran yang wenli andhaipeng cai giventhegeneraldiversity intermsofvaryinglanguagecombinations used of multilingual code the promises of the languageagnostic methodology advocated in these prior approaches are highly meritorious both intuitively e.g.
it would work for any language combinations and based ontheirevaluation results.yet as we arguably and empiricallyshow there are also major pitfalls underneath this methodology that risk practicality.
ultimately the sensible pursuit should be on the balance between the language independence of the analysis design and the practicality of the analysiswithrespectto real world multilingualsoftware.
in this paper we reflect on thelanguage agnostic methodology as demonstrated in orbs the core in the line of works around it.
we first briefly revisit how it works and the promises it holds followed by discussing the pitfallsas illustrated through a replication study of orbsagainst randomly chosen multilingualprojectsongithub .weofferinsightsintoourempirical findingsandlayoutanewresearchdirectiontowardsalternative tradeoffsbetweenlanguageindependenceandpracticalitythatlead tomorepracticalsolutions aswelookforwardtothe prospects oflanguage agnostic dynamicanalysisofmultilingualcode.
openscience.our artifact for this paper isavailable on figshare.
the promises the state of the art multilingual analysis orbs achieves the greatestlanguage independencetodate itinstrumentsatthegiven query i.e.
slicingcriterion whichincludesacodelinenumberand a variable on that line and the rest of the analysis is language agnostic.
it works by tentatively deleting some other code lines recompiling and executing the remaining code and checking if the variable svaluechanges ifso thoselinesaredeleted.thisprocess isrepeateduntilnomorelinescanbedeleted andtheremaining code linesare consideredthe dynamicslice ofthe query.
indeed peritsinnerworkings orbsonlyrequiresprobingfor therun timevaluesofcriterionvariablesintheenclosinglanguage unit.otherthanthislanguage specificstep theanalysisdoesnotassumeanyknowledgeabout thesyntaxorsemantics thelanguages involved in the multilingual code under analysis.
this languageagnosticdesignholdsgreatpromises becausemultilingualsoftware isdiverseandcomplex.priorstudiesonsuccessfulprojectsintop companies reported that there were languages in use and most applications were written in to languages .
later studies basedon open source projects found that more than half of the samples used two or more languages.
most recently further studiesshowedthatmultilingualcodeusesavarietyoflanguage combinations e.g.
java c python shell javascript ruby php anddiversemechanismsforinterfacingbetweendifferent language units e.g.
one unit calling another via explicit calls to foreign functions one unitembedding another .
with these levels of diversity and complexity it is clearly desirable to have an analysis be agnostic of the underlying languages of a given multilingual program as it implies that the analysis can be perfectlygeneralizedtoanygivenmultilingualsoftwarewithout additional e.g.
language specificengineering effort.
theoriginal evaluationexperimentsfor orbs consolidatedthepromises it worked reasonably well for not only small benchmarks of a fewhundredlinesofcode butalsowith foursourcefileschosenfrom areal world multilingualproject bash aunixshell .
in sum as in non code based approaches e.g.
entirely droppinganycodeanalysis thelanguage agnosticmethodology demonstratedvia orbsappearedto be highly promising.
the pitfalls despite its appealing promises the language agnostic design instantiatedin orbs couldfacepracticalitychallengeswithlargescale real world multilingual systems.
the largest scale real world case studied in the original orbsevaluation only considered a quitesmallportion foursourcefiles oftheproject ratherthanthe holisticsystem.asaresult thecomplexitydealtwithmaynotbe representative ofthat ofawhole real world multilingualsystem.
.
technical analysis technically thedesignmaysufferfromafewlimitationsthatmake it impractical since the code lines to remove must be deleted togetherandlinesaregroupedspeculatively despiteaidsof simple heuristics it can take numerous trials resulting in alongtimetodeleteevenoneline e.g.
upto1minuteperlinefora smallprogramof2kloc everysingletrialrequiresacompleterecompilationandthenre executionoftheentiresoftware another potential source of overhead and inefficiency it only works with source code because it relies on deleting the code at sourcelevel and re buildingthe sourceafter deletion and itis semi automatedasitrequiresuserstowritemultiplescriptsthatfit the inner workings of the analysis for each system under analysis.
as a result the technique is not applicable where recompilation is infeasible e.g.
sourcecode isunavailableorincomplete .
the fact that the deleted lines are grouped speculatively has another potential consequence these linesmay not be maximally removable foreach instanceof the line deletionoperation.
inparticular sincethegroupingisheuristicandtentativewhilehaving tobedonescrupulouslytoreducethepossibilityof re compilation failure there may often be code lines that could be deleted but are not comprehensively identified for deletion.
the consequence is that the resulting slice may include many code lines that should not be in the slice i.e.
they should have been deleted since the criterion is not dependent on them .
in other words the languageagnosticmethodologyof orbsmayresultinanexcessiverateof false positives i.e.
greatimpression .
aboveall thegreatestbarrierwiththelanguage agnosticmethodology in orbsmay be its efficiency and scalability.
follow up works achieved valuable improvements e.g.
enabling forward slicing theoriginalimplementationof orbsonlyworksfor backward slicing mitigating the efficiency issue but the practicality efficiency scalability wise challenge remains due to the unchangednature ofthe language agnostic methodology.
.
empirical analysis tovalidatetheabovedissectionandunderstandthegap weperformedareplicationstudyon orbsusingtheartifactsharedbythe authorsintheirpaper .
dataset wetargetedopen sourcemultilingualprojectsongithub that primarily used two or all of three programming languages 1622language agnosticdynamic analysis of multilingual code promises pitfalls andprospects esec fse november14 18 singapore singapore table efficiency results of orbson real world systems.
subject languagecombination codesize qfin.time hrs pyrasite python c .
affinity java c pyjnius python java .
snappy java c shell pysonar2 java python deap python c .
sbe java c c brotli c c java javascript vertx web java python mongo c javascript python python c c andjava becausetheyarewidelyconsideredmainstreamlanguages andcommonly rankedamongthetop 5lists by various sources e.g.
.
among all such projects we sampled thosethatarepopular i.e.
with1 000ormorestars andactive i.e.
updated within the last six months .
we also dismissed projects where the language unit in any of the three targeted languages accounts for less than of total project code size.
then from the resultingsample werandomlyselected10projectsthatcoverall possiblecombinationsof thethreeprimarylanguages asoutlined intable1.the firstcolumn gives the projectname andlink.
metrics as per our technical analysis of the pitfalls we mainly examinetheefficiencyof orbsintermsoftheslicingtimecost.for eachslicingcriterion weseta timeoutof24hours whichisareasonablylargebudgetthatadeveloperpossiblyaffordsinpractice.in addition concerning the practical usefulness of the resulting slices we also look at the slice size generally the smaller slices are more desirablebecausedevelopersmaynotaffordinspectingavery large slice especiallygiventhat orbsitselfdoesnotprovideadditional guidance e.g.
inspectionprioritiesorrankingofstatementsina slice for the post slicing analysis.
procedure wehaveapplied orbstothe10chosenmultilingual systems onaubuntu18.
.5ltsserverwithintel r xeon r cpu e7 .40ghz and512gb ram.
for each subject we randomly picked one test to exercise it and10queries i.e.
slicingcriteria tocomputedynamicslicesfor suchthateachlanguageunitcontainsthenumberofqueriesthat is proportional to the code size of the unit.
for a given criterion if orbsdoesnotfinishtheslicingwithin24hours weterminatedit andconsideredthe casea timeout failure.
results theoverallefficiencyresultsaresummarizedintable .
thelanguagesforwhichatleastonequerywaspickedarelistedin the second column and the total code size of each subject in the third.thefourthcolumn qfin.
indicatesthenumberofqueries withwhich orbssuccessfully finishedthe slicing in24 hours.
as shown only relatively small subjects saw some queries finished within the timeout and orbstimed out for any query of the other subjects.
for the only out of total queries it returnedaslice for the averagecostwas9.
hoursper query.
table2outlinesthefurtherdetailsonthe27successfullyfinished cases includingtheslicingcriterion sc no.
2ndcolumn theslice size the number of source lines of code sloc in the slice 3rd column andthenumberofhours hrs spentoncomputingeach slice lastcolumn .the sliceratio theratiooftheslicesizetothe total number of executed lines in the subject execution underlying the slicing 4th column provides another perspective into theslicesizewithrespecttotheworst caseslicingresults i.e.
allthe executedlinesare consideredpart of the slice .
table detailed results on the finished cases of slicing.
sb.
subject sn.
slicing criterion no.
ss.
slicesize sloc sr. slice ratio th.
time hrs sb.sn.ss.sr.th.pyrasite113211 .
.
.
.
.
.
.
.
.
.60pyjnius12 .
.
.
.
.
.
.
.
.
.53deap15 .
.
.
.
.
.
.75asintheoriginal orbsevaluation wedidnothavetheground truthslicing results to compute precision and recall.
yet the numbers of table show that orbsis very likely to be excessively imprecise it produced more than halfofthe executedcode lines in all of the slices for the two relative large subjects.
.
keyinsights overall the empirical results appeared to corroborate the results of our technical analysis .
the language agnostic design instantiatedinorbssufferedcriticalefficiency scalability barriers and was subjectto excessive imprecision.
taking a closer look into the results we observed that in all the failure timeout cases orbswasstuck inunfruitfulcyclesbetweenrecompilation and line deletion because the deletioncausesfailurestocompile .
the underlying reason as outlined earlier wasthat orbsmade heuristic attemptsinidentifyingthe group of code lines to delete without even fully knowing about the syntactic nottomentionsemantic relationshipsamongthoselines.
asaresult themajorityofsuchattemptsfailedastheremaining program withthoselinesdeletedfailedto compile.
meanwhile in the small percentage of cases in which it finished the slicing within hours orbsoften identified excessively large groupsofcodelinestodelete.inparticular whenheuristicallyforming the group of code lines to delete the deletion line grouping step often ended up also including the lines that have no dependence relationships with the slicing criterion the result was the excessively largedynamicslices asseenespeciallyinthecasesof pyjnius.apparently therewasnoconsistentcorrelationbetween thedegree ofthisimprecision andthetotalcodesizeofthemultilingual system e.g.
deap is much larger than pyjnius .
verus .
kloc but the former saw much smaller slices produced by orbs versus80 interms of slice ratio.
inshort thisreplicationstudyledustothefollowing insights theneedforalmostnoknowledgeaboutanylanguagemakes orbsalmost fully language agnostic yet that lack of knowledge also led to totally uninformed hence opportunistic line deletion a core step in the design of the language agnostic methodology thus a more practical design would need to strike a better balance between language independence and efficiency scalability byutilizing slightly more knowledge abouteachlanguage.
the prospects followingtheinsightsobtainedfromourtechnicalandempirical analyses .
webelieveitis necessarytoexploreothertradeoffs 1623esec fse november14 18 singapore singapore haoran yang wenli andhaipeng cai analysis algorithm language analysislanguage analysislanguage n analysis language independent analysis data data harvesting instrumented multilingual codelanguage agnostic dynamic analysisanalysis data unification language specific static analyses decoupling original multilingual code written in ndifferent languages figure1 envisionedhigh leveldesignforbetterbalancing language independence andanalysis practicality.
betweenthelanguageindependenceandpracticality intermsofefficiency scalability primarily but also concerning practically useful levels of precision .note thatlanguage independencedoes matter for a multilingual code analysis because the more independent theanalysisisoftheunderlyinglanguages themoreextensible generalizable the analysis is to accommodate the diverse language combinationsinreal worldmultilingualsystems.thus atotalrelaxationofthetradeoffwiththe almostfully language agnostic methodologyasdemonstratedin orbsbyentirelycompromising languageindependencetofavorpracticalityisnotaviablesolution.
ingeneral weenvisionanewmethodologyfordynamicanalysis ofmultilingualcode asfordistributedsystems todecouple analysis e.g.
dependencecomputationorslicing algorithmfromdata harvesting i.e.
the process of collecting the program data needed by the analysis .
an overview of this decoupling design is depicted in figure1.thekeyideaandrationaleisthat thedataharvestingis realizedviaminimal language specific staticanalyses relyingonas little knowledge about each particular language of the multilingual codeaspossible buttheharvesteddataislanguage independent intermsof itsformatand semantics and the analysis algorithm itselfisthatofanentirely language agnostic dynamicanalysis as enabledbythelanguageindependenceofthedataharvested.inthis way we will overcome semantics disparity induced by language heterogeneity through minimal language specific effort so as to reach the practicality goal at the sweet spot in balancing language independence and practicality.
conceptually the language specific static analyses and the language agnostic dynamic analysis are bridgedthroughan analysisdataunification layerinbetweenwhere data harvestingwillactually happen at runtime.
the key insight underlying this proposed design is that minimizing language specific analysis hence maximizing languageindependenceand analysis extensibility yet not losing scalability can be achieved by decoupling analysis algorithms from specific languagesemanticsthroughharvestinglanguage independentdata .asa proof of concept of this design we built a cross language dynamic data dependence analyzer for java c programs on top of an earlier work sensa .
we instrumented at every statement where a variableisdefinedorusedasin tosendatruntimethevariable valueinalanguage agnosticformattoananalysisserverthroughinterprocesscommunication ipc .weusedsoot andllvm for probing and identifying variable definitions and uses in the javaandcunit respectively.wethenrantheinstrumentedcode twice onenormallytogettheoriginalexecutionandtheotherwith statements ofinterest beingvoided i.e.
operations there changed to nooperation .oncetheanalysisdataiscollectedbytheserver it computes dependencies through differencing the original and voided executions.
our experiments on a number of java c programs showedthat the decoupling design workedsuccessfully it correctly computed all dynamic data dependenciesacross the two heterogeneous language units.
the key here is that decoupling the analysis data collection and the core analysis algorithm is realized viaipc which isbynature language independent.
related work previousstudiessuggestedthatunifyingorabstractinglanguage semantics is not scalable because it relies on heavyweight perlanguage engineering .
converting code in differentlanguagesintoauniform intermediaterepresentation ir suffers from misinterpretation misconversion issues due to languagesemanticsdisparity.also theirconversionforagivenlanguage is not always practical because it requires vast engineering effort these issues are further aggravated by the evolution of eachlanguage forinstance whilellvm aimsatauniformir forseverallanguages onlyacoupleoffrontends e.g.
forc c receivedregularmaintenancewhilethoseneededfortheirconversionforother languages didnot henceare not practically usable.
meanwhile acommon ormeta model isnot amenable to dynamic analysis since code represented in such models e.g theuniform ir cannotbe executedanymore noraretheyable to represent executioninformation of the originalcode.
earlier approaches to cross language analysis are mostly staticwhile relying on substantial language specific modeling and or engineering.
recently proposed dynamic crosslanguageanalysis capturescoarse grained file level dependencies by modifying os kernel for regression test selection.
extractingco changepatternstoderivefile leveldependenciesachieves languageindependencebyavoidingcodeanalysis which isdifficult to extend for finergranularity.
conclusion asthegrowingmajorityoftoday ssoftwaresystemsarebuiltusing multiplelanguages holisticanalysisofmultilingualcodeisessential for systematic software quality assurance.
we revisited the promises of a state of the artmethodology for dynamicanalysis of multilingualcodethatpromotessuchanalysesbe language agnostic .
whileconceptuallyappealingandpromising thismethodologymay suffer technical limitations that impede its practical use against real world multilingual software systems.
we thus proceeded with an empirical analysis to demonstrate such pitfalls of the languageagnostic methodology.
following the insights distilled from our study weenvisionedanewmethodologytowardsmorepractical dynamic analysisofmultilingualsoftware.
acknowledgment wethank ourreviewersforconstructivecomments.
thisresearch wassupportedbynsf ccf andonr n000142212111 .
1624language agnosticdynamic analysis of multilingual code promises pitfalls andprospects esec fse november14 18 singapore singapore