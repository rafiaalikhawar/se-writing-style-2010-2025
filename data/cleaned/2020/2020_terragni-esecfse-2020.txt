evolutionary improvement of assertion oracles valerio terragni universit della svizzera italiana lugano switzerland valerio.terragni usi.chgunel jahangirova universit della svizzera italiana lugano switzerland gunel.jahangirova usi.ch paolo tonella universit della svizzera italiana lugano switzerland paolo.tonella usi.chmauro pezz universit della svizzera italiana lugano switzerland schaffhausen institute of technology schaffhausen switzerland mauro.pezze usi.ch abstract assertion oracles are executable boolean expressions placed inside the program that should pass return true for all correct executions and fail return false for all incorrect executions.
because designing perfect assertion oracles is difficult assertions often fail to distinguish between correct and incorrect executions.
in other words they are prone to false positives and false negatives.
in this paper we propose gassert genetic assertion improvement the first technique to automatically improve assertion oracles.
given an assertion oracle and evidence of false positives and false negatives gassert implements a novel co evolutionary algorithm that explores the space of possible assertions to identify one with fewer false positives and false negatives.
our empirical evaluation on java methods from different java code bases shows that gassert effectively improves assertion oracles.
gassert outperforms two baselines random and invariantbased oracle improvement and is comparable with and in some cases even outperformed human improved assertions.
ccs concepts software and its engineering software testing and debugging genetic programming .
keywords program assertions oracle improvement evolutionary algorithm acm reference format valerio terragni gunel jahangirova paolo tonella and mauro pezz .
.
evolutionary improvement of assertion oracles.
in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa.
acm new york ny usa pages.
.
esec fse november virtual event usa association for computing machinery.
this is the author s version of the work.
it is posted here for your personal use.
not for redistribution.
the definitive version of record was published in proceedings of the 28th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november virtual event usa introduction recently we witnessed great advances in test input generation .
however the oracle problem remains a major obstacle that limits the effectiveness of automatically generated test suites.
instead of generating test oracles for each automatically generated test case one could rely on assertion oracles to expose software faults.
assertion oracles also called program assertions are executable boolean expressions that predicate on the values of variables at specific program points.
a perfect assertion oracle passes returns true for all correct executions and fails returns false for all incorrect executions.
perfect oracles are difficult to design and thus assertion oracles often fail to distinguish between correct and incorrect executions that is they are prone to both false positives and false negatives which are jointly called oracle deficiencies .
afalse positive is a correct program state in which the assertion fails but should pass and a false negative is an incorrect program state in which the assertion passes but should fail .
oracle deficiencies are a serious problem for both manually and automatically generated assertion oracles.
in fact invariant generators are known to generate invariants that are incomplete and imprecise when used as assertion oracles .
they are incomplete because most dynamic invariant generators notably daikon and invgen cannot generate assertions that do not match pre defined templates of boolean expressions .
existing invariant generators are also imprecise because the generated invariants often do not generalize well with unseen test cases.
in fact nguyen et al.
s and staats et al.
s studies report high false positive rates for daikon invariants.
improving the quality of program assertions by removing oracle deficiencies is of paramount importance.
it would improve the fault detection capability and reduce the false alarms of both automatically generated and manually written test cases.
recently jahangirova et al.
proposed oasis to automatically identify oracle deficiencies.
given an assertion oracle oasis generates test cases and mutations that gives evidence of false positives and false negatives respectively.
this evidence is meant to support the developers in assessing and improving the oracles.
a recent study by oasis s authors shows that the manual improvement of assertion oracles is difficult .
given the oracle deficiencies detected by oasis for only of the given assertions humans successfully removed all oracle deficiencies.esec fse november virtual event usa valerio terragni gunel jahangirova paolo tonella and mauro pezz the difficulty of manually improving assertion oracles motivated us to study how to automatically improve assertions.
given an assertion oracle and some evidence of false positives and false negatives provided by an oracle assessor such as oasis we aim to automatically generate an improved assertion with fewer oracle deficiencies than .
while there are many techniques to automatically generate program assertions for example program invariants automatically improving assertion oracles is an unexplored problem.
in this paper we propose gassert genetic assert ion improvement the first technique to automatically improve assertion oracles.
given an assertion oracle and its oracle deficiencies gassert explores the space of possible assertions to identify those with zero false positives and the lowest number of false negatives.
gassert favors assertions with zero false positives as false alarms are known to trigger an expensive debugging process .
gassert addresses the challenge of navigating a huge search space with an evolutionary approach that evolves populations of assertions by rewarding assertions with fewer deficiencies.
gassert formulates the oracle improvement problem as a multi objective optimization problem moop with three competing objectives i minimizing the number of false positives ii minimizing the number of false negatives iii minimizing the size of the assertion.
the key challenge of defining a multi objective fitness function is that these three objectives are competing with each other.
simply merging the objectives into the same fitness function is not an effective solution as in moops it is difficult to simultaneously reduce all competing objectives .
for an evolutionary algorithm a possible strategy to improve a given program assertion might be either by first removing all false negatives accepting more program behaviors i.e.
generalizing the assertion or by removing false positives accepting less program behaviors i.e.
specializing the assertion or by an interleaving of these two strategies.
gassert addresses this challenge with a co evolutionary approach that evolves two populations in parallel with different fitness functions for each population.
the fitness functions of the first and second population reward solutions with fewer false positives and false negatives respectively considering the remaining objectives only in tie cases.
the two populations exchange their best individuals population migration on a regular basis to supply both populations with good genetic material useful to improve both the primary and secondary objectives.
moreover gassert presents novel crossover and mutation operators specifically designed for the oracle improvement problem.
we empirically evaluated gassert on methods from java code bases.
we evaluated the ability of gassert to improve an initial set of daikon generated assertions.
the improved assertions eliminate all false positives present in the initial daikon assertions and reduce the false negatives by on average with respect to the initial daikon assertions.
when executed with unseen tests and mutants the gassert assertions increase the mutation score by on average with respect to the mutation score obtained with the initial assertions.
in summary this paper makes the following contributions we formulate the problem of automatically improving assertion oracles given a set of false positives and false negatives we propose gassert the first technique to automatically improve assertion oracles we evaluate gassert on methods from seven java code bases and show that gassert outperforms both unguidedrandom and invariant based approaches we release our evaluation results zenodo.
and tool to facilitate future work in this area.
problem formulation this section provides the preliminaries for this work and formulates the problem of improving assertion oracles.
in this paper pis an object oriented program composed of a set of classes each defining a set of methods and fields.
given a program point of a method minp s denotes the set of all program states that can reach when mis executed.
a state s s defines an assignment of values to memory locations that are accessible visible at the program point e.g.
instance fields method parameters and local variables .
s is partitioned into two disjoint sets correct s and incorrect s program states.
we say that a state is correct if it satisfies the intended program behaviour incorrect otherwise.
we drop the subscript and use s s ands when is clear from the context.
a program point can be associated with an assertion oracle a quantifier free first order logic formula that predicates on variables and functions of boolean or numerical types and returns a boolean value t or f .
let denote the set of variables visible at the assertion point .
letfdenote the set of boolean and numerical operators that gassert uses to synthesize assertions.
the content of depends on whilefis fixed for any .
table shows the functions infgrouped by operand and output type.
assertion oracles aim to distinguish correct and incorrect executions.
we consider assertions inserted into program p and not into its test cases.
the difference is that assertions in phandle all possible test case executions while assertions in the test cases check the correctness of a single test execution.
more specifically an assertion oracle expresses a correctness property that is intended to be true at in all correct executions i.e.
s s t and false in all incorrect executions i.e.
s s f where denotes the evaluation of the boolean expression on state s. we callperfect oracle an assertion that satisfies such a condition.
perfect oracles are difficult to design and assertion oracles often fail to distinguish correct from incorrect executions i.e.
they have false positives and false negatives which we call oracle deficiencies .
definition .
afalse positive of an assertion at a program point is a reachable program state where is false although such state is correct according to the intended program behavior .
more formally it is a state s s f. definition .
afalse negative of an assertion at a program point is a reachable program state where is true although such state is incorrect according to the intended program behavior .
more formally it is a state s s t. in this paper we study the problem of automatically improving assertion oracles that is given an assertion and a set of oracle deficiencies generating a new assertion with fewer deficiencies.evolutionary improvement of assertion oracles esec fse november virtual event usa table functions fconsidered by gassert operand output functions type type number number number modulo number number boolean boolean boolean boolean and or xor exor implies equiv.
boolean boolean not identifying oracle deficiencies by enumerating all correct and incorrect states is infeasible because it requires to enumerate infinitely many executions .
thus we rely on a precise but incomplete oracle assessoroa that returns evidence of false positives and false negatives if any for a given assertion.
we assume any oa to be precise it reports only real oracle deficiencies but possiblyincomplete it may miss oracle deficiencies because it cannot enumerate all possible correct and incorrect executions.
an oracle assessor can be either a human or an automated technique.
to enable full automation we rely on the automated oracle assessor oasis .
given an assertion oasis leverages search based test generation and mutation testing to report oracle deficiencies if any can be found within the given time budget.
oasis finds false positives of an assertion by generating test cases that make return false in the reached state.
oasis considers such states as false positives of because it targets the implemented program behavior which might differ from the intended one.
as such gassert needs a manual validation of the improved assertions to ensure that they capture the intended program behavior.
oasis finds false negatives of an assertion by seeding artificial faults mutations into program pusing mutation testing .
oasis generates a test case and a mutation that produce a corrupted program state s s at the assertion point where does not reveal the fault i.e.
returns true.
we now define the oracle improvement problem given an oracle assessoroa.
letadenote the universe of possible boolean expressions containing variables in and functions inf.
to makea a finite set we bound the size of assertions i.e.
the number of variables and functions in the assertions to a maximum value in our experiments .
let fp s denote the number of false positives of wrt a finite subset s ofs .
that is fp s is the number of states s s s f. similarly fn s denotes the number of false negatives of wrt a finite subset s ofs .
that is fn s is the number of states s s s t. problem definition .
given an assertion at a program point inp given a set of false positives s s and a set of false negatives s s reported by an oracle assessor oa and an overall time budgetb theoracle improvement of is the process of finding withinba new assertion a such that fp s 0and either fp s fp s or fn s fn s .
in defining the oracle improvement we give priority to false positive over false negative reduction by requiring all false positives to disappear in the improved oracle .
the rationale for this choice is that false negative reduction can be easily achieved with assertions that raise many false alarms.
however such assertions are troublesome for developers as they trigger an expensive debugging process in which the root of the assertion failures may likelyalgorithm gassert iterative oracle improvement process input initial assertion at progr.
point inp time budgetb output improved assertion 1function gassert 2p instrument method at program point p s s get initial correct and incorrect states p while time budgetbis not expired do get dictionary of variables s s 6 oracle improvement s s s new s new oracle assessment a oasis ifs new s new then return s s s new s s s new 12 return be the assertion itself.
therefore we privilege assertions with no false alarms no false positives .
ideally the improved assertion oracle has zero oracle deficiencies wrt to s ands i.e.
fp s fn s .
however generating such assertions can be expensive and difficult and may be infeasible within a reasonable time budget as an oracle that detects all faults could be as complex as the method under test .
therefore we deem an oracle with zero false positives and the lowest number of false negatives sufficiently adequate in practice .
gassert algorithm overviews the gassert approach.
gassert s inputs are i an assertion oracle ii the program point inpwhere is placed and iii a time budget b. the output of gassert is an improved assertion .gassert improves assertion oracles with an iterative process.
before the first iteration gassert instruments pto capture program states at runtime line of algorithm .
it then produces an initial set of correct and incorrect states s and s by executing an initial test suite on the instrumented version p and on its faulty versions mutants respectively line .
the while loop at lines implements the iterative process.
gassert gets the dictionary of variables from the states s ands line and invokes the oracle improvement of line .
the oracleimprovement algorithm which we discuss in section .
returns an improved assertion line .
if oasis cannot find any oracle deficiencies of algorithm returns and the iterative process terminates lines and .
otherwise gassert adds the newly identified false positives and false negatives s newands new tos ands lines and respectively.
the improved assertion replaces the initial assertion line and a new iteration starts.
.
running example we now describe the gassert oracle improvement process with a running example.
figure shows a java method that accepts two integers xandyas parameters p and returns the minimum between them.
the figure also shows i the assertion point line ii two instrumented method calls to collect the program states lines and and iii two mutants m1andm2used to produce false negative program states lines and .esec fse november virtual event usa valerio terragni gunel jahangirova paolo tonella and mauro pezz table input and output of the oracle assessor oa of our running example false positives fp false negatives fn iter.
input assertion test state test mutant state min x t1 min x y s x y min t2 min x y m1 s x y min min x and min y t3 min x y m2 s x y min min x or min y and min x and min y publicstaticintmin intx inty serializer x y instrumentationintmin if x y min x mutantm2 min else min y mutantm1 min y serializer x y min instrumentation program point pp of the assertion oraclereturnmin figure java source code of the running example.
table illustrates how gassert improves a trivially incomplete initial assertion min x into a stronger assertion that intuitively captures the expected behavior of a min function min x or min y and min x and min y .
column input assertion shows the assertions that the oracle assessor oa receives as input at each iteration.
the first assertion min x is provided to gassert as an input while the following two assertions are automatically generated by its evolutionary algorithm.
the initial assertion can be manually generated or inferred with a tool.
column false positives fp shows the false positive states with the test cases that produce them.
on such states fails while it should pass.
similarly column false negatives fn shows the false negative states with the test cases and the mutants that produce them.
on such states passes but it should fail.
in the example oa identifies both fps and fns for min x. table reports a test case t1thatoa generates for and for which incorrectly returns false.
the execution of test cases t1produces the state s 1that is a false positive for see def.
.
the table also reports a sample test case t2and mutant m1thatoa generates for and for which incorrectly returns true does not kill mutant m1 .
the execution of test cases t2with mutant m1produces the state s 2that is a false negative for see def.
.
at the first iteration gassert takes as input the false positive s 1and the false negative s 2of and returns the improved assertion min x and min y .gassert produces with an evolutionary algorithm that evolves populations of assertions towards an assertion with zero false positives and the lowest number of false negatives.
the evolutionary algorithm explores the search space by i selecting pairs of assertions parents by means of fitness functions that reward solutions with fewer oracle deficiencies ii creating new and possibly fitter offspring by exchanging genetic materials portions of assertions of the parents with crossover operators and iii mutating the offspring with a certain probability using mutation operators.
we now exemplify how the evolutionary algorithm obtains min x and min y during the first iteration.
let usassume that the algorithm selects two parents p1 min xand p2 min y. the assertion p1reduces the number of false positives with respect to the initial assertion fp p1 s where s s but it does not reduce the number of false negatives because p1evaluates true under s s fn p1 s .
conversely the assertion p2reduces the number of false negatives fn p2 s but it has the same number of false positives as fp p2 s fp s .
the crossover operator merge crossover applied to p1and p2produces the offspring o1 min x and min y and o2 min x or min y .
if the mutation operators mutate o1into min x and min y gassert obtains an improved assertion with zero oracle deficiencies wrt s ands and the first iteration terminates.
at the second iteration oa takes in input min x and min y to find its oracle deficiencies if any .
for this assertion oa does not find false positives but it reports a false negative executing test t3with mutant m2leads to the state s which is a false negative for fn s where s s s .
in fact returns true under s while it should return false.
given the assertion min x and min y the correct states s s and the incorrect states s s s the evolutionary algorithm returns the improved assertion min x or min y and min x and min y .
this assertion does not have oracle deficiencies wrt s ands i.e.
fp s fn s .
asoa does not find oracle deficiencies for thegassert improvement process terminates.
the following two subsections describe in detail how gassert serializes program states and how it improves assertion oracles.
.
program state serialization a program state s v1 vn is a set of variables that are in memory at a certain execution point.
each variable vihas a type type vi an identifier id vi and a value value vi .
deciding which variables compose a program state is a key design choice.
it defines both the expressiveness of the assertions that gassert can produce the dictionary and the size of the search space a .
gassert should consider variables that capture useful properties of the method under test and ignore irrelevant ones.
indeed considering too many variables unnecessarily increases the search space which hardens the problem of finding oracle improvements.
given a method m p with formal parameters p gassert constructs the program state sat considering as variables all parameters piof pand all the local variables created in mthat are visible at .
note that when m p is a non static method the object receiver of m this injava ism s first parameter p0.gassert captures the values of the parameters both at the beginning of the method adding the prefix old to the variable identifiers and immediately before .
by considering old values gassert can generate assertions that predicate on method preconditions .evolutionary improvement of assertion oracles esec fse november virtual event usa when the considered variable has a primitive type gassert simply adds its runtime value to the program state rounding floats with a fixed precision using the variable name as identifier.
however variables of object oriented programs can have both primitive and non primitive object types introducing the problem of obtaining primitive values from objects.
given a non primitive variable vi there are two well established approaches to obtain primitive values object serialization and observer abstraction.
object serialization captures the values of all primitive type object fields that are recursively reachable from vi.observers abstraction captures the return values of observer methods invoked with vias the object receiver.
observer methods are side effect free methods that are declared in vi s class and return primitive values.
such values often characterize important properties of objects .
both approaches have advantages and disadvantages.
object serialization can lead to many variables which unnecessarily increase the search space.
indeed many recursively obtained primitive variables often refer to implementation details that do not capture interesting properties of objects.
observers abstraction is inherently incomplete because the available observer methods might not capture all the relevant aspects of the analyzed objects .
hybrid state serialization.
to address the issue gassert opts for a hybrid solution that combines both approaches.
we rely on observer methods for all non primitive variables considered by gassert .
in addition we use the object serialization approach only for the object receiver this of the method under test m capturing the values of all primitive fields of this .
for non primitive fields of this we do not serialize their recursively reachable primitive fields but again we use the observers abstraction approach.
the rationale is that the primitive fields of m s object receiver are more likely to capture important aspects of the behavior of mthan recursively reachable primitive fields or other method parameters.
we now describe in detail our hybrid approach.
letvibe a non primitive variable considered for constructing the program state s.gassert finds the observer methods f1 f2 .
.
.
fn of the class cofviby using a static analyzer that scans the bytecode instructions of the public methods in c. the analyzer marks a method fjasobserver if i fjreturns a number or a boolean and ii fjcannot directly or indirectly execute putfield orputstatic bytecode instructions mis side effect free and iii fjdoes not have parameters besides the object receiver .
when collecting state sat runtime for each observer method fjwith return type j gassert adds to state sa variable with identifier id vi .fj type jand value the result of the invocation of vi.fj.
for non primitive variables of type array string or java collection objects that extend java.util.collection gassert considers a smaller set of observer methods that capture the most important properties of such object types.
gassert addsvi.size vi.len thfor arrays and string and vi.isemptyto the state s. ifviis the object receiver i.e.
id vi this gassert serializes it by adding variable this .fieldjto the state s for each primitivetype field fieldjofthis .
it then applies the observer methods approach described above to each non primitive fields of this .
collecting states.
function instrument method at programpoint instruments the method mthat contains by adding two method calls algorithm line .
one at the beginning of themethod to get the old values and the other immediately before .
when a test execution reaches the instrumented method calls gassert performs the state serialization described above.
every time gassert executes a new test it stores the observed states so that the fitness functions can compute the number of fp and fn without requiring expensive program re executions.
initial program states.
function get initial correct and incorrect states line algorithm generates a set of initial correct s and incorrect s program states by executing an initial test suite on both the instrumented program p and its faulty versions.
the rationale of considering these initial states as opposed to immediately relying on the oracle assessor oa is to minimize the number of iterations of the while loop line algorithm .
in this way gassert avoids invokingoa to detect obvious oracle deficiencies and rather lets oa focus on hard to find ones.
post processing the states.
function get initial correct andincorrect states post processes the states with two scans.
the first scan removes redundant states from s so that s1 s2 s such that s1ands2areequivalent s1 s2 i.e.
all corresponding variables have identical values v1 s1 v2 s2 if id v1 id v2 then value v1 value v2 .
the second scan checks that each state in s is indeed incorrect i.e.
the seeded fault the mutant has successfully corrupted the program state.
for each incorrect state s s gassert retrieves the correct state s s obtained when executing the same test that produced s on the original version of the program without the seeded fault .
if s s gassert found a likely equivalent state and removes s from s .
we call them likely because our collected states encode only a fragment of the actual program state.
dictionary of variables.
function get dictionary of variables line algorithm builds the dictionary of variables that function oracle improvement uses to create new assertions.
the function picks an arbitrary state sin either s ors by construction all states have the same variables and adds all the variables in sto .
.
oracle improvement a major challenge to automatically improve assertion oracles is the huge search space of candidate solutions ain section which grows exponentially with the number of variables and functions.
gassert addresses this challenge with genetic programming gp .
we formulate the oracle improvement problem as a multi objective optimization problem moop with three competing objectives i minimize the number of false positives fp ii minimize the number of false negatives fn iii minimize the size of the assertion that is the number of variables and functions in it.
the latter objective helps to improve the quality of assertions as long assertions are often difficult to understand.
classic multi objective evolutionary approaches for instance nsga ii rely on pareto optimality to produce solutions that offer the best trade off between competing objectives .
however in our case not all assertions with an optimal trade off between fps and fns are acceptable solutions.
as discussed in section we aim to obtain assertions with zero fps and the lowest number of fns.
on the other hand primarily focusing on reducing fps may be inadequate as there may not be enough evolution pressure to reduce the fns at the same time.esec fse november virtual event usa valerio terragni gunel jahangirova paolo tonella and mauro pezz hence we propose a co evolutionary approach that evolves in parallel two distinct populations of assertions populfpandpopulfn with two competing objectives reduce the false positives fitness function fp and reduce the false negatives fitness function fn .
these populations periodically exchange their best individuals population migration to add promising genetic material in both populations.
eventually populfpwill more likely produce assertions with zero fps and fewer fns.
in fact the migration of best individuals adds in populfpassertions with a decreasing number of fns.
fitness functions.
both fpand fnare multi objective fitness functions.
the former gives priority to reducing false positives while the latter to reducing false negatives.
both functions consider the remaining objectives only in tie cases.
in multi objective optimization the fitness of a solution is often defined by the concept ofdominance .
while the standard definition of dominance gives the same importance to all objectives we need an unbalanced definition towards fps and fns which we define as follows definition .
fp fitness fp .
given two assertions 1and 2 and two sets of correct s and incorrect s states 1dominates fp 2 1 fp 2 if any of the following conditions is satisfied fp 1 s fp 2 s fp 1 s fp 2 s fn 1 s fn 2 s fp 1 s fp 2 s fn 1 s fn 2 s size 1 size 2 definition .
fn fitness fn .
given two assertions 1and 2 and two sets of correct s and incorrect s states 1dominates fn 2 1 fn 2 if any of the following conditions is satisfied fn 1 s fn 2 s fn 1 s fn 2 s fp 1 s fp 2 s fn 1 s fn 2 s fp 1 s fp 2 s size 1 size 2 in tie cases fp 1 s fp 2 s andfn 1 s fn 2 s both functions favor smaller assertions.
if neither 1 2nor 2 1 the choice between 1and 2is random.
we now describe the details of our co evolutionary algorithm algorithm .
building the initial populations.
both populations populfpand populfncontain nassertions each.
we represent an assertion popul as a rooted binary tree where leaf nodes are variables or constants terminals and inner nodes are functions.
each node has a type either boolean or numerical.
the type of leave nodes is the type of the associated variable the type of the inner nodes is the type of the function outputs.
we define the size of an assertion size as the number of nodes in its tree representation.
function get initial population at lines and of algorithm initializes the two populations populfpandpopulfn respectively in the same way.
half of the initial population consists of randomlygenerated assertions to guarantee genetic diversity the other half of assertions is obtained by randomly mutating the input assertion to have good genetic material for evolution .
intuitively an improved assertion could include fragments similar to the input assertion thus initializing the populations with variants of increases the chances of introducing good genetic material.
gassert produces the first half of individuals with a tree factory operator that takes a type either number or boolean andalgorithm evolutionary improvement of assertion oracles input correct s and incorrect s states assertion oracle output improved assertion oracle 1function oracle improvement populfp get initial population populfn get initial population for gen from to max number of gen do if a populfp populfn fp a s fn a s and gen min number of gen then return a do in parallel populfp select and reproduce populfp fp s s populfn select and reproduce populfn fn s s ifgen frequency migration then do in parallel populfp migrate populfn fp fn populfn migrate populfp fn fp return a with zero fp and the lowest number of fn input population popul fitness function dictionary of variables correct s and incorrect s states generation count gen output new population popul new 16function select and reproduce popul compute fitness popul s s popul new ifgen frequency of elitism then popul new get best individuals while popul newis not full do ap1 ap2 select parents popul ao1 ao2 crossover and mutation ap1 ap2 add ao1 ao2 topopul new return popul new a depth d and returns a randomly generated assertion with root of type and depth of the tree d. because the root of an assertion must be of boolean type gassert always sets to boolean and invokes tree factory n 2times with random values of d. tree mutations.
to obtain the second half of individuals gassert relies on two classic tree based mutation operators node mutation changes a single node in the tree .
it takes as input an assertion and one of its nodes n and returns an assertion 1obtained by replacing the node nin 1with a new node with the same type of n chosen randomly .
subtree mutation replaces a subtree in the tree .
it takes as input an assertion and one of its nodes n and returns a new assertion a1obtained by substituting the subtree rooted at nwith another subtree.
such a subtree is generated by the tree factory operator with the type of nas and a random number as d. stopping criterion.
algorithm evolves the two populations in parallel until either populfporpopulfncontains a perfect assertion with respect to the correct and incorrect states in input line of algorithm .
if gassert finds the perfect assertion before a maximum number of generations it continues the evolution process to see if it can find perfect assertions of smaller size.
algorithm prematurely terminates when the overall time budget bexpires or when it reaches a maximum number of generations.
in both cases gassert returns the best generated assertion the one with zero false positives and the lowest number of false negatives that is s.t.
populfp populfn fp line algorithm .evolutionary improvement of assertion oracles esec fse november virtual event usa lines and of algorithm evolve in parallel the two populations by invoking function select and reproduce lines .
the function implements the classic evolutionary approach which works in three consecutive steps selection crossover and mutation.
gassert introduces novel selection and crossover operators that are specific for the automatic oracle improvement problem.
fitness computation.
gassert initializes the selection process by computing the number of false positives fp s and false negatives fn s for each popul function compute fitness line algorithm .
both fitness functions need this information to compute the dominance relation.
gassert optimizes the fitness computation by i loading the s ands states in the primary memory to avoid costly re executions of the program ii parallelizing the computation iii caching the results to avoid recomputing them upon encountering the same assertion multiple times.
function select and reproduce initializes the new population popul newwith the empty set line of algorithm performing the elitism if gen frequency migration .
it then proceeds with parent selection parent crossover and offspring mutation adding the resulting offspring to popul newuntil popul newreaches size n. parent selection.
function select parents selects two parents ap1andap2from popul line in algorithm .
gassert implements two different selection criteria tournament and best match selection and chooses between them with a given probability.
tournament selection is a classic gp selection criterion .
it runs tournaments among krandomly chosen individuals and selects the winner of each tournament the one with the highest fitness .
as gassert needs two parents it plays two tournaments to obtain p1and p2.
we choose k the most commonly used value as it mitigates the local optima problem .
best match selection is a new criterion presented in this paper which is specific to the oracle improvement problem.
the criterion exploits semantic information about the correct and incorrect states that each assertion covers .
let cov s denote the subset of s on which evaluates to true i.e.
cov s s s t s .
let cov s denote the subset ofs on which evaluates to false i.e.
cov s s s f s .
the best match criterion selects the first parent p1randomly from popul .
ifpopul ispopulfp the best match selection criterion gets the set of all assertions 1 populfpsuch that cov 1 s cov s .
for each assertion 1in the set the best match selection criterion considers the cardinality of cov 1 s cov s as the weight of 1. it then selects the second parent p2from the set using a weighted random selection where assertions with a higher weight are more likely to be selected.
symmetrically if popul ispopulfn the best match criterion considers cov instead of cov .
intuitively the criterion increases the chances of crossover between two complementary individuals that are likely to yield a fitter offspring.
crossover.
function crossover and mutation exchanges genetic material between two parents p1and p2 producing two offspring o1and o2 which gassert mutates with a given probability with the mutation operators used to initialize the two populations.
gassert implements two crossover operators subtree and merging crossover and chooses between them with a given probability.subtree crossover is the canonical tree based crossover.
given two parents it selects a crossover point in each parent and creates the offspring o1and o2by swapping the subtrees rooted at each point in the corresponding tree .
merging crossover is an operator that we specifically defined for the oracle improvement problem.
given two parents p1and p2 it selects two boolean subtrees 1from p1and 2from p2 and creates the offspring o1 1an d 2 and o2 1or 2 .
this operator works well in synergy with our best match criterion since merging two subtrees with or and and functions combines their semantics without disrupting them.
node selectors.
a key design choice is the criterion to select the nodes of the tree for crossover and mutation.
we implemented two different selection criteria i random that randomly selects a node in ii mutation based that selects a node in such that the subtree rooted on this node contains at least a variable viwith the following property s s in which the value of vidiffers from the value in the corresponding state s s obtained when executing on the original program the same test that yielded s .
as such vican recognize s as a false negative of .
a such a new assertion that predicates on vicould solve such a false negative.
migration.
gassert periodically exchanges the mbest individuals between the two populations where mis a hyper parameter of the algorithm see lines of algorithm .
when selecting the best individuals gassert considers both fitness functions so that both populations can benefit from assertions that have either the lowest number of false positives or false negatives.
evaluation to experimentally evaluate our approach we developed a prototype implementation of gassert forjava classes.
we conducted a series of experiments to answer three research questions rq1 isgassert effective at improving assertion oracles?
rq2 how does gassert compare with random unguided and invariant based oracle improvement?
rq3 how does gassert compare with human oracle improvement?
rq1 evaluates the effectiveness of our evolutionary algorithm.
rq2 checks whether our fitness functions provide useful guidance to improve assertions.
towards this goal we compare gassert with a version of gassert random where the guidance provided by our fitness functions is replaced by a random choice.
as a further baseline rq2 compares gassert with an oracle improvement process inv based that relies on the invariant generator daikon to improve assertions.
rq3 compares our automated approach with oracle improvement performed by humans.
.
subjects we conducted our experiments on java methods.
we took four methods from the simpleexamples se class used by the recent jahangirova et al.
s oracle improvement study .
ten methods from the daikon subjects stackar sa and queuear qa often used to evaluate java invariant generators.
we selected the remaining methods from four popular java libraries apache commons math cm apache commons lang cl google guava gg and jts topology suite ts .
from each library we randomly selectedesec fse november virtual event usa valerio terragni gunel jahangirova paolo tonella and mauro pezz five methods with the following characteristics i contain at least five lines of code ii produce a return value iii are not recursive iv do not write to files and do not use reflection as the outcome of such operations cannot be captured by our assertion oracles .
for each of the methods we selected as the program point of the assertion the last exit point of the method.
.
evaluation setup to run gassert we need an initial test suite and perform mutation analysis to get an initial set of incorrect states in addition to the correct states obtained by running the initial test cases on the original program.
we also need some initial assertions to be improved.
we evaluate the improved assertions with the number of false positives and false negatives on the initial test cases and mutations.
to avoid circularity in the evaluation we collected a new sets of validation test cases and mutations.
the number of false positives and the mutation score obtained on the latter provide an external assessment of effectiveness.
initial test cases and mutations.
we obtained the initial correct states s by executing an initial test suite t0 on the instrumented version ofp.
we generatedt0by running evosuite v. .
.
with the branch coverage criterion and a time budget of one minute .
we performed ten runs with different random seeds to collect a diverse and large set of initial test cases.
we obtained the initial incorrect states s by executing the initial test suite t0 on a set of initial mutations m0 of the instrumented version of p. we obtained such mutations by running major v. .
.
enabling all types of supported mutants.
columns s and s of table show the cardinality of the initial states.
note that for some subjects s s which is counterintuitive.
this is because gassert removes redundant states from both s 0ands and likely equivalent states from s .
initial assertion oracles.
we obtained an initial assertion for our subjects by running the dynamic invariant generator daikon v. .
.
with the initial test suite in input.
we chose daikon because is a fully fledged tool and is the de facto invariant generator for java methods .
because also daikon accepts in input a set of observer methods we ran daikon with the same observer methods thatgassert used to serialize program states.
daikon generates invariants considering all possible exit points of a method e.g.
returns and exception throw statements .
however our oracle improvement process focuses on a single program point .
to ensure that daikon generates invariants that consider only the exit point at we automatically remove all the initial test cases that do not reach i.e.
do not produce program states .
daikon outputs invariants as a series of precondition 1 2 .
.
.
nand postcondition assertions 1 2 .
.
.
m .gassert converts them into a single complete java assertion in the form of 1and 2 .
.
.
and n 1and 2 .
.
.
and n .
gassert initializes half of the populations by adding the complete assertion all single and and random mutations of each of these assertions.
gassert initializes the other half of the populations with randomly generated assertions.
validation test cases and mutations.
to evaluate if the improved assertions generalize well with unseen correct and incorrect states we generated new test cases tv and mutations mv .
wetable gassert configuration parameters values parameter description value parameter description value bound on the size of the assertions 50prob.
of crossover size of each of the populations n prob.
of mutation minimum number of generations prob.
of tournament parent selection maximum number of generations prob.
of best match parent selection frequency of elitism every x gen 1prob.
of merging crossover frequency of migration every x gen prob.
of random crossover number of assertions for elitism 10prob.
of mutate state diff node selector number of assertions to migrate m prob.
of random node selector obtained such validation sets using the tools randoop v. .
.
and pit v. .
.
respectively.
these tools are different from the ones that provide test cases and mutations to the oracle improvement process evosuite major andoasis .
different tools are expected to obtain different test cases and mutations.
for each subject we ran randoop ten times with different random seeds using at least test cases or three minutes as stopping criterion.
we ran pitenabling all types of supported mutants.
columns tv and mv of table show the cardinality of the validation test cases and mutations respectively.
quality metrics for assertions.
we evaluate an improved assertion by comparing the number of fps and fns of with the number of fps and fns of the initial assertion wrt the initial and validation sets of test cases t and mutations m .
before evaluating the assertions we removed from all the test cases the test oracle assertions that evosuite andrandoop generated.
we then inserted the assertion under evaluation either or into the method under analysis at the specified .
to evaluate an assertion with the initial sets we executed t0and count the number of failing tests which represents the number of false positives fp s fp0in short.
if fp0is zero we compute fn s fn0in short by running mutation testing with mutationsm0and test casest0.
iffp0is greater than zero we cannot run mutation testing because we need a green test suite.
in such a case if the evaluated assertion has the form assert 1and 2and 3 we consider each of the smaller assertions assert 1 assert 2 andassert 3 and remove those that have false positives.
we concatenate the remaining smaller conditions with ands and perform mutation testing with m0andt0for this reduced assertion at .
if all smaller assertions have false positives then we report fn0for the assertion oracle assert true .
we follow the same procedure to evaluate an assertion with the validation test cases tv and mutations mv .
we use fpvto denote the number of false positives of an assertion wrt tv.
while major returns the source code of each mutation pitdoes not.
thus we cannot compute the number of false negatives wrt tvandmvbut only the mutation score denoted by mv .
configuration.
table shows the gassert configuration parameters values used in our experiments.
we selected these values after some trial runs following popular gp guidelines .
we ran gassert with an overall time budget bof minutes.
to ensure thatgassert will leverage the feedback of oasis we set an internal time budget of the oracle improvement process to minutes.
as such gassert must receive the feedback of oasis at least two times.
to cope with the stochastic nature of gp we ran gassert ten times with the same input assertion and initial correct and incorrect states.
we implemented gassert to be pseudo deterministic givenevolutionary improvement of assertion oracles esec fse november virtual event usa table evaluation results for rq1 and rq2 rq1 rq2 subj.
evaluation sets initial assertion gassert improved median random improved median inv based improved median id s s t v m v fp0fn0fpvmv size iter.
fp 0fn0fpvmv size iter.
fp 0fn0fpvmv size iter.
fp 0fn0fpvmv size se1 se2 se3 se4 sa1 sa2 sa3 sa4 sa5 qa1 qa2 qa3 qa4 qa5 cm1 cm2 cm3 cm4 cm5 cl1 cl2 cl3 cl4 cl5 gg1 gg2 gg3 gg4 gg5 ts1 ts2 ts3 ts4 ts5 the same random seed.
to avoid biases in selecting the seeds we used the numbers from to .
we executed each run on a dedicated amazon ec2 instance c5.4xlarge with intel xeon .9ghz cpus and 32gb of ram.
the total machine time of the experiments was hours subjects x tools x minutes x repetitions .
.
rq1 effectiveness columns initial assertion of table indicate the quality of the initial assertions generated with daikon .
for eleven subjects se4 cm1 cm2 cm3 cm5 cl1 gg1 gg4 ts2 ts3 and ts4 daikon does not generate any invariant and in this case we consider assert true as the initial assertion.
the false positives of on the initial tests fp are always zero except for subject cl5 .
this is an expected result because daikon uses the execution traces of the initial tests to generate .
the size of the initial assertions ranges from to on average .
for six subjects the size is over confirming that daikon can generate many often redundant preconditions and postconditions .
the number of false negatives on the initial tests fn ranges from to on average .
the number of false positives on the validation tests fp v is always zero except for two subjects sa5 and qa1 indicating that the initial assertions perform well with unseen tests.
this result may depend on the high branch coverage of the evosuite generated initial tests.
the mutation score on the validation set ranges from to on average .columns gassert improved median indicate the quality of the gassert improved assertions.
we report the median values of the ten executions.
the number of iterations ranges from to on average .
the median fp on the initial tests fp is zero for all subjects as gassert produces by construction assertions with zero false positives wrt s .
the median fn on the initial tests and mutations fn ranges from to .
the average is which is .
less than the average fn 0of the initial assertion .
for subjects the median fn 0ofgassert improved assertion is less than fn 0of the initial assertion .
although for nine subjects is the same including subjects se2 qa1 and qa4 with fn gassert often drastically reduced the size of the initial assertions.
these results demonstrate that our evolutionary algorithm is effective in improving assertion oracles.
for only subject sa2 has more false negatives than .
this is because when generating invariants daikon relies on its own set of helper functions that are not supported by gassert and had thus to be excluded from the initial assertion when being passed to it for improvement.
the median fp on the validation set fp v is zero for all subjects.
the median mutation score on the validation set mv ranges from to on average .
themv of is higher than the one of for subjects with an increase of on average.
1the values ofmv are in underlined bold if in at least one run the improved assertion has false positives even after considering smaller assertions individually and therefore we could not measure its mutation score.
in such cases the value shown is the median of the runs with no false positives in the final assertion.esec fse november virtual event usa valerio terragni gunel jahangirova paolo tonella and mauro pezz 510255010025050010002000inv basedgassertrandom median fn0 !
median fn0 !
inv basedgassertrandom medianmv !
medianmv !
figure fn mutation score improvement comparison wrt the initial left and validation right sets.
.
rq2 comparison with random and invariant based oracle improvement in this research question we compare gassert with two baselines gassert with no guidance by the fitness functions random and the invariant inference of daikon inv based .
we set up the process so that these two baselines are used as part of the same iterative oracle improvement process of gassert described in algorithm .
the only difference among gassert random and inv based is how each of them performs the oracle improvement process line of algorithm .
when running and evaluating random anddaikon we used the same evaluation setup of rq1.
random is a variant of gassert in which there is no evolutionary pressure in the population because any guidance by the fitness functions is disabled.
we obtained random by modifying gassert as follows i we replaced the tournament and best match selection with random selection ii we disabled the merging crossover and mutation based node selector iii we disabled elitism and migration.
random terminates the random evolution of the two populations when either population finds a perfect assertion or the time budget expires.
in the latter case random outputs the best assertion wrt fp among all those generated so far.
although true random search would have been the ideal baseline enumerating and uniformly sampling the search space is infeasible because of the huge size of the search space.
there are .
possible binary trees assertion oracles for each program point catalan number with maximum tree size of .
this is just a lower bound of the search space because for each of these trees we need to consider all possible valid assignments of nodes to variables and functions.
as such we opted for a variant of gassert that uses crossover and mutations operations to explore the search space but without any guidance by the fitness functions.
columns random improved median indicate the quality of the assertions returned by random .
the results show that the improved assertion of gassert dominates the one of random for and subjects considering the initial and validation sets respectively.
in such cases gassert assertions are substantially better than the one of random .
for and of subjects random assertions outperform gassert ones but in this cases the difference is minimal.
for the remaining cases the tools are showing similar results.inv based is an oracle improvement approach that relies on dynamic invariant generation to improve oracle assertions.
we chose daikon v. .
.
to build inv based because is the only publicly available tool that meets our requirements i works with java programs ii generates executable java like assertions iii takes in input a list of observer methods for a fair comparison it should use the same observer methods used by gassert .
daikon does not aim to improve a given assertion nor relies on incorrect executions fn .
however daikon can rely on the test cases that oasis outputs which represent evidence of false positives of .
more specifically the inv based oracle improvement process repeats the following two steps until the time budget expires or it is not able to generate any invariant or oasis does not find any false positives for i execute the current test suite and compute the invariant ii invoke oasis to get the test cases that reveal fps for and add them to the test suite.
column daikon improved median indicate the quality of the assertions returned by daikon .
for ten subjects we did not run inv based because daikon did not generate an initial assertion and thus we compare gassert andinv based with the remaining subjects.
considering the fitness function fp the improved assertion of gassert dominates the one of inv based for and subjects considering the initial and evaluation sets respectively.
in such cases gassert assertions are substantially better than the one of inv based .
for and subjects inv based assertions dominates gassert ones considering the initial and evaluation sets respectively.
for the remaining cases norgassert orinv based assertions dominate each other.
figure plots the median fn left andmv right for each pair of initial and improved assertions wrt gassert random andinvbased .
if a point is on the diagonal it means that the corresponding approach did not improve the false negatives or mutation score wrt the initial assertion.
for the initial sets left plot most of gassert points are under the diagonal which means that gassert produced improved assertion with less fns.
for the validation sets right plot most of gassert points are above the diagonal which means that gassert produced improved assertion with higher mutation score.
the plots also show that in most cases gassert outperforms both random andinv based oracle improvement.evolutionary improvement of assertion oracles esec fse november virtual event usa table evaluation results for rq3 subj.
initial gassert human id fpvmvsize fpvmvsize type fp vmvsize ov.
exc.
gpb se1 m se2 m se3 3m se4 m sa3 5m sa4 m sa3 5m o sa4 m o .
rq3 comparison with human oracle improvement jahangirova et al.
conducted a human study to assess the ability of humans to improve assertion oracles.
they performed this study in two settings i the assertion is improved manually by humans without any tool support m ii the assertion is improved in an iterative setting with the use of oasis m o .
overall they recruited humans to participate in the study.
the subject methods they considered were sa3 and sa4 from the stackar class.
moreover the authors also share the data collected from amazon mechanical turk which consists of manually improved assertions for four simple methods performed by different crowd workers.
as the results are publicly available we compare these assertions with the ones produced by gassert .
we run gassert with the input assertions that were provided to the study participants.
then as in rq1 and rq2 we measure the oracle deficiencies in the initial and gassert improved assertions wrt the validation set .
we then compare these values to the oracle deficiencies in the assertions improved by humans.
column type of table indicates whether this improvement was purely manual m or included oasis m o .
as for four methods from our set the oracle improvement was performed by crowd workers and no action was taken to ensure that they have a proper background or experience for such a task we apply an additional filtering step to the list of assertions for these methods.
we exclude the assertions that do not improve the initial assertion i.e.
they do not have less false positives or a higher mutation score.
column ov.
shows the overall number of assertions available and column exc.
shows the number of assertions that were excluded.
the results show that gassert is always able to improve the initial assertion and achieve a higher mutation score.
moreover the median values across runs for gassert and across the number of human participants for manual improvement are always the same.
column gpb gassert performs better reports the number of manual improvements that achieve a lower mutation score than gassert does of cases .
related work gassert is the first fully automated technique to improve oracle assertions.
the closest related work is on invariant generation oracle quality and oracle improvement.
invariant generation.
dynamic invariant generators produce boolean expressions called program invariants that evaluate totrue for all the executions of an input test suite .gassert improves assertion oracles by reducing their false positives and false negatives and as such can improve the assertions produced by invariant generators which are known to be incomplete and imprecise when used as assertion oracles .
ratcliff et al.
proposed an evolutionary approach for invariant generation that leverages negative counterexamples to rank the invariants.
differently from gassert their approach uses negative counterexamples in a post processing phase and not as a part of the fitness function.
moreover gassert uses oasis to actively generate positive and negative counterexamples.
in addition gassert considers both externally parameters return values and internally observable variables local variables private fields .
oracle quality metrics.
research on measuring oracle quality mostly focuses on assertions in the test cases test oracles .
for instance evosuite and a parameterized test case generator proposed by fraser and zeller select from an initial set of possible assertions those that kill the highest number of mutations.
these studies propose metrics to select test oracles with no guidance on how to improve them.
gassert focuses on assertions in the program and not in the tests evaluates the quality of oracles in terms of both false positives and false negatives and actively improves program oracles by generating new assertions.
oracle improvement.
zhang et al.
s idiscovery approach improves the accuracy and completeness of invariants by iterating a feedback loop between daikon and symbolic execution.
the invariants generated by idiscovery are still limited within the set ofdaikon templates.
therefore they are not as expressive as the ones generated with gassert .oasis relies on humans to improve a given oracle assertion so that it does not suffer from the reported oracle deficiencies.
given oracle deficiencies identified by oasis gassert automates the difficult task of improving assertions with a novel evolutionary algorithm.
conclusion improving assertion oracles is important to increase the faultdetection capabilities of both manually written and automatically generated test cases .
in this paper we presented gassert the first automated approach to improve assertion oracles.
our experiments indicate that gassert improved assertions has zero false positives and the number of false negatives in them is largely reduced with respect to the initial daikon assertions.
the few sample cases with independently obtained human improvements indicate that gassert is competitive with and even sometime better than human improvements.
we plan in the future to increase the expressiveness of gassert assertions by also considering the universal and existential quantifiers.
also we plan to investigate how difficult is for a developer to understand the assertions produced by gassert .