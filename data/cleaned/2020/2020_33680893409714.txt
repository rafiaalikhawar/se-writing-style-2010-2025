thinking aloudabout confusingcode aqualitative investigation ofprogram comprehensionand atoms ofconfusion dangopstein new york university new york usaanne laure fayard new york university new york usa sven apel saarlanduniversity saarlandinformaticscampus germanyjustincappos new york university new york usa abstract atomsof confusion are small patterns of code thathave been empirically validated to be difficult to hand evaluate by programmers.
previous research focused on defining and quantifying this phenomenon butnotonexplainingorcritiquingit.inthiswork we address core omissions to the body of work on atoms of confusion focusingonthe how and why ofprogrammermisunderstanding.
we performed a think aloud study in which we observed programmers bothprofessionalsandstudents astheyhand evaluated confusingcode.weperformedaqualitativeanalysisofthedataand found several surprising results which explain previous results outline avenues offurther research and suggestimprovements of the researchmethodology.
anotableobservationisthatcorrecthand evaluationsdonotimplyunderstanding andincorrectevaluationsnotmisunderstanding.
we believe this and other observations may be used to improve future studies and models of program comprehension.
we argue that thinkingofconfusionasanatomicconstructmayposechallengesto formulating new candidates for atoms of confusion.
ultimately we question whether hand evaluation correctness is itself a sufficient instrument to study program comprehension.
ccs concepts software andits engineering softwareusability .
keywords program understanding think aloud study atoms of confusion acmreference format dan gopstein anne laure fayard sven apel justin cappos.
.
thinkingaloudaboutconfusingcode aqualitativeinvestigationofprogram comprehensionandatomsofconfusion.in proceedingsofthe28thacm jointeuropeansoftwareengineeringconferenceandsymposiumonthefoundationsofsoftwareengineering esec fse november8 13 virtual event usa.
acm new york ny usa 12pages.
.
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse november 8 13 virtual event usa associationfor computing machinery.
acm isbn ... .
introduction previousworkon atomsofconfusion introducedamethodology for discovering measuring and validating programmer misunderstandinginapreciseway.an atomofconfusion isthesmallest snippet of code that will often confuse a programmer as to what thecode s output is.
previous work measuredcorrectness rates of programmershand evaluatingconfusingsnippetsandcompared the rates to those for functionally equivalent code hypothesized to be less confusing.
between the minimality of the code snippet and itscomparisonagainstacontrol theresearchonatomsofconfusion wasdesignedtobebothpreciseandaccurate.gopsteinetal.
applied this protocol in an experiment with participants and analyzedthe results withmodern statisticaltechniques.
the study performed by gopstein et al.
was significant in that it was empirical objective and quantitative.
code was found to be confusingorreadilyunderstandablebasedonexperimentation not theory the observationswere basedon performance not opinion andtheextentofconfusionwasabletobepreciselyquantified.thus theexperimentwasdesignedtomaximizeinternalvalidity .by usingminimalcodesnippets gopsteinetal.couldbesurethatthey wereonlymeasuringprecisecodeconstructs.byusingfunctionally equivalentcodesamplesascontrols theywereabletodemonstrate a direct relationship between the code and programmer confusion.
despite gopstein et al.
s precision and accuracy in design it can only tell us the outcome of programmers performance but not how or why they behaved that way.
how can we know that the causesofconfusionarethoseputforthbytheresearchers?howcan we knowthat misunderstandingsamongst multiple programmers arehomogeneous.howcanweevenknowthathand evaluation captures alltypes ofmisunderstanding?
inshort gopsteinetal.
sstrongfocusoninternalvalidityand objectivistrigordoesnottellthewholestory.westudythesame fundamental code snippets and hand evaluation protocols as gopstein et al.
but augment the setting by having programmers thinkaloudastheyparticipate followedbyasemi structuredinterview and discussion.
this unique perspective on an existing methodologicalframeworkallowsustounderstandandscrutinizeexisting work.ourexperiencewithconductingaqualitativestudyaftera quantitativeexperiment leadsusto believethe originalexperiment could likely have been improved if a lightweight qualitative study had been performed as a pilot during the design of the original quantitative experiment.
esec fse november8 13 virtualevent usa dan gopstein anne laure fayard svenapel justincappos our study offers insights into previous results as well as several surprising observations that contradict previous assumptions including theoriginsofincorrectbeliefsaboutsemanticsdifferacross programmers.
errors evaluating atom containing code are often caused by other unrelatedaspectsofthe code snippet.
correctevaluationofasnippetdoesnotmeanaprogrammer understoodits semantics.
our study reveals newtypes ofpotentialatoms.
insection weoutlinedescriptionsofhowandwhyprogrammersmademistakesoravoided providesinsightintohowtomoreaccuratelyinterprettheresults ofgopsteinetal.aswellasotherhand evaluationprogramcomprehensionexperiments.insection weturnaneyetofutureresearch andpropose potentialimprovements ornewresearchquestions.
a complete replication package for this study is provided at .
the goal of the replicationpackageistofacilitatetheunderstandingofourmethods andobservationsaswellastoencouragingotherstoperformsimilar studiesoftheirown.whileweprovidetheoutcomesofouranalysis we recommend that anyone using thispackagestays opentonew themes that mightemerge.the package contains preparatorymaterial includingallcodesnippetsusedand the scripts enlistedto assignthemto subjects.
interviewinstructions includingapre flightchecklist metaprotocolanduniversalanswerkeyusedtoincreasethereproducibility ofthe semi structuredinterviews.
raw data including anonymized transcripts and scans of the subjects written notesfrom eachinterview.
analysis including the labels assigned to the transcripts during open coding and the codebook usedin that process.
related work atomsofconfusion.
thecoretopicthatinspiredourstudyisthe concept of the atom of confusion a small snippet of code empiricallyvalidatedagainsthumansandproventobemoreconfusing than other functionally equivalent code.
introduced by gopstein et al.
theconceptofatomofconfusionsreliesonthemismatch between how programmers think the c programming language worksversushowthespecificationdefinesit.gopsteinetal.define confusion as when aprogrammer isasked tohand evaluate adeterministicand syntactically semanticallyvalidpieceofcode but reports standard output that is different from what is mandated by thelanguagespecification.gopsteinetal.arguedthatthemostprecise way to measure this phenomenon is with the smallest possible piece of code that can cause misunderstanding in a programmer while a similarly sized functionally equivalent simplified pair versionofthe code isableto be evaluatedwithouterror.
intheoriginalstudyofgopsteinetal.
126codesnippets each averaging source lines of code from pairs representing proposed atomswere tested in a human subjects experiment with 73participants.eachsubjectwasshown84ofthecodesnippetsand askedto recordwhat they thoughtwas the output of eachsnippet program.gopsteinetal.wereabletomeasurethecorrect incorrect response rates for each obfuscated transformed snippet pair andtodetermine which code patterns were truly more confusing than their counterpart.of the proposed atoms met the statistical significance requiredto be consideredaconfirmedatom.
following the original studies the notion of atoms of confusion has been shown to be common in practice and correlated with negativecodequalityindicatorssuchasbugdensityandsecurity vulnerabilities .
the concept has also been investigated with the open source community through opinion surveys and pullrequests .
this line of investigation confirms that atoms of confusion are indeed confusing and prevalent across several dimensions.
however there has yet to be an investigation into the mechanismwithwhichthatmisunderstandingoccurs.ourresearch setsoutto explainthe phenomenaobservedinprevious studies.
in an effort to expand the concept of atoms of confusion beyond justtheclanguage castoradaptedittotheswiftprogramminglanguage .
castor used new methods of finding confusing patterns such as measuring the infrequency of occurrence in large code basesandexpertopinion.weproposethatobservingprogrammers ina think aloud study isan acutelyeffective means of identifying specific sourcesofmisunderstandings.
qualitativeresearchinsoftwareengineering.
withgoalsofunderstanding how confusion arises in programmers and improving methodologies for future research we chose aqualitative method to explain previous results and explore potential new research designs.despitethepositivesofgroundedtheory wedecideditwas notagoodfitforourstudy aswewerealreadyfamiliarwithpreexistingliteratureinthefield andthesemi structurednatureofour inquirywasslightlytoorigidtofullybenefitfromgroundedtheory.still wetookmanylessonsbothfromprimarysourcesofthe technique aswellasdescriptionsdesignedspecificallyforthe software engineering field .
we used techniques recommended fromthesetexts suchascontinuousdataanalysis open coding and memoing.perhaps thebest high level descriptionofour style of study is described by creswell as explanatory sequential mixed methods wherearesearchertakesanexistingquantitativestudy analyzes the results and then builds on the results to explain them inmore detailwithqualitative research .
we modeled our research onqualitative studies in the software engineeringfield combiningelementsasnecessarytofitourneeds.
r hmetal.usedahybriddesignconsistingequallyofobservations and interviews with the observation mainly targeting what developersdoandtheinterviewmainlytargetingthemotivationbehind developer sactions .thisblendoftechniqueswasanatural fitforus aswecouldreanalyzeexistingobjectivedata andthen explain them based on the subjects subjective reports.
for the observation component we chose a think aloud protocol due to its abilitytoprovideinsightsintoactivebehaviorsastheyarebeing performed .thismethodiswellsuitedtoanalyzingprogram comprehensiontasks .however publicperformanceandan artificial code reading environment have been linked to adverse affectsoncognitiveload whichmayaffectourresultsthough not invalidatethemaltogether.
oneofthemostpopularmethodsofanalyzingqualitativedata is first using open coding to develop descriptive labels for data then using a hierarchical coding scheme to develop categories from these codes .
this general technique has been used 606thinking aloudabout confusing code esec fse november8 13 virtualevent usa successfully many times in empirical software engineering and more specifically forstudyingprogram comprehension.
seaman givesathoroughoverviewofmanyofthesemethods .inparticular yamashitaandmoonenusedinterviewstodevelopataxonomy ofdifficulties duringcodemaintenance .wehaveemployeda similar technique to develop our understanding of the ways programmers misinterpretatoms.
methods weusedaqualitativeapproachtohelpexplaintheresultsofgopstein et al.
towards that goal we borrow many elements of experimentaldesignfromtheirwork butaugmentthemtofacilitatea deeper more flexibleinterpretation.
.
sourcecodeselection gopstein et al.
s code snippets were divided by two dimensions whetherthesnippetcontaineda potential atomofconfusionor not and which type of atom it contained or not.
after their experiments theydividedtheatomsintothecategoriesofbeingvalidated as confusing or not.
they tested code snippets in total.
for our work were too many to test given the enormous effort involved in a think aloud study.
instead we selected representative examples from the original set.
we made sure in our corpus to includeoneofeachtypeofatom severalsampleswithoutatoms andcompleteobfuscated transformedpairsofeachoftheproposed atomsthat failedto meetstatisticalsignificance.
we wanted to investigate snippets that had shown confusing properties in previous experiments as well as snippets that had been hypothesized to be confusing but did not empirically demonstrateconfusingpropertiesintheoriginalstudy.thismeantthat in addition toverifiedatomsof confusion wewantedtostudy hypothesizedatomsofconfusionthathadpreviouslyfailedtomeet statisticalsignificance.additionally wewantedtoobservesubjects hand evaluating non confusing snippets as a baseline for comprehensionofsimpleprograms.sincemanysnippetswithatoms removedaresimilartoeachother beingsmallandcontainingalimited set of language constructs we did not make an effort to study eachatomsnippet s directtransformation.forsnippetsthatwere hypothesized butnotconfirmedasconfusing however wedidtest directtransformations sinceanoverlyconfusingtransformation has the power to confuse a subject and serve as a defective control.
consequently eachsubjectwasshown 5confirmedconfusing snippets c 1confirmednot confusingatomtransformation nc 1hypothesizedbut not validatedconfusing snippet hc 1transformation ofthe same hcsnippet hnc snippets were assigned to specific participants in using these constraints but otherwise distributed randomly by a script.
the script that we used to determine snippet selection is included in our replication package.
.
data acquisition the principle mechanism of our study is a think aloud protocol with a combined semi structured interview and discussion.
we showed each subject small code snippets of various degrees of confusingnessfrompriorexperiments.foreachcodesnippet weaskedthesubjectstohand evaluatethecodeandreportthestandard output results of the printfstatement .
we then asked the subjects to notate their confidence about their answer on a scale from unsure to positive .
we also requested from each subject whileevaluatingeachprogrampleasespeakaloudyour reasoning thoughts andactions .thestudyleaderremainedinthe room with the subject and audio recorded the entirety of the study.
aftereachindividualevaluation thestudyleaderfirstaskedsubjectswhytheychosethelevelconfidencetheyselected andthen proceededtoaskclarifyingquestionsaboutanyambiguouscomments made by the subject.
the study leader used a meta protocol toguidetheirinteractions.themeta protocolrecommendedspecific situations to look for questions to ask in these scenarios and canned answers for common questions.
at this point the study leader attempted not to provide any information to the subject.
afterall8codesnippetswerefinishedbeingevaluated thesubjects were given a questionnaire that asked about subject demographics previousexperience programminglanguagepreference and perceivedproficiency amongother things.
afterthesubjectcompleted the questionnaire the study leader stepped the subject back througheachofthecompletedcodesnippets thistimeaskingmore probing questions designed to start a back and forth dialog.
at thispoint discussionswerecollaborativeanditerative perhapsthe studyleaderwouldaskaclarifyingquestiontowardsthesubject orthesubjectwouldask foranexplanation fromthestudyleader andthediscussionwouldproceedfromtheretoidentifytheroot causesandprocessesthatledtouncertaintyormisunderstanding.
any error in evaluation or understanding that the study leader identifiedwasdissectedbothbythestudyleaderandthesubject until the subject had a complete understanding of the mistake they hadmade andtheyhadcommunicatedtheirunderstandingoftheir originalthoughtprocessandtheir misconception.
.
subjects weselectedsubjectstorepresentprogrammersalongabroadrange of experience recruited from three general groups.
ultimately we interviewed students professional c application developers and professional authors of a popular c library.
all subjects identified as male though this was not an intentional aspect of the study design.a listofour subjectscan be foundintable .
allstudentsubjectswererecruitedfromthecomputerscience masters program of nyu.
all other subjects were recruited from asinglelargenorthamericanwebtechnologycompany.unsurprisingly thereisamuchstrongerpreferenceforc amongthe subjects who work professionally with the language.
professionals also tend to be older have more experience and have higher self perceivedproficiencywithprogramming.
.
analysis theanalysisbeganastheinterviewsthemselves asthestudyleader keptcontinuousnoteswhileeachsubjectspoke.aftereachinterview the study leader would go back to summarize and reframe each set of observations.
this included writing memos on developing patterns and theories as evidence for them grew.
all the while thesememoscontinuedtobecomparedandjuxtaposedagainstthe newer data that continuedbe collected.
607esec fse november8 13 virtualevent usa dan gopstein anne laure fayard svenapel justincappos table programmers recruitedto participate inthestudy subj.
group age preferred c c years language proficiency progr.
student c python student go student c student js kotlin student python c user c c user c c user c c user c c librarian c c librarian c c librarian c c librarian js c c librarian c subsequently subjects handwritten notes were digitally copied and saved for analysis.
we generated transcripts from the audio recordingsoftheinterviews.wereadthesetranscriptions alongsidethesubjects writtennotes usingopencodingtolabelpatterns thatappearedinsubjectresponses.opencoding asdescribedby corbin and strauss is breaking data apart and delineating conceptstostandforblocksofrawdata.atthesametime oneis qualifyingthoseconceptsintermsoftheirpropertiesanddimensions .
this involves identifying interesting repeated surprising facets of a text and marking them for later analysis.
from these codes we formed higher level groupings of similar concepts.
from these patternswereinducedthatformthebasisofourobservations hypotheses andsuggestionsthat followinthis paper.
theanalysiswasperformedinseveralbatches intertwinedwith data collection as new subjects were recruited and interviewed.
as one of the goals of this study was to explain gopstein et al s results we began by recruiting interviewing and analyzing student subjects to obtain a sample similar and comparable to the original sample.weusedathree foldanalysisstrategythatallowedusto remainsensitivetoinsightsthatemergedfromdata whilefocusingonthequestionsthatemergedfromgopsteinetal soriginal study.
once the first set of interviews was completed the study leader read the transcripts to define emerging recurring themes across subjects.
after discussing with the other authors this first list of common patterns the study leader read the interviews a second time to inductively generate codes through open coding of ourdata.wheneveranewcodewasdeveloped itwasaddedtoa runningcodebook whichlistseverytypeofcodeused alongwitha brief description of when it is applicable.
the full codebook as well as each code s application is included in our replication package online.
since codes were generated dynamically during open coding the coding process was performed iteratively.
any codes that were generatedafterthecodingofatranscriptwerethenretroactively applied to all transcripts that were previously coded without it.
this process was done in two phases.
whenever the last subject ofagroupwascoded alltheprevioustranscriptsfromthatsame groupwouldbere evaluatedtoaddthenewly createdcodes.for years programming345678correct answers1157 subject groups student c app.
dev.
c librarianfigure1 subjects performancerelativetoc c experience example whenthelaststudenttranscriptwascoded allprevious students transcriptswerere analyzedtoseewhetherthenewcodes wereapplicable.finally whenall14transcriptsacrossallsubject groups student c application developer c librarian were analyzed they were all read and recoded once more this time with the complete setofcodes.
we then engaged in a third phase of analysis in which the study leader compared and contrasted across codes and collapsed and combinedthemintohigher levelcategories.thestudyleaderhad regular meetings with the other authors to discuss and agree on thedefinitionofthesehigh orderconcepts.intherestofthispaper these concepts are presented with specific quotes and interactions.
.
descriptivestatistics whilenotthefocusofthiswork weprovideaquantitativeoverview of the collected data because it gives important context for what follows.
in total there were 8h18m of recorded audio consisting of about spoken words broken into roughly blocks of speech by either the subjects or the study leader.
there were types of labels applied to phrases from the interviews.
themostcommonthemesinthetextwere unsure correctsemantics simple .
examples of less frequently occurring labels are maintainability previously used and unfamiliar syntax .
therewere17codesnippetsevaluatedincorrectly.14errorswere committed by4 students 2by asinglec application developer and1byac librarian indicatingthatthestudentsmademore errorsthanprofessionals butthedifferenttypesofprofessionals werenotwelldistinguished.afullaccountingoferrors per subject is depicted in fig.
.
the types of snippets that generated errors largelyfollowedwhatwaspreviouslyreportedbygopsteinetal.
albeit with less fidelity.
there were no transformed non atom snippets that were evaluated incorrectly with all errors coming from snippetsthat were designedas obfuscated.
mechanisms ofmisunderstanding in this section we analyze and discuss our observations pertaining tothecausesofprogrammermisunderstandingswhileevaluating atomsofconfusion.weexplorehigh levelpatternsinducedfrom individualexamples discussedwithour subjects specifically 608thinking aloudabout confusing code esec fse november8 13 virtualevent usa a taxonomy ofdifferenttypes oferrors causes oferrorsbeyondatomofconfusions cases when subjects evaluated code correctly despite being mistakenaboutsemantics thediscussionsintroduceageneralizedpatterninferredfrom the data and also give specific examples in the form of quotes taken from the subjects.
whenever quotes are given they reference the subject and the associate code snippet in the form of .forexample ifsubject1234weredescribing snippet56 we wouldwrite quote aboutcode .
.
taxonomy ofconfusion gopstein et al.
were careful to delineate types of confusing code that were and were not relevant to their investigation.
specifically they excluded code that contained non determinism non standard features high computational load or reliance on a complex api.
the rationale was that they were interested in studying situations in which a programmer would make an error based only on a flawed understanding of a language s semantics.
to test this reasoning we categorized every incorrect hand evaluation and attributed a primary and sometimes secondary high level cause.
these causes naturally fell into four general groups of errors unfamiliarity misunderstanding languagetransfer andattention.the first three would likely be considered in scope for gopstein et al.
while attention related errors would likely fall into the category of excluded types of confusion.
table 2lists each incorrectly evaluated snippet alongwith which high level categoryof erroritwas assignedto.next we describe the categoriesindetail.
unfamiliarity.
the subject appears to have never encountered this phenomenon before or at least does not recognize it in its current form.considerthe following example int v1 i assume the int is going to be thirteen because it doesn t have to representthat zeroinmemory inthiscase thesubjectwasnotawarethataleadingzeromeans the literal represents an octal value and is stored with a value equivalent to the decimal number in this case.
there is no evidence that the subject had ever seen this notation before and wasthenleftinferringthesemanticsofthisnotationbasedonlyon hisownreasoning.originally thesubjectconsideredthataleading zeromightcauseanerror butultimatelyhesuggestedthatignoring the leading zero might make sense for purposes of being able to parse fixed widthintegersfrom data files.
allthesebehaviors are characteristic ofunfamiliarity noevidenceofprevious associationofthe construct often questioning the code svalidity using logic to constructpotentialsemantics misunderstanding.
thesubjectisawareoftheconstruct butuknowlinglyattributes incorrectsemantics to it as inthis example if v1 v2 ... this is pre incrementand uh what iremember from whati studiedisthat you know before the statement is executed this willbe incremented in this example the subject recognized the pre increment operator and noted that the underlying variable would be incremented.
the subject believed thatfirst incrementationwould happen andthen the logical expression would be evaluated.
actually it works the otherway thedisjunctionoperator mustfirstevaluateitsleft operand and only if that is true it will evaluate the right operand incrementingitsvariable svalue.underthesubject sconception v2wouldalwaysbe incremented whichisnot accurate.
unlikeunfamiliarity when asubjectmisunderstands they have seen the constructbefore they purport to have an understanding of it theirunderstanding issomehowflawed language transfer.
the subject has seen similar code before but onlyinanotherprogramminglanguage.fromtheotherlanguage they guess what the semantics mightbe inc int v1 we have like different number base but forint.iknowpythonhassomethinglike it butinc i mnotsure.
inpython the 0infront means nothing.
in this example the subject recognized the form of the octal literal however hewasunsurewhetherornotitappliestoc.hedescribed howsimilarcodeworksinpython andthenultimatelydecidedthe 0waslikelytobeignoredsincethatiswhathebelievedhappens in python.
n.b.
in python 013is interpreted a decimal in python3 013isaparse error .
languagetransfer iseasily identifiedwhen the subject mentionstheirunderstandingisderivedfromtheirknowledge ofanotherprogramming language attention.
the subject verbalizes correct semantics but appears to forget orignore an importantpieceof the computation printf d dn v1 v2 v2 is going to equal and v1 is going to equal after that expression.
and so it s going to print outone two in this example the subject accurately described the state of the variables v1is and v2is but then immediately went on to say thatthevariableswereprintedwiththeirvaluesreversed.there was no explanation for this what so ever and the attribution of attention is somewhat of a guess on the behalf of the study leader.
a misunderstandingisconsideredan attention problem when thesubjectappearstounderstandthesemanticsoftheinvolvedconstructs there isnootherobvious cause of the problem 609esec fse november8 13 virtualevent usa dan gopstein anne laure fayard svenapel justincappos table incorrectly evaluatedsnippets.including error description categorization and unexpectedadditionalatomsthat also appear subject snippet atom mistake category otheratoms pointer arithmetic array as headerpointer pointervs.value unfamiliarity unfamiliarity pre increment failed to incrementvariable misunderstanding attention operator precedence booleanvalue ofinteger languagetransfer implicit predicate literal encoding leadingzerois ignored unfamiliarity logicascontrol xoperates beforestatement misunderstanding pre increment preprocessor instmt ifdetermines macrodefinition unfamiliarity comma operator mistook for comma operator attention unfamiliarity assignment asvalue literal encoding leadingzerois ignored languagetransfer logicascontrol forgot short circuit thoughtit didn t apply attention misunderstanding operator precedence booleanvalue ofinteger unfamiliarity implicit predicate preprocessor instmt if selectspreprocessor unfamiliarity omittedcurly brace booleanvalue ofinteger unfamiliarity implicit predicate macroprecedence pre evaluated macrocontents unfamiliarity repurposedvariable booleanvalue ofvariable not integer unfamiliarity implicit predicate comma operator switched argument order attention logicascontrol falseoperandcausesshort circuit misunderstanding type conversion float to integer is arounding conversion misunderstanding summary.
wehavedefinedfourcategoriesoferrorthatdescribe themistakesthatwesawinourstudy.wedonotexpecttheyare exhaustive of all comprehension errors.
however they capture the essenceofthe issuesthat we happenedto witness.
.
unexpectedcause oferror theverypremiseofearlierworkonatomsofconfusionworkrelied ontheimplicitassumptionthatdifferentprogrammersmisinterpret variousexamplesofconfusingcodeinthesame predictableway.
for example an atom of confusion might be called operator precedence and any time a subject makes an error evaluating this piece ofcode thespecificcauseofconfusionisassumedtobedirectlydue to misinterpreting precedence of the infix operators in the snippet.
despitethetightcontrolsimplementedbygopsteinetal.
therewas nowaytovalidatethatassumption.inourwork weseeevidence bothinfavorandagainstthisassumption.oneexamplethatshows an incorrectlyattributedsourceof confusionhappens witha code snippetofthe operatorprecedence atommentionedpreviously int v1 if v1 else v1 printf d n v1 the part that was assumed to be confusing was the precedence of the logical operators in expression .
two both students ofour14subjectsincorrectlyevaluatedthelogicalexpression above however the root cause of both errors were unrelated to operatorprecedence.subject3316said youcannotevaluatetwo totrue implying hedid notknow thatnon zerovalues are evaluated as truthy by a logical operator in c. subject s confusionwentslightlydeeper sowillthevariablewillbeaffected by this or it will just completely skip this implying that hebelievedalllogicalconditionsmustreferenceavariable.while this code snippet was obviously confusing to these two subjects it happened not to be the reason that was identified by previous research.
to determine which of the errors made inour study were due to the reasons assumed and which were due to unrelated misunderstanding weanalyzedeachincorrectlyevaluatedsnippetand attributed a simplified cause as to why each subject erred while hand evaluating asnippetintable .
ofthe17incorrectlyevaluatedsnippets 10appearedtobecaused solely by the stated atom of confusion as described in gopstein et al.
in cases the cause of the confusion was either partially or solely due to some other factor potentially another atom or atomcandidate.subject4304 serrorinsnippet61appearedtobe caused only by a lapse of attention and is likely not caused by anyatomofconfusionatall.severaloftheinteractionsobserved duringtheincorrectevaluationofothersnippetsprovidedevidence formultiplenewtypesofatomsnotpreviouslyidentified.thisis discussedinmore detailinsection .
potentialnew atoms .
summary.
despite causing confusion atoms of confusion do not necessarilycauseconfusionforthereasonimpliedbytheatom s title.
this maybe dueto insufficient minimality and perhaps the snippetscould be written more carefullyto avoid this pitfall.
.
correct forwrongreasons there is a subtle problem with only collecting the output of the subject shand evaluation.itisonlypossibletomeasurewhetheror nottheirevaluationresultedinthecorrectoutput notwhetherthey evaluatedthe code followingthecorrect semantics.inthiswork weobservedseveralscenariosinwhichsubjectsreportedcorrect output but did so in a circuitous way.
in table we collected every example of a construct that was evaluated correctly but for the wrong reasons.
the table lists which piece of code was evaluated with wrong semantics what the supposed or explicit misunderstandingwas andwhether or not thesubject proceeded to ultimately evaluate the restof the snippetcorrectly.
610thinking aloudabout confusing code esec fse november8 13 virtualevent usa in our example on operator precedence there were no wrong answers that exhibited the expected misunderstanding of precedence rules.
this could be because precedence rules for logical operators are not confusing.
however there is also another explanation provided by our investigation.
several subjects did express a lack of understanding of operatorprecedence however due to the orderingoftheexpressionsinvolved theywouldaccidentallycorrectly evaluate the snippet anyway.
take for example subject who explained if i recall correctly the operator precedence is such that andandorarethesame.idon tbelieveeitheroneofthemtakes precedenceoverthe other andso it sjust left toright .
thisunderstandingofthelanguagesemanticsisgenerallyincorrect however the specific example enabled the subject to still evaluate the example correctly.
had the snippet prompt instead asked thesubjecttoevaluate itislikelythathewouldhave evaluated it incorrectly assuming the parenthesization would be instead of the actual parenthesization .
unlike a simple error that leads to an incorrect output a correct response that arose from an incorrect evaluation often necessitates multiple misunderstandings one to initially generate an incorrect response and another to steer the evaluation back to being correct.
for example in snippet subject did not understand the parsing rules of the statement int v2 v1 ?
however since he believed that was only valid to be used inside a predicateclause forexample thefirstoperandoftheconditional operator the two misunderstandings canceled out and left the subjectevaluatingthe code correctly.
summary.
the implication for these types of errors on previous work is significant.
misunderstandings like these may not result inanincorrectresponseinacorrect incorrectoutputexperiment like the one of gopstein et al.. so if an experiment intends to be measuringmisunderstanding itmaywellbeunderestimatingthe amount.
implicationsand perspectives during the course of this study it became clear that many assumptionsthatweretakenforgrantedinpreviousworkmaynotalways hold true.
in this section we discuss potential new areas to investigateorimprovementsonolddesignsfornewstudiesgoingforward.
we address four specific facets of the previous work from a new perspective newcandidates for atomsdiscoveredthroughobservation limitationsofthe modelofatomsofconfusion potentialpitfallsinhand evaluation experiments the role ofqualitative methodsinquantitative work .
potential newatoms gopsteinetal.proposed19candidatecodepatterns aspotentially confusingrelativetofunctionallyequivalentcode.ofthese 4failed to meetstatisticalsignificance patternswere validatedas atoms ofconfusion.despitethisexistingcorpusofknownconfusingcode patterns it is likely that there still exist more minimal patterns of code that are confusing to programmers.
we list here several constructsthatappeartobeconfusingbasedonourobservations they mayprove to be atomsofconfusionuponfurther validation.uninitializedvariable.
severaloftheprogramsincludedinourstudy declarevariablesanddonotinitializethemimmediately onlyassigning values to them through the course of the program.
each of these variables being local in scope begin life with an indeterminate value and only have a known value once it has been assigned.
in each snippet the value of every variable is assigned beforeitisread.therefore nocodehasunspecifiedorundefined behavior.
however there were dozens of mentions of this concern from subjects the others are actually in an indeterminate state at themomentbecausewehavenoguaranteeoflikeinjavathey dbe zero initialized but this is c you go to hell and you die .
inmostcases subjectsunderstoodthattherewasnounspecified behavior but that it was still bad practice the intention is to to not have the the like declared declaration of an int that s not defined because it s just a uh it s a vector for bugs .
we noticed however several misconceptions around the semantics of uninitialized values that either caused mistakes or likely would have in a different context.
for example subject incorrectly evaluated snippet in part due to this misunderstanding.
herecalledhisunderstanding frommyexperiences thedefault value will be either minus one or to the smallest number from the system and then proceeded to use these values in the snippet.othersubjectsstillmanagedtonavigatethecodecorrectly despite equally unfounded beliefs it depends on the flavor of c thatyou reactuallyworkingin.um actuallyidon tknowforeven today i m not sure if like the default initialization... i think that since c they made sure that these are default initialized so they dbe zero.but that snot guaranteedinthe early versions of c .in thiscase c 11doesnotallowforautomatically initializedintegersinanon static non globalcontext andthat has been the caseinthe standard at least since ansic .
given these misunderstandings it is likely that code containing uninitializedvariablesisconfusingtoprogrammers.theoriginal workonatomsofconfusionspecificallyavoidstestingcodewith unspecified undefined behavior however making the testing of thispotentialatomalittlechallenging.oneinterestingfactthatcan be tested is that integers in a static or global context are and have been since the ansi standard initialized to .
so one potential snippetofatomcode could be atom candidate uninitialized value int x int main printf d x obfuscatedint x int main printf d x simplified inthisexample thestandard specifiesthat xisinitializedto 0and therefore output is however several of our subjects would likely believe the behaviorisunspecifiedorundefined.
modulo operator.
in snippet an example of the implicit predicate atom the modulooperator writtenas and often verbally abbreviated mod wasusedasagenericnon logicalexpressioninthe condition of an ifstatement like if .
while the name and conceptofthemodulooperatorwasalwaysknownbyoursubjects theprecisesemanticsandevaluationwereoftenquestioned.one 611esec fse november8 13 virtualevent usa dan gopstein anne laure fayard svenapel justincappos table every evaluationthat was correct butfor thewrong reasons subj.
snippet construct misconception ultimately truthiness of knew10 3was non zero butdidnotknowits value correct precedenceof and havethe same precedence correct precedenceof alloperators getevaluated from leftto right incorrect incrementation andshort circuiting a both operands getevaluated b incorrect of v1 v2 precedenceof v2 v1 ?
doubleequal tocan onlybethereforthe condition check correct expressionvalue of v2 just like return like nothing.
so onlythe remainingvalue is 2 incorrect subject inparticular knewverywellwhattheoperatorwasata high level but struggled to actually calculate its value.
i mean it s like obviously it s modulo operator so it s like kind of close to the remainder... subject elaborates more but then pauses for seconds trying to calculate the value of the operation oh okay.
actually now that i think about it.
i don t really care what the value is i guess cause it s like it s just a conditional so it s like youcanconvertittoboolean.um sointhiscase uh itdoesnot evenly divide into three is not evenly divided into .
uh so there is a remainder and of non zero value.
so it s true .
after being prompted by the study leader the subject explained that despite knowing the high level description of the modulo operator hestruggledactuallycalculatingitsresult.thestudyleaderpushed himtotrytocalculatethevalueagain towhichthesubjectresorted tocountingonhisfingers andstillfeelingveryunsureofhisresult one two three.one two three four five six seven eight nine .
so that would be... oh interesting.
actually.
not sure what though soit sstartingat.wouldthatbeoneorzero?imeanit s itcan tbe zerobecauseit sdoesn tevenlydivide .despiteevaluating every snippet correctly had the study leader asked subject to evaluate 3andreportitsvalue hewouldnothavebeenable to doso.
evenbeyondthecomputationalabilityrequiredofthemodulo operator severalsubjectsalsoagreedthesemanticsoftheoperatorwasunknowntothemwhentheoperandswerenon positive.
it s themod operator.could have gotteninteresting ifthere were negativeor eventsthatihad tothinkaboutit...likespecificallya negative divisor would like i d never think about that case... and i guess they design it so that like if you flip the sign at both of them itshoulddothesamethingithinkwasthere uh idon tremember.
there sacouple oflogical waysto giventhesecomments itislikelythatthemodulooperatoris itselfconfusing.boththeexamplegiven forcomputationalreasons but also usages with other operands.
below are examples of the modulo operator being used with operands of various signs which maybe confusing as well.
atom candidates modulo operator case expression value twopositiveoperands negativeleft operand negativerightoperand twonegativeoperands zeroleft operand zerorightoperand undefinedoctalnotation two reasons .
snippet105 testswhether programmersunderstandhow toprint an octalliteralinteger asadecimal value.the relevantcode is int v1 printf d n v1 thereweretwoincorrectevaluationsofthissnippet bothbystudents.
one of the subjects was not at all familiar with the leading zerosyntaxandassumeditwouldbeignored umthere sa leadingzerothere.soiassumetheintisgoingtobe13 um because itdoesn thavetorepresentthatzeroinmemory.
.the othersubject knewthatsomelanguagesrepresented octals inthis waywhile othersdidn t andmade the guess that c didnot.
afterwards the study leader told that the leading zero did meanoctal andaskedthe subject toproceedfrom that point with the new knowledge.
from there the subject was still unable to get thecorrectresult it sabase8.andithinkperthismeansthatthe outputfor the be adigit soit s1plus8.
it s .
.
betweenthesetwosubjects wecanseethattherearetwodifferenttypesofmisunderstandings oneregardingthemeaningof the leading zero notation and the other about how to translate betweenoctal and decimal numbers.
perhapsthis indicatesthat there may be room to reduce the complexityof the code snippet further byfactoringitintotwoseperatemore minimal atomcandidates instead.
atom candidates octalnotationand conversion atom candidate code value leading zeronotation printf o decimal to octalconversion printf o stringaspointer.
inc astringisrepresentedasapointertoaseries ofsequentialcharactersinmemory wherethelastcharacterisindicated by a null byte.
this is why strings are declared as char or pointertoacharacter .itwouldappear though thatthespecialized nickname string or something about its conventional representation may obscure its underlying structure to some programmers.
snippet was designed to test whether programmers understood thattheargumentstothearray subscriptoperator squarebrackets canbeswappedwithoutaffectingtheprogrambehavior.one of our subjects nearly evaluated the snippet incorrectly not due to misunderstanding the subscript operator but instead because he didnotrealizestringswerejustpointers ihaveseenitonsome 612thinking aloudabout confusing code esec fse november8 13 virtualevent usa of the class material once where you know that was you know professor was just going through it and he said that this or that wouldn tmatter.andi ididtryitwithan intbecauseijustwanted to check to be sure it did work but you know i kind of initialized anarraybeforeandthenitrieditlikethiswiththeindexandthe youknow basepointer butihaven tdonethatwithstrings...but thisisnotabasepointer butidounderstandit sastringandi m reallyshakywhenitcomestostringsinc .itmightbe valuabletomeasuretheconfusingnessofthepointerrepresentation of strings independently to learn how well subjects understand them atom candidate string as pointer void main char x abc char y x printf c x obfuscatedvoid main char x a b c char y x printf c x simplified logical operator outside of condition.
theimplicit predicate atom impliesaperceivedconnectionbetweenconditionalstatementsand logical operators.
the atom shows that it is more confusing to use anifstatement for example without an equality operator than with one.
conversely if programmers have learned a conventional association between conditions and logical operators perhaps the presenceoflogicaloperatorsinabsenceofan ifstatementor while loopisitself confusing.
snippet designed to test the conditional operator atom also caused perceived ambiguity over the precedence of its operators in thisstatement int v2 v1 ?
subject4281 unsureof whethertoparsetheconditionalexpressionas v1 ?
or v1 ?
madeastatementtothiseffect adoubleequalto can only be there for the condition and used this reasoning to help infer rules about operator precedence.
despite helpinghimcorrectlyevaluatesnippet49 thisunderstandingofthe usageofthe operatorisincorrect.actually theequalityoperator is used in an expression like any other and can be used in any context that can receive an int specifically or .to subject however the logical operator is inseparable from its conditional context and would not have a value if it were it cannot be there for any other reason but for a condition... nothing comes out of this .
it would appear that the conventional relationship between conditional statements and logicaloperands is so pervasive thatsome programmershaveinducedthatitisbyspecification.perhapsnever havingseenalogicaloperatoroutsideofaselectorloopingstatement the programmer believes that itisnot allowedto happen.
atom candidate logical operatoroutsideofcondition void main int x printf d x obfuscatedvoid main int x if x printf d x simplified5.
challenges ofthemodel gopsteinetal.introducedthenotionofatomsofconfusionasaway tosimplifytheprocessofprogramcomprehensiontoapointwhere it can be precisely and reliably measured.
the primary mechanism forgainingthatprecisionwastheminimalityandatomicityofcode snippets.
part of what our study is demonstrating is that talking about code and human comprehension in such dichotomous terms isnotthemostaccuratemodel.wehaveseenseveralexamplesthat undermined theconcept of homogeneity ofconfusion minimality of confusion and evaluation as a precise proxy for comprehension.
homogeneousmisunderstanding.
thewaygopsteinetal.presented their15examplesofconfusingcodepatternsimpliedthatmisunderstandingwas a trait inherent to the code itself independent of thesubjectsonwhichtheywerevalidated.whatwehaveseenin our study is that there is considerable variance across our subjects typesofmisunderstandingsduringevaluation evenforthesame code snippet.
sometimes this is affected by obvious factors such asexperience butsometimesitissubtlefactorssuchaspersonal experience with a given construct or even the specific mnemonics aprogrammerhasusedtomemorizeaparticularquirkofthelanguage.regardless themoreevidencewesee thelesslikelyitseems thatanyparticularcodesnippetislikelytobeuniversallyconfusing orsimpleacrossallprogrammers.infact itisunclearwhetheror notspecificconstructscanbeselectedtobeconfusingforevena specific demographic as each programmer is an individual with theirownmastery andmisconceptions unique to themselves.
one example is various programmers misunderstandings of the boolean value of integers when evaluated in a logical operation.
in c valuesaregenerallyconsidered falsy iftheyevaluateto 0and truthy otherwise.
for example logical conjunction is specified to behave as follows the operator shall yield 1if both of its operandscompare unequalto otherwise it yields .the result hastype int .however weobservedseveraldifferentbeliefs regarding the boolean valueof integers.
considerthesethree differentexamples of incorrectsemantics the only valid integersinalogical contextare 1and0 you cannot evaluate two to true but you usually can evaluate zero and one... to other boolean types integersare not valid inalogical context at all it sconfusingbecausezeroandone...what?whatdoes what s zero and one what does?
how would i... i don t knowwhat itmeans.
allintegersare true because they exist i mean we re using zero here for the if and zero is an integer.
so it it is true.
i mean zero does exist.
given that there is such a diverse set of misunderstandings around asingleconstruct itmaynotbeappropriatetoclaimthatthereisa singlesourceofconfusionthat causes allof them.
mutually exclusive atoms of confusion minimality and atomicity.
partofgopsteinetal.
srestrictionto minimal codesnippetsmeant thatnoexampleofanatomofconfusioncouldcontainanyother confusing code beyondwhat was being tested.unfortunately this necessarily precludes the possibility that two potential atoms of confusionmightsharecommonconceptualground.oneexample concerns expressions with side effects.
several responses in our 613esec fse november8 13 virtualevent usa dan gopstein anne laure fayard svenapel justincappos studyhaveindicatedthatcodethatmutatesstateaspartofalarger expressionisinherentlyconfusing.examplesofthistypeofconfusingcodecanbequiteminimal suchas a b ora b assuming b produces side effects .
the first example has been shown to be confusing as a post increment atom while thesecond has not.
evidence from our study and other studies however suggests that thelatterisagoodcandidatetobeanatom.if however sideeffects are shown to be confusing and become a new atom in their own right this makes existing atoms such as a b logic as control flow ora b c commaoperator non minimal sincethey mustcontainthe side effectingexpression atom.giventheconfusing natureofshort circuiting though the logicascontrolflow atom islikelytobesignificantlymoreconfusingthantheside effecting expressionitwouldcontain.toputitdifferently a b isconfusing it cannot have any part of it removed while retaining its levelofconfusion anditcannotbewrittenwithoutaside effecting expression.
if side effecting expressions are ever validated as an atomofconfusion thiswouldsuddenlycause a b tonolonger beminimal andthereforenotviableasanatomicunitofconfusion.
thiscontradictionmightforceadifficultchoicebetweenseveral valid atoms.alternatively itmaypointto aconceptual shortcominginthedefinitionofatomsofconfusion.perhapsthenotionof atomicityislimited theideathatthereisacertainthresholdlevelof confusionbelowwhichcertaincodeissimpleandabovewhichitis confusing.if instead weacceptthatallcodeexistsonaspectrumof understandability and some code is easier to understand and some harder there cannolongerbea conceptofaminimallyconfusing pieceof code because allbut thesmallestexpressionscanalways bemadesmallerattheexpenseofsomeconfusingness.conversely this lets us talk about several related cooperatively non atomic pieces of code that have varying levels of confusingness despite all sharingrelated constructs.for example a b a b andb .
itislikely that eachisconfusing but to differing degrees.
evaluationvs.comprehension.
perhapsthecoreassumptionofresearchonatomsofconfusionistheuseofthecorrectnessofsource code evaluation as a proxy for program comprehension.
in any specificcontext thiscorrespondencemayremainvalid however evidence from our study indicates that individual understanding is notmonotonic.section .
correctforwrongreason demonstrates thataprogrammerwhocanevaluateasmallsnippetofcodemay be able to understand the same code in another context.
even in circumstanceswheresubjectscorrectlyevaluatedasnippet occasionallycertainassumptionstheymadepossiblywouldnothave beenmadeinthecontextofalargerprogram orwouldnothave leadthemto acorrectanswer inthat case.consequently the relationship between evaluation results and claims of comprehension maynotalwaysbetrueforthetypesofcodeshowninthesestudies let alone generalize to more typical code seen in larger code bases.
.
threatsto validityin previousstudies outsideofconfusingprogrammingconstructs thathavepotential tobeatomsthemselves wediscoveredseveralunintentionalfeaturesofthecodesnippetevaluationprotocol.theseraisethreatsto validityincodeevaluationstudiesofthetypeusedingopsteinetal.
eachoftheexamplesbelowrepresentexceptionstotheintendedresearchquestionsofgopsteinetal.someintroduceconfusionwherethey should not others add mechanisms of inferring correct answers where they should not and still others rely on non standard features ofthe c language.
.
.1printfis confusing.
the basis for hand evaluation experimentsisforthesubjecttoreportthestandardoutputoftheprogram in question.
in c the canonical method of generating standard output is with the stdiofunction printf.
it is famous for its esoteric api thatisrarelyfully learnedbyusers.manysubjects especially the professionals called this out as a potential source of confusion printfandthepercentthingsiprettysureiremembermostofthem and i m pretty sure percent c prints the character but i i check the manpageeverytimeihavetouseonethose.
and we ve got a float and we re printf ing it with a percent d i never know aboutprintfsyntax i never use it .
according to the original description of atoms of confusion certaintypesofconfusionwereexcludedfromthestudy includingapi relatedconfusion whichappearstobeexactlywhat printfinduces.
potential alternatives include providing documentation along with the experiment or using c s coutobject which does not require a format specifier.
both of these solutions have downsides and neither isideal but abettersolution isworth considering.
.
.
relying on the correctness of the example.
the introductory text to our study said each program compiles and runs without error .
a somewhat popular tool amongst subjects was to leverage that facttomakeassumptionsaboutthecode.
i justremembered everyprogramexecutes.sothis mythinkingofthisnotworking iswrong .inpractice programmerslikelywillnothave these types of assurances and cannot rely on the fact that arbitrary code isguaranteednot to produce an error.
.
.
variable names.
the snippets included in our study were designednottoincludesemanticbeacons whichmighttelegraphthemeaningofthecodetotheprogrammerbeforetheyfully comprehendhowitworks.partofthisprocesswastherenamingof all variables to v1 v2 v3 etc.
however there were examples where perhaps the naming of the variables induced otherwise unlikely errors.
for example in snippet variables v1andv2contained thevalues 2and1respectively effectivelyswappingthecontents ofthenamesandvalues.subject4304madeitclearthatheknew which variable contained which value however when writing his responseheaccidentallyswappedthem.oneobviouswaythismay have happened was by subconsciously writing the number containedinthenameofthevariable ratherthanthevalueitcontained.
infutureexperiments itmaybebeneficialtouseavariablenaming scheme that willnot overlap withthe storedinformation.
.
.
redefining macros.
the snippet included in our study to represent the preprocessor in statement atom contains a macro redefinition.therearetwo define softhesameidentifierinthe same file without an undefbetween them.
the c specification section .
.
.
specifically says this is invalid an objectlike macro shall not be redefined by another definepreprocessing directive .andthiswasbroughtupbyoneofthesubjects right here we have like uh a redefinition of both m1 and m2 to be different things.
um and i m not positive.i ithink that snot well defined.um andithinkthatshouldbeacompilererror butitcould alsobelikeoverwritetousethelikethelatterone .there 614thinking aloudabout confusing code esec fse november8 13 virtualevent usa wassomecontroversyherethoughasasecondsubjectclaimedit wasvalid likeifyou redefining avalue inthepreprocessor and it s already set but if you set it again they will not warn you or whatever.itjustletsyouoverrideit.
.interestingly this behavior is documented as being allowed by gcc if a macro is redefinedwithadefinitionthatisnoteffectivelythesameastheold one thepreprocessorissuesawarningandchangesthemacrotouse thenewdefinition .itisunclearwhetheradding undef swould make the code less confusing but the current version is not the bestexamplefromwhichtobaseconclusionsaboutcomprehension.
anotherfactorworthconsideringiswhetherthecpreprocessor arguablyanindependentlanguage oughttobestudiedatthesame time the c language proper as the preprocessor is known to be usedinwaysthat conflictwiththe underlying language .
.
.
void main.
presumably for brevity all code snippets are written using voidreturn types on the mainfunction.
c technically does not allow this despite several compilers being permissive aboutit andmanyprofessionalscomplainedaboutit rightoff the bat it s void main uh which is i feel like i m back in java land.
so uh it should be int the thing i was a little tweaked out by is that void main oh so they are all void main.
oh that s lovely.
uh main is void.
that s a little bit strange to me .
changing the type of the mainfunction tointwould also necessitate adding another line to each program returning .thisreturnvaluemightinturncomplicatethesubjects understandingofwhatvaluetoreportas output .still itisclear thatvoid main isnot an acceptable idiom inastudy like this.
.
improvingquantitativeexperiments throughqualitativepilots the previous sections outline many flaws in an otherwise thoughtfully designed quantitative experiment.
we contend that issues like these are not unique to this experiment but likely manifest in different forms in many program comprehension experiments.
our experience illustrates how performing a qualitative study allowed usto make visiblemanyissuesthat we didnot originallyforesee.
in our case the quantitative and qualitative portions of these studies were conducted sequentially as two separate endeavors.
thefindingsofourstudymayhelpdesignfuturequantitativeexperiments that explore some of the questions that emerged from thisstudy.however ifgopsteinetal.haddoneathink aloudstudy prior to designing their original experiment they most probably wouldhavefoundlimitationssimilartotheoneswefoundandcould haveavoidedthem.indeed whilegopsteinetal.reportconducting a pilot study for their experiment it was solely done to estimate statisticalpowertochooseasamplesize.therefore werecommend toresearchersdevelopingnewtypesofprogramcomprehensionexperiments to begin by validating their approach qualitatively prior to conducting their full quantitative experiments.
while the effort involvedinourstudywassignificant andprobablyprohibitiveto researchers for whom it would be only a pilot test we believe that itispossibletousesimilarapproaches yetinalesstimeconsuming fashion.
while we made sure to reach theoretical saturation when analyzing our data as this was a stand alone study the main themes emerged after we analyzed the first half of the participants andcould have informedthe designofaquantitative study.
conclusion atoms of confusion are a model for conceptualizing measuring andcomparingsmall hard to evaluatepatternsinsource code.previousresearchusedexperimentalapproachestovalidate and quantify the effectsof these patterns.
to further contextualize the existing body of work and to provide a richer description of subject sunderlyingreasoning weperformedaqualitativeinvestigation of the same phenomenon.
specifically we conducted a think aloudstudyofprogrammershand evaluatingatomsofconfusion and their associated simplified code pairs.
the observations made in this paper offer insights for future research on atoms of confusionaswellasformoregeneralhandevaluationstudieson program comprehension.
asthesecond qualitative studyinanexplanatorysequential mixed methods design our study was designed to give context to the results presented by gopstein et al.
.
we wanted to go beyond the dichotomous data presented before and describe more than just whether or not a programmer correctly evaluated a code snippet.
we wanted to understand and describe how programmers evaluated code what steps they took what pitfalls they hit and how they evaluated unknown constructs.
we arrived at a commontaxonomythatwasabletonaturallycategorizemanyofthe incorrect evaluations in our study and that shows that not all misunderstandingscome from the same mechanism.
we investigated responses given bysubjects whose hand evaluationswere correct and learned that correct answers do not alwaysimply correct reasoning on behalf of the subject.
by using a qualitative research approach we were able to see that even for the data points that in a quantitative study would look absolutely correct there was stillsignificantconfusionthatwouldotherwisegounnoticed.insights like these allow us to look back on previous research and understand it with new depth.
we can see that hand evaluation studiesmaybeunder reportingtheamountofmisunderstanding since correct responses are now shown not to necessarily imply completeunderstanding.furthermore wecanseethat justbecause errorsare beingobserved they are not alwaysdueto the factors the experiment wasdesignedto test.
beyond understanding previous work we identified several key factorsthatcanhelpdesignsimilarexperimentsinamorerigorous wayaswellasentirelynewstudiestoexplorefurtherideas.simple changes can help give more accurate results such as avoiding complex apis like printf.
we can expand the current understanding of what code is confusing by empirically validating more atoms of confusion.
finally we have seen ways in which the current model ofconfusionislimiting.definingconfusionasadichotomousevent something that either occurs or not simplifies a very complex phenomenon.
instead it may be valuable to consider a more flexible andcomplexmodelofconfusion onethatisbasedonobjectiveempiricalevidenceandquantitativemeasurementandthusaccounts forarbitraryformsofcodeandthevariationbetweenprogrammers.