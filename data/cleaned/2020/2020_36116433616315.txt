mining resource operation knowledge to support resource leak detection chong wang fudan university shanghai china wangchong20 fudan.edu.cnyiling lou fudan university shanghai china yilinglou fudan.edu.cnxin peng fudan university shanghai china pengxin fudan.edu.cn jianan liu fudan university shanghai china m.fudan.edu.cnbaihan zou fudan university shanghai china bhzou21 m.fudan.edu.cn abstract resource leaks which are caused by acquired resources not being released often result in performance degradation and system crashes.
resource leak detection relies on two essential components identifying potential resource acquisition and release rar api pairs and subsequently analyze code to uncover instances where the corresponding release api call is absent after an acquisition api call.
yet existing techniques con ne themselves to an incomplete pair pool either pre de ned manually or mined from project speci c code corpus thus limiting coverage across libraries apis and potentially overlooking latent resource leaks.
in this work we propose to represent resource operation knowledge as abstract resource acquisition release operation pairs abs rar pairs for short and present a novel approach called m rok to mine such abs rar pairs to construct a better rar pair pool.
given a large code corpus m rok rst mines abs rar pairs with rule based pair expansion and learning based pair identi cation strategies and then instantiates these abs rar pairs into concrete rar pairs.
we implement m rok and apply it to mine rar pairs from a large code corpus of java methods and maven libraries.
we then perform an extensive evaluation to investigate the mining e ectiveness of m rok and the practical usage of its mined rar pairs for supporting resource leak detection.
our results show that m rok mines new abs rar pairs and instantiates them into rar pairs with a high precision i.e.
.
.
in addition by feeding our mined rar pairs existing approaches detect more resource leak defects in both online code examples and open source projects.
ccs concepts software and its engineering !software libraries and repositories.
y. lou is the corresponding author.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro t or commercial advantage and that copies bear this notice and the full citation on the rst page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior speci c permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
resource leaks defect detection knowledge representation knowledge mining acm reference format chong wang yiling lou xin peng jianan liu and baihan zou.
.
mining resource operation knowledge to support resource leak detection.
in proceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa 13pages.
introduction resource leaks which are caused by acquired resources not being released e.g.
unclosed le handle is a serious software defect that may cause runtime exceptions or program crashes.
resource leaks are prevalent in both software projects and online code examples e.g.
even those code snippets accepted as correct answers in stack over ow posts .
to date researchers have proposed various automated resource leak detection techniques which mainly rely on two essential components.
first identify the potential pairs of the resource acquisition api method and the corresponding resource release api method rar pairs for short then based on the rar pairs analyze the code to check whether the release api is not subsequently called after the acquisition api.
for example the resource acquisition api method lockmanager.acquirelock and the resource release api method lockmanager.releaselock are one rar pair of the lock resource and a resource leak occurs when lockmanager.releaselock is not called subsequently after lockmanager.acquirelock .
although achieving promising e ectiveness the majority of existing resource leak detection techniques are concentrated on proposing more precise and more scalable code analysis approaches while few of them focus on building a more complete rar pair pool.
however knowing the rar pair is the prerequisite of detecting the corresponding resource leak in the code and an incomplete rar pair pool would limit the e ectiveness of the following code analysis.
in particular most existing techniques rely on human expertise and heuristic rules to prede ne rar pairs.
such prede ned rar pairs not only require non trivial human e orts but also have limited coverage in libraries and apis.
for example findbugs only considers the prede ned stream related rar pairs and thus could only detect stream related resource esec fse december san francisco ca usa chong wang yiling lou xin peng jianan liu and baihan zou lock.acquire lock.release nooplock.acquirelock nooplock.releaselock globallock.acquire globallock.release ... hlockmanager.acquire hlockmanager.release lockmanager.acquirelock lockmanager.releaselock ...corresponding rar pairs in different librariesabs rar pair for lock resource lock acquire release figure abs rar pair and rar pairs for resource lock leaks.
more recently bian et al.
propose to identify rar pairs for a given project by mining and classifying frequent api pairs within the project code corpus.
however such project speci c frequent mining is limited to speci c libraries projects and could only nd rar pairs that are frequently used in the project code corpus missing those infrequent rar pairs.
thus in this work we aim at building a large rar pair pool from a mass of projects and libraries which could be used to enhance and support resource leak detection.
in fact it is challenging to build such a relatively complete rar pair pool that precisely includes as many rar pairs as possible.
first given the large variety of libraries and apis in the wild it is not easy to cover the diverse resources and acquisition release operations.
for example just for the lock resource there are over relevant rar pairs reported by our approach e.g.
lockmanager.acquirelock lockmanager.releaselock and softlock.lock softlock.unlock .
in addition to popular resources there are many less common resources e.g.
semaphore .
second it is not easy to precisely identify whether two apis belong to one rar pair since a pair of antisense verbs do not always indicate the acquisition and release operations.
for example although open and close are a pair of antisense verbs that are commonly used in acquisition and release apis for some resources e.g.
database.open database.close and connection.open connection.close they do not denote resource acquisition and release in some context e.g.
opentag and closetag actually denote the start tag and end tag of an xml element .
to this end we propose to represent resource operation knowledge as abstract resource acquisition release operation pairs i.e.
abs rar pairs for short and mine such abs rar pairs from a large code corpus.
di erent from rar pairs that are represented by concrete api methods an abs rar pair uses conceptual level noun and verbs to describe the resource object and acquisition release operations which thus is able to represent a group of rar pairs that share similar semantics.
for example as shown in figure the abs rar pair hlock acquire release icould represent a set of rar pairs that use acquire and release to manage the lock resource such as globallock.acquire globallock.release in library xmlbeans and lockmanager.acquirelock lockmanager.releaselock in library copper coreengine highlighted in figure .
our insight is that abstract representation could extract more general resourceoperation knowledge from a large code corpus and cover more diverse rar pairs across di erent libraries projects.
based on this idea we propose m rok a novel approach for mining resource operation knowledge which constructs a large rar pair pool to support resource leak detection.
given a large code corpus m rok rst mines resource operation knowledge in theform of abs rar pairs and then instantiates these abs rar pairs into concrete rar pairs.
in particular m rok iteratively mines new abs rar pairs based on existing ones with two strategies i.e.
the rule based abs rar pair expansion strategy derives new abs rar pairs from existing ones based on the conceptual specialization relationships between resources and the learning based abs rar pair identi cation strategy trains a sequence labeling model to identify new abs rar pairs.
after the abs rar pairs are mined m rok then instantiates them into concrete rar pairs in di erent libraries with matching based rules.
we implement m rok and apply it to mine resource operation knowledge from a large code corpus of java methods and maven libraries.
we then perform an extensive evaluation to investigate the mining e ectiveness of m rok and the usage of its mined rar pairs for supporting resource leak detection.
first we investigate its mining e ectiveness by checking the quality of its mined abs rar pairs and the instantiated rar pairs.
in total m rok mines new abs rar pairs based on seed pairs and .
of them are manually checked as correct and all abs rar pairs are then instantiated into rar pairs from libraries and .
of them are manually checked as correct.
second we feed our mined rar pairs to existing resource leak detection analysis approaches and study how they could boost resource leak detection.
given the prevalence of resource leak issues in both online code examples and open source projects we evaluate how our generated rar pairs help resource leak detection in both scenarios.
first for the online code examples we nd that with our newly mined rar pairs as inputs even a simplistic static analysis approach successfully detects .
more resource leaks i.e.
resource leaks in total from online code examples with a high precision .
.
second for the open source projects we enhance the widely used resource leak static detection tool findbugs by enriching its initial rar pool with our new rar pairs.
our results show that on github projects the original findbugs detects resource leaks while the findbugs extended with our rar pairs detects more previously unknown resource leaks.
among them one has been con rmed by developers as of the submission time.
in summary the results show both the high quality and practical usage of our mined rar pairs.
in summary this paper makes the following contributions a novel representation that represents resource operation knowledge with abs rar pairs.
such abs rar pairs could represent a group of semantically similar rar pairs across di erent libraries projects and thus convey more general resourceoperation knowledge of a large code corpus.
a novel mining approach m rok that constructs a large rar pair pool to support resource leak detection.
m rok rst learns to mine abs rar pairs from a large code corpus in an iterative learning process and then instantiates these abs rar pairs into concrete rar pairs.
a large scale and high quality rar pair pool that contains rar pairs mined from java methods over libraries.
to the best of our knowledge this is the largest rar pair pool for java resource leak detection.
we would publicly release our rar pairs which could be incorporated by existing or future resource leak detection work.
987mining resource operation knowledge to support resource leak detection esec fse december san francisco ca usa an extensive evaluation that investigates both the mining e ectiveness and the practical usage of mined rar pairs for supporting resource leak detection.
the results show that m rok successfully mines and instantiates a large number of rar pairs with a high precision and our mined rar pairs further help existing resource leak detection approaches to nd more resource leaks in both online code snippets and open source projects.
related work since our work mines resource acquisition and release api pairs to support resource leak detection in this section we discuss the related work on resource leak detection section .
and api usage pattern mining section .
.
.
resource leak detection automated resource leak detection techniques have been proposed to detect whether some resource is not being released after its acquisition.
typically there are two important components for resource leak detection.
first identify the potential rar pairs the pair of the resource acquisition api method and the corresponding resource release api method then based on the rar pairs analyze the code to check whether the release api is not subsequently called after the acquisition api.
the majority of existing resource leak detection techniques are concentrated on the analysis part by proposing more precise and more scalable code analysis approaches .
for example torlak et al.
combine intra procedural analysis and inter procedural analysis to enable more scalable and more accurate detection for system resource leaks e.g.
i o stream and database connections wu et al.
propose an inter procedural and callback aware static analysis approach to detect resource leak in android apps kellogg et al.
incorporate ownership transfer analysis resource alias analysis and obligation fresh to enable more precise analysis.
our work is orthometric to this line of work since we focus on building a more diverse and large rar pair pool and our generated rar pairs could further be incorporated into existing resource leak detection techniques.
in fact the rar pairs used in most existing techniques are often prede ned by human expertise and heuristic rules which not only require non trivial human e orts but also have limited coverage in libraries and apis.
for example torlak et al.
manually collect rar pairs that are related to stream anddatabase resources in jdk.
in addition findbugs only considers the prede ned stream related rar pairs and thus could only detect stream related resource leaks.
more recently bian et al.
propose sinkfinder which mines rar pairs for a given project by mining and classifying frequent api pairs within the project code corpus.
however its mined rar pairs are limited to speci c libraries projects and only include rar pairs that are frequently used in the project code corpus thus missing those infrequent rar pairs.
di erent from sinkfinder our work represents and mines resource operation knowledge via a novel abstract representation e.g.
abs rar pairs based on which we build a large rar pair pool from a large amount of diverse libraries projects.
call sequence extractionabs rar pairs initializedwithseedpairs rule based abs rar pair expansion learning based abs rar pair identification largecodecorpus1.preprocessing2.abs rarpairminingresource operation knowledge base3.rarpairinstantiation librariesconcreterarpairsfigure approach overview of m rok .
mining api usage pattern for misuse detection in other domains there are also some techniques that mine api usage patterns to detect the relevant api misuse .
for example chang et al.
leverage frequent subgraph and itemset mining to mine rules for neglected condition detection.
examplecheck mines api usage patterns for popular java apis to detect api misuses such as missing control constructs and incorrect guard conditions.
our work targets a domain i.e.
resource leak di erent from these techniques i.e.
we focus on mining the usage patterns of apis on resource operation knowledge.
to this end we not only propose a novel representation i.e.
abs rar pairs to represent the resource knowledge related api usage pairs but also propose a novel learning based mining approach to mine such abs rar pairs from a large code corpus.
approach m rok mines abs rar pairs from a large code corpus and then instantiates the abs rar pairs into concrete rar pairs of di erent libraries.
figure 2shows an overview of m rok which mainly consists of three phases call sequence extraction abs rar pair mining and rar pair instantiation.
first m rok parses the large code corpus to extract method call sequences section .
.
second m rok iteratively mines abs rar pairs from the extracted sequences with two strategies section .
i.e.
rule based abs rar pair expansion and learning based abs rar pair identi cation.
lastly m rok instantiates the mined abs rar pairs into concrete rar pairs section .
.
in this work we focus on resource operation knowledge in java.
.
method call sequence extraction since resource acquisition and releasing are often achieved by invoking relevant api methods m rok rst parses the given code corpus to extract method call sequences as the input of the abs rar pair mining.
for each source le in the code corpus m rok rst parses it into an abstract syntax tree ast with the javalang toolkit and then extracts a sequence of method calls based on ast node types following previous works .
an extracted method call sequence is a list of method calls ordered by their appearance in the code.
for each method call .
oandmdenote the name of the object and the called method respectively.
for example for the method verify shown in figure a m rok extracts a method call sequence shown in figure b .
.
abs rar pair mining abs rar pair de nition.
an abs rar pair is a two tuple 01b ha4b a4 i where a4brefers to a resource concept and and 988esec fse december san francisco ca usa chong wang yiling lou xin peng jianan liu and baihan zou a code example wakelock.acquirerecoverysystem.verifypackagewakelock.releasecall sequence b method call sequence wakeobjtreslockobjtresacquiremdtacqsystemobjtnonverifymdtnonwakeobjtreslockmdtrestoken sequence part sequence tag sequence recoveryobjtnonpackagemdtnonreleasemdtrel c token sequence part sequence and tag sequence figure a code example and its corresponding call sequence token sequence part sequence and tag sequence a4 is a pair of conceptual level resource acquisition and release operations for a4b.
the bene ts of conceptual level abstraction in abs rar are two folds.
first an abs rar pair can be regarded as an abstraction of similar rar pairs that are implemented in di erent libraries.
for example hlock acquire release iis an absrar pair for lock resource as shown in figure it could represent a group of relevant rar pairs de ned in di erent libraries.
second representing the resources and acquisition release operations in a conceptual way could further support resource generalization specialization e.g.
wake lock is a specialization of lock synonyms e.g.
database and db are synonyms and semantic relevance e.g.
lock and semaphore are both concurrencyrelated resources acquire release and lock unlock are both concurrency related acquisition release operations .
these properties can help the transfer and generalization of resource operation knowledge thus are bene cial for the mining.
with a small set of seed abs rar pairs m rok iteratively mines abs rar pairs from the extracted method call sequences via two strategies i.e.
rule based abs rar pair expansion and learningbased abs rar pair identi cation .
rule based abs rar pair expansion derives new abs rar pairs from existing ones based on the conceptual specialization relationships between resources and learning based abs rar pair identi cation trains a sequence labeling model based on existing abs rar pairs and uses the model to identify new abs rar pairs from the method call sequences.
in each iteration m rok leverages both strategies to extract new absrar pairs which are then included to extend the pool of abs rar pairs.
the iteration process repeats until the maximum number of iterations is reached or no new abs rar pairs are found.
we then detail each mining strategy respectively.
.
.
rule based abs rar pair expansion.
rule based abs rar pair expansion derives new abs rar pairs from existing ones based on the specialization relationships between resources.
in particular a conceptual specialization relationship means that a resource concept is a special instantiation of another resource concept.
for example we regard the resource concept wake lock as a specialization of the resource concept lock and it is very likely that thespecialized resource concept wake lock shares the similar acquisition release operations as lock e.g.
acquire and release .
in particular given a method call sequence m rok rst identify all the candidate method call pairs which match any existing abs rar pair as a conceptual specialization then m rok derives new abs rar pairs based on the candidate pairs.
we then introduce the detailed steps as follows.
first m rok tokenizes each method call .
in the method call sequence based on camel case and parse part of speech pos tags .
in this way each method call .
is tokenized into the form where odenotes the object name and vb np and rest denote the verb noun phrase and the rest tokens in respectively.
for example the method call filescontroller.openfilebyname is transformed into o le controllers vb open np le rest by name .
second for each two methods calls i.e.
.
1and .
in m rok identi es whether they are a pair of resource acquisition release operations based on our pairing rules and whether they match any existing abs rar pair ha4b a4 ias a conceptual specialization based on our matching rules .
the quali ed method call pairs are considered as candidate pairs.
matching rules.
we consider a method call .
with the form matches a4b.
ora4b.
a4 if it satis es the following two conditions the noun phrase npcontains a4b orocontains a4bandnpis empty the verb vbequals ora4 .
pairing rules.
we consider two method calls .
1and .
as a pair of acquisition release operations if they satisfy the following three conditions .
1and .
2match a4b.
anda4b.
a4 respectively the noun phrase i.e.
np and the rest i.e.
rest in .
1and .
2are the same and .
appears before .
2in the same method call sequence.
third based on each candidate pair .
.
m rok creates a new abs rar pair ha4b0 a4 i where a4b0is if contains a4bandnpotherwise.
for example given an abs rar pair hlock acquire release i we can derive a candidate abs rar pair hwake lock acquire release ifrom the method call sequence shown in figure b .
to avoid generating an overwhelming number of abs rar pairs in each iteration we only include those ones whose frequency is more than three into the abs rar pair pool.
.
.
learning based abs rar pair identification.
rule based pair expansion only mines new pairs which have conceptual specialization relationships of existing pairs.
hence to include more diverse abs rar pairs m rok further leverages a learning based absrar pair identi cation strategy.
in particular m rok treats the abs rar pair identi cation problem as a sequence labeling problem leverages existing abs rar pairs to automatically label the data for model training and then utilizes the trained model to extract new abs rar pairs.
we then discuss details on the problem de nition automatic data labeling model design and training prediction procedure respectively.
problem de nition.
we model abs rar pair identi cation as a sequence labeling problem.
sequence labeling has been widely studied in natural language processing nlp and applied to software engineering tasks e.g.
entity concept recognition and its main goal is to tag each token in a token sequence.
989mining resource operation knowledge to support resource leak detection esec fse december san francisco ca usa in our context we de ne four di erent tags i.e.
a4b a4 and denoting tokens corresponding to resource acquisition operation release operation and others respectively .
with each method call sequence as a token sequence our goal is to assign a tag to each token and based on the combination of these tagged tokens we could further identify possible combinations of a resource a4b an acquisition operation and a release operation a4 that can form an abs rar pair like ha4b a4 i. for example the token sequence and the tag sequence of the method call sequence in figure b are shown in figure c .
automatic data labeling.
to prepare the training data for the sequence labeling model m rok automatically labels the method call sequences via a distant supervision method.
distant supervision was originally proposed for the data labeling problem in relation extraction .
the main idea is to use the existing knowledge base to automatically label training data.
in our work we use existing abs rar pairs as the resource operation knowledge base to automatically label method call sequences.
for each method call sequence if it matches an existing abs rar pair it is automatically labeled and used a training sample otherwise it is used as a prediction sample for identifying new abs rar pairs.
we then explain the details as follows.
token part sequence generation .m rok generates a token sequence and a part sequence for the method call sequence .
these two sequences will be used as the input of the sequence labeling model.
for each method call .
in m rok tokenizes and by camel case to get a subsequence of tokens.
for example the method call wakelock.acquire is tokenized into a subsequence .
then m rok generates a token sequence for by concatenating the token subsequences of all the method calls in .
to record the part of method call object or method to which a token belongs m rok generates a corresponding part sequence for the token sequence.
for each token the part sequence uses obj ormd to indicate that the token is from the object part or the method part of the method call.
for example for the above token subsequence its corresponding part subsequence is .
matching sequences with abs rar pairs .m rok then checks whether could match any existing abs rar pair.
for each abs rar pair m rok checks whether any pair of method calls in matches the abs rar pair based on the pairing rules in section .
.
.
if such a pair of method calls is found the method call sequence matches the abs rar pair.
if matches two abs rar pairs and one of them is derived from the other we only keep the derived one i.e.
the specialized one.
for example the method call sequence shown in figure b matches both hlock acquire release iandhwake lock acquire release iand we only keep the latter.
tag sequence generation .
if matches an existing abs rar pair ha4b a4 i m rok then generates a tag sequence for it.
assuming the corresponding method call pair in is .
.
m rok transforms .
1and .
2into the form and generates a tag for each token in the token sequence of in the following way the verbs i.e.
vb in 1and 2are tagged with and a4 respectively the tokens in or the wakeobjlockobjacquiremdsystemobjverifymdwakeobjlockmdtoken sequence part sequence recoveryobjpackagemdreleasemdtoken embedding part embedding layerbi lstm layerbi lstm layertag classification layertag embedding layerh1h2h3h5h6h8h9h4h7h10hidden states trestrestacqtnontnontrestrestag sequence tnontnontreltag vectors t1t2t3t5t6t8t9t4t7t10 i1i2i3i5i6i8i9i4i7i10 d e1e2e3e5e6e8e9e4e7e10enriched token vectors input vectors figure sequence labeling model in m rok noun phrase i.e.
np in 1and 2that contain a4bare tagged with a4b all the other tokens are tagged with .
for example for the method call sequence shown in figure b m rok generates a tag sequence as shown in figure c .
in this way if a tag sequence could be generated for m rok treats it as a training sample and uses its token sequence part sequence and tag sequence for training otherwise m rok treats it as a prediction sample and conducts sequence labeling on its token sequence and part sequence to identify new abs rar pairs.
model architecture.
the sequence labeling model in m rok needs to meet the following two requirements.
first the model should be able to produce multiple tag sequences for a method call sequence as there might be multiple abs rar pairs.
thus we leverage the iterative grid labeling in openie6 which could support iteratively producing multiple tag sequences for a method call sequence.
second the model should be able to incorporate both the textual semantics of tokens and the sequential information of method calls in the learning.
thus we integrate lstm long short term memory in the model which is commonly used for capturing token semantics and sequential contexts.
figure 4shows the detailed architecture of our sequence labeling model which takes a token sequence and a part sequence as input and outputs a xed number d of tag sequences.
here dindicates the depth of the model.
note that some or even all of the dproduced tag sequences may include only the tag indicating that no abs rar pairs are involved.
each token c 8and its corresponding part ?0ac are rst projected into their vector representations c c and4 ?0ac ?0ac respectively through an embedding layer.
then the two vectors are concatenated into an enriched token vector 48 c c ?0ac ?0ac .
after processing all the tokens their enriched vectors i.e.
are fed into a bilstm layer to obtain the corresponding input vectors for the iterative grid labeling block.
the iterative grid labeling block includes the following three layers bi lstm layer.
this layer takes the input vectors and outputs hidden states .
fully connected tag classi cation layer.
this layer predicts a probability distribution ?8of the four tags i.e.
a4b a4 990esec fse december san francisco ca usa chong wang yiling lou xin peng jianan liu and baihan zou for each hidden state .
based on ?
a tag sequence can be generated by selecting a tag c068 that has the highest probability in ?
.
tag embedding layer.
this layer converts the tag sequence into the corresponding vector sequence where c8is the vector representation of c068.
after each block iteration current hidden states and tag vectors are added to produce new input vectors i.e.
for the next iteration of the block.
the iterative process continues until dtag sequences are generated for the current token sequence.
token embeddings pre training.
to alleviate the parameter over tting problem in training and the out of vocabulary problem in prediction m rok leverages token embeddings pre trained on the entire code corpus to initialize the token embedding layer of the model.
the token embeddings are pre trained on all the token sequences extracted from the code corpus using word2vec .
the token embeddings can help capture the semantic associations between tokens by making tokens that frequently appear in similar contexts as close as possible in the space.
for example lock semaphore acquire and release are close in the space and the embeddings can help the sequence labeling model to capture the associations among the resources e.g.
lock semaphore and acquisition release operations e.g.
acquire release .
after initialized by the pre trained token embeddings the parameters of the token embedding layer are frozen during model training.
model training.
according to the grid labeling architecture of the model each training sample which represents a method call sequence needs to have exactly d the depth of the model tag sequences.
therefore m rok randomly selects dtag sequences for the training sample if it has no less than dtag sequences otherwise m rok generates some tag sequences that include only the tag for the training sample to reach the number d. during training the model parameters are continuously optimized with the objective of minimizing the loss.
m rok de nes the loss function as the cross entropy loss between the predicted tag sequences and the labeled ones.
for each training sample the loss is the sum of the loss in the diterations of the grid labeling block.
in the th iteration the model predicts a tag sequence ?a43 with a probability sequence ?a .
here the th element in ?a is the predicted probability of the th tag in ?a43 .
then m rok takes the corresponding tag sequence i.e.
the8 th tag sequence of the training sample and calculates the cross entropy loss l between ?a43 and6 based on ?a .
however the cross entropy loss is not so sensitive to the difference between the acquisition operation i.e.
and release operation i.e.
a4 as they are close in the token embedding space and have the same token part labels i.e.
md .
therefore we add a penalty term to the cross entropy loss to better re ect the di erence between the acquisition operation and the release operation of the same abs rar pair.
given a predicted tag sequence ?a43 and the corresponding tag sequence in the training sample m rok obtains the hidden states of the two tokens in the training sample corresponding to the anda4 tags in .
based on the two hidden states i.e.
and a4 we use equation 1to calculatetheir cosine similarity and use it as the penalty term.
p cos a4 the nal loss lis calculated as equation where l 8and p8 are the cross entropy loss and penalty term in the th block iteration.
based on the loss function m rok trains the model using a stochastic optimizer such as adam .
l l p8 before training m rok splits the training samples into a training set and a validation set by .
the training set is used for model training and the validation set is used to validate the performance of the model.
when the loss on the validation set i.e.
validation loss does not decrease in three consecutive epochs m rok stops the training process and chooses the version of the model having the lowest loss as the trained model.
model prediction and abs rar pair extraction.
m rok use the trained model to predict tag sequences for each prediction sample and extracts new abs rar pairs from the predicted tag sequences.
given a prediction sample m rok takes its token sequence and part sequence as input and uses the trained model to predict dtag sequences for it.
for each predicted tag sequence ?a43 m rok tags the tokens in according to the corresponding tags in ?a43 .
then m rok tries to extract an abs rar pair ha4b a4 iwhere a4b and a4 are continuous tokens in that respectively have the corresponding tags i.e.
a4b a4 .
if such an abs rar pair is extracted and anda4 are not the same m rok treats it as a candidate abs rar pair and calculates its con dence by averaging the probabilities of all the tags in ?a43 .
after all the prediction samples are processed m rok merges identical candidate abs rar pairs and averages their con dences as the nal con dence.
to ensure the quality of new abs rar pairs we only include the candidate abs rar pairs whose frequency is more than three and con dence is higher than .
to extend the abs rar pair pool.
.
rar pair instantiation the abs rar pairs convey general resource operation knowledge summarized from a large code corpus and they could further be instantiated into concrete rar pairs i.e.
the pair of api methods that are de ned in di erent libraries.
these concrete rar pairs could be further incorporated by existing resource leak detection techniques.
di erent from existing work e.g.
sinkfinder mining rar pairs from the project code that uses the apis in rar pairs our rar pairs are instantiated from the library code that directly de nes the apis in rar pairs.
therefore our approach could identify a comprehensive pool of rar pairs including those pairs that are infrequently or unpairwisely used in the project code.
in particular for all api methods de ned in a given library m rok regards any two api methods .
1and2.
de ned in a same class as an instantiation of the abs rar pair ha4b a4 i if2.
1and2.
2match a4b.
anda4b.
a4 respectively.
the matching rules for method calls and resource operations are the same as those in section .
.
.
for example for the two api methods 991mining resource operation knowledge to support resource leak detection esec fse december san francisco ca usa acquire andrelease which are both de ned in same class globallock of the library xmlbeans we consider them as an instantiated rar pair of the abs rar pair hlock acquire release i. implementation the implementation of m rok includes the following important preparations and decisions.
seed abs rar pair collection .
the seed abs rar pairs used in our implementation are extracted from the api method pairs for resource acquisition and release used in wu et al.
s work .
we manually extract seed abs rar pairs from the signatures of the api method pairs.
for example from the api method pair wi manager.lock.acquire wi manager.lock.release we extract an abs rar pair hlock acquire release i. the full list of the seed abs rar pairs can be found in our replication package .
dataset construction .
the code corpus used for abs rar pair mining mainly consists of two sources.
first we obtain crawl the open source java projects on github that were created during the period of to and have more than stars.
these projects have about 4m methods.
second we collect the data in codesearchnet which is a collection of datasets and benchmarks for code retrieval.
it contains about 500k java methods.
we merge the two data sources and lter out duplicate methods.
we further lter out the methods that contain less than three method calls as they are unlikely to include rar pairs.
we also lter out the methods that contain more than method calls since the training of the sequence labeling model will consume a lot of computational resources when processing too long call sequences.
as a result the nal code corpus contains java methods.
the libraries used for rar pair instantiation include top maven libraries in the libraries.io dataset according to their stars on github.
maximum number of iterations in abs rar pair mining .w e set the maximum number of iterations to based on our observation that the iterative mining process usually reaches convergence in around iterations see section .
.
model construction .
the sequence labeling model is implemented using pytorch .
.
which is one of the most popular machine learning frameworks.
the hyper parameters of the model are as follows.
the sizes of token embeddings and part embeddings in the embedding layer are and respectively.
the hidden sizes of the two bi lstm layers are both .
the tag classi cation layer consists of two layers of fully collected networks whose hidden size is .
the settings of these hyper parameters are based on common practice in related work and the considerations of machine con guration and training overhead.
the depth of the model i.e.
d is set to .
model training .
we add a dropout of .
a commonly used technique for regularization between the second bi lstm layer and the tag classi cation layer.
the learning rate is set to .
and the training batch size is set to .
the maximum number of training epochs is set to which is rarely reached due to early stopping.
evaluation we apply m rok to rst mine abs rar pairs from a large code corpus of java methods and then to instantiate the absrar pairs into concrete rar pairs for maven libraries.
intable some examples of the mined abs rar pairs domain abs rar pairs concurrency hmutex lock unlock i hsemaphore acquire release i database hdatabase connect disconnect i hdb connect disconnect i file hxml open close i hzip init close i i o hstream init close i hreader init close i web network hsocket connect close i hclient create destroy i device hcamera start stop i hdevice open close i service hmanager activate deactivate i hcompactor initialize close i this section we rst evaluate the mining e ectiveness of m rok by investigating the quality of its mined abs rar pairs rq1 and its instantiated rar pairs rq2 we then evaluate the practical usage of its rar pairs by investigating whether they could boost resource leak detection in online code examples rq3.a and open source projects rq3.b we also perform an ablation study to investigate the contribution of both mining strategies rq4 .
rq1.
e ectiveness of abs rar pair mining how many abs rar pairs are mined by m rok ?
how many of them are valid?
rq2.
e ectiveness of rar pair instantiation how many concrete rar pairs are instantiated from the mined abs rar pairs?
how many of them are valid?
rq3.
practical usage for resource leak detection rq3.a resource leaks in online code examples can our mined rar pairs help detect resource leaks in online code examples?
rq3.b resource leaks in open source projects can our mined rar pairs help detect resource leaks in open source project?
rq4.
impact of each mining strategy what is the contribution of the each mining strategy in m rok ?
.
rq1 abs rar pair mining in this rq we analyze the abs rar pairs mined by m rok .
.
.
protocol.
we manually assess the quality of the abs rar pairs mined by m rok .
in particular we invite two developers who have more than four years java development experience to independently inspect the validity of all the mined abs rar pairs.
for each abs rar pair they are asked to annotate whether it is valid i.e.
representing a valid pair of acquisition release operations on a resource.
to make a proper decision they can search and consult external sources for help e.g.
reading various technical documents on google or search github projects using speci c keywords to nd code snippets that include the abs rar pair.
if their annotations for an abs rar pair are inconsistent a third annotator is assigned to give an additional annotation to resolve the con ict with a majority win strategy.
the cohen s kappa agreement of the two annotators is .
in our manual assessing indicating a substantial agreement.
.
.
results.
based on the seed abs rar pairs m rok mines new abs rar pairs from the code corpus among which .
are con rmed to be valid.
these new abs rar pairs involve resources of them are not included in the seed pairs and operation pairs of them are not included in the seed pairs .
992esec fse december san francisco ca usa chong wang yiling lou xin peng jianan liu and baihan zou table 1shows some examples of the valid abs rar pairs.
the involved resources scatter in di erent domains such as concurrency database le i o web network device and service.
these absrar pairs re ect the following capabilities of m rok in identifying new abs rar pairs based on existing ones.
conceptual specialization of resources .
new abs rar pairs perform the same acquisition release operations on conceptually specialized resources.
for example hwake lock acquire release i has the same acquisition release operations with hlock acquire release iand wake lock is the conceptual specialization of lock .
this strategy is directly used by the rule based abs rar pair expansion see section .
.
.
conceptually relevant resources .
new abs rar pairs perform the same acquisition release operations on conceptually relevant resources.
for example hsemaphore acquire release ihas the same acquisition release operations with hlock acquire release i and semaphore is a conceptually relevant concept of lock .
new acquisition and release operations on existing resources .
new abs rar pairs perform di erent acquisition release operations on existing resources.
for example hmanager activate deactivate ihas the same resource with hmanager open close iand involves new acquisition release operations activate deactivate instead of open close .
new combinations of existing resources and operations .
new abs rar pairs combine existing resources and acquisition release operations in di erent ways.
for example hdatabase connect disconnect icombines the resource database and the acquisition release operations connect disconnect which exist in existing abs rar pairs such as hdatabase open close iand hconnection connect disconnect.
i completely new resources and operations .
new abs rar pairs involve completely new resources and acquisition release operations.
for example hcompactor initialize close iandhclient create destroy iboth involve unseen resources and acquisition release operations.
in summary m rok can mine a wide variety of abs rar pairs that involve new resources and or acquisition release operations.
the results re ect the capabilities of m rok in learning the latent relationships between resources and acquisition release operations.
we also investigate the invalid abs rar pairs mined by m rok and nd that most of them are caused by the invalid combinations of resources and acquisition release operations.
the problem might be caused by the accumulation of errors during the iterative learning process since m rok adopts a distant supervision method to train the sequence labeling model.
for example if an invalid absrar pair e.g.
hstream mark reset i is mined it might lead to more invalid abs rar pairs with other i o related resources e.g.
bu er in subsequent iterations e.g.
hbu er mark reset i .
to address this issue future work could further introduce perturbation to mitigate the negative a ects in each iteration.
summary m rok is highly e ective in mining abs rar pairs by mining new abs rar pairs with .
valid rate.
the mined abs rar pairs cover a wide spectrum of unseen resources and or acquisition release operations from di erent domains.
.
rq2 rar pair instantiation in this rq we analyze the concrete rar pairs instantiated by m rok for maven libraries.
.
.
protocol.
we introduce the rar pair mining baseline and our manual assessment used in this rq.
rar pair mining baseline.
in this rq we include the stateof the art rar pair mining technique sinkfinder as baseline by applying both sinkfinder and m rok on the maven libraries to generate rar pairs.
sinkfinder rst mines frequent api pairs from the given code corpus based on which it further trains api embeddings to infer reliable api pairs and learns to classify rar pairs.
for a fair comparison we re implement sinkfinder for java and apply it to the same code corpus as m rok .
more speci cally we rst mine frequent api pairs associated with the maven libraries from the code corpus based on the control ows and data dependencies following the original mining process of sinkfinder.
this results in a total of frequent api pairs are obtained as potential rar pairs such as org.slf4j.logger.info org.slf4j.logger.error occuring times .
subsequently we utilize random walks on control ow graphs to extract api sequences and apply word2vec and fasttext to train api embeddings thereby aligning with the approach used in sinkfinder.
building upon the embeddings a set of seed pairs is employed to iteratively infer reliable positive and negative api pairs and a binary classi cation model is trained to identify rar pairs from the frequent api pairs.
the seed rar pairs for initializing the inference process are obtained by matching the frequent api pairs with the seed abs rar pairs in the same matching method presented in section .
.
only one speci c seed pair namely odatabasedocumenttx.open odatabasedocumenttx.close from the orientdb core library emerges from this matching process.
it s worth noting that having only one seed does not does not pose a threat to the validity of the re implementation as sinkfinder is originally crafted to address scenarios where just one seed is available.
manual assessment.
we manually evaluate the quality of the instantiated rar pairs.
given the large number of concrete rar pairs i.e.
m rok instantiates concrete rar pairs in total we rst use a statistical sampling method to randomly sample concrete rar pairs which ensures the estimated precision is in .
error margin at con dence level.
then we invite two developers with more than four years java development experience to independently inspect the sampled pairs.
to make a proper decision the annotators can search various resources such as library documentation and source code on github to con rm whether the api method pairs are actually for resource acquisition and release.
if their annotations for an instantiated rar pair are inconsistent a third annotator is assigned to give an additional annotation to resolve the con ict by a majority win strategy.
the cohen s kappa agreement of the two annotators is .
indicating substantial agreement.
.
.
results.
in total m rok instantiates valid abs rar pairs into rar pairs from libraries.
among the sampled instantiated rar pairs .
are con rmed to be valid.
in 993mining resource operation knowledge to support resource leak detection esec fse december san francisco ca usa contrast the baseline sinkfinder demonstrates an inability to identify any rar pair when tested on the same extensive code corpus as m rok .
based on the provided seed sinkfinder infers only one reliable positive api pair odatabasedocumenttx.create odatabasedocumenttx.close causing it fails to perform the iterative reliable pair inference and the subsequent api pair classi cation.
the main reason is that sinkfinder relies on a set of closely related apis to train high quality api embeddings however when the code corpus is large there are too many apis from di erent libraries whose relevance is rather loose resulting in much less e ective api embeddings.
our experimental results show that sinkfinder is not applicable when mining rar pairs from a large code corpus of di erent libraries.
summary m rok instantiates valid abs rar pairs into rar pairs in libraries and .
of them are valid.
.
rq3.a resource leaks in online code examples as reported by existing work a non negligible e.g.
portion of online code examples e.g.
code snippets in the accepted answers of stack over ow posts may contain defects such as security issues or resource leak issues which would further be widely reused by developers in other projects.
therefore in this rq we incorporate our mined abs rar pairs into a light resource leak detection analysis approach to detect resource leaks in online code examples from stack over ow posts.
.
.
protocol.
we introduce the resource leak detection analysis baseline the online code example dataset and evaluation procedure used in this rq.
benchmark.
we construct a online code example benchmark which contains java code snippets in stack over ow.
in particular we rst include all the posts tagged with java from the stack over ow dump then we extract the code snippets surrounded with the tag pair pre code and code pre from their accepted answers lastly we lter out those low quality code examples with syntactic errors.
in this way we nally collect a benchmark of online code examples.
resource leak analysis baseline.
existing resource leak analysis tools mainly work at byte code level and are only applicable for a complete compilable project.
however online code examples are often short code snippets without a complete project level context and thus existing resource leak analysis tools cannot be directly applied to detect resource leaks in online code examples.
therefore in this rq we rst implement a lightweight resource leak analysis approach which takes abs rar pairs as input and parses code snippets to detect resource leaks at source code level.
in particular for a given code snippet the lightweight detector rst extracts a method call sequence in the same way as section .1and transforms all method calls into the form in the same way as section .
.
then for each abs rar pair ha4b a4 i the method sequence could be considered as containing a resource leak if a method call .
1in matches a4b.
and these is no another method call .
2in that appears after .
1and matches a4b.
a4 .
we further compare the resource leaks reported by a resource leak for abs rar pairhzip init closei b resource leak for abs rar pairhsocket init closeifigure examples of valid resource leaksthe lightweight detector when it is incorporated with the basicseed abs rar pairs or with our mined valid abs rar pairs.evaluation procedure.we manually evaluate the reported re source leaks in online code examples.
in particular we rst ran domly select cases out of all the detected resource leaks and the sample size is calculated based on the statistical sam pling method which ensures the estimated precision is in .05error margin at con dence level.
two developers who havemore than four years java development experience independentlyexamine the resource leaks and annotate whether the they aretrue or not.
the annotators could search various technical docu ments and source code on google and github to understand thegiven code examples as well as the reported resource leak defects.if their annotations for a case are inconsistent a third annotatoris assigned to give an additional annotation to resolve the con ictby a majority win strategy.
the cohen s kappa agreement ofthe two annotators is .
in our evaluation procedure indicatingsubstantial agreement.
.
.
results.the detector reports .
more resource leaks withour mined abs rar pairs compared to with the basic seed abs rar pairs.
in particular the detector with our mined abs rarpairs reports resource leaks while only reports resourceleaks with the basic seed abs rar pairs.
among the sampledresource leaks reported by the detector with our abs rar pairs .
are manually checked as true.figure5shows two examples of the valid resource leak defects.in the two examples the resource zip and socket are acquired bythe constructors but not released using the close operations.
todetect these resource leak defects we can analyze the resource oper ations in the code at the conceptual level and do not require knowl edge about the corresponding apis e.g.
zipfile and socket orlibraries.we further analyze the incorrect resource leak defects that arereported by our approach and nd that most of them are causedby the inherent limitations in source code level analysis such as 994esec fse december san francisco ca usa chong wang yiling lou xin peng jianan liu and baihan zou the ambiguous identi ers in code snippets or the lack of libraryspeci c knowledge.
in fact it is hard to address these limitations for online code examples as they are often source code snippets without global project contexts.
summary with our abs rar pairs even a simplistic resource leak analysis approach could identify resource leaks in the online code examples and .
of them are manually checked as true resource leaks.
the detector reports .5x more resource leaks with our abs rar pairs compared to with the basic seed abs rar pairs.
.
rq3.b resource leaks in open source projects in this rq we incorporate our generated rar pairs with existing resource leak detection tool to investigate whether it could detect more resource leaks in open source projects.
.
.
protocol.
we introduce the resource leak detection analysis baseline the open source project benchmark and evaluation procedure used in this rq.
benchmark.
we construct a benchmark of open source projects from github.
in particular we rst select java project repositories with more than stars from github then lter out the projects that cannot be successfully compiled with pom.xml or do not contain any relevant api method of our rar pairs.
to ensure the diversity of projects we then randomly select projects from the remaining projects.
the detailed information of our projects could be found in our replication package .
resource leak analysis baseline.
in this rq we select the stateof the art resource leak detection tool findbugs as the analysis baseline as it is a representative static analysis tool that could support general resource leak detection and has been widely used in previous work .
in particular the original findbugs includes a prede ned rar pair pool which contains stream related rar pairs.
we enhance the original findbugs by further extending its original rar pool with our newly generated rar pairs.
we denote the enhanced findbugs as findbugs .
we apply the original findbugs and the enhanced findbugs to scan projects in the benchmark respectively.
evaluation procedure.
we manually check the validity of all the resource leaks reported by the original findbugs and findbugs .
in particular two developers with more than four years java development experience independently examine the reported resource leaks.
a third annotator is assigned to resolve the con ict cases by a majority win strategy.
.
.
results.
the original findbugs reports resource leaks with of them being true resource leaks i.e.
.
with our rar pairs findbugs reports resource leaks with of them being true resource leaks i.e.
.
.
we further report newly detected unknown defects to the developers.
by the submission time one of them have been con rmed by the developers.
figure 6shows the con rmed defect1that is newly detected based on our unique rar pair netclient.connect netclient.close of library vertx core .
figure the con rmed resource leak defect as shown in the gure the resource leak occurs as the netclient resource cis acquired in line c.connect ... but without subsequently calling the release method c.close ... .
the original findbugs fails to detect this resource leak as its initial rar pair pool does not contain the rar pair netclient.connect netclient.close and it is unaware of netclient being a resource object.
summary our new rar pairs help existing resource leak detection tool findbugs report more unknown defects without reducing its precision.
our results indicate that our mined rar pairs could be incorporated into existing resource leak detection to enable more powerful resource leak detection.
.
rq4 impact of each mining strategy in this rq we investigate the contribution of each mining strategy i.e.
rule based abs rar pair expansion and learning based absrar pair identi cation .
.
.
protocol.
we compare the e ectiveness of the following variants of m rok to study the contribution of each mining strategy m rok l which removes learning based abs rar pair identi cation and only includes rule based abs rar pair expansion and m rok r which removes rule based abs rar pair expansion and only includes learning based abs rar pair identi cation.
.
.
results.
the results of the impact of the two mining strategies are shown in figure which provides the numbers of the mined abs rar pairs in di erent iterations.
we could observe that m rok mines much more abs rar pairs with two strategies together.
with the learning based abs rar pair identi cation removed m rok l only mines a few abs rar pairs in the rst iteration and cannot mine more abstract abs rar pairs in the subsequent iterations.
with the rule based abs rar pair expansion removed m rok r only mines .
fewer abs rar pairs than the complete m rok .
these results suggest that both the two strategies are important for m rok and both strategies are complementary in their capabilities of abs rar pair mining.
in particular rule based abs rar pair expansion can derive high quality abs rar pairs from existing ones based on simple rules and plays an important role in early iterations while learning based abs rar pair identi cation can continuously identify abs rar pairs in a broader scope.
995mining resource operation knowledge to support resource leak detection esec fse december san francisco ca usa figure numbers of mined abs rar pairs with di erent m rok variants summary both the rule based abs rar pair expansion and the learning based abs rar pair identi cation are important form rok .
these two strategies are complementary in their capabilities of abs rar pair mining.
threats to validity the threats to the internal validity of our studies lie in the randomness of data sampling and the subjectiveness in data annotation.
to mitigate these threats we follow commonly used data sampling strategy by controlling the estimated precision within .
error margin at con dence level and multiple annotators are involved with high agreement coe cients.
thee threats to the external validity lies in the benchmarks used by our work which cannot guarantee the generality of our ndings.
to minimize such threats we leverage a large scale of code corpus and libraries and include two resource leak detection scenarios for evaluation.
we believe it is interesting future work to extend m rok to other programming languages and incorporating m rok with more resource leak analysis tools.
conclusions and future work in this work we propose m rok a novel mining approach which represents resource operation knowledge as abstract resource acquisition release operation pairs abs rar pairs and mine such abs rar pairs from a large code corpus.
given a large code corpus m rok rst mines abs rar pairs with novel rule based pair expansion and learning based pair identi cation strategies and then instantiates these abs rar pairs into concrete rar pairs.
we implement m rok and apply it to mine rar pairs from a large code corpus of java methods and maven libraries.
we then perform an extensive evaluation to investigate the mining e ectiveness of m rok and the practical usage of its mined rar pairs for supporting resource leak detection.
our results show that m rok mines new abs rar pairs and instantiates them into rar pairs with a high precision i.e.
.
.
in addition we feed our mined rar pairs to existing resource leak analysis approaches and help them detect more resource leak bugs in both online code examples and open source projects.
our results indicate both the high quality and practical usage of our mined rarpairs.
in addition we further perform an ablation study to show the contribution of each mining strategy in m rok .
data availability our replication package is at .
acknowledgment this work was supported by the national natural science foundation of china under grant .