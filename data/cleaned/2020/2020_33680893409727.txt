understanding and discoveringsoftwareconfiguration dependencies in cloud and datacenter systems qingrongchen universityof illinois usa qc16 illinois.eduteng wang nudt china wangteng13 nudt.edu.cnowolabilegunsen cornelluniversity usa legunsen cornell.edu shanshan li nudt china shanshanli nudt.edu.cntianyinxu universityof illinois usa tyxu illinois.edu abstract a large percentage of real world software configuration issues such as misconfigurations involve multiple interdependent configurationparameters.
however existingtechniquesandtoolseither donotconsiderdependenciesamongconfigurationparameters termedconfiguration dependencies or rely on one or two dependencytypesandcodepatternsasinput.withoutrigorousunderstandingofconfigurationdependencies itishardtodealwithmany resultingconfigurationissues.
this paperpresentsourstudy of software configuration dependencies in widely used cloud and datacenter systems including dependencieswithinandacrosssoftwarecomponents.tounderstand types of configuration dependencies we conduct an exhaustive search of descriptions in structured configuration metadata and unstructured user manuals.
we find and manually analyze configuration dependencies.we define five typesofconfiguration dependencies and identify their common code patterns.
we report on consequences of not satisfying these dependencies and current software engineeringpractices for handling the consequences.
wemechanizetheknowledgegainedfromourstudyinatool cdep whichdetectsconfigurationdependencies.
cdepautomatically discovers five types of configuration dependencies from bytecodeusingstaticprogramanalysis.weapply cdeptotheeightjava andscalasoftwaresystemsinourstudy.
cdepfinds87.
of the related subset of dependencies from our study.
cdepalso finds448previouslyundocumenteddependencies witha6.
average false positive rate.
overall our results show that configuration dependenciesaremoreprevalentanddiversethanpreviouslyreported and should henceforth be considered a first class issue in software configurationengineering.
ccs concepts softwareanditsengineering softwareconfigurationmanagement and version control systems computer systems organization maintainability andmaintenance .
permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse november 8 13 virtual event usa associationfor computing machinery.
acm isbn ... .
configuration dependency cloud systems datacentersystems acmreference format qingrong chen teng wang owolabi legunsen shanshan li and tianyin xu.
.understandinganddiscoveringsoftwareconfigurationdependenciesincloudanddatacentersystems.in proceedingsofthe28thacm jointeuropeansoftwareengineeringconferenceandsymposiumonthefoundationsofsoftwareengineering esec fse november8 13 virtual event usa.
acm new york ny usa 13pages.
.
introduction .
motivation software misconfigurations are among the major causes of failures andperformanceissuesintoday slarge scalesoftwaresystemsthat are deployed in cloud and data centers .
for example misconfigurations are reported as the second largest cause of service level incidents in one of google s main production services meanwhile misconfigurations contribute to16 ofservice levelincidents atfacebookandareconsidered akey reliabilitychallenge at facebook scale .
besidestheprevalentandseveremisconfigurations users configuration issues e.g.
difficulties in understanding configurations alsoresultinhighsupportcosts .ithasbeenreportedthatconfigurationissuesarethedominantsourceofsupport costsincurredbycloud anddatacentersoftware vendors .
amongmisconfigurationsthatcausereal worldproblems .
.
involvemorethanoneconfigurationparameter .further inthecaseswithmultipleparameters theconfigurationparameters havedependencies thecorrectnessandeffectsofoneparameter s valuedepends on other parameter values.
in other words the dependentconfigurationparametersshouldbeconsideredtogether settingone ofthemcould affectthe others.
dependencies among multiple configuration parameters have beenidentified as a key source incomplexityanderror proneness of software configurations .
system users face not only the enormous configuration space ofverymanyparameters butthey also have to understand thedependencies.
note that exhaustively enumerating all possible dependencies leads to a combinatorial explosion.
to make matters worse configuration dependencies could also cross component boundaries a parameter defined in one software component could depend on a parameter defined in a different component or even in a different project .
as we show 4 inter componentconfigurationdependencies are not rare.
esec fse november8 13 virtualevent usa q. chen t. wang o. legunsen s.li andt.
xu configuration parameters p1 mapred.job.maxtaskfailures.per.tracker p2 mapred.reduce.maxattempts p3 mapred.map.maxattempts dependencies p1 p2 and p1 p3 impact violations of the dependencies will prevent failed tasks from trying on different nodes.
no checking or enforcement is implemented in mapreduce.
the dependencies were undocumented before version .
.
.
configuration parameters p1 dfs.namenode.heartbeat.recheck interval p2 dfs.heartbeat.interval dependencies heartbeatexpireinterval p1 p2 heartbeatexpireinterval is the period to wait for datanode heartbeat impact many hdfs users were confused by the heartbeat behavior and asked on the mailing lists stating that heartbeat does not work.
configuration parameters p1 hbase.lease.recovery.dfs.timeout p2 hbase.lease.recovery.pause p3 dfs.client.socket timeout p4 dfs.heartbeat.interval dependencies p1 p2 p3 p4 impact the violation of this dependency will put the lease recovery procedure into infinite loops.
no checking or enforcement is implemented.mapreducehbase hdfs hdfs a b c figure1 examplesofproblematicconfigurationdependenciesfromcloudanddatacentersoftwareprojectsandtheirimpact a mapreduce b hdfs and c hbase andhdfs.
all these dependencieshave caused real world issues .
taming software configuration dependency through configuration engineering and or tooling is currently limited because the understandingofreal worlddependenciesisstillpreliminary.to make progress a comprehensive study of configuration dependencies is needed.
better understanding would significantly benefit existing configuration tooling e.g.
for misconfiguration detection anddiagnosis reliabilityengineering e.g.
configurationcorrectness rule engineering configuration testing andcustomer support anddocumentation .
a few misconfiguration detection and diagnosis techniques consider configuration dependencies.
however all those techniques rely ona prioriknowledge of only one or two dependency types and or their code patterns as inputs.
tools that implement those techniques only cover a subset ofdependencies and also overlook several common and important dependency types and the corresponding code patterns.
a detailedcomparison isin .
.
contributions this paper makes two main contributions.
first we make the first attempt to the best of our knowledge to systematically study software configurationdependenciesin modern cloud anddatacenter software for both intra and inter component dependencies.
in particular wecomprehensivelystudyconfiguration dependencies in widely used software projects across two different cloud and datacenter software stacks the hadoop based data analytics stack and the openstack cloud computing infrastructure.
we exhaustively search the configuration dependency information described in configuration metadata and manual pages of these projects and identify the types of configuration dependencies that exist.
in total wediscover521configurationdependencies including424intracomponent dependencies and inter component dependencies.
wemanuallyanalyzeeachofthe521configurationdependencies in depth including their source code patterns potential impact on thesystemwhennotsatisfied andexistingengineeringpractices ofdependency checking violation handling andlogging.
basedonourstudy wedefineandformalizefivetypesofconfiguration dependencies with the common code patterns that they manifest.thesecodepatternscanbeusedto automatically discover configuration dependencies from code.
our study also reveals a number of missing opportunities in software configuration design andimplementationforimprovingsoftwarereliabilityandusability.second to discover configuration dependencies we present a tool named cdepthat mechanizes our understanding.
cdepanalyzes java bytecode of the software programs of interest and automatically identifies specific types of dependencies and the interdependentparameters.
cdepusesanovelandintuitiveideato discover configurationdependencies.
cdepfirst colors program variables that store values of different configuration parameters basedonstatictaintanalysis variablesassociatedwithdifferent parametershavedifferentcolors avariablederivedfrommultiple parameterscouldhavemultiplecolors.then cdepanalyzesthedependenciesbetweenthecoloredvariablesbasedonthesourcecode patternsfromourstudy.
cdepshowsthatitisfeasibletoeffectively discovervarioustypesofconfigurationdependenciesbothwithin and across software components without the need to exhaustively evaluate allpossible combinations.
weimplement cdepontopofthesootcompilerframework .
we apply cdepto the eightjava and scala projectsin the hadoop stackfromourstudy.
cdepfinds87.
oftheconfiguration dependenciesinourmanuallycurateddatasetfromourstudy.
cdep alsofinds448previouslyundocumenteddependenciesandincursa false positiverateof6.
.running cdeponthehadoop basedstack ofeightlarge software systemstakes nomore than160minutes.
overall our results show that software configuration dependencies are more common and diverse than previously reported and should henceforth be considered a first class issue in software configuration design and implementation in tooling for misconfiguration detection and troubleshooting as well as in configurationaware testingandverification.
we have madethe datasets and cdeppubliclyavailable at background we show motivating examples of problems due to configuration dependencies describe configurations and theirusage model and formally defineconfigurationdependencies.
.
motivating examples figure1showsthree real worldexamplesofconfigurationdependencieswithinandacrossthewidely usedsoftwareprojectsthatwe studied.wecanseethatsoftwareconfigurationdependenciescould be complex and even across software components.
figure 1also 363understandinganddiscoveringsoftware configurationdependencies esec fse november8 13 virtualevent usa showsthatfailurestounderstandorsatisfyconfigurationdependenciescanhavenegativeimpacts.infact allthreedependencies in figure 1have had significant implicationson system reliability and have causedreal world issues in the past.
in particular in figures1 a and c ifthedependenciesarenotsatisfied thefailures occurduringsystemrecoveryandcausedcatastrophicfailures .
additionally the configuration dependencies were not always well documented figure a and have repeatedly led to bad issues experienced by many different users figure b .
in figure c the configuration dependency includes four configuration parametersacrosstwodifferentcomponents hdfsandhbase fromtwo separate software projects.
.
configurationsandtheirusage aconfigurationisamappingfromaparametertoitsvalue.configurationsallowcustomizationofsystembehaviorwithoutmaking changestothecode.weassumethefollowingmodelofhowconfigurationsare usedinprograms.
loading.
configurations are loaded by reading from an external file or database and storing parameter values in program variables.
mature projects have well defined application programming interfaces apis forloadingconfigurations .
allprojectsevaluatedinthispaperhavesuchapis.hadoopprojects load configurations using getter methods that take a parameter and returna value e.g.
getint getstring declaredinwrapperclasses forjava.util.properties orapache.commons.configuration .openstack projects use the configparser api a part of the standard python library which provides getter methods e.g.
getintand getboolean .
we found that tracking usages of getter methods is effective for findingwhere parametervaluesare loaded.
propagation and transformation.
once loaded parameter values maybepropagatedalongaprogram sdata flowpathsusingassignmentstatementsandmaybetransformedusingarithmeticorstring operations.propagationiscommonly inter procedural througharguments and return values or through message passing with sockets orremoteprocedure calls rpcs .
usage.eventually parameter values are used in statements that changeprogram behavior e.g.
branchconditions orsystemcalls.
this model of configuration usage is the basis of our static analysisfordiscoveringconfigurationdependencies itreasonsabout interactions ofprogram variables thatstore parametervalues .
.
configurationdependencies conceptually aconfigurationdependencyiseither functional if a parameter value is influenced by other parameter values or behavioral ifasetofparametervaluescombinetoinfluencea particularsystembehavior.
wedefinea functionalconfigurationdependency asapair m f .
letpbe the set of all parameters.
mmaps a parameter p p to a non empty set of parameters q pif the value or scope ofpdepends on a function fof the value of parameters in q.f is the function that computes the value of pfrom the values of parameters in q. for example let q q1 ... qn .
then p q1 ... qn f isaconfigurationdependencyifthevalueorscope ofc p is determined by f c q1 ... c qn wherecis a gettermethod.weputthefunctionalconfigurationdependenciesinour study intofourcategoriesbasedonwhat fcomputes .
.
abehavioral configuration dependency is a function g r true false which returns trueif there is a method in the program that takes the set of values of parameters in r p i.e.
c r1 ... c rn as arguments and can return a non zero exit code andfalseotherwise.forexample let r ip.address port.number andletconnect a b beamethodintheprogramthatcreatesanetwork connection at an ip address aon portb.
theng r true is a behavioral configuration dependency because the system can failifelementsin raremisconfigured e.g.
iftheipaddressdoes not allowconnections onthe specifiedport number.
wealso categorizeconfigurationdependenciesbasedonwhere parametersaredefined essentialforanalyzingsoftwarestackswith multiple components.
a functional configuration dependency is intra component ifallparametersin p qaredefinedinthesame componentand inter component ifx y p q suchthat xand yare not definedinthe samecomponent.similarly a behavioral dependencyisintra componentifallparametersin raredefined inthe same component andinter componentotherwise.
studymethodology the key challenge in studying software configuration dependencies lies in the fact that dependency information is neither usually explicitly specified in code nor documented elsewhere.
as the first step towards a comprehensive understanding we manually collect a large dataset of configuration dependencies both within the samecomponent i.e.
intra componentdependencies andacross inter relatedcomponents i.e.
inter componentdependencies .
in this section we describe our methodology for collecting configurationdependencyinformationandforvalidatingandanalyzing the collecteddata.
.
softwaresystemsstudied to collect both intra and inter component configuration dependencies we studied software systems in two widely used cloud anddatacenterstacks thehadoop baseddataanalyticsstackand openstack for cloud computing.
both stacks contain a number of independent but inter related open source software systems.
the hadoop stack includes components for data processing and analytics aswellasunderlyingservicesforclustermanagement scheduling storage coordination etc.similarly openstackconsists of components for computing storage networking imaging etc.
whichcan be usedfor building cloud computing platforms.
table1givesashortdescriptionofthe16componentsthatwe studied eight components from hadoop hadoop common hdfs yarn hbase alluxio zookeeper mapreduce andspark andeightcomponentsfromopenstack nova swift neuron keystone glance placement ironic and cinder .
each component is a stand alone project but is typically used with other components to composelarge scaledistributedsystems.wechosethese16projects becausetheyarewidely usedandstudied theirconfigurationdesign and implementation represents the state of the art in modern cloud systems andeach one exposes manyconfiguration parameters as shownintable .
364esec fse november8 13 virtualevent usa q. chen t. wang o. legunsen s.li andt.
xu table studied software systemsandtheir descriptions.
project lang.
desc.
loc param.hadoophcommon java hadoop corelib runtime 268k hdfs java distributed filesystem 644k yarn java resource management 639k hbase java distributed database 755k alluxio java in memorystorage 459k zookeeper java distributed coordination 105k mapreduce java dataprocessing 220k spark scala mland data processing 586k 348openstacknova python computeservice 365k swift python object storage 216k neutron python networking service 223k keystone python authentication 105k glance python image management 62k placement python resource tracking 15k ironic python machineprovisioning 123k cinder python block storage 364k .
data collectionandanalysis ideally configurationdependencieswouldbecollectedautomatically e.g.
byusingprogramanalysis.however thatwasdifficult forusbecausetherewasnopriorstudyofthetypesofconfigurationdependencies.therefore asdescribedin .
.
wemanually collected configuration dependencies based on two text based data sources henceforth textsources wheredependencyinformationis sometimesdocumented configurationmetadata e.g.
inxmlbased default configuration files and user manuals .
while text sources donotdocumentthecompletesetofconfigurationdependencies they provideastarting point.
weareawarethatusermanualsandotherdocumentsoftenmiss important information .
in fact our automated tool cdep finds many undocumented configurationdependencies 6 .
we are also aware that text sources could be outdated or even incorrect .
so we do not treat the dependencies that we collect from text sources as ground truths.
rather we manually validated every collected configuration dependency by understanding how thedependencyoccursin thecode 3. .
.
.
.
collectingconfigurationdependencies.
wedescribeourheuristicsforexhaustivelysearchingforpotentialconfigurationdependenciesinthetwotextsources.weprioritizedcompletenessover precision ourheuristics basedtextanalysisiseffectiveindiscovering configuration dependencies but also introduces false positives.
false positives are acceptable at this stage all collected data are subsequentlymanuallyinspectedandvalidated.ourdatacollection does not differentiate intra vs. inter component dependencies.
we identify any interdependent configuration parameters which could come from one ormultiple components.
collectingpotentialconfigurationdependenciesfromstructured configurationmetadata.
all16softwaresystemsthatwestudied manage structured descriptions and other metadata about configuration parameters which are organized in different forms e.g.
manual entries and default xml configuration files .ideally thedescriptionofaconfigurationparameter should mention its dependencies on other parameters if any butwerarelyfoundsuchconfigurationdependencyinformationin thesestructuredconfigurationmetadata.weusethefollowingheuristictosearchforpotentialconfiguration dependencies ifthe description ofone parametermentions anotherparameter thereisalikelydependencybetweenbothparameters.weimplementthisheuristicbysearchingforotherparameters in the description of each parameter.
note that the search is not limited to strict string matching on parameter names we implement fuzzy search using a series of natural language processing techniques includingtokenization lowercaseandcamel casefiltering andstemming.aspreviouslypointedout textual descriptions may not contain the exact strings of parameter names but maycontain similar textthat describes parameters.
collecting potential configuration dependencies from unstructured manual pages.
configuration dependencies are sometimes alsodescribedinunstructuredmanualpages e.g.
.weuse thefollowingheuristictoidentifypotentialconfigurationdependencies from unstructured texts if two parameters are mentioned in the same paragraph they may be dependent and we liberally track them as such.
we record the paragraph and the manual page for further validation.
note that for manual pages we search for exact parameternames.
.
.
validation and analysis.
we validate each potential configuration dependency by inspecting each portion of text that contains a likely configuration dependency.
we filter out any false positivesthatweencounter.eachcaseisinspectedbytwoinspectors co authorsofthispaper .oneinspectorfirstmanuallyexamined eachdependencyindetail withthegoaltoanswerthesequestions whatare thedependent parameters?
isit anintra or intercomponentdependency?
howaretheseparametersdependent?
thesecondinspectorthenmanuallyverifiedalltheresultsfromthe firstinspector.intheend wehad521dependenciesandcategorized themby the typesin .
two inspectors spentsixmonths validating.foreachofthe521validatedconfigurationdependencies we further analyze the source code to answer three other questions whatarethecodepatternsexhibitedbydifferentdependency types?
4.
4. howareconfigurationdependencyviolations checkedinsourcecode?
.
howaredetectedviolationsof configurationdependencies handledinsourcecode?
.
configuration dependencytypes we define four types of functional configuration dependencies that we found provide examples and describe commonly occurring code patterns.
we neither imposed a taxonomy ex antenor defined types admissible by the definition in .3but which do not occurinourdataset.wealsoprovidemoredetailsandexamples ofbehavioralconfigurationdependencies.lastly wedescribethe resultsofcategorizingtheconfigurationdependenciesinourdata setaccording to the types describedinthis section.
.
typesoffunctionaldependencies recallfrom .3thatafunctionalconfigurationdependency isonein whichaparametervalueisinfluencedbyotherparametervalues definedasapair m f .mmapsadependentparameter ptotheset of parameters q q1 ... qn such that the scope or value of c p isdeterminedby f c q1 ... c qn whereclooksupparameters and returns values.
the type of mis the same in all functional 365understandinganddiscoveringsoftware configurationdependencies esec fse november8 13 virtualevent usa configurationdependencytypesdefinedbelow fvaries.forbrevity we will sometimes write qfor the list of values of the parameters in q. although qhas one element in all but four of 521configuration dependencies thatwe found below we give generaldefinitionsinwhich qisamulti elementset.
.
.
control dependency.
in a control dependency whether a dependent parameter pvalue can be used or not depends on the value of other parameters f q determines whether pis in scope.
example.
the most common form of control dependency that we found is that q1 ... qn enables or disables the execution of the only parts of code where pis used.
that is c p is used only whenc q1 ... c qn istrue.
in a concrete example from hdfs p rpc.metrics.percentiles.intervals andq rpc.metrics.qu antile.enable .qcontrols whether to measure percentile latency as arpc metric pspecifiespercentiles to measure.
code patterns.
essentially a control dependency occurs when control flows to all uses of c p are guarded by q. we found two control dependency code patterns branch condition.
branching dependson qandthedependentparametervalue c p isusedin only one branch.
the following code snippet shows the control dependency of the example described above in which the value of rpc.metrics.quantile.enable inrpcquantileenable controls the use ofrpc.metrics.percentiles.intervals svalue in intervals .
1if rpcquantileenable 2rpcqueuetimemillisquantiles newmutablequantiles 3for inti i intervals i ... object creation.
qis used to initialize an object and c p is only usedinsidethecreatedobject.thefollowingcodesnippetshowsan exampleofsuchpatternfromhdfs.thevalueof dfs.datanode.ava ilable space volume choosing policy.balanced space preferenc e fraction isonlyusedwhenthevalueof dfs.datanode.fsdataset .volume.choosing.policy isavailablespacevolumechoosingpolicy sincetheformerparameterisonlyusedinsidetheclass availables pacevolumechoosingpolicy1.
1volumechoosingpolicy ... blockchooserimpl 2reflectionutils.newinstance conf.getclass dfs.datanode.fsdataset.volume.choosing.policy ... 5public class availablespacevolumechoosingpolicy ... 6implements volumechoosingpolicy 7balancedpreferencepercent conf.getfloat dfs.datanode.available space .balanced space preference fraction ... ... .
.
defaultvaluedependency.
thedefaultvalueofthedependent parameter pis a function of qif and only if pis not currently assignedavalue c p braceleftbigg h c q1 ... c qn ifc p null c p otherwise a wherenullmeans that aparameterisnot mappedto avalue.
1dfs.datanode.available space volume choosing policy.balanced space p reference fraction is abbreviated to savespace.example.
in one hdfs example p dfs.namenode.edits.dir q dfs.namenode.name.dir andhis the identity function.
dfs.n amenode.edits.dir anddfs.namenode.name.dir specifythe filesystemlocationstostorenametablesandtransactions respectively.
the latter serves as the defaultvalueof the former.
code patterns.
two code patterns that matched the cases in a in file substitution.
one parameter value is explicitly used as the default value for the dependent parameter in the configuration file as showninthe following example.
name dfs.namenode.checkpoint.edits.dir name value dfs.namenode.checkpoint.dir value in code substitution .
during execution if the value of the dependentparameteris null itissettothevalueofanotherparameter.
an example 1public static list uri getnamespaceeditsdirs ... 2if editsdirs .isempty dfs.namenode.edits.dir return getstoragedirs conf dfs.namenode.name.dir wheneditdirs storing the value of dfs.namenode.edits.dir is empty i.e.
notset thevalueof dfs.namenode.name.dir isreturned.
.
.
overwritedependency.
whenmultiplecomponentsareused together some values for parameters defined in one component maybeoverwrittentobeconsistentwiththeparametervaluesin anothercomponent.hence inanoverwritedependency atsome point after pwas initialized c p h c q1 ... c q2 .
overwrite dependencies in our data set are often inter component dependenciesandcrashescanoccurwhenanexpectedoverwritedependency doesnothold.however usersmaynotbeawareofoverwritedependencies sotherecanbeconfusionastowhythesystemdoes not use the parametervaluesthat usersset.
example.
an example overwrite dependency from yarn and hdfshad p dfs.client.retry.policy.spec q q whereq y arn.resourcemanager.fs.state store.retry policy spec andhas theidentityfunction.
pdefinesthetimeoutsandretriesforhdfs clients yarnuseshdfsasadistributedfilesystemandoverwrites pwithits ownparameter q. code patterns.
we identified two code patterns explicit overwrites.the variable holding the dependent parameter s value is directly re assigned.
the following code snippet shows the overwritedependency describedabove 1retrypolicy conf.get yarn.resourcemanager.fs.state store.retry policy spec ... 2conf.set dfs.client.retry.policy.spec retrypolicy inwhichthe getandsetmethodsareusedtoreadandoverwrite configuration values respectively.
implicit overwrites.
multiple parametersareusedtosettheenvironmentalvariablesanddifferent environmentalvariablespossessdifferentprioritieswhichformthe overwritingrelationimplicitly.thefollowingshowsan example from mapreduce 1log4jpropertyfile conf.get mapreduce.job.log4j properties file 2vargs.add dlog4j.configuration log4jpropertyfile 3loglevel conf.get yarn.app.mapreduce.am.log.level 366esec fse november8 13 virtualevent usa q. chen t. wang o. legunsen s.li andt.
xu 4vargs.add dhadoop.root.logger loglevel crla the environment variable log4j.configuration set bymapreduce .job.log4j properties file implicitly has higher priorities over the environment variable hadoop.root.logger set byyarn.app.map reduce.am.log.level .
thus mapreduce.job.log4j properties fil eoverwrites yarn.app.mapreduce.am.log.level .
.
.
value relationship dependency.
the value of the dependent parameter pis constrained by the values of parameters in q. we observed three kinds of such constraints numeric.
c p a1 c q1 ... an c qn where isanyarithmeticoperator a1 ... an are numeric coefficients and is a positive or negative constant orzero.
logical.c p c q1 ... c qn where meansany logical operator and c is a special getter method that returns true orfalsedependingon thevalueof anon boolean qiorc q1 ifqi isboolean.itmeansthelogicalvalue c p shouldbeequaltothe logicalvalueof c q1 ... c qn .
set.c p c q1 ... c qn where canbeanysetoperator.failure tosatisfytheconstraints of value relationship dependencies can cause abnormal program behavior including exit abort exceptions and performance degradation.constraintsinavaluerelationshipdependencyarechecked duringcomponentstartup orduringexecution.
example.
in an alluxio numeric value relationship dependency p alluxio.master.worker.threads.max q q whereq allux io.master.worker.threads.min and .pandqdefinethemax andmin valuesofthe thread poolsize hence p q. code patterns.
commonly numeric value relationship dependencies constrain a parameter value to not be greater respectively less than a max respectively min value specified by another parameter.the following showsan example from alluxio 1mminthreads conf.getint alluxio.master.worker.threads.min 2mmaxthreads conf.getint alluxio.master.worker.threads.max 3preconditions.checkargument mmaxthreads mminthreads ... logicalvaluerelationshipdependenciesareoftenusedtospecify that parameters need to be simultaneouslyenabled.
the following showsan example from spark 1if dynamicallocationenabled spark.dynamicallocation.enabled 2executorallocationclient 3some newexecutorallocationmanager ... 5private classexecutorallocationmanager 6private def validatesettings unit if !conf.get spark.shuffle.service.enabled !testing throw new sparkexception ... ifspark.dynamicallocation.enabled storedin dynamicallocatio nenabled istrue sparkwillcreatean executorallocationmanager object which requires spark.shuffle.service.enabled to betrue.
otherwise an exception will be thrown.
in short spark.dynamical location.enabled andspark.shuffle.service.enabled have to be enabled at the same time.
as the name implies set relationship dependenciesareoftenusedtoenforcethatthevalueofoneparametermustbethesubsetofvaluesspecifiedbyanotherparameter.
the following showsan example from yarnandmapreduce.1collection string shuffleproviders conf.getstringco llection mapreduce.job.shuffle.provider.services 3collection string auxnames conf.getstringcollection yarn.nodemanager.aux services 5for string shuffleprovider shuffleproviders 6if auxnames.contains shuffleprovider ... else throw new yarnruntimeexception variable auxnames which stores yarn.nodemanager.aux services must be a subset of shuffleproviders which stores mapreduce.job .shuffle.provider.services otherwise aruntimeexceptionwill be thrown.
.
behavioraldependencies in abehavioral configuration dependency there is no dependent parameter pwhosevalueorscopedependsonthevaluesofother parameters.ratherthevaluesofmultipleparameters co operate toinfluencesomebehaviorofthesystem.morespecifically aset of parameters p p1 ... pn have a behavioral dependency if they are used together in the same operation such as a library call systemcallormethodcall suchthatchangingthevalueofsome p pcan alteracomponent s behavior.
example.
anexamplebehavioraldependencyinhadoop common isconnect a b wherep a b a fs.ftp.host and b fs.ftp.host.port .changing abutnotb andviceversa could resultinanattempttoconnecttoanipaddressataportthatisnot allowing connections the effectof aisboundedby b. code patterns.
the code patterns for behavioral dependencies are the library system methodcallhas pas arguments e.g.
1string host conf.get fs.ftp.host 2intport conf.getint fs.ftp.host.port 3client.connect host port the resultof an arithmeticoperationonelements in pisan argumenttothelibrary system methodcall.anexamplefromhdfs 1editlogrollerthreshold 2conf.getlong dfs.namenode.checkpoint.txns 3conf.getfloat dfs.namenode.edit.log.autoroll.multiplier.threshold 5nneditlogroller newdaemon newnamenodeeditlogroller editlogrollerthreshold ... 6nneditlogroller.start dfs.namenode.edit.log.autoroll.multiplier.threshold determines the threshold which in turn determines when an active node rolls its own edit log dfs.namenode.checkpoint.txns controls after how many transactions a checkpoint will be created.
these parameters are multiplied to obtain the threshold for rolling logs.
they control howthe function start works.
.
one offcodepatterns we identify configuration dependencies which fall in one of the dependency types defined in .1and 4. but do not have the commoncodepatternsdescribedin .1and 4. .
amongtheseoneoff cases are value relationship dependencies while 367understandinganddiscoveringsoftware configurationdependencies esec fse november8 13 virtualevent usa table the number of dependency types for intra and inter componentdependenciesinhadoopandopenstack.
hadoop openstack dependencies intra inter intra inter control valuerelationship overwrite defaultvalue behavioral dependency table the number of intra and inter component configurationdependenciesfoundineachsystem.inter component dependencies count one for each component involved the sum of unique inter component dependencies is therefore half ofthesum ofthenumberofinvolved components.
hadoop openstack component intra inter component intra inter hcommon nova hdfs swift yarn neutron hbase keystone alluxio glance zookeeper placement mapreduce ironic spark cinder total total are behavioral dependencies .
are intracomponentand23.
are inter component.
weprovidetwoexamples.thefirstexampleinvolvesparameters dfs.hosts anddfs.hosts.exclude in hdfs.
the former specifies alloweddatanodeaddresses whilethelatterspecifiesblockeddata nodeaddresses.thatis theintersectionofvaluesspecifiedbythese two parameters should be empty.
however from inspecting the code we did not find how they are related.
a second example also in hdfs involves the parameters dfs.namenode.replication.mi nanddfs.namenode.safemode.replication.min .
both parameters control replication numbers the former controls the replication number in normal mode while the latter controls the replication number in safe mode.
thus the latter should be larger than the former tobesafe butthereisnocodetocheckthisdependency.
our future direction is to infer those logical dependencies that miss structural dependencies in code using other types of coupling measures e.g.
evolutionary coupling .
.
results ofgrouping dependenciesby type tables2and3showtheresultsofgroupingtheconfigurationdependenciesinourstudyoftextsourcesbythetypesdiscussedin 4.1and 4. .
we highlight four main observations from table which shows the intra and inter component configuration dependencies of various types in hadoop and openstack.
first majority .
of configuration dependencies that we studied are functional.
second control dependencies are the most common form of functional configuration dependencies comprising .
of the 521dependenciesthatwe studied.third acrossalldependency types there are many more intra component dependencies thaninter component dependencies as expected parameters should be usedmoreinsidethecomponentsinwhichtheyaredefined .we further investigatedthe inter component dependenciesand found thatthecomponentsthatinteractedthemostweremapreduceand yarnwith22inter componentdependencies.finally openstack hasmuchfewerinter componentdependenciesthanhadoopbecausecomponentsinopenstackaremuchlooselycoupled each componentprovidesindependentservicesandusesrestfulapis tocommunicate.hence inbuilding cdep wedecidedtofocuson java inorder to discover dependencies inhadoop.
table3shows how many intra component dependencies and inter componentdependenciesareineachofthe16softwaresystems that we evaluate.
a key observation is that every software in our evaluation contains a configuration dependency suggesting that configuration dependencies are widespread.
onaverage a component has configuration dependencies.
even though placementisthesmallestcomponentwithonly22parameters ithasone configurationdependency.
weremindreadersthatthepopulationoftheconfigurationdependencies presented in tables 2and3should be taken with the specific systemsandour methodology inmind.
.
discussion .
.
variables in dependencies.
the majority of configuration dependencies only involve configuration values read from configurationfile whilesomeconfigurationdependenciescouldalso includevariableswhosevaluescanonlybeevaluatedatruntime.
the following code snippet from a value relationship dependency illustrates the latter mapreduce.map.memory.mb 2resource capability getperallocationresource yarn.nodemanager.resource.memory mb allocated m emory 4resource available total memory allocated memory 5if available capability 6return new containerallocation pendingask allocated 7else 8return containerallocation.locality skipped inwhich capability storestherequestedmemory setby mapreduce .map.memory.mb whileavailable storesthetotalavailablememory total memory set byyarn.nodemanager.resource.memory mb .
the variable available can only be evaluatedat runtime.
.
.
dependencies that we do not cover.
in this paper we mainly focus on configuration dependencies that are formed in software programs.
we do not consider configuration dependencies that are formedexternally inthe deployment environment .
one such example is resource competition in which different configuration parameters refer to external resources such as cpu memory and operating system os resources e.g.
ip addresses ports and file descriptors .
in other words pandq defined in 2. mustsatisfyexternalconstraintsenforcedbytheos virtual machine or hardware that deploys the software systems.
take the example in .
.
yarn.nodemanager.resource.memory mb is constrained by the physical memory size and is competing with other co running systems sharing the same machine.
resource competition is difficult to capture within the target software without knowledgeofthedeploymentenvironment.therefore wedonot considertheminthis paper.
368esec fse november8 13 virtualevent usa q. chen t. wang o. legunsen s.li andt.
xu dependencyhandling inpractice inthissection westudyhowconfigurationdependenciesare checked handled andloggedinthesoftwareprogramswestudy.wefocus onlyonvaluerelationshipdependencytypes .
.
whichhave clear definitions of violations which occur when parameter values do not hold constraints.
in principle software programs should rigorously check that dependencies hold handle any violations andprovidefeedbackto the systemusers .
wealsostudiedtheothertypesofdependencies suchascontrol defaultvalue andoverwritedependencies.unfortunately werarely found checking code or feedback messages in the program.
for example weobservethatonly13controldependencieshavechecking code or feedback messages.
our analysis follows the practice of source code inspection and violation injection .
for a target configuration dependency we start the system with crafted configuration values thatintentionally violate the dependency and then run workloads to exercise the code that uses the configurations meanwhile we observe the system behavior and logs to determine the impact ofthe violations.
.
checking configurationdependencies checking that configuration dependencies hold has significant implications on the reliability performance and usability of software systems .withoutsystematicandproactivechecking dependency violations would manifest as runtime exceptions error code failedassertions orperformance issues discussedin .
.
table4showsabreakdownofthethreeexecutionphasesduring whichconfigurationdependencyischeckedinhadoopandopenstack checking at initialization time checking at runtime after initialization and no checks.
note that neither checking at runtime nor no check is desirable the former could raise runtimeerrorswhilethe latter could degrade performance.
observations.
intable4 mostdependencies inhadoopand .
in openstack have logic in the code to check that they hold.
however a significant percentage of dependencies in hadoop and .
in openstack have no checking logic the program directly uses the dependent parameter evenwhen the dependency isviolated as exemplifiedinfigure c .
moreover and .
of the cases in hadoop and openstack are checked after initialization when it is often too late to prevent orrecoverfromruntimeexceptionsorotherfailuresandanomalous consequences .
the main reason is that not all modules areneededatthesystem sinitializationphase somemodulesare created on demand.
thus in those on demand modules the checking code is only invoked when the module is created.
moreover some dependency cases involve dynamic variables which can only be checkedat runtime as describedin .
.
.
.
handlingdependency violations weinvestigatehowdependencyviolationsdetectedbythechecking logic 5. are handled.
table 5ashows handling logic in three categories exceptions theprogramdoesnotrecoverfromthe violation theviolationissimplyreported.table 5areportson when the exception is thrown either at initialization time or runtime.
correction the program enforces dependencies by correctingtable checking practices of valuerelationship dependencies.
sw stack init time runtime nocheck total hadoop .
.
.
openstack .
.
.
table handling practices and feedback on dependency violations.weonlyincludecasesthathavecheckingcodeintable 4 no check cases arenothandled.
a violationhandlingpractices of valuerelationship dependencies.
sw stackexception correction loggingtotalinit time runtime w log w o log only hadoop .
.
.
.
.
openstack .
.
.
.
.
b logging quality for violationsof valuerelationship dependencies.
swstack complete partial inadequate none total hadoop .
.
.
.
openstack .
.
.
.
the violation such correction could potentially lead to behavior that is different from what the users expect due to deviation from the original parameter values set by users.
table 5aalso reports whethertheprogramlogsitscorrectiveactionsasusernotifications logging only the program logs the dependency violation and continues its executionwithoutinvokingany handling logic.
observations.
only45 and22.
dependencyviolationsarecorrectedinhadoopandopenstack respectively.ofthesecorrected violations and do notprovide any logmessages to users that parameter values were updated in hadoop and openstack respectively.theimplicationisthatthesoftwarethat we studiedare missing manyopportunities to correct dependency violations theysimplythrowexceptions .
ofcasesinhadoop and .
of cases in openstack or log the violations .
of casesinhadoopand4.
of casesinopenstack .
.
giving feedbackon dependency violations we systematically examined the quality of log error messages producedduringthehandlingofdependencyviolations .
.table5b showsfourcategoriesoffeedbackqualitythatwefound complete thelogmessagecontainsallparametersinthedependency andalsodescribes the dependency e.g.
1preconditions.checkargument mmaxworkerthreads mminworkerthreads alluxio.master.worker.threads.min can not be less than alluxio.master.worker.threads.max partial the log message contains some but not all parameters in thedependency.itishardtounderstandthedependencydirectly from the logmessage.the following isan example 1if recoveryenabled mapreduce.jobhistory.recovery.enable 2storeclass conf.getclass mapreduce.jobhistory.recovery.
store.class 3if storeclass null throw new runtimeexception unable to locate storage class check mapreduce.jobhistory.recovery.store.class 369understandinganddiscoveringsoftware configurationdependencies esec fse november8 13 virtualevent usa table impact of violationsof valuerelationship dependencies.
sw stack usabilitystartup runtime perf.
servicetotalfailure failure issues degrad.
hadoop .
.
.
.
.
openstack .
.
.
.
.
the message only pinpoints mapreduce.jobhistory.recovery.stor e.class butdoesnotmention mapreduce.jobhistory.recovery.en able stored in recoveryenabled which can be disabled to fix the exception.
inadequate thelogmessagecontainsnoparameter.
an example 1try 2scheme conf.
enabled backends 3except keyerror 4msg store for identifier s not found store id 5raise exceptions.unknownscheme msg the log message will only tell users identifier is not found while tellingneitherparameternames.
nomessage thismostlyoccurs when the program overrides the configuration values to enforce dependencies.
observations.
majorityofdependencyviolationhandlinglogic .
in hadoop and .
in openstack do not provide complete logmessages.
.
oflogmessagesinhadoopand35.
of logmessagesinopenstackare inthe inadequate or none categories.theseresultssuggestthatlogenhancementtools could beenhanced withconfiguration dependencyinformation to improve the qualityofthesemessages.
.
consequences ofdependency violations based on the analysis in .1 5. we turn to the question what arethe potential consequences ofconfiguration dependencyviolations?
wefindthatviolationsofconfigurationdependenciescan haveseveralconsequences including runtimefailures startup failures performance issues usability issues and service degradation.
table 6shows a breakdown of these categories of potentialconsequencesfor controlandvaluedependencies.
usabilityissuesreferto systemsignoringoroverwritinguserinputtedconfigurationswithoutprovidinguserswithfeedback e.g.
logging .
the typical cases are changing a configuration parameter takes no effect due to not satisfying control dependencies and the user inputted configuration is overwritten to resolve dependencyviolationswithoutfeedback.althoughitkeepsthesystem running the overwritten value may not reflect users intention whichinfluencesusability.performanceissuesaredefinedbyperformance metrics and do not consider system feedback.
we do not have acasethat fitsinboth usabilityandperformance.
.
and .
of consequences are severe i.e.
failures or performance issues for hadoop and openstack respectively.
the following code snippet from hdfs shows an example in which aruntimeexceptionisthrownwhen dfs.replication islessthan dfs.namenode.replication.min 1replication conf.get dfs.replication 2minreplication conf.get dfs.namenode.replication.min 3if replication minreplication 4throw new ioexception ... dependencyviolationscanalsoleadtoperformancedegradation.
for example when mapreduce.map.cpu.vcores exceeds yarn.nod emanager.resource.cpu vcores yarn will not grant more cpus to mapreduce slowing down the system.
many dependency violations could potentially lead to usability issues as the software eithersilentlyignoresoroverwritesuser specifiedparametervalues.
as discussed in .
configuration dependencies often lead to user confusion and questions in reality.
we also observe service degradationsuch as logtruncation andstaledata.
automated dependencydiscovery as discussed in .
.
manual discovery of configuration dependenciesistime consuming.ittookus20personmonthstodiscover analyze and validate the dependencies described in the documents for the software projects despite extensive scripting .
.
.
however the understanding that we gained including the definitionandsourcecodepatterns inspiredourautomatedsolution for discovering configuration dependencies.
we present cdep a toolforautomaticallydiscoveringvarioustypesofconfiguration dependencies by statically analyzing the target software programs.
cdepis built on the soot compiler framework .
it analyzes java bytecode and thus works for both java and scala programs.
cdeptakes the bytecode of multiple programs as input and outputstheconfigurationdependencies theconfigurationparameters involvedandthe dependency types.
.1cdepdesign andimplementation intra procedural taint tracking inter procedural taint tracking dependency pattern analysislocating config apisjava bytecode dependency informationcoloring pattern matching figure workflow ofthecdeptool.the basic idea of cdepis intuitive.
cdepfirst colors each program variable that stores a configuration parameter value based on static taint analysis variables associated with different parameters have different colors and one variable could have multiple colors if its value is derived frommultipleparameters.
cdepthen analyzes the dependencies between the colored variables using the source codepatternssummarizedin .ifthe variablesmatch thepatternsofaspecific configuration dependency type cdeprecordsthecorrespondingconfiguration parameters and reports a dependency between them.
figure showsthe workflowof cdep.
.
.
coloring.
cdepcolorsprogram variables based on an implementation of static taint analysis on topofthesootcompilerinfrastructure.differentparameterscorrespond to different taint colors.
cdeptaint analysis is interprocedural to track values across methods field sensitive configurationvaluescouldbestoredinafieldofaclass andcontext sensitive recording the calling context see the modelin .
.
theinitialtaintsarevaluesreadfromtheconfigurationgetter apisidentifiedby cdep 2.
.taintsarethenpropagatedalongthe data flowpaths throughassignments arithmeticoperations and string operations until they reach sink statements.
cdepsupports 370esec fse november8 13 virtualevent usa q. chen t. wang o. legunsen s.li andt.
xu taint propagation through rpcs remote procedure calls by mappingthecallerstubinterfacetothecalleeimplementation.asink statementonlyconsumestheparametervalue itdoesnotfurther propagate thevalue e.g.
by using the value as a branch condition orpassingthevaluetoanexternallibraryorsystemcall.wedonot propagatetaintsvia allcontrolflows toavoidover tainting .
wedo however analyze somecontrol flowdependenciesoftainted variables to identify dependency types such as control dependency andlogical valuerelationship.
.
.
pattern matching.
with colored variables cdepsearches for patternsdescribedin 4todiscoverdifferenttypesofdependencies control dependency.
if a branch condition uses variables from parameters q q1 ... qn and the branch condition dominates thesinkstatementsofaparameter p thencdepreportsacontrol dependencybetween pandq.cdepalsofinds asanobjectcreation pattern if qisusedtoinitializeanobjectwithinwhich pisused 4. .
.
default value dependency.
cdepleverages the semantics of common configuration getter apis in which the default value needsto be providedas an argument e.g.
t get class t class string parametername t defaultvalue ifthedefaultvalueofparameter pistaintedbyotherparameters inq a default value dependency is found.
moreover cdepchecks the pattern in which c p is overwritten by parameters from q after checking pis not set i.e.
nullorisempty .
overwritedependency.
cdepcapturesexplicitoverwritesandidentifiesallthe configurationrewriteapis intheformofsettermethods asshown in 4. .
.wedonothandleimplicitoverwrites astheyarenotcommon .
in our dataset and it requires cdepto understand theparsingcodethatreadsthevaluesloadedintocorresponding variables.
value relationship dependency.
for the numeric and set values cdepidentifies colored variables used in binary operator and set operations e.g.
contains .
it outputs the operators if the numeric set relationship is enforced in the program.
cdepalso identifies tainted variables used in max min methods whichindicatenumericvaluerelationships.forlogical values cdepsearches for all tainted variables used in a logical expression.
behavioral dependency.
cdepidentifies results of applying arithmetic operators to tainted variables which are then used in subsequent library system method calls.
these are output as behavior dependencies.
moreover if tainted parametersareusedinjava scorelibraryapis theyarealsooutput as behaviordependencies.
.
evaluation we applied cdepto the eight java and scala software components in the hadoop based stack .
overall cdepdiscovered trueconfigurationdependenciesofthefivetargettypes witha6.
averagefalsepositiverate.thebreakdownbasedondependency types is shown in table .
two authors manually verified each dependency discovered by cdepbased on the definition of the dependencies andthecodelocationpointedby cdep athird author will be looped in whenever the two inspectors needed additionalopinionsforconsensus.theverificationprocesswasthe same as the processusedinour study describedin .
.
.table evaluation results of applying cdepto the eight software projects in the hadoop based stack .
tp and fp stand for trueand false positives respectively.
dependencies discovered known tp newtp fp control .
.
valuerelationship .
.
overwrite .
default value .
behavioral .
.
overall .
.
among the true dependencies that cdepdiscovered were not in our dataset collected from the documents we were not aware of these until cdepdiscovered them.
there are two reasons for the surprisingly large number of undocumented dependencies.first manyofthedependenciesarecontroldependencies and default value dependencies as shown in table those dependencies do not lead to crashes or runtime exceptions.
so developersmaynotcarefullydocumentthemeventhoughtheycan lead to usability problems.
second there is currently no systematic practice of discovering subtle configuration dependencies.
some dependenciesareobviousbutmanyofthosediscoveredby cdepare subtle and even counter intuitive we ourselves did not understand somedependencies until we manually validatedthem.
wereverse checkedallthe448dependencycasesfoundby cdep that were not included in our study.
we find that .
of the cases are not documented while the rest .
are documented but are missedinour data collection methods .
wealsoinvestigatedthe38falsenegativesand46falsepositives fromcdep.
as shown in table cdepidentified .
out of of the dependencies in our dataset.
there are three reasons whycdepmissed the remaining .
dependencies do not have commoncodepatterns as discussed in .3 the patterns usedbycdepcannotcapturethosedependencies.
someprojects usead hocmeans to overwrite parameters instead of the standard configuration apis which contributes to the missing cases of overwritedependencies.forexample hbaseusessubstringmatchingtooverwritezookeeperparameters.
theremainingcases are dependencies that involve through external libraries which cdepdoes not analyze.
the false positives are mainly caused by over taintingdueto cdep sanalysisnotbeingpath sensitive some variables should not be tainted as the variables will not store parametervaluesat runtime.
discussion eliminating configuration dependencies a solution to the complexity caused by configuration dependencies is to eliminate them via better configuration design.
we believe that some dependencies are not necessary but result from poor configuration design.
for example the dependency between dfs.hosts anddfs.hosts.exclude in 4.3should be eliminated if a host string is in both it is unknown whether it will be allowed or blocked.
also min and max value dependencies can be designed as values in a range type to help users keep track of dependent parameters.
on the other hand many dependenciesexistforgoodreasons e.g.
mapreduce.map.memory.mb 371understandinganddiscoveringsoftware configurationdependencies esec fse november8 13 virtualevent usa andyarn.scheduler.maximum allocation mb bothcontrolmemory allocationatdifferentlevels.so itisimportanttoinvestigateradical new designs to eliminate unnecessary dependencies and to effectivelymanage existing ones.
betterhandling.
configurationdependenciesareoftennotsystematicallyhandledw.r.t.checking errorhandling andfeedback .
testing and analysis tools are needed to detect deficiencies in handlingandtoimproveusabilityandreliabilityofconfigurablesoftware.cdepcanprovidedependencyinformationtoenhancemisconfigurationinjectiontesting configurationchecking validation andconfiguration awaresoftware testing .
applying nlp to discover configuration dependencies.
a potential direction is to add nlp natural language processing to discover newtypesof configuration dependencies.somedependenciescollectedfrom documentsdonot have commonsource code patterns 4. and would be hard to find using program analysis.
using the definitions in text features can be built with focus on descriptions of dependencies.
recent work has shown promises of applyingnlptechniquestoinferconfigurationconstraints but do not consider configuration dependencies between multiple configuration parameters.
further data mining based methods can be used to discover more dependencies from large scale datasets .
threatstovalidity.
manuallyfindingconfigurationdependencies fromtextsourcesiserrorprone andwemaymissormis classify dependencies.toreducethisrisk twoinspectorsdouble checked theresults.ourresultsmaynotgeneralizetoothersystems weonly studied software for cloud and datacenter systems and software with well defined configuration apis.
cdepcan only find configurationdependencieswithcodepatternsthatwemanually identified.thus wecannotclaimtohavefoundalltheconfigurationdependenciesintheprojectsstudied.however cdepproved our concept and showed that automatic configuration dependency discovery isfeasible andshould be improvedmore inthe future.
related work the prevalence and severity of software misconfigurations have driventhedesignanddevelopmentofanumberofdetectionanddiagnosistechniques .
detectionaimsatdetectingmisconfigurationbeforedeployment while diagnosis identifies root causes of misconfigurations that causedfailures performance issues andincorrectresults.
most existing techniques either implicitly assume or are explicitly scoped tofindmisconfigurations ofindividualparameters.
however priorstudiesshowthat23.
61. ofreal worldmisconfigurationsinvolvemultipleinterdependentconfigurationparameters .inthosecases eachparametervalueiscorrectinisolation butthe value combination violates dependency constraints.
hence techniquesforsingle parametermisconfigurationscannot deal effectively withproblems causedby configuration dependencies.cdepis one step towards enhancing existing techniques to make themreason aboutdependencies.
afewpriorstudiesconsiderspecifictypesofconfigurationdependencies .mostoftheseapplymachinelearningordataminingtechniquestoinferthedependentparametersfromalargenumberofconfigurationfiles.as aprioriknowledge thesetechniquestakeconfigurationdependencytypesasinputs eitheraslearningtemplates oraslanguagegrammars .
forexample if aislargerthan binahundredofconfigurationfile thosetechniques inferavaluerelationship dependency a b. our work complements the above studies in the following three aspects.
first we cover more dependency types e.g.
default value overwrite andbehaviordependencies whicharenotcoveredby prior studies.
second for control and value relationship dependencies presented in our study shows more diverse code patterns.
third nopriorworkprovidesformaldefinitionsofconfiguration dependencies.
by filling the knowledge gap we believe that our workcansignificantlyenhanceexistingtoolstolearnmoretypes ofconfigurationdependencies.
cdepismostrelatedtospex .spexattemptstoautomatically discoverconfigurationdependenciesfromsourcecode including control dependencies and numeric value relationships between two parameters.
cdepdiffers from spex in at leasttwo aspects cdepis able to discover more dependencies with different types and different code patterns benefiting from the systematic understanding of configuration dependencies in our study and cdep isgenerictodependenciesamongmorethantwoparameters while spex ishardcodedto two parameter code patterns.
the notion of dependencies as a source of complexity has been studiedinotherdomains.forexample dependenciesofnetwork router configurations are considered a key source of complexity of network management and software productlines .
ourworkfocusesonconfigurationdependenciesintroducedand enforcedby softwareprograms not networks orproduct lines.
prior work has studied cross stack configuration errors referredtoaserrorsinonecomponentcausedbymisconfigurations of other components.
the concept is fundamentally different from configurationdependencies definedandstudiedinour paper.
conclusion this paper presents our study of and tool for finding configuration dependencies within and across software components.
we definefive typesofconfigurationdependencies andidentifytheir commoncodepatterns.wealsoreportonexistingpracticesforhandlingtheseconsequences whichareoftendeficientand adhoc.our tool cdepis effective it discovers known dependencies with high precisionandrecallandalsofinds448previouslyundocumented configuration dependencies.
these results show that configuration dependencies are prevalent and diverse that it is feasible to automaticallydiscoverthem andthattheyshouldhenceforthbe consideredafirst classissueinsoftwareconfigurationengineering.
allthe data andthe cdeptoolare madepubliclyavailable at acknowledgement we thank xudong sun sam cheng jack chen and elaine ang for usefuldiscussionsandpaperproofreading.xudongsunandwenyu wanghelpedvalidatethereproductionoftheartifactsforthepaper rebuttal.xuan pengcontributedto the study of openstack.
372esec fse november8 13 virtualevent usa q. chen t. wang o. legunsen s.li andt.
xu