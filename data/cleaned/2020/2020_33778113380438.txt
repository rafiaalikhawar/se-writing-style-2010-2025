heaps n leaks how heap snapshots improve android taint analysis manuel benz department of computer science paderborn university germany manuel.benz upb.deerik krogh kristensen department of computer science aarhus university denmark erik cs.au.dklinghui luo department of computer science paderborn university germany linghui.luo upb.de nataniel p. borges jr. cispa helmholtz center for information security germany nataniel.borges cispa.saarlanderic bodden paderborn university fraunhofer iem germany eric.bodden upb.deandreas zeller cispa helmholtz center for information security germany zeller cispa.saarland abstract the assessment of information flows is an essential part of analyzing android apps and is frequently supported by static taint analysis.
its precision however can suffer from the analysis not being able to precisely determine what elements a pointer can and cannot point to.
recent advances in static analysis suggest that incorporating dynamic heap snapshots taken at one point at runtime can significantly improve general static analysis.
in this paper we investigate to what extent this also holds for taint analysis and how various design decisions such as when and how many snapshots are collected during execution and how exactly they are used impact soundness and precision.
we have extended flowdroid to incorporate heap snapshots yielding our prototype heapster and evaluated it on droidmacrobench a novel benchmark comprising real world android apps that we also make available as an artifact.
the results show the use of heap snapshots lowers analysis time and memory consumption while increasing precision a very good trade off between precision and recall is achieved by a mixed mode in which the analysis falls back to static points to relations for objects for which no dynamic data was recorded and while asingle heap snapshot ideally taken at the end of the execution suffices to improve performance and precision a better trade off can be obtained by using multiple snapshots.
ccs concepts software and its engineering software testing and debugging keywords points to analysis heap snapshot taint analysis soot permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
.
.
.
reference format manuel benz erik krogh kristensen linghui luo nataniel p. borges jr. eric bodden and andreas zeller.
.
heaps n leaks how heap snapshots improve android taint analysis.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
introduction android is the world s most popular mobile operating system.
its official marketplace google play store holds more than .
million apps which can be installed on billions of devices.
to perform their tasks apps frequently interact with sensitive information from private images to banking details.
research shows that securityrelated bugs introduced by developers frequently put this sensitive information at risk .
to identify such sensitive information leaks taint analysis detects potential leaks by determining if data acquired on a sensitive source reaches a sink where the information would no longer be secure.
such taint flows can be detected statically or dynamically.
a static taint analysis which we focus on in this paper reasons about all possible execution paths in a program and aims to achieve close to perfect recall i.e.
it seeks to identify virtually all potentially sensitive information leaks.
static analyses though often suffer from a trade off between accuracy and scalability.
although existing taint analysis tools such as flowdroid can be configured to conduct a relatively precise flow context and field sensitive analysis such configuration needs to be identified by possibly inexperienced users and imprecise configuration causes the taint analysis to report substantial amounts of false positives .
a recent approach by grech et al.
addresses this problem by extending static pointer analysis with information extracted from heap snapshots collected at runtime.
as the authors show one can improve soundness by augmenting statically computed points to information with additional data from the heap snapshots.
conversely one can improve precision by restricting static points to computation to such information present in the heap snapshots .
in their experiments grech s idea has been proven to be very effective however the utility of the technique is still vastly unexplored leaving many questions unanswered.
both their implementation and evaluation are limited to pure pointer analysis only ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea m. benz e. kristensen l. luo n. borges jr. e. bodden and a. zeller buthow does using heap snapshots affect complex client analysis?
furthermore their setup was limited to collecting only a single heap snapshot for each execution of the analyzed application yet does a single heap snapshot suffice or are multiple heap snapshots better?
when should they be collected?
last but not least grech et al.
considered the two extremes of augmenting and restricting points to information based on heap snapshots as well as proposed a recall oriented blended analysis mode where they enhance a static model with dynamic information.
it is an open question how to model the middle ground between imprecise static heap models and unsound dynamic heap snapshots?
in this work we present an empirical study in which we seek to reproduce the original experiments revised by grech et al.
but also go significantly beyond them to address these open questions.
we make the following original contributions using heap snapshots for android taint analysis.
we investigate how heap snapshots impacts the soundness and precision not just of simple pointer analysis but of a concrete client analysis a static android taint analysis.
assessment of design decisions.
we investigate how various essential design decisions impact precision and soundness of the analysis.
in particular we evaluate the impact of two novel extensions information not only from a single heap snapshot but multiple ones e.g.
collected at various times during the execution and dynamic heap models collected at runtime precise but possibly unsound versus pure static heap models sound but possibly imprecise versus mixed models that seek to define a sensible middle ground between those two extremes by focusing on precision and enhancing a dynamic model with static information.
implementation and benchmark.
to evaluate the above decisions we implemented heapster an extension to flowdroid that can incorporate heap dumps.
additionally we created droidmacrobench a set of real world android applications that we manually labeled with ground truth for taint analyses.
evaluation.
we explore the impact of different design decisions about when to collect and how to consume heap snapshots.
in our evaluation we show that adding heap snapshots can significantly improve the precision of taint analysis from .
to up to .
while restricting points to information to that of the heap snapshots offers high precision it significantly harms recall.
our mixed mode solution however provides both good precision .
and good recall .
.
its f1 score is the highest among all configurations in all evaluated scenarios incorporating heap snapshots significantly lowers the amount of computational resources required by the taint analysis moreover in of the scenarios it also improves the analysis performance and while a single heap snapshot taken at the end of the runtime suffices to significantly increase the analysis precision additional snapshots taken at different times are beneficial for the analysis recall achieving the best overall f1 score.
1because droidmacrobench comprises closed source apps we cannot legally make it available as open source.
we will make it available to other researchers though through a password protected website.
droidmacrobench will also be made available to the artifact evaluation.the remainder of this paper is organized as follows in section we discuss limitations of the static analysis and how dynamic information can be used to enhance it.
we then present heapster which uses heap snapshots to improve taint analysis in section and in section our experiments showing the impact of different design decisions on the taint analysis results.
after discussing threats to validity and related work in sections and we close with the conclusion and future work.
background .
unsoundness in static analysis an optimal static analysis would be both sound and precise that is it would report allrelevant program information and would report only information that is in fact correct.
a points to analysis for instance is considered sound if it reports that an allocation site e.g.
a new expression ais contained in a points to set pts v of a variable vinevery case in which the program under analysis can assign to van object allocated at a. a points to analysis is maximally precise if it reports such a points to relation only under those circumstances.
points to analysis is however known to be an undecidable problem as of other static analyses.
much previous research has attempted to find trade offs that are optimal for various applications some experimenting with different context sensitivities and others selectively applying context sensitivity .
while these approaches are to some extent helpful in general they are restricted by their limited ahead of time knowledge about the program under analysis and its actual execution.
in general even the work that attempts to counter unsoundness so far has always been incomplete due to complicated usage of reflection inside some programs.
in such scenarios a sound model of these reflective features could cause a massive drop in performance precision or both.
while smaragdakis et al.
showed that one could achieve provably sound results for parts of a program under analysis the general undecidability makes the general problem unsolvable.
most work in the area of point to analysis of java thus attempts to reach some middle ground where most features of the language are modeled soundly while a small part of the language is modeled unsoundly.
.
blended analysis a blended analysis is a static analysis that incorporates dynamic information obtained while executing the analyzed program.
while dynamic information of various kind can be obtained and incorporated into the static analysis in the following we focus on heap snapshots.
heap snapshots.
a heap snapshot is a representation of objects from a running program with the values and relationships that the objects had at the specific point in time in which the snapshot was collected.
many different industrial language runtime implementations directly support collecting heap snapshots with little or no performance overhead .
heap snapshots are commonly used for debugging applications or finding memory leaks and are sometimes even collected from running production servers .
besides being useful for debugging 1062heaps n leaks how heap snapshots improve android taint analysis icse may seoul republic of korea purposes heap snapshots can be used to augment static analysis since they provide a accurate view of a single concrete heap.
uses of this concrete heap data include skipping parts of the analysis and improving the abstract heap precision in an analysis .
even if enhanced with a complete picture of the heap a static analysis must still perform approximations.
heap snapshots provide information only about objects in the heap.
they lack information e.g.
about stack variables.
also a heap does not allow the static analysis to determine which branches will be taken during runtime.
finally given that heap snapshots only contain information about objects that existed at a particular point in time the snapshot might fail to capture short lived objects that only exist during a brief computation.
these temporary objects are especially hard to capture given that some runtimes perform a garbage collection before creating a heap snapshot.
approach we designed a blended taint analysis heapster where we use heap snapshots as an upper bound in the static points to analysis.
we therefore obtain points to sets that are strict subsets of the ones obtained through a purely static analysis.
as our results show this leads to a more precise analysis than using a strictly static heap model.
however by design this also means that heapster may sacrifice some level of soundness or recall i.e.
heapster may miss reporting some true positives.
yet as our evaluation shows useful tradeoffs do exist that keep recall high while nonetheless increasing precision significantly resulting in an f1 score higher than that of purely static analysis.
to obtain such tradeoffs it is crucial to understand and appreciate that the incorporation of heap snapshots is not just a binary yes or no decision.
it opens up a design space within which one can make a number of sensible design choices from how to use the heap snapshots to when to collect them all of which affect the trade off between the analysis precision and soundness.
we implemented heapster on top of flowdroid the leading tool for static taint analysis of android applications.
flowdroid itself is built on top of the program analysis framework soot and uses soot s points to analysis engine spark .
thus in our quest for improved precision and performance in flowdroid we modify spark to incorporate information from heap snapshots.
to explain our approach we first present the inference rules used by the heap analysis in spark and we then explain our incorporation of heap snapshots as modifications to these inference rules.
we only present the rules for object allocation field stores field reads and variable assignment as these rules are the only relevant rules for our approach.
adding e.g.
context sensitivity or method calls is orthogonal to our approach.
also while our implementation was applied to android our modifications contain no android specific code thus the same implementation can also be used to analyze java applications.
figure depicts these inference rules.
the following syntax is used in the rules oidenotes a concrete object where new oicreates a new object.
vdenotes a variable.
x.fdenotes a field access of the field fof variable or object x.l rdenotes an assignment from rtol.
the symbol denotes a relation where the left side is apointer i.e.
a variable or field reference and the right side is the object the pointer points to.
e.g.
v o1andv o2denotes that the points to set of vincludes o1 o2 .
the analysis works by initializing all points to sets as empty and then applying the rules thereby adding allocation sites to the points to sets until it reaches a fixed point.
store o.f v o o1v o2 o1.f o2 read v o.f o o1o1.f o2 v o2 alloc v newo i v oi assignment v t t o1 v o1 figure the four inference rules related to the heap used by the pointer analysis spark in flowdroid in the following we explain three different designs that differ in the way in which they incorporate the dynamic heap information into spark s static pointer analysis.
.
using heap snapshots in static analysis to incorporate heap snapshots into the points to analysis we modify the store rule in figure to only apply if the same relation can be found in a given heap snapshot.
grech et al.
instead remove the store rule and modify the read rule such that it directly reads points to sets from their heap snapshot grech et al.
can thereby skip the static heap analysis altogether and achieve incredible performance.
however their approach leaves little room for modification.
by modifying the store rule our approach makes the heap analysis in flowdroid more precise without entirely skipping it.
we can thereby later selectively reenable the full heap analysis in flowdroid which we will do later in this section.
loading our heap snapshots into the analysis exposes two new functions heap andfield.
heap is a function that accepts an allocation site and returns a set of heap objects and field is a function that given a heap object and a field name returns an allocation site or null .
these two functions trivially work with multiple heap snapshots.
particularly heap will return the union of all the heap objects that have been allocated at the given allocation site from the heap snapshots.
heapster treats the heap snapshots as being a ground truth and this is achieved by restricting the statically computed points to sets to contain only allocation sites also found in the heap snapshots.
this can be expressed by replacing the store rule from figure with the one presented in figure store d o.f v o o1v o2hi heap o1 field hi f o2 o1.f o2 figure replacement store rule for spark generally in heapster it is possible to derive points to information from multiple heap snapshots gathered throughout the target application s runtime.
we propose three variants to consume heap snapshots during static analysis separate heaps in which we 2note that is used as equality in this rule.
1063icse may seoul republic of korea m. benz e. kristensen l. luo n. borges jr. e. bodden and a. zeller restrict the static points to information to what is present in a single heap snapshot and run the analysis once for each snapshot given.
merged heaps which acts like separate heaps but with all given heap snapshots used together in one single analysis run.
static fallback where the heap snapshots are used in combination with the abstract heaps.
separate heaps.
this variant essentially computes taint flows for a single realistic application state.
to nonetheless obtain a broader picture of the apps behavior we execute the analysis once for each heap snapshot collected and merge the findings as produced by flowdroid.
the separate heaps configuration assures that no points to information is merged among different heap snapshots and thus eliminates yet another source of imprecision.
this is because merging different states of an app s heap can lead to pointer combinations that are not feasible in any real execution.
since the whole taint analysis and all its pre and post analyses are executed for each snapshot the overall runtime of this variant is expected to be comparatively long even though a single run should in theory be faster than with the other variants due to having the least pointer information available at a single time.
taint flows are merged by simply aggregating flows with equal source sink pairs after all analysis runs have completed.
merged heaps.
this variant is conceptually similar to the separateheaps one.
also here we restrict the points to information to what is present in the given heap snapshots.
in contrast to separateheaps however the analysis is executed a single time with a set of heap snapshot merged together as the single source of points to information.
since only one analysis run is required the analysis usually terminates faster.
as previously stated however merging the findings of different heap snapshots might lead to an over approximation due to generating unrealistic permutations of points to information between multiple pointers.
static fallback.
there are two situations for which the separateheaps andmerged heaps variants can cause the points to set for an object field o1.fto be empty the heap snapshot only contains such objects allocated at o1for which the ffield is null or the heap snapshot contains no objects allocated at o1at all.
the latter case can be caused by objects of type o1never being allocated or by the dynamic exploration failing to explore that part of the app or because the heap snapshot by chance did not contain a shortlived o1object.
depending on the relevance of o1.fin the analyzed program the analysis might erroneously produce wildly unsound points to sets which due to the call graph becoming smaller can result in large parts of the application never being analyzed.
this mixed analysis mode addresses these limitations with a middle ground approach.
we reuse the heap snapshots from the merged heaps approach but we no longer consider the heap snapshot as the single source of points to information.
in this approach we use the static points to information as a fallback option for fields that do not exist in the merged snapshot.
our approach just as gretch et al.
combines dynamic information extracted from heap snapshots with static analysis.
however while they enhanced a static points to model with dynamic information to increase the soundness of the analysis we follow theopposite direction that is we enhance the dynamic heap model with static points to information to increase precision by only falling back to static points to information where the dynamic is missing.
this approach introduces the following changes to spark s inference rules we use the store d rule from the section .
when the heap function returns a non empty set of heap objects otherwise we use the store rule from figure .
we achieve this behavior by replacing the store rule from figure with the store d rule from the figure plus the one from figure .
store sf o.f v o o1v o2heap o1 o1.f o2 figure additional store rule for spark in comparison to the merged heaps and separate heaps approaches static fallback forces only such points to sets to be empty whose base object is indeed contained in the heap snapshot and where the specific field was observed to have the value null .
specifically static fallback retains static points to sets for such objects that the heap snapshot gives no information about.
note that we decided to not run the experiments with separate heaps in combination with static fallback.
each snapshot will have some area of the app that is uncovered and where the analysis therefore falls back to static analysis.
thus the combination would probably behave close to the fully static approach due to combining all the static pointer information for the uncovered parts of each snapshot.
additionally considering the huge amount of experiments to conduct for all apps snapshots and heuristic this would lead to an enormous time effort which is out of scope for this work.
.
collecting heap snapshots heap snapshots can be collected at distinct points of app execution and with different frequency opening up a virtually infinite set of design possibilities.
they can be collected at regular intervals or at specific points of execution.
in this work we chose to acquire heap snapshots after an input event was triggered.
while an event could be triggered by the user by clicking on the screen for example or by the system by receiving a message we restricted our snapshot collection to user events so that it could be executed on any stock android device.
we take snapshots after the app has finished its initialization and after each user action e.g.
clicks text input etc.
for this we ensure the ui is stable and the app is waiting for user input.
from a set of heap snapshots we propose the following heuristics to select which ones to use during static analysis first.
uses only the snapshot acquired immediately after the app starts with no input given.
with this heuristic it is possible to automatically acquire heap snapshots for any app without additional use of test generators or a manual app exploration.
last.
uses only the last snapshot taken during the app execution.
the rationale behind this heuristic is that by interacting with the app new elements are allocated into the heap and by collecting the last element the heap would contain more information than collecting only the first one.
1064heaps n leaks how heap snapshots improve android taint analysis icse may seoul republic of korea all.uses all collected snapshots during the analysis.
since we take snapshots after each user action executed on the phone this heuristic is equivalent to picking a snapshot for each user action.
unique activity.
use a single snapshot for each activity.
by extracting meta data when taking a snapshot such as the current user interface state we can map snapshots to activities after collecting the snapshots.
if multiple snapshots were collected for the same activity only the last one is chosen.
we opted for the last snapshot as it is more likely to contain the most substantial amount of points to information due to previous user interactions with the activity.
evaluation we used heapster to evaluate the effect of using heap snapshots for taint analysis of android applications.
specifically we aim to answer the following research questions rq1 how are the precision and soundness of flowdroid impacted by using heap snapshots as an upper bound for the static analysis?
rq2 how do precision and soundness change when using the static fallback approach?
rq3 how often and when should heap snapshots be collected to gain a useful level of precision and soundness?
rq4 how does using heap snapshots impact the runtime performance and memory consumption of the taint analysis?
.
experimental setup hardware setup.
we performed all experiments on a virtual machine with cpu cores from an intel xeon e5 v3 cpu and 100gb of ram of which we assigned 80gb as java virtual machine heap space.
dataset.
for our experiments we chose the most downloaded apps from the google play store according to com apps popular .3we opted for large real world applications for two major reasons first they resemble the most realistic use case scenario for heapster as we expect it to be best suited for large applications with hard to analyze code.
second we were unable to find an existing benchmark collection containing taint flows in real world apps where we were able and willing4 to execute the apps on our android phones.
we then filtered the apps for which we could obtain heap snapshots.
on a stock android it is not possible to extract heap snapshots from a non debuggable app that is where its androidmanifest.xml file does not contain debbugable true .
to enable the acquisition of heap snapshots we unpacked updated and re packed all downloaded apps using apktool.5we then proceeded with the apps which could be successfully re packed.
we then filtered out apps which did not contain any taint flows.
for that we analyzed the re packed apps with an unmodified version of flowdroid configured with its default list of sources and sinks which resulted in taint flows being identified in apps.
finally we filtered out apps that we were unable to install and execute on a device successfully.
for instance some apps could not be used after re packing due to security countermeasures such as 3the full list of apps is available at 4annotated taint flows for android apps are provided for known malware.
and signature checks.
other also popular apps did not have a launchable activity and were meant to be either integrated or invoked from other apps such as samsung push service6.
interestingly one app in our dataset youcam makeup launched into a developer mode after re packing.
the app behaved as usual but included extra options such as dump db dump logcat and an option to switch from production to development backend.
in the end we were able to install execute and obtain heap snapshots from apps which we used for the remaining of this evaluation.
as we will explain later we chose a subset of those apps to establish our artifact droidmacrobench.
app exploration.
to get a reasonably good coverage of the used apps we manually explored all of them on a oneplus phone and collected heap snapshots after each conducted user action.
we thereby tried to capture all reachable app functionality and created accounts to pass login screens if the apps asked for it.
experimental configurations.
in our experiments we aimed to evaluate not only how different usages of the heap snapshots impact taint analysis but also when should the heap snapshots be collected.
we analyzed every app in different configurations comprised of all sensible permutations of the analysis mode and the snapshot acquisition time c.f.
section .
.
for each analysis we used flowdroid or our extended version heapster with its default parameters.
we opted for the default configuration since it is the most widely accepted baseline and allows direct comparisons to previous work that is also based on flowdroid.
table presents the different experimental configurations including a traditional static analysis without any heap snapshot alongside the average and the accumulated number of snapshots over all analyzed apps.
snapshots snapshots mode heuristic full static none merged heapsall unique activity first last separate heaps7all unique activity static fallbackall unique activity first last table average and accumulated number of heap snapshots used per configuration runtime restriction.
since a single analysis run of some of the larger apps took multiple hours to complete we limit the runtime of the separate heaps approach to a maximum of two times the runtime of the pure static approach.
this prevents the separateheaps approach from taking multiple days to complete when several snapshots are used for those apps.
to still leave a chance for the separate heaps approach to complete on small apps that do not 7we omit first last for the separate heaps analysis mode because it is equivalent to use first last with merged heaps mode.
1065icse may seoul republic of korea m. benz e. kristensen l. luo n. borges jr. e. bodden and a. zeller take as much time we also allow it to run at least one additional hour to what the pure static approach needed.
.
droidmacrobench as one contribution of this work we provide droidmacrobench a benchmark of of the top most downloaded real world android applications with labeled taint flows.
similar to the popular droidbench micro benchmark also droidmacrobench provides android applications labeled with ground truth for taint analyses.
however in contrast to droidbench droidmacrobench comprises real world android applications which are in essence much larger more complex and altogether more realistic benchmarks for analysis at hand.
using droidbench for assessing heapster was not an option since its apps are not executable.
moreover even if they were the droidbench apps are too small and trivial to cause a realistic static over approximation which heapster aims to counter.
furthermore due to the missing complexity such small apps are not able to profit from the performance gains possible when using heap snapshots.
to establish droidmacrobench we manually investigated and labeled flowdroid s findings for of the apps as feasible infeasible taint flow.
investigating a large number of apps manually would be a worthwhile future endeavor but due to the significant amount of manual labor involved would probably have to be conducted as a community effort.
by exposing droidmacrobench we hope to seed such an effort.
we classify a taint flow as infeasible if during a manual investigation we find it impossible for data from a given source to flow to a given sink.
this manual investigation was done by having one author initially classify a taint flow as produced by flowdroid and this classification was then independently confirmed by another author.
in the remainder of this paper we consider reports of feasible flows as true positives other taint reports as false positives.
in our classification of flowdroid s findings we label the reported taint flows as feasible or infeasible but we make no determination as to what kind of data flows and whether this data is sensitive.
the high complexity of the code and in particular the frequently employed obfuscation made this determination impossible.
to evaluate droidmacrobench however this information is also not required.
droidmacrobench comprises real world android applications with a total of taint flows found by flowdroid of which we were able to classify into feasible and infeasible taint flows.
for the unclassified flows the taint flows are so complex that we were not able to classify them with the necessary certainty.
in the future we plan to provide droidmacrobench and the corresponding ground truth as a benchmark suite compliant to the reprodroid framework to allow others to reproduce our experiments easily but also to run their experiments on droidmacrobench.
.
rq1 how are the precision and soundness of flowdroid impacted by using heap snapshots as an upper bound for the static analysis?
to answer this question we used the apps from droidmacrobench and analyzed them with both separate heaps andmergedheaps approaches which consider the heap snapshots as upper bounds for the static analysis.
we used all the collected heap snapshots.
we then compared these results with those from the benchmark s ground truth.
since we use real commercial applications the total number of existing taint flows is unknown.
for our analysis we assume that the taint flows found by flowdroid represent all possible taint flows that can exist in the apps and we thus measure precision and recall relative to the findings of the purely static approach.
this assumption is sensible since we seek to determine exactly to what extend the incorporation of heap snapshots allows one to change flowdroid s original precision and recall curve.
our results are shown in table .
separate heaps approach.
theseparate heaps approach identified a total of taint flows of which are feasible resulting in a precision of .
compared to .
precision with the purely static analysis.
the separate heaps approach missed out of feasible taint flows found by the purely static analysis resulting in a recall of .
.
this high precision low recall trade off resulted in an f1 score of .
.
merged heaps approach.
the merged heaps approach identified taint flows of which are feasible.
that is by merging multiple heap snapshots into a single one the analysis was able to identify new taint flows of which is a true positive which were not identified by multiple single heap experiments.
overall compared to separate heaps merged heaps obtained marginally lower precision .
and higher recall .
resulting in an f1 score improvement of .
.
while these values are pretty similar the runtime performance of these approaches differ significantly as we show further in our experiments.
these results suggest that while restricting the points to information to what was observed dynamically leads to excellent precision but at the same time the overall trade off between precision and recall is rather drastic both approaches show an f1 score smaller than that of the purely static approach .
.
nevertheless given that developers tend to abandon tools with high false positive rates this high precision low recall trade off may be adequate under specific scenarios.
generally different analysis scenarios require different trade offs between precision and recall.
in our work we empirically explore which trade offs the use of heap dumps offer.
we leave to related work to judge in which scenarios which trade off is ideal.
using heap snapshots as an upper bound increases precision from .
to up to .
but sacrifices at least .
of recall.
the use of multiple heap snapshots has limited effect.
1066heaps n leaks how heap snapshots improve android taint analysis icse may seoul republic of korea full static classified as input true false total true tp fn false fp tn total precision .
recall .
accuracy .
f1 score .67separate heaps classified as input true false total true tp fn false fp tn total precision .
recall .
accuracy .
f1 score .37merged heaps classified as input true false total true tp fn false fp tn total precision .
recall .
accuracy .
f1 score .
table confusion matrix for static analysis and our merged heaps and separate heaps approaches using all collected heap snapshots as upper bound for analysis.
note for full static the recall is by definition as we measure recall relative to it.
those results also motivate the static fallback approach which we evaluate next.
.
rq2 how do precision and soundness change when using the static fallback approach?
by construction the static fallback approach from section .
should produce strictly larger sets of taint flows compared to the merged heaps approach and strictly smaller sets compared to the purely static one.
it is thus interesting to see how these additional missing flows impact precision and recall compared to the other approaches.
to answer this question we analyzed the apps from droidmacrobench with the static fallback approach and compared these results with the ground truth from droidmacrobench and the results from our previous experiments.
table shows the results of our experiments with the static fallback approach when all heap snapshots were used and merged together.
static fallback detects a total of taint flows in droidmacrobench of which are feasible.
compared to separate heaps and merged heaps this represents more taint flows detected with more feasible taint flows detected.
compared to the purely static approach the static fallback analysis identified of all known taint flows and of the feasible ones with a precision of .
and a recall of .
.
.
we conclude that due to the increased recall compared to the separate heaps and merged heaps approaches and the increased precision compared to the purely static approach static fallback yields a very favorable trade off between precision and recall with a f1 score of .
compared to the merged heaps s score of .
and to the purely static one of .
even only .
for separate heaps .
static fallback classified as input true false total true tp fn false fp tn total precision .
recall .
accuracy .
f1 score .
table confusion matrix for our static fallback approach when all collected heap snapshots are used for analysis.heap snapshots with static fallback offered the best trade off between precision .
and recall .
with the highest f1 score overall .
.
.
rq3 how often and when should heap snapshots be collected to gain a useful level of precision and soundness?
we discussed in section that using heap snapshots alongside static analysis is not a binary choice but opens up different design decisions.
in sections .
and .
we evaluated how the way heap snapshots are used impact the analysis results.
in this section our goal is to gather empirical evidence about the impact of how often and when heap snapshots are collected on the analysis findings.
to evaluate this research question we measured how many feasible infeasible taint flows were found with all possible heapster configurations.
the results of all experiments are shown in figure and summarized in table .
in figure each color represents a different app and the same color applies to the same app throughout the chart.
from figure it is possible to see that using heap snapshots always improves precision and worsens recall independently of how they are used.
nevertheless the choice of which heap snapshots are used does in fact affect the results.
using only the snapshot of the first action appears to restrict the taint analysis resulting in the lowest number of correctly detected taint flows in both merged heaps and static fallback .
the same behavior is also observed when using only the heap snapshot of the last action however with slightly better results and feasible flows detected.
note that it might seem counter intuitive at first that for staticfallback all the analysis reports fewer findings than for staticfallback unique activity.
after all the former uses more heap snapshots than the latter.
however while for the configurations mergedheaps and separate heaps it is in fact true that there the all option yields the highest recall by definition for static fallback this does not hold.
this is because when adding a further snapshot in static fallback this new snapshot might well add a heap object for an allocation site where none of the previous snapshots contained objects for that allocation site.
this then prevents the static fallback from falling back to the purely static analysis for this allocation site hence showing a tendency to increase precision but lower recall.
1067icse may seoul republic of korea m. benz e. kristensen l. luo n. borges jr. e. bodden and a. zeller nonetheless the recall generally benefited from using multiple snapshots.
for the static fallback approach when compared to a single snapshot using multiple heap snapshots improved the precision significantly by more than with the best results overall an f1 score of .
being achieved with unique activity where heapster takes a snapshot after each activity.
table shows that in many cases using all snapshots yields similar results to only using the last snapshot for each activity.
since pointer information is only lost on garbage collection and when a field is re assigned similar performance of those two heuristics shows that this does not happen often i.e.
there is not much additional pointer information when taking all snapshots instead of only the last for each activity.
from figure it is also possible to observe that the results vary depending on which app is analyzed.
when analyzed with the static fallback approach with first and lastheuristics the apps com.contextlogic.wish andcom.bitstrips.imoji exhibit the opposite trend as the one observed on the aggregated result with both the apps finding more feasible taint flows with the firstheuristic.
in conclusion the experiments suggest that two different snapshotcollection strategies should be used depending on what level of precision is desired.
if precision is critical a snapshot collected right as the app is started should be used as the only snapshot as this achieved precision with our merged heaps approach.
if precision is less critical a snapshot should be collected for each activity in the app.
this gives a good trade off with both high precision and recall and only requires an average of collected heap snapshots on our benchmark applications.
when and how often a heap snapshot is collected has an impact of up to .
on the precision and on the recall with the best overall results being achieved with a single snapshot per activity and the static fallback approach.
.
rq4 how does using heap snapshots impact the runtime performance and memory consumption of the taint analysis?
a major reason for developers to use less precise static analysis configurations is to improve scalability i.e.
to reduce the amount of time taken by the analysis and the amount of computational resources needed.
in this section we aim to measure how the use of heap snapshots impacts these factors.
analysis duration .figure depicts the relative speedups in analysis time for of our configurations across all apps with higher values representing faster analysis.
the green line shows the median speedup and the red line shows the average one.
the time reported includes all parts of the analysis including loading the heap snapshots into memory.
regarding the analysis duration the average analysis time for the purely static configuration was hour and minutes while theaverage running time for merged heaps last the fastest on average was only minutes.
separate heaps.
the separate heaps configurations were slower for most of our applications with the separate heaps all resulting in a slowdown factor of the largest among all.
the difference between the separate heaps all and separate heaps unique activity configurations is entirely explained by the larger numbers of snapshots the analysis has to run on in the separate heaps all configuration.
with the separate heaps approach the analysis timed out for of the 988experiments runs.
the apps where the analysis timed out overlap with the apps for which we witnessed out of memory errors which will be discussed later in this section .
however the analysis never timed out for any of the apps in droidmacrobench.
this result shows that even though heapster scales it does not scale to the point where it is feasible to run the analysis repeatedly with many different heap snapshots.
merged heaps.
in section .
the merged heaps and separateheaps approach had very similar precision and recall results when using multiple heap snapshots.
however as can be seen in figure while the separate heaps approach did not scale the merged heaps approach achieved by far the best performance with the average speedup from the separate heaps to the merged heaps approach improving from .
to .
and .
to .
for the all and uniqueactivity configurations respectively.
moreover the performance of the approach is better if a smaller collection of heap snapshots are used.
the best scaling configuration on average is using only the heap snapshot collected as the application has started up with an average speedup of .
and max of .
this is not surprising as the merged heaps approach should by construction be the most scalable of all our evaluated approaches.
the relatively worse performance of using multiple snapshots is also unsurprising as these configurations produce larger points to sets and take longer loading the heap snapshots from the file system.
some apps experienced a performance slowdown when using the merged heaps approach.
these are apps where the analysis itself took very little time down to about seconds and thus the overhead caused by loading the heap snapshots from the file system was significant.
static fallback.
the results for our static fallback approach reveal performance gains between and times on average with an analysis duration time between and minutes on average.
these improvements are not as high as those obtained by separate heaps and merged heaps due to the many cases in which the analysis ends up inspecting parts of the app with no heap snapshots information.
looking back at our f1 scores from section .
static fallback with both multiple heap snapshots heuristics had comparable and great precision results.
given that the static fallback unique activity approach also has better runtime performance our experiments indicate that it presents the best trade off.
memory consumption .figure depicts the average memory usage by the analysis of our configurations across all apps.
8separate heaps all and separate heaps unique activity across apps.
1068heaps n leaks how heap snapshots improve android taint analysis icse may seoul republic of korea tp fp tn fn precision recall f1 score mode heuristic full static none .
.
.
separate heapsunique activity .
.
.
all .
.
.
merged heapsfirst .
.
.
last .
.
.
unique activity .
.
.
all .
.
.
static fallbackfirst .
.
.
last .
.
.
unique activity .
.
.
all .
.
.
table aggregated true false positives negatives and relative recall precision f1 score per configuration.
out of the runs could not be completed due lack of sufficient memory even with the substantial 80gb heap space reserved for the jvm.
this error happened on different apps none of which are contained in droidmacrobench nor were used in the previous evaluations.
on average the entirely static analysis without any heap snapshot required the most substantial amount of memory .29gb.
the separate heaps and merged heaps approaches required the least amount of memory .2gb when using the only the last collected snapshot with the separate heaps approach requiring the lest overall amount of memory .13gb .
the static fallbackapproach required more memory than both separate heaps and merged heaps when using the same heuristic.
however it still required more than less memory then its entirely static counterpart.
considering the static fallbackapproach with the unique activity heuristic which achieved the highest f1 score in our previous evaluations it led to an average reduction of in memory consumption.
if running time scalability is a concern then merged heaps configurations should be chosen as it requires significantly less time and resources.
static fallback achieved the best trade off between precision recall and runtime performance reducing analysis time by and memory consumption by .
threats to validity we here describe four limitations that might threaten the validity of the results we have presented.
non deterministic taint flows.
during our experiments we noticed that flowdroid s results are non deterministic i.e.
two runs of flowdroid for the same app with the same configuration might produce different results.
we clarified with flowdroid s authors that this is a known bug in a post analysis component that reconstructs context sensitive path information for an identified taint flow.
it remains unfixed in the latest version and it is not planned to get fixed10.
the bug makes our ground truth slightly uncertain 9the separate heaps and merged heaps approaches are equivalent when using the first orlastsnapshot heuristics thus for the average memory consumption we them on both approaches.
10the authors are working on a complete overhaul of their taint propagation algorithm which will fix the problem.
there is however no release scheduled yet.due to the ground truth being build from flowdroid s findings.
however others using flowdroid for their experiments also fell victim to the same non determinism yet we are the first reporting it.
in our experiments this non determinism can lead to unintuitive findings.
in particular all our analysis configurations refine the static points to information which means that by construction we should always find a subset of the taint flows found by the full static configuration.
in our experiments however we sometimes encountered taint flows that are not found by the full static configuration.
for example in the com.soundcloud.android app respectively taint flows were not found with the full static configuration but were found when using the static fallback approach with the first and last snapshot respectively.
no other configuration had such taint flows for this app.
in the evaluation we limit the results to only consider those we had found as being feasible infeasible with the full static configuration.
of the total taint flows including unclassified ones found across experiment runs11were false positives not found by the full static configuration .
per run .
we compared the findings to some of the apps in droidmacrobench and found that the deviance comprises not more than a handful of findings per run and that the distribution of false to true positives among the deviating findings is random but corresponds to the overall distribution of false to true positives in all findings.
hence the overall findings remain valid.
app selection.
the chosen apps for building the ground truth might not be representative for all android applications.
the selection of apps for manual investigation was arbitrary among all the evaluated apps.
however the selection was not influenced by any a priori knowledge of taint flow feasibility since feasibility was only assessed thereafter.
user action order and code coverage might influence heap data.
our current experiments only measure how user interaction influences the heap data and therefore the analysis results in general section .
.
we do not meassure in which manner the order of user actions or the amount of covered code influences the heap data and the analysis results.
to study the correlation between user actionorder or coverage and analysis performance we have to design our experiment differently by exploring the apps aiming for these configurations using heap snapshots across benchmark applications results in runs.
1069icse may seoul republic of korea m. benz e. kristensen l. luo n. borges jr. e. bodden and a. zeller com.ucmobile.intl com.contextlogic.wish com.spotify.music com.fgol.hungrysharkevolution com.microsoft.office.outlook com.microsoft.skydrive com.soundcloud.android com.sgiggle.production com.uc.browser.en com.natenai.glowhockey com.forthblue.pool com.bitstrips.imojifull static infeasiblefeasible merged heaps first infeasiblefeasible merged heaps last infeasiblefeasible merged heaps unique activity infeasiblefeasible merged heaps all infeasiblefeasible separate heaps unique activity infeasiblefeasible separate heaps all infeasiblefeasible static fallback first infeasiblefeasible static fallback last infeasiblefeasible static fallback unique activity infeasiblefeasible static fallback all infeasiblefeasible figure a barchart showing how many feasible infeasible taint flows were found with each configuration.
the individual apps are represented using different colors.
merged heaps all merged heaps unique activitymerged heaps first merged heaps last separate heaps all separate heaps unique activitystatic fallback all static fallback unique activitystatic fallback first static fallback last0.
.
.
.0speedup figure execution time speedup compared to full staticfull static merge d heaps first merge d heaps last merged heaps unique activity merged heaps all separate heaps unique activity separate heaps all static fallback first static fallback last static fallback unique activity static fallback all44.
.
.
.
.
.
.
.
.
.
figure average memory gb for each experiment configuration metrics.
obviously there is also a tradeoff adding two additional dimensions to the experiments leads to many more experiment permutations and the payoff may be unclear.
nonetheless this is an interesting research question that could be addressed in the future.
feasible labeled flows might not be realizable during runtime.
we only checked data flow of the found taint paths for feasibility assessment.
we were not able to make a confident assessment of control flow feasibility.
hence it is possible that some of the flows labeled as feasible cannot be realized in any dynamic execution.
in such cases the recall given for the heap snapshot approaches might actually be higher than reported.
related work taint analysis has been primarily used on android applications to discover security and privacy issues.
according to li et al.
s literature review approaches using static taint analysis focus on detecting private data leaks in android apps.
these approaches achieved good precision by regarding multiple analysis sensitivities from context flow field object and path sensitivity when applied to artificial benchmarks .
however very few of them evaluated real world applications due to the lack of ground truth.
studies have shown that static tools are most likely to be adopted by developers when they yield a low rate of false positives .
thus it is essential to know how good these tools perform when applied to real world applications.
in our paper we evaluated both a static flowdroid and our hybrid approach heapster with top android applications from the google play store.
our results show in comparison to flowdroid that using heap snapshots always improves the precision in all configurations we tried.
the measured f1 scores also suggest that our mixed mode static fallback configuration can achieve a better trade off between precision and recall than other configurations that extend or restrict points to computations in all cases see table .
in the area of dynamic analysis for android applications taintdroid is one of the most prominent tools.
however taintdroid was implemented as an extension to the android platform i.e.
taint tracking within the dalvik vm interpreter rather than a standalone tool which makes it hard to maintain for every new version of android i.e.
the last supported version was android .
in .
our tool instead is built on top of flowdroid which is well maintained since its first appearance.
we were able to apply our tool to the top most downloaded android applications targeted to the recent 1070heaps n leaks how heap snapshots improve android taint analysis icse may seoul republic of korea android versions e.g.
com.spotify.music was targeted for android .
and com.contextlogic.wish was for android .
.
hybrid approaches that combine static and dynamic analysis seem to become more promising in recent researches .
dufour et al.
were probably the first to propose blended analyses and to coin this term in which static analyses incorporate dynamic information information to optimize precision and or recall .
the authors present a concrete example of a blended escape analysis.
our work is inspired by the blended hybrid approach of grech et al.
in which they used heap snapshots to reduce the cost of modeling the heap in static analysis and achieved excellent scalability precision and recall according to their evaluation using the dacapo java benchmark suite .
in their approach the heap snapshots were taken on jvm exit for each application .
to maintain more information e.g.
the actual linking between objects and