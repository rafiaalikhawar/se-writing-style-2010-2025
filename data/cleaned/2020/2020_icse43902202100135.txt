codeshovel constructing method level source code histories felix grund department of computer science university of british columbia vancouver canada fgrund cs.ubc.cashaiful chowdhury department of computer science university of british columbia vancouver canada shaifulc cs.ubc.canick c. bradley department of computer science university of british columbia vancouver canada ncbrad cs.ubc.ca braxton hall department of computer science university of british columbia vancouver canada braxtonh cs.ubc.careid holmes department of computer science university of british columbia vancouver canada rtholmes cs.ubc.ca abstract source code histories are commonly used by developers and researchers to reason about how software evolves.
through a survey with professional software developers we learned that developers face significant mismatches between the output provided by developers existing tools for examining source code histories and what they need to successfully complete their historical analysis tasks.
to address these shortcomings we propose codeshovel a tool for uncovering method histories that quickly produces complete and accurate change histories for methods including of all method changes outperforming leading tools from both research e.g finergit and practice e.g.
intellij gitlog .
codeshovel helps developers to navigate the entire history of source code methods so they can better understand how the method evolved.
a field study on industrial code bases with industrial developers confirmed our empirical findings of codeshovel s correctness low runtime overheads and additionally showed that the approach can be useful for a wide range of industrial development tasks.
i. introduction historical data embedded within version control systems contains a wealth of information that is useful to both developers and researchers.
source code histories are used by developers to understand how a particular unit of source code evolved to provide context for code reviews to share information among collocated teams and for identifying experts .
researchers use source code histories to understand developers work habits and to predict the likelihood and location of source code changes and defects .
version control systems vcs store a project s source code history by tracking developers line level changes to files.
unfortunately these systems do not provide a complete understanding of the source code s evolution primarily due to the frequent moving and renaming of files across the file system and groups of lines being moved between files.
typically both researchers and developers are interested in accessing only a subset of a project s history which is not well supported by vcs .
to address these information needs tool support that is robust to the commondevelopment transformations and is able to generate accurate source code histories is needed.
studies have focused on improving the accuracy and usability of source code history construction e.g.
this is often referred as history slicing .
these studies mainly differ in the granularity of the generated history.
for example in functional level granularity one can extract all the relevant commits that are connected to a specific software feature .
similarly the history can be generated only for a given file of interest .
there are also scenarios when the research and the developer community desire lower level source code history .
consequently several studies aimed for line level history unfortunately these suffered from high false positive and false negative rates due to many code lines can be similar just by chance .
these observations support the need for method level source code histories to balance between being too coarse e.g.
file level and too fine e.g.
line level granularity.
unfortunately only a few approaches specialize in building method level histories .
previous history construction approaches including the recent finergit require preprocessing the entire project history before making any queries.
this up front cost hinders a tool s usability .
historical tracing tools that are commonly used in practice do not require pre processing these include intellij s git history feature and gitlog l which generate code history on demand.
unfortunately these tools are not resilient to common code transformations present during software development and produce inaccurate method history section v .
we surveyed industrial engineers and academic developers to gain further insight into method level source code histories to learn what questions they are trying to answer with these data and what shortcomings they experience with existing approaches.
ultimately these participants indicated that they wanted up to date results without lengthly preprocessing.
they also reported that inaccuracies introduced by ieee acm 43rd international conference on software engineering icse .
ieee source code transformations inhibit existing tools causing the tools to frequently return incomplete histories.
to address the shortcomings we propose codeshovel a tool for surfacing complete histories of source code methods.
codeshovel builds method histories on demand as desired by a developer or researcher thus requires no pre processing or whole program analyses.
the similarity algorithm used by the approach surfaces all changes to a source code method along with a categorization of how the method was changed.
the codeshovel similarity algorithm is robust in the face of common filesystem and source code transformations that occur during software development.
we evaluated codeshovel s accuracy and runtime performance using a manually constructed oracle from popular open source project repositories and compared its accuracy to both the state of the art finergit and sate of the practice tools intellij and gitlog l .
we also conducted an industrial field study to verify that codeshovel also generates accurate histories for industrial systems.
in both cases codeshovel correctly determined the complete history of of the evaluated methods with a median runtime of seconds.
the primary contributions of this paper include a survey with professional developers demonstrating a lack of tool support for the most frequently performed historical understanding tasks.
the open source implementation of codeshovel a novel approach for extracting method level source code histories which can be used interactively through a developer facing web service or a research oriented command line client.
a quantitative analysis of codeshovel s accuracy and runtime performance using popular open source projects.
we also verified codeshovel s accuracy and runtime with industrial developers.
a manually derived history oracle for methods required hours of manual work to facilitate future research on source code history construction algorithms.
ii.
background related work source code histories have long been recognized as a key information source for program understanding and for capturing change rationale e.g.
.
several approaches have been proposed to help developers and researchers better leverage source code histories.
we examined these approaches according to three requirements important to both industrial developers and researchers speed granularity and robustness table i provides an overview of many of these.
analysis burden.
many approaches require a complete project to be analyzed before any queries can be issued.
these offlineanalyses can usually be queried e fficiently once a history is created but can require hours of preprocessing before they can return results.
while it is possible to compute results incrementally many tools do not support this these tools are best geared towards mining style analyses rather than answering developer queries.
for example historage and finergit an improvement over historage preprocess arepository to place each method in its own file they then use git s history mechanism to track changes on each individual method s corresponding file .
sunghun et al.
proposed a function matching algorithm for the clanguage.
the algorithm considers metrics including the number of incoming calls fan in which require preprocessing the complete repository.
this is also true for beagle apfel and c rex .
unfortunately preprocessing the entire repository for each change can cause high feedback latency discouraging developers in adopting a particular tool .
recently li et al.
proposed cslicer for extracting source code history this approach requires existing test sets for conducting dynamic analysis.
tools commonly used in practice like git log l and intellij do not require any up front analysis making them more practical for answering developer queries on demand without any prior configuration or analysis.
granularity.
the granularity at which a history can be generated can be a key factor for the utility of a given tool .
method level granularity is widely accepted in di fferent areas such as bug localization and software energy estimation .
our survey with professional developers reveals that method level granularity is also desired for source code history generation.
the importance of extracting previous method level changes for predicting future change patterns has been mentioned in the research community .
different approaches provide histories at di fferent granularities.
cslicer extracts a minimal changeset that completely isolates a feature.
such changeset may contain information from multiple files.
by default version control systems operate on lines within files but provide incomplete history because of file movements and renaming.
daniela et al.
address this problem using an incremental origin analysis approach.
by focusing on the text itself these approaches are languageagnostic but are unable to answer interesting queries like find all changes to this class .
tools which support queries on code elements rather than lines support various levels of queries for instance to classes e.g.
beagle methods e.g.
method log1 or blocks e.g.
apfel .
granularities also vary in terms of time while most tools in table i try to find complete histories pry git2 and beagle only analyze changes between two specific versions of a program or file and do not try to uncover the complete history.
this is also true for recent approaches like cldi ff and gumtree .
transformations.
the one constant in software is change .
this makes histories important but many changes can be challenging to track.
changes can range from simple singleline code edits to complex refactorings that involve renaming methods and moving them to new files.
refactoring is described as the bread and butter of software restructuring and refactorings happen remarkably frequently during development.
for example of the changes to apis are refactorings and of the method introductions in the postgresql source code were caused by refactorings .
log .com pry pry git 1511table i selectionoftoolsforexaminingsourcecodehistories .
thesevaryin whethertheyare on demandorrequirepre processingawholeproject the granularitythatcanbeanalyzed codemeansasubsetofclass method or statement andtheirtolerancetocommonsourcecodetransformations mreferstomethod f referstofiles referstopartialorweaksupport andm movedenotespull upmethod andpush downmethod .
code transformations approach on demand?
granularity intra file inter file apfel no code beagle no code historage no code m rename f rename c rex no code m rename pry git yes code method log yes code git log l yes text intellij yes text f rename finergit no codem rename m signaturef rename m mo ve codeshovel yes codem rename m signaturef rename m mo ve approachs like method log designed for ruby methods can detect transformations within a file intra file changes as long as enough textual similarity is maintained through the transformation.
some code based analyses are able to further categorize the changes historage and c rex can identify method rename refactorings.
while dedicated refactoring detection tools exist e.g.
most history tracking tools cannot track inter file transformations except for historage finergit and intellij which are robust in file rename events but often cannot track other inter file transformations e.g.
extract method refactoring .
unfortunately such refactorings are prevalent in practice .
iii.
industrial survey many of the existing approaches we identified in the literature section ii were geared at the research community and did not fully consider the needs of industry developers.
prior work by codoban et al.
found that developerfacing history tools e.g.
gitlog are not ideal developers complained about information overload and wanted more structured and selective information.
to verify these findings and to gain additional insight into how and why developers use software histories we conducted a survey with participants.
we examined the following two research questions rq1 do developers use source code histories and if so at what granularity?
rq2 what mechanisms do developers use for generating histories and what shortcomings do they have?
survey design.
the survey was administered online and consisted of likert scale and free response questions along with two code oriented scenarios.
each survey took minutes to complete.
the complete survey and anonymized responses are available.
survey participants.
we recruited professional developers from industry and from academia total participants .
were contacted via email from the authors professional networks individuals were solicited giving a final response rate of .
the majority of job titles were software developer engineer or similar all academic participants were upper level graduate students or faculty.
across all participants had more than years of programming experience and had used source code history for four years or more.
for the professional developers had been employed in industry for four years or more.
a. rq1 do developers use histories?
survey questions how recently did you last use source code history of any kind?
what were you looking for?
in terms of source code granularity how interested are you in gathering information on source code history at the following levels?
when you use code history how far in the past do you usually examine?
the majority of the survey participants frequently use source code history had used code history within two days prior to performing the survey within a week .
participants use source code history for a variety of activities including version control e.g.
to check what i modified to check change accountability e.g.
to determine who had been contributing who could contact for dev support and who is associated with change and for program understanding e.g.
to understand how the solution to a certain problem was implemented and how and why a property was changed .
around of participants responded positively to usingmethod function granularities and class granularity responded positively about file granularity while responded positively about using histories at block granularity.
this suggests developers are interested in examining histories at source code granularities other than just the file or textual range block level as is supported by most tools.
in terms of duration while a few participants only used recent commits most expressed that they would go back as far as necessary even years to find the changes they were looking for.
for example one participant mentioned that sometimes i need to trace back the lifespan of a class until it was created which might get tricky if it was renamed .
according to another participant it ll be great to have the complete history available all the time.
rq1 summary developers frequently use source code histories.
they aremost interested in method level and class level followed by file level granularities and often traverse the full history of the element they are investigating.
b. rq2 how do developers generate histories?
we asked participants to review a pull request from the checkstyle project that involved reasoning about a method in a file that had changed times over three years.
1512survey questions is this pull request scenario familiar to you?
how would you identify the commits in which the method of interest has changed?
how well do existing tools support identifying these changes?
how hard would it be to find the first commit for the given method?
how useful would it be to have support for a more semantic history in this scenario?
of the participants are either very familiar orfamiliar with the pull request scenario where they need to inspect code history.
developers generally extract code history with their preferred tools either using the tooling within the ide or in the shell .
participants mentioned several tools that they used to do this with gitlog and intellij s history feature among the most popular.
of the participants however responded that the existing tools do not support these tasks well while responded neutrally.
overall participants stated that it is hard orvery hard to find the commit that actually introduced a method i.e.
to extract the method s complete history .
in particular participants believe their approaches are suited not very well ornot well at all to deal with complex structural changes such as method move.
the majority of the participants stated that it would bevery helpful orhelpful to have a tool that is robust to structural changes and can generate complete and accurate method level history.
these results align well with the prior study by codoban et al.
that showed that developers need enhanced support for eliciting source code histories.
rq2 summary existing tools are inadequate for extracting history at themost desired levels of granularity.
when faced with these tasks developers most commonly use on demand tools likegitlog and intellij.
iv .
codeshovel surfacing method histories motivated by the drawbacks of previous approaches section ii and feedback from the developer survey section iii we now describe codeshovel a tool for quickly constructing accurate source code histories.
codeshovel has been explicitly designed to robustly identify and track changes in the face of common code transformations.
it generates histories at the granularity of individual methods class level histories can be constructed by aggregating all method level histories in a class.
to ensure codeshovel results are always up to date and to minimize unnecessary overhead histories are computed on demand with no pre processing.
to allow developers to explore the full history of a method codeshovel searches backwards through time to identify all relevant commits until it finds the method s introducing commit.
codeshovel can be used as a command line tool and as a web service.4its source code including scripts that can install build and run codeshovel with a single command is available.
4web service https se.cs.ubc.ca codeshovel 5source code data and executables https github.com ataraxie codeshovelfigure provides a high level illustration of codeshovel s heuristic approach.
to build a history codeshovel starts with the most recent commit for a method and iteratively steps back through past commits in the version control repository to find other commits that also modified the method.
this process continues until the introducing commit is found.
this entails two main tasks first all of the commits that modified the method need to be found among the commits in the repository figure left rectangle .
second the changes to the method need to be analyzed to determine how the method was changed this information can help developers find specific changes of interest figure right rectangle .
inputs.
the inputs codeshovel requires are readily available to the developer a repository identifier e.g.
a git clone url the path of the file containing the method the method name and the line number6of the method declaration.
the starting commit sha for building the history can be provided buthead is used by default.
outputs.
to provide presentation flexibility codeshovel emits a json object containing a list of commits that modified the specified method and relevant metadata.
the web service and command line clients render the json output object to increase usability.
a. method matching at the core of codeshovel s method finding procedure is a similarity algorithm for matching methods across file versions.
our selection of the matching algorithm is driven by two factors first the algorithm must be on demand we can not use complex method features e.g.
whole program call graph that require processing a complete repository making the algorithm non performant.
second developers want the full method history.
this is also true for the msr community who are interested in source code origin analysis .
as we show later some methods have years long history and may have been modified more than times.
to locate a method even in one single commit we sometimes need to parse many other files because the method moved and compare with all the methods in those files which negatively impacts the runtime.
these observations discouraged us from using complex strategies like ast matching techniques .
our matching algorithm relies on techniques from clone detection e.g.
.
textual similarity is an efficient strategy for clone detection but lacks accuracy in many cases .
one approach for mitigating this problem without significantly sacrificing runtime efficiency is to compare di fferent source code metrics .
therefore codeshovel measures similarity between two methods by comparing their body similarity and signature similarity it also considers the name of the type containing the method and its line number when needed.
when calculating text based similarities e.g.
body and signature codeshovel uses the jaro winkler distance algorithm .
as we show 6the line number is only used to di fferentiate overloaded methods that have the same name but might appear at di fferent file locations.
1513later this simple algorithm achieves high accuracy in both open and closed source projects with e fficient runtime performance.
when invoked for the first time codeshovel locates the specified method by cloning the repository checking out the appropriate sha and reading the method text from the provided file path and line number.
codeshovel uses a languagespecific parser to generate an ast of all the methods in the files it analyzes while for most commits this is just one file when a method has been moved it can include parsing all files modified in a given commit.
the ast enables quick and systematic identification of all methods their signatures and bodies for the matching algorithm.
for a given commit codeshovel stores the current file path path line number num method signature sig and method body body for the specified method.
to build the history for the method codeshovel then considers the preceding commit that modified the path containing the method.
codeshovel includes all the branches that contributed to the method s current state.
since codeshovel works backwards through time from the most recent commit to the oldest commit it is generally trying to determine where the method came from while it searches for the commit that introduced the method into the repository.
using a greedy approach codeshovel tries to identify the method using a four phase heuristic the description of these phases is presented below and the pseudo code for the heuristic can be found in figure .
codeshovel uses several thresholds when comparing program elements these thresholds were derived using the data driven approach described in section v. phase method unchanged.
modifications to the file containing the method do not necessarily imply that the specified method was changed.
to check for this codeshovel first looks for a method with textually identical sigandbody within the path.
if there exists such a method this means that relative to the preceding commit this commit changed some other part of the file but not the method itself.
therefore this change is not added to the method s history.
codeshovel then iterates using the version control system to find the preceding commit that modified path and executes again from the beginning.
for efficiency codeshovel s algorithm only considers commits that modify the file containing the method.
phase method modified within current file.
if an identical method is not found in path in phase codeshovel then considers all other methods within the file to check for instances where the method was modified.
it does this by examining all of the method bodies within path.
if a method is found with at least a similar body the inputs are updated for subsequent searches e.g.
to reflect any changes to the sig body ornum and the commit is added to the method s history for the next iteration.
phase method moved through file rename or move.
if no match is found in the first two phases which only examine path codeshovel widens its search to consider all other files that were modified in the commit.
the files modified in this commit are important because codeshovel knows that by not matching previously either the method was moved fromanalyze changesfind method method unchanged.
method modified within file.parse file find preceeding sha detect moves method move file move categorize changes signature change body changenono no retur n annotated change stack.
sig path num sha add change to stack yes yesstart yes method extracted from file.nop1 p2 p3 p4file rename or move.p3yesfor each change in the change stack fig.
.
high level approach each query starts with a method name and sha.
codesho vel iterates backwards through history until it finds the introducing commit for that method.
another file e.g.
because the file changed paths or the file was renamed or the method was introduced.
to check for this codeshovel examines the signature asts for all other files modified in the commit.
in this phase codeshovel accounts for path rename refactorings e.g.
the filename is the same but the overall path has changed .
it does this by searching all files for a method that has the same sigand a body that is at least similar.
if such a method is found the inputs are updated and the change is added to the method s history for the next iteration.
phase method extracted from di fferent file.
finally codeshovel considers the most challenging form of transformation method extractions.
in an ideal situation an extract method refactoring will just move a method from one file to another.
in reality the methods are often changed along the way e.g.
their signatures are modified and their body may be changed .
codeshovel ranks all methods within all files modified by a change by their body similarity.
the mostsimilar method is matched if either a method is similar and is characters of code or is similar and is characters of code.
this size based discrimination is needed to decrease the chances of erroneously matching short methods.
if a match is made the inputs are updated for subsequent searches and the commit is added to the method s history for the next iteration.
preparing method history.
if no candidate is matched in the final phase the last change added to the method s history is considered the method s introducing commit.
at the end of this process the history contains only a list of the changes inputs sig method signature body method body text path path to file method is in files list of all files changed in the commit phase find unchanged method within same file 9foreachmethin files 10ifsim meth sig .
11sim meth body .
12returnno change phase find modified method within same file 16foreachmethin files 17ifsim meth body .
18returnmeth method found in file phase find method within renamed or moved file 22foreach file in files 23foreachmethin file 24ifsim meth sig .
25sim meth body .
26returnmeth method found in moved file phase find method modified from different file 30methods all methods in all files sort methods by decreasing body similarity 32methods sort methods sim entry body find highest matching method 35foreachmethin methods 36ifisshort meth characters 37ifsim meth body .
38returnmeth 39else 40ifsim meth body .
41returnmeth no match last commit was introducing commit 44returnnull fig.
.
codeshovel method matching algorithm meth refers to method sim refers to the previously described similarity matching approach.
thresholds are explained in section v. to the method each consisting of angbracketleftpath sig sha num angbracketright.
to increase the utility of this history we further analyze each change to analyze how the method changed before returning the history to the developer.
it is important to note that with codeshovel s approach multiple methods can share the same ancestor method history but one method cannot have more than one ancestor method s history.
therefore if several smaller ancestor methods are merged to form a larger method the new method s history will only contain the best matching ancestor method s history.
this was a choice we made because tracking multiple anchestors histories would negatively impact codeshovel s runtime.
b. change analysis once the list of changes for a method have been identified the change analysis phase examines each change to determine how the method was modified.
each commit in the codeshovel output is associated with one or more specific change nochange methodchange introduced multichange signaturechange rename modifierchange paramchange returnchange bodychange crossfilechange methodmove filemove1.. exceptionchange fig.
.
hierarchy of change kinds in codeshovel.
change kinds.
this categorization of changes presented in figure is a simplified version of the change taxonomy described by fluri et.
al.
.
at the top most level there are four primary change kinds.
the goal of codeshovel s analysis is to find the complete change history back to the method s introductory commit this is captured by the introduced change kind.
most changes in practice are methodchange which captures the primary modifications that methods undergo.
the multichange kind is used to maintain an unordered list of other change kind instances so the developer can examine these compound changes.
the nochange is a special kind that indicates methods that did not change in an identifiable way e.g.
when a commit modified some other part of the method s containing file .
method changes can occur in several di fferent ways.
the most common of these by far is the bodychange which occurs whenever the text of the method body changes.
the signaturechange kind occurs when the method is renamed rename or its parameters paramchange return type returnchange modifiers modifierchange or thrown exceptions exceptionchange are altered.
finally some method changes arise from crossfilechange filemove occurs due to common filesystem transformations like file rename or path changes.
more complex changes that move methods between files methodmove include extract method push down and pull up refactorings.
the significance of the methodmove change kind especially in combination with the rename change kind has been previously identified .
consequently we consider a proper identification of this change kind to be an important goal for building comprehensive method histories.
c. implementation we implemented codeshovel in java.
while codeshovel is language aware the core approach is language independent given the required ast parsers.
all core components with language specific functionality use abstract classes and interfaces with concrete language specific implementations.
to add support for a new language two codeshovel interfaces parser andmethod need to be implemented.
for example parser defines a method signature findmethodbynameandline name line which finds amethod instance within a 1515file given its name and start line and is relatively easy to implement.
our java implementation of these two interfaces has loc and is the only language specific code required to support a new language.
to perform git operations and to traverse commits in repositories codeshovel leverages the jgit library andjavaparser to generate asts.
we have also started to implement support for python using antlr javascript usingnashorn and ruby using jruby but have not extensively evaluated codeshovel on these languages.
approach summary codeshovel leverages di fferent source code metrics e.g.
body similarity signature similarity and line similarity to decide if two given methods are similar.
if these similarities exceed our data informed thresholds then two methods are considered the same.
this process continues until the first introduction commit is found for a given method.
each change commit is also associated with a change kind e.g.
bodychange which makes codeshovel s output helpful for program comprehension.
v .
empirical evaluation from our literature review and the developer survey we identified two important requirements for method history extraction tools first they need to be able to extract complete histories and second they need to run on demand without requiring pre processing.
these requirements necessitate that codeshovel be robust to transformations and quickly perform online analyses of the version control repository.
to assess how effectively codeshovel meets these requirements we examine the following research questions rq3 how accurate and robust is codeshovel for producing complete and correct method histories?
rq4 what is codeshovel s runtime performance and is it acceptable for on demand use?
a. methodology this section describes how we constructed an oracle of method histories and how we tuned codeshovel s matching algorithm to evaluate the correctness of the histories codeshovel produced.
we chose to develop an oracle to allow us to compute both recall the proportion of complete histories an approach can detect as well as the precision the proportion of histories that do not contain incorrect results we believe recall to be most important metric for history tracking as this measures how likely a developer will be able to find the complete history of a method of interest.
subjects.
for our evaluation we chose popular open source java projects each with at least commits methods and stars on github.
these projects span a range of domains and we consider them a representative set of mid to large scale open source java projects.
table ii lists the projects and their statistics.
oracle construction.
to verify the correctness of the histories produced by codeshovel we manually constructed antable ii javarepositoriesusedforourempiricalevaluation .
repository commits methods starstrainingcheckstyle commons lang flink hibernate orm javaparser jgit junit4 junit5 okhttp spring framework 769validationcommons io elasticsearch hadoop hibernate search intellij community jetty lucene solr mockito pmd spring boot total oracle of method histories.
to do this we randomly selected 10methods having at least commits from each project in table ii for a total of methods.
this was laborious manual work and required minutes per method.
method histories were extracted by multiple authors and one nonauthor using a combination of tools e.g.
git log and manual inspection.
it was then independently validated by two experienced developers for completeness and correctness.
full details about oracle construction are available online.
training phase.
as described in section iv codeshovel uses a heuristic approach to match methods across changes.
we initially set codeshovel s thresholds using our intuition.
for example we set a high body similarity threshold to reduce false positives.
we then used methods from the oracle as our training set.
we modified the algorithm e.g.
adding a special condition for short methods and updated the threshold values until we achieved training accuracy.
in order to alleviate regression issues while we tuned the thresholds we created a separate test method for each training method which compares the expected method history with the codeshovel s generated history.
validation phase.
during the validation phase codeshovel s thresholds were fixed at the values previously shown in figure and could no longer be changed.
when computing accuracy we compare the histories generated by codeshovel using these threshold values with the remaining validation methods that were not used for training.
b. results this section describes codeshovel s accuracy and runtime performance in accordance with rq3 and rq4.
rq3 codeshovel s recall and precision to evaluate codeshovel we examined precision and recall recall by different change types and recall compared to intellij andgitlog l and finergit.
completeness and correctness.
we compared the histories produced by codeshovel with the histories of the validation methods in our validation phase.
codeshovel correctly identified the exact histories for of the methods that is the tool had recall for this oracle.
encouragingly codeshovel could still be useful for the methods for which it failed to uncover the complete history.
for one method codeshovel found the complete history including the introducing commit but unfortunately continued tracking another prior method due to its similarity.
this is the only false postive result e.g the returned history was not part of the method s history resulting in precision for this oracle.
codeshovel was only able to return partial histories for the other missed methods.
for example for one of the validation methods codeshovel successfully extracted the first commits out of the that actually occurred .
the methods in the validation set underwent changes in total and codeshovel correctly identified of these.
when does codeshovel fail?
figure shows a diff from one of the ten incomplete methods.
from a developer s perspective the method was modified to take an instance of invocation instead of creating it in the method body which can be seen by the changes to the parameters the exception signature and the removal of the single line in the body.
the method was also renamed in the same commit.
collectively these changes caused codeshovel to fail to report that the second method represented a transformation of the first.
it remains an interesting challenge to us to solve these kind of scenarios without significantly a ffecting codeshovel s runtime performance.
characteristics of the validation set.
two reasonable questions are whether codeshovel s recall was high because the validation set contained only methods with similar size characteristics or methods that have short change histories.
in the validation set of the methods have sloc while have sloc .
in terms of changes of the methods were changed more than times and of the methods were changed at least times.
with respect to change complexity most commits changed by fewer than lines but there are some commits that changed by almost lines.
fig.
.
a diffshowing a complex method transformation that codeshovel failed to recognize.ultimately the difference in distributions when compared in pairs between all of the methods in the validation set and the methods codeshovel correctly identified from that set are statistically insignificant nonparametric wilcoxon mannwhitney test p value .
.
this suggests that the validation set contained a diverse set of methods and codeshovel s high accuracy was not influenced by a particular group e.g.
methods with short change history .
robustness across di fferent transformation types.
many kinds of source code transformations happen during development ranging from simple body changes to a complex refactorings such as a pulling up pushing down or extracting methods.
our initial survey participants acknowledged the difficulty of tracking methods that have undergone complex refactorings.
existing approaches section ii have di fficulty constructing histories for methods that have undergone these transformations making it important to evaluate codeshovel s robustness across these complex transformations.
for a given method our validation set contains all the commits and change types in which the method changed.
to calculate the accuracy of each change type we counted instances where change type produced by codeshovel did not match the change type in the oracle.
for example the validation set contained a total of commits with the type bodychange .
the change types of of the commits produced by codeshovel were di fferent resulting in a .
accuracy forbodychange .
table iii provides the accuracies of each change type.
the lowest accuracy of codeshovel is .
caused by failures for the rename change type.
we conclude that codeshovel can robustly construct method histories regardless of the types of changes a method undergoes.
table iii codeshovel saccuracyacrossdifferenttypesofsourcecode transformations .
codeshoveldoesnotexhibitweaknesseson anyparticulartypeofchange .
change type occurrence accuracy failures bodychange .
filerename .
introduced .
parameterchange .
movefromfile .
rename .
modifierchange .
returntypechange .
parametermetachange .
exceptionschange .
multichange .
codeshovel accuracy relative to prior work among all the tools discussed in section ii only four work for java methods intellij s git history feature gitlog l historage and finergit.
finergit is an improvement over historage and it is the state of the art tool for java method history tracking despite its problem with large projects that we discuss later.
intellij and gitlog l were frequently mentioned in the developers answers and discussions from our survey intellij was mentioned times and gitlog was 1517mentioned times.
we thus compare codeshovel with intellij gitlog l and finergit.
it was extremely laborious and time consuming to manually run and check all the validation methods against these tools to evaluate their accuracy unlike codeshovel there is no test suite that can automatically run and evaluate them.
this validation took one of the authors hours to complete.
codeshovel compared to gitlog l intellij.
there are two modes for using gitlog l one works with line range gitlog lstart end filename and the other directly works with a given method name gitlog l funcname filename we evaluate each of these modes.
in contrast to the recall of codeshovel intellij was able to identify the complete history for of the validation methods.
gitlog l identifies the complete history for of the complete histories using the start end filename mode and of complete histories using the funcname filename mode.
to examine recall on particularly challenging tasks we also investigated complex methods from our validation set to compare the accuracy of these two tools with codeshovel.
these methods have undergone di fferent types of transformations throughout their lifetime.
for selecting such complicated methods we counted the total number of unique transformation kinds for each method.
for example the count is 3for a method that had bodychange 2rename and introduced commits in its history.
we then ordered the methods based on those counts and selected the top of them.
for this set codeshovel identifies the complete method history with accuracy.
intellij achieves accuracy .gitlog l achieves accuracy using thestart end filename mode and accuracy with the funcname filename mode.
combining the best results from bothgitlog and intellij the accuracy is which is lower than codeshovel alone.
this shows that codeshovel significantly outperforms the state of the practice tools used by practitioners today.
codeshovel compared to finergit.
when comparing codeshovel to finergit we encountered a problem as finergit ran out of memory with gb of ram for the finergit process or did not finish pre processing within minutes for the four largest projects in the validation data set intellij community elasticsearch lucene solr hadoop .
for the methods in the validation set from the smaller six projects finergit identified the complete history for of the methods.
in contrast codeshovel identified the complete history for of these same methods.
this demonstrates that codeshovel has higher recall than the state of the art without the memory and computation downside associated with pre processing.
.java diff java must be in the.gitattributes file.rq3 summary codeshovel s recall exceeds both related industrial and research tools.
for our method oracle it uncovered the complete method history for of methods in terms of changes to those methods it found of method changes.
rq4 codeshovel s runtime performance to evaluate codeshovel s runtime performance we recorded the wall clock time for each of the methods from the validation repositories total of methods .
we collected the runtimes on a development computer core processor running at .30ghz with 32gb memory .
codeshovel has a median runtime under seconds of the methods returned in less than seconds while the worst case runtime was seconds.
we were also interested to see codeshovel s runtime performance across di fferent repositories.
we calculated the median for graph readability of all the methods runtimes for each validation repository.
figure shows the distribution of the medians.
the intellij community repository is the outlier with a median execution time of about seconds which is due to a combination of large source files which take longer to parse and a high frequency of change within these files.
repository median runtime seconds fig.
.
the median wall clock time it took codeshovel to process all methods ineach validation repository circle listed in table ii.
we believe that codeshovel s latency is acceptable with a median runtime of seconds per method.
a previous study by kochhar et al.
found that developers are very satisfied with software analysis tools having feedback latency less than one minute .
rq4 summary although codeshovel computes method histories on demand it is can uncover the entire history of most methods in less than two seconds.
vi.
industrial fieldstudy to ensure codeshovel s accuracy and the runtime performance translates to industrial closed source systems we performed an industrial field study.
industrial participants independently verified the accuracy and completeness of generated histories on methods they selected from their own projects.
we also captured codeshovel s runtimes for the participantselected methods.
as a follow up to the industrial survey section iii we also asked participants how they would apply 1518codeshovel in their industrial setting.
for this purpose we aim toadditionally answer one research question rq5 in which scenarios are method level histories useful to industrial developers and why?
a. study participants we conducted our field study with industrial engineers.
the majority of the participants did not participate in the survey described in section iii.
participating developers were required to have java background and had to be able to provide a set of java methods whose histories they were familiar with.
they had a median of years of programming experience .
years working as professional software developers and .
years experience with version control.
each participant was given a co ffee gift card for their time.
b. study design we conducted the field study as on site interview sessions lasting minutes per participant.
each participant was asked to choose java methods from their own repositories that they were familiar with and that had been revised multiple times.
we executed codeshovel using the participant selected methods on their computer and recorded the results and runtime.
each participant then evaluated the correctness of the results for their selected methods.
we asked participants three questions was the method history correct?
which scenarios might codeshovel be useful for?
is the information produced by codeshovel helpful?
c. study results we summarize the results of the field study by the associated research questions rq3 rq4 and rq5.
rq3 codeshovel s correctness the industrial participants produced method histories during the field study.
codeshovel found the correct and complete histories for of the methods .
for the four methods for which codeshovel failed two had commits containing multiple complicated changes causing the overall similarity to be below the matching threshold.
for one method codeshovel stopped while parsing a file 9and for one we could not reproduce the problem.
otherwise participants confirmed that codeshovel performed well and identified the relevant commits without any false positives.
rq4 codeshovel s runtime performance the median wall clock runtime was less than seconds for the methods chosen by our industrial participants on their projects showing that codeshovel s on demand algorithm is fast enough for interactive use on industrial codebases.
there was an outlier method which had changed times in an extremely large file.
codeshovel took seconds to find the full history of that method.
medappscodeshovel s accuracy is similar for open source and closed source projects.
its runtime performance is also similar on industrial codebases.
9this was related to the javaparser which we subsequently fixed.
scenarios for method level histories rq5 participants described several scenarios in which codeshovel would be useful.
codeshovel allows developers to determine a method s provenance because they can see easily who introduced a method p3 .
it can help answer this code came to be p8 .
it can aid in traceability especially through refactorings other tools like intellij and git log don t help us here p9 .
developers can focus on moves and other refactoring operations that would not be traceable with conventional git history p5 .
participants thought that the histories are very helpful for onboarding git blame isn t useful because formatting commits destroy everything p14 or if you re new to a codebase p10 .
participants also thought it would be useful forcode understanding because one can learn more about the codebase in an easy way p7 for code you re not used to p10 .
codeshovel automates history related tasks because developers already do what this tool is we just do it manually p8 .
overall participants rated the method histories as very helpful or somewhat helpful while the remaining were neutral.
rq5 summary industrial engineers appreciated being able to use codesho vel to quickly check method provenance to aid traceability understanding and onboarding despite the refactorings these methods often undergo.
vii.
discussion here we discuss future codeshovel improvements and present some research questions that should be investigated.
a. improving codeshovel codeshovel leverages manually constructed histories to tune its thresholds for deciding if two methods are similar.
machine learning is an alternative for such a data driven approach.
however the difficulty in building the oracle limited the size of our training and validation sets.
with this relatively small oracle there is evidence that a heuristic approach could be more accurate than a machine learning approach .
our heuristic approach also explains why it considers two methods similar or di fferent which is often not easy with machine learning and is important for software tools as practitioners are less confident in predictions based on unexplainable models .
one aveneue to investigate would be to examine the few situations where where other tools e.g.
finergit generated correct method histories but codeshovel failed to do so to try to discover if there is a weakness in the algorithm that could be improved.
codeshovel currently uses the jaro winkler distance algorithm for string similarity ratings although for source code n gram string matching may be a better alternative .
presently codeshovel can be run from a web service and from the command line interface integration with an ide e.g.
intellij would be useful.
we are currently extending codeshovel with support for python and typescript.
1519b.
impact on the msr research community we believe that codeshovel can help extend msr research.
for example for the entire corpus of methods in table ii while of methods were never changed after they were inntroduced were changed three times or more and were changed ten times or more.
why do some methods change so frequently and what impact do they have on software maintenance?
can we discover information from these methods for writing more stable code?
can codeshovel build accurate history of test methods as well so we can study the evolution of test methods alongside source methods?
codeshovel is currently being used for three di fferent software evolution studies by two different research groups.
c. threats to validity internal validity.
the primary threat to the internal validity is related to the construction of our oracle.
this threat was mitigated by two experienced developers who validated the oracle independently.
another threat is related to our sampling method the methods selected to be used in our oracle were randomly chosen from all methods having more than three commits.
this was meant to focus the evaluation on more interesting and challenging histories but we may have missed certain classes of histories by using random sampling.
in both the survey and the field study there may be moderator bias since participants were selected from the authors personal networks.
an additional placebo could have been used but we were concerned this would reduce the participant pool .
external validity.
although we evaluated codeshovel on both open source and closed source industrial codebases the number of methods was small so our findings may not generalize.
in our survey and field study our recruited participants may not be representative of all developers.
viii.
conclusion in this paper we described a formative survey with developers from both industry and academia to learn how they use source code history and what challenges they face when so.
we learned that existing tools do not e ffectively surface the results developers need to answer their source code history questions.
to address this we built codeshovel a tool that is robust to common source code transformations and can generate accurate method level source code histories on demand.
empirical analysis with open source and closedsource projects shows that codeshovel can return complete and accurate histories for of methods and of all method changes.
this outperforms finergit the current stateof the art and both intellij and gitlog the current state ofthe practice.
an industrial field study further confirmed that codeshovel would be useful for a wide range of industrial development tasks such as traceability and program understanding.
having access to robust source code histories is also useful for extending research in mining software repositories and software evolution for example enabling studying the structural properties of methods that make a method more or less prone to future changes.
it is our hope that both developers and the research community will find codeshovel useful for providing a richer understanding of how their systems have evolved in the face of the kinds of source code transformations that frequently occur in practice.
ix.