difuzer uncovering suspicious hidden sensitive operations inandroid appsjordan samhi1 li li2 tegawend f. bissyand 1 jacques klein11snt university of luxembourg luxembourg f irstname.lastname uni.lu2monash university australia f irstname.lastname monash.eduabstractone prominent tactic used to keep malicious behavior from beingdetected during dynamic test campaigns islogic bombs where ma licious operations are triggered only when speci f ic conditions aresatis f ied.
defusing logic bombs remains an unsolved problem inthe literature.
in this work we propose to investigate suspicioushidden sensitive operations shsos as a step towards triaginglogic bombs.
to that end we develop a novel hybrid approach thatcombines static analysis and anomaly detection techniques to un cover shsos which we predict as likely implementations of logicbombs.
concretely d u.sc e.sc r.scidenti f ies shso entry points using aninstrumentation engine and an inter procedural data ow analysis.then it extracts trigger speci f ic features to characterize shsos andleverages one class svm to implement an unsupervised learningmodel for detecting abnormal triggers.we evaluate our prototype and show that it yields a precisionof .
to detect shsos among which .
are logic bombs.d u.sc e.sc r.scoutperforms the state of the art in revealing more logicbombs while yielding less false positives in about one order ofmagnitude less time.
all our artifacts are released to the community.acm reference format jordan samhi1 l il i2 tegawend f. bissyand 1 jacques klein1.
.
di fuzer uncovering suspicious hidden sensitive operations in android apps.
in44th international conference on software engineering icse may21 pittsburgh pa usa.acm new york ny usa pages.
introductionsecurity and privacy in android have become paramount given itspervasive use in a wide range of user devices be it handheld athome or in the o ce .
yet regularly new threats are discovered even in the o cial google play app store .
typically thousandsof apps are regularly agged by antivirus engines for the year 2020alone the a n.sc r.sc z repository has collected over228 000apps among which over10 000apps are agged by at least f iveantivirus engines hosted by virustotal.
addressing the spread ofmalware in app markets is therefore a prime concern for researchersand practitioners.
in the last decade several approaches have beenproposed in the literature to automate malware identi f ication.
theseapproaches explore static analysis techniques this work is licensed under a creative commons attribution international .
license.icse may pittsburgh pa usa copyright held by the owner author s .acm isbn .
execution or a combination of both as well as the use of machine learning .while the aforementioned techniques have been provene ectiveon benchmarks attacks evolve rapidly with increasingly sophisti cated evasion techniques.
typically malware writers rely on codeobfuscation to bypass static analyses.
to evade detection dur ing dynamic analysis attackers seek to hide malicious code behindtriggering conditions.
these are known aslogic bombs the trigger ing conditions of which being varied.
for example a logic bombcould execute malicious instructions only at a speci f ic time thatis not likely to be reached when market maintainers dynamicallyanalyze the software before it is distributed.logic bombs can be used for any malicious activity such asadware trojan ransomware spyware etc.
.furthermore as the trigger and the malicious code are generallyindependent of the core application code logic bombs can easilybe added in legitimate apps and repackaged for distribution .
therefore detecting logic bombs is of great importance especially in mobile devices that carry much personal information.however due to the undecidable nature of this detection problemin general and the fact that dynamic analyses will likely failto detect such behaviors analysts explore static analysis basedheuristic or machine learning approaches to detect logic bombs.a logic bomb is characterized by the fact that it implementsa hidden sensitive operation.
therefore recent works addressinglogic bombs have focused on the identi f ication of hidden sensitiveoperations hsos as a target .
however not all hsos are logicbombs.
indeed an hso may be neitherintentionalnormalicious while logic bombs always are.
in this work we propose to identifysuspicious hsos shso towards triaging logic bombs amonghsos.
indeed we consider that an shso is an hso that is likelyimplementing a logic bomb.
further note that in this study we donot attempt to address a binary classi f ication problem of discrimi nating malware from benign apps e.g.
by using logic bombs as akey criteria of maliciousness .
instead our ambition is to improvethe detection of logic bombs which are considered sweet spotsfor targeting the understanding of malware s malicious behaviors.indeed while the literature proposes a variety of approaches forpredicting android apps maliciousness i.e.
malware detection the community still seeks to make signi f icant breakthroughs inthe location of malicious code parts.
detecting logic bombs thusprovides an opportunity to locate and characterize malicious codeimplemented as hidden sensitive operations.recent literature on android has already approached the prob lem of detecting sensitive behavior triggered only when certainconditions are met.
such triggers are referred hereafter assensitivetriggers.t r.sc .. e.sc r.scs e.sc was proposed as a static analysis tool todetect logic bombs its analyses are based on heuristics and are thus7232022 ieee acm 44th international conference on software engineering icse icse may pi t tsburgh pa usajordan samhi1 li li2 tegawend f. bissyand 1 jacques klein1limited to certain trigger types i.e.
time related location related and sms related triggers .
t r.sc .. e.sc r.scs e.scfurther relies on symbolicexecution which reduces its capacity to scale to massive datasets.unlike t r.sc .. e.sc r.scs e.sc h1 m n.sc e.sc r.sc leverages a supervised learn ing approach with engineered features to reveal sensitive triggers.h1 m n.sc e.sc r.sc however does not speci f ically target malicious triggers it ags up to20 of apps which makes it ine cient for isolatingdangerous triggers in the wild it also takes on average13min app which makes it challenging to exploit for large scale experiments.hso triggering conditions are typically implemented byif state ments.
a given app code however may contain from hundredsto thousands of such conditional statements.
therefore a majorchallenge in the research around hso is to reduce the search spacefor accurately spotting suspicious sensitive triggers.
our core ideatowards achieving this ambition is to model speci f ic trigger charac teristics to spot shsos.in this work we propose a novel approach to identify suspicioushidden sensitive operations where we rely on an unsupervisedlearning technique to perform anomaly detection.
we intend todetect suspicious triggers deviating from the normality of the myr iads of conditional checks performed in typical apps.
to do so weexplore speci f ic trigger behavior features to guide our detectionsystem towards enumerating truly suspicious triggers and thusre f ine the search space for uncovering logic bombs.
we proposed u.sc e.sc r.sc a novel hybrid approach that combines code instrumen tation to insert particular statements required for taint analysis inter procedural static taint analysis to f ind suspicious sensi tive triggers and anomaly detectionto revealsuspicious hiddensensitive operationsin android apps.while the literature includes work that proposed supervisedlearning techniques for detecting hsos d u.sc e.sc r.screlies on unsu pervised learning to spot abnormal triggers.
moreover towardsensuring that the model is accurate in the detection of suspicioushsos d u.sc e.sc r.scleverages features that are speci f ically engineeredto capture semantic properties of maliciousness.the main contributions of our work are as follows we propose d u.sc e.sc r.sc a novel approach to detect shsos in an droid apps.
d u.sc e.sc r.sccombines code instrumentation static inter procedural taint tracking and anomaly detection techniques.
we evaluate d u.sc e.sc r.scand show its ability to reveal shsos witha99.
precision in less than seconds on average per app outperforming previous approaches.
we demonstrate that the trigger and behavior speci f ic featuresof d u.sc e.sc r.scare relevant for triaging logic bombs among hsos .
of detected shsos are indeed con f irmed as logic bombs.
we compare d u.sc e.sc r.scagainst a state of the art logic bomb de tector t r.sc .. e.sc r.scs e.sc d u.sc e.sc r.screveals more logic bombs thant r.sc .. e.sc r.scs e.scwhile yielding less false positives.
we further applied d u.sc e.sc r.scon a dataset of benign apps fromgoogle play.
by analysing the yielded shsos d u.sc e.sc r.sccon tributed to suspect adware apps which google removed fromgoogle play after we have pointed them out.
we release the d u.sc e.sc r.scprototype in open source and furthermake available to the research community the f irst android logicbomb dataset called d232b background and definitionsin this section we f irst introducetaint analysisandanomaly de tection two techniques used in our approach.
then we carefullyde f ine important concepts and f inally succinctly give the contextfor our study.taint analysis taint analysis is a data ow analysis that followsthe ow of speci f ic values within a program.
a variable u1d449is taintedwhen it gets a value from speci f ic functions calledsources.
the taintis propagated to other variables if they receive a derivation of thevalue in u1d449.
if a tainted variable is used as a parameter of speci f icfunctions calledsinks it means that during execution the valuederived from asourcecan be used as a parameter of asink.
in thispaper s context we rely on taint analysis to check if the conditionalexpression involves sensitive data value s .anomaly detection when analyzing data of the same class several items can signi f icantly di er from the majority.
they arecalledoutliersand can be viewed as abnormal.
there are numeroustechniques in the state of the art for achieving this outlier detectionin sets of data .
this paper relies onone class support vectormachine oc svm an unsupervised learning algorithm thatlearns common behavior based on features extracted in an initialdataset.
once the model is learned a prediction is performed bychecking whether a new sample features make it more or less abnor mal w.r.t.
the common model.
in this paper s context an anomalyis computed by considering distances among vectors representingtriggers i.e.
a condition along with the behavior triggered.de f initions we de f ine terms that will be used and referred tothroughout the paper.
figure visually depicts our de f initions.
a triggerde f initions1 b hidden sensitive operationde f inition4 c logic bombde f inition6if u1d70b u1d450 uni03a3 uni0393 u1d447 u1d450 uni03a6 u1d450 u1d70f u1d447 u1d450 uni03a6 u1d450if u1d70b u1d702 u1d446 u1d447 u1d450 u1d446 uni03a6 u1d450sensitivebehaviorif u1d70b u1d706 u1d440 u1d446maliciousbehaviorfigure de f initions illustrations.
the graphs represent thecontrol flow graph of the same function.de f inition trigger .
a trigger is a piece of code that activatesoperations under certain conditions.
in figure 1a the trigger u1d70f dashed rectangle is represented by the condition u1d450 rounded rec tangle node the true branch u1d447 u1d450and the false branch uni03a6 u1d450.
the truebranch u1d447 u1d450represents all the statements nodes for which each pathfrom the entry point must go through u1d450and are executed if andonly if u1d70bis true.
note that every path from the entry point to thehatched node must go through u1d450.
in other words u1d450strictly domi nates the hatched node.
however the hatched node can be executedif u1d70bis true or false.
therefore it is not part of u1d447 u1d450nor uni03a6 u1d450.
the falsebranch uni03a6 u1d450represents all the statements for which each path fromthe entry point must go through u1d450and are executed if and only if u1d70bis false.724difuzer uncovering suspicious hidden sensitive operations in android appsicse may pi t tsburgh pa usamore formally let uni03a3be the set of statements of a function nodesin fig.
.
let u1d450 uni03a3be a conditional statement i.e.
an if statement rectangle nodes in fig.
.
let u1d70bbe u1d450 s predicate.
let u1d700be the condi tional execution function such as u1d700 u1d70b u1d70e is true if u1d70e uni03a3is executedif and only if u1d70bis true.
let be the dominator function such as u1d451 u1d70e is true if u1d451 uni03a3strictly dominates u1d70e uni03a3 false otherwise.let u1d447 u1d450and uni03a6 u1d450be thetrueand thefalsebranch1of u1d450such as u1d447 u1d450 u1d70e u1d70e uni03a3 u1d450 u1d70e u1d700 u1d70b u1d70e uni03a6 u1d450 u1d70e u1d70e uni03a3 u1d450 u1d70e u1d700 u1d70b u1d70e then a trigger u1d70fis de f ined as a triplet u1d70f u1d450 u1d447 u1d450 uni03a6 u1d450 .de f inition guarded code .
let u1d70fbe a trigger such as u1d70f u1d450 u1d447 u1d450 uni03a6 u1d450 .then the code guarded by u1d450is uni0393 u1d447 u1d450 uni03a6 u1d450.de f inition trigger entry point .
we de f ine a trigger entry pointas the condition triggering the guarded code.
more formally givena trigger u1d70f u1d450 u1d447 u1d450 uni03a6 u1d450 u1d450is de f ined as its entry point.de f inition hidden sensitive operation hso .
an hso is apiece of code that represents a set of instructions which im plement a security sensitive operation and are only executedwhen speci f ic criteria are met cf.
figure 1b .
more formally let u1d702 u1d450 u1d447 u1d450 uni03a6 u1d450 be a trigger and u1d446a piece of sensitive behavior suchas u1d446 uni03a3.
then u1d702is a hidden sensitive operation if u1d446 u1d447 u1d450 u1d446 uni03a6 u1d450.de f inition suspicious hidden sensitive operation shso .
anshso refers to an hso that implements a sensitive operation thatappears to be suspicious given the context of the app.
for example anavigation app may legitimately retrieve user location information which is a sensitive operation while a calculator is suspicious ifit attempts to retrieve such sensitive data.de f inition logic bomb .
a logic bomb is a piece of maliciouscode triggered under speci f ic circumstances.
more formally let u1d706 u1d450 u1d447 u1d450 uni03a6 u1d450 be an shso u1d446its sensitive behavior and u1d440a pieceof malicious code such as u1d440 uni03a3.
then u1d706is a logic bomb if u1d440 u1d446 cf.
figure 1c .
in other words a logic bomb is an shso whichsuspicious sensitive behaviour is malicious.
example simplified for reading with renamed methods2public staticvoidm 3m1 4performmaliciousactivity 6public staticvoidm1 7if m2 8system.exit 11public staticbooleanm2 12string str1 build.model 13string str2 encryptedstring str2 quotedbl.varemulator quotedbl.var14returnstr1.contains str2 16public staticstringencryptedstring 17string s1 quotedbl.varcb6624dec24f889f4fcdf6c8cda99d4a quotedbl.var 18returnbydecoder.decode s1 quotedbl.var0ec47edd8db3a02b quotedbl.var listing logic bomb identi f ied by d f.sc u.sc z.sc e.sc r.scin com.
yingbees.brasiltvenvivo with emulator evasion.in listing we summarize the general behavior of a concreteexample of a logic bomb extracted from a real world app.
this logicbomb was detected by d u.sc e.sc r.sc.
in this example the di erent partsof the shso including the triggering condition checks are splitacross several methods .
.
.
.
the actual triggering conditioncheck is done in line .
will returntrueif the device runs in1note that in case there is no false branch uni03a6 u1d450 .an emulator and the app execution will be halted.
otherwise themalicious behavior line will be triggered.the challenge in detecting the aforementioned logic bomb isthat analysts cannot rely on rules or models to detect it due tothe lack of a formal de f inition of malicious behavior.
therefore we note that with little coding e ort malware authors could pushmalicious code that will be missed in most dynamic analyses.
indeed sandboxes and testing environments usually return default valuesfor environment variables .
besides the device s model di erentenvironment values e.g.
sensors settings gps remote values etc.
can be used to trigger malicious code.comparing to previous works we note that the presented simpleexample of logic bomb detected by d u.sc e.sc r.scwould constitutea challenge to the existing state of the art.
t r.sc .. e.sc r.scs e.sc cannot identify this logic bomb.
indeed since its heuristics arelimited to time location and sms related triggers logic bombswith a new trigger e.g.
environment variable such asbuildclass f ields are missed.
h1 m n.sc e.sc r.sc could detect this logicbomb if its training set includes similar examples.
unfortunately h1 m n.sc e.sc r.sc ags too many hsos e.g.
of apps making themanual check a cumbersome task.
in contrast d u.sc e.sc r.sco ers areasonable number of warnings to be checked manually.
approachgoal with d u.sc e.sc r.sc we do not aim at detecting any hsos butonly suspicious hsos shsos for which the likelihood of beinglogic bombs is high.intuition as shown in previous studies the number of hsosper app can be large even in benign apps.
this suggests that al though hsos are sensitive operations most of them are legitimate i.e.
they are used to implement common behavior.
in contrast logicbombs are rare especially in benign apps.
the idea behind d u.sc e.sc r.scis to use an anomaly detection approach with speci f ically designedfeatures to triage logic bombs among shsos.overview in figure we present an overview of our approach which consists of two main modules identi f ication of shsoentry point candidates via control ow analysis instrumentation and taint tracking left dotted block from these entry points triggers are extracted and the second module right dotted block extracts speci f ically designed features fed into an outliers predictor.this predictor is previously trained on a set of reference apps i.e.
apps considered benign to learn legitimate usages of triggers.
.
identifying shso candidate entry pointsprevious works have shown that speci f ic values such as system inputs and environments variables are often usedto trigger hsos.
state of the art approaches have thus proposedto check whether the conditions ofif statementscontain thesesensitive data.
to that end they rely on symbolic execution or backward data dependency graphs that could su er fromscalability problems.
with d u.sc e.sc r.sc we propose to use taint analysisto track sensitive data values and check if they are involved inconditional expressions.725icse may pi t tsburgh pa usajordan samhi1 li li2 tegawend f. bissyand 1 jacques klein1 control flowanalysis instrumen tationtainttracking triggersextractionfeaturesextractionpredictionof outliers trainingphasefeaturesextraction sourcessinkssourcessystematicstudy icfglibrariesfeaturevectorsmodelfeaturevectorstriggerentry points shsoentry points detection candidatesanomalydetectionsuspicioushidden sensitive operationspotentiallogic bombswhitelistsofmethodsreferencesettriggerstriggers figure overview of the d f.sc u.sc z.sc e.sc r.scapproach.taint analysis tools generally track data from sources to sinks.the implementation of f6 7d r.sc a popular taint analysis frame work for tracking sensitive information considers sources and sinksat the method level.
in our case however sinks are f ine grainedcode locations which are conditional expressions ofif statements.this requires for d u.sc e.sc r.scto instrument apps in order to insertdummy method calls that will make the apps ready for analysis byf6 7d r.sc cf.
section .
.
.
moreover sources can be methodcalls or data f ield accesses.
to build the set of source and sinks wepropose to make a systematic mapping cf.
section .
.
that ex plores internal and external system properties and their associatedapis as well as environment variables.
.
.
systematic mapping toward defining sources.as already ex plained a f irst step is to track sensitive values.
in this work thesevalues are derived from particular source methods.
then if a sensi tive value falls into anif statement we consider the condition asa potential shso entry point.
this section will describe how wegathered a comprehensive list of source methods used for the tainttracking phase.
note that we did not rely on the reference sourceslist produced by s u.scs since it has been shown that most of themethods are inappropriate for tracking sensitive data and lead to ahigh amount of false positives e.g.
.in general decisions on whether to trigger shsos or not aretaken on system properties .
hence we performed asystematic mapping of the android framework from sdk version 3to versions and were unavailable to gather a comprehensivelist of source methods.
in particular since in the case of androidapps system properties can be derived from the device sinternalandexternalproperties we inspect the successive versions of theframework to identify various means to access these properties.deviceinternalexternalsystemcontentbuildsiminternetgpsexamplessensors calllogs model phone call parameters latitude cameracontactshardwaresmscontentlongitudetable examples of sensitive sourcesin table we enumerate the di erent property types with ex amples on which we reasoned to retrieve sensitive sources whichare classically focused on in the literature .
we fol low a systematic process to perform the retrieval of sources fromthe given property types we f irst extracted patterns from the dif ferent ways to access the aforementioned properties.
then weused those patterns to automatically discover the sensitive sourcesthat we make available to the research community in the d u.sc e.sc r.scproject s repository.
in the following we further detail the internaland external properties that we consider.internal in the case of internal properties a developer can getsensitive information of the device from three main channels system properties content in internal databases and informa tion frombuildclass see table .
in the following we describehow we obtain a list of sources for those three channels system properties while developing an android app developershave access to several useful apis.
in this case the most interestingisandroid.content.context.getsystemservice java.lang.
string which returns the system level handler for a givenservice.
the service is described by a string given as parameter togetsystemservicemethod.
thecontextclass gives developersaccess to pre de f ined constants e.g.
sensor service .in fact every constant contains the name of the service with quotedbl.var service quotedbl.varappended to it.
the return value type of thegetsystem servicemethod call is derived from the constant name e.g.
sensor servicewill give asensormanager which in turn can be usedto get a object whose type is also derived from the constant name e.g.
a sensormanager object can be used to obtain a sensor ob ject .
we used this pattern to compile our list of sensitivesources for the system properties.
more speci f ically we verify ifthe class exists in at least one sdk version for each class obtained.if this is the case we list the methods of the class and keep only the getter methods i.e.
those starting by get or is e.g.
methodssuch asgetid oriswifienabled .
content in internal databases to access databases f ields one hasto perform a query which returns aandroid.database.cursor object.
this object is then used to iterate over the result of the query.hence to get sensitive source methods related to content in internaldatabases we applied the same process as for system properties i.e.
to retrieve the getter methods but on thecursorclass.
buildclass thebuildclass allows developers to accessinformation about the current build of the device from its f ields.for instance one can get the brand associated with the device byaccessingbuild.brand.
note that our objective is to retrieve a listof source methods.
however the information a developer can getfrom thebuildclass can only be retrieved from class f ields notmethod calls.
consequently in section .
.
we will explain howwe instrument the app under analysis to add method call statementsrepresentingbuild f ield accesses.we gathered a list of unique methods for internal values.726difuzer uncovering suspicious hidden sensitive operations in android appsicse may pi t tsburgh pa usaexternal in the case of external properties a developer can getsensitive information from three channels sim card internetconnection and gps chip.
the process to collect the sourcemethods is similar to the one followed withcursorclass exceptwe do not know in advance the name of the classes to inspect.therefore we relied on a heuristic to identify such classes for eachsdk version we listed all the classes and kept only those with classnames containing the following words sms telephony location gps internet and http .
once the classes were retrieved we listedthe methods for each class and kept those starting by get or is .the intuition is the same as in the case of internal sources.we gathered a list of unique methods for external values.finally after combining sensitive sources from internal and externalvalues our list contains unique methods duplicates .
.
.
instrumentation.performing taint tracking as brie y de scribed in section consists of a data ow algorithm that propa gates the taint from a source method to a sink method.sinks related challenge we remind that one objective of d u.sc e.sc r.scis to identify shsos trigger entry points.
consequently the taints that d u.sc e.sc r.sctracks are supposed to fall intoif state ments.h o w e v e r b e i n gnot a method call anif statementcannot beconsidered as a sink when using state of the art static taint analyz ers .
a concrete example of what d u.sc e.sc r.sctracks is givenin listing .
on line countrycodevariable is tainted fromgetnet workcountryiso source.
this value is then used line to performa test and trigger malicious activity line .
as anif statementisnot considered a sink a ow cannot be found.1publicvoidmethod 2string b build.brand b buildclass.getbrand dummy method call for field access4string p context.telephony service 5object o this.getsystemservice p 6telephonymanager tm telephonymanager o 7string countrycode tm.getnetworkcountryiso ifclass.ifmethod countrycode quotedbl.varru quotedbl.var dummy method call for if statement9if countrycode.equals quotedbl.varru quotedbl.var performmaliciousactivity listing example of app instrumentation performed by d f.sc u.sc z.sc e.sc r.sc lines with represent added lines .our approach overcomes this limitation by instrumenting apps.to accomplish this the app code is f irst transformed into jimple the internal representation of soot .
then d u.sc e.sc r.sciterates overevery condition of the app and for each condition d u.sc e.sc r.scinsertsa dummy methodifmethodwith the variables involved in thecondition as parameters.
thisifmethod is static and declared ina dummy classifclassthat contains all instrumented methodsrelated to conditions.
see line in listing .once the instrumentation is over we dynamically register everynewly generated method calls as sinks to f6 7d r.sc .sources related challenge as described in section .
.
we con sider in this study buildclass f ields as sources.
since f ield ac cesses are not method calls we follow the same process as forifstatementsto insert dummy methods.
more speci f ically d u.sc e.sc r.scgenerates a static method call on the y representing a f ield accessfrom thebuildclass.
listing depicts an example of this instru mentation process where the dummy methodgetbrand of thedummy classbuildclassis inserted in line .
furthermore newlygenerated method calls are registered as sources for taint tracking.
.
anomaly detectionthis section presents d u.sc e.sc r.sc s second module which relies onanomaly detection.
in particular we detail the unsupervised ma chine learning technique used to detect abnormal triggers.
.
.
why a one class svm?.a classical classi f ication problem re quires samples from positive and negative classes to build a model which is then used to assign labels to test instances .
this in duces possessing a reasonable amount of samples from two classes which is not the case in our study.
indeed the shso detectionproblem is challenging and to the best of our knowledge there isno ground truth made publicly available.
thus using supervisedlearning in our study is not practical and present limited feasibility.therefore we decided to rely on an unsupervised learning tech nique to detect shsos particularly on a one class support vectormachine oc svm machine learning technique.
an svm algorithmwas chosen due to its ability to generalize and its resistanceto over f itting .
the general idea of oc svm is to identify thesmallest hyper sphere to include most of the samples of the positivesamples .
a sample considered as an outlier by the model meansthe data point is not in the hyper sphere.
.
.
features extraction.as already said the second d u.sc e.sc r.scmodule s objective is to detect abnormal triggers with the intuitionthat these triggers are hsos for which the likelihood to be a logicbomb is high namely shsos.
this module implements an oc svmalgorithm which takes as input feature vectors computed from thetriggers previously extracted from the entry points yielded by the f irst module of d u.sc e.sc r.sc cf.
figure .to engineer anomaly detection features we reviewed surveys and related papers discussing android malwareand investigated the techniques used by malware writers to hidemalicious code within apps.
eventually we identi f ied nine uniquetrigger behavior features that are described in the following.in the remainder of this section we consider a trigger u1d70f u1d450 u1d447 u1d450 uni03a6 u1d450 and its guarded code uni0393 u1d447 u1d450 uni03a6 u1d450 cf.
section .d u.sc e.sc r.scbuilds a feature vector u1d463 u1d446 u1d441 u1d437 u1d445 u1d435 u1d443 u1d4401 u1d4461 u1d43d for a given trigger where s number of sensitive methods used in guarded code.in tuitively this feature represents how much a trigger controls theexecution of sensitive methods.
indeed while hsos guard the execu tion of sensitive operations for performing sensitive activities benign triggers in the general case perform benign activities i.e.
invoke few sensitive methods or not at all.
to retrieve this value d u.sc e.sc r.sciterates over every statement of uni0393and recursively checkswhether a sensitive method is called or not.
for this purpose wegathered a list of sensitive apis constructed in previous work .n is native code used in guarded code?since analyzing nativecode is more challenging than java bytecode android malwaredevelopers tend to hide malicious code from automated analysesin native code .
hence this feature is a boolean value that when set to means native code is used in uni0393 otherwise.d is dynamic loading used in guarded code?dynamic classloading is not exclusively used in malware.
however as malware isbecoming increasingly sophisticated they use built in capabilitieslike dynamic loading to hide from automated analyses .
conse quently likewise native code this feature is a boolean value set to1 if dynamic loading is used in uni0393 otherwise.727icse may pi t tsburgh pa usajordan samhi1 li li2 tegawend f. bissyand 1 jacques klein1r is re ection used in guarded code?android malware writerstend to use more and more re ection based code since most ofthe state of the art techniques overlook this property due to thechallenging task of resolving it.
therefore this feature is set to ifre ection is used in uni0393 otherwise.b does guarded code trigger background tasks?android appsrely on the service component to run background tasks.
hence with this feature we aim at capturing the fact that the app underanalysis performs stealthy operations without user knowledge.
theintuition here is that shsos role is to hide code both from securityanalysts and end users e.g.
in the case of a logic bomb .
this featureis set to if background services are triggered in uni0393 otherwise.p are parameters of condition used in guarded code?thisfeature captures the dependency of a condition to its guarded code.the hypothesis is that in the case of shsos the guarded code doesnot use values used in the condition since they represent di erentbehaviors.
to achieve this d u.sc e.sc r.scperforms a def use analysisof the guarded code to verify if any variable used in the conditionis used before being assigned a new value.
if this is the case thefeature is set to otherwise.m1 number of app methods called only in guarded code.with this attribute we attempt to uncover the number of methodsde f ined in the app called only in the guarded code of a trigger.
therationale is that app methods that are only used under a speci f iccircumstance are likely to be de f ined only for this speci f ic circum stance representing hidden behavior .
to retrieve this number d u.sc e.sc r.scqueries the call graph built using spark algorithm for each method call in the guarded code to verify if it has only oneincoming edge i.e.
it is only called within the current method .s1 number of sensitive methods called only in guarded code.in the same way as m1 we aim to capture the number of sensitivemethods only used in the guarded code of a given trigger.j behavior difference between branches.intuitively two bran ches of an shso should be noticeably di erent.
indeed of thetwo branches one is considered the normal behavior no or fewsensitive operations if the condition is not satis f ied and the otheras the sensitive behavior sensitive operations if the conditionis satis f ied .
therefore to compute this di erence d u.sc e.sc r.sc f irst inter procedurally retrieves sensitive method calls in bothbranches of a given trigger.
let u1d44b u1d447 u1d450and u1d44b uni03a6 u1d450respectively be the setsof sensitive methods in the true and the false branch of a trigger.therefore to compute this di erence of the two branches d u.sc e.sc r.screlies on the jaccard distance u1d437 u1d457 u1d44b u1d447 u1d450 u1d44b uni03a6 u1d450 u1d44b u1d447 u1d450 u1d44b uni03a6 u1d450 u1d44b u1d447 u1d450 u1d44b uni03a6 u1d450 whichcharacterizes the behavior di erence of the two branches.
a valueclose to means that both branches are dissimilar.
.
.
training phase.to train our oc svm model we need sam ples of a positive set i.e.
triggers considered normal.
therefore we randomly chose10 000goodware i.e.
virustoal score from a n.sc r.sc z .
then for each of these apps we appliedd u.sc e.sc r.scto extract a feature vector for each app s condition.afterward we randomly chose10 000feature vectors2fromthose yielded by d u.sc e.sc r.sc which we labeled as positive i.e.
part ofthe normal behavior .
we then trained our one class classi f ication2the number of extracted vectors is orders of magnitude higher.
however for e ciency we validated that a random set of10 000vectors yields an acceptable performance.based anomaly detector leveraging libsvm .
to ensure thatthe selected training set does not bias the trained model s perfor mance we split it and compute accuracy in fold cross validation.overall we achieve a stable accuracy of .
on average.
evaluationto evaluate d u.sc e.sc r.sc we address the following research questions rq1 what is the performance of d u.sc e.sc r.scfor detecting suspicioushidden sensitive operations shsos in android apps?rq2 can d u.sc e.sc r.scbe used to detect logic bombs?
we address thisquestion by considering three sub questions rq2.a are shsos detected by d u.sc e.sc r.sclikely logic bombs?
rq2.b how does d u.sc e.sc r.sccompare against t r.sc .. e.sc r.scs e.sc a state of the art logic bomb detector?
rq2.c from a qualitative point of view does d u.sc e.sc r.scleadto the detection of non trivial triggers logic bombs?rq3 can shso detection in goodware reveal suspicious behavior?
.
rq1 suspicious hidden sensitiveoperations in the wildin this section we assess the e ciency of d u.sc e.sc r.scto f ind shsoson a dataset of malicious applications.dataset.to the best of our knowledge there is no shso ground truth available in the literature.
consequently in this study weconsidered10 000malicious android apps as our malicious dataset.these apps were released in collected from the a n.sc r.sc z repository and have been agged as malware by at least f ive an tivirus scanners in virustotal.we contacted the authors of state of the art approaches e.g.
h1 m n.sc e.sc r.sc and t r.sc .. e.sc r.scs e.sc to get their artifacts data sets and tools for comparative assessment.
unfortunately no arti fact was made available to us.libraries.it has been shown in the literature that librarycode can a ect analyses performed over android apps since it oftenaccounts for a larger part than the app s core code.
consequently in this study we considered two cases with lib analysis i.e.
weconsider the entire app code including library code without libanalysis i.e.
we consider only developer code .
to rule out libraries we rely on the state of the art list available in .post filter.as a precaution before analyzing the results withoutlibs we listed the classes in which d u.sc e.sc r.scfound potential sensitivetriggers to search for redundant classes that could indicate libraries.we were able to f ilter out19additional libraries that were not listedin the list we used and provided by .in the following when referring to the analysis without libraries we consider the19libraries previously presented as well as thelibraries of the list in as f iltered.
it accounts for a total of5982library classes and packages f iltered.
.
.
efficiency of detecting shsos.we recall that d u.sc e.sc r.scistargeted at detecting shsos.
while in rq2 we investigate the like lihood for these shsos to be logic bombs we f irst investigate thee ciency with rq1 of d u.sc e.sc r.scin the detection of shsos.
wefurther perform an ablation study to highlight the performance ofthe anomaly detection module.728difuzer uncovering suspicious hidden sensitive operations in android appsicse may pi t tsburgh pa usain table we report the results of applying d u.sc e.sc r.sc with theanomaly detection step activated on our10 000malware dataset.when analyzing the entire apps d u.sc e.sc r.scdetects at least one shsoin339apps .
.
overall d u.sc e.sc r.scdetects5575shsos in these339 apps leading to an average number of16.4shsos per app.
incomparison when only the app developers code is considered d u.sc e.sc r.scdetects at least one shso in259apps .
with a totalnumber of2435shsos detected and an average number of8.2shsos per app.
we note that the3437 shsos that arenot in the app developer code are actually detected in librariessuggesting that only a few libraries contain shsos .
figure furtherdetails the distribution of detected shsos per apps.
figure distribution of the number of shso s per app inanalyses with and without libraries only apps with at leastone shso are considered .these f irst results show that shsos indeed exist in malicious apps but in relatively low number in around of the apps .
however when shsos are present in an app they are not rare on average about shsos per app in the developer code .
finally shsos are moreprevalent in library code than in app developer code but only a fewlibraries contain shsos.table also reports the average numbers of triggers before andafter applying the anomaly detection step i.e.
the second moduleof d u.sc e.sc r.sc .
interestingly we can see that this anomaly detectiondrastically reduces the number of triggers that are considered asshsos.
indeed when considering the10 000apps there are onaverage .43and .60triggersper apps with or without libraries respectively generated by the f irst module of d u.sc e.sc r.sc i.e.
by the taint analysis step.
after theanomaly detection step these numbers drop to5575 .56and2435 .24respectively corresponding to a decrease of96 and respectively.these results show that the anomaly detection step has a signi f icantimpact on the number of detected shsos by signi f icantly reducing thesearch space of triggers by up to .
this search space reduction iskey when the ultimate goal is to detect malicious code and to supportsecurity analysts manual inspection cf.
section .
.table results of the experiments executed on10 000mal ware with and without taking into account libraries.analysis with libsanalysis without libsnumber of apps with shso s 339259number of shsos55752435number of shsos app16.
.2average triggers i.e.
before anomaly detection .
.60average shsos i.e.
after anomaly detection .
.24meananalysis time35.
s33.
swe further inspect the shsos detected by d u.sc e.sc r.scby focusingon the app developer code only we do not consider library code .table lists the top types of trigger that d u.sc e.sc r.scwas able todiscover.
the second column gives some examples of methods con sidered sources for the taint tracking to uncover shso entry points.we note the diversity of types of triggers that developers use.
forinstance a developer can decide to trigger or not the sensitive codeif database trigger type speci f ic values are present in databases e.g.
contacts messages internet trigger type external orders sayso build telephony and camera trigger types the device is notan emulator connectivity and wi fi trigger types the device hasinternet access location rigger type the user is in a pre de f inedlocation note that the methods in row have been dynamicallygenerated by d u.sc e.sc r.scduring instrumentation to track the buildclass s f ield values.table top ten trigger types discovered by d f.sc u.sc z.sc e.sc r.scin thedeveloper code.
t. triggers trigger typeexamplesof methods t.trigger typeexamplesof methods t.databasegetstring getint getcount785locationgetlastknownlocation getlongitude84internetgetresponsecode getresponsemessage715wi fiiswi f ienabled getconnectioninfo76buildgetmodel getmanufacturer374powerisscreenon isinteractive47telephonygetdeviceid getnetworkoperatorname97audiogetstreamvolume ismusicactive37connectivitygetactivenetworkinfo getnetworkinfo88cameragetcameraidlist28regarding the component types in which d u.sc e.sc r.scfound shsos of shsos are in methods of normal classes i.e.
not an droid components.
shsos are found inactivitiesin of thecases.
however they are rarely found inservicesandbroadcastreceivers less than .
.
.
manual analyses.since static analysis approaches often suf fer from false alarm issues i.e.
they report a large proportion offalse positive results we decided to verify the detection capabili ties of d u.sc e.sc r.scmanually.
to that end the authors of this paperrandomly selected a statistically signi f icant sample of102apps outof the259apps in which shsos exist in developer code with acon f idence level of and a con f idence interval of .
only onesample was found to be a false positive result.
indeed this app veri f ies if it is running in an emulator by comparingbuild.product build.model build.manufacturer andbuild.hardwareagainstwell known strings such as generic emulator google sdk etc.this test seems sensitive but the guarded code displays the fol lowing message to the user scooper warning app is runningon emulator.
.
therefore d u.sc e.sc r.scachieves a precision of99.
to f indsuspicious hidden sensitive operationson this dataset.
werelease the annotated list of102apps that were manually checkedfor transparency in the project s repository.
.
.
analysis time.the last row in table reports d u.sc e.sc r.scanal ysis time.
d u.sc e.sc r.scoutperforms state of the art trigger detectorswith an average of33.54s per app .63s for the analysis withlibraries with an average dex size of7.03mb per app makingd u.sc e.sc r.scsuitable for large scale analyses.
in comparison state of the art tools such as t r.sc .. e.sc r.scs e.sc and h1 m n.sc e.sc r.sc require219.21s and765.3s per app respectively.
note that85.
i.e.
.65seconds on average of this time is reserved for the taintanalysis.
also 24apps .
reached the timeout i.e.
hour before the end of the analysis.rq1 answer d u.sc e.sc r.scdetects shsos in android malware withhigh precision i.e.
.
in less than seconds on average.among the average .
hsos identi f ied in an app based on trig gers spotted by static taint analysis only are suspicious accord ing to anomaly detection which shows that d u.sc e.sc r.scis e ectivein reducing the search space for manual analysis.729icse may pi t tsburgh pa usajordan samhi1 li li2 tegawend f. bissyand 1 jacques klein14.
rq2 can d f.sc u.sc z.sc e.sc r.scdetect logic bombs?in this section we evaluate d u.sc e.sc r.sc s e ciency in detectinglogic bombs rq2.a compare it against t r.sc .. e.sc r.scs e.sc rq2.b and discuss logic bomb use cases in real world apps rq2.c .
.
.
rq2.a are shsos detected likely to be logic bombs?xuntil now we have shown that d u.sc e.sc r.scis e ective in detectingshsos.
from a security perspective however we must further showthat these shsos are actually malicious.
in other words are theseshsos likely to be logic bombs.
unfortunately such assessment ischallenged by the lack of ground truth in the literature.
we thereforerequire extra manual analysis e ort of reported results.initial manual analysis in previous section .
.
we presentour manual analysis of shsos detected in102apps.
during thisanalysis we further checked if the detected shsos contain mali cious code.
in particular for each app under analysis we gatheredinformation about the reason it was agged by antiviruses e.g.
on virustotal .
then in the guarded code of the potential shsofound by d u.sc e.sc r.sc we looked for malicious behavior matchingour information previously gathered.
for instance if an appis labeled as being a trojan stealing the device s information the potential shso is performing emulator detection e.g.
callingsystem.exit method if the device is running in an emulator and the behavior exhibited in the code guarded by the conditiondetected by d u.sc e.sc r.scis gathering the device s information e.g.
unique identi f ier current location etc.
and sending it outside thedevice the shso is considered a logic bomb.eventually 30apps i.e.
.
were manually con f irmed to belogic bombs i.e.
the shsos were triggering malicious code.semi automated further analysis manual investigation istime consuming.
this is the reason why we inspected102appsand not all259apps reported to having at least one shsos withinthe developer code parts.
to quickly enlarge the set of identi f iedlogic bombs we decided to follow a simple but e cient process.
itis known that malicious developers often reuse the same piece ofcode in di erent apps .
therefore for each already identi f iedlogic bomb we search for similarities i.e.
shsos found in the sameclass name same method name and the same type of trigger used in shsos contained in the remaining apps.
ouranalysis yielded16additional apps containing logic bombs thatwere manually veri f ied and con f irmed.
eventually our logic bombdataset called d232b contains46android apps each with anidenti f ied logic bomb.
we believe this dataset to be useful to thecommunity to further improve logic bomb detection in androidapps.
we made it publicly available in the project s repository.discussion about hso shso and logic bomb in the liter ature hso is consistently de f ined as a sensitive operationthat is hidden by speci f ic triggering conditions.
nevertheless thenotion of sensitive operation is not clearly delineated which chal lenges comparison across approaches.
in our work we postulatethat while detecting hsos is an important f irst step it is not enoughto help security analysts.
indeed as shown by our manual analysis a large proportion of hsos are indeed sensitive but not necessarilysuspicious.
as a result most of the detected hsos are legitimateand do not require any inspection e ort from security analysts.in this context if the goal is to detect real security issues and re duce the burden of security analysts a tool such as h1 m n.sc e.sc r.sc which detectshsosin18.
of apps within a set of over300 000apps including malicious and benign apps appears to be unprac tical.
in contrast d u.sc e.sc r.scdetectssuspicious hsosin3.
of theanalyzed apps when libraries are considered and our manual anal yses con f irm that in about of the apps these shsos are logicbombs making the work of security analysts easier.
though bothh1 m n.sc e.sc r.scdataset and our dataset are di erent we were not ableto get the h1 m n.sc e.sc r.sc s authors dataset if we compare the18.
ofapps with hsos reported by h1 m n.sc e.sc r.sc with the3.
reported byd u.sc e.sc r.sc we can say that d u.sc e.sc r.screduces the search space by upto81.
.
.
.
.
to accelerate the identi f icationof logic bombs.rq2.a answer by triaging hsos to focus on suspicious onesbased on anomaly detection d u.sc e.sc r.scwas able to reveal logicbomb instances in a sampled subset of malware apps havingshsos.
besides we release d232b an annotated dataset of46 android apps con f irmed to be using logic bombs.
.
.
rq2.b how does d i.sc f.sc u.sc z.sc e.sc r.sccompare against t r.sc i.sc g.sc g.sc e.sc r.scs c.sc o.sc p.sc e.sc astate of the art logic bomb detector?xin the absence of a public ground truth for android logic bombinstances we perform experimental comparisons against the t r.sc .
.
e.sc r.scs e.scstate of the art detector in the literature that relies onstatic analysis.
although t r.sc .. e.sc r.scs e.scis not publicly available we are able to build on a replication based on technical detailsprovided in t r.sc .. e.sc r.scs e.scpaper .overall our approach di ers from t r.sc .. e.sc r.scs e.sc s by threemajor di erences technique t r.sc .. e.sc r.scs e.scuses symbolic ex ecution to tag variables with a limited number of values we usestatic data ow analysis target t r.sc .. e.sc r.scs e.scdetects hiddensensitive operations i.e.
whether at least one sensitive method iscalled within the guarded code of a trigger whereas d u.sc e.sc r.sc sgoal is to detect suspicious hidden sensitive operations i.e.
theguarded code is sensitive and implements an abnormal behavior and approach t r.sc .. e.sc r.scs e.scmaintains a list of sensitive meth ods and uses the occurrence of any of them as the sole criterion d u.sc e.sc r.scimplements an anomaly detection scheme where the pres ence of sensitive methods is one feature among many others.
whilet r.sc .. e.sc r.scs e.scand d u.sc e.sc r.scboth rely on list of sources to f indtriggers of interest t r.sc .. e.sc r.scs e.schandpicks a limited set of meth ods whereas d u.sc e.sc r.sc s list is based on a systematic mapping cf.section .
.
we leverage patterns to systematically search forsources .does t r.sc i.sc g.sc g.sc e.sc r.scs c.sc o.sc p.sc e.scidentify as logic bombs the shsos flaggedby d i.sc f.sc u.sc z.sc e.sc r.sc?we applied t r.sc .. e.sc r.scs e.scon the subset of102apps where d u.sc e.sc r.scidenti f ied a shso cf.
section .
.
.
the objective is to checkwhether t r.sc .. e.sc r.scs e.scis more or less accurate than d u.sc e.sc r.sc.
typ ically among the logic bombs that have been manually veri f iedas true positives how many are detected by t r.sc .. e.sc r.scs e.sc.
sim ilarly does t r.sc .. e.sc r.scs e.scdetect logic bombs manually veri f iedas true positives that d u.sc e.sc r.sccould not.
figure illustrates thedi erences in logic bomb detection left f igure .
overall t r.sc .. e.sc r.scs e.scdid not ag any logic bomb that d u.sc e.sc r.scdid not.
t r.sc .. e.sc r.scs e.sccould only detect logic bombs among the 30logic bombs that d u.sc e.sc r.sccorrectly identi f ied.730difuzer uncovering suspicious hidden sensitive operations in android appsicse may pi t tsburgh pa usa as reported in the literature t r.sc .. e.sc r.scs e.scexhibits a veryhigh false positive rate at .
among its detections arefalse positives the rate for d u.sc e.sc r.scis .
.does d i.sc f.sc u.sc z.sc e.sc r.scfail to flag as shsos the logic bombs detectedby t r.sc i.sc g.sc g.sc e.sc r.scs c.sc o.sc p.sc e.sc?we recall that contrary to d u.sc e.sc r.sc which builds on anomalydetection t r.sc .. e.sc r.scs e.scis restricted to detect only logic bombswhere the trigger involves location time and sms related prop erties.
aligning with the assessment of d u.sc e.sc r.sc we applied t r.sc .
.
e.sc r.scs e.scon our set of10 000malware.
t r.sc .. e.sc r.scs e.screported591 logic bombs in apps app .
of the reported casesare time related.
in the absence of ground truth we again proposeto manually verify a random sample set of reported logic bombs.
tofacilitate comparison with d u.sc e.sc r.sc we sample102apps we simplyconsidered the same number of apps as in the previous question and manually con f irmed that for .
apps the reported logicbombs are false positives.
in .
apps we found at least onereported logic bomb to be a true positive.we further check whether on these apps where t r.sc .. e.sc r.sc8s e.screported a logic bomb d u.sc e.sc r.scalso ags any case of shso d u.sc e.sc r.sc agged apps as containing shsos among which aremanually con f irmed to be logic bombs.
the details of the compari son between t r.sc .. e.sc r.scs e.scand d u.sc e.sc r.scare presented in the venndiagram in figure right f igure .
we note that logic bombs are detected by both d u.sc e.sc r.scand t r.sc .. e.sc r.scs e.sc.
shsos detected by d u.sc e.sc r.scare actual logic bombs but notdetected by t r.sc .. e.sc r.scs e.sc.
indeed t r.sc .. e.sc r.scs e.scis limited byits focus on time location and sms related triggers.
logic bombs are detected by t r.sc .. e.sc r.scs e.sc but not detectedby d u.sc e.sc r.sc.
our prototype implementation considers a limitedlist of sources which do not cover those logic bomb cases.although we do not have a complete ground truth with infor mation about all cases of logic bombs con f irming and comparingdetection reports by d u.sc e.sc r.scand t r.sc .. e.sc r.scs e.sco ers an alter native to assess to what extent each may be missing some logicbombs.
the results described above suggest that d u.sc e.sc r.scsu erssigni f icantly less from false negative results than t r.sc .. e.sc r.scs e.sc.
figure venn diagram representing results of t r.sc e.sc r.sc s .
e.scand d f.sc u.sc z.sc e.sc r.scon apps originally detected by d f.sc u.sc z.sc e.sc r.scon the left and t r.sc e.sc r.scs .
e.scon the right.
fp falsepositive tp true positive rq2.b answer overall d u.sc e.sc r.scoutperforms t r.sc .. e.sc r.scs e.scbydetecting more logic bombs more accurately wrt.
false positives and by missing less logic bombs wrt.
false negatives .
.
.
rq2.c from a qualitative point of view does d i.sc f.sc u.sc z.sc e.sc r.sclead tothe detection of non trivial triggers logic bombs?xin this section we discuss two real world apps in which d u.sc e.sc r.screvealed logic bombs that cannot be detected by t r.sc .. e.sc r.scs e.sc.advertisement triggering.d u.sc e.sc r.screvealed an interesting logicbomb in com.walkthrough.knife.assassin.hunter.baoer app whichis an adware app of the hiddenad family.
the app uses theandroid.
app.job.jobserviceclass of the android framework to schedulethe execution of jobs the developer can handle the code of thejob inonstartjobmethod .
in theonstartjobmethod the apptakes advantage of thepowermanagerof the android framework tocheck if the device is in an interactive state i.e.
the user is probablyusing the device with methodisscreenon .
if this is the case the app displays advertisements to the user and schedules the sameclass s execution after a certain time.data stealer.logic bombs can also be used to trigger data theftunder the condition that the data is available.
for instance in app com.magic.clmanager which is a trojan hidden behind a clean ing app capable of stealing data on the device d u.sc e.sc r.scfound alogic bomb related to the device unique identi f ier.
indeed in methodd context c of the classc.gdf a check is performed against thevalue returned by methodgetdeviceid to verify if the valuematches speci f ic values emulator detection in a given f ile named invalid imei.idx .
in the case the app considers that the device isnot an emulator it triggers the stealing of sensitive informationabout the device such as the current location phone number in formation on the camera information about the bluetooth diskspace left whether the device is rooted or not the current country the brand the model information about the wi fi etc.
afterward this information is written in a f ile and sent to a native method forfurther processing.
.
rq3 shsos in benign appsuntil now we have focused on malware.
however shsos are notexclusively found in malicious apps .
therefore in this section we intend to conduct a study on benign applications.results.as con f irmed in section .
.
and in previous stud ies benign libraries and benign android apps implementhsos.
our study con f irms this f inding.
even more 354benign apps .
were agged by d u.sc e.sc r.scto contain suspicious hsos.
wefurther manually analyzed apps randomly selected from our re sults and con f irmed that they all contain at least one shso.
table 4shows the di erent trigger types used in benign apps to triggershsos.
a signi f icant result here is that benign apps use consid erably less the build trigger type see table for comparison than malicious apps.
similarly the telephony trigger type is lessused in benign apps than in malicious apps.
this induces that inbenign apps decisions are less taken depending on values derivedfrom methods like getdeviceid getnetworkoperatorname getphonetype getmodel getmanufacturer orget fingerprint .
a hypothesis would be that benign apps are lessprone to recognize an emulator environment and use this informa tion to set triggering conditions .besides we can see in figure that in comparison with maliciousapps benign apps tend to have signi f icantly fewer triggers per app.731icse may pi t tsburgh pa usajordan samhi1 li li2 tegawend f. bissyand 1 jacques klein1table top ten trigger types used by benign android apps.databaseinternetlocationconnectivityaudiotelephonywi fiviewactivitybuild89728326474635825211919figure distribution of the number of shso s app in good ware and malware apps with at least shso are considered .
.
.
case study.this section presents an shso of a benign app.benign app.the app we consider in this case study is no.apps.dn bnor .
d u.sc e.sc r.scdetected an shso in method bom.
uni222e java.lang.
string which tests if the value ofbuild.cpu abiorbuild.cpu abi2is equal to pre de f ined values stored in a f ile.
inthe case a match is found it triggers the copy of a native code f ileinto a second f ile.
the native code f ile name is in the form lib str lib f9 .so .
thestrvariable represents acpu abivalue and thef9variable represents a string to designate the f ile.this f ile is then opened and eventually copied in the user datadirectory of the running app.although not malicious in this case this behavior is suspicious and d u.sc e.sc r.scwas able to reveal it.
.
.
malicious activities in google play.we now illustrate howd u.sc e.sc r.sccontributed to removing8apps whose behavior was po tentially harmful to users in the form of aggressive unsolicited and intrusive ads in google play.
developers of suchadware appsmanaged to evade classical checks performed in google play.during our manual analyses of benign apps we stumbled uponan app with an shso agged by d u.sc e.sc r.sc.
our inspection of thecode suggested that the shso is not a logic bomb per se since itdoes not trigger the malicious code.
however during this manualanalysis we noticed that the app was apparently mainly designed todisplay advertising content aggressively.
to con f irm our hypothesis we downloaded the sample and executed it in an emulator.
first we noticed poor app design poor quality and low content.
thenin nearly every screen i.e.
activitycomponent we receivedembedded ads and full screen ads.
this behavior is characteristicof adware apps.
after veri f ication we found that the app was stillin google play with a relatively high number of downloads a fewthousands but with negative comments.
in fact the app pretendedto provide users with a walkthrough version of an existing gameto display a profusion of ads on each screen.we then search in our analyzed apps if d u.sc e.sc r.scdetected similarshsos.
eventually d u.sc e.sc r.scdetected three apps with the exactsame shso and the exact same service proposed to the user walk through games .
we tested these apps to con f irm they were adware.they were also still in google play.we then checked if similar walkthrough games were also stillin google play and not in our initial dataset.
therefore we searchedfor apps made by the same developers of the three previous appsdetected by d u.sc e.sc r.sc.
we also searched for walkthrough games in google play and browsed the resulting apps.
we inspected thenewly collected apps and con f irmed they were adware apps.
even tually we identi f ied apps with the same adware behavior.we contacted google to report these8apps.
they were removedin less than two weeks from google play.
we make available thesamples in the project s repository.rq3 answer our experiments show that shsos are present inbenign apps and in widely used libraries.
we have seen throughreal world examples that d u.sc e.sc r.sccan reveal potentially harmfulapplications pha and raise alarms concerning some apps po tential maliciousness.
overall d u.sc e.sc r.sccontributed to removing8 adware apps from google play.5l i m i t a t i o n s a n d t h r e a t s t o v a l i d i t yan essential step in our approach is the identi f ication of shsosentry points.
to do so d u.sc e.sc r.screlies on state of the art tool f6 78d r.sc .
therefore it carries the analysis limitations of f6 78d r.sc i.e.
unsoundness regarding re ective calls dynamicloading multi threading and native calls .although our approach proved to be e cient to detect shsosand logic bombs feature selection can impact the performances.indeed feature engineering is a challenging task and can be proneto unsatisfactory selection since it does not captureeverything.besides our approach is based on shso entry points detectionusing taint analysis which relies on sources and sinks methods.sinks are not an issue in our approach since they always representif conditions.
however sources selection is at risk since they havebeen selected systematically using heuristics and human intuitions.therefore our list of sources might not be complete.although we have implemented t r.sc .. e.sc r.scs e.scby strictly fol lowing the description in the original paper our implementationmight not be exempt from errors.in the absence of a priori ground truth some of our assessmentactivities rely on manual analysis based on our own expertise.
whilewe follow a consistent process e.g.
we carefully verify the hiddenbehaviour implementation against the antivirus report our con clusions remain a ected by human subjectivity.
nevertheless wemitigate the threat to validity by sharing all our artefacts to theresearch community for further exploitation and veri f ication.
related worklogic bombs in general.hidden code triggered under speci f icconditions is a concern in many programming environments.
theliterature includes studies of the logic bomb phenomenon in pro gramming prior to the android era and targeting the win dows platform for example.
since then various approaches havebeen proposed to tackle the challenging task of trigger based be havior detection .
state of the art techniques forthe detection of trigger based behaviour are varied and leveragefully static analyses dynamic analyses hybridanalyses and machine learning based analyses .trigger based behavior detection for androidd u.sc e.sc r.sccom bines static taint analysis and unsupervised machine learning tech niques.
our closest related work is thus h1 m n.sc e.sc r.sc whichrelies on static analysis and automatic classi f ication to detecthsos.732difuzer uncovering suspicious hidden sensitive operations in android appsicse may pi t tsburgh pa usacontrary to our work however h1 m n.sc e.sc r.scis not targeting suspi cious hsos and therefore does not focus on logic bombs.fratantonio et al.
proposed t r.sc .. e.sc r.scs e.sc an automatedstatic analysis tool that can detect logic bombs in android apps.t r.sc .. e.sc r.scs e.scleverages a symbolic execution engine to modelspeci f ic values i.e.
sms time location related variables .
t r.sc .
.
e.sc r.scs e.scmodels conditions usingpredicate recovery.
it combinessymbolic execution results and path predicate recovery results to in fer suspicious triggers.
finally potential suspicious triggers undergoa control dependency step to verify if it guards sensitive operations.nevertheless the whole approach relies on static analysis to checkde f ined properties of suspiciousness.
in contrast d u.sc e.sc r.sctakesadvantage of unsupervised learning to discover abnormal hencesuspicious trigger based behavior.anomaly detection for security.we note that the idea of usinganomaly detection to detect malware has been presented in theavdiienko et al.
s paper .
indeed they present m u.sc f6 7thatrelies on anomaly detection to spot malware for which sensitivedata ows deviate from benign data ows.
it proved to be e cientby detecting more than86 malware.
while our approach is alsobased on anomaly detection to triageabnormaltriggers i.e.
suspi cious sensitive behavior that deviate from normality i.e.
normaltriggers conditions the end goal of both approaches is di erent.indeed m u.sc f6 7addresses a binary classi f ication problem to dis criminate malware from goodware.
in contrast d u.sc e.sc r.scaddressesthe problem of detecting and locatingsuspicious hidden sensitiveoperationsthat are likely to be logic bombs in android apps.malicious behavior detection in android apps.malware de tection does not only focus on trigger based malicious behavior.indeed the android security research community worked on tack ling general security aspects .
in the literature numerous approaches have been proposed to detect android hostileactivities.
among which machine learning techniques deep learning techniques static analyses through semantic baseddetection privacy leaks detection as well as dynamicanalyses .
each of these approaches tackles a particularaspect of android security.
therefore analysts could combine ourapproach with the aforementioned techniques to detect a widevariety of android malicious behavior more e ciently.
conclusionwe proposed d u.sc e.sc r.sc a novel approach for detectingsuspicioushidden sensitive operationsin android apps.
d u.sc e.sc r.sccombinesbytecode instrumentation static inter procedural taint tracking and anomaly detection for addressing the challenge of accuratelyspotting relevant shsos which are likely logic bombs.
after empiri cally showing that our prototype implementation can detect shsoswith high precision i.e.
.
in less than seconds per app we assessed its capabilities to reveal logic bombs and demonstratethat up to30 of detected shsos were logic bombs.
we there fore improve over the performance of the current state of the art notably t r.sc .. e.sc r.scs e.sc which yields signi f icantly more false posi tives while detecting less logic bombs.
finally we apply d u.sc e.sc r.scon goodware to investigate potential shsos d u.sc e.sc r.sceventuallycontributed to removing new adware apps from google play.
data availabilityfor the sake of open science we provide to the community allthe artifacts used in our study.
in particular we make available thedatasets used during our experimentations the source code of ourprototype the executable used for our experiments the annotatedlist of our manual analyses and a dataset of logic bombs.the project s repository including all artefacts tool datasets etc.
is available at acknowledgmentthis work was partly supported by the luxembourg national re search fund fnr under projects reprocess c21 is theafr grant by the sparta project which has receivedfunding from the european union s horizon research and in novation program under grant agreement no by the lux embourg ministry of foreign and european a airs through theirdigital4development d4d portfolio under project luxways and by the inter mobility project sleepless seattle no .