declarativesmartcontracts haoxian chen universityof pennsylvania usa hxchen seas.upenn.edugeraldwhitters universityof pennsylvania usa whitters seas.upenn.edumohammad javad amiri universityof pennsylvania usa mjamiri seas.upenn.edu yuepeng wang simonfraseruniversity canada yuepeng sfu.caboonthauloo universityof pennsylvania usa boonloo seas.upenn.edu abstract thispaperpresents decon adeclarativeprogramminglanguage for implementing smart contracts and specifying contract level properties.
driven by the observation that smart contract operations and contract level properties can be naturally expressed as relationalconstraints deconmodelseachsmartcontractasaset of relational tables that store transaction records.
this relational representation ofsmart contracts enables convenient specification ofcontract properties facilitatesrun timemonitoringofpotential property violations and brings clarity to contract debugging via data provenance.
specifically a decon program consists of a set of declarative rules and violation query rules over the relational representation describing the smart contract implementation and contract level properties respectively.
we have developed a tool that can compile decon programs into executable solidity programs with instrumentation for run time property monitoring.
ourcasestudiesdemonstratethatdeconcanimplementrealistic smartcontractssuchaserc20anderc721digitaltokens.ourevaluation results reveal the marginal overhead of decon compared to theopen sourcereferenceimplementation incurring median gas overhead for execution and another median gas overhead for run time verification.
ccs concepts software and its engineering domain specific languages .
keywords smartcontracts declarative programming run time verification acmreference format haoxianchen geraldwhitters mohammadjavadamiri yuepengwang andboonthauloo.
.declarativesmartcontracts.in proceedingsofthe 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november 14 singapore singapore.
acm newyork ny usa 13pages.https permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrights forcomponentsofthisworkownedbyothersthanthe author s mustbehonored.abstractingwithcreditispermitted.tocopyotherwise or republish topostonserversortoredistributetolists requirespriorspecificpermission and or a fee.
request permissions from permissions acm.org.
esec fse november 14 18 singapore singapore copyright heldby the owner author s .
publicationrightslicensed to acm.
acm isbn ... .
introduction smart contracts are programs stored and executed on blockchains.
they have been used in a wide range of blockchain enabled distributedapplicationstomanagedigitalassets includingauctions financial contracts elections trading platforms and permission management .
unfortunately today s smart contractsareerror prone andthishasledtosignificantfinancial losses resultingfrom attackssuch asdice2win kingof ether parity multisig bug accidental anddao .
over the past few years different analysis and verification techniques have been proposed for known vulnerabilities of smart contracts such as re entrancy attacks and transaction order dependency .however whenitcomestohigh level properties specific to individual smart contracts programmers typicallyhavetorelyonhand writtenassertions whichishard tomaintainanderror prone.forexample givenasmartcontract that manages digital tokens one may want to ensure that all account balances add up to the total supply of tokens.
to monitor thispropertyduringrun time onehastoinstrumentthecodeto maintainastatethatkeepstrackofthesumofallaccountbalances andaddassertionsabouttheirequivalencewherevereitheraccount balances or token supplies are updated.
there are third party tools thatsupporthigh levelproperty specificationand verification for solidity e.g.
temporal logic and formula with extended operators .however counter examplesarereturnedintheformof ethereumbytecodetracesortransactionsequences whichmaynot be easy for programmers to understand and localize bugs in the originalimplementation.
to make smart contracts easier to analyze and verify this paper presentsdecon adeclarativeprogramminglanguageforsmartcontractimplementationandpropertyspecification.deconisbased on datalog a declarative logic programming language that syntacticallyisasubsetofprolog.datalogfreesprogrammersfrom low levelimplementationdetails e.g.
datastructures algorithms etc.
and allows them to reason about the contract on the specificationlevelviainferencerules .inaddition suchrelational representation serves as a high level abstraction of the contract whichenables efficient formalanalysisandverification .
a typical smart contract provides two kinds of interfaces transactionsandviews.
transactions are function calls that alter the contract states e.g.
a token transferthatupdates bothsenderand recipientbalances.viewsareread onlyfunctionsthatreturnparticularstates ofthe contract e.g.
the balanceof an account.
esec fse november14 18 singapore singapore haoxianchen geraldwhitters mohammad javad amiri yuepeng wang andboonthauloo smartcontractpropertiesandoperationscanbenaturallymapped torelationallogic.forexample transactions themainelementin smartcontracts canbemodeledasrelationaltables wherethetable schemacontainstransactionparameters e.g.
sender recipient and amount.
similarly the balance of each account can be expressed as sum aggregation on transaction records and lookingup an account balance can be expressed as a constraint on the address column of the balancetable.
given this relational view of transactions committing a transaction can be interpreted as appending a new row to the correspondingtable.
the commit andabortion logicof apendingtransaction isspecifiedbydatalog baseddeclarativerules.viewscanthenbe specified as declarative queries on these tables.
for example an account balance is the total income of the account subtracted by itstotalexpense eachofwhichisa query onrelevanttransaction records.
contractpropertiesarealsospecifiedasinferencerules.theyare interpretedaspropertyviolationqueries aspecialkindofviews and are expected to be always empty during correct executions.
forexample ifasmartcontractforbidsoverspending thenaquery on accounts withnegative balancesshould always be empty.
such unification of implementation and property specification language saves programmers effort to learn another language to formally specifyproperties.
decon complies declarative specifications into executable solidity programsthatrunonblockchains e.g.
ethereum and monitor the specified properties at run time.
when a property violation view is derived non empty after executing a pending transaction thetransactionisaborted.suchautomaticcodegenerationnotonlysavesimplementationeffort butalsoeliminates the gap between the program specification and implementation providingastronger guarantee ofthe verification result.
thekeyinsighttogenerateefficientexecutablecodefromdeclarativespecificationsisthatsmartcontracttransactionsareexecuted insequence.inotherwords newrowsareappendedtothetransactiontablesoneatatime.therefore deconborrowstheideaof incremental view maintenance in databases to generate efficientupdateprocedures.oncommittinganewtransaction instead of evaluating the queries on the whole tables only the differences inquery results are computedandappliedto existing views.
in addition decon is easyto debug withdata provenance .
provenance is a mechanism for explaining how certain tuples or factsarederived rightdowntotheinputvalues.inanimperative languagelikesolidity dependencyinformationisdifficultto becapturedautomatically throughdata flowanalysis .incontrast inference rules in decon give explicit dependency information where each tuple can be directly attributed to one rule thus providingmore clarity to the executionprocess.
the key contributionsofthe paper are as follows we design decon a declarative language that unifies smart contract implementation and specification.
we demonstrate itsexpressivenessviacasestudiesonrepresentativesmart contracts andtheirhigh level correctness properties.
wedesign analgorithmtocompilethesehigh level specificationsintoexecutablesolidityprograms withinstrumentation for run time verification.
we implement and experimentally evaluate decon.
our evaluation shows that the generated executable code has comparableefficiencywiththeequivalentopen sourceimplementation of the same contract median gas overhead andtheoverheadofrun timeverificationismoderate median gas overhead .
the prototype implementation and evaluation benchmarks are open sourced for future studiesandcomparisons.
therestofthispaperisorganizedasfollows.section 2motivates decon using a wallet example.
the declarative smart contract language is presented in section .
section 4demonstrates the translationofdeclarativerulesintoanexecutablesolidityprogram.
theexpressivenessofdeconispresentedinsection 5usingtwo casestudies.section 6experimentallyevaluatesdecon.section discussesrelatedwork andsection 8concludes the paper.
illustrative example inthissection weshowhowtousedecontoimplementasmart contract specify itsproperties anddebug via provenance using a walletsmart contract that manages digital tokens.
.
contract implementation a smart contract offers two kinds of interfaces transactions and views.
transactions are the function calls that update the contract states.ontheotherhand viewsareread onlyfunctionsthatreturn one ormore contract states.
indeclarativesmartcontracts transactionrecordsaretheonly states.
transactions are modeled as relational tables.
a new row is appended to the table when a new transactionis committed with column entries storing the transaction parameters.
transaction rules i.e.
theconditiononwhichanewtransactioncanbecommitted arespecifiedasdeclarativerules.finally viewsarespecifiedas declarative queriesover the transaction tables.
weusethewalletexample showninlisting toexplainhow relationaltablesanddeclarative rulescanbespecified.
thewallet contract manages token transactions between ethereum addresses where the contract owner can mint or burn tokens to addresses anddifferentaddresses can transfer tokens to eachother.
relationsandinterfaces.
lines1to14declaretherelations with schemaintheparenthesis and optionally primarykeyindicesin thebracket e.g.
balanceofonline8 .primarykeysuniquelyidentify arowinthetable.forinstance balanceofrecordsthebalanceofeach account andthushasauniqueaccountcolumn.withoutexplicit specification all columns are treated as primary keys.
relation totalsupply line is a singleton relation a kind of relation that contains only one rowandisannotatedbyastar symbol.
given these relation declarations transaction and view interfacesaregenerated.first transactioninterfacesaregeneratedfrom relationswith recv prefix wheretheinputparametersdefinethe schema and a boolean return value indicates the success of the transaction.
for example relation recv mintis translated into the following interfaceinsolidity the target executablelanguage.
function mint address p intamount returns bool second viewfunctionsaregeneratedfromtherelationsthatappear inthepublicinterfaceannotations line9 .theinputparameters 282declarative smartcontracts esec fse november14 18 singapore singapore transaction event triggers .declrecv mint p address amount int .declrecv burn p address amount int .declrecv transfer from address to address n int views .decl totalsupply n int .declbalanceof p address n int .public totalsupply balanceof transaction rules .declmint p address amount int .declburn p address amount int .decltransfer from address to address n int 15r1 mint p n recv mint p n msgsender s owner s n .
17r2 burn p n recv burn p n msgsender s owner s balanceof p m n m. 19r3 transfer s r n recv transfer s r n balanceof s m m n n .
view rules 23r4 totalsupply n allmint m allburn b n m b.
24r5 balanceof p s totalout p o totalin p i s i o. auxiliary relations and rules ... .decltotalmint p address n int .decltotalburn p address n int 29r6 transfer p n mint p n .
30r7 transfer p n burn p n .
31r8 totalout p s transfer p s sumn transfer p n .
33r9 totalin p s transfer p s sumn transfer p n .
.decl allmint n int .decl allburn n int 37r10 allmint s s sumn mint n .
38r11 allburn s s sumn burn n .
listing walletsmart contract are the primary keys and the output is the remaining values.
note that since a singleton relation e.g.
totalsupply has no primary keys it becomes a function withoutparameters.
if all columnsare primary keys then the function returns a boolean value indicating theexistenceoftherow.forexample balanceof p address n int istranslatedintothe following functioninterface.
function balanceof address p returns int rules and functions.
the rest of the program shows the rules thatprocesstransactionsanddefinetheviews.eachruleisofthe form head body interpreted as follows.
for all valuation of the variables that satisfy all constraints in the body generate a row as specified in the head.
for example r1on line says that aminttransactioncanonly besent bythe contract owner and the amount should always greater than .
this rule is compiled into the following soliditycode withsimplification .
function mint address p intn returns bool boolret false if msg.sender owner n call functions to update dependent views... ret true return ret whena minttransactioniscommitted r5willbetriggeredthrough achainofrules r1 r6 r9 r5 .itspecifiesthebalanceofanaccount p asthetotalincome totalin p i subtractedbythetotalexpense totalout p o withtotalinandtotaloutfurther defined by r8andr9 respectively.thisruleiscompiledintotwosolidityfunctions each updates balanceof when either totalinortotaloutisupdated.
function updatebalanceofontotalin address p inti into totalout balanceof i o function updatebalanceofontotalout address p into inti totalin balanceof i o to get the balance of a given account one could call balanceof a viewfunctionthattakestheaccountaddressasaparameter and returnsanintegervalueastheaccountbalance.indecon relational tablesarestoredinmaps mappingprimarykeystovaluesinthe remaining columns.
this viewfunction isgeneratedas follows.
function balanceof address p public view returns int read the row by primary key p balanceoftuple memory balanceoftuple balanceof return the value return balanceoftuple.n .
specificationandrun time verification in decon properties are specified the same way as views but with additional annotation.
for example in the wallet contract one may want to make sure that all account balances are always non negative whichcan be specifiedas follows.
.declnegativebalance p address n int .violation negativebalance r14 negativebalance p n balanceof p n n .
ruler14specifiestheviolationinstanceoftheproperty foreach row inbalanceof table with n insert a row p n innegativebalance table.duringtheexecutionofthetransaction the negativebalance table is incrementally updated when its dependent relations are updated the same as otherviews.
the keyword .violation annotates that every row in the table is a property violation instance.
a property is satisfied if and only if its corresponding violation table is empty.
given such annotations deconinstrumentstheprogramtochecktheemptinessof allviolation tables before eachtransaction iscommitted.
notethatpropertiesaremonitoredonthegranularityoftransactions.
as we show in section due to the underlying update procedure transient violations could occur during the execution of a transaction but disappear at the end.
therefore instead of abortingrightafteraviolationtupleisderived atransactionisonly abortedif attheendofitsexecution anyviolationtableremains non empty.suchinterpretationallowsprogrammerstoreasonat thetransactionlevel withoutworryingabouttheunderlyingupdateprocedure.
theviolationcheckingprocedureisgeneratedandperformed attheendofeachtransaction.inthisexample the negativebalance violation ischeckedas follows.
function checkviolations ifnegativebalance isnot empty revert negative balance.
check other violations ... 283esec fse november14 18 singapore singapore haoxianchen geraldwhitters mohammad javad amiri yuepeng wang andboonthauloo balanceof 0x01 totalin 0x01 totalout 0x01 r5 r8 burn 0x01 totalout 0x01 r2 recv burn 0x01 figure provenance ofaviolation ofnegative balance .
debuggingviaprovenance data provenance is afeature ofdeclarative programs that records thedataflowfrominputtooutputandenablesrule wisedebugging.
itallows counter exampletraces tobe presentedin thecontext of theoriginalspecification insteadofthelow levelevminstructions thus makingthe debuggingprocessmore intuitive.
suppose the original program has an incorrect r2 which misses a predicate to check that the account has enough balance to be burnt.the incorrect version of r2isshown as r2 in the following.
r2 burn p n recv burn p n msgsender s owner s .
an account with a balance of nwould have a negative balance if more than ntokens are burnt.
suppose during execution the account 0x01isdetectedtohaveanegativebalanceof .tounderstandwhythisviolationhappens onecouldquerytheviolation tuple s provenance tree as shown in figure .
the provenance tree is read from topto bottom.
onthe topis a tuple balanceof 0x01 that triggers the violation in negativebalance .
below shows that it is derived by r5 based on totalin 0x01 andtotalout 0x01 whicharethetotaltokensreceivedandsentbyaddress 0x01.the tupletotalout 0x01 isfurtherderivedby r8.thisback tracing continues for another step until one finds the derivation of r2 isincorrect whichsuggeststhatthecondition balanceof p m m n shouldbeadded.withthisprovenance programmerscan debug contracts inavisual andinteractive manner.
language adeconcontractconsistsofthreeelements relations rules and relationannotations.a relationdeclarationspecifiesthenameof a relational table and its schema.
each relational table can store eithertransactionrecords withthetransactionparametersbeing the column values or views the summary information of these transaction records.
a rulespecifies either the conditions on which anewtransactiongetsapprovedorthederivationofaviewfromthe transactionrecords.finally relationannotations specifywhether a relational table is a public view or a violation.
public views are compiledintopublicinterfacesthattaketherelation sprimarykeys asparametersandreturntheremainingvaluesinthematchingrow.
violations will be monitored during run time and a transaction is reverted if the violation relation is non empty after the transaction execution.
type t int uint bool address schema s c1 t1 c2 t2 ... primarykeys k k1 k2 ... reservedrelation rs singletonrelation sg .decl r schema simplerelation sp .decl r schema transactionrelation tr .decl recv schema relation r rs sg sp annotation a .public r .violationr figure syntax ofrelation declarations and annotations .
relation declarationsandannotations theformalsyntaxofrelationdeclarationsandannotationsisdefinedinfigure .
schema.
schema of a relation is specified as a list of ci ti where ciisthe column name for the i th column and tiisthe data type.
primary keys.
primary keys kare a list of indices in the relation schema.
specifying primary keys is optional.
if a simple relation isspecifiedwithoutprimarykeys thenallcolumnsaretreatedas primarykeys.primarykeysuniquelyidentifya rowineachtable.
oninsertinganewrow ifanexistingrowhasthesameprimary key the existing rowisreplacedbythe newrow.
singleton relations are relations with only one row which are annotated with inthespecification.
whena new row is inserted intoasingleton relation itreplaces the existing row.
transactionrelations arerelationswithprefix recv .asexplained inthenextsection theserelationsaretreatedaseventtriggerswhen used in a rule and are compiled into smart contract interfaces that handle incomingtransaction requests.
reservedrelations.
thefollowingrelationsarereservedtohandle smart contract specific constructs msgsender a address stores the address of messagesender.
msgvalue v uint stores the values of ethers sent along a message.
send to address n uint32 triggersatransactionthatsends nethers to anotheraccount.
constructor is translated into the constructor function with schemabeing function parameters.
.
rules asshowninfigure wedistinguishtwokindsofrules transaction rules and view rules.
a transaction rule contains a transaction relationinitsbody.transactionrelationsarerelationswithaprefix recv innames.theserulesareonlyfiredonreceivingthecorrespondingtransactionrequest andthetransactionisapprovedifthe restoftheconstraintsintherulebodyaresatisfied.ontheother hand aviewrule doesnotcontainanytransactionrelations.itis evaluatedwhenever one of the relations inthe body isupdated.
syntaxrestrictions.
decondoesnotsupportrecursions.thatis no dependency loop exists between any two relations.
the dependencyrelationship indecon isdefinedas follows.
definition3.
relationdependency .relationraisdependent onrelation rb if there existsa view rule where rais inthe head 284declarative smartcontracts esec fse november14 18 singapore singapore variable x aggregation agg sum max min count function f condition c !
transactionrelation tr recv other relation r headliteral h r x bodyliteral b r x c x y f x y aggx r x transactionrule tx h tr x b1 ... bn view rule v h b1 ... bn figure syntax ofrules andrbis in the body or a transaction rule where rais in the head andrbisatransactionrelation withaprefix recv inthe body.
rule semantics.
a rule is evaluated as follows.
for each variables valuation that satisfies the rule constraint generate the head tuplewithallvariablesassignedtoitscorrespondingvaluesin .
avariablevaluationisamappingfromthesetofvariablenames vto the variable domain d v d .
rule constraint is a conjunction of all body literal constraints.
as described in figure there are four kinds of body literals.
for literals in the form of relational tuples r x the constraint is satisfied if row xexists in the relational table r. other kinds of literals i.e.
conditions functions and aggregations are directly interpreted as constraints onthe variables.
consider r5inthe walletexample listing .
r5 balanceof p s totalout p o totalin p i s i o. thisruleisinterpretedasfollows forallvaluesofvariable p o i suchthatthereexistsatuple totalout p o andtotalin p i derive the head tuple balanceof p s where s i o .
aggregationliteral aggx r x computestheaggregate forall rowsinrelation rthatsatisfytheruleconstraint.forexample in thewalletexample listing line31showsarulewithaggregation.
r8 totalout p s transfer p s sumn transfer p n .
for each unique value of pin the first column of transfertable this rulecomputesthesumofthethirdcolumnforrowsin transfertable that has the value pin the first column.
in other words this rule groupsthetablebythefirstcolumn andthencomputesthesumof the thirdcolumn within eachgroup.
limitationsinexpressiveness.
deconforbidsrecursionsinorder to keep the gas consumption predictable and affordable.
in fact recursionisnotrecommendedbythesoliditydocumentationfor stack spaceissues .
inaddition therearefunctionsthatlieoutsideofrelationallogic e.g.cryptographicoperations randomizedfunctions etc.suchfunctionscanbeimplementedindeconbylinkingthecontractwithexternallibraries.however analyzingsuchfunctionsischallenging andwouldneedsubstantialfutureresearch.deconalsodoesnot supportcontractinheritance dynamicdispatching andchecking interfaces of another contract.
these features can be incorporated intodecon infuture compilerdesigns.
compilation to solidity decon translates a set of declarative rules into an executable solidityprogramthat processestransactionsfollowingtheconditions intransaction rules updates views incrementally as new transactions are committed and monitors property violations.
the compilation processinvolves three majorsteps.
abstractupdatefunctions.
first eachruleistranslatedintoa set of abstract update functions each of which performs incrementalupdatestotheheadrelationwhenoneofthebodyrelationsis updated.thesefunctionsareabstractinthattheydonotimplement concretedatastructures.forexample inthewalletcontract the following ruleprocesses minttransactions.
r1 mint p n recv mint p n msgsender s owner s n .
this ruleistranslatedintothe following abstract updatefunction.
1on insert recv mint p n search ownerwhere address s owner search msgsender wheres msg.sender if n insert mint p n thisupdatefunctionistriggeredwhena minttransactionisreceived asindicatedbytheeventtriggertuple recv mint p n .theremaining two relational literals owner s andmsgsender s are translated into nestedsearchstatements line2andline4 .asearchstatementhas the form search r where c do s where ris the relational table cis the set of constraints on rows and sis the statement to execute for each row that satisfies the constraints in c. the condition literal n istranslatedintoan ifstatement line5 .ifallpriorconditions are satisfied we arrive at line6 where the rulehead isinserted.
data structures.
theseabstractfunctionsare then translated intoconcretesoliditystatements wherethe searchstatementsbecome efficient join algorithms on concrete data structures and update functions for dependent views are called after an insert statement.
instrumentation.
inthelaststep thesolidityprogramisinstrumentedtomonitorpropertyviolations andabortthetransactionif anyviolationhasbeendetectedbytheendoftransactionexecution.
.
abstractupdate functiongeneration there are two kinds of updates that could trigger a rule tuple insertionandtupledeletion.weuse insert e anddelete e todenote the update trigger on inserting and deleting a tuple e respectively.
note that both a tuple and a literal have the form r x .
it is called atuplewhen xhasconcretevalues andiscalledliteralinarule where xissymbolic.weuseliteralandtupleinterchangeablyin the following discussionof updatetriggers.
givenarule r letb r bethesetofallrelationalliteralsin r s body andebe the transactionrelation in rifris atransaction rule 285esec fse november14 18 singapore singapore haoxianchen geraldwhitters mohammad javad amiri yuepeng wang andboonthauloo the setofupdatetriggers t r are definedas t r uniontext.
l b r insert l delete l risview insert e ristx rule ifrisaviewrule thenitcanbetriggeredbyupdatesofanyrelation initsbody.otherwise risa transactionrule triggeredonlywhen receivingatransactionrequest.
algorithm updatefunction r t .
given a rule r and a trigger t returns an updateobject.
initialize the setofgroundedvariables g t.variables .
literalsotherthanthe trigger l r.body t .
updateprocedure s update r.head l t g .
return ont dos for each rule r and for each update triggers in t r an abstract update function is generated by updatefunction r t presented in algorithm .
it first initializes the set of grounded variables by variablesinthetriggerliteral.groundedvariablesarevariablesthat are constrained to a constant value.
variables in a trigger literal are considered grounded because the update function is always triggered by the insertion or deletion of a concrete tuple.
in step update procedure sis generated by a sub routine update which ispresentedinalgorithm .finally itreturnstheabstractupdate functionintheformof on t do s wheretistheupdatetriggerand sisthe updateprocedure.
algorithm update h l t g .
given a rule head h a list of body literalsl anupdate trigger t andthesetof groundedvariables g return statements that perform the incrementalupdate.
matchl casenil matcht caseinsert returninsert h casedelete returndelete h casehead tail add groundedvariables g g x x head innerstatements s update h tail t g matchhead caser x derive constraints c constraint r x g return searchrwhere c do s casec x return if c then s casey f x return y f x s casey aggx r x return y aggx r x s asshownin algorithm update h l t g performsrecursion onl the list of literals in the rule body with every recursion translating one literal to a layer of code block nested within the code blockgeneratedbythe previous literals.
inparticular itperformspatternmatchingoninput l alistof literalstobetranslated.if lisempty whichmeansallbodyliterals havebeentranslated anupdatestatementthatisconsistentwiththe updatetriggerisreturned.otherwise lhastheform head tail.itfirstaddsallvariablesin headintothesetofgroundedvariables and then generates the inner code blocks sby recursively calling itself ontailandtheupdatedsetofgroundedvariables g .depending on the form of head the current layer of code block is generated in different ways.
by the syntax of the language in section head could take one ofthe following forms a relational literal r x .
given the set of grounded variables g the searchconstraintsfor rowsin risgeneratedas follows.
constraints r x g logicalanddisplay.
r v v g v x i x.indexof v wherer vmeans filtering rows in table rwhosei th column equals to v. a condition literal c x in which case the condition is directly used in the same way as an ifcondition with the inner code blocksplacedwithin the ifstatement.
a function or aggregation.
in either case the literal is directly translatedintoanassignmentstatement followedbytheinner code blocks.
aggregations.
the evaluation results of aggregation functions are maintained incrementally.
sums are incremented by nwhen a row with aggregate value nis inserted and decremented by nwhen a row is deleted.
similarly counts are incremented by 1on row insertionanddecrementedby 1onrowdeletion.maximumsand minimums are slightly different.
when a new row is inserted with valuen ifnis greater than the current maximum the maximum is updatedton.whenthecurrentmaximumrowisdeleted themaximum is updated as the second maximum value.
thus it requires maintaining a sorted list of values.
minimum is maintained in a similar fashion.
.
concrete data structuresandinstructions given the abstract functions generated from each rule the next stepistogenerateconcreteandefficientdatastructuresandsearch algorithms inthe soliditylanguage.
datastructures.
eachrelationaltable r exceptsingletonrelations is translated into a mapping from its primary keys to a structure that stores the restofthe column values struct rtuple boolvalid t1 field1 t2 field2 ... mapping k1 k2 ... kn rtuple r bydefault hash mapsinsoliditymapallkeystozero.therefore avalid bit valid is introducedto indicate theexistence of atuple.
columns other than primary keys are the structure members.
if all columns are primary keys its structure only contains avalid bit.
singletonrelationsaredirectlystoredinastructurewithcolumns being the structure members.
join index.
join index is built for each search statement in the abstractupdate program.
given a searchstatement search r where c do sintheabstractupdateprogram ifallprimarykeysof rare constrained to constant values no join index is generated.
the matching entry can be directlylookedupbyprimary keys.
286declarative smartcontracts esec fse november14 18 singapore singapore on the other hand if in some rules not all primary keys of r are constrained to constant values a join index is built as a map from the constrainedkeys to alistofunconstrainedkeys.
suppose relation r1 k1 k2 v1 has primary keys k1andk2.
as described above table r1is stored as a map from primary keys to remaining values mapping k1 k2 r1tuple .
given a search statementsearch r1 where r1 k1 do s whereonlyoneprimarykey k1 isconstrained the joinindex for r1isbuiltas the following.
struct r1keytuple boolvalid t2 k2 mapping k1 r1keytuple r1index wherer1indexmapsk1to a list of r1keytuple which stores the value of the other primary key k2.
during the join execution to iterateallrowsin r1thatsatisfy r1 k1 itfirstlooksupall k2 inr1keytuple andthen for each k2 getthe valuein r1 .
update dependent views.
an insert or delete statement in the abstractupdatefunctionistranslatedintotwosetsofsolidityinstructions.thefirstsetupdatesthecorrespondingdatastructure and the second set calls the update functions for the dependent relations definition .
.
insertingarelationaltuple t1directlyupdatesthemap aswell asthejoinindexifoneexists.ifatuple t0withthesameprimary keysexists alldependentviewsareupdatedbyfirstcallingdeletion updatesont0 andthentheinsertionupdateson t1.insertionupdate referstofunctionstriggeredbytupleinsertion anddeletionupdate referstofunctionstriggeredbytupledeletion.otherwise insertion updates are directly called.
since a solidity mapping maps all keys to valuezerobydefault atuple existsif its valid bit issetto true.
deleting a relational tuple resets its valid bit to false.
then deletionupdatesare calledfor alldependent relations.
in this way when a new transaction is committed all dependentviewsareupdatedthroughthischainofupdatepropagation.
sincethereisnorecursion i.e.
dependencyloopbetweenrelations allowedin decon update propagation isguaranteedtoterminate.
logging.
committedtransactionsareloggedassolidityevents amoregasefficientstoragethanglobalmemory butcanonlybe read offline.
these events constitute all states of a decon contract whichenableofflineanalysisforfurtherinsightsandpotentialbugs.
.
run time verification properties are specified as declarative rules that derive violation instances.
such relations are annotated with the keyword violation.
as introduced in section .
transient violations that occur duringthetransactionexecutionarenotcounted.toseewhytransient violationscanoccur consideragainthewalletcontractinsection andapropertythatrequiresallaccountbalancestoadduptothe totalsupply.the property can be specifiedas showninlisting .
.violation unequaltotalsupply r12 totalbalance s sumn balanceof n .
r13 unequaltotalsupply n m totalsupply n totalbalance m n!
m. listing all account balances add upto total supply.during the execution of a minttransaction the totalsupply and thetotalbalance areupdatedinsequence whichleadstoaviolation whenoneisupdatedbeforeanother buttheviolationdisappears when both are updated.
given this notion of transient violations instead of aborting the transaction right after a violation tuple is derived the checking procedure is deferred to the end of transaction.
if any violation view is non empty the transaction is aborted.
note that a solidity mapping does not record its domain.
hence a separate array of mappingkeysaremaintainedanditeratedforvalidviolationtuples.
.
provenancegeneration to debug a violation programmers can use data provenance to visualizethederivationprocessofaviolationtuple.asshownin figure1 provenance is a directed graph with two kinds of vertices tuples and rules.
edges from a tuple vertex to a rule vertex denote tuplereads andedgesfromarulevertextoatuplevertexdenote tuple derivations.
to generate this provenance graph during the rule evaluation procedure twokindsofadditionalrecordsarelogged tupleread read tuple rid andtuplederivation write rid tuple where ridis a uniqueidentifierfor eachrule.the read tuple rid is interpreted as an edge from tupleto the rule indexed by rid and conversely write rid tuple isan edge from rule ridtotuple.
note that in solidity a failed transaction reverts all instructions includinglogging.whenatransactionisrevertedduetoaproperty violation theprovenancelogswouldalsobereverted.therefore to generate provenance for a violation tuple the transaction needs to be executed in a local debugging environment instead of the deploymentblockchain.thispracticealsosavesstoragespaceon the publicblockchain.
.
optimizations toimprovegasandstorageefficiency twooptimizationshavebeen appliedto the generatedcodes.
join order.
body literals in a rule are sorted by their iteration cost in an increasing order.
first are reserved relations and singleton relations since they need no iteration.
second are the relations whoseprimarykeyshaveallappearedinproceedingliterals.these literalscanbesearchedviaadirectmappinglook up thusrequiring no iterations either.
next are the rest of the relations which are translatedintoloops.finally come condition andfunction literals.
storage space.
storage space on a blockchain is precious due to the high synchronization cost.
deriving relations on demand that is delayingevaluatinganinferenceruleuntilitisused cansave storagespace butmayincurperformanceoverhead.
toachieve a balancedtrade offbetweentimeandspace decononlyproactively derivesandstoresrelationsannotatedaspublicviewsorviolations as well as relations that are read during their derivation.
other relationsarederivedon demand.forexample inthewalletcontract in section relation mintonly serves as an update trigger for dependentrules whichisneverqueriedduringtheupdateofpublic viewsorviolations.therefore whena minttupleisgeneratedby r1 it only triggers the update for dependent rules but it is not written to the persistent storage.
287esec fse november14 18 singapore singapore haoxianchen geraldwhitters mohammad javad amiri yuepeng wang andboonthauloo case studies this section demonstrates the expressiveness of decon and the explainabilityofdataprovenanceviacasestudiesontwopopular smart contracts erc20 and erc721.
for the sake of brevity only a subsetofrulesisdiscussed.allcontracts are available online .
.
erc20 erc20 isatokenstandardforfungibletokens.similartothe wallet contract in section it also supports token transfers between users.
in addition it has an allowance mechanism where users can allow other users to transfer their tokens up to a certain amountcalled allowance.theallowancemechanismcanbespecified as follows.
r1 transferfrom sender receiver spender n recv transferfrom sender receiver n sender has enough balance.
balanceof sender m m n operator has enough allowance.
msgsender spender allowance sender spender l l n. onreceivinga transferfrom transaction inadditiontochecking that the senderhas enough balance m n the rule also requires the spendertohaveenoughallowancetospendtokenson sender sbehalf l n .therelation transferfrom representstransactionswherethe spendersendsntokens from the senderto thereceiver.
the allowance of a spenderon an account is specified as follows.
r2 spenttotal o s m transferfrom o s m sumn transferfrom o s n .
r3 allowance o s n allowancetotal o s m spenttotal o s l n m l. therelation spenttotal accountstheamountoftokens mthatspender shas spent on behalf of the sender o. andallowanceis derived by subtracting the total spending from the total allowance an amount approvedbythe sender definedinanotherrule .
given the definition of allowance and the spenttotal we can specifyaproperty that aspendernever overspends as the following .violation overspent overspent o s n m allowancetotal o s n spenttotal o s m m n. decon then generates instrumentation to monitor this property at run time.
explain allowance changes via data provenance.
suppose the programmer madeamistakeinspecifying spenttotal r2 spenttotal r s m transferfrom r s m sumn transferfrom r s n .
the error in r2 is that the transferfrom table is grouped by the receiver r and spender s column instead of the sender o and spender s column as in r2 .
when a spender account swants to transfer 20tokens from account atoaccount b bysubmittingatransaction transferfrom a b s it is reverted.
decon explains that it is because the condition l ninr1is false which means the spender sdoes not have sufficientallowance to transfer tokens on a sbehalf.
to understand why the spenderonly has 10allowance to a s account onecouldgettheprovenanceofthetuple allowance a s allowance a s r3 allowancetotal a s spenttotal a s r2 transferfrom b a s a allowance a s transferfrom a s r tokenid r4 ownerof tokenid a approved tokenid a r5 approve b s tokenid b transferfrom a s r tokenid figure provenance tree fortuples.
asshowninfigure 4a.ontopoftheprovenancetree allowance a s isderivedby r3 fromthefactthatthetotalallowanceis allowancetotal a s andthat ahasspent 90already spenttotal a s .
to see why spenttotal a s is derived the programmer continuesexpanding itsprovenancetree.abug isrevealed atthis step where a transaction from address btoais accounted for s s allowance onaddress a whichpointsto the bugin r2 .
.
erc721 erc721 isasmartcontractstandardfornon fungibletokens nfts .
a main transaction for erc721 tokens is transfer which recordsthetransferofatokenfrom sendertorecipientataparticular time.thetransactiontimeisincludedtospecifythefollowingviews.
firstistheviewfunction ownerof.giventhe transferrelation the ownerofatoken isdefinedas follows.
latesttransfer tokenid s r t transfer tokenid s r t t maxi transfer tokenid i .
ownerof tokenid p latesttransfer tokenid p p !
.
thefirstruleselectsthelatesttransferrecordfor tokenid andthe next rule specifies that if the recipient of the latest transfer is nonzero itisthe ownerofthe token.
nextisthe existrelation.atokenexistsifitismintedandisnot burnt.inerc721contracts burningatokenemitsatransferrecord from its ownerto zeroaddress.
hence existisdefinedas follows.
exists tokenid true latesttransfer tokenid to to!
.
therulechecksthatatoken slatesttransferrecipientisanon zero address whichmeans itisnot burnt.
toensureeveryexistingtokenhasanowner wecouldspecify the following property.
.violation tokennoowner tokennoowner tokenid ownerof tokenid exists tokenid true .
this rule defines a property violation as an entry in the ownerof table where owneraddress is 0andtokenidexists.
explainanunexpectedtokentransferviadataprovenance.
supposetheownerwantstounderstandwhyoneofhertokenshas beentransferredawayinatransaction transferfrom a s r tokenid 288declarative smartcontracts esec fse november14 18 singapore singapore whereais the operator sis the sender and ris the receiver she expandstheprovenancetreeforthetransaction whichisshownin figure4b.ontopoftheprovenancetreeisa transferfrom tranaction approvedbythe following rule r4 transferfrom operator sender receiver tokenid recv transferfrom operator sender receiver tokenid sender owns the token.
ownerof tokenid sender operator is approved to move the token.
msgsender operator approved tokenid operator .
whereapproved tokenid operator means that the token tokenidhas been approved to use by operator.
this approval is set by the token owner.
suspicious about the approved tokenid a tuple the owner continuestoexpandtheprovenancetree andfindsthatitisderived from the following rule.
r5 approved tokenid operator approve operator tokenid .
and the tuple approve b s tokenid which means account b a previousowner hasapprovedthistokentooperator sbeforetransferring thistokento a.here shefinds thebug r5doesnotcheckthatthe address that approves the token should be the token owner.
the ruleshould have been updatedas followsinstead.
r5 approved tokenid operator ownerof tokenid owner approve owner operator tokenid .
evaluation we implement a prototype compiler for decon in scala that generates solidity programs with instrumentation for run time verification.wefirstevaluatethecompilerbycomparingitsoutput withoutinstrumentation withreferencecontractwritteninsolidity.
next weevaluatetheoverheadofrun timeverificationonthese contracts andtheirproperties.
.
overhead to reference implementations reference smart contracts.
we collectfive reference smart contractimplementationsfrompublic repositoriesand priorresearch.
walletis the example shown insection .
crowdsale is from prior research paper .
simpleauction is from solidity documentation .erc20 fungibletokens anderc721 non fungibletokens aretwoofthemostpopularsmartcontractsdeployedonethereum andweusetheimplementationfromtheopenzepplinlibrary .
declarative smart contract implementation.
we implement declarative counter parts for all reference contracts with the same interfacesandfunctionalitieswithoutinstrumentationforrun time verificationorprovenance.thesecontractsconsistof10to18rules column rulesintable1 .
although decon can specify all the high level logic of the these contracts wenotethatthegeneratedsoliditycodehasthefollowing difference from the reference implementations.
first the reference crowdsalecontractisimplementedastwoseparatecontracts.as decon does not yet support contract composition the compiler 1accordingto atthetimeofwritingthispaper thereareabout erc20tokens and erc721 tokens onethereum.outputs a stand alone smart contract with all the functionalities.
fortheerc721contract thereisa safetransferfrom interface which wrapsthe transferfrom functionwithacheck iftherecipientisalso asmartcontract itshouldimplementthe onerc721received interface.
thecurrentimplementationofdecondoesnotyetsupportsuch checkingprocedure whichreliesoncallingthebuilt infunctions ofsolidity sothis interfaceisomitted.
measurementmetrics.
wemeasuretwometrics thesizeof evmbyte codedeployedontheblockchain and thegascostfor eachtransaction.evmbyte codeisgeneratedbythetruffle compiler.tomeasuregascost wefirstdeploythesmartcontract on truffle s local blockchain and then populate the smart contract states by sending transactions from ntest accounts which results innentriesinthecontractstates.thenwecalleachtransaction interfaceagainandrecordgascostreportedbytruffle.wefindthat n 10to1000 doesnotimpactgascost.thisisbecauseallcontracts use hash maps to store contract states.
if the hash collision rate is low the number of instructions is constant to the size of the hash map andthusthegascostremainsconstant.therefore we report the gas costmeasuredwith n .
results.asshownintable themediangasoverheadtoreference implementation is across transactions with of them have evenlowergascostbetween to .intheextremecase the withdrawtransaction from simpleauction shows gas overhead.
weidentifytwosourcesofextragascost longfunctioninvocation chain and inefficient use of data structures.
for example in the wallet example section mint transaction updates the variable totalmint which further updates totalsupply thus adding extra cost than directly incrementing totalsupply as done by the reference implementation.
for data structures relational tables are directly maintained as arrays of tuples with extra information like valid bits and timestamps.
such extra information takes up additional space than their counterparts in solidity implementations.
mitigatingsuchoverheadborrowingideasinsqlexecutionplan optimizationwould be an interestingdirection forfuture research.
decon consumes less gas in some transactions.
in wallet the deconcontracthaslessread writetotheglobalmemory.incrowfunding the reference contract invokesan external call toanother contract whereasdeconimplementseverythinginonemonolithic contract thus eliminating the inter contract transaction cost.
in erc721 deconhasfewerconditionchecksbecausesomeconditions are specified as rules and therefore automatically maintained bythe contract.
intermsofbyte codesize decon scompileroutputisslightly greaterthan thereference programs with a kb simpleauction maximum increase.
note that on crowsale decon s output is smallerthanthereferencecontract.thisisbecausethereference implementstwoseparatecontracts whiletheprogramgenerated by deconcompiler has all functions implemented inone contract.
contractfeaturesthatarenotyetsupported.
duringthesearch ofbenchmarks wefindsomecontractsusefeaturesthatarenotyet supported by decon.
for example the votingcontract from soliditydocumentation checksvotingloopinarecursivemanner.
although recursion can be naturally expressed in decon language the execution of recursion functions requires non trivial reasoning 289esec fse november14 18 singapore singapore haoxianchen geraldwhitters mohammad javad amiri yuepeng wang andboonthauloo table1 overheadofsolidityprogramsgeneratedbydecon comparedtoreferenceimplementations.column rulesshows thenumberofrulesinthedeclarative smart contracts.
contract loc functions rulesbyte code size kb transactiongas cost k reference decon reference compiled diff wallet 3mint burn transfer crowdsale 3invest close withdraw claimrefund simpleauction 4bid withdraw auctionend erc721 11transferfrom approve setapprovalforall erc20 6transfer approve transferfrom median table run time verification overhead.
column sizeand gasshow the overhead in byte code size kb and gas cost k respectively compared to the decon contract without instrumentation.
contract property size transaction gas walletnonegative balance2mint burn transfer crowdsalenomissing funds2invest close withdraw claimrefund simple auctionrefund once 2bid withdraw auctionend erc721every token has owner1transferfrom approve setapprovalforall erc20account balancesaddup to totalsupply1transfer approve transferfrom median toensureterminationandgasefficiency andisthereforenotyet supported by decon.
in addition certain functions that lie outside ofrelationallogic includingcheckinginterfacesofanothercontract e.g.safetransferfrom in erc721 and cryptographic functions arenotyetsupported buttheycanbeincorporatedintodeconvia user definedfunctionsinthe future.
.
run time verification overhead wemeasurerun timeverificationoverheadbyfirstspecifyingproperties for each contract which are generated as instrumentation intheoutputsolidityprogram.theseinstrumentedprogramsare then comparedto deconprograms without instrumentation on byte code size andgas usage.
contractpropertiesarespecifiedasfollows.first asshowninthe example in section the wallet contract is monitored for negative account balances.
the crowdsale contract allows participants to invest in a crowd funding project with a particular funding target.
the property specifies that the total amount of raised fund should equal to all participants investments.
in simpleauction bidders transfer their fund on every bid and get refunds when the auction isended.apropertyspecifiesthateverybiddercanclaimrefund at most once.
in erc721 the property specifies that all existing tokens should have a valid owner non zero address .
in erc20 all account balancesshould add upto the total supply of tokens.
results.
table2showstheoverheadofrun timeverification.bytecodesizesareincreasedbynomorethan2kb.gasusageoverhead varies across different transactions with the median being .
wallet and erc721 contracts show small overhead where transaction gas consumption increases by no more than and respectively.
crowdsale and simpleauction contract come with largeroverhead.thehighestincreaseintheirtransactiongasusage are and .
the erc20 contract incurs the highest overhead where the transferfrom transaction shows109 increase.
related work in this section we survey several lines of research that are related to our work.
run time verification.
similar to decon solythesis also specifies properties as invariants and generates instrumentation 290declarative smartcontracts esec fse november14 18 singapore singapore forrun timemonitoring.itappliestogeneralsmartcontractsimplementedinsolidity whereasdecontargetsdeclarativecontracts only.byrestrictingthescopeondeclarativecontracts bothspecification and monitoring can be performedina more straightforward manner.
invariants become violation queries where joins are analogous to existential quantifiers and aggregations to universal quantifiers.
detection becomes query evaluation which reuses the same procedure for contract execution.
soda is a framework forimplementing generic attackdetection algorithms.
unlike decon where the monitoring procedure isautomaticallygeneratedfromspecification thedetectionalgorithmsinsoda are implementedmanually.
sereum monitorsreentrancyattacksonlineviataintanalysis.
azzopardi et al.
monitors contract execution against legal contract logic.
these two worktargets specific vulnerabilities and propertiesonsoliditysmartcontracts whereasdeconmonitors user specifiedpropertiesondeclarative contracts.
static analysis and verification.
static analysis has been applied todetectgenericvulnerabilitiessuchasreentrancyattacks integerbugs tracevulnerability andevent ordering bugs .
securify translates the evm byte code into stratified datalog andchecks vulnerability patterns using off the shelf datalogsolvers.
alt et al.
translate solidity program into smt formulas and useoff the shelfsmtsolvertoverifycontractproperties.zeus leverages abstract interpretations and symbolic model checking to verifycorrectness andfairnessofsmart contracts.
symbolic execution is another popular techniqueforsmartcontract verification.oyente detects generic predefined vulnerabilities including reentrancy transactionorderdependency mishandledexceptions etc.verx on the other hand allows programmers to specify contract specific propertiesintemporal logic.
fuzzinghasalsobeenappliedtosmartcontracts.forexample contractfuzzer testssmartcontractsforsecurityvulnerabilities.
echidna generates tests that triggers assertion violations.
ilf andharvey focusonimprovingcode coverage.
unlike these work decon monitors properties online which incurs run timeoverhead butdoesnot suffer fromfalse positives or false negatives.
in addition decon targets declarative smart contracts while these tools analyze solidity or evm byte code.
although targeting different languages the underlying verification techniquescanalsobeappliedtodeconandbenefitfromitshigherlevel abstraction.
we believe this is an exciting direction for future research.
domain specific languages for financial contracts.
scilla is a intermediate level language for smart contracts that offers type safety and support for verification.
kevm defines the formal semantics of evm and has been used to verify contracts against erc20 standards.
these languages provides precise formal specificationofsmartcontractdowntothebyte codelevel andare good for verifying low level properties.
in contrast decon focuses onthehighlevelabstractionofsmartcontractsandspecification of contract specific properties.
jones et al.
uses functional programminglanguage to writefinancialcontracts.bitml isa high levellanguageforbitcoinsmartcontracts.basedonprocesscalculus it translates contracts into bitcoin transactions.
decon ontheotherhand isbasedonrelationallogicandtargetsethereum smart contracts.
datalog languages.
decon shares similar syntax with general datalog languages like souffle and is inspired by incremental evaluationtechniquesinsystemslikeddlog .decon however is specific to ethereum smart contracts in the following aspects.
first decon has a number of domain specific language extensions necessary for capturing execution semantics in smart contracts section3 .second deconcompiles datalogtosolidity withseveral domain specific optimizations section .
.
finally decon offers a property specification and run time monitoring feature section4.
whichisessentialsincesmartcontractsaremanaging alot ofdigital assets.
deontic logic for normative knowledge.
gabbay et al.
present a historical overview of deontic logic for normative knowledge.
based on similar principles prakken et al.
overview logic based approaches for legal applications.
decon is a logical systemrepresentingknowledgeinthedomainofsmartcontracts whichenables efficient communicationandautomaticreasoning.
conclusion and futurework we present decon a declarative programming language for smart contract implementation and property specification.
in decon smartcontractsarespecifiedinahigh levelandexecutablemanner thus providing opportunities for efficient analysis and verification bringing clarity to transaction execution via data provenance.
contractsimplementedindecondemonstratecomparableefficiency toopen sourcereferenceimplementation.furthermore run time verification adds moderategas overhead.
ourinitialexperiencewithdeconsuggestsafewexcitingfuture directions.
first we find interesting contracts that require additionallanguagefeatures includingcontractcomposition recursion user defined functions etc.
second there are extreme cases where decon compiler generates contracts with non negligible overhead to the reference hand written code.
decon compiler needs further optimizationtogeneratemoreefficientexecutablecode.third to save the overhead of run time verification we can leverage the high level abstraction of decon programs to perform static verification.
data availabilitystatement the software and scripts for reproducing the experiment results are available online .