hyperion unveiling dapp inconsistencies using llm and dataflow guided symbolic execution shuo yang xingwei lin jiachi chen qingyuan zhong lei xiao renke huang yanlin wang zibin zheng sun yat sen university yangsh233 zhongqy xiaolei6 huangrk9 mail2.sysu.edu.cn chenjch86 wangylin36 zhzibin mail.sysu.edu.cn zhejiang university xwlin.roy zju.edu.cn abstract the rapid advancement of blockchain platforms has significantly accelerated the growth of decentralized applications dapps .
similar to traditional applications dapps integrate frontend descriptions that showcase their features to attract users and back end smart contracts for executing their business logic.
however inconsistencies between the features promoted in frontend descriptions and those actually implemented in the contract can confuse users and undermine dapps s trustworthiness.
in this paper we first conducted an empirical study to identify seven types of inconsistencies each exemplified by a real world dapp.
furthermore we introduce hyperion an approach designed to automatically identify inconsistencies between front end descriptions and back end code implementation in dapps.
this method leverages a fine tuned large language model llama2 to analyze dapp descriptions and employs dataflowguided symbolic execution for contract bytecode analysis.
finally hyperion reports the inconsistency based on predefined detection patterns.
the experiment on our ground truth dataset consisting of dapps shows that hyperion reaches .
overall recall and .
overall precision in reporting dapp inconsistencies.
we also implement hyperion to analyze real world dapps.
the experimental results show that hyperion discovers real world dapps containing at least one inconsistency.
index terms smart contract llm inconsistency detection dataflow analysis symbolic execution i. i ntroduction in recent years the blockchain industry has witnessed a remarkable proliferation of various decentralized applications dapps which have gained substantial popularity and market capitalization .
similar to traditional applications like web or android apps a dapp utilizes a user interface ui as its front end to present feature descriptions and employs smart contracts for back end logic execution.
however inconsistency between the front end descriptions and the actual implementation of their back end contract code of dapps may have detrimental consequences .
for example a dapp might advertise a investment return in its description but the actual return could be changed lower than after investment.
similarly in the case of some nft dapps the front end description may claim that nfts can live forever while in reality the metadata of these nfts is stored on centralized servers which are susceptible to shutdown.
these inconsistencies can pose threats to users interests and undermine the trustworthiness of dapps.
jiachi chen is the corresponding author.many research efforts have been made to detect vulnerabilities in smart contracts to ensure their safety .
however they usually overlook the importance of inconsistencies between the front end descriptions and back end implementations in dapps.
for instance consider a scenario where a dapp offers users a interest rate and does not mention fees traditional vulnerability detection tools may not flag this as an issue.
however when the promised rates in the dapp s description do not align with this or fees are charged secretly it can indicate dishonest behavior of the dapps owners and pose potential risks to dapp users.
the detection of dapp inconsistencies presents unique challenges.
first there is no systematic work aimed at uncovering the various types of inconsistencies within the dapp ecosystem.
this absence makes it not easy to design rules to detect inconsistencies.
second the diverse and intricate structures of dapp front end descriptions present considerable difficulties when attempting to extract information related to user assets.
third it is challenging to recover the semantics from the contract code effectively.
many malicious dapp developers may not disclose their source code on ethereum .
consequently detecting inconsistencies from the bytecode level is crucial but also increases the difficulty.
to address these challenges we first conducted an empirical study employing an open card sorting approach to find dapp inconsistencies.
this involved analysis of both the frontend descriptions and the smart contracts of a dataset comprising dapps see section iii .
based on this approach we define seven types of dapp inconsistencies that encompass both defi and nft dapps namely unguaranteed reward hidden fee adjustable liquidity unconstrained token supply unclaimed fund flow changeable dapp status and volatile nft accessibility .
to automatically detect these inconsistencies we propose a tool named hyperion which contains a description analyzer hyper text and a contract analyzer hyper code.
hyper text leverages llama2 a widely recognized public available large language model llm to scrutinize the diverse natural language descriptions found on dapp websites.
to optimize llama2 for the specific domain task i.e.
extract critical attributes from the dapp front end descriptions we first design a prompt template based on the chain of thought cot prompting technique tailoredarxiv .06037v1 aug 2024to our identified inconsistency types.
then we manually label a dataset containing dapp inconsistencies to finetune llama2 see section iv b thereby enhancing its performance for our downstream task and obtaining our model hyper text.
finally we employ the natural language tool kit nltk to extract inconsistency related attributes from hyper text s output see section iv b2 .
for the analysis of dapp contract bytecode hyper code employs an approach that utilizes dataflow analysis to guide symbolic execution on the contract intermediate representation ir so as to obtain relevant program states and recover contract semantics see section iv c .
specifically hyper code first decompiles the contract bytecode and performs dataflow analysis to recover low level semantics such as contract call and state variable storage access operations.
then it performs a graph analysis based on the recovered semantics to obtain the contract s fund transfer and state variable dependency relationship.
to obtain contract semantics hyper code proposes a symbolic execution framework based on contract ir.
this framework utilizes dataflow and graph analysis to optimize search paths and direct symbolic execution to check relevant program states merging the strengths of both methods.
furthermore we propose algorithms that compare the information extracted from dapp descriptions and contract semantics based on this framework to detect the seven defined inconsistencies unveiling whether one dapp s saying is consistent with its .
to evaluate the performance of hyperion we first collect two datasets one serves as the ground truth dataset containing labeled dapps used to define dapp inconsistencies and evaluate the effectiveness of the hyperion .
the other dataset is used to evaluate the performance of hyperion on analyzing real world wild dapps which contains real world dapps collected from dappbay and dappradar .
hyperion reaches an overall recall of .
and an overall precision of .
in the first ground truth dataset.
furthermore hyperion identifies out of dapps with at least one inconsistency that we define in the second large scale dataset with an overall precision of .
in our sampled dataset.
among the true positives dapps in the sampled dataset we find that dapps websites become inaccessible within only months.
in summary the contributions of our paper are as follows we define seven common inconsistency types between dapp front end description and back end smart contract implementation.
to enhance comprehension we illustrate each inconsistency with a real world dapp example and its consequences.
we design and develop hyperion a tool that leverages llm and dataflow guided symbolic execution to automatically detect defined inconsistencies.
we find out of dapps in our dataset contain at least one inconsistency which demonstrates the prevalence of the defined inconsistencies in the dapp ecosystem.
to promote further research and transparency we have released the source code of hyperion both fine tunedhyper text and hyper code as well as the dapp dataset resources and experimental results in the repository ii.
b ackground a. dapp and smart contract decentralized applications dapps typically leverage smart contract technology to achieve autonomous and transparent operations .
a dapp usually uses a user interface ui that showcases its functionalities to attract users.
some financial related features such as return on investment roi token supply and liquidity are central to user interest and are implemented within the smart contract.
smart contracts are commonly written in high level programming languages e.g.
solidity .
ethereum virtual machine evm is a stackbased virtual machine that executes the contract evm bytecode.
the evm executes transactions by splitting contract evm bytecode into operation codes opcodes each with specific execution instructions.
b. large language model recently large language models llms have exhibited remarkable proficiency in natural language understanding .
notably chatgpt is distinguished by its advanced performance.
however it faces limitations such as limited availability in some regions and high api usage fees.
in contrast llama offers advantages in terms of transparency adaptability cost free access and robust performance in natural language tasks.
these features make llama an ideal model for complicated or unstructured natural language understanding.
additionally the ability of llama in downstream tasks can be further enhanced by its fine tuning capabilities a process of training the model on specific task related labeled data in a supervised manner .
this adaptability is further amplified in the context of instruction tuning which trains models to interpret and act on explicit instructions in diverse tasks.
numerous models have been developed based on llama including code llama optimized for understanding and generating programming code and llama2 which offers enhanced capabilities for natural language processing.
given our specific objective of comprehending intricate natural language data in dapp descriptions we select llama2 as our base model.
iii.
i nconsistencies definition figure illustrates how we define the seven types of dapp inconsistencies.
first we collected dapp descriptions and corresponding smart contracts from two platforms.
then we employed the open card sorting approach to analyze the collected data manually.
finally we defined seven dapp inconsistencies each illustrated with a real world dapp example.
a. data collection we first crawled all dapps labeled as high risk or red alarm by dappradar and dappbay two main platforms that offer detailed information on dapps.
we then removed dapps whose websites are inaccessible for furtheranalysis and manually collected the html of each dapp by visiting their official websites.
next we extracted related smart contract addresses from these websites and collected their source codes from etherscan.
we finally obtained descriptions and smart contracts of dapps.
fig.
.
workflow of defining dapp inconsistencies.
b. data analysis to find dapp inconsistencies three authors use the open card sorting approach which is widely adopted in problemfinding and definition in software engineering .
in this process we first created a card that contains the front end description and the contract code for each dapp.
we considered two aspects to ensure the significance of the inconsistency issues namely user financial related information in dapp descriptions e.g.
promised return on investment claimed fees charged and the stability of the token economy and corresponding financial related code logic in smart contract implementations.
these aspects are highly related to users profits or assets and are usually the major concern of users.
then three authors worked together to determine the labels for each card.
they followed the detailed steps illustrated in the previous problem definition works .
there are three steps in the open card sorting process.
in the first step they randomly chose of the cards and read the dapp descriptions.
they extracted the claims that are related to users funds or assets e.g.
our dapp pays daily for users orwe charge another fee for marketing etc.
similarly they read the contract code and focused on the implementations related to the fund transfer or tokens.
they checked the transfer target the transfer amount and other attributes related to the assets.
for those contracts without source code they used an online decompiler and analyzed the contract ir.
based on the two aspects of information extracted from the dapp description and the smart contract they compared them and understood the inconsistencies.
in the second step of card sorting the same three authors analyzed and categorized the remaining cards independently following the same steps as in the first round.
meanwhile if they encountered new descriptions or contract implementation related to users funds or assets other than what they found in the first round e.g.
daily reward they kept the cards to the final discussion.
in the third step they compared the results discussed the differences and finally identified seven types of inconsistencies across dapps from all the collected dapps.
the remaining dapps found no further inconsistencies or had no financial related codes or descriptions during the open card sorting process.
we established the mapping relationshipbetween the filtered dapp and the defined inconsistencies which is publicly available in our repository.
c. definition of dapp inconsistencies table i shows the definition of seven inconsistency types between the dapp front end descriptions and smart contracts.
the third column highlights the inconsistency types and to clearly show each inconsistency we list both the illustration of front end descriptions and the implementation of smart contracts columns fourth and fifth .
our defined inconsistencies cover nft and defi dapps.
the following paragraphs provide the corresponding detailed definition and example for each inconsistency.
unguaranteed reward ur rewards are pivotal in incentivizing user investment in dapps.
some dapps advertise high rewards to attract investments but inconsistencies between these advertised rewards and the contract s actual implementation can deceive users.
such inconsistencies might lead to users not receiving the guaranteed rewards or even resulting in financial loss.
fig.
.
dapp descriptions top and contract snippet bottom of bnb ultra .
example descriptions on bnb ultra figure might mislead users that they can obtain a daily profit of .
an examination of the contract reveals that the reward is not guaranteed.
specifically line indicates that the user reward comprises two components i.e.
the value of eggs andbasefee .
the value of eggs is determined by the function calculatetrade line depending on variable marketeggs and contract balance.
this implementation means that the promised reward rate is subject to undetermined variable factors contradicting the front end claim.
fig.
.
dapp description top and contract snippet bottom of milky token.
hidden fee hf dapps often charge fees to maintain their operations compensating for resources such as management efforts.
however issues arise when these fees are eithertable i definitions of the da ppinconsistencies .
general type dapp type inconsistency type front end description smart contract implementation mathematicsdefiunguaranteed reward ur claim a reward of x reward rate is not a guaranteed constant value hidden fee hf not claim fee or claim fee as x fees are charged with a rate of y y!
x transparencyadjustable liquidity al claim x years of liquidity lock time the lock time are adjustable to be less than x defi nftunconstrained token supply uts claim a token supply of x the supply can be bigger than x unclaimed fund flow uff not claim the possible fund flow to the project owner the contract fund can be withdrawn by specific users changeable dapp status cds not claim the possible pause of the dapp the dapp can be paused to impede trading nft volatile nft accessibility vna not claim the accessibility of nfts or claim they are accessible the nfts can be inaccessible undisclosed on the dapp s front end description or differ from the actual contract implementation which can unexpectedly impact user assets and compromise the dapp s trustworthiness.
example returning to bnb ultra the final reward for users is reduced by fees directed to predetermined addresses figure line .
specifically lines show fees being allocated to three different addresses with the total fee amount determined by the devfee function line .
however this fee structure is not disclosed in the dapp s front end description figure resulting in a hidden fee inconsistency.
unconstrained token supply uts many dapps have their native tokens e.g.
aave and bayc .
setting the maximum supply of tokens can uphold tokens scarcity stabilizing the market.
inconsistencies between the stated token supply and actual contract code can detrimentally affect token holders by affecting the token s value and scarcity .
example descriptions about the milky token claims a total supply of 250m figure .
however the contract line allows one to mint tokens without a supply cap.
adjustable liquidity al liquidity lock time refers to a period during which some users e.g.
token project managers cannot withdraw their tokens.
the liquidity lock time in defi dapps is crucial for stability offering a stable pricing environment and encouraging prolonged asset holding.
inconsistencies in this aspect such as unaligned claims or adjustable lock times may cause market instability and compromise the interests of investors.
fig.
.
description top and contract snippet bottom of baby bnb tiger .
example baby bnb tiger claims a year liquidity lock figure .
however its contract allows the owner to modify this time line through the lock function arbitrarily.
unclaimed fund flow uff most dapps allow users to deposit or transfer funds to make profits.
in some cases dapp owners may have the capability for emergency withdrawals.
however transparency is important for users.
failure to disclose this capability can significantly risk user assets and lead to a loss of trust in the dapp ecosystem.
example the dapp metarevo figure does not disclose that the owners have the ability to transfer users assets in front end descriptions.
however its contract allows theowner to withdraw all balances line via the cleareth function lines .
1function authnum uint256 num public returns bool require msgsender auth permission denied authnum num return true 5function cleareth public onlyowner require authnum permission denied authnum msg.sender .transfer address this .balance fig.
.
contract code snippet of metarevo .
changeable dapp status cds the pause function in dapps provides developers with the capability to manage unexpected events security issues or implement updates .
however the lack of information about the pause status for users may result in failed transfers eroding trust in the dapp.
example in the balancenetwork dapp the pause functionality is not publicly disclosed figure .
the pause function lines allows the owner to pause the dapp which stops the trading system by restricting the transfer function lines by whennotpaused modifier.
1function pause onlyowner whennotpaused external paused true emit pause 4function transfer address from address to uint256 value internal whennotpaused ... balances value balances value fig.
.
contract code snippet of balancenetwork .
volatile nft accessibility vna nfts represent digital ownership of unique assets on the blockchain .
however storing nft metadata on centralized servers while claiming its permanence introduces inconsistencies.
centralized storage is susceptible to shutdowns or issues conflicting with the promise of permanence and longevity.
to ensure durability decentralized solutions such as ipfs and arweave are recommended for storing nft metadata.
fig.
.
description top and contract snippet bottom of cryptoz universe .
example cryptoz universe nft claims its nfts can live forever on the blockchain figure .
however its smartcontract uses https for metadata storage line .
when this server was shut down the nfts became inaccessible hurting user benefits and contradicting the claim of permanence.
iv.
m ethodology in this section we introduce our tool hyperion which is capable of detecting the seven types of inconsistencies defined above by analyzing dapp descriptions and smart contracts.
a. overview figure shows an overview of the hyperion which has three components namely description analysis contract semantic analysis and inconsistency detection .
fig.
.
overview of h yperion approach.
the input of hyperion contains two parts i.e.
front end description can be a dapp url html or text and back end contract code.
fordescription analysis the dapp descriptions are first parsed as raw text and then concatenated with our designed prompts through hyper text which is obtained by llama2 instruction tuning see section iv b .
next nltk is employed to extract inconsistency related attributes from the output of hyper text llm responses which are used for further comparison with the contract semantics.
incontract semantic analysis hyper code first decompiles the contract bytecode using elipmoc to recover the cfg and the contract ir.
hyper code then performs dataflow analysis on this ir to extract inconsistency related semantics such as fund transfers.
this analysis includes constructing fund transfer and storage variable dependency graphs that guide targeted symbolic execution on the ir to trace inconsistency related paths.
furthermore the smt solver validates program states collaborated with on chain state extraction thus identifying contract semantics.
finally in inconsistency detection hyperion incorporates the attributes extracted from dapp descriptions and contract semantics to identify inconsistencies based on defined rules.
b. llm based dapp description analysis in this subsection we give details of how we extract attributes related to inconsistencies from the dapp description.
instruction tuning in this part we introduce the process of obtaining our hyper text model.
we adopt llama2 as our base model due to its adaptability cost free access and excellent performance in natural language tasks see section ii b .
to make llama2 perform well in our downstream dappdescription analysis task we propose an instruction tuning approach as depicted in figure .
specifically after we obtain the raw text of the description we first design specific prompts to improve the model s efficacy in yielding the specific desired attributes we want to extract.
next we adopt a prompt segmentation method to fix issues caused by long input.
then we perform instruction tuning with manually labeled dapp descriptions and finally get our model h yper text.
fig.
.
workflow of llama2 instruction tuning.
fig.
.
prompt template of numeric inconsistency related information.
prompt design.
llms operate on a prompt based learning approach with prompt design crucially impacting performance .
we adopt llama2 s recommended prompt structure comprising a system prompt sp and a user prompt up .spdefines the model s role r e.g.
requiring the model to act as a smart contract expert and includes general instructions gito ensure accuracy e.g.
requiring the model to avoid sharing false information .
the user prompt up is divided into upitand chain of thought upcot components.
specifically upitdirects llm to analyze and extract specific kinds of inconsistency related information types i.e.
numeric and boolean.
figure and figure show the prompt templates for extracting numeric and boolean inconsistency related information respectively.
for generating numeric values like rewards or fee rates the prompt directly instructs the llm to extract numeric values from the provided dapp description .
however when generating boolean values which are not explicitly stated in the description the prompt does more than just instruct the llm to answer with yes or no.
it also utilizes cot chain of thought patterns to construct upcot which guide the llm in deducing the answer by providing key phrase explanations e.g.
dapp pause the storage way of nfts and illustrative examples.
this approach helps the llm interpretand infer boolean values from the context.
the complete prompt template for dapp description analysis is formalized as p sp r gi up upit upcot d where drepresents the raw text of the dapp description.
fig.
.
prompt template of boolean inconsistency related information.
prompt segmentation.
the maximum number of tokens that llama2 can process in a single prompt is .
however the token length of some dapp descriptions in our dataset exceeds this limit which yields incorrect answers and unwanted output.
to address this issue we segment the raw text of the dapp description dby setting a token limit.
every segmentation diis further concatenated with the design prompt sp andup to construct the prompt pi.
through experimentation we find that a limit of tokens per segmentation yields the best results compared to and .
this choice effectively handles lengthy descriptions without significantly impacting llm s comprehension abilities.
although segmentation can result in incomplete sentences llms are skilled in contextualunderstanding which allows them to interpret meaning and maintain coherence with fragmented input preserving their overall comprehension and effectiveness.
instruction tuning.
to enhance llama2 s effectiveness for our specific task we further instruction tune the model using labeled data on dapp inconsistencies .
specifically we first segment the raw text of the dapp descriptions adhering to the tokens per segmentation and then construct the llama2 instruction according to our designed prompts p for every segmentation.
however this step yields some wrong responses and useless information e.g.
multiple lines of empty spaces without any text.
to refine llama2 s responses we remove redundant words while only retaining outputs that contain the relevant information and correct any inaccuracies.
the revised responses form the basis of our training dataset which aligns with the structure of the alpha dataset as defined by the llama2 official fine tuning project .
the format can be represented by the tuple instruction input output where instruction refers to the user prompt up input represents dapp description raw text d and output denotes the adjusted llama2 response.
after that we adopt lora a famous peft parameter efficient fine tuning method to train the learnable parameters for our inconsistency information extraction task based on our training dataset.
the above process achieves an precision on our test dataset comprising labeled dapp descriptions section iii b and we finally obtain our model hyper text.
due to page limitation we provide a detailed fine tuning process in our open repository.
inconsistency related attributes extraction the output generated by hyper text comprises several sentences assessing the presence of inconsistency related information within the dapp descriptions.
however these outputs vary in format necessitating the extraction of uniformly formatted key value attributes for further comparison with the contract semantics.
in our experiments we find that directly extracting keyvalue attributes using llm is inefficient and often inaccurate.
to address this challenge we employ the nltk to extract inconsistency related information from llm answers and unify them into the key value format attributes.
for instance to find the reward rate from hypertext s answer we first tokenize the sentences and use pos tagging to label the words.
then we scan for keywords like reward and its synonyms extended by nltk wordnet.
the final result is located around the keyword and we obtain the numeric value based on the digit word tag and symbol .
it is straightforward to extract the yes or no boolean symbols from hypettext s answers as shown in the template figure .
we directly extract the boolean value from the llm response.
c. contract semantic analysis this subsection details how hyper code recovers highlevel semantic features related to inconsistencies from lowlevel bytecode.
the analysis can be divided into three parts i.e.
decompilation and dataflow analysis graph analysis and ir based symbolic execution.
decompilation and dataflow analysis for contract bytecode analysis we utilize elipmoc for decompilation.
elipmoc converts evm bytecode into a high level ir structured in static single assignment ssa form and delineates function borders.
utilizing this ir we perform dataflow analysis with datalog rules to extract essential semantics for subsequent graph analysis and symbolic execution.
this includes defining core irs related to storage external calls and data flow.
instruction sstore s y z x sload s y call s arg x callpriv ate pf arg returnpriv ate t v x phi y z letters x y z t v denote the variables declared in the ir.
the variables pfandargrepresent the private function and call arguments respectively and sdenotes the ssa statement in which an instruction lies.
the semantics of the first three instructions are the same as those of the evm opcodes.
the storage write instruction sstore s y z signifies that the statement swrites variable zto the storage address y. and x sload s y represents the variable xloaded from the storage address yin statement s. instruction call s arg denotes the statement sexecutes the external contract invocation with arguments arg.
the final three instructions unique to elipmoc ir pertain to dataflow and control flow within the ir.
instructions callpriv ate andreturnpriv ate are involved in private function calls x callprivate pf arg calls the private function pfwith arguments arg and xcaptures the return value.
the returnprivate t v instruction facilitates returning variables vto the caller at target t. lastly the x phi y z instruction indicates the flow of variables yandzto x playing a pivotal role in dataflow within the ir.
based on the instruction semantics above we summarize the high level semantics in table ii that we adopt to formulate our dataflow and semantic recovery rules.
the first eight relations in the table are supported by elipmoc while the remaining three rules are induced on the basis of the eight relations which recover a higher level semantic of contracts.
according to the definition of the seven dapp inconsistencies there are three of them related to transfer funds ur hf uff while the other four are about reading and writing storage al uts cds andvna .
therefore our analysis primarily revolves around two types of operations fund transfer and specific storage access store and load crucial for pinpointing inconsistencies in contract bytecode.
the first induced relationship is transfer transfer operations are extracted by identifying call operations in the contract bytecode.
from the collected dataset for finding inconsistencies there are two types of transfers i.e.
ether and erc20 token transfer.
erc20 token transfers are identified through the function signatures mandated by the erc20 standard transfer andtransferfrom with respective function signatures 0xa9059cbb and 0x23b872dd .
in contrast ether transfers are characterized by those call operations which uniquely do not utilize memory arguments for the call target andtransfer amount referring to the call instruction semantics .
hyper code identifies these transfer operations and uses rules to to determine the critical call sites in the ir.
ca cs r ca cs a ec cs fs c fs xa9059... sf cs cf transf cs r a cf ca cs r ca cs a ec cs fs c fs x23b87... sf cs cf transf cs r a cf !ca cs call cs r a sf cs cf transf cs r a cf the second induced relationship is senderguard which helps us analyze whether some operations are restricted to specific users e.g.
check whether the function caller is the owner.
this relationship is induced by the following rule .
when a statement sretrieves variable xfrom storage slot y and subsequently compares xwith the function s caller we can deduce that function cfincorporates a sender verification mechanism.
this process helps us to identify privileged users within the contract.
x sload s y sf s cf comp x caller sg y cf the other key induction storageinfer is to recover semantics about storage inference.
our approach involves deducing five distinct types of storage variables from the ir by identifying characteristic features of storage operations.
these types include owner time supply pause and token uri.
recognizing these variables is essential for pinpointing operations that interact with inconsistency related variables.
for example to determine the storage slot for the owner variable that represents the contract owner or privileged users we utilize rule .
if a contract implements the function f owner with a specific signature sha f we infer that the return variable loaded from slot yis indicative of the owner variable.
in scenarios where owner is not explicitly defined we resort to pattern matching based on the senderguard sg induction.
specifically a variable loaded from slot yand compared with thecaller indicates the owner variable is stored in slot y. x sload s y sf s cf c fs sha f controls x sg y cf stowner y cf in our approach the identification of function signatures is a critical step.
we refer to standard interfaces defined in ethereum improvement proposals eips and utilize widely recognized third party libraries such as openzeppelin .
this technique allows us to quickly locate critical variables in the contract s bytecode which is also adopted by other works .
we use this method to find the storage of variables that represent the token supply e.g.
totalsupply the dapp pause status e.g.
pause and the token uri e.g.
tokenuri of the nft from contract bytecode as shown in rule .
for contracts lacking these standard function implementations our strategy involves a detailed analysis of operational sequences and constraints in the bytecode.
we have crafted specifictable ii contract ir level semantic relations relation notation description constant c x v variable xis inferred to denote a constant value v externalcall ec cs addr fs call the function fsof the contract addr at the call site cs controls controls x s variable xdetermines whether the statement swill be executed mathop x math op y z variable yandzare two elements of the math operation op callarg ca cs x i variable xis the ith parameter of the external call whose call site is cs funcarg fa fs x variable xis the argument of the function whose signature is fs dataflow df x y the value of the variable xwill flow to the variable y statementfunc sf x y the statement xis in the public function y transfer transf cs r a cf the variables randaare the recipient and the transfer amount of call site cs respectively in the function whose signature is cf senderguard sg x cf the variable loaded from storage slot xis inferred to be compared with caller in function whose signature is cf storageinfer st var x cf variable var is inferred to be stored in slot xin function with signature cf patterns based on source code level features derived from our ground truth dataset for defining inconsistencies.
these patterns facilitate the identification of storage locations by extracting unique features and constraints within the bytecode.
the rules from to outline our variable semantic recovery patterns.
for example rule is employed to identify the state variable storing the dapp s liquidity lock duration.
we ascertain whether the arguments of a public function x combined with the current timestamp derived from timestamp flow to a variable z stored in slot y. represented semantically as lock now x where xis user defined lock time and now is the current timestamp slot yis inferred to store the lock time.
likewise we look for the add operations rule and the control semantics rule to infer the storage of the token supply and the pause variable respectively.
due to the page limit please refer to our repository for more details.
x sload s y sf s cf c fs sha f stx y cf x sstore s y z timestamp t df t z fa fs x df x z sf s cf sttime y cf x sload s y r mathop x sstore a y r df r r stsupply y cf x sload s y sf s cf controls x a sstore a y t c t true stpause y cf graph analysis after we recover the high level semantics of the ir of the contract we construct a graph to obtain the connection between the critical information that we extracted in the contract.
this graph contains two subgraphs i.e.
the fund transfer graph ftg and the state variable dependency graph sdg .
these subgraphs facilitate our analysis of contract semantics particularly in relation to inconsistency attributes.
the graph construction is grounded on three key relations transfer senderguard and storageinfer .
the transfer cs r a cf relation is utilized to identify recipient nodes and the corresponding transfer amount edges for each transfer operation.
we also identify whether the transfer amountto some nodes is part of the amount transferred to users to identify receiving fee operations and whether there exists a recipient who can withdraw the contract balance.
for state variable dependencies we start by identifying state variable nodes e.g.
stx using stvar x cf .
then through thesenderguard relationship we determine state variables that are conditionally manipulated based on sender verification e.g.
pause status stpause is controlled by the owner .
this step is crucial for mapping the complex dependencies of state variables within the contract and finding those privileged operations.
in our graph analysis we delve into the roles of recipients and their associated high level features.
additionally we organize the extracted information at the function level to guide our subsequent symbolic execution.
two essential features are extracted for this purpose ftg cs r a cf p and sdg cs x cf d where pdenotes the inferred privileged owner e.g.
who can withdraw the contract balance and d represents the dependency relationships among state variables.
ir based symbolic execution with the extraction of basic features completed we proceed with an ir based symbolic execution framework to obtain runtime states and validate critical attributes.
the ir distinct from evm opcodes features unique instructions as detailed in section iv c .
the interaction between identified public and extracted private functions is managed by callprivate andreturnprivate instructions which facilitate parameter and result passing in ir cfg.
the phi instruction is critical in merging variables from divergent control flows.
the first element indicates the in loop variable that determines the loop exit condition while the second acts as an out loop bound checker.
due to page limitation we show an exemplary ir cfg in our repository.
based on the ir cfg illustrated above hyperion builds an extensible symbolic execution framework from scratch that makes use of the completeness of ir cfg while incorporating the semantics of each instruction and the dataflow analysis results.
to guide the symbolic execution process we use dataflow information to monitor critical variables involved in key operations and their flows e.g.
variables flow from and to storage slots via sstore and sload to formulateinduction rules.
graphs extracted based on contract semantics using dataflow analysis and datalog rules label key variables e.g.
transfer amounts and statements e.g.
external calls at the function level.
they also highlight dependencies among core state variables e.g.
which state can be changed by the contract s privileged user.
these graphs record information identical to the contract ir operated by symbolic execution guiding which functions to test which variables to load and at which program point to check the execution states.
this framework can support our testing during symbolic execution and check critical states for contract semantics recovery which is also extensible for programming more rules.
d. inconsistency detection to detect the inconsistencies the frontend analysis yields key value information for critical attributes e.g.
fee rate.
the backend analysis maps these attributes to key variables e.g.
transfer recipient and amount token uri and operations e.g.
ether token transfer contract states modification that are identified using induction rules and graph analysis during symbolic execution.
specifically the attributes extracted by hyper text are denoted as f with each attribute afassigned a numeric n or boolean b value v based on the inconsistency type.
for contract semantics hyper code identifies attributes ab and their values v as well as expressions fexpr from symbolic execution se .
f af v v n b b ab v fexpr v n b fexpr se to facilitate this detection hyperion utilizes public nodes via the web3 api employing methods like getcode for bytecode retrieval and getstorageat for accessing specific storage data.
in total our hyperion supports inconsistency detection across blockchain platforms.
urinconsistency is flagged when the dapp s description cites a fixed reward rate af r .
yet the contract s semantic analysis reveals a transfer amount fexpr tadependent on dynamic factors like contract balance with the transfer target fexpr ttbeing the user caller .
in hfinconsistency detection hyperion examines dapp descriptions for fee claims and analyzes contract semantics for transfer amounts to specific addresses.
an example involves symbolically expressing the transfer amount as bvudiv i ia store iv with hyperion then querying public nodes for corresponding storage values to calculate and compare fee rates ia store1 against those mentioned in the dapp description.
the modifiable status of fee variables is also reported through sdg.
uff inconsistency is identified when the dapp description omits mention of fund withdrawal by specific or privileged users yet contract semantics suggest otherwise.
foralinconsistency hyperion assesses both the frontend lock time description and the contract s ability to modify this duration.
an inconsistency is noted if the lock time is alterable irrespective of whether users are informed or not.
in uts analysis hyperion contrasts the front end description with the contract s token minting capabilities.
two scenarios are flagged as inconsistencies when a limited token supply is claimed but the contract allows unconstrained minting when the front end does not explicitly mention any limit on the number of tokens but the contract is designed to support unconstrained minting.
for the boolean inconsistencies cds andvna hyperion extracts the boolean value inferred from the dapp description.
the modifiability of the dapp status can be obtained from contract semantics by rule when performing symbolic execution so as to report the cds inconsistency.
to obtain the storage way of nfts we request the public node to obtain the base uri of dapp nfts considered as the prefix of stored metadata of nfts which is stored in the inferred variable from contract semantics.
we judge whether the nft is stored in decentralized storage services such as ipfs and arweave or in centralized ways https and base64 from this prefix.
hyperion compares this information with the storage way inferred from the description to report vna.
v. e valuation a. experiment setup the experiment was conducted on a server running ubuntu .
.
lts and equipped with intel r xeon r platinum 8336c .30ghze cpus and nvidia a800 80gb pcies.
dataset.
we used two datasets to evaluate hyperion .
the first one is the ground truth dataset which contains dapps we labeled for inconsistency definition in section iii b .
the second dataset contains real world dapps with their available html files contract addresses and platforms.
notably hyperion is compatible with contracts written in solidity regardless of whether they are deployed on ethereum e.g.
bnb chain polygon .
we crawled them from the defi and nft categories on dappradar and dappbay.
evaluation metrics.
we summarize the following research questions rqs to evaluate h yperion .
rq1.
how effective is hyperion in detecting inconsistencies in our ground truth dapp dataset?
rq2.
how is the performance of hyperion in detecting inconsistencies in the large scale dapp dataset?
rq3.
what is the efficacy of hyper text andhyper code in analyzing dapp descriptions and contract semantics respectively?
b. answer to rq1 effectiveness in the ground truth dataset to answer rq1 we run hyperion in our ground truth dataset of dapps.
the detection result is shown in table iii which outlines the number of each type of inconsistency incs in the dataset true positives tp correctly identified false negatives fn not detected and false positives fp wrongly identified by hyperion .
we use formulas tp tp fn and tp tp fp to calculate the recall rec and precision prec rate respectively.
furthermore we also calculate the overall precision and recall of hyperion on the ground truth dataset.
using overall precision as an example the overall result can be calculated by the formulapn i 1pci ci pn i ci in which pcirepresents the precision to detect inconsistencies i and ci is the number of inconsistencies i. this method is also adopted by other works .the results show that the overall precision and recall of hyperion are .
and .
respectively.
the detailed false negative and false positive analysis is discussed and illustrated in our answer to rq3 see section v d .
table iii detection result in ground truth dataset .
dapp inconsistency incs tp fn fp rec prec unguaranteed reward .
.
hidden fee .
.
adjustable liquidity .
.
unconstrained token supply .
.
unclaimed fund flow .
.
changeable dapp status .
.
volatile nft accessibility .
.
c. answer to rq2 detection in a large scale dataset to answer rq2 we run hyperion on unlabeled dapps obtained from dappradar and dappbay.
the experimental results given in table iv the second and third columns show the frequency of each dapp inconsistency in this dataset.
to evaluate the performance of hyperion in finding inconsistencies in the large scale dataset we refer to a random sampling method based on the confidence interval to generalize the population of the total number of problems found for this inconsistency which is also adopted in the previous works .
specifically to establish the sample size of each inconsistency we set a confidence interval of and a confidence level of and calculate the number of samples s the fourth columns in table iv that we need to collect .
the calculated results of the seven inconsistencies are and respectively.
the evaluation dataset is then randomly sampled according to the result and manually labeled by three authors of this paper.
we analyzed all the reported samples of urandalas the total number reported is close to the calculated number that should be sampled for these two inconsistencies.
table iv detection result in large scale dataset .
dapp inconsistency incs per s tp fp prec unguaranteed reward .
.
hidden fee .
.
adjustable liquidity .
.
unconstrained token supply .
.
unclaimed fund flow .
.
changeable dapp status .
.
volatile nft accessibility .
.
the fifth and sixth columns in table iv show precision evaluation on the randomly sampled dataset divided into tps and fps we manually labeled all dapp with ur and alinconsistencies to make the results more reliable which is also adopted by other related works .
the precision rate of hyperion in the analysis of each inconsistency is shown in the seventh column.
the results show that for ur hf uts and uff inconsistencies hyperion reports them with a precision of .
.
.
and .
respectively and reaches a precision of when analyzing other types of inconsistency.
our tool hyperion reaches an overall precision of .
.
in addition we have further checked tps dapps from the sampled dataset based on hyperion s reports.
we find that of them are now inaccessible within just months.
of the remaining accessible dapps .
dapps are labeled ashigh risk by dappradar.
these numbers underscores the threats these dapps pose to users assets.
d. answer to rq3 evaluation of respective performance we observe that hyperion has some fp and fn in the former two rqs.
however we do not know whether these inaccuracies are stemmed from hyper text orhyper code.
therefore we propose rq3 evaluating hyperion s two analyzers performance respectively.
our evaluation utilizes the ground truth dataset in rq1 and the randomly sampled dataset used in rq2.
hypertext the development of hyper text involved multiple evaluations and experiments mentioned in section iv b .
starting with the design of effective prompts we progressed through prompt segmentation and instruction tuning our model.
due to the page limit detailed experimental results and related datasets are presented in our open repository.
for the performance evaluation three authors manually reviewed the dapp descriptions and the corresponding outputs of our hyper text.
this involved reading the website pages and verifying the accuracy of extracted attributes.
in the ground truth dataset we noted instances where hyper text failed to extract reward or fee information from dapp descriptions leading to missed inconsistency.
the precision and recall of hyper text are and .
.
in the large scale dataset we find that hyper text exhibited misclassification errors due to the existence of prompt keywords.
for example in the dapp alchemix hyper text mistakenly categorized the text total expected supply after years as token supply information misled by the keywords total and supply despite the context indicating a time duration rather than token quantity.
the overall precision of hyper text in the largescale dataset is .
.
additional examples of hyper text s incorrect responses are available in our repository.
hypercode to evaluate hyper code we compare its output against the contracts code to identify fns and fps.
the precision and recall of hyper code in the ground truth dataset are .
and .
respectively and the precision in the large scale dataset achieves .
.
false negatives.
to analyze false negatives we refer to the ground truth dataset used in rq1.
we find that there are some fns of urand hfinconsistencies due to path explosion in symbolic execution and missing detectable fee transfer operations.
hyper code sets constraints such as path search depth and loop iteration limits to avoid the path explosion which contributes to its inability to reach deep checkpoints in the ir cfg of some complicated contracts.
in detecting hfinconsistencies hyper code misses cases where state variables storing fees are not part of the transfer operation.
consequently even if there is an inconsistency between the dapp description and the actual fee rate stored in the state variable the absence of a detectable fee transfer operation results in false negatives.false positives.
to identify uts inconsistencies our hyper code uses the erc interface totalsupply to locate the state variable for total token supply.
however some contracts do not directly return this variable when implementing the interface.
for instance contracts using currentindex starttokenid or alltokens.length for total supply deviate from our pattern.
moreover an fp is noted where the condition check occurs after adding to the total supply state variable contradicting our pattern of requiring a protective comparison before such an addition.
hyper code incorrectly identifies split payments to preset addresses as fee transactions which could actually be regular payments.
for example a contract s payment function lines to splits the user s payment between two trusted wallets .
in contrast to being a hidden fee it is merely a division of a user s payment across two accounts.
for uff false positives exist when the contract logic actually stipulates transferring all remaining funds when the balance is insufficient for the user s earnings.
when detecting ur hyper code incorrectly views percentage based transfers as a profit distribution while the function s purpose is to manage funds stuck in the contract.
specific samples are provided in our repository.
furthermore the dataflow analysis on the decompiled ir reduces the .
of functions to be tested on average in our large scale experiments when hyper code performing irbased symbolic execution improving the detection efficiency.
comparison experiment.
we conducted a survey on works published in top journals conferences on se security and found that the proposed inconsistencies have not been covered before while nftguard and pied piper have similar detection patterns for contract semantics of uts and uff respectively.
we compare hyper code with nftguard as piped piper is not fully open source missing the fuzzing part .
we randomly select dapps from the large scale dataset and collect their contract sourcecode nftguard only supports sourcecode .
the result shows that hyperion finds problematic uts contract behaviors with a precision of while nftguard does not report any bugs.
details are provided in our repository.
vi.
t hreats to validity external validity.
our approach employing the symbolic execution technique faces challenges due to the increasing complexity of dapp contracts .
this complexity can lead to a path explosion issue making it difficult to analyze deeper program points.
additionally our dataflow analysis presents a limitation in accurately recovering dataflow through struct data types.
in description analysis despite instructingtuning the llama2 we encounter instances of information misidentification.
this issue partly stems from the inherent nature of llms where subtle nuances in data or prompts can influence output accuracy.
however identifying specific error causes or model misinterpretations remains a challenge.
however hyperion can be improved by an instruction tuning process with a larger labeled dapps dataset and more rules to identify complicated data structures in the contract.internal validity.
our manual labeling process for llm construction and evaluation might introduce errors particularly in differentiating between fns and tps.
to mitigate this we implement a double check procedure and continuously update our dataset to ensure accuracy.
all experimental results and evaluations are transparently shared in our repository.
vii.
r elated work inconsistency detection in dapps.
several previous works focus on unexpected behaviors in dapps.
for instance dapphunter assesses consistency among user intentions blockchain wallet transactions and contract behaviors though it does not delve into contract bytecode or dapp descriptions analysis.
vetsc detects discrepancies between contract bytecode and dapp category rules deduced from the text around dapp buttons or widgets.
our approach hyperion introduces a broader scope of inconsistency bridging the gap between dapp descriptions and contract behaviors using natural language understanding and program analysis.
smart contract security issues detection.
recently many program analysis tools have been developed to focus on detecting security problems in smart contracts.
static analysis tools like are widely used for security issue detection.
dynamic testing tools along with machine learning approaches also contribute to this landscape.
however to the best of our knowledge hyperion is the first tool incorporating both description analysis and contract semantics extraction to report newly found inconsistencies.
inconsistency detection of traditional applications.
there are some related works focusing on detecting trustworthiness and inconsistency issues in mobile and web applications .
however the inexistence of a framework with rich semantics in the smart contract programming language poses unique challenges to contract bytecode analysis.
the immutable nature of blockchain transactions and financial attributes highlights the risks of dapp inconsistencies.
our work specifically addresses this challenge and bridges the gap to enhance the dapp ecosystem s security assisting developers users and marketplaces in identifying inconsistencies.
viii.
c onclusion in this paper we define seven types of dapp inconsistencies from an empirical study and introduce hyperion a tool using llm and dataflow guided symbolic execution to identify inconsistencies between dapp descriptions and smart contract implementations automatically.
hyperion instruction tunes llama2 for dapp description analysis and utilizes dataflowguided symbolic execution for contract bytecode analysis.
the experimental results show our hyperion s effectiveness in unveiling dapp inconsistencies with an overall precision of .
and an overall recall of .
.
acknowledgment this work is partially supported by fundings from the national key r d program of china 2022yfb2702203 the national natural science foundation of china .