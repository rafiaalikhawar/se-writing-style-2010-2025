tumbling down the rabbit hole how do assisting exploration strategies facilitate grey box fuzzing?
mingyuan wu research institute of trustworthy autonomous systems southern university of science and technology shenzhen china mail.sustech.edu.cnjiahong xiang research institute of trustworthy autonomous systems southern university of science and technology shenzhen china xiangjh2022 mail.sustech.edu.cnkunqiu chen southern university of science and technology shenzhen china mail.sustech.edu.cn peng di ant group hangzhou china dipeng.dp antgroup.comshin hwei tan concordia university montreal canada shinhwei.tan concordia.caheming cui the university of hong kong hong kong china heming cs.hku.hkyuqun zhang research institute of trustworthy autonomous systems southern university of science and technology shenzhen china zhangyq sustech.edu.cn abstract many assisting exploration strategies have been proposed to assist grey box fuzzers in exploring program states guarded by tight and complex branch conditions such as equality constraints.
although they have shown promising results in their original papers their evaluations seldom follow equivalent protocols e.g.
they are rarely evaluated on identical benchmarks.
moreover there is a lack of sufficient investigations on the specifics of the program states explored by these strategies which can obfuscate the future application and development of such strategies.
consequently there is a pressing need for a comprehensive study of assisting exploration strategies on their effectiveness versatility and limitations to enlighten their future development.
to this end we perform the first comprehensive study about the assisting exploration strategies for grey box fuzzers.
specifically we first collect nine recent fuzzers representing the mainstream assisting exploration strategies as our studied subjects and real world projects to form our benchmark suite.
after evaluating the subjects on the benchmark suite we then surprisingly find that the dictionary strategy is most promising since it not only achieves similar or even slightly better performance over the other studied assisting exploration strategies in terms of exploring program states but also is more practical to be enhanced.
accordingly we propose cdf uzz which generates a customized dictionary for each seed upon the baseline fuzzer afl to improve over the original dictionary strategy.
the evaluation results demonstrate that cdf uzz increases the edge coverage by .
on average for all benchmark projects over the best performer in our study i.e.
afl with the dictionary strategy .
cdf uzz also successfully exposed previously unknown bugs with nine confirmed and seven fixed by the corresponding developers.
i. i ntroduction fuzzing has been widely adopted to expose the vulnerabilities of software systems by producing invalid unexpected or yuqun zhang is the corresponding author.
these authors contributed equally.
these authors are also affiliated with the department of computer science and engineering southern university of science and technology shenzhen china.
mingyuan wu is also affiliated with the university of hong kong hong kong china.random data as test inputs .
particularly given a collection of seeds grey box fuzzers iteratively mutate them for generating new seeds to optimize their exploration on program states i.e.
executed code guarded by branch conditions via obtaining real time coverage feedback based on instrumenting target programs.
although many grey box fuzzers are effective in exploring sufficient program states to expose software vulnerabilities they are still ineffective in exploring certain program states e.g.
the ones guarded by equality constraint s unless developers design specific mutators for their own applications .
to improve program state exploration researchers have proposed multiple assisting exploration strategies which are usually implemented as an independent phase in an existing fuzzer e.g.
implementing an smt solver as a constraint solving phase into afl to assist general grey box fuzzers for exploring such program states.
to our best knowledge there are four types of assisting exploration strategies the dictionary strategy which enables a list of tokens that fuzzers can insert to mutants to cope with the grammar blind problem i.e.
generating input that may violate grammar the input tostate correspondence strategy which utilizes lightweight taint tracking to monitor how input values are used at various states during program execution.
in this way the correspondences between the operands of a given instruction and the given input can be derived to first identify the offsets via lightweight taint tracking and then update their values for exploring the associated program states the smt solver based strategy which leverages smt solvers to solve constraints that satisfy complex branch conditions for exploring program states e.g.
q sym and the gradient based strategy which utilizes gradient descent to solve constraints for exploring program states e.g.
angora .
although these strategies have been shown effective in their correspondingarxiv .14541v2 sep 2024papers their evaluation can be potentially biased since they seldom follow equivalent protocols e.g.
while angora and qsym both use eight real world projects in their original evaluations they only adopt two projects objdump andfile in common.
moreover the evaluations of these strategies focus mainly on the performance of the grey box fuzzers integrating the assisting exploration strategies as a whole while neglecting the individual contributions of the strategies e.g.
the specifics of their explored program states.
without a thorough understanding of the explored program states by these strategies it is unclear how to further improve the effectiveness of these strategies to assist grey box fuzzers in exploring deeper program states.
in this paper we perform the first comprehensive study to evaluate the assisting exploration strategies.
specifically we first collect nine recent fuzzers as our studied subjects and construct a benchmark suite which consists of opensource real world projects commonly studied by their original papers.
then we conduct an extensive evaluation where our evaluation results suggest that the dictionary strategy achieves quite similar and even slightly better performance over other studied assisting exploration strategies e.g.
afl activating the dictionary strategy slightly outperforms the best performing smt solver based fuzzer q sym in terms of the average edge coverage vs. explored edges .
we observe that it is also more practical to be enhanced by strategically selecting tokens to form a dictionary for each seed.
inspired by our study we propose cdf uzz customized dictionary fuzz ing which customizes the dictionary by strategically selecting tokens for each seed upon the baseline fuzzer afl .
specifically cdf uzz derives the execution path of each seed and extracts all its constant tokens in equality constraint s to generate a customized dictionary.
accordingly each of such tokens is inserted to a random seed offset to generate a mutant for the further fuzzing campaign.
the evaluation results indicate that under hour evaluation cdf uzz can outperform the best performer in our study i.e.
afl activating the dictionary strategy by .
in terms of edge coverage.
cdf uzz also exposed previously unknown bugs where of them can only be exposed by cdf uzz in our evaluation i.e.
other evaluated fuzzers can only expose of them within the given time limit .
specifically nine of them have been confirmed and seven have been fixed by the corresponding developers.
to summarize this paper makes the following contributions to the best of our knowledge we conduct the first comprehensive study of nine representative fuzzers on the performance impact of assisting exploration strategies on top of a collection of real world projects.
our study revealed that the dictionary strategy is most promising because it not only achieves similar or even slightly better performance over other studied strategies but also is more practical to be enhanced.
we propose a lightweight approach cdf uzz which customizes the dictionary for each seed by strategically selecting constant tokens.
it outperforms the best performerin our study by .
in terms of edge coverage and exposes previously unknown bugs with nine confirmed and seven fixed by the corresponding developers.
all experimental results and our tool is publicly available in ourgithub repository .
ii.
b ackground a. grey box fuzzing grey box fuzzing has become the major practice for fuzzing.
the objective of a grey box fuzzer is to iteratively explore the target program thoroughly for exposing potential vulnerabilities.
we take the widely used baseline fuzzer american fuzzy lop afl to illustrate generic grey box fuzzers.
first afl instruments the coverage tracking instructions into the target program in compilation time for collecting coverage information.
next it mutates seeds i.e.
inputs of the target program and executes the resulting mutants on the instrumented program to obtain coverage information.
if such mutants explore new program states i.e.
increase code coverage afl identifies such mutants as interesting seeds and retains them for further exploration.
the procedure above is iterated throughout the entire fuzzing campaign.
while grey box fuzzers can in general advance the exploration of program states upon the explored program states progressively they have also been shown somewhat limited in exploring the program states guarded by tight and complex branch conditions e.g.
equality constraint s .
b. assisting exploration strategies many assisting exploration strategies have been proposed to assist grey box fuzzers on exploring program states guarded by tight and complex branch conditions .
the general workflow of integrating assisting exploration strategies in grey box fuzzers is shown in figure and illustrated as follows seed corpusx 0xdeadbeefidentify variablesseed 0xffx0xfflocate offset from seed 0xff0xdeadbeef0xffreplace offset with variable dictionary tokenstoken 0xdeadbeefrandom select a tokeninsert token into seed the dictionary strategy mutant program edge coverageyes trigger new edge?
nodiscardmutation afl coordinator seed selection constraint solving engine the input to state strategythe constraint solving strategies fig.
the workflow of assisting exploration strategies the dictionary strategy the dictionary strategy either adopts a set of user defined tokens so called dictionary or generates tokens automatically by parsing the constant values defined in the target program .
such tokens are randomly inserted into random seed offsets to generate mutants for the further fuzzing campaign expecting that certain tokens can beinserted in the correct branch conditions of the target program to advance the program state exploration.
for example in figure to explore the equality constraint x 0xdeadbeef the token 0xdeadbeef in the dictionary can be either given by users or parsed from code.
next the token 0xdeadbeef is inserted to a random seed offset to generate a mutant.
if the token happens to be inserted in the offset of the input corresponding to the righthand side of the equality constraint x 0xdeadbeef i.e.
the equality constraint is satisfied by executing the mutant its guarded program state can be explored.
the input to state correspondence strategy since it is likely that partial input can be stored in the memory or registers at run time the input to state correspondence strategy derives the correspondence between such input and the associated program state to facilitate fuzzing.
specifically the input to state correspondence strategy identifies the lefthand and righthand side of a branch condition during runtime via additional instrumentation.
next it identifies which side originated from the corresponding seed and then locates its offset via lightweight taint tracking.
furthermore it updates such offset with the value of the other side i.e.
generating a mutant to be executed for satisfying the corresponding branch condition such that its guarded program state can be explored.
for instance in figure given a branch condition x 0xdeadbeef the input to state correspondence strategy first identifies the value of x and then traces the offset of xin the seed.
at last xis updated with the value 0xdeadbeef in the seed to generate a new mutant which is then input to the target program for exploring the program states guarded by x 0xdeadbeef .
the constraint solving strategies the smt solver based strategy and the gradient based strategy symbolic execution is widely used in grey box fuzzers by leveraging full taint tracking and constraint solving to generate seeds satisfying target branch conditions.
in particular the smt solverbased strategy utilizes smt solver and the gradient based strategy utilizes gradient descent for solving constraints respectively.
to illustrate in figure the grey box fuzzer and the constraint solving engine i.e.
the symbolic concolic execution engine or the gradient descent solver are first activated at the same time.
next the grey box fuzzer passes its generated seeds to the constraint solving engine which leverages full taint tracking to derive constraints corresponding to the seed inputs and solve them for exploring program states guarded by tight and complex branch conditions.
meanwhile the constraint solving engine also passes its generated seeds to the grey box fuzzer for the further fuzzing campaign .
although all these strategies have been well evaluated in their original papers their evaluations can be potentially biased because they seldom follow identical protocols and the assessment of their individual contributions is rather obscure.
thus there is a pressing need to comprehensively study the assisting exploration strategies to enlighten their future development.iii.
e mpirical study a. subjects benchmarks subjects we aim at the grey box fuzzers with assisting exploration strategies as our study subjects.
in particular we filter many such fuzzers for selecting the representative ones.
following prior studies we first limit our search scope to the fuzzers recently published in the top software engineering and security conferences e.g.
icse fse ccs and s p .
furthermore we can only evaluate the fuzzers which are publicly available and can be successfully executed.
lastly as it is rather challenging and time consuming to activate certain strategies e.g.
the dictionary strategy in nonafl based fuzzers we only target afl based fuzzers.
finally we select nine representative fuzzers as our studied subjects.
specifically afl afl m opt and fairfuzz represent the dictionary based fuzzers while they deactivate the dictionary strategy option by default it can be easily activated as long as the associated tokens are provided .
q sym m euzz and p angolin represent the smt solver based fuzzers.
angora and redqueen are typical gradient based fuzzer and inputto state correspondence based fuzzer respectively.
note that redqueen is implemented into afl which is maintained by google as the r edqueen mode and thus we choose it as the representative fuzzer of input to state correspondence strategy following prior work .
benchmark suite following prior work we construct our benchmark suite based on the projects commonly adopted by the original papers of the selected fuzzers .
to ensure general applicability of our study we additionally adopt seven projects from fuzzbench resulting in a total of real world projects.
in particular we select frequently used projects out of the papers to form our benchmark suite.
more specifically we first select seven projects that are adopted by at least three papers.
then we randomly select another seven projects which are adopted by one or two papers.
the selection details are presented in our github page .
table i presents the statistics of our benchmark suite.
specifically we consider our benchmark to be sufficient and representative due to the following reasons these benchmark projects cover ten different file formats for seed inputs e.g.
elf xml jpeg and json the sizes of these programs that range from to over 150k lines of code loc can represent a wide range of programs in practice they are all open source real world programs from different vendors with various code logic.
they cover diverse functionalities including development tools e.g.
readelf objdump xml processing tools e.g.
xmlwf network analysis tools e.g.
tcpdump graphics processing tools e.g.
djpeg etc.table i statistics of the studied benchmarks programslocpackage target commit version class readelf .
elf nm .
elf binutils objdump .
elf size .
elf strip .
elf libjpeg djpeg 9c jpeg tcpdump tcpdump .
.
pcap libxml2 xmllint .
.
xml jhead jhead .
jpeg libpng pngfix .
.
png libtiff tiffinfo .
.
tiff expat xmlwf .
.
xml libtiff tiff2bw .
.
tiff mupdf mutool .
.
pdf libjpeg turbo libjpeg turbo 3b19db jpeg libpng libpng cd0ea2 png libxml2 libxml2 c7260a xml re2 re2 b025c6 regex jsoncpp jsoncpp 8190e0 json sqlite3 sqlite3 c78cbf sql bloaty bloaty 52948c elf these benchmark packages come from fuzzbench .
b. environment setup and implementation our evaluation was conducted on the esc servers with core .
ghz amd epyctm rome 7h12 cpus and gb ram.
the servers run on linux .
.
generic bit ubuntu .
.
we strictly follow the respective original procedures of the studied fuzzers when executing them.
specifically to allow the fuzzers to generate more tests we set the execution time budget for all the experiments hours.
meanwhile as all fuzzers rely on randomized algorithms we run each experiment five times to obtain the average result following prior evaluations .
notably since all the studied fuzzers are afl based we apply the afl v2.57b which is the latest released version in github llvm mode llvm to instrument the source code during compilation and llvm ir for presenting and analyzing programs.
at last we collect the initial seed corpus following prior work .
we adopt edge coverage to measure code coverage where an edge refers to a transition between program blocks e.g.
a conditional jump following prior work .
specifically we compute edge coverage via the unique edge number derived by the afl built in tool named afl showmap which has been widely used by many existing fuzzers .
constructing dictionary versions via fuzzingdriver.
to form dictionaries for all studied fuzzers involving dictionary strategy we automatically extract tokens using the most recent fuzzingdriver instead of relying on userprovided tokens to reduce potential bias.
specifically fuzzingdriver is designed to automatically generate dictionaries for each program leveraging codeql to extract key pieces of information from the target program s internals including commonly occurring keywords strings and constants.
moreover it employs a data cleaning module that scrutinizes extracted tokens to customize the dictionary for enhancing theefficiency of the fuzzing process.
c. research questions we investigate the following research questions in our study rq1 how well do different assisting exploration strategies perform on our benchmark suite?
rq2 what are the specifics of program states explored by assisting exploration strategies?
rq3 what are the potential obstacles of different assisting exploration strategies?
d. result analysis rq1 effectiveness of the studied fuzzers table ii shows the edge coverage results of all studied fuzzers where the numbers show the coverage results averaged over multiple runs i.e.
five times .
the orig column denotes the original implementation of the grey box fuzzers which deactivates the dictionary strategy and dict denotes the grey box fuzzers activating the dictionary strategy represented as fuzzer dict in this paper .
in general we can observe that all fuzzer dicts outperform all original grey box fuzzers in terms of the average edge coverage by .
to .
e.g.
afl dict explores .
more edges than afl vs. explored edges .
moreover we also observe that q sym m euzz pangolin angora and r edqueen outperform the best performing greybox fuzzer i.e.
afl by .
in terms of the average edge coverage.
as all the studied subjects are afl based we can derive that both input to state correspondence strategy and constraint solver based strategies can somewhat advance the exploration of program states over the original grey box fuzzers.
however we can also observe that the performance advantage is limited and may not well generalize in different benchmark projects.
for instance the best performing constraint solving based fuzzer q sym outperforms afl in projects by .
vs. explored edges in strip to .
vs. explored edges in jhead while afl outperforms q sym in the remaining ten projects by .
vs. explored edges in re2 to .
vs. explored edges in sqlite3 .
we also perform the mannwhitney u test to demonstrate the significance of fuzzers that adopting assisting exploration strategies compared to the grey box fuzzer afl.
the p value of less than .
for afl compared to afl dict q sym and r edqueen in terms of average edge coverage indicates that fuzzers adopting assisting exploration strategies significantly outperform the grey box fuzzer afl.
interestingly we further observe from table ii that the dictionary based fuzzers can potentially achieve similar or even slightly better performance over other studied fuzzers.
for instance afl dict outperforms q sym by .
vs. explored edges on average.
since afl dict and q sym only differ in their adopted assisting exploration strategies it indicates that the dictionary strategy is close to or potentially 1note that fuzzingdriver is not an independent fuzzer but just a tool for extracting tokens to generate dictionaries for fuzzers we cannot adopt it as an independent baseline in our evaluation.table ii the average edge coverage result of studied programs benchmarkafl afl f airfuzz moptqsym meuzz pangolin angora r edqueenorig dict orig dict orig dict orig dict readelf nm objdump size strip djpeg tcpdump xmllint jhead pngfix tiffinfo xmlwf tiff2bw mutool libjpeg turbo libpng libxml2 re2 jsoncpp sqlite3 bloaty average p value .
.
.
.
.
.
.
.
.
.
.
.
dictionaries of fuzzer dictsare all generated by fuzzingdriver .
more effective than the smt solver based strategy.
such indications can be generalized when comparing the dictionary strategy with other assisting exploration strategies.
therefore we can infer that the dictionary based fuzzers are effective solutions in exploring program states.
finding the dictionary based fuzzers achieve similar or even slightly better performance over other studied fuzzers indicating that the dictionary strategy is rather effective.
rq2 specifics of the explored program states in this paper we characterize a constraint as a predicate that is represented as the edge between two basic blocks in the control flow graph cfg .
to reach a given program state all its guarded constraints should be satisfied.
we thus represent each program state by an ordered sequence of its guarded constraints i.e.
a sequence of branch conditions which guard the corresponding basic blocks.
in particular we consider the following two types of constraints based on llvm ir an equality constraint denotes equality comparisons at the source code level e.g.
which correspond to one jump equal instruction orjump not equal instruction following otherwise it is referred to as a non equality constraint .
our goal is to find out which constraint in the ordered sequence of a program state is critical to be satisfied by grey box fuzzers.
particularly given a program state represented as the ordered sequence of its guard constraints c1 c2 ... c k ck ... c nwhere c1 ... c kare satisfiable and ck 1is unsatisfiable we consider the first unsatisfiable constraint i.e.
ck to be critical since it prevents the remaining unsatisfied constraints ck ... c n from being explored.
we first investigate the specifics of the program states which can be explored by the fuzzers with assisting exploration strategies other than the grey box fuzzers to reflect the improvement that the assisting exploration strategies brings to grey box fuzzers.
specifically we collect the unexplored program states denoted as s by applying the grey boxfuzzers.
we then filter out the ones which cannot be explored by any fuzzer with assisting exploration strategies.
finally we derive the critical constraints from the remaining program states for further analysis.
we observe that the majority of the constraints which can be explored by the fuzzers integrating assisting exploration strategies but cannot be explored by their corresponding grey box fuzzers are equality constraint s. figure presents the ratios of the total number of equality constraint s to the total number of critical constraints.
for example .
of the critical constraints explored by afl dict .
by afl dict and .
by q sym but not by their corresponding grey box fuzzers are equality constraints.
finding the assisting exploration strategies bring improvement over grey box fuzzers by effectively exploring program states guarded by equality constraints.
afl afl fairfuzz mopt qsymmeuzzpangolinangoraredqueenratio .
.
.
.
.
.
.
.
.1dictdictdictdict fig.
ratios of the total number of equality constraint s to the total number of unsatisfiable critical constraints we further investigate the characteristics for the unexplored program states by fuzzer origs.
note that all these program states are guarded by equality constraint s and can be explored by either dictionary strategy input to state correspondence strategy or constraint solver based strategies.
specifically weuse a semi automated approach to analyze the program state characteristics guarded by equality constraint s our script first automatically extracts equality constraint s and then we manually identify common characteristics among these equality constraint s. surprisingly we find that .
of these unexplored equality constraint s share the same form as input constant e.g.
function memcmp input constant orswitch input case constant after compilation i.e.
taking the content directly from the input to compare with a predefined constant value constantevaluating equality constraint s .
finding the constraints explored by dictionary strategy and other studied strategies are mostly constantevaluating equality constraints.
rq3 the obstacles of different strategies our previous findings indicate that all assisting exploration strategies achieve similar edge coverage performance.
we then discuss the potential obstacles for their future development to understand which strategy is more practical to be enhanced for better exploring the program states guarded by tight and complex branch conditions.
.
.
.
.
.
readelfnmobjdumpsizestripdjpegtcpdumpxmllintjheadpngfixtiffinfoxmlwftiff2bwmutoollibjpeg turbolibpnglibxml2re2jsoncppsqlite3bloaty execution time ratioexplored edge ratioratio fig.
ratios of the execution time and explored edges of the input to state correspondence strategy input to state correspondence strategy.
for the input tostate correspondence strategy we first investigate its potential effect by studying the input to state correspondence based fuzzer i.e.
r edqueen .
apart from input to state correspondence strategy r edqueen also includes other strategies e.g.
thehavoc strategy .
we then investigate the ratio of the execution time of the input to state correspondence strategy to the overall execution time budget i.e.
hours for studying its effectiveness as in figure .
we can observe considerable variations on the execution time of the input to state correspondence strategy across different benchmarks.
for instance inreadelf nm and strip its execution exceeds hours.
on the contrary in jhead andxmlwf its execution lasts merely less than one hour.
meanwhile figure also presents the ratio of the edges explored by the input to state correspondence strategy to the overall explored edges.
it is surprising to see that executing the input to state correspondence strategy longer does not necessarily explore more edges e.g.
executing hours but only exploring .
edges in readelf indicatingthat the adopted mechanisms e.g.
lightweight taint analysis in the input to state correspondence strategy can incur performance issues in certain benchmark projects.
we further infer that its development may be hindered by the inaccuracies of its adopted lightweight taint tracking.
to illustrate we manually analyze of constant evaluating equality constraint s which r edqueen fails to explore in our evaluation.
we observe that although it successfully detected the corresponding constant values for these equality constraint s its lightweight taint analysis failed to locate their corresponding offsets in the seeds.
figure presents one such example from xmllint where redqueen successfully obtains the constant value but it fails to locate its offset corresponding to cur ptr in the seed.
therefore the equality constraint at line cannot be satisfied and r edqueen fails to explore its guarded program states.
finding the input to state correspondence strategy could potentially trigger performance issues in certain benchmarks while also running the risk of inaccuracies in locating correct offsets.
1void xmlparsenotationdecl xmlparserctxtptr ctxt cmp10 checks if the first characters of a string s match the provided characters c1 to c10 .
if cmp10 cur ptr !
n o t a t i o n ... fig.
an input to state fuzzing strategy failure case in xmllint parser.c 1if alias !
xml char encoding error const char canon the return value of xmlgetcharencodingname is determined by a switch statement canon xmlgetcharencodingname alias if canon !
null strcmp name canon return xmlfindcharencodinghandler canon fig.
a case in xmllint encoding.c constraint solver based strategies .
for the constraintsolver based strategies i.e.
the smt solver based strategy and the gradient based strategy we infer that although they can advance the exploration of program states to some extent their effectiveness can nevertheless be compromised when exploring program states guarded by certain complex and tight branch conditions.
notably the constraint solver based fuzzers fail to explore many program states guarded by equality constraint s which can otherwise be explored by fuzzer dicts.
for example in figure only the fuzzer dicts can explore the condition in line canon !
null ... in our study.
to investigate how the performance of the constraint solver based strategies correlates with the specifics of program states we first characterize the depth of constraints.
as the constraint ck 1can be reached if and only if the conjunction of its all dependent constraints c1 c2 ... ckis satisfied wethus compute the depth for constraints ck 1as the size kof the conjunction of its dependent constraints.
figure demonstrates the success rate of solving constraints at different depths by applying the constraint solver based strategies where successful solving refers to that a constraint solver finds a satisfiable solution for these constraints.
we observe that for all constraint solver based fuzzers the success rate significantly decreases as the depth approaches e.g.
q sym has .
success rate when the depth reaches while only .
when reaching .
finding although constraint solver based strategies may potentially explore tight and complex constraints it still becomes less effective when solving deeper constraints.
.
.
.
qsym meuzz angora pangolin depth of constraintssuccess rate fig.
the success rates of solving constraints at different depths dictionary strategy.
we then investigate the potential obstacles which may hinder the future development of the dictionary strategy.
interestingly we observe that although thefuzzer dicts can slightly outperform the fuzzers with other assisting exploration strategies in terms of the average edge coverage they fail to achieve consistent performance advantages in each benchmark project.
for instance q sym and angora outperform the best performer of fuzzer dicts i.e.
afl dict in nine benchmark projects by .
to .
.
we thus infer that the power of the dictionary strategy has not been fully exploited i.e.
randomly selecting tokens to form a dictionary may be essentially deficient.
to validate this hypothesis we set out to evaluate what performance impact can be caused by strategically selecting the tokens to form a dictionary.
specifically we first randomly selected ofequality constraint s out of our benchmark suite which can be explored by the fuzzers with all the assisting exploration strategies other than the dictionary strategy.
next for an edge in cfg corresponding to the failed exploration on an equality constraint e.g.
the false edge from memcmp input 8bim in figure when running a seed e.g.
s1in figure we identify its sibling edges i.e.
edges under one shared prefix edge defined in such as the true edge from memcmp input 8bim in figure .
accordingly weonly collect the associated constant tokens e.g.
8bim and add them into the dictionary of the seed such that it can be randomly inserted to its offsets.
at last we apply afl dict to run the target program.
as a result .
of such equality constraint s can be explored by afl dict in three hours indicating that strategically selecting tokens to form a dictionary can advance the exploration of the program states guarded by equality constraint s. finding the exploration of program states guarded by the equality constraints can be enhanced by strategically choosing tokens to form a customized dictionary.
memcmp input photoshop .
void show iptc ... falsebadsig errnonfatal ... memcmp input 8bim false...truetruedictionary photoshop .
8bim ... seed s1 fig.
strategically building a dictionary for exploring jhead iptc.c e. discussion as assisting exploration strategies have been shown to be powerful and yet limited in our study we then discuss how we could potentially enhance assisting exploration strategies for advancing program state exploration in practice which essentially demands being lightweight.
while it has been widely recognized that improving the taint analysis and constraint solvers can be typically heavyweight to cause potentially excessive efforts strategically selecting tokens to form a dictionary for the dictionary strategy is likely to be lightweight and more practical.
note that while ideally accurately tracking the offsets of seeds to insert the correct tokens can further improve the effectiveness of the dictionary strategy it is nevertheless heavyweight as presented in prior work .
we thus do not consider accurately tracking the seed offsets to improve over the dictionary strategy.
iv.
c ustomized dictionary fuzzing motivated by our previous findings we propose cdf uzz customized dictionary fuzz ing which builds upon the baseline fuzzer afl a customized dictionary for each seed by accurately selecting tokens.
a. approach figure presents the workflow of cdf uzz.
for each seed in the seed corpus cdf uzz first derives its execution path and then extracts all its constant tokens in equality constraint s to form a dictionary for the seed.
next cdf uzz randomly selects a token from the dictionary and inserts it into a randomprogram dictsin token?exploredunexploredsibling edge seed seed corpustoken... mutant edge coverageyes trigger new edge?
nodiscard execute program get execution path .cfgget constant token ... token ... random selectionrandom insertion fig.
the workflow of cdf uzz algorithm customized dictionary fuzzing input initialseed budget output seedcorpus function customized dictionary fuzzing cfg getcfgfromtargetprogram tokens getconstanttokensfromcfg cfg path getpathbyseed initialseed cfg dict getvalidtoken tokens path cfg dicts seedcorpus initialseed while fuzzing time notexceed budget do foreach seed inseedcorpus do sdict dicts token randomselection sdict mutant randominsertion seed token ifmutant has new edges then seedcorpus seedcorpus mutant mupath getpathbyseed mutant cfg mudict getvalidtoken tokens mupath cfg dicts mudict return seedcorpus offset to generate a mutant.
if running such a mutant upon the target program increases edge coverage it will be added to the seed corpus.
instead of maintaining an overall dictionary as in prior dictionary based approaches cdf uzz generates a customized dictionary for each seed input.
our intuition is that having a separate dictionary for each seed will allow easier tracking and effective selection of relevant tokens for each seed and avoid polluting or overloading the dictionary with tokens from other seeds.
algorithm presents the workflow of cdf uzz which takes an initialseed as input and performs fuzzing with a given time budget .
first we parse the control flow graph of the target program cfg and its corresponding constant tokens following previous work lines .
next we initialize the seed corpus seedcorpus by parsing all the constant tokens extracted from the equality constraint s of the executed path path ofinitialseed via the getvalidtoken function.
specifically this function extracts constant tokens from the sibling edges out of all the edges corresponding to failed exploration on equalitytable iii the edge coverage results of cdf uzz benchmark afl dict afl dict qsym redqueen cdf uzz readelf nm objdump size strip djpeg tcpdump xmllint jhead pngfix tiffinfo xmlwf tiff2bw mutool libjpeg turbo libpng libxml2 re2 jsoncpp sqlite3 bloaty average p value .
.
.
.
constraint s of path .
in this way we form a customized dictionary for initialseed with the collected tokens.
for eachseed cdf uzz generates a mutant for exploring new program states.
to avoid inserting irrelevant tokens into the seedcorpus we only select tokens from the customized dictionary of such seed to generate a mutant lines .
meanwhile if running such a mutant successfully explores new program states we add it to seedcorpus for further exploration lines .
similarly we generate a customized dictionary for this mutant by parsing the constant tokens according to its executed path lines .
for example assuming that running a seed presented in figure fails to satisfy the equality constraint memcmp input 8bim cdf uzz then identifies the associated constraint solving constant token 8bim while filtering out other irrelevant tokens e.g.
photoshop .
to customize a dictionary for further mutations.
b. evaluation to evaluate cdf uzz we include the best performing dictionary based fuzzer afl dict and constraint solverbased fuzzer q sym as well as the input to state correspondence fuzzer r edqueen for performance comparison.
we also include afl dict to assess the effectiveness of the customized dictionary by cdf uzz since they only differ in the adopted dictionaries.
similar to the setup in section iii b we run each experiment five times to obtain the average result within hours.
note that the dictionary for each seed is built on the fly so the time cost is included in the overall running time hours .
prior to running algorithm cdf uzz first builds cfg and collects constant tokens this process only incurs roughly seconds overhead per benchmark which is minimal compared to afl clang fast .
we further present the details of compilation cost in our github page due to the page limit.
result and analysis table iii presents the edge coverage results of the studied approaches on top of all the benchmark projects.
in general by only differing the adopted dictionaries cdf uzz significantly outperforms afl dict by .
vs. explored edges indicating the effectiveness of our proposed customized dictionary.
moreover cdf uzz outperforms afl dict by .
vs. explored edges q sym by .
vs. explored edges and r edqueen by .
vs. explored edges averagely.
the results suggest that cdf uzz can significantly improve the effectiveness of the dictionary strategy.
we also perform the mann whitney u test to illustrate the significance of cdf uzz.
the fact that the p value of cdf uzz comparing with afl dict in terms of the average edge coverage is .
indicates that cdf uzz outperforms afl dict significantly p .
.
afl afl qsymredqueencdfuzzexplored equality constraints05000100001500020000 640dictdict fig.
the explored equality constraint s of each studied fuzzer we further investigate how the fuzzers perform on exploring equality constraint s as in figure .
specifically cdf uzz outperforms the runner up performer q sym by .
in terms of exploring equality constraint s vs. .
the results indicate that cdf uzz can significantly improve the power of exploring equality constraint s for grey box fuzzing.
figure presents the edge coverage trends of the studied approaches in each benchmark within hours.
overall cdf uzz outperforms all studied fuzzers significantly in most of the benchmarks except xmlwf and size .
specifically cdf uzz outperforms the best performing afl dict of our study in all benchmark projects in terms of edge coverage e.g.
cdf uzz outperforms afl dict by .
in strip.
moreover although afl dict and q sym achieve higher edge coverage than cdf uzz inxmlwf and sizerespectively their performance gaps are rather limited i.e.
cdf uzz underperforms afl dict inxmlwf by .
and q sym insizeby .
.
such results altogether indicate that cdf uzz can achieve quite robust edge coverage performance.
bug finding capability for bugs in the wild to evaluate the bug finding capability we apply cdf uzz on our original benchmark suite and randomly select additional real world open source projects stars from github following prior evaluations .
we also include all the grey box fuzzers with dictionary strategy and q sym meuzz pangolin angora r edqueen in the evaluation of bug finding capacity.
to identify unique bugs we first compile the selected projects with two additional sanitizers to trigger crashes as possible.
next we derive the unique crashes based on whether they incur unique execution paths following existing work .
finally we manually analyze each unique crash to derive unique bugs.
all bugs are categorized based on their roottable iv the unique bugs explored by cdf uzz project bug type number status bison use of uninitialized value reported objdump infinite loop confirmed and fixed bsdtar use of uninitialized value reported jasper assertion failure confirmed and fixed loutranslation infinite loop confirmed and fixed libtiff use of uninitialized value reported objcopy use of uninitialized value confirmed and fixed jhead use of uninitialized value reported precomp bad malloc reported nm memory leaked confirmed zziplibstack buffer overflow reported stack buffer overflow reported jpeginfoheap buffer overflow confirmed and fixed use of uninitialized value confirmed cmixalloc dealloc mismatch confirmed and fixed memcpy param overlap confirmed and fixed use of uninitialized value reported bento4allocation size too big reported out of memory reported memory leaked reported heap buffer overflow reported segmentation fault reported heap use after free reported causes their details are available in our github page .
table iv presents the unique bugs exposed by our approach.
cdf uzz has exposed previously unknown bugs where of them cannot be exposed by other studied fuzzers within the given time limit.
moreover nine of them have been confirmed and seven have been fixed by the corresponding developers.
the results suggest that cdf uzz is more effective than other fuzzers in terms of exposing real world bugs.
in particular we list two examples of the exposed bugs below to illustrate the importance of the bugs found by cdf uzz.
we also demonstrate the details of all exposed bugs in our github page with their report links due to page limit.
heap buffer overflow bug in project jpeginfo .figure shows the code snippet for a heap buffer overflow bug in project jpeginfo where in line six bytes from exif ident string are copied to cmarker data without any length checking leading to a buffer overflow.
to expose this bug the equality constraint cmarker marker exif jpeg marker should be satisfied.
in our evaluation only cdf uzz reaches the branch guarded by such equality constraint .
the developer fixed the bug by adding buffer length checking statements from line to line .
they also replied to our bug report as follows thanks looks like memcmp may have read past end of the buffer in some circumstances.
memcpy param overlap bug in project cmix .we have also reported a memory overlapping bug in cmix only exposed by cdf uzz.
the corresponding developers have fixed this bug after receiving our report .
figure shows the corresponding buggy code snippet where in line the memory content is copied from source w letters to sinkw letters viamemcpy .
as the source and sink addresses differ by a single byte it causes potentialfig.
edge coverage of cdf uzz over time define exif jpeg marker jpeg app0 define exif ident string exif define exif ident string len ... 5while cmarker if cmarker marker exif jpeg marker if cmarker marker exif jpeg marker cmarker data length exif ident string len if !memcmp cmarker data exif ident string exif marker cmarker cmarker cmarker next fig.
a heap buffer overflow bug in jpeginfo 1void convertutf8 word w for int i w start i w end i u8 c w letters w letters 0xa0 ?
x60 0x40 if w letters 0xc3 isvowel c w letters 0xdf 0x87 w letters c if i w end memcpy w letters w letters w end i memmove w letters w letters w end i w end fig.
a memcpy param overlap bug in cmix overlapped memory i.e.
an undefined behavior in c c programming.
the function memcpy does not guarantee proper handling of overlapping memory regions.
in contrast memmove ensures accurate data replication in such cases.
in our evaluation only cdf uzz generates seeds that expose this defect by satisfying the equality constraint in line i.e.
w letters 0xc3 andisvowel c .
the developers also commented on our report thanks for the bug report and the suggested fix!
changing to memmove fixed this.
v. t hreats to validity internal validity.
one threat to internal validity lies in the implementation of the studied techniques in our evaluation.
to reduce this threat we reused all the source code from the original projects directly in our implementation with best effort.
when implementing the dictionary strategy we proposed an automatic approach to extract tokens in a llvm pass following prior work to reduce potential bias caused by user provided tokens.
moreover all the student authors manually reviewed the code of all studied fuzzers including cdf uzz to ensure their correctness and consistency.
external validity.
the threat to external validity lies in the subjects and benchmarks.
to reduce this threat we have selected representative state of the art fuzzers which cover mainstream types of assisting exploration strategies including dictionary based fuzzers input to state correspondencebased fuzzers gradient based fuzzers and smt solver based fuzzers.
we also collect frequently used projects from their original papers as our benchmark suite.
construct validity.
the threat to construct validity mainly lies in the metrics used.
to reduce this threat we adopted the most popular metrics in fuzzing i.e.
edge coverage following to reflect the performance of different studied techniques.
furthermore we evaluated the effectiveness of our approach in terms of the number of unique crashes.
vi.
r elated work a. fuzzing most existing fuzzers use code coverage information to improve the efficiencyof fuzzing.
in particular afl provides the fundamental framework for coverage guided fuzzers.
accordingly fioraldi et al.
integrated several techniques e.g.
taint tracking to enhance the ability of exploring program states for afl.
she et al.
proposed neuzz which leverages the power of neural network models to explore unknown edges.
pham et al.
proposed sgf which generates seeds on the virtual structure of the file rather than on the bit level to improve fuzzing efficacy.
meanwhile aflfast uses markov chain to schedule seeds for exploring program states .
f airfuzz focused on rare branches for its exploration .
zeror is a coveragesensitive tracing and scheduling fuzzing framework that uses zero overhead instrumentation and a schedule strategy between different instrumentation for afl based fuzzers .
recently researchers also pay attention to exploring program states by focusing on the diversity of the program behaviors.
nguyen et al.
introduced bedivfuzz to schedule the mutation strategy towards the validity and diversity of program behaviors based on the received program feedback.
liang et al.
proposed pata to mutate the influencing input bytes by leveraging the power of diverse explored program paths.
yan et al.
introduced a new approach pathafl to reduce the tracing granularity of an execution path for exploring program states.
qatest adopts a new coverage guidance and seed schedule strategy for question answering systems.
ems utilizes historical explorations to identify mutators that can trigger unique paths and crashes .
by adopting an automatic dictionary generation strategy fuzzingdriver generates dictionary tokens for coverage based grey box fuzzers via parsing the original code .
compared to fuzzingdriver cdf uzz schedules existing tokens in dictionaries for different seeds in runtime instead of generating tokens before fuzzing.
to explore program states guarded by complicated constraints hybrid fuzzing techniques are proposed to combine constraint solvers with grey box fuzzers.
majumdar et al.
presented hybrid fuzzing to interleave random fuzzing with constraint solver for deep exploration of program state space.
driller leverages fuzzing and selective concolic execution with constraint solver in a complementary manner to explore program states .
chen et al.
leveraged the power of gradient descent to solve the constraints in the target program.
q sym optimistically solves constraints and prunes uninteresting basic blocks during fuzzing .
chen et al.
introduced a machine learning based seed scheduling strategy for hybrid fuzzing to explore program states efficiently.
huang et al.
utilized polyhedral path abstraction to facilitate constraint solving.
confetti fuzzes java programs by combining fuzzing with taint tracking and concolic execution with constraint solver .
meanwhile chopped symbolic execution leverages various on demand static analyses at runtime to automatically exclude code fragments while resolving their side effects to improve the efficiency of constraint solving.
compared to constraint solver and dynamic taint tracking adopted by hybrid fuzzing cdf uzz generates a customized dictionary for each seed via a lightweight static analysis.
our experiments show that cdf uzz outperforms thestate of the art constraint solving fuzzers.
b. studies on fuzzing many empirical studies on fuzzing reveal various insights for improving fuzzing techniques.
donaldson et al.
investigated a variety of fuzzing techniques including coverage guided fuzzing with and without custom mutators to test compilers and processing tools for the graphics shading languages.
wu et al.
conducted a study on havoc fuzzing strategy and demonstrated that it largely outperforms other strategies.
b ohme et al.
performed a study on discussing the reliability metrics for evaluating the effectiveness of different coveragebased fuzzers.
they also study the scalability issues of fuzzing in vulnerability discovery .
fuzzbench is a open source platform proposed for evaluating fuzzers to facilitate reliable and reproducible evaluation results .
herrera et al.
systematically investigated and evaluated how seed selection affects a fuzzer s ability to expose vulnerabilities in real world systems.
klees et al.
provided multiple guidelines about how to evaluate the effectiveness of different fuzzers.
in this paper we conduct the first comprehensive study to investigate how assisting exploration strategies perform in exploring program states and reveal various findings to facilitate future research.
vii.
conclusion in this paper we investigated the strengths and limitations of assisting exploration strategies for exploring program states.
we first conduct an extensive evaluation to investigate how assisting exploration strategies perform in exploring program states.
the evaluation results suggest that dictionary strategy can be close to or even slightly more effective than other techniques.
next we investigate their limitations and find that the dictionary strategy is most promising to be improved.
inspired by our findings we present a lightweight approach namely cdf uzz which customizes the dictionary for each seed.
our evaluation results show that cdf uzz outperforms the best performer in our study by .
in terms of edge coverage.
cdf uzz also exposes previously unknown bugs where nine of them have been confirmed and seven of them have been fixed by the corresponding developers.
data availability the data and code are available at github for public evaluation.
viii.
a cknowledgement this work is partially supported by the national natural science foundation of china grant no.
and natural sciences and engineering research council of canada nserc discovery grant.
it is also partially supported by the leading innovative and entrepreneur team introduction program of zhejiang grant no.
td2019001 and ant group research fund.