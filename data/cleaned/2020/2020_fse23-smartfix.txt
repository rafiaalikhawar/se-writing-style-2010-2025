smartfix fixing vulnerable smart contracts by accelerating generate and verify repair using statistical models sunbeom so korea university republic of korea sunbeom so korea.ac.krhakjoo oh korea university republic of korea hakjoo oh korea.ac.kr abstract we present smartfix a new technique for repairing vulnerable smart contracts.
there is an urgent need to develop automatic bug repair techniques for smart contracts as smart contracts are safety critical software and manual debugging is burdensome and error prone.
while several repair approaches have been proposed recently they are unsatisfactory since no existing techniques can achieve high repairability full automation and safety guarantee at the same time posing significant problems for practical use.
smartfix aims to address these shortcomings by using a generateand verify approach that iteratively enumerates candidate patches while validating their correctness by invoking a safety verifier.
however in this approach a technical challenge arises as the search space is huge and the verification based patch validation is expensive.
to address this challenge we present a novel technique for accelerating the generate and verify repair procedure using statistical models derived from the verifier s feedback.
experimental results on real world ethereum smart contracts show that smartfixis able to achieve a fix success rate of .
for critical classes of vulnerabilities far outperforming sguard the existing state ofthe art technique whose success rate is .
.
ccs concepts security and privacy software security engineering software and its engineering software testing and debugging .
keywords smart contract generate and verify repair statistical model acm reference format sunbeom so and hakjoo oh.
.
smartfix fixing vulnerable smart contracts by accelerating generate and verify repair using statistical models.
inproceedings of the 31st acm joint european software engineering conference and symposium on the foundations of software engineering esec fse december san francisco ca usa.
acm new york ny usa pages.
current affiliation gwangju institute of science and technology gist corresponding author permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse december san francisco ca usa copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
introduction ensuring the safety of smart contracts is vital for trustworthy blockchain ecosystems.
blockchain is a decentralized database in which stored data is transparent and unchangeable.
smart contracts are programs running on blockchain whose primary means is to automatically fulfill obligations between untrusted parties.
inheriting advantages of blockchain such as transparency smart contracts have received much attention from various domains such as digital assets and supply chain .
unfortunately however considerable safety concerns remain for smart contracts because smart contracts often manage valuable assets they easily become targets of malicious users and once exploited even a single flaw can cause huge financial damage e.g.
.
to make matters worse smart contracts are immutable and hence their flaws cannot be fixed.
it is therefore crucially important to develop techniques for improving the safety of smart contracts before deployment.
in this paper we present smartfix a new technique for automatically fixing vulnerable smart contracts.
the last few years have witnessed a large number of techniques for finding bugs in smart contracts e.g.
.
although they are useful for identifying safety issues manually fixing bugs detected by those safety analyzers remains a time consuming and error prone task.
our aim is to reduce this burden with an automated technique that can safely and accurately fix vulnerable smart contracts before they get deployed on blockchain.
existing approaches .recently a few techniques have been proposed to repair vulnerable smart contracts but they are insufficient for practical use.
this is because most of the existing approaches rely on a single repair strategy for each bug type and hence fails to fix diverse patterns of bugs e.g.
section .
an exception is screpair a test based repair technique that supports multiple repair strategies for each bug type.
however screpair fails to achieve full automation it requires users to provide test cases i.e.
transaction sequences with concrete arguments for each transaction for validating candidate patches but manually constructing robust test suites is nontrivial.
furthermore screpair does not guarantee the safety of generated patches because test cases are typically incomplete as repair specification in practice .
our approach .unlike existing techniques smartfix aims to achieve high repairability full automation and safety guarantee all at once.
to achieve this goal we present a new bug repair technique that combines a generate and verify repair procedure with statistical models.
figure illustrates our approach.
smartfix startsesec fse december san francisco ca usa so and oh prior knowledge base patch generator candidate patch statistical model analysis reportspatch verifiertransferred for future repair tasks verifiersolidity contractverification results statistical modelpatched contract new knowledge base figure overview of smartfix .
by automatically obtaining analysis reports for a given smart contract using a verifier section .
given the smart contract to repair and its analysis reports smartfix basically alternates between the generate and verify phases to fix diverse patterns of security bugs automatically and safely it iteratively performs enumerative search for exploring various candidate patches and verificationbased patch validation for ensuring the safety of output patches.
this approach however poses a technical challenge to repair efficiency as the search space for candidate patches is huge and invoking a verifier is expensive.
to address this challenge we propose a machine learning based technique that intelligently guides the repair procedure using statistical models.
we build statistical models both online and offline we construct a model online from the verifier s feedback verification results such as the number of alarms on candidate patches for the contract under repair and we also derive a model offline from a prior knowledge base abstract forms of verification results obtained during the repair of other contracts .
by using learned statistical models to prioritize candidate patches that are helpful in finding desired safe contracts we can greatly improve the performance of the repair procedure.
results .experimental results show that our technique is highly effective at fixing security bugs in smart contracts.
we implemented our approach in a tool smartfix which generates patches at source code level.
smartfix currently targets contracts written in solidity the most popular programming language for writing ethereum smart contracts.
we extensively evaluated smartfix on four datasets.
these datasets contain five types section of known security bugs that are arguably the most common yet critical ones in ethereum smart contracts integer over underflow ether leak suicidal reentrancy and improper use of tx.origin .
in comparison with sguard the state of the art bug fixing tool for smart contracts the fix success rate of smartfix was .
on commonly supported classes of bugs whereas the fix success rate of sguard was .
.
we also show that our learning based technique is critical for high performance.
compared to the baseline algorithm that explores candidate patches in order of increasing size without using learned statistical models our techniques collectively improved the repair effectiveness by .
in terms of generating bug free contracts.
function transferfrom address from address to uint value public returns bool success if value return false uint frombalance balance uint allowance allowed bool sufficientfunds frombalance value bool sufficientallowance allowance value bool overflowed balance value balance bool sufficientfunds frombalance value bool sufficientallowance allowance value bool overflowed balance value balance if sufficientfunds sufficientallowance !
overflowed balance value balance value allowed value return true else return false figure a vulnerable function simplified from dimoncoin cve .
indicates buggy lines in original source code.
indicates patches produced by smartfix .
contributions .we make the following contributions.
we present an effective approach for automatically fixing vulnerable smart contracts.
the key enabling technology is a learning based method for accelerating the generate andverify procedure with statistical models.
we conduct comprehensive evaluation of smartfix in comparison with sguard the state of the art repair tool for smart contracts using four datasets that contain five types of annotated security bugs.
for open science we make the implementation of smartfixopen sourced and datasets publicly available section .
motivating example we demonstrate usefulness of smartfix with an example.
figure shows a buggy implementation of the transferfrom function in the dimoncoin contract cve .
the job of transferfrom is to allow an agent msg.sender to transfer tokens on behalf of an original token holder from .
the core functionality is implemented at lines when the agent the transaction sender msg.sender invokes the function the agent s allowance allowed and the original token holder s balance balance decrease by value tokens lines and the recipient s balance balance increases by the same amount of tokens line .
observe that due to flaws in conditional expressions at lines integer over underflow bugs can happen at lines which can result in improper state changes.
for example contrary to what the variable name sufficientfunds indicates the flawed condition allows from to send tokens when from s balance balance is insufficient.
existing techniques for repairing smart contracts do not work well on this example.
for example approaches that resort to a single repair strategy i.e.
inserting runtime bound checks could generate safe but functionally incorrect patches failing to eliminate root causes of bugs.
indeed sguard smartfix fixing vulnerable smart contracts by accelerating generate and verify repair using statistical models esec fse december san francisco ca usa produces the following incorrect patch 1which replaces all arithmetic operators by bound checks i.e.
bysafeadd and bysafesub that raise exceptions when over underflows occur at runtime if value return false value !
holds afterwards ... bool overflowed balance value balance bool overflowed safeadd balance value balance if sufficientfunds sufficientallowance !
overflowed deadcode if branch balance value balance value allowed value balance safeadd balance value balance safesub balance value allowed safesub allowed value return true ... where line is changed to line and lines are changed to lines respectively.
while this patch ensures that the fixed parts are free of integer over underflow bugs it does not provide proper functionalities making the function unusable.
for example the patch introduces deadcode in the if branch due to the two conflicting conditions value 0andvalue .
the former is imposed by line .
the latter implicitly holds by the combinations of the two balance value balance imposed by safeadd at line in the above and balance value balance !overflowed at line in the above .
screpair is also unsatisfactory here while screpair would be able to generate candidates that change comparison operators as it supports multiple repair templates it imposes the hard burden on users of building rigorous test suites for validating the safety of candidate patches.
moreover it could generate unsafe patches when tests are incomplete.
smartfix aims to address the shortcomings of existing techniques by a new generate and verify approach guided by statistical models.
in this example smartfix accurately fixes the bugs within reasonable time while iterating the repair loop it tries changing comparison operators in lines to the ones in lines figure and outputs the patch after verifying its safety.
moreover smartfix can reject the incorrect patch made by sguard through verification based patch validation section .
.
.
repair algorithm in this section we present the algorithm of smartfix .
section .
describes the basic generate and verify approach which iteratively generates candidate patches and verifies their safety.
section .
explains how we accelerate this basic approach using statistical models learned during the iterative process.
vulnerability and regression reports .given a smart contracts we assume we have two types of reports for it vulnerability report vr and regression report rr .
these reports can be obtained by our patch verifier section .
.
during the algorithm.
vris a set of tuples v x l es wherev vis a vulnerability type xis the signature of the function that contains the 1this patch was obtained after we modified the original contract as sguard generated an execution error heap out of memory for the original contract.
to make sguard produce patches somehow we applied two changes to the contract removing a loop in the contract to prevent the runtime error from happening and inserting an external function call that has dependencies on arithmetic operations sguard does not generate any patches even after applying see section .
.algorithm basic algorithm of smartfix and its enhanced version based on machine learning lines and input a smart contract s0 output a patched contract s a knowledge base kon vr0 rr0 verify s0 don kon s vr p vr0 c extract s0 vr0 .
.
w generate c s0 .
.
derivemofffrom prior knowledge koff .
.
repeat s p argmin s p wcost p w w s p vr rr verify s .
.
ifbettercandidate rr rr0 vr vr p p then s vr p s vr p don kon mon moff run algorithm w w generate c s0 p .
.
if vr 0then s is a solution contract w s p s p w p p untilw or timeout return s kon vulnerability lis the source code line where the vulnerability is detected and esis the expression or the statement related to the vulnerability detected at l. we write vr to denote the number of alarms reported for s. in this paper vis one of the five bug types that are most common and critical in solidity smart contracts io integer over underflow re reentrancy vulnerabilities due to unexpected reentrancy from external contracts el ether leak hijacking of ethers in contracts su suicidal deactivation of contracts by unauthorized users and tx improper use oftx.origin in user authentication .
rris a set of pairs r x wherer ris a functional regression type section .
.
and xis the signature of the function where the potential regression is detected.
goal .given a contract s0to repair our goal is to transform s0 into a new contract sproven to be free of bugs which we call a solution contract .
specifically it should satisfy vr 0andrr rr0.
vr means that the absence of bugs in sis proven by the patch verifier section .
.
based on formal verification.
rr rr0 meanssis non regressive in that existing potentially abnormal behaviors of s0are preserved and no new abnormal behaviors are detected in s. .
basic generate and verify repair algorithm shows the basic generate and verify architecture of smartfix which iteratively searches for solution contracts.
the input is a potentially vulnerable smart contract s0.
the outputs are a partially patched contract s and a new knowledge base kon constructed during the repair of s0.
for now we assume that the lines highlighted by are ignored in algorithm which areesec fse december san francisco ca usa so and oh procedures for accelerating the overall repair process using learned statistical models section .
.
in the preparation phase lines we first run the verifier verify to obtain the vulnerability and regression reports for s0 line .
at line we initialize donandkonwith the empty sets don is a training dataset for deriving a statistical model online during the repair loop and konis the new knowledge base consisting of the abstract form of the verifier s feedback section .
.
.
at line we initialize s with null vr with vr0 and p with the empty sequence that indicates the null value of a patch respectively.
here s will be a patched contract that is best so far in terms of safety and patch size vr is a vulnerability report for the best contract s orvr0ifs does not exist and p is a patch applied to s .
at line we extract patch components c which are the basic elements of patches.
at line we generate initial candidate patches using c and initialize the workset wwith them.
during the repair process wstores candidate patches that will be examined.
more precisely wmaintains a set of pairs s p where pis a candidate patch and sis a candidate contract obtained by applyingpto the original contract s0.
given a candidate s p ifs is a contract that has been added to w we assume that s p is not accumulated to wto avoid redundant attempts.
in the generate and verify repair loop lines we first pick the candidate s p with the least cost line and remove it from w line .
in the baseline algorithm the function cost prefers smallsized patches cost p p .
in section .
we will enhance this size based cost function as it is insufficient for making smartfixpractical.
at line we validate s where the candidate patch p is applied by invoking the patch verifier.
if pis a better candidate patch than p line in terms of safety or patch size we replace p bypand update other related data similarly line .
the predicate bettercandidate at line is defined as follows bettercandidate rr rr0 vr vr p p rr rr0 vr vr rr rr0 vr vr p p that is a patch pis better than p if pis non regressive and safer the first case or pis non regressive equally safe and simpler the second case .
at line we add new candidates to w. ifs is a solution contract line we eliminate patches larger than p to find simpler solution contracts line .
the repair loop repeats until the workset becomes empty or a timeout occurs line .
.
.
patch generation.
we explain how to extract patch componentsc extract line in algorithm and generate patches p generate lines .
repair template .an atomic repair template a ais the basic unit of a patch component and a patch.
we use the following atomic repair templates to fix the five types of bugs.
insert l s inserts a statement sin front of line l. rep l e1 e2 replaces expressions e1atlwithe2.
addm x m adds a modifier whose name is mto a function whose signature is x. move l l1 ln moves statements at l1 lnahead of the statement at l. tocnstr x replaces a function whose signature is x by a constructor.
elserevert l inserts else revert atl wherelis the line at which an if statement without else branches ends.
we devised these templates by carefully studying typical causes of security bugs in smart contracts.
insert rep addm move are templates that are commonly used to fix vulnerabilities in smart contracts .
in addition we included the tocnstr template to fix elandsuvulnerabilities whose root cause is a faulty access control due to mistakenly named constructors e.g.
.
we also included elserevert as an auxiliary template that is used in combination with move to fix rebugs as we observed cases where putting the two templates together is essential for fixing rebugs safely and correctly.
component extraction .a patch component c cis a sequence of atomic repair templates i.e.
c a1 an .
while most components are single repair templates to accelerate the repair process we also use components with multiple templates for several special cases e.g.
fixing rebugs often requires applying multiple nonreentrant modifiers .
given an original contract s0and its vulnerability report vr0 extract s0 vr0 outputsc cio cre cel csu ctx where eachcvis a set of patch components for fixing bugs whose type is v.extract collects components from s0 according to vulnerability types and locations reported in vr0.
for example given an alarm io l a b vr0 i.e.
an iobug is detected at a bin linel cio will include a component that inserts a bound check in front of line l i.e.
insert l require a b a .
the component extraction rules for each bug type are explained in the supplementary material.
patch enumeration .a patchpis a sequence of patch components i.e.
p c1 cn c .
given a set of patch components cand a candidate patch p generate returns new candidates as follows generate c s0 p s p c c c .
here p cis a new patch obtained by appending a patch component cto the old patch p andsis a new contract obtained by applying the new patch to the original contract s0.
.
.
patch verification.
given a contract s the job of the patch verifier verify lines and in algorithm is to produce vrand rrfors by performing safety verification and regression detection ons.
we developed the patch verifier on top of verismart an open sourced verification tool for solidity contracts.
safety verification .we obtain the vulnerability report vrfrom vulnerability detection results of verismart its latest version supports the verification of the five types of bugs that we target.
smartfix guarantees patch safety by design as we use the patch verifier based on the formal verification method that can prove the absence of bugs if there are bugs reported from s0but not from a patched contract it is guaranteed that the original bugs from s0were safely fixed w.r.t.
safety conditions defined in the verifier.
for example smartfix outputs the patches in figure only after the patch verifier has formally proven that the safety condition balance value balance is always true at line and therefore line is free of iobugs.
2e.g.
cy 0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.solsmartfix fixing vulnerable smart contracts by accelerating generate and verify repair using statistical models esec fse december san francisco ca usa regression detection .in automatic program repair apr research ensuring patch correctness is an open problem as complete formal specifications on functional correctness are not readily available.
we aim to mitigate this challenge as much as possible by eliminating likely incorrect patches.
specifically we detect incorrect patches by validating them against predefined regression conditions.
for example suppose a patched function consists of the following statements require x a require x a y x a where the underlined statement is a patch to fix the underflow atx ain the last statement.
observe that this patch introduces a regression that is absent in the original function the final statement always assigns the zero value to y as the condition x aholds due to the improper combinations of the two conditions in the first two statements x aandx a. to detect this regression we insert the assertion statement assert y after the last assignment during the preprocessing step require x a require x a y x a assert y here y is a regression condition to see whether yalways gets assigned which would be typically an abnormal behavior.
next in the regression detection step we generate the following verification condition and check its validity x a x a y x a y .
here since the condition is valid i.e.
the likely abnormal property always holds we include this result in rr i.e.
za f rr where zadenotes the regression type for zero value assignments and fis a signature of the patched function.
finally we decide that the patch is regressive because this behavior exists in the patched function only i.e.
rr rr0where rr0 .
we detect three kinds of incorrect patches which can appear in our search space due to improper overlaps of conditionals deadcode e.g.
section zero value assignment e.g.
the example above and effectless assignment the l value s state of an assignment never changes .
we implemented a regression detector as a post analysis procedure invoked after the safety verification.
for efficiency we perform regression detection at program locations likely to be beneficial only.
for example we insert an assertion assert false after guard statements to detect deadcode by checking the feasibility of paths but do not insert it after assignments.
.
guiding repair using statistical models we present the main technical contributions of this paper.
we enhance the basic algorithm using statistical models learned at lines and in algorithm .
at line we construct a unified prior knowledge base koffby collecting knowledge bases obtained from past repair tasks and derive a model moffoffline before entering the repair loop from koff.
the process for line is described in algorithm .
at line in algorithm we compute score which we call safety score is a real number that quantifies how close pis to solution patches patches necessary for generating solution contracts the definition of the function qwill be explained soon.
at line we generate a training data dbased on the verifier s feedback score algorithm learning phase of smartfix input a set of patch components c verification results vr0 vr rr0 rr a candidate patch p learning related data don kon mon moff output don kon mon moff score q p vr0 vr rr0 rr don don d d fc p score .
.
derivemonfromdon kon kon k k p score .
.
setmoffto ifscore 0or a solution contract has not been generated within a predetermined loop bound.
return don kon mon moff and adddtodon.
at line we derive a model mononline during the iteration of the repair loop from don.
at line we create a new knowledge data kbased on score and accumulate ktokon.
a model moffderived offline could misguide the repair procedure because for example a contract under repair could have characteristics different from prior contracts.
thus at line if at least one of the two conditions holds we consider that the model mofflearned offline is unlikely to be useful in the next iterations and thus we invalidatemoff in the implementation the pre set loop bound is .
quantifying verifier s feedback .given a candidate patch p its verification results vr rr and verification results for the original contract vr0 rr0 the function qcomputes a safety score score forpas follows q p vr0 vr rr0 rr vr0 vr p vr0 ifrr rr0and vr vr0 p ifrr rr0or vr vr0 .
in short the main metric of qis the alarm reduction rate against the number of alarms from the original contract.
in the first case where pis a non regressive rr rr0 and equally or more safe vr vr0 candidate we compute a safety score by subtracting the scaled patch size p from the reduced number of alarms vr0 vr and normalizing the result with vr0 .
here subtracting p means that we prefer smaller patches.
this is because as in previous studies e.g.
on automatic program repair we observed that when compared to smaller patches that are equally safe larger patches are likely to contain redundant or incorrect patches.
in the current implementation .
.
in the second case where p is a regressive or more unsafe patch we compute a negative score p forp.
in the remaining of this section we explain the following how to learn models online and offline section .
.
and .
.
and how to use learned models section .
.
.
.
.
learning a model online.
to build a statistical regression modelmononline we produce a training data d don d v1 vn score .
score is a safety score for p computed at line in algorithm .
v1 vn nis a feature vector representation for p. suppose a set of patch components c c1 cn is given where each component cihas a unique identifier i .
the featureesec fse december san francisco ca usa so and oh vector forpis obtained by converting pusing an encoding function fcparameterized by c fc p v1 vn whereviis1 resp.
ifpcontains resp.
does not contain an i th patch component ci.
our feature representation method is inspired from which used a similar representation in the context of learning based program debloating.
given a training dataset doniteratively collected this way mon can be derived using an off the shelf supervised learning algorithm.
in the current implementation we used the one for learning a linear regression model section .
.
.
learning a model offline.
we also try to accelerate the repair procedure using prior knowledge.
more precisely given repair templates that were used to fix some vulnerabilities in past repair attempts we aim to quickly fix similar vulnerabilities using similar templates.
we first explain how we build a new knowledge base line in algorithm and then describe how we derive a statistical model from an existing knowledge base line in algorithm .
constructing knowledge .given a safety score score for a candidate patch p line in algorithm we generate a knowledge datak bp score where bpis an abstract form of pfor abstracting away its code specific information e.g.
line numbers variable names that would not be directly applicable to new contracts.
we convert a patch p cx1 cxm x1 xm n c into an abstract patch bpusing a function i.e.
p bp which is defined as follows p cx1 cxm .
here is a function that returns an abstract patch component for a given patch component c a1 anas follows c insert h fl ts s ifc insert l s drep h fl te e1 op e1 te e2 op e2 ifc rep l e1 e2 addm h fx h m ifc addm x m m nr cnr h fx ifc addm x m m nr move h fl ifc move l l1 ln tocnstr h fx ifc tocnstr x elserevert h fl ifc elserevert l a1 an ifc a1 an each abstract component is built by an abstract component constructor.
for example cnris a constructor for abstracting components that apply nonreentrant denoted nrin the above modifiers for fixing rebugs e.g.
.
in short abstracts information on patch locations line numbers function signatures into function level features and patch expressions statements into types of variables in them.
flis a function that contains line l andfxis a function whose signature is x. ts s resp.
te e returns a set of types of global variables that appear in a statement s resp.
an expression e .op e computes the set of binary operators in e. given a function f or a modifier h f returns its feature h f d f u f p f l f e f x f whered f andu f return the set of types of global variables defined via assignments and used via guards in f and the rest are predicates return if true and if false that check whether a function contains the payable modifier p loops l ether sending1 function minttoken address to uint value public returns bool success require msg.
sender owner require totalsupply value totalsupply fix totalsupply value overflow balances value overflow a a vulnerable code snippet and fix for it.
function minttoken address to uint value public returns bool success require msg.
sender owner balances value overflow totalsupply value overflow b a similar statements reversed code snippet to repair.
figure code snippets for explaining offline learning example and .
statements e and contract deactivating statements x such as selfdestruct in solidity.
the design of the function feature is mostly inspired from where similar abstractions were used to learn probability distributions on vulnerable transaction sequences.
example .
letp insert require totalsupply value totalsupply be a candidate patch in figure a .
suppose the types of the variables are the following address owner uint totalsupply andmapping address uint balances .
then we have bp p that is an abstract patch for p bp insert d f z uint mapping address uint u f z address z h f uint z ts s wherefdenotes the function minttoken in figure a and s require totalsupply value totalsupply .
finally assuming a safety score for pis0.
we obtain a knowledge data k bp .
.
deriving a model from knowledge .to derivemoff line in algorithm we first construct a unified prior knowledge base koff by collecting all knowledge bases from past repair attempts and transform it into a training dataset doff doff v1 vn score bp score koff where v1 vn nis a feature vector for bp.
we obtain v1 vn using a feature encoding function gc i.e.
v1 vn gc bp .gctakes an abstract patch bpand converts it into a binary feature vector that is valid in the context of a contract under repair in that parameterized by c c1 cn gc bp v1 vn whereviis resp.
if bpcontains resp.
does not contain an abstract version of an i th patch component ci i .
once doffis generated we can derive moffby invoking an off the shelf supervised learning algorithm on doffas in section .
.
.
example .
suppose our goal is to fix the code in figure b .
suppose we have a knowledge base koff k wherek bp .
is the knowledge data made in example .
suppose we have a set ofsmartfix fixing vulnerable smart contracts by accelerating generate and verify repair using statistical models esec fse december san francisco ca usa patch components c c1 c2 where c1 insert require balances value balances c2 insert require totalsupply value totalsupply .
note that bpcontains c2 but does not contain c1 c1 insert h f mapping address uint z ts s1 c2 insert h f uint z ts s2 wheref denotes the function minttoken in figure b and h f equalsh f in example and s1 resp.
s2 denotes the statement inc1 resp.
c2 .
thus gc bp the feature vector of bp is .
as a result we obtain doff .
fromkoff.
.
.
using learned models.
we redefine the function cost line in algorithm using learned statistical regression models mon moff to effectively guide the selection of likely candidate patches cost p score p where score computes an expected safety score for a patch p score p moff fc p ifmoff p ifmoff and e e.e v v don mon fc p ifmoff and e e.e v v don .
in the above edenotes the set of all possible one hot vectors in n c dimensions e i i n i i1 in n j 1ij .
in the first case where moffis learned moff we prioritize candidates using moff.
in the second case where moffis not available and impacts of some patch components are unknown yet we perform size based estimations.
in the third case where moff and impacts of all patch components are known we search by prioritizing likely patches according to mon.
note that the function cost is updated at each iteration in accordance with changes of mon andmoff.
further note that in the definition of cost we negate the score s output as our algorithm selects a candidate with the least cost at each iteration line in algorithm .
.
applicability to other types of bugs although we formalized and implemented our approach for the five critical classes of bugs in solidity smart contracts the core principle of our technique machine learning based patch prioritization section .
can be extended to support fixing other types of bugs as well.
as one aspect that supports this claim we note that the function q line in algorithm which quantifies the verifier s feedback does not use any information on bug types.
to fix other kinds of bugs two major extensions are necessary devising patch search space section .
.
for other bugs and extending the analysis scope of the verifier section .
.
.
implementation and optimization implementation .we implemented smartfix in ocaml on top ofverismart an open sourced verification tool for smart contracts written in solidity .
to learn and use statistical regression models section .
we wrote a python script that uses the scikit learn library .
to invoke learning related functions in the python script from ocaml code we used pyml .smartfix provides patch safety section .
.
by design but it might produce unsafe patches for two reasons in practice.
first to produce simple patches as much as possible we used several heuristics for filtering benign ioandrealarms they can be found in the supplementary material.
such intentionally ignored alarms do not appear in vr.
second the underlying verifier may be unsound for some tricky features e.g.
inline assembly .
nonetheless we note that these two potential sources do not significantly harm the practicality of smartfix in our experiments section we have not observed unsafe patches generated due to these reasons.
to accelerate the repair process similar to when enumerating patches section .
.
we prune away candidates likely to perform nonsensical actions e.g.
inserting the same bound checks at the same lines .
while the basic approach section .
almost immediately terminates once a solution contract is found as it enumerates patches in increasing order and wbecomes empty by lines in algorithm the learning based approach section .
may not.
to balance the efficient termination and the patch simplicity once the first solution contract is found the repair loop repeats y 10in the implementation times at most.
acceleration via differential verification .the verificationbased patch validation line in algorithm ensures the patch safety but poses a significant performance problem to smartfix .
we devised a method based on differential verification to further mitigate this issue.
in particular our technique aims to reduce the patch validation cost in the learning based enhanced algorithms section .
which arises due to additional y iterations for finding simpler patches when solution contracts are already found.
suppose a solution contract has been generated and its invariant isi can be obtained as a part of outputs of verismart .
then given a candidate contract s we first check whether iis an inductive invariant of sor not.
if not we immediately break out of the current iteration of the repair loop without performing safety verification and regression detection on s typically more expensive than inductiveness checking and start the new iteration i.e.
pick another candidate contract s at line in algorithm .
that is we expect the invariant of a solution contract to hold in other solution contracts too.
by precisely detecting unpromising candidates and early stopping verification for them this way we can effectively improve the repair performance.
evaluation we evaluate smartfix to answer the following research questions.
how effectively does smartfix repair vulnerable smart contracts?
how does smartfix compare to sguard the state of the art repair tool for smart contracts?
section .
is using statistical models important for improving the performance of smartfix ?
section .
.
experimental setup benchmark .we collected four datasets with annotated bugs.
io bench contracts that contain iobugs which are randomly selected out of cve reported contracts .esec fse december san francisco ca usa so and oh el su bench contracts from which contain eland suvulnerabilities.
re bench contracts with revulnerabilities from three sources contracts from and contracts collected by us contracts from the wild and contracts with injected likely bugs .
tx bench contracts with txvulnerabilities one test contract from and contracts with injected likely bugs.
in total the source lines of the benchmark contracts range from to including contracts that are relatively large lines .
on average the benchmarks consist of lines.
to conduct a more meaningful experiment we applied modifications to the contracts from prior works when constructing there bench .
as several contracts from were buggy and indeed safe from realthough they contain vulnerable code patterns we modified the code so that the intended vulnerabilities can be triggered.
we deduplicated contracts from e.g.
duplicated addresses minor syntactic differences .
we excluded contracts where the root causes of bugs are not related to reentrancy.
for more extensive evaluation on datasets that contain trustful ground truth bugs we constructed our own benchmarks from real world contracts deployed on the ethereum blockchain .
for re bench we collected contracts that contain rebugs without modifications and constructed contracts by manually injecting likely bugs in deployed contracts.
for tx bench we constructed contracts by injecting likely bugs.
we tried hard to inject realistic bugs as much as possible.
in the supplementary material we provide concrete bug injection patterns that we used.
our benchmarks including the refined benchmark set are publicly available section .
comparison tool .we evaluate the effectiveness of smartfix in comparison with sguard the state of the art bug repair tool for solidity contracts.
we could not consider screpair as we failed to run it in our environments despite our best efforts.
we did not consider evm bytecode level patching tools elysium smartshield since comprehending bytecode level changes is difficult and thus evaluating their patch correctness objectively is nontrivial.
given a potentially vulnerable contract both smartfix section and sguard aim to make it vulnerability free.
the overall workflow of sguard is the following.
it first detects all potential bugs by using relatively light weight static analyses control and data dependency analyses to identify certain vulnerable instructions that have dependencies to external function calls .
next it applies bug type specific runtime checks to fix the detected bugs.
for the experiment we used the latest version ofsguard as of february .
sguard currently supports fixing arithmetic vulnerabilities ioand division by zero re and tx.
since its current implementation does not have options for specifying solidity compiler versions and the names of main contracts to be patched we modified its source code to take those information as inputs the modified code is publicly available section .
evaluating correctness .assuring patch correctness remains an open problem in automatic program repair techniques .smartfix andsguard are no exceptions.
thus we manually validated the correctness of patches produced by each tool.
in particular we inspected whether patches safely fix vulnerabilities and do not damage any functionalities of original implementations.
hardware and execution options .all experiments were conducted on ubuntu machine with amd ryzen threadripper 3970x cpu .
ghz cores and threads in total and 62gb of memory.
we ran smartfix using threads at most after putting all contracts together in random order.
we ran sguard using threads at most on contracts excluding contracts in el su bench as it does not support fixing elandsu.
for smartfix we set timeout to minutes for the total repair time algorithm .
we allocated seconds for each invocation of the verifier and the external timeout to minutes technically the former is a time budget for the safety verification and regression checking is done during a separate time budget section .
.
.
we set the timeout to seconds per z3 v. .
.
invocation from the verifier.
for both tools we set the external timeout to minutes.
.
effectiveness of smartfix overall results .table shows repair results on fixing annotated bugs which are likely to be more impactful bugs in contracts.
the column fix rate c b shows end to end fix rates on annotated bugs in entire contracts.
in our experiment sguard generated execution errors uncompilable patched contracts no outputs are generated and timeout on non negligible number of contracts forio bench for re bench and for tx bench .
since these failures vacuously lowered the fix rate of sguard in an effort to favorably evaluate sguard we also report success rate c br a rate of successful fixes on annotated bugs in contracts without execution errors.
when tools correctly fixed annotated bugs but introduced functional regressions in other parts of a contract we considered generated patches to be incorrect.
the results show smartfix is highly competitive in fixing bugs compared to the state of the art.
specifically smartfix was much more effective on commonly supported classes of bugs io re tx achieving a success rate of .
vs. .
and an accuracy of .
vs. .
.
moreover including elandsu which are hardly supported by existing approaches e.g.
that rely on a single repair template for each bug type section smartfixobtained still noticeable results the success rate is .
and the accuracy is .
.
in particular we found smartfix is far more effective than sguard in fixing critical arithmetic overflow bugs io that are assigned cve ids.
concretely smartfix fixed cve reported arithmetic bugs safely and correctly achieving the success rate of .
.
by contrast the success rate of sguard was only .
as the total number of repair attempts was only the column g out of valid repair targets the column br .
this is because sguard relies on a rather restricted fix strategy to reduce false positives i.e.
to reduce the number of patches that are unnecessarily applied to already safe arithmetic operations .
specifically sguard fixes only iobugs that have dependencies to external function calls.
unfortunately such a restricted strategy can result in missing opportunities to fix critical arithmetic bugs as shown in table .
further note that security disasters can happen due to iosmartfix fixing vulnerable smart contracts by accelerating generate and verify repair using statistical models esec fse december san francisco ca usa table results on fixing annotated bugs in each dataset.
b the number of annotated bugs in contracts.
br the number of annotated bugs in contracts that are successfully run by each tool.
g the number of annotated bugs fixed by each tool.
c the number of annotated bugs correctly fixed by each tool.
fix rate c b end to end fix rate on annotated bugs in entire contracts .
success rate c br fix rate on annotated bugs in contracts without execution errors .
accuracy c g. bug type bsmartfix sguard br g c fix rate success rate accuracy br g c fix rate success rate accuracy io .
.
.
.
.
.
re .
.
.
.
.
.
tx .
.
.
.
.
.
el .
.
.
n a n a n a n a n a n a su .
.
.
n a n a n a n a n a n a io re tx .
.
.
.
.
.
total .
.
.
forsmartfix gis counted if no alarms are generated by the patch verifier at annotated lines.
for sguard gis counted if runtime checks are inserted at annotated lines io nonreentrant modifiers are inserted in contracts re or annotated lines have been changed by the patches tx .
bugs irrelevant to external function calls e.g.
cve .
unlike sguard smartfix does not rely on such a rather restricted strategy to reduce false positives as it can identify where to apply patches much more accurately will be discussed shortly with table thanks to the verification based patch validation.
forre sguard incorrectly fixed bugs where of them were incorrect as the patches introduced deadcode due to improper overlaps of nonreentrant modifiers.
by contrast smartfix did not generate such incorrect patches thanks to its verification based regression detection section .
.
achieving .
accuracy.
forelandsu smartfix achieved relatively low fix and success rates and accuracy compared to the numbers for the other types of bugs we discuss the reasons in section .
.
nevertheless we believe the results are overall encouraging in that smartfix is the first repair tool that can safely fix diverse patterns of access control related bugs el su .
patch simplicity .we evaluated the patch simplicity in terms of the number of inserted runtime checks bc the number of bound checks applied to addition subtraction and multiplication for fixing iobugs nr the number of nonreentrant modifiers for fixing rebugs .
we assess the simplicity in terms of bc and nr because bcandnrare the two types of additive repair operators that increase code sizes.
evaluating the patch simplicity is important because redundant patches would be undesirable for developers and they would result in unnecessary payments of gas fees .
table shows that smartfix can generate solution contracts more economically by producing simpler yet safe patches thanks to the verification based patch validation.
to make contracts bug free smartfix used runtime checks which correspond to .
of sguard .
in particular considering that sguard typically fixes fewer iobugs i.e.
fixes only overflows that have dependencies to external calls our result is noteworthy.
scalability .to obtain the results in table the average termination time of smartfix is the following excluding runtimetable comparison on the patch simplicity.
sol the number of solution contracts generated by both tools.
bc the number of inserted bound checks.
nr the number of added nonreentrant modifiers.
dataset solsmartfix sguard smartfix sguard bc nr bc nr bc nr io bench .
re bench .
tx bench .
total .
forsguard the contracts in solare patched contracts that are proven to be free from io re and tx according to its safety criteria .
exception cases 43m for all four datasets 43m io bench 32m re bench 17m tx bench and 51m el su bench .sguard took much smaller time as it uses relatively light weight static analyses 34s for three datasets 39s io bench 8s re bench and 5s tx bench .
considering the importance of safe smart contracts and the benefits of smartfix much higher fix and success rates supporting more classes of bugs patch simplicity we believe its cost is reasonable.
we also found that smartfix can be useful for relatively large contracts too.
in particular smartfix could fix rebugs in contracts consisting of lines and lines.
for annotated bugs from contracts with more than lines the fix and the success rate of smartfix was .
and .
.
the average termination time for contracts without execution errors was 1h m. summary of comparison .the experimental results show that smartfix has two main advantages over sguard by adopting the generate and verify approach.
first smartfix can fix wider ranges of security bugs safely.
for example smartfix can fix more diverse patterns of arithmetic bugs and it can support access control related bugs e.g.
el su which could be hardly supported by tools suchesec fse december san francisco ca usa so and oh generated solution contracts020406080100120cumulative runtime h basic online online offline figure comparison between the variants of smartfix .
assguard that rely on a single repair strategy for each bug type.
second smartfix can generate much simpler patches.
our evaluation also identifies a downside of smartfix .
it could be much more inefficient than sguard when generating patches that are safe by construction.
for example patches that insert runtime checks for iobugs are always safe.
sguard is specialized for producing such patches and therefore fast.
on the other hand smartfix attempts to formally prove safety even in this case.
contract level fixing results .smartfix was also effective at generating solution contracts too smartfix achieved a fix rate of .
and an accuracy of .
on the benchmark contracts.
.
impact of using statistical models to assess the utility of using statistical models section .
we made three variants of smartfix .basic indicates smartfix that performs the basic generate and verify repair it uses the size based cost function in section .
.
online indicates smartfix without offline learning it uses the final cost function in section .
.
where moff always.
online offline indicates the final version of smartfix which combines all of our techniques.
the cactus plot in figure compares the performance of the three variants by visualizing the number of generated solution contracts x axis according to the cumulative termination time y axis .
the results show that using statistical models is critical for greatly enhancing the performance of smartfix .
compared to our baseline approach basic our techniques based on online and offline learning collectively improved the contract level repair effectiveness by .
in terms of generating solution contracts.
we also found that both online and offline learning is crucial as depicted in figure .
although the two enhanced variants online online offline were similar in terms of generating solution contracts within minutes of the termination budget section .
when we counted the number of solution contracts generated within minutes of termination time the performance difference between the variants became more evident basic online online offline .
.
limitations to inspect room for future improvements we manually analyzed why smartfix failed to fix bugs in our experiments.incorrect patches .smartfix incorrectly fixed known annotated bugs g cin table as the patches failed to satisfy contract specific properties that are unspecified at runtime of smartfix .
for example consider the simplified code snippet modifier onlysettler require msg.
sender settler modifier onlyowner require msg.
sender owner function settlebet string randomseed onlysettler ... function setsettler address newsettler onlyowner settler newsettler function withdrawfunds address rcv uint amt onlyowner removed function withdrawfunds address rcv uint amt onlysettler rcv .
send amt ether leak in the above contract for gambling settler is responsible for determining the winner of bets made by players line and owner is responsible for managing the contract such as designating a new settler line .
in the original contract the critical statement send at line which sends ethers amt of the contract to rcv can be executed by any unauthorized user and therefore has the elbug.
smartfix produced the above patch using the modifier onlysettler line which can be considered vulnerability free because settler is an authorized user hence proven to be safe by the patch verifier .
however this patch is incorrect considering the original contract the benchmark was made by removing the modifier onlyowner inwithdrawfunds .
to correctly fix these bugs smartfix should be able to distinguish the roles of settler andowner and infer that withdrawfunds should be only invoked byowner not by another trusted user settler .
unfixed bugs .we identified three main reasons on why smartfixfailed to generate patches.
first smartfix failed due to the limited performance of the verifier.
for example smartfix even could not finish the verification within a verification time budget for a complex original contract line in algorithm causing the abnormal early termination of the repair procedure in the implementation if we fail to obtain vr0and rr0 we just stop the execution .
second smartfix could not effectively handle rather a large search space for candidate patches.
for example smartfixwas able to fix only one bug out of the three annotated bugs for a contract in which patch components were generated to fix potential bugs.
third smartfix failed due to the imprecision of the verifier even though desired patches have been searched the verifier failed to validate their safety.
.
threats to validity we discuss potential threats to validity of our experimental results.
first the four datasets used in our experiments might not be representative despite our significant effort for the benchmark construction section .
thus the effectiveness of smartfix on other new datasets remains to be seen.
second we did not conduct a comprehensive study on the choice of hyperparameter values e.g.
in section .
z3 solving timeout used in our algorithm the efficacy of our techniques might vary if using different values.
related work repairing smart contracts .compared to recent approaches for fixing vulnerable smart contracts before they get deployed smartfix is differentiated in that it achieves high repairability full automation and safety guarantee all at once.smartfix fixing vulnerable smart contracts by accelerating generate and verify repair using statistical models esec fse december san francisco ca usa sguard is a tool that aims to make contracts vulnerabilityfree.
elysium and smartshield are tools that generate patches at evm bytecode level in combination with bug finders such as mythril .
a major weakness of them is that they cannot fix diverse patterns of bugs as they rely on a single repair template for each bug type.
screpair a test based repair tool would be an exception from this limitation as it supports multiple repair strategies by using a genetic search algorithm.
however unlike smartfix screpair does not achieve full automation and patch safety as it relies on test suites for patch validation.
there are also techniques for patching already deployed contracts .smartfix is complementary to these approaches.
for example for patch validation evmpatch uses past transactions as test suites which would not be available before deployment.
by contrast smartfix can safely fix bugs without them.
repairing traditional programs .there are a bunch of prior works on automatically fixing traditional and typically larger programs such as c or java.
in particular our work is closely related to generate and validate approaches which iteratively generate candidate patches using search algorithms until a solution program is found.
our work substantially differs from these works in two aspects.
first while most existing works perform patch validation using test cases we perform verification based patch validation to guarantee safety of generated patches.
second and more importantly we propose a new learning based technique to speed up the repair procedure using statistical models.
our work is also related to approaches that use sound verification techniques for patch validation.
memfix and saver use abstract interpretation specially designed to safely fix memory errors e.g.
memory leak in c c .
by contrast we use hoare style verification techniques to safely fix security vulnerabilities in smart contracts.
similar to ours the work in uses a hoare style verification tool to guarantee patch correctness of c programs assuming functional specifications of programs are available .
the difference is it uses the verifier s feedback the number of alarms in the context of genetic programming while we leverage the verifier s feedback for learning statistical models.
analyzing smart contracts .a number of analyzers for smart contracts have been developed e.g.
.
we believe using other tools in the patch validation could enhance the practicality of smartfix .
for example fuzzers e.g.
would help to filter false alarms of the patch verifier and thus produce more economical patches.
conclusion in this paper we showed that the generate and verify approach can be made practical for repairing vulnerable smart contracts.
previous techniques for automatically repairing smart contracts failed to achieve high repairability full automation or safety guarantee.
the generate and verify approach has the potential to overcome these shortcomings but poses a significant performance challenge.
we presented a learning based technique to accelerate the approach using statistical models derived from the verifier s feedback anddemonstrated that our enhanced method is highly effective at fixing five important classes of vulnerabilities in smart contracts.
data availability the replication package for this paper including the source code ofsmartfix and the benchmarks is publicly available .
acknowledgment we thank dooseop lee for his contribution to the construction of the rebenchmark.
this work was supported by institute of information communications technology planning evaluation iitp grant funded by the korea government msit no.
sw star lab research on highly practical automated software repair .
this work was also supported by institute of information communications technology planning evaluation iitp grant funded by the korea government msit no.
high assurance of smart contract for secure software development life cycle .
this work was also supported by institute of information communications technology planning evaluation iitp grant funded by the korea government msit no.
development of sbom technologies for securing software supply chains .
this research was also supported by the msit ministry of science and ict korea under the ict creative consilience program iitp supervised by the iitp institute for information communications technology planning evaluation .
this work was also supported by the national research foundation of korea nrf grant funded by the korea government msit no.2021r1a5a1021944 .
this research was also supported by basic science research program through the national research foundation of korea nrf funded by the ministry of education 2020r1a6a3a13068761 .