just in time reactive synthesis shahar maoz tel aviv university israelilia shevrin tel aviv university israel abstract reactivesynthesisisanautomatedproceduretoobtainacorrect byconstruction reactive system from its temporal logic specification.
gr is an expressive assume guarantee fragment of ltl that enablesefficientsynthesisandhasbeenrecentlyusedindifferent contexts and application domains.
inthisworkwepresentjust in timesynthesis jits forgr a novelmeanstoexecutesynthesizedreactivesystems.ratherthan constructing a controller at synthesis time we compute next states during system execution and only when they are required.
we provethatjitsdoesnotcompromisethecorrectnessofthesynthesizedsystemexecution.
wefurthershow thatthebasicalgorithm can be extended to enable several variants.
we have implemented jits in the spectra synthesizer.
our evaluation comparing jits to existing tools over known benchmark specifications showsthatjitsreduces totalsynthesistime thesizeofthesynthesisoutput and theloadingtimeforsystem execution allwhilehavinglittletonoeffectonsystemexecution performance.
ccs concepts software and its engineering formal methods .
keywords reactive synthesis gr acm reference format shaharmaozandiliashevrin.
.just in timereactivesynthesis.in 35th ieee acminternationalconferenceonautomatedsoftwareengineering ase september21 virtualevent australia.
acm newyork ny usa pages.
introduction reactivesynthesisisanautomatedproceduretoobtainacorrectby constructionreactivesystemfromitstemporallogicspecification .
rather than manually constructing an implementation andusing modelcheckingtoverify itagainsta specification synthesis offers an approach where a correct implementation of the systemisautomaticallyobtainedforagivenspecification ifsuch an implementation exists.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
ase september virtual event australia association for computing machinery.
acm isbn ... .
ltl thathas an efficient symbolic synthesis algorithm and whose expressivepowercoversmostofthewell knownltlspecification patterns of dwyer et al.
.
gr specifications include assumptionsandguaranteesaboutwhatneedstoholdonallinitial states onall statesand transitions safety and infinitelyoften on every run justice .
gr synthesis has been used and extended in different contexts and for different application domains including robotics scenario based specifications aspect languages event basedbehaviormodels hybridsystems and device drivers to name a few.
the synthesis algorithm in as implemented with some variations in existing gr synthesizers ratsy slugs and spectra consistsoftwophases.inthefirstphase thealgorithm checks for realizability.
if the specification is found to be realizable inthefirstphase synthesiscontinuestothesecondphase where it constructs a controller using memory collected in the first phase.
according to experience reported on in and supported by evidencewereportinourevaluation inmanycasesthefirstphase of realizability checking takes only a small fraction of the total synthesis time.
most of the time is spent in the second phase of controller construction.
in this work we introduce just in time synthesis jits a novel means to execute synthesized reactive systems whichskipsthecontrollerconstructionphase.instead itefficientlystoresthememorycollectedinthefirstphaseofre alizability checking and uses it during system execution tocompute next states only when they are required.
the con troller is never constructed.
however importantly as thenextstatecomputationisperformedusingthememorythat was collected during realizability checking jits keeps system execution correct by construction.
as jits skips construction it is expected to dramatically reduce the overall synthesis time.
moreover jits symbolic representation of the memory that is required for correct execution consists ofchains of very similar bdds and makes storing it at the end of synthesis and loading it just before system execution very efficient.
during system execution at each step jits manipulates only a smallnumberofbdds eachofrelativelysmallsize andthusthe effect on performance of the just in time next states computation is kept to a minimum.
beyondperformance fromarchitecturalandmethodologicalperspectives jits decouples synthesis realizability checking from system execution.
this decoupling is significant as indeed synthesistakesplaceatdevelopmenttimeandisexecutedondevelopment machines while system execution i.e.
the actual running of the synthesized system will typically run on very different machines e.g.
onarobot.thedecoupling whichisuniquetojits enables flexibility in system execution and supports for example exten sions and variants that aim to improve qualitative aspects of the 35th ieee acm international conference on automated software engineering ase execution such as eagerness recovery and configurability.
see sect.
.
finally jitsisdefinedforgr andthusseamlesslysupports any specification that is reduced to gr .
in particular the use of jits is independent of the use of advanced constructs such aspast ltl operators patterns counters etc.
as supported e.g.
inspectra .
our evaluation of jits see below indeed includes such rich specifications.
we have implemented jitson top of the spectra synthesizer using its implementation of realizability checking ignoring its implementationofcontrollerconstruction .toevaluatejits we compared it against existing tools over specifications from publicly available benchmarks.
the results show that jits outperforms existing tools in all aspects of synthesis including time and memory andthatitsoutputsofthesynthesisphasearesmallerandtypically faster to load.
in practical terms it makes the execution of systems withratherlargespecificationsfeasibleevenonenvironmentswith limited resources.
see sect.
.
theremainderofthepaperisstructuredasfollows.insect.2we providenecessarybackgroundongr realizabilityandcontroller construction.
in sect.
we present the jits approach and prove its correctness.
in sect.
we discuss several optional extensions to jits.insect.5wepresentourevaluationsforjitssynthesisand execution as compared to other tools.
finally in sect.
and sect.
we discuss related work and conclude.
preliminaries werecallthenotionsofrealizabilityandsynthesis gr realizability problem and the controller construction algorithm from .
.
ltl realizability and synthesis the interaction of a reactive system with its environment is bestseenasaturn basedinfinitedurationgamewhereineachof its roundsthe environment first chooses an assignmentto its input variables and the system responds by choosing an assignment toitsoutputvariables.then anltlformulaovertheseboolean variablescanbeusedasaspecificationforthebehaviorofadesired reactive system.
weconsiderreactivesystemsthatcanbeimplementedby controllersof finite size i.e.
by finite mealy machines that compute their outputs.
a controller realizesan ltl specification if for all environmentinputs itprescribesoutputsthatresultincomputationswhichsatisfy .wesaythat isrealizable ifsuchacontroller exists.otherwise isunrealizable.itiswell knownthat finitecontrollersaresufficientforrealizabilityofltlspecifications .the goalof ltl synthesis is given anltlspecification toconstructa controller that realizes it if it is realizable.
.
gr realizability problem gr synthesis handles a fragment of ltl where specifications have a predefined syntactic structure.
specifically they containinitialassumptionsandguaranteesoverinitialstates denoted eand sresp.
safety assumptions and guarantees relating the current and next state denoted eand sresp.
and justice assumptionsandguaranteesrequiringthatanassertionholdsinfinitely many times during a computation denoted jeandjsresp.
.gr synthesishasthefollowingnotionofrealizability1defined by the ltl formula e g e logicalanddisplay.
i ..mgfje i s g s logicalanddisplay.
j ..ngfjs j the gr realizability problem is formulated as a two player game between the system and the environment and reduces to decidingthewinnerinsuchgame.intuitively thesystemwinsif it has a strategy that allows it to satisfy its njustice guarantees infinitely often while maintaining initial and safety guarantees or forcetheenvironmenttoviolateanyofits mjusticeassumptions or its initial or safety assumptions.
we denote the states from which the system can force the environment to visit a state in xby x also called the controlled predecessors defined as x c 2x y x 2x e c x y 2y s c angbracketleftx y angbracketright angbracketleftx y angbracketright x the winning states are characterized using the following threelevel nested calculus formula from wsys z.n intersectiondisplay.
j 1 y.m uniondisplay.
i 1 x. js j z y je i x theoutputofformula2isthesetofwinningstatesforthesystem player.
.
gr original controller construction the realizability checking algorithm outputs additional intermediateresultsofthenestedfixed pointcomputationsfromeq.
stored inmx andmy .
these intermediate results along with the winningset wsys arepresentedasfollows.weuse1 basedindexes for the justice assumptions and guarantees to conform with the notation in .
.
.
.
mx represents the set of states in which the system is at most rsteps from the satisfaction of js j the system is at rank r andfromanystateinthisset thesystemcaneitherkeepforcing theenvironmenttoviolate je i oralternativelymoveonestepcloser towards satisfying js j. it is the result of the safety game innermost greatest fixed point computation from formula .
specifically when r mx representsthesetofstates inwhichthesystemeithersatisfies js j orforcestheenvironment to violate je i. .
.
.
my represents the set of states in which the system is at mostrsteps fromthe satisfaction of js j. fromany state inthis set the system can either force the environment to violate at least oneje ifor some i or move one step closer towards satisfying js j. my is defined as follows my uniondisplay.
i mx 1thereexistsastrict moreinvolvedvariantofrealizability .however thedifference is not relevant for the paper.
636itisanintermediateresultoftheinnerreachabilitygameleast fixed point computation from formula .
we denote by rjthe number of iterations during this computation.
it holds that j r rj.
parenleftbig my my parenrightbig specifically my is the result of the reachability game inner leastfixed pointcomputation.fromthisset thesystemcaneventuallysatisfy js j orforcetheenvironmenttoviolatesomejustice assumption.
.
.
.finally wsys denoted zfromnowon representsthesetof states in which the system can act towards satisfying allits justice guarantees in a round robin fashion or can force the environment to violate any of its assumptions.
it is the winning set of the gr game and the result of the safety game outermost greatest fixedpoint computation.
duringthe iterations of this computation the inner reachability games are adjusted each time to stop within the boundaries of z hence finally j.z my from these intermediate results bloem et al.
show how to constructacontrollerimplementingawinningstrategyasdescribed in alg.
.
we briefly present the algorithm.
letzndenotethevariablerepresentingtheindexofthecurrent justicegoal.primedbdds e.g.
x prime denotethesetofstates x but where variables refer to their next value.
denote as e s. as the bdd responsible for the transitions safety contains both primedandunprimedvariables.denote astheadditionoperation modulon.
theconstructionisdividedintothreeparts.eachpartconjuncts valid transitions to the controller i.e.
relations between current and next states givenj a 1transition lines is taken from z states wherecurrentstatesatisfiesjusticeguarantee js j.inthis case znis updated with j and next states are in z. givenj andr a 2transition lines is taken from my states where rank ris minimal namely currentstateisin my butnotin uniontext.
r prime rmy .inthiscase controller proceeds to my .
givenj r andi a 3transition lines is taken from mx states where current state violatesje i andrandiareminimal namely currentstateisin mx but not in uniontext.
r prime i primemx forr prime rorr prime rand i prime i. in this case the controller remains in mx .
theoutputofalg.1isasinglebddovervariables x yand znthat describes a reactive controller i.e.
a finite mealy machine.
since this representation uses a pre computed bdd we refer to it hereasthe staticapproach todifferentiatefromourjust in time approach.
bloemetal.
showthatthisconstructionissoundandcomplete i.e.
thatallnextstatesreturnedarewinningforthesystem and that if there is a winning next state at least one is returned.algorithm controller construction for the static approach input z my mx trans true for allj do 1transitions transj zn j z js j transj transj z prime z primen j trans trans transj end for for allj do 2transitions low my for allr do transjr zn j my low transjr transjr low prime z primen j trans trans transjr low low my end for end for for allj do 3transitions low my for allr do for alli do transjri zn j mx low je i transjri transjri mx prime z primen j trans trans transjri low low mx end for end for end for returntrans .
gr original controller execution beforesystemexecution thisbdd denoted trans isloaded andis used during execution to compute next possible assignments to all systemvariables asweshowinalg.
.onestepoftheexecution consistsoftheenvironmentchoosingvaluesforthenextinput after which the system must choose values for the next state output from the result set of alg.
.
in alg.
c 2x yis a bdd describing the current state of the variables.
x 2xis a bdd describing environment inputs.
jis the index of the current justice goal.
the execution itself is straightforward.
it conjuncts transwith current state c inputsxprimed and the assignment zn j. observe that the resulting bdd t represents a subset of transitions encoded in transthat conform tothegiveninputs.thecontrollerextractsthenextstatesfrom t by quantifying out unprimed variables and unpriming the result intuitively it means moving to the next step in the game .
fromtheoutputofalg.
thecontrollerpicksoneassignment to variables over y zn which is regarded as the next state.
this assignment can be chosen at random or by applying some deterministic rule.
we assume that environment inputs are checked for correctness prior to the call to alg.
namely they do not violate the safety assumptions.incaseofaninvalidinputthecontrollermayraisean error message.
637algorithm controller next states for the static approach input c 2x y x 2x j t zn j c x prime trans wheretransis from alg.
t quantifyoutunprimedvars t t unprime t returnt just in time synthesis we are now ready to present the main contribution.
the jits solution is divided into two separate phases storing and execution.
we use set theoretic and logic notation interchangeably when describing operations on bdds as representations of sets and as boolean functions respectively .
.
storing given the intermediate results computed by the realizability checking algorithm we make the following key observations.
.
.
.
my andzare derived from the array of mx fixedpoints as seen in equ.
and equ.
.
thus even though they are crucialforcorrectexecution storingthemforlateruseisredundant.
.
.
.the mx array holds many bdds each of which describes a set of states.
while there are summationtext.
j m rjsuch bdds in total we expect them to be similar to one another because they represent monotonic sequences of sets i.e.
ordered by subset relation.
formally j r rj i. parenleftbig mx mx parenrightbig equation holds following equ.
and equ.
.
one may hope to take advantage of this similarity when storing them.
.
.
.whenencodingmultiplebddstoafileondisk thememory optimizationachievedbysharingnodesintheinternalbddengine between these bdds is lost if they are encoded separately.
basedonthesethreeobservations jitsencodestherequireddata in a single bddover three new variables j r i and the variables x yas follows xs logicalanddisplay.
j r i parenleftbig j j r r i i mx parenrightbig at the end of the construction phase jits stores the bdd xs along with the bdds representing the justice assumptions je i justice guarantees js j initial and safety formulas s e sand e fromtheoriginalspecification.asourevaluationshows seesect.
this representation is highly efficient.
together as we explain next the stored bdds provide all the necessary information for correct execution.
.
execution .
.
loading.
systemexecutionstartsbyloadingthebddsstored at the end of the storing phase.
as part of loading jits extracts everymx toanarraybyrestrictingthe xsbddtoeveryunique assignmentof the j r andivariables and computes my arrayaccordingtodefinitionfromequ.
.jitsalsoomits zcalculation since it holds that z my from equ.
.
jitsloadstheinitialandsafetybdds andsets s e. as wellasallprimedversionsof mx andmy bddsarecomputed at load time and cached for later use.
note that the variable zn is absent from the bdd state space of jits.
as we show in our evaluation jitsloadingtimeistypicallyshorterthanthatofthe static approach and the longer the loading time with the static approach the shorter jits loading time becomes in comparison reaching order of magnitudes relative improvement .
.
.
step wise execution.
at the end of loading jits is ready for step wise execution as we show in alg.
.
this step wise execu tion algorithm acts as an eager just in time implementation of alg.
static construction and alg.
execution.
as in the static approach we assume correct environment inputs and in case of aninvalidinput whichviolatessafetyassumptions canraisean error message.
during runtime jits maintains on the algorithm level a helper indexrminthat keeps the current rank distance from js j .
jits maintains this index such that after initialization and at the end of each step it points to the lowest rank possible.
thealgorithmfirstchecksifthecurrentstate csatisfiesjs j.a ccording to the 1transitions from the static construction next states should be the whole zset.
jits instead performs an eager look ahead to find the lowest rank for next justice goal given environmentinputs x andupdates rmin.thebdd n whichrepresents the next states is assigned with my .
lines .
otherwise jits tries to decrease rank.
according to the 2transitionsfromthestaticconstruction nextstatesisthe my set.asbefore jitsperformsaneagerlook aheadtofindthenext lowest rank possible for the current goal.
it updates rminand assignsntomy lines .
note that it is not always possible to decrease rank from cwith inputsx since for every jandr my contains not only the controlled predecessors of my but also the results of m safetygamesforthisrankthatforcejusticeassumptionviolation.
another possibility is that rminis currently yet justice goal is not satisfied.in thesecases jitsresorts toforce theenvironment toviolate some je i.it computesthe minimal iminforthat purpose and assigns ntomx lines .
the final part is similar to alg.
.
jits conjuncts nin its primed state with c x prime .
then it processes the result by quantifying out unprimed variables and unpriming and finally returns a bdd that represents a set of possible next assignments over y. observe that at this stage the next justice goal jis already decided.
as in thestaticapproach asingleassignmentcanbechosenatrandom or deterministically.
remark1 eagerness .
apropertyofjitsthatonemightconsidereager isthatitfirstandforemostconsiderstransitionsthatmake progress towards satisfying the current justice guarantee and resorts to justice assumption violation only if conditions are not met.
theoriginal construction from on the other hand always considers 3transitions from any step since they were already added to trans bdd regardless.
638algorithm controller next states for jits input c 2x y x 2x j ifc js jthen corresponds to 1from alg.
j prime j rmin min r c x prime my prime nequal n my else j prime j rnew min r c x prime my prime nequal ifrnew rminthen corresponds to 2from alg.
rmin rnew n my else corresponds to 3from alg.
imin min i c mx n mx end if end if t c x prime n prime t quantifyoutunprimedvars t t unprime t returnt specifically this creates a redundancy that the static construction suffers from and of which jits is devoid.
when the current state satisfiesjs j alg.
outputs as next states both z withzn j andmx for somei withzn j since both 1 and 3transitions are available.
this may result in pairs of states that agree on all variable values in x yand disagree on the value ofzn.bloemetal.
attempttotacklethiscaseandminimizethe transition system but at the cost of a much larger bdd according to their evaluation.
in jits due to the inherent eagerness this problem does not exist.
.
soundness and deadlock freedom jits next states algorithm alg.
is sound w.r.t.
the original static approach i.e.
it does not return a state that the original static approachwouldnothaveproduced.moreover jitsisdeadlock free w.r.t.
the static approach in the following sense italways returns a correct set of next states if at least one such state exists.
the remainder of this subsection formalizes and proves these claims.
.
.
formalization.
webridgethegapbetweentheoutputformat of alg.
where multiple possible assignments of znare part of the result bdd t and alg.
where the next justice goal is deterministic and maintained outside the bdd state space.
weusethetuple s k wheres 2yandk todescribe an assignment sto system variables over yalong with a justice goalindex k.wedescribethebddoutputsofthestaticapproach and jits next state functions as a set of such tuples.
givenc 2x y x 2x andj wedenote nsstatic astheoutputofalg.2and nsjitsastheoutputofalg.
inthe formofasetoftuples s k .letj primebethevalueofthejusticegoal index by the end of alg.
for inputs c x andj.
observe that for everytuple s k nsjits khasthesamevalue whichis j prime whileforeverytuple s k nsstatic kcanbeeither jorj according tozn .
weproceedtostatethetheorems.weassumecorrectenvironment behavior i.e.
environment inputs that do not violate theenvironment assumptions.
soundness and deadlock freedom for the case of an environment assumption violation are trivial.
theorem jits is sound .
for every c 2x y x 2x and j nsjits nsstatic note the use of in thm.
.
equality happens when a 3transition is the onlytransition possible according to alg.
.
in this case bothjitsandthestaticapproachkeepthejusticeguaranteegoal indexintactandreturnnextstatesin mx forsamevaluesof r andi.inallothercases therelationbetween nsjitsandnsstatic is a strict inclusion.
in these cases 2or 1transitions are possible aswell.whilejitswillignoreany 3transitionsthen thestatic approach will consider all possible transitions.
theorem2 jitsisdeadlock free .
forevery c 2x y x 2x andj nsstatic nequal nsjits nequal .
.
proofs.
denote the set of the intermediate results of the fixed point computations bdds as fp fp z uniondisplay.
j r my uniondisplay.
j r i mx observe that transbdd is a disjunction of transitions each of which is a bdd of the following form zn a b prime zn prime a fprepresents a current set of states b prime fp primerepresents a primed next set of states znrepresents an assignment to zn andzn primerepresentsanextassignmentto zn.therefore line1in alg.
can be rewritten as t zn j c x prime parenleftbig logicalordisplay.
all transitionszn a b prime zn prime parenrightbig alg.
extracts the next states from tby targeting only primed variables.
hence we define nsstaticas follows nsstatic s y s zn s x parenleftbig logicalordisplay.
all transitionsb zn parenrightbig observe that zn s support is the single variable zn.
we may restrictznvalue to some k and define nsstatic k nsstatic k s y k s x parenleftbig logicalordisplay.
zn kb parenrightbig naturally nsstatic k nsstatic.
similarly jitsextractsthenextstatesfrom t whichwascomputed in line in alg.
.
we define nsjitsas follows nsjits s j prime s x n n fp z is the bdd of next states.
j primeis the justice goal index at the end of alg.
for the given inputs.
639proof of thm.
jits is sound.
it is enough to show that nsjits nsstatic j prime .
considering that xand bdds appear on both sides it is enough to show that n uniontext.
zn j primeb.
weconsiderthreecases basedontheassignmentto ninalg.
nistheresultofcurrentstate csatisfying js j lines3 .inthis case j prime j andn my .
there is a corresponding 1transition with b zthat also updateszntoj .
from equ.
and equ.
we know that my my z. nistheresultofthesystemprogressingatleastonesteptowards satisfying its justice goal lines .
in this case j prime jand n my for the lowest computed rmin.
since previous rwas minimal such that c my there is a corresponding 2transition with b my that retains znvalue.
from the fact that rmin r and from equ.
we know that my my .
nistheresultofthesystemstayingatthesamedistancefrom thejusticegoalandinsteadforcingtheenvironmenttoviolate je ifor the minimal i lines .
in this case j prime jandn mx .
sinceiis minimal such that c mx there is a corresponding 3transition with b mx that retains znvalue.
square proof of thm.
jits is deadlock free.
first we show that nsstatic nequal nsstatic j prime nequal .
consider two cases there is a state s j nsstaticthat is a result of a 1 transition which also updates zntoj .
hence current state satisfiesjs jandsoj prime j 1injits.thereforethisstateisalso innsstatic j prime .
allstates s j nsstaticaretheresultof 2or 3transitions which keep znintact.
hence j prime jin jits as well and same states are in nsstatic j prime .
we complete the proof by showing that nsstatic j prime nequal nsjits nequal .
similarlyto thm.
wecancel out xand and show that uniontext.
zn j primeb nequal impliesn nequal .
we consider two cases there is a b fpin uniontext.
zn j primebthat is a result of a 1or 2 transition.
in alg.
either current state satisfies the current justice goal lines or it is possible to decrease rat least by one lines .
in any case nis assigned with one of the my bdds.
allb fpin uniontext.
zn j primebare the result of 3transitions.
in this case thecontrollercannotprogresstowardssatisfyingcurrent justicegoal.alg.3doesn tchange jandrindexes andassigns nwith one of the mx bdds lines .
square extensions thanks to the decoupling of synthesis from system execution jits opensthewayforsynthesisindependentextensionsthatcanchange system behavior at runtime without the need to re synthesize the specification.theseextensionscanbeimplementedasvariantsof the controller loading procedures and of alg.
.
the extensionsoughttobeindependentofeachother andideallyoneshouldbe able to combine multiple extensions during execution.
we present three such example extensions.
.
justice guarantees bookkeeping schlaipferetal.
suggested bookkeeping asamethodtosatisfy eachjusticeguaranteeasquicklyaspossible.thisisachievedvia a boolean array that keeps track of the guarantees satisfied in the current round and a master bit.
on each step the bookkeepingcode checks whether any guarantee other than the current goalis satisfied and marks the relevant index in the boolean array accordingtothemasterbit.whenthecurrentjusticegoalissatisfied andthesystemchoosesitsnextgoal itusesthearraytoretrieve the smallest index not yet marked.
once all indexes in the array are marked it flips the master bit and starts a new round with the bookkeeping array and the master bit having inverted values.
we have added optional bookkeeping feature as an extension to the basic jits with a slightly improved algorithm.
our method tracks unsatisfied guarantees both backwards and forwards i.e.
it doesnotwaituntilafullroundofjusticeguaranteesiscompleted before it checks on a specific guarantee but does so on every step.
the bookkeeping extension changes the basic jits in two locations.
first we add bookkeeping array management code before the call to jits next states computation alg.
.
this code iterates overalljusticeguarantees foreach js kthatissatisfiedbythecurrentstate thecodemarksthecorrespondingindex kinthebkarray accordingtothe masterbit.guaranteeswhoseindexissmallerthan jits current goal are marked with the opposite value of master.
this way our method begins to track a new round even before the system has satisfied all the remaining guarantees on the list.
second we replaced line in alg.
with the code in alg.
which returns the next justice goal according to bk master and the current goal j. the method iterates over the justice guarantees startingfromthe j thplaceandfindsthesmallestindexwhose justiceguaranteehasnotyetbeensatisfied.onceitreachestheend of the array it flips the masterto indicate that a round of justice guarantees has been completed and then continues to iterate from 0t oj.
note that in case all indexes in the bkarray are marked the algorithm simply returns to j. specifically this means that while working its way to js j the system has already satisfied all its other justice guarantees.
.
recovery wongetal.
suggestedcontrollerimplementationsthatattempt torecoverincaseofenvironmentsafetyassumptionviolation.this isachievedbyalteringtheoriginal staticcontrollerconstruction phase removing the check whether a transition with a given environmentinputsatisfies eandisthereforeallowed andinstead considering allnext input possibilities.
then the construction still attemptstofindtransitionsthatensurethatthenextstatecankeep satisfying the winning conditions although such a next state may not exist.
we have added optional recovery feature as an extension to the basicjits.recallthatweassumedcorrectenvironmentbehaviorin the previous sections.
in this extension we revisit this assumption 640algorithm controller next states for jits with bookkeeping input c 2x y x 2x j ...n for allk do ifbk masterandc js kthen bk master end if end for for allk do ifbk masterandc js kthen bk master end if end for returnnext states c x j call alg.
algorithm next justice goal for jits with bookkeeping input j for allk do ifbk masterthen returnk end if end for master master for allk do ifbk masterthen returnk end if end for returnj and do expect inputs that may violate environment safeties e during runtime instead of returning an error we proceed with the jits next states algorithm and attempt to find a valid next state.
recall that jits always returns next states that are contained in z which is the winning states set.
still as in the static controller recovery in it may be the case that due to the environment safetyviolation nosuchpossiblenextstateexists andthusnosuch next state will be returned.
only in this case the jits recovery extension returns an error same as in the basic jits variant.
.
configurable set of justice guarantees configurabilityisaknownextrafunctionalrequirement.givena familyofcloselyrelatedproducts ratherthandevelopingaseparate softwareforeach oneisencouragedtodesignanddevelopasingleproduct that can be customized to a specific subset of the complete requirements at deployment time.
configurability is related to the ideaandmethodologyofsoftwareproductlines.toapplyconfigura bilitytoourdomainofsynthesizedreactivesystems aconfigurablecontroller may be one that supports a set of justice guarantees that is chosen from a larger superset of justice guarantees.
inthestaticapproach inordertoachievesuchconfigurability a uniquecontroller mustbesynthesized foreachrelevant subsetof the justice guarantees or alternatively a unique flag variable must bemaintainedinside thespecificationtorepresenttherelevanceof each justice guarantee adding to the overall state space and complexity of the specification.
in jits however this kind of configurability can be achieved at execution time via an extension that receives at load time a set ofrequiredjusticeguaranteeindexesasanargument.duringthe extraction phase jits skips those indexes that are not in the set thusloadingonlythebddsrelevanttotheremainingindexes.this solution does not affect synthesis time.
it only requires that the complete specification containing allthe guarantees is realizable.
naturally whenthecompletespecificationisrealizable anyvariant with only a subset of the justice guarantees is realizable as well.
moreover anyvariantwillbeavailableatdeploymenttime sinceit depends only on the required justice guarantees indexes argument.
wehaveimplementedthisfunctionalityofconfigurablesetof justiceguaranteesasanoptionalextensiontothebasicjits.the extension receives a set of required justice guarantee indexes as an argument and loads only the bdds relevant to these indexes.
note that an execution based on the original basic jits is still correct as the required set of justice guarantees is a subset of the completesuperset.
however one may expect that given a strict subset of justice guarantees indexes the extension typically loads faster and takes less memory than the original basic jits.
implementation and evaluation wehaveimplementedjitsintheopensourcespectra which alreadyincludesagr synthesizerandimplementationsofseveral additional analyses.
our implementation in java uses bdds via the cudd .
package.
realizability checking includes heuristics described in .
all specifications used in our evaluation the raw data we collected and the code to reproduce our experiments are available in supporting materials .
we consider the following research questions.
rq0how does static controller construction time compare with realizability checking time?
rq1how does jits compare with existing approaches duringsynthesis w.r.t.
time memory usage and size of its output representation?
rq2how does jits compare with existing approaches duringsystem execution w.r.t.
load time memory usage and step time?
belowwereportontheexperimentswehaveconductedinorder to answer the above questions.
.
corpus of specifications we evaluate jits using two sets of benchmark specifications from the literature.
first arm sambaahbarbiter amba andibm sgeneralized buffer genbuf .
these two specifications have been extensivelyused in the gr literature for evaluation purposes e.g.
in .
they are valuable as they are parametric and therefore suitable for examining scalability.
second specifications from the syntech benchmarks available from the spectra website.
these specifications were writtenby3rdyearcsundergradsinclassprojectstaughtbytheauthorsof .
the benchmarks have been used in some works .
641they include several versions of each specification submitted by thestudents.
weuse herethe largestspecifications i.e.
allspecifications where the total number of variables is greater than .
for each we use the final specification the students submitted.
in total we use specifications from the syntech benchmarks.
.
validation we have systematically and automatically validated the correctnessofourimplementationbycreatingatestthatrunsthestatic approach controller and the jits step by step in parallel against thesameenvironmentbehaviors andineverystep checksthatthe choice of next state by the latter is included in the possible next statessuggestedbytheformer.weexecutedthistestoverallthe specifications in our corpus against a random environment for runsof10 000steps.thisvalidationincreasesourconfidenceinthe correctness of our ideas and their implementation.
.
experiment setups weusedtwoseparateexperimentsetups onetoexaminesynthesis rq0 rq1 the other to examine system execution rq2 .
.
.
synthesis setup.
forthe synthesissetup wecompared jits againsttwoexistingtools slugs andspectra .weusedthe latestversionsofslugsandspectrafromgithubandonlyadded minimalcodetomeasuretimeandmemory.bothtoolsuse variants of theoriginalapproachfrom .spectrarealizabilitychecking includesallheuristicsdescribedin .wechosetocomparespectra against slugs and not against other gr synthesizers e.g.
ratsy as according to results in the larger the specification thefasterslugsrealizabilitycheckingtimecomparedtothatof ratsy.
moreover slugs is a more recent tool the version of slugs that we used is the latest available from june .
wemeasuredsynthesistime memoryused andsizeofoutput as follows.
synthesis time is the time of realizability checking combinedwithcontrollerconstructionorstoringtime.memoryusedis thenumberofactivebddnodesasreportedbycudd.notethat memory usage is as an important metric as indeed some specificationscouldnotbesynthesized executedsuccessfullybythestatic approach due to an out of memory error.
the size of the output is the size of the output on disk.
we used a fixed timeout of two hours.
we mark timeouts by .insomecasesslugsresultedinanout of memoryerrorduring synthesis.
we mark thesecases by xx.
when synthesisfailed due to any of these cases we mark the other measures as n a. all values we report are median values of runs per specification per tool.times wereportaremeasured byjavain milliseconds.even though the algorithms we deal with are deterministic we repeated each experiment times since jvm garbage collection and cudd garbage collection add variance to running times.
for the specifications available for slugs amba and genbuf wetooktheequivalentspectraspecificationsavailablefrom and usedthem inthe comparisonbetween thethree tools.for the specificationsfromthesyntechbenchmarks whicharericher e.g.
include patterns and therefore not available for slugs we compared only between spectra and jits.
in this setup we run all experiments on an ordinary pc intel xeonw 2133cpu3.6ghz 32gbramwithwindows1064 bitos table1 comparisonofconstructionvs.realizabilityrunningtimes for slugs and spectra specificationsynthesis time sec slugs spectra real.
constr.
real.
constr.
amba1 .
.
.
.
amba2 .
.
.
.
amba3 .
.
.
.
amba4 .
.
.
.
amba5 n a .
amba10 n a .
genbuf5 .
.
.
.
genbuf10 .
.
.
.
genbuf20 .
xx .
.
genbuf30 .
xx .
.
genbuf40 .
xx .
.
genbuf90 .
xx .
.
airportshuttle .
.
junction2 .
.
junction3 .
.
roboticarm .
.
simplevehicle .
.
java864bit andcudd3compiledfor64bit usingonlyasingle core of the cpu.
.
.
system execution setup.
for the system execution setup we comparedjitswithandwithoutthebookkeepingextensionagainst spectra.
we could not compare againt slugs because to the best of our knowledge it does not provide a direct controller execution api.
we measured load time memory used and step time.
we load the controller and execute it for steps against a random environment.
load time includes loading the bdds caching as described in sect.
.
and the initial step.
memory used is the number of active bddnodesasreportedbycuddlibraryattheendoftheexecution.
steptimeisthetimetocomputethenextstep.weuseaveragesteptimeoverthe10 000steps.timeswereportaremedianvaluesof10 runs of steps each per specification per tool measured by java in milliseconds.
again we repeated each experiment times to accommodate for the variance in running times.
insomecasesspectraresultedinanout of memoryerrorduring load.wemarkthesecasesby xx andconsequentlywemarkthe other measures for the same specification by n a. in this setup we run all experiments on a raspberry pi model b with 900mhz quad core arm cortex a7 cpu 1gb of ram with raspbian bit os java8 32bit and cudd compiled for 32bit using only a single core of the cpu.
we chose this rather weak computer different and much weaker thanthe computer on whichwerunsynthesis asanexampleofatargetplatformfora synthesized controller e.g.
a robot.
.
results realizability vs. construction table presents a comparison between realizability and controller construction times in seconds for spectra and slugs.
642theresultsshowthatinbothtools formostofthespecifications constructiontakesconsiderablymoretimethanrealizability except for the amba specifications for slugs and airportshuttle .
for amba5 and up slugs could not complete realizability checking and spectra could not complete construction within the hours timeout.
for genbuf20 and up slugs construction resulted in an out of memory error.
in the extreme case of junction3 more than ofthetotalsynthesistimewasspentoncontrollerconstruction.
toanswerrq0 wehaveevidenceshowingthatinbothtoolsand for most of the specifications construction takes significantlymoretimethanrealizabilitychecking.thisevidenceisconsistentwithdatareportedonin .theseresultsstrengthenthe motivation for jits which skips controller construction.
.
results synthesis table2presentstheresultsforsynthesis.foreachofthethreetools weshowconstruction storingtimeinseconds numberofactive nodesinthousands andspaceondiskinmb.notethatjitsuses spectra realizability checking but replaces spectra construction with storing.
amba and genbuf .
in terms of construction time the results show that while slugs and spectra grow very fast with the size ofthespecification numberofmasters numberofsenders jits storingtimegrows butmuchslower.inabsoluteterms inallbut one specification the smallest amba1 jits performs better than bothothertools sometimemorethananorderofmagnitudebetter.
in general the larger the specification the better the performance of jits relative to the two other tools.
similarily intermsofactivenodesandspaceondisk theresults show that whileslugs and spectragrowvery fast with thesize of the specification jits growth is much slower.syntech .thetablefurtherpresentstheresultsonspecifications from the syntech benchmarks.
this part of the table does not include data for slugs as these specifications are rich they include patterns monitors etc.
which are not supported by slugs.
in terms of construction time spectra is in all cases higher than jitsstoringtime.asexpected storingismuchfasterthanconstruction.
intermsofactivenodesandspaceondisk theresultsshowthat jitsrequireslessmemoryanditsoutput ssizeondiskissmaller in most cases by a factor of or more.
to answer rq1 jits outperforms existing approaches w.r.t.
construction time memory usage and output size sometimes by orders of magnitude.
moreover jits scales better than the other two tools.
the larger the specification the better jits synthesis time memoryusage andsizeondiskcomparedtotheothertwo tools.
.
results system execution table3presentstheresultsforsystemexecution.foreachofthe twotools weshowloadtimeinseconds numberofactivenodesbytheendoftheexecutioninthousands andsteptimeinmilliseconds.
for the number of active nodes and step time we show results also for jits with bookkeeping.
we do not report load time for jits with bookkeeping since this extension is independent of this part.amba and genbuf .intermsofloadtime theresultsshowthat whilespectraloadtimegrowsveryfastwiththesizeofthespecification number of masters number of senders jits load time growsveryslowly.inabsoluteterms jitsloadtimeisalwaysfaster than that of spectra.
intermsofactivenodesandsinglesteptime theresultsshow obvious advantage to jits with or without bookkeeping as the specifications grow larger.syntech .thetablefurtherpresentstheresultsonspecifications fromthesyntechbenchmarks.intermsofloadtime activenodes andsinglesteptime theresultsdonotshowaclearadvantageto oneoftheapproachesovertheother.inparticular intermsofsingle steptime wedonotobservethatoneapproachisconsistentlybetter than the other.
weconsidertheseresults forallspecifications tobeagoodpoint forjits as apriori onemayexpectthatgiventhecomputations it has to do in every step we would observe much slower step timesforjitsthanforspectra.however recallthatthestatic trans bdd whichholdsallthetransitions canbeverylarge.loadingand applying logical operations on large bdds can be costly and vary greatlybasedonvariableordering.incontrast whiletypicallyjitshasahighernumberofoperationsperstep thebddsitmanipulates are much smaller.
to answer rq2 jits does not compromise system execution performance andinsomecasesachievesevenbetterresultsthan existing approaches w.r.t.
load time memory usage and steptime.
we also see that in many cases jits scales better than spectra.thelargerthespecification thebetterjitsloadtime memory usage and step time compared to spectra.
.
threats to validity we briefly discuss threats to the validity of our results.
first thesymboliccomputationsarenottrivialandourimplementationmayhavebugs.tomitigatethis weperformedathoroughvalidationusingallspecificationsavailabletous seesect.
.
.
second even though the algorithms we deal with are deterministic garbagecollectionofthejvmandofcuddaddvarianceto running times.
to mitigate this werepeated each experiment timesandwereportmedianvalues.cudddynamicreorderingmayresultinadditionalvariance.duringrealizabilitychecking weused cudd sdefaultdynamicreorderingforalltools.thisiscommon practice in therelated literature e.g.
.
during construction we used the default for each tool2.
during system execution we turned off dynamic reordering for spectra and jits because for both it creates unpredictable occasional extremely slow steps.
third thespecificationsweusedintheevaluationmaynotbe representativeof real worldspecifications.
toalleviate thisthreat 2slugs turns it off spectra and jits keep it on.
643table comparison of slugs static spectra static and jits during synthesis specificationconstruction time sec memory an in thousands size on disk mb slugs spectra jits slugs spectra jits slugs spectra jits constr.
constr.
stor.
amba1 .
.
.
.
.
.
.
.
.
amba2 .
.
.
.
.
.
.
.
.
amba3 .
.
.
.
.
.
.
.
.
amba4 .
.
.
.
.
.
.
.
.
amba5 n a .
n a n a .
n a n a .
amba10 n a .
n a n a .
n a n a .
genbuf5 .
.
.
.
.
.
.
.
.
genbuf10 .
.
.
.
.
.
.
.
.
genbuf20 xx .
.
n a .
.
n a .
.
genbuf30 xx .
.
n a .
.
n a .
.
genbuf40 xx .
.
n a .
.
n a .
.
genbuf90 xx .
.
n a .
.
n a .
.
airportshuttle .
.
.
.
.
.
junction2 .
.
.
.
.
.
junction3 .
.
.
.
.
.
roboticarm .
.
.
.
.
.
simplevehicle .
.
.
.
.
.
table comparison of spectra static and jits during system execution specificationload time sec memory an in thousands single step time ms spectra jits spectra jits jits w bk.
spectra jits jits w bk.
amba1 .
.
.
.
.
.
.
.
amba2 .
.
.
.
.
.
.
.
amba3 .
.
.
.
.
.
.
.
amba4 xx22.
n a355.
.
n a3.
.
amba5 xx119.
n a611.
.
n a .
.
amba10 xx2539.
n a2488.
.
n a11.
.
genbuf5 .
.
.
.
.
.
.
.
genbuf10 .
.
.
.
.
.
.
.
genbuf20 .
.
.
.
.
.
.
.
genbuf30 .
.
.
.
.
.
.
.
genbuf40 .
.
.
.
.
.
.
.
genbuf90 xx114.
n a .
.
n a .
.
airportshuttle .
.
.
.
.
.
.
.
junction2 .
.
.
.
.
.
.
.
junction3 xx54.
n a5321.
.
n a .
.
roboticarm .
.
.
.
.
.
.
.
simplevehicle .
.
.
.
.
.
.
.
we used several existing benchmarks from the literature.
for the ambaandgenbufweuseddifferentnumberofmasters asiscommon practice in related literature.
for the syntech specifications we chose all specifications where number of variables is greater than see sect.
.
.
finally oursystemexecutionsetuprunsthecontrollerfor10 stepsagainstarandom yet correct environment seesect.
.
.in practice environment behavior is not expected to be random.
real environmentbehaviorisnotavailableforthespecificationsathand.
that said we are not aware of reasons to believe that next stepperformance against a real environment would be different than what we observed neither for spectra nor for jits.
related work gr synthesis was introduced in .
it has since been used and investigated by many including e.g.
kress gazit et al.
whousedgr inrobotics maozandringert whoshowed gr synthesis for specification patterns cavezza and alrajeh who investigated assumptions refinement in unrealizable gr specifications tolistafew.severaltoolssupportgr synthesis 644e.g.
ratsy slugs andspectra .noneoftheseworks and tools considered just in time synthesis.
heuristics to improve the running time performance of gr synthesishavebeensuggestedin .specifically firmanet al.
presentandevaluateheuristicsatthelevelofthecontrolled predecessor computation and bdds as well as heuristics for early detection of fixed points and early detection of unrealizability.
the work however is limitedtoacceleratingtherealizabilitychecking phase.
it has no effect on the controller construction phase and no effect on system execution performance.
the suggested heuristics are implemented in spectra.
as noted earlier our comparison against spectra includes all these heuristics.
dathathri and murray suggest efficient gr synthesis for specifications with singleton liveness guarantees i.e guarantees thatarelimitedtoasinglestate.ourwork however isindependent of any such restrictions on the gr specifications.
schlaipfer et al.
present an approach to gr synthesis without what they refer to as a monolithic strategy applied to hardware synthesis.
they synthesize several separate strategies one for each justice guarantee and manage them via auxiliary circuits.thisreducesstrategyconstructiontimeandmemoryusage at the expense of a major increase in circuit size.
evaluation is limited to the amba specifications.
heuristics to improve realizability and strategy construction timeshavealsobeensuggestedintheseriesofsyntcompcompetitions e.g.
.
the competition measures realizability checking and strategy construction times where the targets are hardware circuits not softwaresystems.evidently jitsisapplicable tosynthesized software systems not hardware circuits.
moreover the specificationsusedinthecompetitionareeitherltlorsafety only specifications.
our work focuses on gr specifications which on the one hand are not as expressive as ltl but on the other hand includenotonlysafetybutalsojusticeassumptionsandguarantees.
thus we cannot evaluate our work against the competition s tools and specifications.
in particular strix is an ltl reactive synthesis tool which hasrecentlygainedattentionduetopromisingresultsinthesyntcomp competition.
strix decomposes the ltl formula into simplerformulas translatestheseon the flyintodeterministicparity automata solves the intermediate parity games using strategy iteration andfinallytranslatesthewinningstrategy ifitexists into amealymachineoranaigercircuitwithoptionalminimization using external tools.
only during the last step the authors discuss encoding of the mealy machine as a bdd.
hence one may consider applying the concept of jits perhaps redesigned to adapt to thedomain ofdeterministic parityautomata insteadofgr torevise this encoding and open the way for efficient execution of controllers synthesized with strix.
finally onemayconsiderjitstobesimilartoon the flyalgorithmsinmodelcheckingandgamesanalysis e.g.
.however these algorithms are meant to improve the performance of verifica tionorrealizabilitychecking.jits incontrast isanovelmeansfortheexecution ofthesynthesizedsystem.itusesthesamerealizability checking as the static approaches to gr synthesis.
conclusion we introduced jits just in time synthesis for gr .
jits provides a novel fast and flexible means to execute synthesized controllers.
itdoesnotcompromisethecorrect by constructionpromise while fromarchitecturalandmethodologicalperspectives itopensthe way for the decoupling of realizability checking and system execution.
wehaveimplementedjitsontopofthespectrasynthesizer.we showedthatcomparedtoexisting staticapproaches jitsgreatly improves overall synthesis time memory usage and output size and scales better with larger specifications.
moreover we showed thatjitsremainscompetitivecomparedtothestaticapproachin system execution performance w.r.t.
time and space.
as future work we consider the following research directions.
first one may investigate how to adapt jits to specific system execution platforms and how tocontrol the tradeoffbetween performance and memory consumption of jits execution potentially for example using bdd reordering or different possibly adaptive caching mechanisms.
second to further enhance the configurability of synthesized controllers atload time one maysuggest differentstoring mechanisms.
finally mostrecently amrametal.havepresentedgr anextension of gr with existential guarantees .
one may consider to define and implement jits for gr .