how android developers handle evolution induced api compatibility issues a large scale study hao xia fudan university haoxia17 fudan.edu.cnyuan zhang fudan university yuanxzhang fudan.edu.cnyingtian zhou fudan university yingtianzhou17 fudan.edu.cn xiaoting chen fudan university xtchen16 fudan.edu.cnyang wang fudan university fudan.edu.cnxiangyu zhang purdue university xyzhang cs.purdue.edu shuaishuai cui fudan university sscui16 fudan.edu.cngeng hong fudan university ghong17 fudan.edu.cnxiaohan zhang fudan university xh zhang fudan.edu.cn min yang fudan university m yang fudan.edu.cnzhemin yang fudan university yangzhemin fudan.edu.cn abstract as android platform evolves in a fast pace api related compatibility issues become a significant challenge for developers.
to handle an incompatible api invocation developers mainly have two choices merely performing sufficient checks to avoid invoking incompatible apis on platforms that do not support them or gracefully providing replacement implementations on those incompatible platforms.
as providing more consistent app behaviors the latter one is more recommended and more challenging to adopt.
however it is still unknown how these issues are handled in the real world do developers meet difficulties and what can we do to help them.
in light of this this paper performs the first large scale study on the current practice of handling evolution induced api compatibility issues in about android market apps and more importantly their solutions if exist .
actually it is in general very challenging to determine if developers have put in countermeasure for a compatibility issue as different apis have diverse behaviors rendering various repair.
to facilitate a large scale study this paper proposes rapid an automated tool to determine whether a compatibility issue has been addressed or not by incorporating both static analysis and machine learning techniques.
results show that our trained classifier is quite effective by achieving a f1 score of .
and .
in the training stage and the validation stage respectively.
with the help of rapid our study yields many interesting findings e.g.
developers are not willing to co first authors permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn .
.
.
.
alternative implementations when handling incompatible api invocations only .
for those incompatible apis that google gives replacement recommendations the ratio of providing alternative implementations is significantly higher than those without recommendations developers find more ways to repair compatibility issues than google s recommendations and the knowledge acquired from these experienced developers would be extremely useful to novice developers and may significantly improve the current status of compatibility issue handling.
ccs concepts software and its engineering software testing and debugging general and reference empirical studies.
keywords compatibility issues api evolution android app analysis acm reference format hao xia yuan zhang yingtian zhou xiaoting chen yang wang xiangyu zhang shuaishuai cui geng hong xiaohan zhang min yang and zhemin yang.
.
how android developers handle evolution induced api compatibility issues a large scale study.
in 42nd international conference on software engineering icse may seoul republic of korea.
acm new york ny usa pages.
introduction recent years have witnessed the rapid growth of android powered devices.
to keep up with the emerging needs for new functionalities and improve user experience google frequently updates its android operating system.
during the evolution of android platform many new apis are introduced while some apis are removed.
google designates a dedicated api level for each major os release to label the apis that can be used on this os release .
to safely invoke an android api developers should check the current api level of the running platform which can be accessed viaandroid.os.build.sdk int sdk int for short before the invocation.
otherwise invoking an unsupported api will lead to ieee acm 42nd international conference on software engineering icse icse may seoul republic of korea hao xia yuan zhang yingtian zhou xiaoting chen yang wang xiangyu zhang et al.
a nosuchmethoderror and crash.
this kind of issue is called an evolution induced api compatibility issue .
with the recent release of android p there are different api levels in total and each level defines tens of thousands of android apis.
obviously it is quite challenging and errorprone for android developers to manage app compatibility against different api levels .
even worse android lint which is the default app bug detector integrated by the official android app ide android studio is ineffective in helping developers perform api compatibility checks because it performs contextinsensitive analysis and does not cover the integrated external libraries.
as a result evolution induced api compatibility issues are prevalent.
for example by querying google with android nosuchmethoderror entries return till april .
a recent study shows that .
of fdroid apps write specific code to perform api level checks and .
of them have evolutioninduced incompatible api usage .
to help developers to test whether they perform sufficient compatibility checks li et al.
and he et al.
systematically model the lifecycle of every android api and leverage heavyweight static analysis.
however performing sufficient compatibility checks is not enough to deal with evolution induced api compatibility issues.
in fact it just prevents the app from raising a nosuchmethoderror .
for example when google removes the api resources.getcolor int it suggests developers invoke another api resources.getcolor int theme instead .
if an app just performs a check with sdk int before invoking resources.getcolor int without providing a replacement api on those incompatible api levels the app would incur an inconsistency bug.
to better deal with the compatibility issue in this example developers should invoke another api such as the recommended resources.getcolor int theme method on those incompatible api levels.
based on the above observation this paper distinguishes two kinds of checks against evolution induced compatibility issues.
the first kind of check just aims to prevent the app from crash by simply avoiding the invocations of apis that are not supported by the underlying platform.
this kind of check is named as sigchk for short explained later in .
.
the second kind of check not only guarantees that apis with compatibility issues are invoked when supported but also provides similar functionalities to these apis when not supported.
we call this kind of check as rplchk for short explained later in .
.
to provide better app compatibility against different api levels developers are expected to implement consistent app behavior across all api levels they claim to keep compatible with.
previous works only manually analyzed several cases of how evolution induced compatibility issues are checked.
however their study only covers a small number of cases.
there is no large scale study to measure the current practice of developers in handling evolution induced incompatible api invocations e.g.
do developers tend to replace them or just simply check them how different compatibility related apis are replaced what typical difficulties do developers encounter in finding ways to replace them can novice developers be benefited from learning the practice of experienced developers.in light of this this paper aims to perform a large scale study on real world android market apps about apps to shed light on the practice of developers in dealing with evolution induced api compatibility issues.
to the best of our knowledge this paper is the first to perform such a study with a large volume of real world apps.
the results reported by our study can facilitate an in depth understanding of the current status in handling app compatibility issues and enable the community to conduct more effective efforts to help developers fix compatibility issues.
except for evolutioninduced api compatibility issues android apps are also vulnerable to other kinds of compatibility issues such as device specific issues .
in this paper we mainly consider evolution induced api compatibility issues because of their prevalence severe effects and the feasibility of systematically modeling these issues .
in the following we shortly name evolution induced api compatibility issues as compatibility issues when not specifically mentioned.
to facilitate the large scale study we need an automated tool which can classify compatibility checks into sigchk andrplchk.
however building such a tool entails challenging program analysis.
since there are a lot of compatibility related apis more than apis as reported in .
and different apis may be replaced in specific ways we cannot directly search all possible alternative implementations for every compatibility related api to provide appropriate classification.
as demonstrated in the large scale study see developers have various ways to implement alternative functionalities to the compatibility related apis.
to this end we propose a tool named rapid replacement api detection to automatically recognize rplchk.
the intuition of rapid originates from the definition of rplchk i.e.
a compatibility check which provides a replacement operation when the api is not supported.
thus if there is a similar operation to the api in the other branch it is rplchk.
otherwise it is sigchk.
however it is quite difficult to judge whether there is a similar operation to an api in the other branch because each api provides different functionalities and exhibit diverse behaviors.
by manually analyzing about one hundred real world sigchk andrplchk cases we have some interesting findings we find that the alternative operation in rplchk shares similar semantics with the api which is often reflected in the semantic similarity of the corresponding natural language artifacts e.g.
api names .
for example the recommended alternative api resources.getcolor int theme by google is quite similar to the original api resources.getcolor int in terms of the api names.
we find that the arguments that an alternative operation takes are similar to the arguments of the original api and the return value of an alternative operation may flow to similar points as the return value of the original api.
based on these observations we propose a learning based approach to automatically determine if a compatibility check is rplchk or not.
specifically we extract features from code blocks at each compatibility check point and encode them into numeric vectors.
we manually label compatibility checks and utilize machine learning to train a classifier.
the model reports a precision of .
and a recall of .
in the training stage.
besides we also randomly select compatibility checks from the study to 887how android developers handle evolution induced api compatibility issues a large scale study icse may seoul republic of korea manually validate the effectiveness of our trained classifier.
the result shows that it achieves a precision of .
and a recall of .
which we believe is good enough for a large scale study.
we collect about 300k apps from popular android app markets to study the practice of handling compatibility issues in the real world.
our study yields many important and interesting findings that have never been reported before e.g.
we find that only .
of compatibility checks actually provide replacement implementations on those incompatible api levels developers are likely to handle incompatible api invocations with alternative operations when google provides recommendations although google only gives recommendations for very few apis developers do not always follow the recommended way when providing replacement implementations especially when the recommended api needs more arguments to invoke and hence is not the easiest way to handle the issue developers can find their own way to provide replacement implementations for those incompatible apis when google does not give recommendations not all developers succeed in providing replacement implementations and the current status of handling compatibility issues can be significantly improved by simply learning from experienced developers.
in all this paper makes the following contributions large scale study to understand the current practice of compatibility issue handling.
this paper is the first to distinguish two kinds of compatibility issue checks sigchk andrplchk and performs the first such large scale study to measure the real world practice of handling compatibility issues.
our study reveals many important findings that are expected to stimulate more relevant works to improve the compatibility issue fixing.
the rapid tool that can automatically classify two kinds of compatibility checks.
it is quite challenging to automatically classify sigchk andrplchk.
this paper designs a learning based approach to automatically determining if a compatibility issue check is a rplchk or not based on a comprehensive set of features from texts data dependencies etc.
despite from facilitating a large scale study our tool is also very useful to help developers to check whether they have properly performed compatibility checks.
note that our goal is to distinguish two kinds of compatibility issue checks and study the current fix practice on a large scale while not aiming to automatically fix repair incompatible apis.
the rest of this paper is organized as follows.
introduces our definition of two kinds of compatibility checks and presents the motivation of this paper as well as the challenges we met.
presents the design of our rapid tool which is built to automatically classify sigchk andrplchk.
evaluates the performance of rapid and reports the results drawn from our large scale study.
discusses the limitations of our work.
summarizes the related work and concludes the paper.
problem statement .
evolution induced compatibility issues android platform is frequently updated to meet various emerging requirements and to optimize the user experience.
for example there have been two or more major platform updates almost every 28api count api levelapi lifecycle deprecated api inherited api added apifigure api lifecycle ranging from api level android .
to android p .
this figure shows the numbers of apis that are deprecated added at this api level and those inherited from the previous api level.
year in the past decade.
the evolution of the android operating system brings significant burdens for developers to keep their apps compatible with different system versions.
to help developers manage app compatibility google designates an api level for each major system version which defines all the apis that can be accessed on this version.
if an app invokes an api that is not defined by the api level it will trigger a nosuchmethoderror and crash.
while it is unnecessary for an app to be compatible with all api levels app developers usually declare the api levels that their app should be compatible with in the app manifest file aka.
androidmanifest.xml .
there are three attributes in the manifest file that can be used to declare the compatibility level minsdkversion defines the minimum api level that the app is compatible with and android ensures that the app cannot be installed on devices below this api level targetsdkversion defines the most appropriate api level that the app is designed to run on maxsdkversion is previously used to define the maximum level but this attribute is deprecated since android .
.
among the three attributes minsdkversion is the most important because it determines the range of api levels that an app should ensure compatibility.
for example if an app sets minsdkversion to it should ensure compatibility with the api levels from to the latest api level of android .
api lifecycle database.
during api evolution some apis are deprecated and new apis are introduced.
android maintains the available api level range for each occurred api in apiversions.xml of android sdk.
by analyzing this file we can build a database to figure out the apis that can be invoked at each api level.
figure shows the number of apis that each api level defines.
from this figure we can find that a lot of apis are added removed during each api level update.
.
two kinds of compatibility checks to handle evolution induced api compatibility issues developers need to perform api level checks of the running platform before invoking a compatibility related api.
specifically for those newlyintroduced apis app developers should guarantee that these apis 888icse may seoul republic of korea hao xia yuan zhang yingtian zhou xiaoting chen yang wang xiangyu zhang et al.
if build.version.sdk int accountmanager v0 .
removeaccountexplicitly v1 if build.version.sdk int accountmanager v0 .
removeaccountexplicitly v1 else accountmanager v0 .
removeaccount v1 null null if build.version.sdk int accountmanager v0 .
removeaccountexplicitly v1 else logger.warn just a log a compatibility issue check with if then cfg struc ture b compatibility issue check with if then else cfg structure c compatibility issue check with if then else cfg structure figure different cases of checking compatibility issues.
in this figure acccountmanager.removeaccountexplicitly x1 is added since api level and acccountmanager.removeaccount x1 x2 x3 is deprecated since api level .
are not invoked on the previous api levels for those deprecated apis app developers should ensure that these apis are not invoked on the subsequent api levels.
in practice different checks can be performed for a compatibility related api invocation.
figure shows an example of several cases of checking compatibility issues.
based on the aims of different compatibility issue checks we differentiate two kinds of compatibility issue checks sigchk single compatibility issue check.
a simple way to handle compatibility issues is to perform a check against sdk int which returns the api level of the running platform before invoking any compatibility related api.
figure a gives an example where acccountmanager.removeaccountexplicitly x1 is added since api level and hence the code snippet tests whether sdk int is larger than or equal to .
by placing such api level checks before invoking compatibility related apis developers can effectively prevent nosuchmethoderror .
from figure a we observe that this kind of check does nothing but just checking the api level of the underlying platform.
we call such practice to handle compatibility issues as sigchk for short.
rplchk replaced compatibility issue check.
although sigchk can prevent apps from crashes it is not the best effort to handle compatibility issues.
a better way to handle evolutioninduced compatibility issues is to provide an alternative implementation function that has similar functionalities when an api is not compatible.
take figure a as an example the remove account operation is only performed when the api level is larger than .
it would lead to inconsistent behaviors on devices whose api level is below .
in contrast figure b gives a better way to handle the compatibility issue by invoking another api with similar functionalities on api levels lower than .
we call such a way to handle compatibility issues as rplchk for short.
.
motivation obviously rplchk is more desirable than sigchk.
when some apis are deprecated google may recommend developers to use other apis to replace the incompatible ones.
for example when google removes the api resources.getcolor int it suggests developers to invoke another api resources.getcolor int theme as analternative .
however not all deprecated apis have suggested replacement apis.
meanwhile for apis that are newly introduced there are no recommendations on earlier api levels.
when there are no official recommendations to handle a compatibility issue developers often resort to their own efforts to implement similar functionalities.
sometimes it is almost impossible to fix a compatibility issue in this way because the feature provided by the compatibility related api may only be implemented by the platform.
for example wifimanager.startscan is deprecated since api level which requests a scan for wifi access points .
except for this api an app cannot implement similar functionality because a normal app does not have the privileges to control wifi devices for access point scanning.
based on the above observations we can find that it is quite challenging for developers to fix compatibility issues with replacement implementations.
previous work leverages manual analysis of open source apps to gain insights into how compatibility issues are fixed .
however their study only covers a small number of apps and thus cannot give a representative and quantitative measurement about the status of compatibility issue handling.
in light of this our paper aims to perform a large scale study to measure the current practice of developers in dealing with compatibility issues such as how many compatibility issues are addressed by providing alternative functionalities do google s recommendations help developers in handling these issues.
besides facilitating an in depth understanding of compatibility issues and their fixes the insights acquired through our study may have substantial ramifications on future research about automatically addressing such issues.
.
challenges to facilitate such a large scale study we first need a tool which can automatically and reliably classify sigchk andrplchk.
however it is challenging to achieve this goal because there are a large number of compatibility related apis more than apis as reported in .
and different apis have different functionalities such that their invocations can only be replaced in specific ways.
thus we cannot simply crawl all possible alternative implementations for every compatibility related api to conduct classification.
specifically there are two challenges to differentiate rplchk from sigchk challenge i recognizing the control structure of compatibility checks does not reliably distinguish rplchk from sigchk.
one may observe that a sigchk usually has only a single true branch after the check of sdk int while a rplchk always has both true branch and false branches.
however as depicted in figure c not all compatibility checks with both branches are rplchk.
the case in figure c is actually a sigchk.
challenge ii measuring the similarity between the true and false branches of compatibility check does not accurately differ rplchk andsigchk.
to differ figure b from figure c one may propose to use code block similarity since the two branches of the sdk int check in figure b are quite similar while the two branches in figure c are dissimilar.
however this rule is not reliable.
figure gives an example in which the two branches are quite similar.
however by examining this case we can 889how android developers handle evolution induced api compatibility issues a large scale study icse may seoul republic of korea if build.version.sdk int intent i new intent this cameragallery.class i.putextra from hoarding activityoptions op activityoptions.makecustomanimation this r.anim.anim1 r.anim.anim2 this.startactivity i op.tobundle else intent i new intent this cameragallery.class i.putextra from hoarding this.startactivity i figure a sigchk case where there is no alternative operation in the else branch for activityoptions.makecustomanimation .
this case demonstrates that the identification of rplchk requires fine grained analysis.
find that the functionality provided by the compatibility related apiactivityoptions.makecustomanimation is not provided in the other branch.
to reliably differ rplchk from sigchk we need to analyze the fine grained code semantics.
to address these challenges this paper proposes a learningbased approach rapid replacement apidetection which can automatically classify rplchk andsigchk by leveraging static analysis and machine learning.
in the following we will elaborate on the technique.
3rapid approach .
overview by manually analyzing about one hundred real world sigchk and rplchk cases we gain some insights about determining whether a compatibility check is sigchk orrplchk.
basically we follow two steps.
firstly we examine the control structure of the check on sdk int .
if the check is a if then check it is directly flagged assigchk since there is no way for the app to provide similar functionalities to the compatibility related api in this scenario see figure a for an example .
note that we focus on checks on sdk int because according to recent works that detect missing checks of incompatible api invocations developers mostly use the attribute sdk int to check api compatibility.
secondly if the check is a if then else check we cannot simply flag it as rplchk.
our core idea to classify this kind of check is inspired by the definition of rplchk i.e.
whether the app provides similar functionalities to the problematic api on unsupported api levels.
since there is a large search space for the possible replacements of an incompatible api invocation we usually cannot give a definitive answer.
instead we disclose the characteristics that rplchk exhibits from the experience in manual inspection of a number of real world sigchk andrplchk cases and design a learning based approach to facilitate such classification.
specifically we find rplchk cases share many common features from two perspectives that sigchk cases do not have behavior semantics andinput output dependencies.
behavior semantics.
the names of android api classes methods and fields contain rich semantic.
in rplchk cases we observe that the alternative operations to an incompatible api often share very similar semantics in their natural language r4 android.os.environment.
g etexternalstoragestate r3 goto label08label07 r4 android.os.environment.
g etstoragestate r3 label08 z1 r4.equals mounted if z1 !
goto label09 i0 r2 r1.getexternalfilesdirs null r3 r2 i1 android.os.build version.sdk int if i1 goto label07figure example to demonstrate the features that can be used to locate replacement api.
artifacts e.g.
names .
figure gives an example where environment.getexternalstoragestate is used to replace environment.getstoragestate on those incompatible api levels.
we can observe that the two apis are from the same class.
besides from their names it is not hard to infer that they provide very similar functionalities.
in contrast in the sigchk case shown in figure c it is easy to recognize that logger.warn andaccountmanager.removeaccountexplicitly are likely to be semantically different.
note that only names of api classes methods and fields are considered here because they belong to the public interface of android system that should not be obfuscated .
in contrast app specific artifacts e.g.
functions defined locally by an application are precluded in our analysis.
input output dependencies.
besides behavior semantics we also observe that if an api can be used to replace another one.
they are expected to accept very similar inputs and the outputs generated may be used in a similar way.
the rplchk case in figure can be used as an example to illustrate such a similarity.
we can find that the arguments of environment.getexternalstoragestate andenvironment.getstoragestate are the same i.e.
r3 and the return value of them are also the same i.e.
r4 .
note that not all the apis that can replace each other have the same inputs and outputs.
meanwhile for the sigchk cases in figure c there is no operation in the false branch which shares similar inputs and outputs with accountmanager.removeaccountexplicitly .
rapid workflow.
we present rapid which leverages the aforementioned insights to automatically classify rplchk andsigchk.
figure depicts the overall workflow of rapid .
first rapid identifies all compatibility checks using static analysis and also extracts the branches of each check.
to identify compatibility checks rapid leverages the api lifecycle database constructed in .
.
second rapid extracts features from the branches and encodes them into vectors.
at last we choose support vector machine svm for its over fitting resistant feature to train a classifier for rplchk identification.
in the following we will detail the design of the two modules in rapid.
.
static analysis .
.
compatibility check identification.
in order to recognize rplchk rapid needs to first identify compatibility checks.
actually 890icse may seoul republic of korea hao xia yuan zhang yingtian zhou xiaoting chen yang wang xiangyu zhang et al.
api lifecycle d atabase apkstatic analysis compatibility check i dentification check related control f low branches extractionfeature extraction behavior semantics input output d ependenciessvm c lassifier feature v ectorground truth 6lj kn 5so kn10.. figure workflow of rapid.
it first identifies all compatibility checks and check related control flow branches with static analysis and then extracts features from the branches to encode them into vectors.
finally svm is trained to give a classification result.
previous works on detecting missing compatibility checks have explored many ways for compatibility check identification.
this part of rapid is inspired by these works and we do not claim contributions.
the key contributions of rapid lie in the classification of sigchk andrplchk which will be elaborated.
nevertheless we give an overview of this part for the sake of completeness.
specifically rapid follows three steps to identify compatibility checks.
first we leverage flowdroid to build a precise inter procedural control flow graph icfg for each app.
during icfg construction flowdroid generates a dummy main method to connect all app components and callback functions.
second by traversing the icfg rapid locates all compatibilityrelated api invocations in the app.
in order to find all compatibilityrelated apis for an app rapid looks up the api lifecycle database which is constructed in .
with the minsdkversion attribute in the androidmanifest.xml of the app.
at last we traverse backward to find the api level check against sdk int for each located api.
.
.
check related control flow branches extraction.
after identifying compatibility checks we further extract the control flow graphs of these checks for the following rplchk classification.
if a check has a if then control structure we can quickly recognize it as asigchk.
thus only the compatibility checks with two branches i.e.
if then else control structure proceed to this step.
to differ the two branches we call the branch that invokes the api the apibranch and call the other branch candidate branch.
the goal of rapid is to find an alternative operation in the candidate branch which provides similar functionalities to the incompatible api if it exists.
as indicated in the most common fix practice is to invoke an alternative api from a different api level .
besides combined with our experience in manual inspection we focus on two kinds of operations in the candidate branch to reduce the search space method invocation operation which invokes an api fieldaccess operation which gets sets a field of a system class.
specifically we name each operation as unitop including the compatibilityrelated api invocation in the api branch.
our compatibility check branch extraction works by transforming the statements in the candidate block into a list of unitop s. during the transformation we also inline the app methods that are invoked by the candidate branch since an alternative operation may be inside an app method.
besides we recognize java reflection api calls in the candidate branch and transform them into normal java statements with the help of constant propagation.
note that we do not employ a dedicated tool such as droidra to tamethe reflection calls here because our scenario is not an adversarial setting and the cases we meet are quite standard to handle.
for each unitop we also perform intra block data flow analysis to track the flows to the arguments of an unitop and the propagation of its return value.
.
feature extraction we further extract features for each identified unitop to train a classifier to identify rplchk.
if a unitop in the candidate branch provides similar functionalities to the incompatible api invocation unitop the check is recognized as rplchk.
specifically the feature extraction module extracts features from two perspectives as mentioned before behavior semantics and input output dependencies.
overall we extract features for every unitop pair i.e.
one is the alternative of the other and each feature is represented as a floating point value.
before we detail the extraction for these features we introduce similarity functions as follows jaccard similarity models the similarity between two sets based on how many common items they share.
word similarity utilizes the word2vec model to calculate the semantic similarity between two words.
word set similarity leverages the word2vec model to calculate the similarity between two word sets.
specifically we adopt an algorithm of calculating sentence similarity which works by calculating the average word similarity between all words in the two sets.
.
.
feature extraction for behavior semantics.
we notice that names and comments of code elements in java code usually covey a lot of semantic information.
therefore we leverage the text similarity between two unitop s to represent their closeness in behavior semantics.
specifically for every unitop pair we extract features from their package names class names method field names and comments as described below.
common package prefix length for example the common package prefix length of android.app and android.support.v4.app is .
package hierarchy distance for example it takes steps to reach android.support.v4.app from android.app in the package hierarchy so the package hierarchy distance is .
package name similarity we split package names into separated words by the dot symbol and use the jaccard similarity to calculate the package name similarity.
for example we can split android.app and android.support.v4.app into two word 891how android developers handle evolution induced api compatibility issues a large scale study icse may seoul republic of korea sets android app and android support v4 app .
with jaccard similarity we can calclate the package name similairty is .
.
class name similarity because java uses camel nomenclature we also split class names into word sets and use the word set similarity to calculate their similarity.
is both static we test whether the method invoked or the field accessed in the two unitop s is both static or non static.
operation action similarity the operation action is the action a verb performed by a unitop.
for method invocation operations we can extract the verbs from their method name.
to tag part of speech for different words we use stanford log linear part of speech tagger .
for example get is the operation type for getstoragestate .
for field access operations we use get or set to represent their actions.
operation target similarity the target of an operation can be represented by the nouns in the method name for a methodinvocation operation and the nouns in the field name for a fieldaccess operation.
we also use to tag the part of speech for different words.
we use word set similarity to calculate the similarity between the two noun sets.
comment similarity android provides sufficient comments to describe each method and field.
note that we do not require source code of apps.
for each unitop pair the methods invoked or the fields accessed all belong to android system classes which have comments.
these comments also help to gauge the distance of two methods or fields.
by parsing the comments and extracting the nouns we also use word set similarity of two noun sets to calculate comment similarity.
.
.
features extraction for input output dependencies.
the behavior semantic features mainly consider the characteristics of unitoppairs without taking their dependencies with other statements into account.
therefore we also extract input output dependency features for each unitop as a complement.
specifically during the static analysis phase we perform intrabranch data flow analysis to track data flow to the arguments of an unitop and the propagation of its return value.
figure gives an example to demonstrate this kind of data flow.
in this example i0 settings.system.getint r7 r3 is the target unitop.
by tracking the data flow to its arguments we find that r3 and r0 are two input related variables is transitively dependent on r0 and the getcontentresolver api is an input related operation because r7 is acquired by this api .
besides we track the usage of return value i0 and find that r5 is an output related variable because it depends on i0 and the append api is an output related operation because it takes i0 as argument .
based on input output dependencies we extract the following features.
argument number we extract the number of arguments that the subject api takes.
arguments type similarity we extract all argument types for a method invocation operation and the declared type of a field for a field set operation.
based on the texts of these types we split them into words and calculate word set similarity between them.
for field get operations they have no argument so the word set for them is empty.
constant similarity sometimes constants are used as arguments for method invocation operations or assigned to fields i0 settings.system.getint r7 r3 r7 r2.getcontentresolver r3 v ibrate when ringing r5 r1.append i0 return r5 r2 r0.context figure example to demonstrate feature extraction for input output dependencies for settings.system.getint .
for field set operations.
typically these constants are static final variables which are declared in android system classes.
the names of the constant variables contain a lot of semantic information useful for similarity testing.
for example for a method invocation operation alarmmanager.set ... ... if we search the constant in the alarmmanager class we can find its name is rtc wakeup.
by recovering the constant names we can get more semantic information about the operation.
to recover the names for constants we build a name database from android api documents which records all possible names for a given constant value.
by querying the database we may get several names for a constant value and we will use the one declared in the same class with the method field of theunitop.
after splitting the constant names into words we use word set similarity between two word sets to represent constant similarity.
has return value we test whether the compatibility related api has return value.
return type similarity we extract the return type for a method invocation operation the declared type of the field for a field get operation.
based on the texts of these types we split them into words and calculate word set similarity.
a field set operation does not have return value.
hence its word set is empty.
input output related variable set size we extract the number of input output related variables that depend on the arguments return value of the subject api.
input output related variable set similarity we use jaccard similarity to calculate the similarity between two input output related variable sets.
for example the similarity for r0 r3 and r3 is .
.
input output related operation set similarity we collect two input output related operation sets for each unitop pair and split the method names into words.
we use the word set similarity to calculate the similarity between the two word sets.
results the static analysis module of rapid is implemented on flowdroid .
it leverages the icfg inter procedure control flow graph of flowdroid to identify compatibility checks.
to support feature extraction for input output dependencies it implements an intra branch data flow analysis for the compatibility check related branches.
overall the static analysis module contains loc java code and the feature extraction module has 892icse may seoul republic of korea hao xia yuan zhang yingtian zhou xiaoting chen yang wang xiangyu zhang et al.
table the app dataset for the large scale study.
market date count google play .
.
huawei .
qihoo .
tencent .
baidu .
all unique loc java code.
the feature extraction module utilizes the pretrained googlenews word2vec model and deeplearning4j framework to calculate word similarity.
our classifier is built with the smo classifier in weka a kind of support vector machine svm with a poly kernel exponent as .
dataset.
to perform a large scale study we crawled apps from google play and third party app markets including their topranked apps.
as shown in table we collect unique apps.
we run rapid in parallel to analyze these apps and set the timeout for each app to minutes.
in all rapid successfully analyzed apps with apps timeout.
besides there are apps which failed to parse by flowdroid.
based on the results of apps our study is conducted from the following perspectives effectiveness efficiency of rapid see .
landscape of compatibility issue handling see .
the help of google s recommendations see .
sigchk cases that can be improved see .
.
.
effectiveness efficiency of rapid to construct ground truth for the classifier we manually analyze compatibility checks covering distinct apis.
for each compatibility check we first reverse the bytecode and label whether it issigchk orrplchk following the definition in .
.
for rplchk we further locate the alternative unitop to the incompatible api and label it as a positive case in our ground truth.
for other unitop s in the candidate branch we label them as negative cases.
here each case consists of two unitop s one being the incompatible api invocation from the api branch and the other a unitop from the candidate branch.
in all our ground truth consists of unitop pairs including positives and negatives .
as we will show later such a ground truth set is sufficient for achieving high classification accuracy.
in all student authors participate the ground truth labeling and every participant has at least years of android app reverse engineering experience.
besides at least two participants are involved in every unitop pair.
q1 how effective is rapid in differentiating sigchk and rplchk?
first we use ten fold cross validation to evaluate the performance of the trained svm classifier.
as table shows our model achieves high accuracy during the training phase f1 score .
.
second we randomly select compatibility checks from the whole dataset as the validation set to further validate the performance of the classifier for the large scale study.
note that there is no overlap between the training set checks and the validation set checks and the validation set is constructed randomly before the classifier is trained.
for the selected checks rapid reports rplchk cases and sigchk cases.we manually label these checks and every check is verified by at least two student authors.
the results show that our trained model still achieves quite good performance f1 score .
in this set.
table the effectiveness of rapid.
dataset precision recall accuracy f1 score training set .
.
.
.
validation set .
.
.
.
q2 how do the selected features help rapid?
we also split the whole feature set into two parts feature set from behavior semantics and from input output dependencies and train two respective models.
table shows the performance of the two models.
observe that the trained model with the feature set from either behavior semantics or input output dependencies alone exhibits inferior performance.
it shows the necessity for rapid to consider the two feature sets together.
table the effectiveness of rapid with different feature sets in training set .
rapid behavior semantic input output dependency f1 score .
.
.
q3 how efficient is rapid?
we collect the time cost of rapid in performing the analysis and classification on the whole dataset.
specifically in the static analysis phase the average time for rapid to analyze an app is .
seconds.
in the feature extraction and rplchk predication phase the average time for processing an app is .
seconds depending on how many compatibility checks are detected in the app.
summary rapid is both effective and efficient in classifying sigchk andrplchk by achieving a f1 score of .
and .
in the training set and randomlyselected validation set respectively.
besides the two feature sets both contribute significantly to its overall performance.
.
landscape of compatibility issue handling q4 how prevalent is evolution induced api compatibility issues in real world?
by checking the analysis results of the apps that have been successfully analyzed as presented in table we find apps do not invoke any api that is incompatible on the api levels they declared to have compatibility with thus they are unaffected by evolution induced api compatibility issues.
for the remaining apps i.e.
.
of the apps at least one incompatible api is used by each app.
this result shows that compatibility issues are indeed prevalent in android apps.
q5 how many checks belong to sigchk andrplchk respectively?
as table shows among the affected apps developers perform checks against compatibility related apis.
for these checks rapid reports that checks provide 893how android developers handle evolution induced api compatibility issues a large scale study icse may seoul republic of korea table apps with compatibility issues in the dataset.
all apps unaffected apps affected apps replacement implementations for the compatibility related apis on incompatible api levels while the remaining compatibility checks just prevent the app from crashing.
we can find that the ratio of rplchk .
is quite low in the real world which calls for improvement.
besides by examining the control structure of these checks checks are found to have both true and false branches.
this result clearly shows that simply utilizing the control flow structure to differ rplchk from sigchk is not reliable rendering the necessity to design a tool such as rapid forrplchk classification.
table sigchk andrplchk distribution in the dataset.
all checks sigchk rplchk cases if then if then else checks summary evolution induced api compatibility is a prominent challenge while developers do not tend to deal with incompatible api invocations by providing replacement functionalities.
besides sigchk andrplchk can not be classified by simply considering the control structure of the compatibility check.
.
the help of google s recommendations in our study there are compatibility related apis that have been checked by developers constituting compatibility checks.
since the overall ratio of rplchk .
is quite low we want to dive further into the results to find the factors that affect developers choice on handling compatibility issues.
specifically we focus on the following research questions.
q6 how many recommendations does google give to developers to deal with api related compatibility issues?
considering google sometimes provides recommendations for compatibilityrelated apis in the api document we first collect all the recommendations that google provides to developers.
since google s recommendations are given as comments of the compatibility related apis without a specialized format we choose to manually compile such recommendations.
by carefully reading the documents for these apis we label the recommendations that are given by google as follows.
each api is labeled by at least two analysts and if they have different opinions another analyst will participate.
in all analysts took part in labeling and it costs about people hours.
based on our investigation google only gives replacement recommendations for apis among the total apis and all the apis belong to deprecated apis.
for the remaining apis apis are newly introduced apis and apis belong to deprecated apis.q7 do google s recommendations affect developers decision on sigchk andrplchk?
for apis that have recommendations and those that do not have recommendations we calculate the ratio of rplchk for them separately.
table presents the results.
from this table we find that .
of the compatibility checks for apis with google s recommendations are rplchk while the rplchk ratio for apis without google s recommendations is only .
.
the significant gap in the rplchk ratio between the two api sets p value .
indicates that whether google giving replacement api recommendations significantly impacts developers decision on dealing with the compatibility issue using sigchk orrplchk.
we can also infer that providing developers with replacement recommendations is an effective way to help them handle compatibility issues.
table the ratio of rplchk for compatibility checks of the apis that do not have recommendations.
rplchk cases sigchk cases rplchk ratio with recommendations .
no recommendations .
q8 do developers follow google s recommendations when they replace incompatible api invocations?
since we have manually extracted google s recommendations for apis we want to further check whether developers follow google s recommendations to provide replacement functionalities for these apis.
first we collect all the rplchk cases for the apis i.e.
rplchk cases .
second we search the compatibility check branches for these cases.
if a recommended api appears in a candidatebranch we considered this case is handled by following google s recommendation.
table presents the ratio of the rplchk cases that do not follow google s recommendations.
the results show that although google gives recommendations developers handle a large part i.e.
.
of compatibility issues in their own way.
table the ratio of rplchk cases that do not follow google s recommendations.
rplchk cases that have google s recommendationsrplchk cases that do not follow recommendationsnot followed ratio .
q9 why do developers not follow google s recommendations?
for those incompatible api invocations that are not replaced in the recommended way by google we further investigate the underlying causes.
first we count the rplchk cases that do not adopt google s recommended api.
second we select the top apis and manually analyze the rplchk cases for these apis to infer why developers do not want to follow recommendations.
overall we observe two main reasons that cause developers to handle compatibility issues in a different way from the recommended way .
the analysis result is presented in table .
reason a the recommended api needs extra parameters.
the replacement apis that are recommended by google sometimes need more arguments than the original 894icse may seoul republic of korea hao xia yuan zhang yingtian zhou xiaoting chen yang wang xiangyu zhang et al.
table top apis that are not replaced in the recommended way.
api google recommended api reason actual replacement resources.getcolor i i resources.getcolor i theme i a context.getcolor i i resources.getdrawable i drawable resources.getdrawable i theme drawable a context.getdrawable i drawable resources.getcolorstatelist i colorstatelist resources.getcolorstatelist i theme colorstatelist a context.getcolorstatelist i colorstatelist display.getwidth i display.getsize point v b displaymetrics.widthpixels display.getheight i display.getsize point v b displaymetrics.heightpixels compatibility related api.
for example as depicted in table google recommends using resources.getdrawable i theme when resources.getdrawable i is not available.
however to invoke resources.getdrawable i theme developers need to prepare a theme instance as the second argument which is not so easy.
as a result we observe that in real world apps developers tend to use another api context.getdrawable i to fix the compatibility issue because it can be invoked with the same argument as the incompatible apiresources.getdrawable i .
reason b a quick replacement exists.
some of the compatibility related apis are getter functions of some fields.
for example display.getwidth returns the current width of display.
although google recommends using display.getsize point instead when this api is deprecated since api level developers are more willing to deal with this issue by directly accessing the field displaymetrics.widthpixels to get the current width of display.
it shows that a quick and easy replacement is more preferable.
summary on one hand the rplchk ratio for compatibility related apis that google give recommendations is significantly higher than those without recommendations but google only gives recommendations for apis out of compatibilityrelated apis seen in our study.
on the other hand though google gives recommendations developers do not always follow because an easier way to fix the compatibility issue than the recommended one exists.
therefore providing easily adoptable recommendations seems a promising way to help developers fix compatibility issues.
.
sigchk cases that can be improved for those sigchk cases we want to measure how many of them actually have replacement implementations while developers do not actively explore.
first of all we need to know which compatibilityrelated apis can be replaced since we observe that some apis can not be alternated if the platform does not support the functionalities.
for example wifimanager.startscan is deprecated since api level and the platform does not provide similar interfaces for apps to use.
thus no app in our dataset is found to provide a replacement implementation for this api.
q10 how many compatibility related apis have replaced implementation?
by checking all the rplchk cases we can find out all the compatibility related apis that have alternative implementations.
since some apps replace these apis it is appropriateto expect that other apps are able to replace these apis too.
in our dataset we find that developers successfully provide alternative implementations for compatibility related apis.
among the apis apis belong to deprecated apis and apis belong to newly introduced apis.
considering that google only gives recommendations for deprecated apis we find that developers can also work out their own solutions to provide replacement functionalities for newly introduced apis.
it is worth noting that this knowledge acquired from experienced developers is quite valuable to facilitate compatibility issue handling.
q11 how many sigchk cases can actually be handled by rplchk?
based on the compatibility related apis that can be replaced we count all the sigchk cases on these apis.
as table shows in our study checks can be handled with rplchk while developers do not do.
if all these issued are checked with replacements the ratio of rplchk in our dataset can significantly increase from .
to .
.
this gap shows that there is a great room to improve the current practice of handling compatibility issues.
however generating a legitimate alternative implementation automatically entails addressing new challenges e.g.
parameter preparation which are beyond the scope of the paper.
table sigchk cases that can be handled by rplchk.
all checks rplchk cases sigchk casessigchk cases that can be handled by rplchk summar y developers find more ways to replace incompatible apis than google s recommended ones while not all developers know these ways.
it is quite meaningful to mine such knowledge and share it with the whole community especially with novice developers.
limitations limitations of rapid.
this paper aims to conduct a large scale study on real world android apps to shed light on the current practice of handling compatibility issues without trying to extract common fix patterns from them.
with the aim to facilitate a measurement study rapid is not designed to be a repair tool.
it is quite different from the heavy weight static dynamic analysis techniques used in program repair and patch generation which need to reason about repair correctness.
the main contribution of rapid is that it features a deeper analysis than existing works by classifying rplchk and 895how android developers handle evolution induced api compatibility issues a large scale study icse may seoul republic of korea sigchk.
rapid extracts features for classifier training.
actually more features can be considered such as features extracted from api implementations.
nevertheless our trained model achieves good accuracy on both training and random selected data sets.
our static analyzer is built upon existing tools thus it inherits limitations of these tools.
besides developers may handle api compatibility issues by checking other conditions instead of sdk int .
for example java reflection may be used to find out if an api is supported by the underlying platform.
currently rapid cannot handle this kind of cases.
however sdk int is the most convenient way for developers to check compatibility issue and the most prevalent way as reported in .
to handle the compatibility checks against java reflection calls rapid can adopt existing techniques .
limitations of study.
the inherent limitations of the underlying analysis infrastructures may post external threats to the validity of the reported results.
several experiments in our study depend on google s fix recommendations.
since google only provides the fix recommendations in api documents we have to manually collect these recommendations.
to reduce the threat of manual mistakes or biases we follow the widely adopted cross validation method to ensure the correctness of our results.
besides to guarantee the representativeness of our study we have collected about 300k apps to conduct the study.
to the best of our knowledge this is the largest study in the scope of android app compatibility issues.
the ground truth data set for training the classifier contains compatibility checks with distinct apis.
note that substantial manual efforts are involved for each check as we have to label each pair wise combination of the incompatible api and each statement in the other branch.
although our results show that the trained classifier achieves good accuracy it is possible that the samples in our ground truth data set do not provide comprehensive coverage of the features for classification.
to mitigate the threat we further validate the results on a set of randomly selected samples.
related work compatibility issues in android apps.
wei et al.
perform the first systematical study on the compatibility issues of android apps by manually analyzing real world issues in open source apps.
their study categorizes compatibility issues into devicespecific and non device specific.
according to this classification method evolution induced compatibility issue belongs to nondevice specific issues.
since android api evolution is well documented it is quite easy for systematical modeling .
based on android api lifecycle cid and ictapifinder leverage program analysis techniques to detect missing checks of evolutioninduced compatibility issues.
huang et al.
discover another kind of non device specific compatibility issue called callback compatibility issue which is caused by the callback protocol evolution.
wei et al.
recently present pivot which can help to find device specific compatibility issues by ranking api device correlations.
acryl detects compatibility issues by learning the app changes in response to api changes.
to understand the observed incompatibilities in android apps haipeng et al.
conduct a study on installation time and run time app incompatibilities.
ziyi et al.
give a study on the intentions of developers onapp compatibility.
existing works also measure the consequences of compatibility issues affecting application performance disappointing users and even leading to security risks .
in comparison our work is the first to distinguish two kinds of compatibility checks sigchk andrplchk and to perform a study of a much larger scale on real world practice in handling evolutioninduced api compatibility issues.
program repair fix.
monperrus presents a systematic survey on automatic software repair.
to guide automated program repair liu et al.
analyze bug fix commits in open source java projects to extract repair patterns.
presents some manual analysis results on bugs in defects4j to shed light on how to automatically repair these bugs.
further proposes a way to automatically repair defects4j bugs based on api documents.
more advanced program analysis techniques are also incorporated into this line of research.
koyuncu et al.
automatically mine repair code pattern by differing the ast trees between fixed and unfixed code and utilize this pattern to guide program repair.
xuan et al.
propose a way to repair buggy conditional statements in java programs.
seeks to establish common root causes for android apps crashes and propose generic transformation operators to facilitate the remedy of these crashes such as replacement code and null pointer check.
compared to these works this paper performs a large scale study on the developers practice in fixing compatibility issues and the findings gained through the study could help to investigate automatic repair techniques for these issues.
conclusion previous works on evolution induced api compatibility issues mainly focus on detecting missing checks for incompatible apis.
however performing compatibility checks does not necessarily mean the compatibility issues are well handled.
this paper conducts the first large scale study on the practice of handling evolutioninduced compatibility issues with about android apps.
to perform such a large scale study this paper presents rapid which adopts a learning based approach to determining whether developers simply check an incompatible api invocation or provide a replacement implementation on those incompatible api levels.
through the study many interesting findings are derived to help us gain an in depth understanding about the current status of compatibility issue handling and indicate several directions to help developers to handle these issues.