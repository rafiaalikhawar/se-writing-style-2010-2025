the evolution of type annotations in python an empirical study luca di grazia university of stuttgart germany luca.di grazia iste.uni stuttgart.demichael pradel university of stuttgart germany michael binaervarianz.de abstract type annotations and gradual type checkers attempt to reveal errors and facilitate maintenance in dynamically typed programming languages.
despite the availability of these features and tools it is currently unclear how quickly developers are adopting them what strategies they follow when so and whether adding type annotations reveals more type errors.
this paper presents the first large scale empirical study of the evolution of type annotations and type errors in python.
the study is based on an analysis of type annotation changes which we extract from commits among projects.
our results show that i type annotations are getting more popular and once added often remain unchanged in the projects for a long time ii projects follow three evolution patterns for type annotation usage regular annotation type sprints andoccasional uses and that the used pattern correlates with the number of contributors iii more type annotations help find more type errors .
correlation but nevertheless many commits .
are committed despite having such errors.
our findings show that better developer training and automated techniques for adding type annotations are needed as most code still remains unannotated and they call for a better integration of gradual type checking into the development process.
ccs concepts software and its engineering language features software evolution general and reference empirical studies.
keywords type annotations type errors python empirical study acm reference format luca di grazia and michael pradel.
.
the evolution of type annotations in python an empirical study.
in proceedings of the 30th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse november singapore singapore.
acm new york ny usa pages.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
copyrights for components of this work owned by others than the author s must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission and or a fee.
request permissions from permissions acm.org.
esec fse november singapore singapore copyright held by the owner author s .
publication rights licensed to acm.
acm isbn .
.
.
.
commit .
def f x float y sum x y if sum return true b commit .
def f x int y bool sum int x y if sum return true c commit .
def f x int y optional sum int x y if sum return true figure example of an evolving partially type annotated python function.
introduction dynamically typed languages such as python and javascript have become the most popular languages for newly written code.1one reason for this popularity is their lightweight syntax which does not require developers to specify the types of parameters return values fields or variables.
at the same type the absence of static type annotations often hampers maintenance causes type related bugs to be missed and limits ide support.
the problems caused by the complete absence of type annotations has motivated optional type annotations.
they offer a flexible middle ground between no type annotations at all and a fully statically typed language enabling each developer to annotate only those types she believes to be beneficial.
the two most popular dynamically typed languages python and javascript both support optional type annotations.
in particular python .
specifies the meaning of type annotations for functions 2and python .
adds syntax for specifying the types of variables.
in recent years a variety of tools have been proposed for helping developers deal with type annotations in dynamically typed languages.
gradual type checkers use the available type annotations possibly along with type information for popular libraries to check for type errors.
beyond gradual type checkers recent work proposes techniques to infer and predict type annotations based on static analysis dynamic analysis probabilistic rules learned predictive models and combinations of the former .
such tools help annotate code with types in particular code written before the standardized introduction of type annotations into the programming language.
figure shows an example of a partially type annotated python function and its evolution across three commits which illustrates different kinds of type annotations how they may evolve and type errors that may become apparent as a result.
the function expects two parameters and returns whether their sum is an even number.
in commit the first parameter is initially annotated to be of type float whereas the second parameter remains unannotated.
november singapore singapore luca di grazia and michael pradel commit updates the parameter type of xfrom float toint and also inserts an annotation of the return type being bool.
moreover the code change inserts an annotation for the sumvariable to be of type int.
type checking commit will produce a type error because not all paths through the function return a boolean but the function implicitly returns none when the sum is not even.
finally commit fixes the type error by modifying the return type annotation to optional .
several years have passed since the release of python .
in and type annotations are hypothesized to be useful to developers but it is currently unclear how often they are adopted in practice and how this trend is evolving.
how frequently do people use this feature?
and how has its usage changed over time?
this serves to double check if adding type information to the python language is actually perceived as a benefit worth undertaking by developers.
moreover the gradual type system of python defines several standard library types such as int list and optional .
which of those are the most useful to developers?
and which of those have the most changes?
we can find that adding those types is non trivial and they sometimes result in incorrect type annotations.
what impact do the annotations have on detected type errors and if errors are detected do developers address them?
this helps to understand if type checkers are useful during the development process.
as a result answering these and other questions consist in better understanding the adoption of type annotations in python identify issues that developer s commonly face in this process and steer future research on developer tools toward the most relevant problems.
this paper presents the first comprehensive study of the evolution of type annotations and type errors in python.
the study is performed on of the most popular python projects analyzes commits and studies projects in more detail as they contain at least one annotation.
we address four research questions rq1 how does the adoption of type annotations evolve at the ecosystem level?
to better understand to what extent type annotations are getting adopted by the developer community as a whole we study the evolution of the prevalence of type annotations across a wide range of projects.
rq2 how does the usage of type annotations evolve at the project level?
this question aims at understanding the evolution of type annotations based on a commit based timeline of single projects.
rq3 how do individual type annotations evolve?
answering this question helps understand if and how type annotations once inserted change over time.
we also study whether type annotations are added alongside other code changes or in specific commits and how long they remain in a code base.
rq4 how do statically detectable type errors evolve and how do they relate to the type annotations in a project?
this question aims at understanding to what extent gradual type checkers can help avoid type errors whether developers fix these errors and how they are impacted by adding changing or removing annotations.
our methodology is based on an ast based analysis to extract type annotations a differential analysis to understand how type annotations evolve over time and gradual type checking on different versions of the projects.prior work has studied other aspects of dynamically typed programming languages e.g.
whether developers migrate from python to python how linters are used in javascript and whether type annotations in javascript and python reveal bugs.
ore et al.
assess the human effort involved in adding type annotations and hanenberg et al.
study the impact of type annotations on development time and maintainability .
another recent study is about the kinds of type annotations developers use and how the errors reported by different gradual type checkers differ.
in contrast to all the above our study focuses on the evolution of types and type errors over time allowing us to better understand the long term trends in adopting gradual typing.
our study leads to several findings regarding the prevalence characteristics and evolution of type annotations and type errors in real world python code including type annotations are getting more and more popular but are still far from being the norm.
less than of all possible code elements are currently annotated even in projects that have at least one type annotation.
this trend is slowly changing in favor of more annotations offering a huge opportunity for researchers and practitioners to build tools that help with this process.
most type annotations are added alongside other code but developers also occasionally .
of all type editing commits work on the type annotations only.
developers mostly focus on annotating parameter types and return types and less on variable types.
once added many type annotations are never updated .
and many type annotations .
are still present in the latest version of a project rewarding the effort of adding type annotations.
if developers change type annotations then optional types are commonly involved in the change.
most commits .
contain statically detectable type errors but are nevertheless integrated into the code base.
adding type annotations tends to increase the number of detected type errors correlation of .
.
our findings have several implications for developers and researchers working on developer tooling.
first we find that adding type annotations is a long term investment because they are rarely modified which can impact the maintainability of a code base over years.
second the result that more than of program elements are not yet annotated both in legacy code and newly written code is a call to arms for creating tools that infer and predict types.
recent work on learning based type prediction is a promising step .
third the repetitive nature of type annotation changes pinpoints several easy to avoid mistakes such as avoiding corner cases using a type tinstead of its optional variant optional as in our motivating example.
finally the fact that most commits have statically detectable type errors calls for more developer awareness and better integration of gradual type checkers into the development process.
in summary this paper makes the following contributions a comprehensive study of the evolution of type annotations and type errors in real world python code.
findings that may impact developers and teachers as well as future work on tools and techniques for developers.the evolution of type annotations in python an empirical study esec fse november singapore singapore a dataset of type annotation related code changes to be used in future work e.g.
on mining and learning from these changes.
our implementation the dataset and all experimental results are available online.
methodology this section discusses the methodology we use to address our research questions.
.
extracting and studying type annotations the core concept of our study are type annotations definition type annotation .a type annotation is a tuple tann t n k l wheretis a type nis the name of an annotated program element kis the kind of the annotated program element and lis the code location of the type annotation.
in line with the type annotations specified by the python language we consider three kinds kof program elements argument types return types and variable types.
the code location lis specified by a file path and a line number.
as an example consider the code in figure 1a.
the type annotation for the annotated parameter type is t n k l wheretisfloat nisx kis argument type and lis line of the corresponding file.
given the type annotations in a code base we compute the following notion of coverage which indicates how many of all program elements that could be annotated are indeed annotated definition type annotation coverage .given a code base b the type annotation coverage for a kind ktarget of program elements is covann t n k l b k ktarget all program elements of kind ktarget for example consider a code base that consists only of the function in figure 1b.
the type annotation coverage for argument types is because one out of two arguments is annotated whereas the type annotation coverage for return types is .
to extract both present and missing type annotations we perform an ast based static analysis of each python file .py and each python stub file .pyi in a version of a project.
the analysis visits each node that corresponds to a possibly type annotated program element and if an annotation is found extracts the corresponding tuple.
we focus on type annotations in the type definition syntax added in python .
pep and python .
pep .
in contrast we do not consider types described in informal type comments because type comments are only partially supported by tools and because our preliminary results found type comments to occur clearly less often than annotations in proper syntax.
the analysis of python files and python stub files is implemented on top of the libcst and typed ast libraries respectively.
extracting and studying type annotation changes as the primary focus of our work is to study the evolution of type annotations we extract annotations across the history of a project and relate them to each other.
definition type annotation change .a type annotation change is a tupletchange toldann tnewann c d wheretoldannandtnewann are the type annotations before and after a code change respectively cis the kind of code change and dis the date of the code change.
we consider three kinds of code changes inserting updating and removing a type annotation.
in a type annotation change that inserts or removes an annotation the old or new annotation is undefined respectively which we represent with .
for example the commits in figure involve four type annotation changes an update of the argument type x a newly inserted annotation for the return type of f a newly inserted annotation for the variable sum and an update of the return type of f. to study the evolution of individual type annotations we combine multiple type annotation changes into a history definition type annotation history .a type annotation history is a sequence t1 change ... tm change of type annotation changes where thet1 changehas code change kind c insert there is at most one type annotation change with c remove and if it exists then it is tm change the kindkof program element is the same in all type annotation changes and for consecutive type annotation changes the new type annotationtnewann of the first change is the same as the old type annotationtoldannof the second change.
for example consider an extended version of the example in figure where the code change in the figure is preceded by a commit that adds the function without any type annotations and followed by a commit that removes the annotation of the xargument again.
this evolution of the argument type would be represented as a type annotation history with three type annotation changes which describe how the annotation of argument xgets inserted updated and removed respectively.
we compute type annotation changes and type annotation histories by combining the annotations extracted by our ast based analysis across the commit history of a repository.
tracking annotations across histories is a non trivial challenge e.g.
because line numbers change due to removed and added code or because developers may modify multiple type annotations in a single commit.
algorithm summarizes our approach for addressing this challenge.
the algorithm iterates through a sequence of commits and extracts a set of type annotation changes from it.
at first lines and extract the type annotations from the old and the new version of a commit respectively.
then the algorithm compares these annotations based on their code location the kind of the annotated element and the name of the annotated element.
the goal is to find matches i.e.
pairs of an existing annotation and a revised version of it and that hence should be combined into a type annotation update.
to this end the algorithm builds upon the concept of hunks esec fse november singapore singapore luca di grazia and michael pradel algorithm extract type annotation changes from commits.
input sequencecof commits output settof type annotation changes old and new type pairs t forcommitcincdo told type annotations in code before commit c tnew type annotations in code after commit c d date ofc t for told tnew told tnewdo if hunkhincwheretoldinoldlinerange h andtnewinnewlinerange h then iftoldandtnewhave same kind k and same name nthen add told tnew update d tot t ensuresinglematch t fortnewnot yet added to t do add tnew insert d tot fortoldnot yet added to t do add told remove d tot t t t i.e.
consecutive lines that are changed together.
concretely lines to check whether a pair of an old and a new type annotation fit into the line range of a hunk in the commit and if so compares the kind and name of the annotated program element.
because we collect the life of type annotations from insertion to removing if removed the ensuresinglematch function checks if it is an update of a program element already collected or if it is a different program element without creating duplicate elements.
after finding pairs of type annotations that are changed in the commit lines to consider annotations that exist only in the old or only in the new version of the commit.
these annotations are added to the set of type annotation changes as inserted and removed annotations respectively.
because algorithm is heuristic we validate the accuracy of the type annotation changes it extracts by manually inspecting histories with a total of type annotation code changes.
we randomly sample these type annotation histories based on three categories i annotations that are never updated and still present in the last analyzed version of the project ii annotations that are never updated but removed at some point during the commit history iii annotations that are updated multiple times.
for each sampled history we carefully inspect the commits involving the annotation and establish a ground truth history.
we find that .
of the automatically extracted histories match the manually established ground truth i.e.
the vast majority of histories is correctly extracted.
the main reasons for partially incorrect type annotation histories are mismatched annotations due to multiple identifiers with the same name in the same file and renamed or deleted files that our analysis does not track.
.
gathering and studying of type errors we study the evolution of type errors by running a gradual type checker on different commits in the history of a project.
there areseveral popular type checkers for python e.g.
pyre mypy and pytype.
for our study we focus on pyre because it is industrially used e.g.
at facebook and could successfully analyze the studied projects.
the kinds of type errors reported by pyre and other gradual type checkers fall into two categories.
one category of errors are those caused by missing dependencies e.g.
when the type checker cannot find an imported class or cannot resolve a reference to a type.
these errors are unlikely to occur when a type checker is used by the project developers assuming that the developers create a proper configuration that resolves all external dependencies.
in contrast eliminating these errors in a large scale study is difficult because resolving all dependencies and configuring the type checker to find the dependencies is non trivial.
the second category of errors are the actual type errors which result from inconsistencies between inferred and annotated types of values and the uses of these values.
for example these errors occur because a function argument is incompatible with the declared parameter type or because a method overrides another method with an incompatible type signature.
we focus our study on the second category of errors and unless otherwise mentioned ignore the first category providing a realistic view of what errors the developers of a project would see when using a type checker.
.
selection of projects to study as subjects for our study we select a wide range of open source projects based on their creation time and their popularity.
at first we gather the list of all python projects at github via the github api.6we group the projects by their creation date considering projects created in the years to into ten groups that each cover one year.
then we sort the projects in each group by their number of stars and select the top per group which yields a total of projects to study.
the rationale for first grouping and then sampling is to avoid biasing our study toward projects created in a particular time frame e.g.
mostly old projects.
removing projects that we could not clone e.g.
because they became unavailable since the beginning of our study the total number of analyzed repositories is .
results this section presents the results we obtain when addressing our four research questions.
before going through the research questions we give an overview of the analyzed data.
in total the study involves commits in repositories.
our analysis extracts type annotation changes from these commits.
these type annotation changes correspond to commits and repositories that have at least one type annotation change.
our results are for these projects.
as general statistics the number of commits with at least one type annotation grows every year.
an early adoption started already in where .
of the commits contain at least one type annotation and this number of commits grows every year until reaching .
in .
evolution of type annotations in python an empirical study esec fse november singapore singapore year0200000400000600000800000type annotations type annotations per loc type annotations left stub annotations left type annotations per loc right figure evolution of type annotations across all projects.
.
rq1 ecosystem level evolution of type annotations to understand whether type annotations are becoming more common in the python ecosystem as a whole we analyze the evolution across all studied projects.
the goal is to understand trends in the ecosystem e.g.
caused by the introduction of new programming language features or tools.
we perform this analysis from two points of view.
first we analyze the evolution of the absolute number of type annotations.
second we measure the evolution of type annotation coverage.
.
.
how is the total number of type annotations evolving?
we measure the overall number of type annotations and the overall number of lines of code between and .
figure shows the results taking a snapshot of each project on october of each year.
the main observation is that both the absolute number of type annotations and the number of type annotations per line of code are steadily increasing in a roughly linear manner since .
in there are around .
annotations per lines of code.
to better understand the relative importance of annotations provided in regular python files .py and python stub files .pyi figure distinguishes between them.
it shows that the vast majority e.g.
.
of all annotations present in are provided in regular python files.
a manual inspection of stub files sampled from projects shows that most annotations provided in stub files are about apis of external libraries out of the files for example native libraries accessed via python s native bindings.
two of the remaining three files are automatically generated.
given the relatively low number of annotations in stub files and their focus on external libraries the remainder of the study considers only annotations in regular python files.
year0246810type annotation coverage function arguments function returns variable assignmentsfigure evolution of program elements with and without type annotations.
finding type annotations are getting more and more popular with an increase of about type annotation per line of code after and reaching .
annotations per lines of code in .
.
.
how is the type annotation coverage evolving?
this question is important to understand how much of the available annotation potential developers are currently using.
out of all projects we study only use type annotations at all.
that is six years after the introduction of type annotations into the language the large majority of projects is not yet using this feature.
figure takes a detailed look into those projects that use type annotations.
the figure shows the type annotation coverage for function arguments return values and variables on october of each year.
the results allow for several observations.
first the type annotation coverage is steadily increasing.
second developers prefer to annotate function argument types and return types but focus less on variable types.
third despite the clear upward trend the type annotation coverage is still relatively low with an average of around for function arguments and return values.
to put the type annotation coverage in perspective we consider a project known for its heavy use of type annotations mypy7 which is one of the gradual type checkers for python.
this project has a type annotation coverage of .
for parameter types .
for return types and .
for variable types.
a manual inspection shows two main reasons for leaving program elements unannotated.
first the developers do not annotate self parameters as self always has the type of the current class and hence does not really need a type annotation.
second a significant number of unannotated local variables have types that can be easily inferred by a gradual type checker e.g.
because a variable is assigned the result of a constructor call or the variable is assigned an annotated variable.
omitting such annotations fits the philosophy behind gradual typing i.e.
to annotate types when it is helpful without cluttering the code with unnecessary annotations.
november singapore singapore luca di grazia and michael pradel regular annotation time steps during version history of facebookresearch pytext01000020000300004000050000 lines of code left type annotations right type sprint time steps during version history of deepinsight insightface0100002000030000 lines of code left type annotations right occasional use time steps during version history of hhatto autopep8050001000015000 lines of code left type annotations right figure per project evolution of three representative projects.
finding type annotations are not yet the norm with less than of all possible code elements being currently annotated but there is a clear upward trend.
function arguments and return types are annotated more commonly than variables.
.
rq2 project level evolution of type annotations after considering the python ecosystem as a whole in rq1 we now study the evolution of type annotations within individual projects.
to this end we measure how many type annotations a project has at different points during its lifetime where lifetime means all commits from creating the project until the end of our measurement period end of .
putting the absolute number of type annotations in perspective we also measure the number of lines of code at each point during the project lifetime.
a commonality of almost all studied projects is that the number of type annotations is rarely decreasing but instead grows continuously i.e.
once annotations are added developers rarely remove them.
by inspecting the evolution of type annotations of various projects we identify three common evolution patterns illustrated in figure with three representative projects.
for each project the plot shows how the code size and the number of type annotations have evolved throughout the project s history.
regular annotation .
some projects such as facebookresearchpytext 8have adopted type annotations throughout their entire history and regularly add annotations as the project is growing.
the typical evolution pattern of these projects is that the number of type annotations is growing at roughly the same rate as the overall code size.
as can be observed by comparing the absolute numbers of lines of code left axis in figure and type annotations right axis such projects often have significantly more type annotations than the average project.
for the specific example there are about annotations per lines of code whereas the average determine project level evolution pattern.
input projectp output evolution pattern of p dividepinto time steps of equal number of commits p.annotations number of annotations for each time step p.slope annotation evolution slope for each time step ifmax p.annotations 15orp.slope.count .
8then return occasional use else ifp.slope.count .
4then return type sprints else ifaverage p.slope 0then return regular annotators else return other project reaches even in only about annotations per lines of code figure .
type sprints .
some other projects e.g.
deepinsight insightface 9have invested into type annotations during a focused sprint like effort where many annotations are added at once but otherwise do not regularly add annotations.
a variant of this pattern is a step like curve of the number of type annotations i.e.
projects that add annotations in multiple yet non continuous efforts.
occasional use .
some projects such as hhatto autopep8 have only a small number of annotations typically added in a single or very few files.
this kind of project is included into the study because we consider all projects with at least one type annotation.
to measure the prevalence of these three patterns across all studied projects algorithm heuristically determines whether a project fits any of the patterns.
the algorithm divides the commit history of a project into ten equally sized steps and it then checks the number of annotations present at each step and the slope from the previous to the current time step.
for example if the average evolution of type annotations in python an empirical study esec fse november singapore singapore slope across all time steps is positive then the algorithm classifies the project as regular annotation whereas a project with four or more time steps that do not add any annotation is classified as occasional use .
in the algorithm p.slope refers to the list of slopes observed at different time steps and p.slope .
checks how many of these slope values are equal to zero.
we validate algorithm in three steps.
first we generate the evolution plots of all studied projects.
second we manually inspected randomly selected plots and looking at the curve manually label each of them.
third we run algorithm and compare the labels produced by the algorithm with our manual labels.
during this validation the algorithmically produced labels all match our manual labeling.
running the algorithm across all projects shows that .
perform regular annotation .
use type sprints and .
are occasional use .
the remaining .
are other i.e.
their evolution does not fit any of the three patterns.
we also study the relation between the patterns and the characteristics of the project such as the number of stars and contributors.
while most characteristics are independent of a project s evolution pattern we find a relationship with the number of contributors.
regular annotation projects have an average of contributors projects using type sprints have contributors and projects with occasional use have only contributors on average.
these numbers show that regularly adding type annotations is practice followed particularly in large repositories with a more solid organization presumably because type annotations help coordinate between a large number of developers.
finding most projects follow one of three evolution patterns when adding type annotations regular annotation type sprints and occasional use .
projects with more contributors tend to use regular annotation whereas projects with few contributors tend to follow occasional use .
.
rq3 evolution of individual type annotations the following studies how individual type annotations evolve which allows us to better understand how developers insert modify and remove type annotations.
.
.
when do developers edit types?
since type annotations are optional in python developers can freely choose when to add or edit them.
in particular a developer can add new type annotations along with other code e.g.
along with a newly added function or in a separate step later on e.g.
as part of a code improvement session.
to understand when developers insert or modify types in a code base we analyze all commits in the dataset that affect at least one type annotation.
for each such commit we compute how many of all lines edit a type annotation.
the resulting value is a percentage where means that the commit is only to edit type annotations and a value closer to means that more other code is edited alongside the type annotation edit.
the results are shown in figure .
we see a bi modal distribution where the majority of commits edit a significant number of other lines in addition to editing type annotations.
at the same time there are a non negligible number of commits that exclusively edit type percentage of annotation related lines among all inserted removed and changed lines102103104number of commits log scale figure percentage of annotation related edited lines among all edited lines.
a commit .
def pdist2 x torch.tensor z torch.tensor none order pdist2order pdist2order.d second torch.tensor b commit .
def pdist2 x z none order pdist2order.d second type torch.tensor torch.tensor pdist2order torch.tensor figure example of removing a type annotation.
annotations showing that developers at least sometimes specifically focus on editing type annotations.
finding most type annotations are edited alongside other code but developers also occasionally .
of all type editing commits work on the type annotations only.
.
.
how long do type annotations remain in a code base?
answering this question helps understand whether adding type annotations is a long term investment.
we address the question in two ways.
at first we study how many of all ever added type annotations are still present in the latest version of the projects.
to this end we compute for each repository the number of type annotation changes that insert an annotation.
in addition we analyze the latest version of each repository cloned on march and compute how many type annotations it contains.
in absolute values .
of all annotations survive until the latest version of a repository.
for some projects shown in the upper right corner of the figure all ever added annotations are still present in the latest version.
second we consider all type annotation histories in the dataset where the last change is a commit that removes the annotation.
we compute the lifetime of each such annotation as the difference between the first and the last date in the history.
in total we find that .
of all type annotations eventually get removed.
we analyze in detail the removed type annotations.
their average lifetime is days showing that even annotations that get removed remain in the code for a while.
an example is shown in figure where theesec fse november singapore singapore luca di grazia and michael pradel number of changes for a type annotation100101102103104105type annotations log scale figure number of times that the same type annotation is updated by developers.
not shown are the .
of all type annotations with zero updates.
types are removed from the source code and saved in a comment.
the commit messages says that the developers are adding support for python .
which does not support the type annotation syntax yet.
we inspect a random sample of of all removed annotations and classify them into three categories.
we find that in of the cases the entire files are removed or renamed in of the cases the program element is removed or renamed and in of cases types are explicitly removed e.g.
for supporting python or to simplify the code as shown in figure .
as a result we can affirm that type annotations are a long term investment because only in very few cases types are explicitly removed again.
finding .
of all ever inserted type annotations are still present in the latest version of a repository and those type annotations that get removed at some point live for an average of days.
.
.
how do type annotations change?
once type annotations are added developers may modify them e.g.
to fix a wrong annotation or because the annotated code is evolving.
in this research question we do not consider types that are removed.
we study type annotation changes by at first investigating how often type annotations are updated at all.
to this end we analyze all extracted type annotation histories and compute how many updates of a type annotation they contain.
figure shows how many type annotations we find that are updated a specific number of times.
the plot does notshow the vast majority .
of all type annotations that are never updated.
overall we count annotation updates with an average of .
updates for each type annotation that gets updated at least once.
the maximum number of observed updates is which is an outlier though.
out of those annotations that get updated at all most are updated five times or less.
figure shows an example.
in case the type annotation is updated to sequence and later to the user type modelfield .
to better understand how annotations that get updated evolve we analyze which kind of type annotation updates are most common.
figure shows the results of this analysis where the three plots show the five most commonly observed updates for argument types return types and variable types respectively.
we show all types that are part of the python language and its standard library as is e.g.
strandoptional and abstract all user defined types into usertype .
the results allow for two observations.
first many type annotation updates involve custom types.
second many updates affect optional types e.g.
changing strtooptional .
in total we count type annotation updates involving optional types.
a manual inspection of some of these updates shows that developers easily get confused about whether a parameter is optional or whether a variable should be immediately initialized.
figure shows an example where the code on the left is type incorrect which the developer then fixed.
finding most type annotations .
never get updated.
for those that get updated a frequent update pattern involves custom and optional types which seems a common source of confusion.
.
rq4 type errors vs. type annotations in this last research question we inspect the number of type errors and their relationship with type annotations.
we divide this analysis into three parts.
first we compute how many type errors are in these repositories.
second we check if there is a correlation between the number of type errors and type annotations.
third we analyze if insertions of type annotations increase the number of type errors.
these three parts are performed on all the projects that have at least one annotation.
.
.
how common are type errors?
this research question is important to understand what value gradual type checkers could add to real world python projects and whether today s developers are using these tools.
for each analyzed project we run the type checker on each commit in the project s history and then count the number of non dependency related type errors section .
.
we find that .
of the analyzed snapshots have at least one type error.
on average there are type errors per lines of code.
this result indicates that type checking is not yet part of the typical development routine calling for better tool support and more developer awareness.
to better understand the kinds of detected type errors we analyze what kinds of errors are most common in the most recent versions of the studied projects.
we find a total of type errors and that a few kinds of errors occur repeatedly in particular the errorincompatible variable types .
and incompatible parameter types .
.
evolution of type annotations in python an empirical study esec fse november singapore singapore a commit .
def request params to args required params list ... tuple list b commit .
def request params to args required params sequence ... tuple list c commit .
def request params to args required params sequence ... tuple list figure example of a type annotation updated multiple times.
usertype usertypeusertype strstr usertype str optional any usertype type changes in function arguments100102104occurrences log scale usertype usertypenone usertypeusertype noneusertype strstr usertype type changes in function return100102104occurrences log scale usertype usertypefloat decimal str optional str usertype int optional type changes in variable assignment100102104occurrences log scale figure most common kinds of type annotation changes.
a commit .
class licenseinfo license type str owner str none b commit .
class licenseinfo license type str owner optional none figure example of adding a wrong type annotation and then updating it with optional type.
type annotations log scale 100101102103number of type errors log scale figure relation between type errors and type annotations in a project correlation .
.
finding most projects have statically detectable type errors and type errors seem to not prevent developers from committing code.
a few kinds of mistakes account for most type errors.
.
.
how does the number of type errors depend on the number of type annotations?
one major goal of introducing type annotations is to statically detect otherwise missed type errors.
the reason is that most gradual type checkers including the pyre tool used here run additional type checks if more annotations are present.
even if these tools are not perfect several studies proved the usefulness of type checkers so we decide to use pyre for this research question.
to check if type annotations indeed provide this benefit in practice we compute the correlation between the number of type errors and the number of type annotations in each project.
figure visualizes the relation between these two measures showing that there is a significant correlation pearson coefficient of .
between them.
we conclude that adding type annotations is only the first step toward improving type correctness and the developers also need to introduce type checking into their developing routine.
finding adding type annotations positively correlates with an increase in the number of detected type errors correlation .
.
developers should introduce type checks in their developing routine to find and fix such errors early on.
.
.
how does the number of type errors evolve when type annotations evolve?
the following aims to understand how evolving the type annotations of a project impacts the statically detectable type errors.
for this purpose we extract from all type annotation changes only those where all lines changed in the commit correspond to only adding type annotations which we call pure commits .
pure commits are interesting because they allow us to study in isolation the effect on the code base of adding type annotations.
for each pure commit we compare the number of type errors before and after the type annotation change.
we find that commits introduce more errors commits reduce the type errors and commits keep the same number of errors.
while in most cases the number of type errors remains the same the kind of pureesec fse november singapore singapore luca di grazia and michael pradel commit has a significant impact on incrementing the number of errors.
finding adding type annotations can introduce new type errors so this process should come with the usage of type checkers.
discussion implications for developers and project managers.
the overall trend is that type annotations are increasingly popular rq suggesting that developers should pick up the habit of adding annotations as they write code.
regularly adding annotations is common especially for projects with many contributors rq .
adding to benefits reported by others our results provide empirical motivation for adding type annotations such as the fact that more annotations help find more type errors rq and the observation that most annotations remain in the code for a long time rq .
we also pinpoint specific update patterns for individual annotations which could help developers to avoid recurring mistakes e.g.
related to optional types rq .
finally we show that developers do not need to annotate every program because even in projects with heavy use of annotations self explanatory parameters and variables often remain unannotated rq .
implications for researchers and tool builders.
even though type annotations are being used more and more the large majority of code elements that could be annotated currently remains unannotated rq .
while probably not all code in all projects needs type annotations we see a huge potential for techniques that automate the process of adding types into an existing code base such as neural type prediction models .
another promising direction is to improve the integration of type checking into the development process.
the fact that many commits contain type errors found by a type checker rq but nevertheless are committed shows that type checking currently is not yet standard.
better understanding the reasons for this phenomenon will be interesting future work.
threats to validity.
our selection of projects is based on popularity and the projects creation time.
another selection strategy e.g.
based on application domains might give other results.
we focus on popular projects because they overall have a higher impact and are more likely to represent serious development efforts than e.g.
small toy projects or student assignments.
to study type errors we use a single type checker pyre and other type checkers may give other type errors.
see ?
for a discussion of the subtle differences between the type systems behind pyre and mypy.
some of our results are based on manual inspection and heuristic algorithms which likely are imperfect.
to mitigate this threat we carefully check all results and make them available as a reference for future work.
finally our study focuses on a single language python and we cannot claim that our results will generalize to others.
comparing the evolution of type annotations across different languages will be interesting future work.
related work studies of type annotations.
some prior work studies type annotations.
the perhaps most closely related study is by ?
who study type annotations and type errors in a single version of popular python projects.
in contrast to this work they do not analyze the evolution of type annotations and type errors.
jin et al .
study type annotations in python projects.
they find six patterns that type annotations practices follow and they find three features of python type annotation files.
our study differs from their result because we analyze many more projects and we focus on different kinds of research questions focusing more on single type annotations and type errors.
khan et al .
study type errors in python repositories using mypy .
they conclude that many type defects can be avoided by simply integrating a type checker in the software development process.
then they find that junior and senior python developers make a similar number of errors concluding that the experience is not always enough to avoid this kind of errors.
our study differs from this one because we not only analyze the number of type errors but we study the relationship and the evolution between type annotations and type errors.
moreover our study focuses on type annotations and not only type errors.
researchers also study type annotations in programming languages other than python e.g.
relating static type checking in javascript with known bugs .
bogner and merkel compare javascript and typescript focusing on code quality and readability.
however also as our findings show they find that typescript does not always guarantee fewer errors.
another study suggests that the time spent adding static types to programs is helpful in impacting the overall effort required for bug resolution .
finally several studies of dynamically typed languages focus on questions complementary to ours e.g.
the use of dynamic language constructs performance issues and security vulnerabilities .
type prediction for dynamically typed languages.
techniques for predicting type annotations in dynamically typed languages fall into three categories.
first static type inference computes types using e.g.
abstract interpretation or type constraint propagation.
while sound by design these approaches are limited by the dynamic nature of the languages like javascript and python.
second dynamic type inference tracks data flows during an execution of a program which yields precise types but is limited by code coverage.
third probabilistic type prediction propagates and combines type hints using probabilistic rules or learns a machine learning from existing type annotations .
our work underlines the need for such techniques and motivates future improvements.
program analysis for python.
beyond type prediction several other analyses for python have been proposed including techniques to find type related bugs an analysis to reveal inconsistencies between the name of a variable and the runtime values stored in it and a general purpose dynamic analysis framework .
these analyses are all based on dynamic analysis which is at least partially motivated by the lack or incompleteness of type annotations in python.the evolution of type annotations in python an empirical study esec fse november singapore singapore tracking code elements across version histories.
tracking code elements across the different commits in a project is a challenging problem due to the various ways how code may change and because there is no universally accepted definition of when a code element remains the same across a change.
grund et al.
propose codeshovel which addresses this problem on the method level through an ast based heuristic algorithm.
ketkar et al.
focus on type changes in java using type fact graphs to represent code changes.
our algorithm for extracting type annotation changes is the first attempt at tracking annotations in a dynamically typed language.
analyzing code changes.
there are many approaches to analyze and study code changes.
several techniques build edit scripts on asts providing an abstract representation of a change that can then be applied in different scenarios .
lase generalizes multiple code changes into a single edit script .
paletov et al.
study code changes related to crypto apis and they extract security fixes from code histories.
weissgerber et al.
identify code changes that have a high chance to be refactored.
hashimoto et al.
propose a technique for reducing a diff to the essence of a bug .
scc and deepjit are predictive models that estimate the correlation between the insertion of a code change and introducing a bug.
a related problem is to find the bug inducing code change for a given bug report .
to simplify studies on code changes techniques for matching commit histories against specific queries have been proposed e.g.
prequel and diffsearch .
because type annotation changes typically affect only a single code location using a complex representation such as ast edit scripts is unnecessary for our study but we instead analyze annotation changes using custom algorithms.
studies of code evolution.
software is continuously evolving and many researchers perform interesting studies.
nguyen et al.
study the repetitiveness of code changes in code histories modeling a code change as a pair of ast sub trees within a method.
gu et al.
analyze large project histories to study problems related to multi thread programming.
dagenais et al.
study code evolution to recommend relevant changes with a high precision.
our paper contributes the first in depth study of the evolution of type annotations in python.
gradual type checking and type errors.
gradual type checkers have developed into powerful tools for dynamically typed languages.
chen et al.
build a framework to check type bugs extracting information from source code using static analysis .
dolby et al.
use static analysis with types to track tensorflow behavior and find bugs .
the results of our study underline the need for better integrating such tools into the development workflow.
conclusion this paper presents a large scale empirical study of the characteristics and evolution of type annotations and type errors in python.
our methodology statically analyzes individual commits of projects extracts type annotations combines them into histories that show the evolution of the annotations and type checks different commits of projects.
we extract .
million type annotation changes from repositories.
our results show that type annotations areclearly gaining traction yet the large majority of code elements that could be annotated currently remains unannotated.
while probably not all code in all projects needs type annotations we see a huge potential for techniques that automate the process of adding types into an existing code base such as neural type prediction models .
finally many developers seem to not regularly check their code for statically detectable type errors or if they do commit the code despite such errors.
we recommend to increase developer awareness and to better integrate gradual type checkers into the development process to alleviate this situation.
acknowledgment this work was supported by the european research council erc grant agreement and by the german research foundation within the concsys and democo projects.