efficientmodule level dynamic analysis fordynamic languages with modulerecontextualization nikos vasilakis mitcsail usa nikos vasilak.isgrigorisntousakis tucrete greece gntousakis isc.tuc.gr veitheller unaffiliated germany veit veitheller.demartinc.
rinard mitcsail usa rinard csail.mit.edu abstract dynamic program analysis is a long standing technique for obtaininginformation aboutprogram execution.we present module recontextualization anewdynamicanalysisapproachthattargets modern dynamic languages such as javascript and racket enabled bythefactthattheyfeatureamodule importmechanismthatloads codeatruntimeasastring.thisapproachuseslightweightloadtimecodetransformationsthatoperateonthestringrepresentation ofthemodule aswellasthecontexttowhichitisabouttobebound toinsert developer provided analysis specific codeintothe module before it is loaded.
this code implements the dynamic analysis enabling this approach to capture all interactions around the module in unmodified production language runtime environments.
we implementthisapproachintwosystemstargetingthejavascript andracketecosystems.ourevaluationshowsthatthisapproach candeliverorder of magnitudeperformanceimprovementsover state of the artdynamicanalysissystemswhilesupportingarange ofanalyses implementedonaverageinabout100linesofcode.
ccs concepts software and its engineering software maintenance tools dynamic analysis frameworks .
keywords dynamic runtime analysis instrumentation recontextualization performance security acmreference format nikos vasilakis grigoris ntousakis veit heller and martin c. rinard.
.
efficient module level dynamic analysis for dynamic languages with module recontextualization.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of softwareengineering esec fse august 23 28 athens greece.
acm newyork ny usa 12pages.
permissionto make digitalor hard copies of part orall ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation onthefirstpage.copyrightsforthird partycomponentsofthisworkmustbehonored.
forallotheruses contactthe owner author s .
esec fse august 23 28 athens greece copyright heldby the owner author s .
acm isbn .
introduction dynamic program analysis is a technique for monitoring understanding andpotentiallyinterveninginprogrambehaviorduring its execution.
to cite only a few examples dynamic analysis has beenusedtoinferinvariants checksecurityconstraints andextract performance characteristics .
existing dynamic analyses often impose significant runtime overhead jalangi androadrunner forexample report no op analysis overheads on the order of 26 32 and respectively.forthisreason dynamicanalysisistypicallydeployedfor offline use collecting and replaying traces offline or stressing a program withtestinputs inatestenvironment.the factthatproductionenvironmentscandifferconsiderablyfromofflineortesting environments can significantly impair the utility of dynamic analysesthataredeployedonlyduringdevelopmentortesting.software vulnerabilities for example can be latent during development and test but exploitableonly inproduction .
we present a new point in the dynamic analysis design space modulerecontextualization isanapproachthatoperatesatthegranularity of modules with the resulting analysis code executing at moduleboundaries.1weemphasizethatthegoalisnottosupplant existingtechniquesthat operateatthegranularityofinstructions orprocedures .thegoalisinsteadtoprovideacoarse analysis with low enough overhead in practice 2 3 runtime overhead to enable always on uniform deployment during development testing and production.
in effect we trade off detail and precision to drive down the overhead while still supporting meaningfulanalyses .
module recontextualization leverages characteristics of modern dynamic languages to dynamically transform each module when it is loaded applying both source code and object transformations.
it thusrequiresnochangestotheruntimeenvironmentandworks with completely unmodified dynamic language production runtimes.theanalysesthemselvesarewritteninthesamelanguageas theanalyzed program preservingdeveloperknowledge expertise libraries andcode andenabling thedevelopment ofanalysesthat analyzeanalysiscode.theseanalysesremainfullyunderdeveloper control with module recontextualization supporting targeted analysisofonlyselectedmodulesanddynamictogglingonandoffas the applicationexecutes.
1weusethe terms moduleand libraryinterchangeably.
esec fse august 23 28 athens greece nikos vasilakis grigoris ntousakis veitheller andmartinc.rinard this paper makesthe following contributions module recontextualization itpresents module recontextualization a new dynamic analysis approach that targets modern dynamic languages and operates atthe boundaries of selected modules.
module boundaries go well beyond externally invoked entrypoints theyalsoincludereferencedglobalvariables basic languagefeaturessuchas importandexportstatements and basic type constructors such as numberandarrayconstructors.
twoimplementations it presents a two part implementation ofmodulerecontextualization lya thattargetsthejavascript and racket ecosystems.
the discussion of the opportunities and challenges associated with implementing lya as a pluggable library for modern dynamic languages focuses on the javascript port anddiscussesracketwhen the twodiverge.
case studies andevaluation it presents an evaluation of lya for three dynamic analyses of javascript applications and libraries includingaread write executesecurityanalysis aperformanceanalysis andarun timetypeinvariantdiscoveryanalysis.itshowsthatlyaincursruntime overheadsunder5 and can accurately detectissuesand applicationcharacteristics that would surface only in production environments e.g.
invalid accesses during object deserialization performance pathologies inregular expressionmatching anddynamic type anomalies.
lya has been open sourced and is available for download from github background examples and scope wefirstpresentbackgroundonmodulesystemsemployedbydynamic languages .
.
we then describe three use cases that highlight the kinds of the analyses the lya is designed to support .
.
we finish by identifying the scope of lya i.e.
the characteristics of the environmentsandanalysesthat ittargets .
.
.
modulesystems modules encapsulate reusable functionality.
this functionality typically falls into two categories it either i comes bundled with the language possiblywrappingoperating systeminterfacessuchas the file system in a way that is system agnostic and conforms to the language s conventions or ii is provided by other developers sharingcodeothersmightfinduseful.consideramodulenamed simple mathbelow providing a few mathematical functions such asmulanddiv letmath mul a b a b div a b import log .info b returna b ...some more code... exports math thismodulemaybe importedandusedbyadifferentmodule as shownbelow 2in the background and design sections of the paper we write import in the sections describingthetwoimplementationsandevaluationoflya weusetheactualname corresponding to the prototypein eachlanguage e.g.
require.letm import simple math letresult m.div m.mul m.mul print result exports result from a developer s perspective importing a module makes its functionalityavailabletothe calling code bymeans ofbindingits functionality to a name in the caller s scope.
this is achieved by some form of exporting where the module developer expresses which values should become available to the importing code.
the definition of a value depends on the semantics of the language.
internally the module may importother modules cause side effectsto the file systemor the network or even be implemented in multiple languages.
importingamoduleinadynamiclanguagesuchasjavascript typically involves several steps.
the runtime system first locates themodule inthefile system.it then reads the module and wraps ittoresolvemodule localnames suchas filename injavascript and name in python to meaningful values.
the wrapper is then interpreted and evaluated using the language s interpreter whichmightresultinsideeffects forexample a process.exit inthemodule stop levelscopewillexittheentireprogram.finally the value bound to the exported interface or returned from this interpretation dependingonthelanguage ismadeavailabletothe scope ofthe importingcode.
complicationsmayincludetheuseofamodulecachetoavoid loadingoverheadsandmaintainconsistencyformodulesthatare loadedmultipletimesfromdifferentpartsofthecodebase.theuse of a module cache can also support recursive imports and cyclic dependences.
an increasingly common feature is to allow different versions of the same module to co exist in a program to avoid imposingonemutuallyexclusivechoice aparadoxicalsituation knownas dependencyhell .asaresult asingle importlmaynot necessarilyresolvetothesame versionofthe module leverytime.
thedualofthisisalsopossible twodifferentmodulenamesmay resolvetothesameidentifier i.e.
pointtothesamecacheentry .
thesefeaturescansignificantly complicatedynamicanalysesthat operate at the granularity of modules.
we further discuss these issues includinghowlyadeals withthem insection .
.
dynamicanalysis examples wenextdiscussthreeexampledynamicanalysesthatcanbeperformedatthegranularityofmodules i aread write executesecurity analysis ii a performance profiling analysis and iii an analysisextracting runtimetype invariants.
securityanalysis thepervasiverelianceonthird partylibraries hasledtoanexplosionofsupply chainattacks .
both bugs and malicious code in libraries create attack vectors exploitablelongafterlibrariesreachtheirendusers.popularlibraries dependeduponbytensofthousandsofotherlibrariesorapplications can allow vulnerabilities deep in the dependency graph to affectagreatnumber ofapplications .
consider for example the recent event streamincident in which a maintainer of a highly popular library inserted codetostealbitcoinwalletcredentialsfromprogramsusingthatlibrary.heavyweighttestingorinstrumentation wouldnothave helped as event streamactivated onlyduringproductionrather 1203efficient module level dynamic analysis fordynamic languageswithmodule recontextualization esec fse august 23 28 athens greece than during testing or development.
whole program os level containment or system call interposition would have not helped either as the programs importing event streamalready made use of system calls to access the disk and network.
finally static analysis wouldhave beenoflittleuse as event streamencryptedits malicious payload.
amodule level dynamicanalysisofread write execute permissions used by this library would have detected the unusual resources accessed by event stream.
analyzing the behavior within thelibraryitselfis notcritical ifanydata exfiltration ishappening it will require calling out of the library and into the network in event stream scase usingthe fslibrarytomodifyadifferentlibraryandthencall httpfromthesecondlibrary.both fsandhttp arepartofthestandardlibrary builtintotheruntimeenvironment.
other examples of interfaces that are available to the entire programincludeglobalvariables libraryimporting andthemodule cache allofwhichare accessible byany third partylibrary.
performancediagnosis diagnosingperformanceproblemsisa difficult task exacerbated by the heavy use of third party libraries.
theselibrariesoftenworkwelluntilthereisanunexpectedchange inthetypeorcharacteristicsoftheworkload .inmanycases theperformancebehavioroftheselibrariesisaffectedbyasingle unusualinput.
consider for example the minimatch library a regular expression basedfile matchingutilitysusceptibletolongdelaysdueto regular expressions that involve backtracking .
pathological inputs reaching minimatch even if benign can cause significant performance degradation deep in the dependency chain affecting also other parts of the program competing for the same resources .
developers use various techniques to understand suchproblems e.g.
collecting and replaying tracesagainstoffline versions of the system or using statistical profiling to identify hot code paths.
these techniques however require significant manual effort capturingtraces settinguptestbeds replayingtraces analyzingstatistics anddebuggingperformancearealltediousand time consuming tasks compounded by the difficulties of mapping the results to the right third partylibraries.
a library level profiling analysis would quickly detect any slowdownandappropriatelyattributeittothebottlenecked minimatch .
wrapping library interfaces with profiling logic can be of aid to constructing a model of the current workload.
such profiling could operate at a high resolution in time and space at every function call entering a library and on hundreds of libraries across anapplication butdoesnotneedtotrackdetailedoperationssuch as direct variable accesses.
each library wrapper can collect profiling statistics at its own boundary aggregating summaries into a globalstructure orderinglibraries byresourceconsumption.
type invariant discovery extracting type information at the moduleboundaryishelpfulin a varietyof scenarios.for example itcanbeusedtoidentifyprograminvariantstobepreservedduring code modifications or guide program learning and regeneration .dynamicallyextractedtypeinformationisparticularly relevantfordynamicallytypedlanguagesthathavenoexplicittype information inthe language.
consider forexample the grpcmoduleforserializinganddeserializingobjects .tousethismodule developersprovideaprotocol bufferspecificationdescribingthetypesofvaluesthatwill be serialized.
given a library e.g.
bignum crypto a developer has to first call it manually take note of the result s type and then fillintheprotobufspec.thisprocesshastoberepeatedwithevery change oftendue tolibraryupdatesor changesintheconsuming program s structure.
module leveldynamicanalysiscouldbeusedtodiscoversuch typeassertionsorinvariants.theanalysiswouldconsultthedefinitionofatypesystem capturingthetypeofvaluesattheboundaries oflibrariesbyobservingtheirargumentsduringtheexecutionof the program.
.
scope lyaexploits features of modern dynamic languageenvironments forexampledynamicmoduleloading runtimemetaprogramming facilities such as reflection or exposing object accesses as overloadablefunctions andruntimeresolutionofexternalreferences.the basic approach is therefore not appropriate for software written in traditionalcompiledlanguagessuchasc java ml orhaskell.itis also not appropriate for traditional scripting languages such as the unixshell dueto several challenges .
because lya operates at the granularity of modules it targets modern application development methodologies where applications comprise hundreds of modules with the modules typically reused from large open source repositories such as github or npm.
these methodologies deliver applications with i a module decompositioncoarseenoughforminimalruntimeoverhead ii amodule decompositionfineenoughtosupportmeaningfulanalysesthatoperateatthemodulegranularity lyaisthereforenotwellsuitedfor monolithic applicationswith fewor no modules and iii most of the code obtained from external and potentially untrusted sources motivatingtheneedfordynamicanalysesthatcanpinpointand helpsolve security orperformance issues .
ourproposedtechniquesworkwellwhentherecencyofinformation ideally online ismoreimportantthanthelevelofdetail.
they meet such recency needs through a combination of factors.
first lya provides the ability to perform the analysis online by operatingatacoarsergranularity byusingaproduction optimized runtime andbytogglingpartsoftheanalysisonandoff.second it allowsdeveloperstoleveragetheirexpertiseintheirlanguageof choice rather thanintroducing anewlanguageonly for analysis the program being analyzed and the program implementing the analysis can only be in the same language as the analysis transformations are applied dynamically over theprogram by the same runtime environment.
finally it deconstructs programs only at library boundaries a natural boundary for many problems caused orexacerbated bythird partylibraries.
module recontextualization lya starts by dynamically modifying the functionality of the modulesystemthatisresponsibleforimportingandloadingmodules instead of simply locating and loading a modules from the file system themodulesystemyieldscontroltolya whichappliesaseries of transformations to modules with the goal of interposing at their boundaries.westartwithanoverviewoflya .
highlighting 1204esec fse august 23 28 athens greece nikos vasilakis grigoris ntousakis veitheller andmartinc.rinard severalkeychallenges followedbyadetaileddescriptionofeach step 3.2 3. .
.
overview lya operates by decomposing the program at the boundaries of modules applying transformations that insert analysis specific machinery and then carefully reassembling individual components to maintain the originalsemantics decomposition lyastartsbyrecursivelydecomposingaprogram into its dependencies.
this is achieved by rewiring the language s importfunction to go through lya resulting in lya walkingtheprogram srecursivedependencystructureatruntime.
during this phase lya has to determine the granularity of the analysis e.g.
top level modules a specific module etc.
in orderto apply transformationsat thecorrect level and mapthe providedanalysishooks to the corresponding modules.
recontextualization lyathensetsuptheprovidedanalysis by transforming each module interface its surrounding environment and possibly the valuespassing through the module boundary.programmatictransformationswalkandwrapeach oneofthesevaluesbasedontheirtype.thisphaserequiressolvingseveralchallenges includingenumeratingallpointsofentry intoandexitoutofamodule andswappingalloriginalvalues externallyavailabletoamodulewithonesthatarewrappedwith interposition mechanisms.
reassembly finally lya reassembles individual modified modules back into the program s original structure.
a key challenge inthis phase is the treatment of the module cache .
which needstobeaugmentedtosupportmultiplewrapperspermodule eachcapturingapart ofthe overallanalysis.
example countingglobalaccesses asthethreeaforementionedanalyses .
aretoocomplextoshowhere wepresenta smaller analysis that counts all accesses to global variables from thesimple mathmodule letfs import fs letcount forevery.global.inlib simple math .analyze pre name path leto resolve name path count count ?count process.on exit fs.writefilesync access.json utf json.stringify count lya provided forevery generates a set ofmodule identifiers.the inlibfieldisamethodthattakesaregularexpressionmatching module identifiers.
if not empty preandposthooks are called before and after each access of the elements specified in the set.
finally resolveisamethod fortraversinganobjectgivenapath within that object.
upon program exit the results are written to disk allusing the expectednode apis.
to perform this analysis lya first interposes on the importcall todetectwhen simple mathisloaded.whenloading simple math lya applies a source to source program transformation that redefine global identifiers as module local ones and a dynamicmetaprogramming i.e.
runtimereflection transformationtotraverse global values and create a global indirection map specific to thesimple mathmodule.
for every global identifier the map holdsmodifiedglobalvaluesthatarewrappedsuchthatanyaccess to these values from within the simple mathmodule is visible by lya which upon access calls the corresponding prehook.
finally lyainterpretsthetransformed simple mathmoduleusing thebuilt incodeevaluationprimitive similartothevanillamodule system effectivelylinkingthemodule localidentifierlookupsto the map entries that hold the modified values corresponding to theseidentifiers.
the nextfewsubsections discuss the details.
.
decomposition whenalya augmentedprogramstarts itfirstloadstheanalysisfile providedbythedeveloper.thefilemayspecifyasubsetoflibraries whoseboundariesareofinterestorasubsetoflibrariesthatshould notbeanalyzed.amongotherthings lyaneedstodeterminethe library boundaries of interest and the granularity of analysis.
to dothis itextractsanapproximationofthedependencygraphby traversinglibraryfiles.usingthisgraph itprocessestheanalysis file to extract a mapping from library identifiers to analysis hooks.
italsochecksforconstructsnotassociatedwithlibraries forexample whether the analysis includes global variables library local constructs standardlibraries etc.lyathenproceedstodynamically replace the implementation of importand launch the program ratherthansimplylocatingandloadingalibrary callsto import nowyieldto lya.
for every invocation of importlya checks the cache .
to determine i ifthelibraryhasalreadybeenloaded and ii whether thelibraryhasbeenloadedwiththesameanalysishooks.ifbothare determinedtrue lyaretrievesthecachedversionofthelibraryand returnsthetransformed exported value.ifthelibrary wasloaded witha differentanalysis say because there are differentanalyses applied to different parts of a dependency tree lya constructs the appropriate analysis and applies a transformation pass on a cached copy of the unmodified library .
.
otherwise lya first invokes the built inlibrary loaderto locate the library.
the process of loading new libraries includes i a phase of reading the necessary source files and ii a phase of interpreting them interspersedbyapplicationsoftransformations .
.readingfiles returns a string representation of the code interpretation uses the language s runtime evaluation primitives to convert thecode into an in memory object.
some analysesmay themselves makeuse ofglobalvariables libraries andotheranalyzableconstructs.asthesewillbepartofthe same execution context lyamust note toavoidtransforming and wrapping these constructs as part of the analysis.
lya frameworks mayalsowanttoaddanalysis specifickeywordsnotprovidedby thelanguage.toachievethis lyawrapseachanalysishookwith afunctionwhosebodystartsbydefiningtheexpectedkeywords.
the precise techniques for achieving this will be made clear in the nextsection .
aftercoveringtransformations thekeypoint to remember is that analyses are initially represented as source strings similar to libraries.
1205efficient module level dynamic analysis fordynamic languageswithmodule recontextualization esec fse august 23 28 athens greece mod foo proc .id var x y ... import mod.foo main foo ... lya wrappers context proc mock.proc glob.y return values mod.foo n foo figure shadowing segments.
cross module variable name resolution left augmentedwithlya greenboxes whichinterjects non bypassablestepsresolvingtolya augmentedvalues topright implicitmoduleimports bottom right explicit import cf.
3. .
.
recontextualization for each analyzed library lya needs to place hooks all around its boundary not just its interface entry points figure .
this is achieved in three logical steps i transforming the library s context amappingfromnamestovaluesthatareavailablefrom outsidelibrary ii interpretingthelibrarywithinthiscontext so that all names bind and resolve tolya augmented values and iii transformingthelibrary s exportvalue i.e.
thelibraryinterface oncetheinterpretationiscomplete.beforediscussing whereeach transformation isapplied we show howthey are applied.
transformations lya s transformations boil down to a base transform wrapthattraversesandaugmentsvalueswithruntime analysismonitors.atahighlevel wraptakesavalue vandanalysis fragments 1 2 andreturnsanewvalue v thathaseveryone ofitsfields fwrapped every fisreplacedwithamethod f that callsfragment 1 callsf callsfragments 2 andreturnstheresult ofthe callto f. more specifically wrapcan be applied to any value in the language which can generally be a primitive a function or a compound value say a list of values or an object of key value pairs.
transformationswalkcompoundvaluesfromtheirroot processing componentvaluesbasedontheirtypes figure i functionvalues arewrappedbyclosuresthatcontainanalysis specifichooks ii objectandlistvalues are recursively transformed with their getter andsettermethodsreplacedsimilartofunctionvalues iii primitivevaluesareeithertransformeddirectlyorcopiedunmodified and wrapped with an access interposition mechanism.
to avoid cycles during the walk values are added to a map that is consulted at the beginningofeachrecursive call.
direct field accesses such as assignments require detection uponaccess.toachievethis lyawrapsfieldswithaninterposition mechanism this mechanismessentiallytreatsdirect fieldaccesses asfunctioncalls see 4forimplementationdetails .extendinga transformed object with a value will start withthe value stransformation.
for example if a field in a transformed object is assigned a new value that value has to be transformed before it is attached to the object.
lyaallowstogglinganalyseson off changinganalyses orchaining multiple analyses during the execution of the program.
to achieve this it maintains a handle to the root of both the unprocessed and the newly processed values for further processing the wrap e value analysis value match e with s v vs s wrap v wrap vs ...args .f ...args .
1 f 2 args interpose 3 e end figure2 basetransform.
thealgorithm simplified ispresented infunctionalstyletosimplifyvariablebinding types object list function andprimitive usedforpatternmatching areshownin lightturquoise cf.
3. .
the functions 1 2 and 3stand for the locations ofanalysishooks.
unprocessed value is used to create objects at runtime that run differentanalyses thenewvalueisusedtorevokeorchainanalyses together.
contexttransformation to be able to track an analysis at the library boundary lya needs to provide each library with values thatareaugmentedwithinterpositionwrappers anddothisforall ofthenamestowhichalibraryhasaccess.thisincludesglobaland pseudo global3names providedbythe languageandits runtime.
toachievethis lyafirstneedstoprepareatransformedcopyof thelibrary scontext amapfromvariablenamesthatare expected tobe inscopetotheirvalues.lyacreatesanauxiliaryhashtable mappingnamestotransformedvalues.namescorrespondtoany namethat bythelanguagedefinition isaccessiblebythelibrary andresolvestoavalueoutsidethatlibrary suchasglobals builtins module locals etc.transformedvaluesarecreatedbyapplying wrapto valuesinthe context addingthe providedanalysishooks.
care must be taken with library local variables.
these are accessiblefromanywherewithinthescopeofalibrary similartoglobal variables butresolvetoadifferentvalueforeachlibrary.examples includethelibrary sabsolutefilenameas name itsexported values andwhetherthelibraryisinvokedastheapplication s main library .
.attemptingtoaccesslibrary localvariablesdirectly from within lya s scope will fail subtly as they will end up resolving to library local values of lya itself and specifically the module within lya that is applying the transformation.
lya solves this problem by leaving the value empty and deferring binding for laterfrom within the scope of the library see below .
contextbinding tolinkthelibrarywiththenewlytransformed version of its context lya wraps the library still an uninterpreted stringofsourcecode withaclosure.theclosure sbodystartswith aprologue ofthe form local print ctx.print local error ctx.error ...more entries... thesestatementsshadowglobalvariablenamesbyredefiningthem asfunction localones.theclosureacceptsanargument ctxthat willholdthecustomizedcontext seeabove assigningitsentries totheirrespectivevariablenames.theprologueexecutesbeforeeverythingelseinthelibrary.thistechniqueleverageslexicalscoping 3forexample nodeintroducesobjectsthatarenotpartoftheecmascriptspecification into the global scope such as process andconsole similarly lua s luvit introduces its own globals such as p andexports.
1206esec fse august 23 28 athens greece nikos vasilakis grigoris ntousakis veitheller andmartinc.rinard toinjectanon bypassablestepinthevariablenameresolutionprocess insteadofresolvingtovariablesinthecontext resolutionwill first hit library local valuesaugmentedwithanalysismonitors.
late bound library localvariables suchastheabsolutefilename mentioned during context creation are the result of applying wrap over variable names in the current scope these names are now bound to the correctlibrary local values.
libraryinterfacetransformation returningthelibrary svalue to its consumer amounts to interpreting the library linking it with thecustomcontext andapplyingafinaltransformationtoitsreturn value.
the goal of the final transformation is to track activity at theboundary.4thisfinaltransformationisappliedforeverynew consumer of the library returning a fresh analysis wrapper.
this is due to the need for distinguishing between different boundaries of the same library.
the treatment of this feature during reassembly is explained in the nextsection .
.
.
reassembly tosuccessfullyreassembletheapplication lyaneedstoensurethat cross