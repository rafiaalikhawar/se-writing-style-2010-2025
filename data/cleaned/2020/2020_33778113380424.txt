gap between theory and practice an empirical study of security patches in solidity sungjae hwang kaist daejeon south korea sjhwang87 kaist.ac.krsukyoung ryu kaist daejeon south korea sryu.cs kaist.ac.kr abstract ethereum oneofthemostpopularblockchainplatforms providesfinancialtransactionslikepaymentsandauctionsthroughsmartcontracts.
due to the immense interest in smart contracts in academia the research community of smart contract security has made a significant improvement recently.
researchers have reported varioussecurityvulnerabilitiesinsmartcontracts anddevelopedstaticanalysistoolsandverificationframeworkstodetectthem.however itisunclearwhethersuchgreateffortsfromacademiahasindeed enhanced the security of smart contracts in reality.
to understand thesecurity levelof smartcontracts in thewild we empirically studied real world ethereum smart contracts written in solidity the most popular programming language used by ethereum smart contract developers.
we first examined how manywell knownvulnerabilitiesthesoliditycompilerhaspatched and how frequently the solidity team publishes compiler releases.
unfortunately weobservedthatmanyknownvulnerabilitiesare not yet patched and some patches are not even sufficient to avoid their target vulnerabilities.
subsequently we investigated whether smartcontractdevelopersusethemostrecentcompilerwithvulnerabilitiespatched.wereportedthatdevelopersofmorethan98 of real world solidity contracts still use older compilers without vulnerabilitypatches andmorethan25 ofthecontractsarepotentiallyvulnerableduetothemissingsecuritypatches.tounderstand actual impacts of the missing patches we manually investigatedpotentially vulnerable contracts that are detected by our static analyzerandidentifiedcommonmistakesbysoliditydevelopers which may cause serious security issues such as financial loss.
we detected hundreds of vulnerable contracts and about one fourthof the vulnerable contracts are used by thousands of people.
we recommend the solidity team to make patches that resolve known vulnerabilitiescorrectly anddeveloperstousethelatestsolidity compiler to avoid missing security patches.
keywords empirical study smart contracts solidity security patches permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acmmustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
icse may seoul republic of korea association for computing machinery.
acm isbn ... .
reference format sungjaehwangandsukyoungryu.
.gapbetweentheoryandpractice anempiricalstudyofsecuritypatchesinsolidity.in 42ndinternational conferenceonsoftwareengineering icse may23 seoul republicofkorea.
acm newyork ny usa 12pages.
.
introduction blockchaintechnologieshavebecomeincreasinglypopularandare now considered as one of the key enablers of secure distributed computations providing a wide spectrum of applications withsmartcontracts.oneofthemostpopularblockchainplatformsis ethereum whichimplementsadecentralizedturing complete virtual machine called the ethereum virtual machine evm and it can support not only cryptocurrency but also other applications like games and financial services .
the key to support such a variety of applications in the blockchain is smart contracts.
smartcontractsareprogramsthatprovidesecurity criticalapplications like financial transactions but they are vulnerable to varioussecurityattacks .amonglanguagesthatarecompiled to ethereum bytecode embedded in transactions as bytecode and run on evm solidity is the most widely supported and maintained one so far.
however because the semantics of solidity is notformallynorcompletelyspecified severesecurityissueswith smart contracts have been reported.
for example vulnerabilities of the decentralized autonomous organization dao resulted in 150millionbeingstolen andparity s 280methereumwallets had to be frozen.
toalleviatetheproblemofinsecuresmartcontracts researchers havestudied varioussecurityvulnerabilities and developedstatic analysis tools and verification frameworks to detect them.
static analysistechniquestodetectsuchvulnerabilitiesformallyverify a subset of solidity analyzes ethereum bytecode using symbolic execution or analyzes solidity contracts by compiling them to llvm bitcode .
researchers also have attempted to formalize the semantics of various subsets of solidity .sucheffortsfromacademiamadeasignificant improvement in the theory of smart contract security.
however it is unknown whether such efforts from academia improved the security of smart contracts in reality.
to understand the security level of smart contracts in the wild we empirically studied real world ethereum smart contracts in case of the solidity programming language.
to the best of our knowledge no previous research answers the following questions.
does the solidity languagebecomemoresecurebyfixingknownvulnerabilities.does thesoliditycompilergetsecuritypatchesfortheknownvulnerabil ities?ifso wouldsoliditydeveloperstakeadvantageoftherepaired ieee acm 42nd international conference on software engineering icse soliditycompilers?arethecompilerpatcheseffectiveenoughto preventtheirtargetvulnerabilities?inaddition dodevelopersactually make bugs and errors due to such vulnerabilities?
in this paper we answer the above research questions and reportourempiricalfindingsaboutthegapbetweentheimportant advances in the theory of smart contract security and the developmentandusesinreal worldcontracts.aftercollecting41known vulnerabilitiesfromdiversesourcesincludingacademicpapersand industrial reports we examined all the solidity patches from the official release notes and found that seven out of known vulnerabilities are patched and one patch is under development by thesoliditycompilerteam.thus weobservedthatmanyknown vulnerabilities are not yet patched and even some patches applied topreventspecificvulnerabilitiesarenotsufficienttoremovethem.
giventhatthesolidityteamhaspatchedatleastsevenknown vulnerabilities would solidity developers utilize the solidity compilerfixes?tounderstandwhethersoliditydevelopersusesecuritypatchesintheircontractdevelopment weinvestigatedwhetherthe developersuse themost recentcompilerversion withvulnerabilitiespatched.unfortunately wefoundoutthatdevelopersof98.
ofsoliditycontractsinthewildusedoldercompilersthantheupto dateversionatthetimeofdevelopingthecontracts.moreover among contracts that are currently available from etherscan contracts are created by the compilers without all the security patches available.
to see the effects of not using the mostrecentcompilerversions webuiltalight weightstaticanalyzerthatdetectscontractsexposedtounpatchedvulnerabilities.
theanalyzerreportedthat13 943contracts .
arepotentially vulnerable due to the missing security patches.
inordertounderstandwhetherthepotentiallyvulnerablecontracts reported by our tool actually contain security issues we manuallyinvestigatedthereportedcontractsthathadreceivedandsentmorethan10transactions.foreachvulnerability weinspected howthesoliditycompilerpatchedthevulnerability whetherthe patch is sufficient what mistakes developers commonly make due tothevulnerability andwhatkindsofsecurityissuestheycancause.
asfarasweknow previousresearchdidnotconductin depthinvestigation on most of the vulnerabilities discussed in this paper such asstorage variable shadowing confusion andinheritance order confusion.ourinvestigationshowedthathundredsofvulnerable contracts are doubtlessly exploitable.
wereportedeightvulnerablecontractsthatrepresentallthevulnerabilities discussed in this paper and received eight cve ids for them.inaddition ourwork alsorevealedinse curecodingpractices from solidity developers that have not been previously studied.
we recommend the solidity team to make security patches that resolve known vulnerabilities correctly and developers to use the latest solidity compiler to avoid missing security patches.
the tool usedforourempiricalstudyispubliclyavailable1.intheremainder of this paper we discuss the findings in detail.
background beforediscussingthefindings thissectionexplainsbasicfeaturesof solidity to understand the paper.
solidity basics solidity isahigh levelprogramminglanguagedevelopedby ethereum foundation.
while ethereum transactions embed smart contracts inthe formof evmbytecode programmersoften write contracts in high level languages which is less error prone and moreproductivethaninbytecode.solidityisthemostsupported and widely used language that compiles to evm bytecode.
asmartcontractsourceunitisasequenceofcontractdefinitions.
acontractdefinitiondefinesacontract alibrary oraninterface.a contract is like a class in object oriented languages that support multiple inheritances.
contracts can specify their fields and methods.acontract residesataspecific addressontheethereum blockchain.
the evm is the runtime environment for solidity contracts which is sandboxed and isolated.
solidity uses five memory areas to save data of contracts storage stack memory logs and calldata.
among them storage is the only persistent memory area and the other four are temporal ones.
.
storage everycontracthasapersistentkey valuestore whichmaps256 bit words to bit words called storage.
each key refers to a slot and each slot can store bit data thus storage is a collection of slots.
a contract can neither read nor write to any other storage than its own.
the storage layout is defined and fixed at the creation time of a contract and it cannot be altered at run time statically sized variables everything except mapping anddynamically sizedarraytypes arelaidoutcontiguouslyinstoragestartingfromposition0.multiple itemsthatneedlessthan32bytesarepackedintoa singlestorageslotifpossible accordingtothefollowing rules structs and array data always start a new slot and occupy whole slots thus eachelementofafixed size uintarraytakestheentiresingle bit slot in storage.
because the sizes of mapping types and dynamic array types are unknown at compile time such types use a keccak hash function to calculate the starting point of the value or the array data.
solidity security patches first we explored the question of whether the solidity programming languagebecomes moresecure byfixing knownvulnerabilities.
we examined the question in two respects how many known vulnerabilities are patched by the solidity compiler and how often the compiler gets released.
.
does solidity patch known vulnerabilities?
we first collected known vulnerabilities from various sources includinglistsfromindustryandathoroughcollectionfromacademic papers as follows themostrecentversionoftheofficialsoliditydocumentation as of march swcregistry smartcontractweaknessclassificationand test cases consensys ethereum smart contract best practices 543table known vulnerabilities patched by the solidity compiler and the number of contracts that are vulnerable to them idknown vulnerabilitypatched no.
of vul.
no.
of vul.
contracts total no.
of tx of version contracts with tx vul.
contracts with tx spv misuse of constructors .
.
spv functions without visibility .
.
spv storage variable shadowing confusion planned spv type casting to arbitrary contracts .
.
and .
.
spv inheritance order confusion .
.
and .
.
spv uninitialized storage pointers .
.
spv typo of the operator .
.
spv use of deprecated functions .
.
total nccgroup decentralizedapplicationsecurityproject academic papers from major conferences and arxiv that contain smart contract in their titles and abstracts the swc registry is an implementation of the weakness classification scheme proposed in eip its purpose is to share securityissuesinsmartcontracts.theconsensysgroupassembled ethereumsmartcontractbestpractices andthenccgroupruns the decentralized application security project which is a collaborative effort discover smart contract vulnerabilities within the security community.
we inspected all the sources and collected all thereportedvulnerabilitiesfromthem whichamountsto41.the list of collected known vulnerabilities is publicly available2.
for each known vulnerability we investigated whether any versionofthesoliditycompilerpatchedthevulnerability.wereviewed the official solidity release notes and double checked them by implementing a contract with the vulnerability compiling it with a patched and an unpatched versions of the solidity compiler and comparing their results.
we found that seven out of known vulnerabilitiesarepatchedandoneisplannedtobepatchedassummarized in table .
we named each vulnerability in the table with the spv prefix which stands for smart contract patched vulnerability.
the second column describes the vulnerability and the third column shows which solidity compiler version patched the vulnerability.notethatapatchforspv 03isunderdevelopment .we discuss the remaining columns of the table in section .
because all the existing solidity patches for known vulnerabilities are available from solidity .
.
we strongly recommend developers to use at least version .
.
of the solidity compiler.
.
how often does solidity get updated?
inordertounderstandwhetherthesolidityteamactivelyresponds to demands from developers such as feature requests and security patches weinspectedtheofficialsolidityreleasenotes.fromsolidity0.
.2releasedonaugust21 50compilerreleaseshave madetillversion0.
.7releasedonmarch26 .themaximum numberofdaysbetweenconsecutivereleasesare121 theminimum one andtheaveragedays27.basedonthedata weregardthatthe solidity compileris activelyevolving and gettingsecurity patches as long as they are available.
of contracts .
.
.
figure available days for developers to make their con tracts conform to newly released compiler versions uses of solidity security patches now that the solidity compiler patched seven out of known vulnerabilities dodevelopersusethecompilerwithpatches?we studiedthequestioninthreeregards howmanycontractsare compiled by older versions of the compilers than the up to date versions at the time of developing them how many contracts are exposed to already patched vulnerabilities due to the use of old compilers and how many contracts are statically reported as vulnerable due to the use of old compilers.
toanswerthesequestions wedevelopedacrawlertocollectsoliditysmartcontractsfrometherscan awell knownethereum blockchainexplorer.foreachcontract wecollecteditsname sourcecode compiledversion deploymentdate etherbalance numberof transactions andthe last transactiondate.
we crawledthem from december to march and collected verified contracts.
among contracts we excluded destructed contracts which are unavailable for use because their bytecode are removed from the blockchain .
for the remaining live contracts weusedtheirtotalnumbersoftransactionsandthedates of the last transactions to identify the most actively used ones.
.
how many contracts are compiled by old compilers?
to get the number of contracts that are compiled by older versions of compilers we checked the deployed dates of contracts and their no.
of new compilersno.
of contracts 8000average .
figure2 numberofcompilerversionsmissedbydevelopers table2 numberofcontractsthatarenotexposedtoknown vulnerabilities due to the use of old compilers compiled version no.
of contracts patched vulnerabilities .
.
.
spv to spv except spv .
.
v .
.
.
spv partially .
.
.
none total used compiler versions.
when the used compiler version of a contractisnotthelatestcompilerversionatthetimeofitsdeployment weconfirmedthatthecontractwascompiledbyanoldcompiler.
among55 046livecontracts 373contractswerecompiledbyold compilers whichamountsto47.
.theresultindicatesthatmany developers do not use the latest version of the solidity compiler.
to understand why the developers did not use the latest version of the solidity compiler we further investigated how many days arepassedbetweenthereleasedatesofthenewestcompilersand thecontractdeploymentdates.theyshowthenumbersofavailable days for developers to make their contracts applicable to newly released versions of the compiler before deployment.
figure illustratesthat33.
ofthecontractshadmorethan30days .
hadmorethan60days and18.
hadmorethan90daystouse newly released compilers before deploying their contracts.
the resultshowsthatthedevelopersofaboutonethirdofthecontracts had more than days to make their contracts comply to the latest compiler version.
in addition for the contracts compiled by old compilers we also checked how many compiler versions were missed between the newest ones and the used ones by developers.
figure shows that most developers used the previous versions of the latest ones and four compiler versions were missed on average.
.
how many contracts are exposed to already patched vulnerabilities?
giventhat47.
ofthecontractsarecompiledbyoldcompilers how many contracts are exposed to already patched vulnerabilities due to the use of old compilers?
table summarizes the result3.
more than a half of the live contracts .
were compiled by compilerspriortov0.
.
and98.
werecompiledbytheones 3we considered v0.
.
as v0.
.
because it was officially released after v0.
.
.below v0.
.
.
therefore more than of the live contracts are exposed to the vulnerabilities that are already patched in v0.
.
.
.
how many contracts are detected as vulnerable?
among98 ofthelivecontractsthatareopentothevulnerabilities how many of them are actually vulnerable?
to understand the impactsofmissingsoliditypatchesinpractice wedevelopedasimplestaticanalysistoolthatdetectspotentiallyvulnerablecontractsdue to the lack of solidity patches.
we describe how the tool detects vulnerable contracts for each vulnerability in the next section.
table presents the results of our static analyzer.
out of contracts itreportedthat13 943contractsmaybevulnerableduetothemissingpatches whichcouldhavebee npreventedifthepatches wereapplied.thecontractsreportedasvulnerablearepopularones asthenumbersoftheirtransactions denotedastx show.evensuchpopularcontractswithmanytransactionsmayhavevulnerabilities that were already patched in the current compiler.
vulnerable contracts in practice toverifyactualimpactsofmissingsoliditypatchesinreality we manuallyinvestigatedthepotentiallyvulnerablecontractsreported byourtool.toanalyzeonlymeaningfulcontracts wechosecontracts with at least transactions.
for each vulnerability whenover contracts have more than or equal to transactions we selected top contracts in the order of the number of total transactions.
inthissection weexplaineachvulnerability howthesolidity compiler patches it whether the patch is sufficient to avoid the vulnerability howourtooldetectspossiblyvulnerablecontracts what kinds of errors and mistakes developers actually make due to the vulnerability and how the developers mistakes can causeserious security problems.
code examples in this section are all from real world contracts.
.
misuse of constructors solidity initially provide two ways to define contract constructors but one has been deprecated from v0.
.
because it often allows developers to make vulnerable contracts.
the original two ways tomake a function constructor are using the constructor keyword and2 usingthesamenameasitscontract sname.thesecondway is vulnerable because if a developer accidentally uses a different nameforafunctionintendedtobeaconstructorfromitscontract s name thefunctionbecomesanordinaryfunction whichmaybe accessible by external users.
since constructors usually perform criticaloperationslikeinitializationofsensitivedatasuchascontract owners if they are open to external attackers it may cause security issues.
thus the solidity compiler from v0.
.
forbids the secondwaybyrejectingfunctionsthathavethesamenamewith theircontracts.unfortunately thispatchisnotsufficienttoavoid thevulnerability becauseprogrammerscanstillmakemistakeslike usingdifferentnamesforafunctionintendedtobeaconstructor and its contract.
as we show in this section solidity developersoften make such mistakes in real world smart contracts and we received four cve ids for them as we discuss below.
545our tool reports potentially vulnerable contracts due to misuse of constructor names by using a well known string similarity algorithm levenshtein distance forfunction namesandcontract names.
because the algorithm gives the same weight for insertion and delete of letters and case substitution we modified the algorithm using the weight rules proposed by wagner and fischer togivedifferentweightsforeachoperator.inaddition weadded a swap operator to detect similar strings that are different only in the order of two letters.
the tool also analyzes comments if a comment just above a function definition contains the constructor keywordignoringcases andifthefunction snameisdifferentfrom its contract s name the tool reports it as a vulnerable constructor.
wemanuallycheckedthepossiblyvulnerablecontractsreported by the tool and confirmed that contracts are vulnerable due to themisuse ofconstructorsas table1shows.we furthermanually investigated109contractswithatleast10transactions andwecon firmed that all of them are indeed vulnerable constructor functions in the sense that either their comments say that they are meant to beconstructorsorthefunctionbodiesperformonlyinitialization.
wefurtheridentified exploitable contractsthatarecallablebyexternal users and let them change sensitive data such as their contract owners.we found out that contracts which amounts to .
are exploitable due to vulnerable constructors.
thesecontracts are popular ones because the total number of theirtransactions is and contracts have more than 100token holders.
weanalyzed55exploitablecontractsandclassifiedtheirmain causes as the following three types of developer mistakes incorrect reuse of standard contracts we observed that developersincorrectlyreusestandardcontracts constructorsprovided by ethereum and other renowned blockchain companies.
for example weencountereddevelopersincorrectlyreusestandardcon tractssuchas tokenerc20 byethereumand simpletoken by openzeppelin .when developersreusedit theyoftencopied the contract and changed only the contract nameleaving the constructornameunchanged whichmakesavulnerableconstructor.
wefoundthat18differentcontractshadthesameconstructorof tokenerc20 and we received one cve id for them4.
typos in constructor names we observed that developers domaketyposinconstructornamesduetowrongcapitalization swapping characters and misspelling.
for example we encoun tered contracts with simple typos where contract names and constructornamesdiffer onlyinoneletter onenumber theorder of two characters or capitalization.
they are popular contracts in that the total number of their transactions were and we received three cve ids for them5.
usageof publicfunctions wefoundthatdevelopersuse public functionsasconstructors.ifa publicfunctionisusedasaconstructor its contract should guarantee that only authorized users can call the constructor.
however we found that ten contracts had no authentication which allows external attackers to call them and alter their sensitive data and another case checked only its initialization flag which may lead to the race condition attack a s beableto callthefunction beforethe ownerofthe contract.
in addition to the three patterns from exploitable contracts we also observed another frequent pattern from non exploitable contracts splitting initialization functions in multiple functions.
consider the following minimized code from a real world contract 1contract bookerc20ethv1p1 constructor.
creator needs to call init to finish setup.
function bookerc20ethv1p1 ... function init ... public ... where initialization statements are distributed in bookerc20ethv1p1 and init.
as the comment says the contract owner should manuallycallallofthenecessaryfunctionstoproperlyfinishtheinitialization process.
we analyzed transactions of these contracts to see whether the owners of the contracts called all the necessaryfunctionsproperlyrightaftertheircontractdeployment.we foundoutthatsixoutof24contractsfailedtocallallthenecessary functions which may miss initialization of important data such astokenaddressesandtheinitialtokenbalancesoftheirowners.
even though they may cause such problems we classified them as non exploitablebecausetheyallproperlyauthenticatedfunction callers.
finally we report three insecure cases due to vulnerable constructorsobservedfromexploitablecontracts.first 19constructors initialized their owners to callers.
consider the following example 1contract owned address public owner function owned public o w n e r m s g .
s e n d e r where the ownedfunction was intended to be a constructor but it isapublicfunctionduetothetypoinitsname.anyattackerthat calls ownedbecomes the owner of the contract and the attacker can stealing all the ether reserved in the contract obtain tokens without paying a fee and more.
second we found vulnerable constructors that transfer their tokens to their callers.
for example 1contract bosscoin function tokenerc20 ... public totalsupply give the creator all initial tokens balanceof totalsupply any attacker can get the total tokens of bosscoin by simply calling tokenerc20 .
third we found that vulnerable constructors initialize flags for crowdsale and ico status.
by calling such constructors attackers can change the flag of a finished ico and buy its tokens.
.
functions without visibility solidityusedtoallowfunctiondeclarationstoomittheirvisibilities but from v0.
.
it throws a compilation error if a function visibility isnotspecified.insolidity afunctionmaydeclareitsvisibilityas external internal public orprivate.functionswiththe publicor external visibilitycanbecalledbyexternalusers whereas private and internal functionsarehiddenfromthem.hence ifattackers attempttoattackcontracts theonlypossibleentrypointsare public and external functions.
however before v0.
.
when a function 546declarationdoesnotspecifyitsvisibility itwas publicbydefault whichiscriticallyvulnerable.thus solidityenforcesfunctionsto declare their visibilities.
note that android had a similar history.
sincethevisibilityofanandroidcontentproviderusedtobe public bydefault itcausedmanysecurityissues andgoogleofficially changedthedefaultvisibilitytofalse whichcorrespondsto private.
our tool reports functions as potentially vulnerable due to functionvisibilitywhentheysatisfythefollowingthreeconditions no visibilityspecified nomodifierfunctioncheckingpre conditions and update of a critical storage variable a storage variable that is used by modifier functions because modifiers often check the validity of security sensitive data stored in storage variables.
table shows that the tool detected contracts as vulnerable.
we chose contracts in the decreasing order of the number of total transactions and manually investigated them to see whether they are indeed exploitable.
we considered contracts as exploitableif1 theirfunctionsreportedasvulnerabledonotcheck authorization for updating critical storage variables which allows any attacker to update them and updates on critical storage variablesdisablethevaliditycheckingofthestoragevariablesin modifier functions.
thus we may have missed some exploitable contractsthatdonotmeettheserequirementsbutwedonotfind falsepositives.
outof200contracts weconfirmedthat63contracts have vulnerable functions which amounts to .
.they are popular ones whose total number of transactions is1 and48contractshavemorethan100tokenholders.
among them we reported one exploitable contract and received one cve id for it6.
weanalyzed63exploitablecontractsandobservedthreetypes ofdevelopermistakes onlyinitializationchecking nochecking and misuse of constructors again!
we found that most vulnerable functions checked only the initialization flags before updating critical storage variables which as we discussed in the previoussection cancausetheraceconditionattack.wealsofound that vulnerable functions often missed any authentication logic which allows anyone to call such functions to change critical storagevariables.thethirdpatterniswronglynamedfunctionsthat were intended to be constructors.
consider the following example from a real world contract 1contract token function ownable owner msg.sender function transfer address to ... ... ... modifier onlyowner require msg.sender owner ... whichshowsthatitsdevelopermergedastandardexamplecontract token and an ownablecontract into one contract but failed to rename the constructor of ownable which became a general publicfunction.now anyattackercancallthe ownablefunctionto change the owner of the contract.
our investigation revealed that attackers can change the following critical storage variables important addresses such as the owners of the contracts crowdsale contract addresses proxy token addresses proxy asset addresses and wallet addresses the start date of pre invest bychangingtheabovecriticalstoragevariable attackerscan performvariouscriticalattacks.forexample attackerscanstealallthe etherbalances reservedin acontractonce theychange theowner of the contract.
.
storage variable shadowing confusion insolidity whenaparentcontractandachildcontracthavestorage variables with the same name the storage variable in the parent is hiddenfromthechild.asaresult withthesamename functionsintheparent refer tothe variabledefined intheparent andfunctions inthechildrefertothevariabledefinedinthechild whichcould be confusing to developers.
the solidity team is currently working onapatchforthisvulnerabilityandaimstopublishitinthenext release .
our tool identifies contracts as potentially vulnerable due to storagevariableshadowingconfusionwhentheysatisfythefollowing three conditions parent and child contracts have storage variables with the same name one of the functions from the parent contract reads or writes the storage variable with the same namedefinedintheparenttoshowtheeffectsofshadowing and the visibility of the storage variable in the parent is publicor internal because only such storage variables are inherited.
wemanuallycheckedthepossiblyvulnerablecontractsreported by the tool and confirmed that contracts are vulnerable due to the storage variable shadowing confusion as table shows.
we manuallyinspected231contracts thathavemorethanorequalto transactions.
among contracts we found out that contractsareexploitable whichamountsto45.
.thetotalnumber of transactions for contracts is and 26contracts have more than token holders.
amongthem we reported two exploitable contracts and received two cve ids7.
weanalyzed106exploitablecontractsandobservedsixpatterns of developers mistakes.
initializationconflict thefirstpatternistoinitializeonlythe storagevariabledefinedinthechildwithoutinitializingthestorage variable defined in the parent which causes a problem when a function in the parent uses the uninitialized storage variable in the parent.
consider the following example 1contract standardtoken is erc20 safemath uint public totalsupply function burn uint256 value public returns bool success totalsupply safesub totalsupply value end of parent contract 7contract usdxcoin is own able standardtoken uint public totalsupply function usdxcoin public totalsupply function minttoken uint value... totalsupply safeadd totalsupply value boththeparent standardtoken contractandthechild usdxcoin contract have the storage variable named totalsupply but only the totalsupply variable in the child is initialized on line .
hence 547anintegerunderflowexceptionoccursifthe burnfunctioninthe parent on line is called.
functionconflict thesecondpatterndenotessuchcaseswhen a developer splits functionalities into both parent and child contracts.
let us consider the above example again.
addition to the totalsupply variable is done only in the child contract by the minttoken function on line and subtraction from totalsupply isdoneonlyintheparentcontractbythe burnfunctiononline3.
thus burnintheparentupdates totalsupply definedintheparent whereas minttoken in the child updates totalsupply defined in the child which may lead to unexpected behaviors due to inconsistent use of totalsupply .
write conflict the third pattern is when a developer updates onlyoneofthestoragevariablesasshowninthefollowingexample 1contract ownable address public owner function ownable owner msg.sender function transferownership address newowner onlyowner public owner newowner 7contract daditoken is standardtoken ownable address public owner function daditoken ... o wner msg.sender theparent ownableandthechild daditoken bothhavethestorage variable named owner.
initially both variables have the same value on lines and .
however once the transferownership function in the parent gets called it updates only the ownervariable defined in the parent leaving ownerdefined in the child intact.
missing override the fourth pattern is when a child contract overridesonlysomeofitsparent sfunctionsthatusethestorage variable defined in both parent and child.
then the overridden functions in the child update the storage variable defined in the child whereas non overridden functions update the one defined in the parent.
supercallconflict thispatternrepresentscaseswhenachild contract overrides all of itsparent s functions that use the storage variabledefinedinbothparentandchild andoneoftheoverriding functions in the child calls an overridden function in the parent internally.becausethecalledfunctionintheparentusesthestorage variable in the parent such super calls could be confusing.
override misunderstanding the last pattern is due to the confusionbetweenoverridingandoverloading.considerthefollowing example 1contract crowdsale uint256 public rate function transfer address beneficiary uint256 weiamount internal uint256 tokens weiamount.mul rate 6contract cappedcrowdsale is crowdsale ... 7contract ethealnormalsale is cappedcrowdsale ... uint256 public rate dev overriding crowdsale transfertoken.
function transfer address beneficiary uint256 weiamount uint256 time ... internal while the comment on line claims that transfer on lines overrides the function in the parent on lines because the former has more than two parameters and the latter has only twoparameters theyareoverloadedratherthanoverridden.asaresult a different rateis used depending on which function is called.
finally we report the following list of eight security issues that we found from real world contracts confusion of the total amount of tokens the totalsupply storagevariableholdsthetotalamountofavailabletokens.duetoshadowingonsuchavariable thecalculatedamountofavailable tokens was wrong.
confusion of user balances storage variables like balances and balanceof holdtokenbalancesoftheirusers.duetoshadowing on them the calculated amount of user balances was wrong.
confusion of owners the ownerstorage variable stores the addressofthecontractowner.becauseofshadowingon owner only one of the storage variables from a parent contract and a child contract got updated which led to confusion on owners.
referencesofnull contracts mostcrowdsalecontractshave thetokenstoragevariable whichholdstheaddressoftheerc20 tokencontractimplementation.however becausethisvariable wasshadowed thecorrectaddressofthetokenwasnotavailable.
confusionofthetotalamountofcommissionfees because storagevariableslike ratewereshadowed thecalculatedamount ofcommissionfeeswasdifferentdependingonwhetheraparent function or a child function was called.
confusionofthesaleduration storagevariablessuchas cap and goaldecidethedurationoftokensales.becausesuchvariables were shadowed between parent and child contracts the functions in the parent and the child had different duration.
confusion of the mint duration since mintingfinished was shadowedbetweenparentandchildcontracts thefunctionsin the parent and the child had different minting duration.
transferofinvalidtokens the allowedstoragevariableholds theallowedtokenamounttobetransferred.sincethisvariable was shadowed the transferred amount was different depending on whether a function from a parent or a child was called.
notethatweencounteredapossiblymaliciouscontractthatuses variable shadowing confusion.
consider the following contract 1contract standardtoken is token uint256 public totalfee function transfer address to ... ... totalfee safeadd totalfee fee ... ... 6contract hawalatoken is standardtoken uint256 public totalfee function disperserewards address to uint256 amount ... if totalfee totalfee amount totalfee safesub totalfee amount balances safeadd balances amount ... ... becausebothparentandchildcontractsdefinethestoragevariable totalfee theparentaddsfeestoits totalfee online4 andthechild subtractssomeamountsfromits totalfee online11aswediscussed for thefunction conflict pattern.
this behavior is not only unintuitive but possibly malicious.
while the disperserewards function inhawalatoken distributes rewards only if totalfee is greater than because totalfee indisperserewards is always users cannot receive rewards.
this behavior from a real world contract could be due to a developer s mistake or an intentional malice but it clearly 548shows that attackers can utilize the storage variable shadowing vulnerability to implement malware that look benign.
.
type casting to arbitrary contracts solidityallowsexplicitandimplicittypeconversion andthe old solidity compilers allowed developers to perform bad casting down casting conversionofaparentcontracttypetoachild contract type unrelated casting conversionofacontracttypetoanother contracttypethatisnotitsparentnoritschildcontracttype non contractcasting conversionofacontracttypetoanoncontract type problemswithbad castingaretwofold callingafunctionfroma wronglyconvertedtypemaycallanunintendedfunction orsimply performnooperationwithoutthrowinganyerror dependingon the existence of functions with the same name.
to alleviate the problems the solidity compiler from v0.
.
throws an exceptionifan addressassociated withnocode iscalled and fromv0.
.
it disallows down casting and unrelated casting.
despite these compiler patches solidity developers can still make bad casting by converting a contract type to addressfirst .
our tool reports bad casting by a simple type analysis using def use and class hierarchy information.
we manually checked the possiblyvulnerablecontractsreportedbythetoolandconfirmed that864contractshave1 803bad castingwithoutusingthe address type as table shows.
we chose contracts in the order ofthe number of total transactions the total number of their trans actions is .
we manually investigated them to identifyexploitable contracts that have type conversions causing unexpectedbehaviorslikecallingabsentfunctions.
ourinvestigation showed that out of contracts are exploitable whichamounts to .
.
the exploitable contracts consist of33 down casting unrelated casting and eight both down castingandunrelated castingones.theexploitablecontractsarepopular becausethetotalnumberoftheirtransactionsis730 and contracts have more than token holders.
among them we reported one exploitable contract with downcasting and received one cve id for it8.
whileinvestigatingthem weobservedtwointerestingpoints.
first among live contracts we found that only three contracts validate whether type conversion results are correct.
consider one of the example contract with validation 1contract auctionstorage is ... bool public isauctionstorage true ... 4contract saleclockauction is clockauction function saleclockauction address addr ... require auctionstorage addr .
isauctionstorage ... ... the auctionstorage contract declares a publicstorage variable called isauctionstorage on line .
because solidity generates a getterfunctionforevery publicstoragevariable itgeneratesagetter function for isauctionstorage as well.
the saleclockauction function on line takes a parameter named addrof type address.
addris converted to auctionstorage on line and the conversion result is immediately verified by calling the getter function ofisauctionstorage .
second even with the solidity compiler patches to avoid badcasting developers still can perform bad casting using the address type.
out of live contracts contracts use type conversion among contracts only 864contracts perform type conversionwithoutusing address andtheremaining20 675contracts which amounts to .
use casting with address.
our investigation implies that instead of validating type conversion resultsinsourcecode developersrelyoncorrectinputsfromexternal users which is an insecure programming style.
.
inheritance order confusion soliditysupportsmultipleinheritanceusingthereverseofthec3 linearization order to decide which function to call.
unfortunately allthesolidityofficialdocumentationreleasedbeforemay 2018wronglystatedthatsolidityusesthec3linearizationorder.
thisdocumentationerroriscriticalbecauseprogramsemanticsare differentdependingonwhetherc3linearizationisusedoritsreverseisused.ifdevelopersrelyonwhatthesoliditydocumentation statedandimplementtheircontractswiththestatedsemantics the contracts may not operate as what the developers expected.
thus the solidity team fixed the documentation in v0.
.
.
ourtoolreportspotentiallyvulnerablecontractsduetoinheritance order confusion when they satisfy all the following three conditions theyimplementmultipleinheritance morethan one parent contract have functions with the same signature and these parent contracts do not inherit each other.
if multiple parent contracts that do not inherit each other have functions with the same signature but different semantics then using c3 linearization and using its reverse may make different results.
astable1shows thetooldetected475vulnerablecontractsdue to inheritance order confusion out of contracts deployedearlier than may .
we manually examined contracts thathavemorethanorequalto10transactions.
ourinvestigation showed that only out of contracts may have differentsemantics depending on the use of c3 linearization or its re verse which amounts to .
.
the total number of transac tions of contract is .
during manual investigation we observed three cases of semantics changes due to the confusion of inheritance order.
the firstcase iswrong token minting where different amounts of tokens were minted because of the different semantics in the functionswith the same signature in different parent contracts.
we found sevencontractsinthiscase.thesecondcaseis wrongownerchecking where the results of owner checking were different because differentobjectswerereferencedinthefunctionsindifferentparent contracts.
we found three contracts in this case.
finally the thirdcaseappearedinonlyonecontractis wrongstorageupdating.
in this case the functional logic of the functions in different parent contracts were the same but they updated different storage variables due to variable shadowing.
note that even though our empirical study with contracts available from etherscan showed that only .
of the contracts are vulnerable to inheritance order confusion this vulnerability can 549happenincomplexcontractsanddetectingitisquitechallenging.
indeed such bugs required extensive audits by external auditors even for one of the renowned blockchain companies .
.
uninitialized storage pointers in solidity ifdevelopers do not specify the memorykeyword when they declare local variables of type arraysorstructs the local variablesarebydefaultconsideredasstoragepointers whichare variablespointingtostoragelocations.becausestorageisnotdynamicallyallocated storage pointersshouldbe initialized before being used.
if a storage pointer is uninitialized it points to thestorage slot by default .
this semantics implies that if a developerwritessomevaluetoanuninitializedstoragepointer the value is stored in the first storage variable.
because this semantics isunintuitive contractdeveloperscaneasilymakemistakes which mayleadtosecurityissues.asafixtothisvulnerability starting fromv0.
.
thesoliditycompiler throwsan errorifit detectsany use of uninitialized storage pointers.
ourtoolreportsuninitializedstoragepointerusesviaasimple def useanalysis.wemanuallycheckedthepossiblyvulnerablecontracts reported by the tool and confirmed that contracts among which contracts have more than or equal to transactions are vulnerableduetotheuninitializedstoragepointerastable1shows.
weconsideredcontractsthatuseuninitializedstoragepointersand corrupt storage values as exploitable.
we found that out of contracts were exploitable which amounts to .
.
thetotal number of transactions of contracts is and11 contracts have more than token holders.
wereportthreekindsofsecurityissuesduetothisvulnerability.
pollute winning numbers in storage game game contracts should generate winning numbers randomly and rewardusers when they correctly specify the winning numbers.
if users do not specify the winning numbers correctly the contract owners getthebettingfee.however thecodebelowshowsacasewhere no users can win the play because of uninitialized storage pointers 1contract cryptoroulette uint256 private secretnumber function play uint256 number payable public require msg.value betprice number game game game.player msg.sender game.number number if number secretnumber msg.sender.transfer this.balance win!
... it generates a secret number and stores it in the secretnumber storagevariabledefinedonline2.whileitseemstobeabenigncontract because gameon line is an uninitialized storage pointer two assignments of msg.sender andnumberon lines store theminstorage.itisaserioussecurityissuebecausethevalueof secretnumber on line is changed to the value of msg.sender since the uninitialized storage pointer gamepoints to the 0th index of storage.
therefore to win the game users have to input their addresses.however becauseofthe requirestatementonline4 no onecanwintheplay.thestatementrequiresthattheuserinputbe equal or smaller than .
since users unique addresses are always greater than the execution terminates on line .pollute dynamically decided storage some contracts had uninitialized storage pointers that point to variables whose values are dynamically determined at run time by external inputs.
for example consider the following real world contract 1contract emojitoken is erc721 uint256 private startingprice .
ether uint256 private firststeplimit .
ether address public ceoaddress function createemojistory uint parts public memoryholder storage memd for uint i i parts.length i ... memd.bal val ... memd.used thecreateemojistory functionhasanuninitializedstoragepointer defined on line .
depending on the input value of parts different storage variables can be overwritten.
this is a serious secu rity issue because the values of partsis controlled by external users.allthesensitivestoragevariablessuchas startingprice firststeplimit and ceoaddress can be overwritten.
pollute other info in storage we also discovered that some contracts using uninitialized storage pointers overwrite the following sensitive data tokens tokennames totalsupplytokennumbers andtoken balances of users addresses ownersofcontractsandaddressesofproxycontracts sales duration of sales and refund dates prices the maximum profit and the limit level of exchanges whilethefollowingcontractreceivedandsentonlyfourtransactions wereportitbecauseitleverageduninitializedstoragepointers to perform malicious behaviors 1contract eth anonim transfer uint256 feepaid uint256 creatorfee .
ether modifier secure transfer logunit logunit.timestamp now logunit.currcontractballance this.balance function maketransfer address adr uint256 am payable secure creator.send creatorfee adr.send am this contract always gives financial benefits to the owner of the contract because of the uninitialized storage pointers on lines .
because the creatorfee is updated to this.balance which is the totalamountofetherthecontractreserved the sendfunctionon line12failssincealltheavailableetherwassenttotheownerofthecontractonline11.thefailureon sendfunctiondoesnotthrowany exception but just returns false .
hence the contract owner alwaysgainsthefinancialprofiteventhe sendfailsonline12.asthis exampleillustrates attackerscanuseuninitializedstoragepointers tomakemaliciouscontractsthatlookbenign.thesoliditypatch cannotpreventsuchmaliciouscontractsasattackerscansimplyuseolderversionsofthecompilertoimplementthemaliciouscontracts.
.
typo of the operator solidityusedtoprovidethe operator butitprohibitstheoperator fromv0.
.
becausedevelopersoftenmake mistakesbecauseof it.
this vulnerability is the case where a developer s intention is to sum up numbers using the operator but accidentally used as a typo.
to avoid such mistakes the solidity compiler throws an error if it detects the operator since v0.
.
.
our tool searched for the operator and found four contracts that used the operator.
all four contracts have more than or equal to transactions and we confirmed that they all implemented the same token named hackergold 1function transferfrom address from address to uint256 value ... do the actual transfer balances value balances value unlike the valid subtraction on line the addition on line shows thetypoof .suchavulnerabilitycanbeavoidedifdevelopersuses thelatestcompilersinceitautomaticallypreventsthevulnerability.
.
use of deprecated functions usingdeprecatedfunctionsmayleadtosecurityissuesespecially when the functions were deprecated due to security problems.
we inspecteddeprecatedfunctionsinsolidityfromitsreleasenotes and the official documentation and found the following six deprecated functions all deprecated in v0.
.
the callcode functionwasreplacedwith delegatecall because theimplementationof callcode hadbugssothatitdidnotpreserve the correct values of msg.sender and msg.value .
the throwfunctionisreplacedwith revertbecauseitusesupany remaining gases whereas revertreturns the remaining gases to users.
the block.blockhash function was replaced with blockhash because its name was misleading .
the msg.gasfunctionwasreplacedwith gasleftbecauseitsname was misleading .
the sha3functionwasreplacedwith keccak256 becauseitsname was ambiguous .
the suicidefunctionwasreplacedwith selfdestruct touseless connotative word .
among55 046contracts 782contractsuseddeprecatedfunctions where only the callcode function can cause a security issue.outof10 782contracts onlyonecontractusesthedep recated callcode function.
all the other functions are deprecated due to their ambiguous and misleading names ratherthan security issues.
discussion .
recommendations we give the following recommendations to solidity developers usethelatestsoliditycompilertoapplyavailablesecuritypatches which resolves several vulnerabilities such as functions without visibility the typo of the operator and deprecated functions.
when reusing a standard example contract update the names ofboththecontractanditsconstructorcorrectly.moreover be carefulnottomaketyposinconstructornames.itisalsorisky to use publicfunctions for initialization.
do not use the same name for storage variables in parent and child contracts.
this makes the code complex to understand and possibly causes security issues as described in this paper.
verify type conversion results and do not use the address type for conversion because the compiler cannot check bad casting.
becarefulwhenmultipleparentcontractshavefunctionswiththe samesignature sincedifferentfunctionsmaybecalleddepending on whether c3 linearization or its reverse is used.
do not use uninitialized storage pointers which may corrupt storagevalues.whilethelatestsoliditycompilerpreventsthis issue attackers may leverage uninitialized storage pointers to implement malicious behavior.
use our tool to verify contracts before making them publicly available.
we give the following recommendations to the solidity team release more security patches for known vulnerabilities.
improve the patches for constructor misuses and casting to arbitrary contracts because they are not sufficient as we discussed.
.
threats to validity because we manually investigated potentially vulnerable contracts toidentifydevelopers mistakes theresultsmaybesubjectiveto human who analyzed.
to reduce this threat we performed manual investigation independently for multiple times.
there were no disagreements between the authors in manual analyses because allthedetectedvulnerabilitiesanddevelopers mistakepatternsare obvious.
furthermore because the known vulnerabilities are welldefined analyzing them in contracts was straightforward.
also since we had to inspect only one to three functions per contractthat the tool detected it reduced possible human errors due to manual investigation.
since identifying exploitable contracts simply by inspecting sourcecodeisdifficult theresultsmaybedependentonhumanwhoinspected.tolessenthisthreat weadditionallyperformeddynamicsimulationusingremix forcomplexcontractstodouble check whetherthecontractsareexploitable.wealsorequestedcveids for exploitable contracts to receive external reviews.
the eight cvesweobtainedsofarrepresentallthevulnerabilitiesintroduced in this paper.
related work recentworkhasstudiedvarioussecurityvulnerabilitiesinsmart contracts.atzeietal .
organizedpreviouslyknownvulnerabilitiesonethereumcontracts.theyreportedvulnerabilitiescaused by the solidity language features.
we also discussed known vulnerabilitiesbutwefocusedonthosethatarepatchedbythesolidity compiler.delmolinoetal .
reportedcommonmistakesbyundergraduatestudentsfromacryptocurrencylaboratorysuchaslogicflaws in cryptography.
on the other hand we studied mistakes of real worldsoliditydevelopersduetosolidityvulnerabilitiesthat are patched or planned to be patched.
551todetectvulnerable smartcontracts researchersstudiedstatic analysis tools.
luu et al .
developed a static analyzer using a symbolic executor of evm bytecode.
kalra et al .
converted solidity contract code to llvm bitcode and detected potential vulnerabilities in contracts by using a symbolic model checker and an abstractinterpreterdevelopedforllvmbitcode.tsankovetal .
developedadomain specificverifier whichanalyzesevmbytecode.
krupp and rossow developed an automatic exploit generation toolforsmartcontracts kollurietal .
developedethracer which detects event ordering bugs in smart contracts and nikoli et al.
introduced maian which applies inter procedural symbolicanalysistodetectvulnerablecontracts.ferreiratorresetal .
developed osiris which uses symbolic execution and taint analysis to detect integer bugs in smart contracts.
researchers also have formallyverified smartcontracts.
hirai definedevm in alanguagethatcanbecompiledformultipleinteractivetheorem provers and mavridou and laszka designed and implemented a formal finite state machine for smart contracts.
hildenbrandt etal.
definedthesemanticsofevmbytecodeinthekframework andgrishchenkoetal .
definedacompletesmall step semanticsofevmbytecode.thesetoolsmayserveasafirmground forunderstandingandreasoningaboutthesoliditysemantics.however noneofthemstudiedeightknownvulnerabilitiesdiscussed in this paper in detail.
moreover it is unclear whether such efforts from academia indeed improved the security of smart contracts in reality.
conclusion weconductedanempiricalstudyonsoliditypatchesand55 046live contracts to understand the current security status of real world smart contracts.
our investigation results showed that many soliditydevelopersareunawareoftheimportanceofsoliditypatches.
wereportedthat98.
of55 046livecontractsdidnotapplysolidity patches for known vulnerabilities.
furthermore we discovered that contracts are potentially vulnerable because solidity patches arenot adopted.our manual investigationon potentially vulnerable contracts in source code level revealed insecure coding practicesfromdevelopersandlimitationsofsomeofthesolidity patches.wefoundhundredsofexploitablevulnerablecontractsandaboutonefourthofthemareusedbythousandsofpeople.wehope that our empirical study results improve the security awareness of solidity developers and help them implement secure smart contractsbypreventinginsecurecodingpractices.finally ourworkcanbealsohelpfultosecurityexpertsforsecurityauditingofcontracts and to the solidity team for improving solidity.