skeletal approximation enumeration for smt solver testing peisen yao the hong kong university of science and technology hong kong china pyao cse.ust.hkheqing huang the hong kong university of science and technology hong kong china hhuangaz cse.ust.hkwensheng tang the hong kong university of science and technology hong kong china wtangae cse.ust.hk qingkai shi ant group china qingkaishi gmail.comrongxin wu xiamen university china wurongxin xmu.edu.cncharles zhang the hong kong university of science and technology hong kong china charlesz cse.ust.hk abstract ensuring the equality of smt solvers is critical due to its broad spectrum of applications in academia and industry such as symbolic execution and program verication.
existing approaches to testing smt solvers are either too costly or nd diculties generalizing to dierent solvers and theories due to the test oracle problem.
to complement existing approaches and overcome their weaknesses this paper introduces skeletal approximation enumeration sae a novel lightweight and general testing technique for all rst order theories.
to demonstrate its practical utility we have applied the sae technique to test z3 and cvc4 two comprehensively tested state of the art smt solvers.
by the time of writing our approach had found conrmed bugs in z3 and cvc4 of which had already been xed.
ccs concepts software and its engineering !software verication and validation .
keywords smt solver testing metamorphic testing mutation based testing acm reference format peisen yao heqing huang wensheng tang qingkai shi rongxin wu and charles zhang.
.
skeletal approximation enumeration for smt solver testing.
in proceedings of the 29th acm joint european software engineering conference and symposium on the foundations of software engineering esec fse august athens greece.
acm new york ny usa pages.
introduction satisability modulo theory smt solvers evaluate the satisability of formulas over rst order theories such as integers reals permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for prot or commercial advantage and that copies bear this notice and the full citation on the rst page.
copyrights for components of this work owned by others than acm must be honored.
abstracting with credit is permitted.
to copy otherwise or republish to post on servers or to redistribute to lists requires prior specic permission and or a fee.
request permissions from permissions acm.org.
esec fse august athens greece association for computing machinery.
acm isbn .
.
.
.
and strings .
to date smt solvers have been widely used in a variety of techniques such as testing verication program repair program synthesis and others.
despite the tremendous research progress in smt solving state of the art smt solvers are still errorprone .
bugs in smt solvers can aect the correctness and robustness of the software that depends on the solvers.
for instance in symbolic execution spurious satisfying assignments i.e.
models for path conditions are mapped to infeasible test inputs.
in program verication wrong satisability results can invalidate the results of the veriers which can have detrimental consequences for safety critical domains .
the predominant approach to validating smt solvers consists of various testing techniques.
an important and challenging problem is the test oracle i.e.
the input formula s satisability which is crucial for detecting correctness bugs in smt solvers.
for example a buggy solver may return unsat i.e.
unsatisable for satisable formulas or return sat i.e.
satisable for unsatisable formulas.
to address the oracle problem there are two categories of techniques dierential testing and oracle guided approach.
dierential testing techniques randomly generate syntactically valid formulas solve the formulas using multiple smt solvers and compare the solving results to identify correctness bugs .
however dierential testing cannot be applied when a formula contains some solver specic extensions.
for example a formula with the specic z3 extension assert soft cannot be solved by cvc4 .
in comparison the oracle guided approach systematically synthesizes formulas whose satisability results are known by construction .
such information acts as the oracle i.e.
an smt solver violating the results is buggy.
compared to dierential testing they do not need to run a formula against dierent solvers and thus are usually more lightweight and easier to deploy.
however we observe that existing oracle guided techniques still face the generality problem owing to the innate semantic complexity of smt problems.
as illustrated in the last three rows of table on the one hand some strategies only apply to specic theories .
on the other hand while the technique in is general for dierent theories it only partially addresses the oracle problem i.e.
its mutation strategy can only generate satisable mutants.
consequently the technique can miss certain bugs i.e.
a formula is unsatisable but the solver returns sat .
1141esec fse august athens greece peisen yao heqing huang wensheng tang qingkai shi rongxin wu and charles zhang table comparison among state of the art techniques.
the oracle column represents whether the tool can generate formulas whose satisability is known by construction.
the theory column represents the supported theories.
technique oracle theory blotsky et al.
dierential string scott et al.
dierential string oat winterer et al.
dierential all theories bugariu et al.
sat unsat string winterer et al.
sat unsat int real string mansur et al.
sat all theories this paper presents a new oracle guided approach to testing smt solvers which signicantly complements existing work in that our strategy is general enough for all theories and can generate both satisable and unsatisable mutants.
our approach builds on the metamorphic testing formalization which takes as input a seed formula and tests the solver by identifying the inconsistency between the satisability result of and its equi satisable mutants.
to generate the mutants we propose to use a less explored metamorphic relation that rests on a fundamental property of rst order formulas let oand ube an over approximation and an underapproximation of respectively we have is satisable ois satisable and is unsatisable uis unsatisable .
thus in our approach with the satisability of a seed determined by the solver we further compute an equi satisable mutant oor uvia logical approximations.
if the solver does not provide a consistent result for and its approximations then a potential aw manifests.
by nature of the metamorphic relation our approach can generalize to dierent theories and generate both satisable and unsatisable mutants.
to instantiate the metamorphic relation the major challenge is how to correctly and eciently approximate the seed formulas.
dierent from existing logical approximation techniques that are either theory specic or costly due to heavyweight logical reasoning this paper introduces a novel general and lightweight approximation approach namely skeletal approximation enumeration sae .
sae views an smt formula e.g.
x y.alt x 2 z as two parts a boolean structure e.g.
23 24 and a set of literals e.g.
fx y.alt x z 3g.
the essence of sae is to obtain equi satisable formulas by mutating the literals 2ilocally which is usually lightweight.
we present a practical realization of sae which is embodied by a series of literal level mutation rules and a systematic way to combine the local mutants.
we also prove the correctness of our algorithms.
we have implemented the proposed idea as a tool named sparrow and applied the tool to testing z3 and cvc4 two state of the art and comprehensively tested smt solvers.
by the time of writing sparrow had found and conrmed bugs in z3 and cvc4 respectively.
besides of the bugs had been xed by the developers among which are correctness bugs.
in summary this paper makes the following contributions we present a new metamorphic testing approach for smt solvers which leverages logical approximations as the metamorphic relation.
we introduce skeleton approximation enumeration sae a methodology for approximating smt formulas and propose a practical realization of sae.
we implement our approach as the sparrow tool which detects conrmed bugs in z3 and cvc4 two state of theart smt solvers.
we also present several in depth evaluations to understand sparrow s eectiveness.
preliminaries in this section we present the notations and terminologies throughout the paper.
basic notations .satisability modulo theories smt extend the boolean satisability problem sat with the capability of reasoning with rst order theories such as integers reals arrays and strings.
in a rst order theory a term can be a variable a constant or an n ary function applied to nterms.
an atom istrue false or an n ary predicate applied to nterms.
a literal is an atom or its negation.
a formula is built from atoms using the boolean connectives e.g.
!.
given a formula we denote its free variables and literals by v.altars andlits respectively.
for ease of presentation in the rest of the paper we assume that all literals in lits are distinct.
denition .
.
conjunctive normal form a formula is in the conjunctive normal form cnf if it is a conjunction of one or more clauses c1 c2 where each clause ciis a disjunction of one or more literals l1 l2 .
example .
.
in the theory of integers the function symbols includef gand the predicate symbols consist of f g. consider an integer formula x 1 x x .
the expressions x and x xare integer terms and the expressions x and x x are literals.
the formula is in cnf which has only one clause.
by contrast the formulas x !x and x y.alt are not in cnf.
logical approximations .a formula is satisable if there exists an assignment to v.altars under which the formula evaluates to true.
if it is impossible to nd such an assignment the formula is unsatisable.
a formula is atautology i its negation is unsatisable.
we write to denote that the formula !
is a tautology.
in other words i the formula !
is unsatisable.
denition .
.
over and under approximations let be a rst order formula.
we say a formula oover approximates i o i.e.
ois unsatisable .
we say a formula uunderapproximates i u i.e.
u is unsatisable .
intuitively the over and under approximations of a formula are the necessary and sucient conditions for the formula to be satisable respectively.
example .
.
consider an integer formula x .
clearly the formula 0 x over approximates .
ifx does not hold then x must also be unsatisable.
conversely we can say that under approximates 0.
1142skeletal approximation enumeration for smt solver testing esec fse august athens greece metamorphic testing .a test oracle is a mechanism for determining whether a test has passed or failed.
under certain circumstances however the oracle is unavailable or too expensive to achieve.
this is known as the test oracle problem .
metamorphic testing can be exploited to alleviate the problem.
based on the existing successful test cases metamorphic testing generates follow up test cases by referring to domain specic metamorphic relations which are the necessary properties of the target program in terms of multiple inputs and their expected outputs.
the violation of a metamorphic relation will be suspicious and indicate a potential bug.
example .
.
letfbe a program implementing the transcendental function sin .
the equation sin x sin x is a typical metamorphic relation with respect to f. hence given a successful test case say a metamorphic testing generates its follow up test case a0 and then runs the program over a0.
finally the two outputs i.e.
f a andf a0 are checked to see if they satisfy the expected relation f a f a0 .
if the relation does not hold a bug in fmanifests.
an important property of metamorphic testing is that it does not need a reference engine for dierential testing because the metamorphic relation provides an explicit oracle i.e.
the seed and its variants must output the same result.
when testing smt solvers this property is particularly benecial when the test inputs contain some solver specic extensions.
problem formulation in this section we rst present the metamorphic relation used in our work.
we then formulate skeletal approximation enumeration which aims to realize the metamorphic relation eectively.
.
approximation based metamorphic relation in smt solver testing the satisability of randomly generated formulas is typically unknown without which we cannot decide whether the solver correctly solves the formulas.
to address the problem our work follows the metamorphic testing formulation.
specically we propose to use a less explored metamorphic relation for smt problems which builds on the following fundamental property of rst order logic.
t h.sc e.sc o.sc r.sc e.sc m.sc .
.
let oand ube an over approximation and an under approximation of a rst order formula respectively i.e.
oand u .
we have if is satisable then ois also satisable and if is unsatisable then uis also unsatisable.
example .
.
consider the formula x in example .
.
the formula 0 x over approximates .
clearly if is satisable then 0is also satisable.
conversely under approximates 0. if 0is unsatisable then must be unsatisable.
based on theorem.
.
a metamorphic relation can be dened within a pair of formulas 0 where is a seed formula and 0 is a mutant.
given a formula and an smt solver s we denote s the result of using sto solve .
we then dene the metamorphicrelation as follows s s 0 where 0if is satisable 0 if is unsatisable to test the solver s we could obtain and compare the solving results s ands 0 .
ifs s 0 then a bug in the solver is revealed.
.
skeletal approximation enumeration to eectively instantiate the metamorphic relation in equation we formulate the skeletal approximation enumeration problem a new methodology for approximating rst order formulas.
as mentioned in an smt formula consists of two parts a boolean structure and a set of literals in some rst order theory.
denition .
.
skeletal approximation enumeration given a formula with a set of literals lits f21 2ng skeletal approximation enumeration sae computes the approximations of by enumerating the approximations of the literals.
for a given literal 2i2lits sae can randomly pick a new literal l0 ito replace the literal such that 2i l0 iorl0 i 2i.
we denote the resulting mutant as 0 l0 i 2i .
example .
.
consider a satisable integer formula x y.alt x 2 z .
according to the metamorphic relation in equation we should obtain the mutants by over approximating .
suppose x is chosen for mutation.
after replacing x byx an over approximation of x we obtain a mutant 0 x y.alt x 2 z which over approximates the seed .
to realize skeletal approximation enumeration there are many potential methods for selecting the literals in a seed formula and picking the new literals for replacement.
these methods should address the following challenges.
correctness .
first we need to preserve the metamorphic relation in equation i.e.
enforce that the mutant does over or under approximate the seed formula subject to the satisability of the seed.
in essence sae generates the mutants by enumerating literal level approximations.
for the skeleton in example .
overapproximating the literal x can yield an over approximation of the seed formula.
however simply approximating a literal in a given formula may lead to a nondeterministic mutant that can be either an over approximation or an under approximation.
consequently the mutation strategy can violate equation making the satisability of the mutant unpredictable.
example .
.
suppose we need to over approximate an integer formula x !
y.alt .
clearly the formula x overapproximates x .
however after replacing x by x the new formula 0 x !
y.alt does not over approximate .
this is because x y.alt x 5 y.alt 0 x y.alt x 1 y.alt since x under approximates x we conclude that 0is an under approximation of .
1143esec fse august athens greece peisen yao heqing huang wensheng tang qingkai shi rongxin wu and charles zhang eciency and generality .
second it is crucial but challenging to approximate the seed formulas in various theories eciently considering smt problems innate semantic richness.
the formulas can encode relations about diverse variables such as integers reals bit vectors and oating points.
the relations can be combined with dierent boolean connectives !
etc.
in a complicated manner.
while there are many algorithms for approximating rstorder formulas in the smt solving literature most of them are either theory specic or rely on heavy weight logical reasoning thereby undermining their applicability in smt solver testing.
problem statement .based on the discussion above we aim to address two challenges in using skeletal approximation enumeration to instantiate the metamorphic relation in equation how to guarantee that the generated mutant indeed overor under approximates the seed formula?
how to design the mutation strategies for eciently mutating literals in dierent theories?
approach in this section we rst present and prove the basic principle underlying our approach which addresses the rst challenge.
we then present our literal level mutation strategies which address the second challenge.
finally we describe how to combine the literal level mutants for testing smt solvers.
.
approximation from cnf skeletal approximation enumeration approximates a formula by enumerating the approximations of its literals.
to ensure that the literal level approximations preserve the metamorphic relation in equation we need to ll the gap between approximating a seed formula that can be an arbitrary boolean combination of literals and approximating the individual literals in the seed.
to ll the gap our key idea is to rst transform a seed formula into a suitable internal form and then design the mutation operators.
our idea draws inspiration from existing smt solving algorithms that often build on some specic representations such as the add inverter graph aig the conjunctive normal form cnf .
specically we lay the foundation of our approach with the following theorem.
t h.sc e.sc o.sc r.sc e.sc m.sc .
.
let be a rst order formula in cnf and l2lits a literal in .
we have if a formula l0over approximates l then must over approximate i.e.
l l0 and if a formula l0under approximates l then must underapproximate i.e.
l0 l .
p r.sc o.sc o.sc f.sc.
we rst prove .
by the denition of cnf denition .
we assume that c1 c2 cn where each ci i n is a disjunction of literals.
without loss of generality we suppose l0 kover approximates lkin the n th clause cn l1 l2 lk i.e.
lk l0 kis unsatisable.
next we prove by induction on the structure of cnf formulas.
a first we prove that c0n cn l0 k lk over approximates cn i.e.
the following formula is unsatisable.
cn c0 n l1 lk 1 lk l1 lk 1 l0 k for simplicity we abbreviate l1 lk tob.
cn c0 n b lk b l0 k b lk b l0 k b b l0 k lk b l0 k f alse lk b l0 k since lk l0 kis unsatisable we conclude that cn c0n is unsatisable i.e.
c0nover approximates cn.
b then we prove that 0 over approximates i.e.
the following formula is unsatisable.
0 c1 cn cn c1 cn c0 n for simplicity we abbreviate c1 cn to .
0 cn c0 n cn c0 n cn cn c0 n f alse cn c0 n since cn c0nis unsatisable as proved in a we conclude that 0is unsatisable i.e.
0over approximates .
taking a and b together we complete the proof for .
the proof for is similar.
we omit the details due to lack of space.
theorem .
is crucial for fullling the correctness criterion of skeletal approximation enumeration.
specically if a seed formula has been transformed into cnf then locally over or underapproximating a literal in can yield a global over or underapproximation of the whole formula respectively.
as a result it allows us to turn the problem of approximating a rst order formula into approximating the literals in the formula and composing the literal level mutants.
example .
.
consider again the formula x !
y.alt in example .
.
we can rst transform to cnf and obtain a normalized formula cnf x y.alt x 5 y.alt .
we then perform the mutation on the cnf formula.
for instance consider a formula x that over approximates x .
after replacing x by x in cnf we obtain the mutant 0 cnf x 10 y.alt that over approximates cnf.
in what follows we detail how to realize skeletal approximation enumeration for testing smt solvers.
our approach has two building blocks designing mutation strategies for literals in dierent rst order theories and combining literal level mutants to obtain the whole formula s mutants.
.
literal level mutation strategies we present two mutation strategies predicate symbol transformation .
.
and live predicate injection .
.
which approximates a literal by mutating the predicate symbols and injecting formula snippets respectively.
both strategies can over and underapproximate a literal.
without loss of generality we assume that the seed formula has been transformed into cnf.
1144skeletal approximation enumeration for smt solver testing esec fse august athens greece .
.
predicate symbol transformation pst .
the rst strategy is to mutate the predicate symbol in a literal.
our basic observation is that the predicate symbols in a rst order theory can have some partial order relations ordered by logical implication .
thus transforming the symbols in a literal can yield the over or underapproximations of the literal.
for example the following is a small sample of transformations for various theories.
letxand y.altbe two integer variables.
the predicate x y.alt over approximates x y.alt.
letxand y.altbe two real variables.
the predicate x y.altunderapproximates x y.alt.
letxand y.altbe two string variables.
the predicate xis a prex of y.alt is an under approximation of y.altcontains x .
in what follows we detail the mutation strategies for predicate symbols in literals of dierent theories.
mutating an atom .first suppose that the literals to be mutated do not contain logical negations i.e.
each literal is an atom.
table summarizes the rules for approximating an atom in integers reals bit vectors oating points and strings.
the rules have several characteristics.
first for a given atom there can be more than one mutation rule.
for example to over approximate x y.altwhere x and y.altare integers we can mutate to or .
intuitively if x y.altholds then x y.altandx y.altmust also hold.
second the mutations may introduce fresh constants in the background theory.
for example when over approximating x y.alttox y.alt a we can use a randomly generated integer constant awhere a .
third there are some unsupported atoms for bit vectors and oats due to the overow semantics .
for example we cannot overapproximate xbvule y.alttoxbvult y.altbvadd a a like the one for integers because bit vectors model bounded integers e.g bits integers where the add function may overow.
we will present the strategy for handling such atoms in .
.
.
mutating negated literals .so far the mutation rules only apply to atoms i.e.
negation free literals.
as our goal is to mutate a literal that can contain negations e.g.
x y.alt we proceed to discuss the approximations of such cases.
the overall idea behind our approach is to eliminate the negations after which we can reuse the rules in table .
the challenge however is how to eliminate negations soundly.
our solution is embodied by two parts.
first we can transform the literal to an equivalent and negationfree atom and then reuse the mutation rules for that atom.
for example to over approximate the integer literal x y.alt we rst transform it to an equivalent atom x y.altand then apply an overapproximation rule for x y.alt.
second there are some cases where it is hard to eliminate negations by nding equivalent atoms.
for example consider a literal xstr.prefixof y.alt in the string theory which means xis not a prex of y.alt .
it is nontrivial to represent the literal as an equivalent atom.
to handle such cases our approach leverages the conversions between under and over approximations established by the following proposition.
p r.sc o.sc p.sc o.sc s.sc i.sc t.sc i.sc o.sc n.sc .
.
given two rst order formulas oand uthat over approximates and under approximates a formula respectively we have ounder approximates i.e.
o o and uover approximates i.e.
u u .p r.sc o.sc o.sc f.sc.
we sketch the proof of .
since o we have that !
o is unsatisable.
to prove we need to show that o!
is unsatisble.
observe that o!
o o !
o .
since !
o is unsatisable we conclude that o .
proposition .
has two implications.
first it allows us to use over approximating techniques to generate under approximations and vice versa.
second it allows for eliminating the negation in a literal.
as such we can soundly reuse the rules in table .
for example suppose we need to over approximate a literal p which can be processed in three steps negate pand obtain an atom i.e.
p p under approximate p using the rules in table and let the result be p0 i.e.
p0 p negate p0and obtain the nal result p0 by proposition .
we have that p0over approximates p i.e.
p p0 .
in the above process we only apply under approximation rules and logical negations while the nal result over approximates the literal p. example .
.
let xstr.prefixof y.alt be the string literal to be over approximated.
first we take its negation and obtain an atom xstr.prefixof y.alt.
second we under approximate the atom xstr.prefixof y.alt and let the result be y.alt xstr.
alice where str.
represents string concatenation .
finally we negate the result and obtain y.alt xstr.
alice which over approximates xstr.prefixof y.alt .
remarks .first we should emphasize that literal level approximations are not restricted to the rules in table .
a richer set of rules can be designed.
second the strategy is similar to the type aware operator mutation presented by winterer et al .
.
however their mutations do not guarantee the preservation of satisability.
this is because they operate over formulas with arbitrary boolean structures and perform the mutations randomly.
for example consider a trivially unsatisable integer formula .
the approach in may mutate the formula to or the second of which has a dierent satisability result.
.
.
live predicate injection lpi .
the pst strategy transforms the predicate symbol of a literal but has two limitations.
first it cannot mutate certain literals such as over approximating xbvule y.alt .
second the search space is conned by the seed e.g.
pst cannot change the function symbols and boolean connectives in the seed.
to stress test smt solvers we would like to generate syntactically more complex mutants which can exhibit diverse control and data dependence between variables.
to this end our second mutation strategy enriches a literal by synthesizing a new formula snippet and injecting it back to the seed formula using some proper boolean connectives .
the basic idea is to utilize the formula snippet to relax or restrict the solution space of a literal thereby yielding the logical approximations of the literal.
example .
.
consider an integer formula x y.alt and its two mutants below 1 x y.alt 5 x 1 2 x y.alt x 2 1145esec fse august athens greece peisen yao heqing huang wensheng tang qingkai shi rongxin wu and charles zhang table mutation rules for approximating an atom in dierent theories.
each atom may have one or more possible mutants separated by .
a denotes a randomly generated constant in the corresponding theory.
n a means unsupported.
logic atom over approximation under approximation x y.alt less than x y.alt x y.alt x a y.alt a x y.alt less than or equal to x y.alt a a x y.alt x a y.alt a int real x y.alt greater than x y.alt x y.alt x y.alt a a x y.alt greater than or equal to x a y.alt a x y.alt x y.alt a a x y.alt equal x y.alt x y.alt a x a a y.alt a any a x y.alt inequal x a y.alt a any a x y.alt x y.alt xbvult y.alt unsigned less than xbvule y.alt x y.alt n a xbvule y.alt unsigned less than or equal to n a x y.alt xbvult y.alt xbvugt y.alt unsigned greater than xbvuge y.alt x y.alt n a xbvuge y.alt unsigned greater than or equal to n a x y.alt xbvugt y.alt xbvslt y.alt signed less than xbvsle y.alt x y.alt n a bit vec xbvsle y.alt signed less than or equal to n a x y.alt xbvsgt y.alt xbvsgt y.alt signed greater than xbvsge y.alt x y.alt n a xbvsge y.alt signed greater than or equal to n a x y.alt xbvsgt y.alt x y.alt signed equal xbvsle y.alt xbvsge y.alt abvsle xbvsle a abvsle y.altbvsle a any a x y.alt signed inequal x a y.alt a any a xbvsgt y.alt xbvslt y.alt x y.alt unsigned equal xbvule y.alt xbvuge y.alt abvule xbvule a abvule y.altbvule a any a x y.alt unsigned inequal x a y.alt a any a xbvugt y.alt xbvult y.alt xfp.lt y.alt less than xfp.leq y.alt xfp.neq y.alt n a xfp.leq y.alt less than or equal to n a xfp.eq y.alt xfp.lt y.alt float xfp.gt greater than xfp.geq y.alt xfp.neq y.alt n a xfp.gt greater than xfp.geq y.alt xfp.neq y.alt n a xfp.geq y.alt greater than or equal to n a xfp.eq y.alt xfp.gt y.alt xfp.eq y.alt equal xfp.leq y.alt xfp.geq y.alt afp.leq xfp.leq a afp.leq y.altfp.leq a any a xfp.neq y.alt inequal xfp.eq a y.altfp.eq a any a xfp.gt y.alt xfp.lt y.alt xstr.
y.alt lexicographic ordering xstr y.alt x y.alt xstr.
a str y.alt len a xstr y.alt lexicographic ordering xstr y.altstr.
a len a x y.alt xstr.
y.alt xstr.prefixof y.alt xis a prex of y.alt xstr y.alt y.altstr.contains x y.alt xstr.
a len a string xstr.suffixof y.alt xis a sux of y.alt xstr y.alt y.altstr.contains x y.alt astr.
x len a xstr.contains y.alt xcontains y.alt y.altstr x y.altstr.suffixof x y.altstr.suffixof x x y.alt equal xstr.suffixof y.alt xstr.perfixof y.alt xstr.suffixof a xstr.prefixof a xstr.contains y.alt xstr y.alt y.alt str.suffixof a y.altstr.prefixof a any a x y.alt inequal x a y.alt a any a xstr.
y.alt y.altstr.
x in the mutants 1and 2 the snippet x is injected via disjunction and conjunction respectively.
observe that 1and 2 over approximates and under approximates respectively.
more concretely we dene the mutation strategy as follows.
denition .
.
live predicate injection given a cnf formula and a literal l2lits live predicate injection rst randomly generates a formula snippet and then injects the snippet as follows if is satisable it replaces lbyl and if is unsatisable it replaces lbyl .
the correctness of live predicate injection lpi is enforced by the following proposition.
p r.sc o.sc p.sc o.sc s.sc i.sc t.sc i.sc o.sc n.sc .
.
letlbe a literal and be an any rst order formula.
we have l over approximates l and l underapproximates l. p r.sc o.sc o.sc f.sc.
we sketch the proof of .
by denition .
we need to prove l!
l is unsatisable.
since l!
l l l l l f alse we have .
taking theorem .
and proposition .
together we conclude that the mutants produced by lpi are equi satisable with the seed formula and thus preserve the metamorphic relation in equation .
moreover by proposition .
the conclusion holdsregardless of the satisability of the formula snippet which can contain any variables function symbols predicate symbols and boolean connectives.
this property allows us to generate satisability preserving mutants that exhibit dierent and diverse control and data dependence.
algorithm for lpi .to realize the lpi mutation strategy we need to generate formula snippets automatically.
in what follows we use integer arithmetic to illustrate the essence of our approach and the handling of other theories is similar.
the key observation behind our solution is that by nature smt formulas follow a layered construction.
a formula is a boolean combination of atoms which are built on top of lower level terms.
for example the integer formula x y.alt consists of two atoms where the atom x consists of two terms xand .
algorithm describes the process to build a formula snippet.
the function random select randomly picks one element from a set.
the function smt expr takes as input the operator and operands and returns an smt expression.
we omit the details of the functions as their implementations are straightforward.
at a high level algorithm works in a top down manner.
at the top we rst randomly choose a boolean connective e.g.
negation conjunction and disjunction line .
we then proceed to build the atoms.
to generate an atom the function generate atom 1146skeletal approximation enumeration for smt solver testing esec fse august athens greece algorithm generating an integer formula snippet.
input a seed integer formula output a new formula snippet 1function generate formula snippet op random select fnone !
xorg ifop none then return generate atom else if op then l generate atom return smt expr op l else l1 generate atom l2 generate atom return smt expr op l1 l2 11function generate atom op random select f g t1 generate term t2 generate term return smt expr op t1 t2 15function generate term op random select f g v.alt1 random select v.altars if in linear arithmetic and op2f gthen v.alt2 randomly generate a constant else v.alt2 random select v.altars return smt expr op v.alt1 v.alt2 line line rst synthesizes two integer terms using the functiongenerate term line line and then relates the terms with an integer predicate symbol e.g.
and .
note that when the seed formula is in the theory of linear integer arithmetic we should not synthesize non linear terms such as x y.altandx y.alt.
thus to avoid generating such terms the function generate term restricts the second operand v.alt2to an integer constant when the randomly selected operator is or line .
example .
.
in the following formula pair 0over approximates .
the mutant 0is obtained by replacing y.alt zby y.alt z x z y.alt 1xor y.alt z x where the shaded part is a randomly generated formula snippet.
x y.alt y.alt z 0 x y.alt y.alt z x z y.alt 1xor y.alt z x remarks .first in principle one can generate and inject new formulas that are arbitrarily large and complex.
however generating such formulas can be time consuming.
second the mutants generated by lpi are not necessarily in cnf.
by denition cnf formulas only contain three boolean connectives i.e.
and while lpi can use other boolean connectives such as xorand!.
.
bug detection with sparrow based on the principle introduced in .
and the mutation strategies presented in .
we have designed and implemented sparrow a tool for stress testing smt solvers.
bug types .sparrow can detect three categories of bugs soundness bugs the solver returns unsat for satisable formulas or returns sat for unsatisable formulas invalid model bugs a formula is satisable and the solver returns sat but the solver yields an infeasible model that falsies the formula and crash bugs the solver terminates abnormally when solving a formula which can be caused by some internal assertion failures or memory safety problems such as buer overow.
we refer to the rst two categories as the correctness bugs .
algorithm .algorithm shows the general workow of sparrow which takes as input a set of seed formulas and an smt solver under test.
the three sets soundness bugs model bugs and crash bugs are used to collect soundness invalid model and crash bugs respectively line .
in each round of the loop we rst randomly choose a formula from the seeds convert it into cnf and pass the cnf formula to the smt solver.
if the solve yields sat we generate a mutant 0by over approximating line .
otherwise we obtain a mutant 0by under approximating line .
we then invoke the solver to solve the mutant and check whether it gives a consistent answer or not.
if not we have found a candidate soundness bug line .
if the answer is consistent and sat but the solver returns a model that falsies 0 we have found an invalid model bug line .
finally if the solver crashes on the mutant we have found a candidate crash bug line .
in algorithm the two sub procedures over approximate and under approximate can be implemented using the rules presented in .
.
briey to approximate a cnf formula we randomly select a subset of literals from lits and then apply the corresponding literal level mutations.
note that to guarantee the correctness the approximation type for a formulas literals should be the same.
for example if we over approximate one literal but under approximate the other it would be hard to gure out whether the solution space of the cnf formula is enlarged or reduced.
consequently we cannot ensure whether the nal mutant over or under approximates the seed formula.
implementation .we have implemented sparrow in lines of python code which instantiates algorithm as follows.
first we convert a seed formula into cnf using tseitin s cnf transformation algorithm whose time complexity is linear in the formula size.
second for each seed formula we generate mutants by default line .
third since the number of literals in a formula can be gigantic in practice we bound the number of mutated literals in each mutant as .
to mutate each selected literal we randomly apply one applicable strategy from pst .
.
and lpi .
.
.
after collecting the candidate bugs we reduce the sizes of the bug revealing formulas via delta debugging .
we have automated the test case reduction using ddsmt and pydelta two open source delta debuggers for the smt lib2 language.
finally we contact the solver developers to conrm the bugs.
1147esec fse august athens greece peisen yao heqing huang wensheng tang qingkai shi rongxin wu and charles zhang algorithm testing smt solvers via approximation.
input a set of seed formulas seeds and an smt solver s output the candidate bugs 1procedure test smt solver seeds s soundness bu afii10069.itals model bu afii10069.itals crash bu afii10069.itals while some budget is not reached do 4 randomly select a formula from seeds 5 transform into cnf res solve with the solver s generate nequi satisfiable mutants fori 1tondo ifres sat then 0 over approximate else 0 under approximate res0 solve 0with the same solve s ifres0 resthen soundness bu afii10069.itals soundness bu afii10069.itals f 0g else if res0 sat then m a model of 0returned by s ifmdoes not satisfy 0then model bu afii10069.itals model bu afii10069.itals f 0g else if scrashed then crash bu afii10069.itals crash bu afii10069.itals f 0g return soundness bu afii10069.itals model bu afii10069.itals crash bu afii10069.itals evaluation to evaluate the eectiveness of skeletal approximation enumeration we conduct two sets of experiments.
in the rst experiment we examine the eectiveness of sparrow in nding bugs in z3 and cvc4.
in the second experiment we compare sparrow with two existing techniques regarding performance code coverage and bug nding.
.
experimental setup tested solvers .we have selected z3 and cvc4 the two most popular smt solvers for the experimental evaluation.
we choose the solvers by following four criteria.
first they have been widely used in both academia and industry.
second they support most of the theories in the smt lib2 standard .
third they show a state of the art performance i.e.
regularly achieve high ranks in smt comp the annual smt competitions.
finally they are mature and have been extensively tested by previous works which means nding their bugs is challenging.
we mainly focus on testing the default modes of the solvers.
for cvc4 we use the options produce models incremental and strings exp as needed to support all the seeds.
to detect invalid model bugs we have supplied the check models option to cvc4 and the model.validate true option to z3.seeds selection .the seed formulas come from two sources the regression test suits of several open source smt solvers including z3 cvc4 yices2 and opensmt and the smtlib2 standard benchmark suite maintained by the smt lib initiative .
after collecting the formulas we preprocess them as follows.
first we use z3 s simplify tactic to lter out formulas that are trivially satisable e.g.
p p or unsatisable e.g.
.
these formulas can often be instantly solved in the simplication phase of smt solvers which may make our mutations futile.
next we exclude formulas that cannot be solved by z3 and cvc4 within seconds to improve the testing throughput.
environment .all the experiments are conducted on a linux workstation with an core intel r xeon r .20ghz processor and gb ram.
we compile z3 and cvc4 using gcc .
.
with assertions and addresssantizer enabled.
we use gcov to measure the code coverage.
all the tools are set to run in singlethreaded mode.
for each of the experiments we perform ten independent runs and report the average results.
.
results of bug finding in this section we present some statistical analyses of the bugs found by sparrow.
all the bug reports are publicly available at the site in .
bug count .table summarizes the status of the bugs.
reported represents the number of reported bugs conrmed represents the bugs that the developers conrm as real and unique fixed represents the xed bugs duplicate represents the bugs that the developers identify as duplicates and won t x represents the bugs that the developers reject to x. overall sparrow nds previously unknown unique and conrmed bugs in z3 and cvc4 which are missed by the solver developers users and regression testing.
by the time of writing .
out of of the conrmed bugs had already been xed.
won t x bugs .some bugs are marked as won t x mainly due to miss congurations i.e.
improper options are supplied to the solver.
for example in a z3 bug report the developer commented that i am going to skip these bugs on strings tweaking strange conguration parameters .
aected theories .sparrow can nd bugs in dierent smt lib2 theories such as integers reals bit vectors oating points strings and the combinations of these theories.
figure presents the distribution of logic types among the conrmed bugs.
among the top most frequent theories in z3 are integers strings and bit vectors.
among the top most frequent theories in cvc4 are integers strings and reals.
we observe that most of the bug triggering integer formulas are non linear.
the results indicate that decision procedures for non linear integer arithmetic and strings are among the weak components in smt solvers.
bug types .table shows the distribution of bug types among the conrmed bugs.
the most common bug category is crash bugs out of followed by invalid model bugs and soundness bugs .
in summary .
out of of the conrmed bugs are correctness bugs including soundness bugs and invalid model 1148skeletal approximation enumeration for smt solver testing esec fse august athens greece integer string bit vec468101211 a z3integer string real5101514 b cvc4 figure top theory type of the conrmed bugs.
table status of the bugs found by sparrow.
status z3 cvc4 total reported conrmed fixed duplicate won t x table bug type of the conrmed bugs.
type z3 cvc4 total fixed soundness invalid model crash bugs which clearly demonstrates the strength of sparrow in nding logic issues in smt solvers.
feedback of developers .the developers of the solvers are generally responsive in xing our bug reports which indicates that they take our bugs seriously.
for example to quote the developers comments this is due to a fairly obscure extended equality rewrite.
thanks a lot for the report.
it turns out that the issue is a bit less severe though still pretty bad than i rst thought .
as shown in table among the xed bugs .
are correctness bugs.
besides the developers have added the bug triggering formulas to the regression test suites of their solvers.
taken together we conclude that sparrow is eective in nding a large number of diverse bugs and its ndings are signicant.
.
comparison to existing techniques in this section we present an in depth study of the mutation strategies in sparrow by comparing the following techniques yinyang fusion a metamorphic testing based approach where the metamorphic relation is based on the semantic fusion strategy yinyang opfuzz a dierential testing based approach that uses the type aware operator mutation strategy for the input generation sparrow pst the variant of sparrow that only applies the predicate symbol transformation strategy .
.
table time milliseconds of generating a mutant.
tool avg min max stddev yinyang fusion .
.
.
yinyang opfuzz .
.
.
.
sparrow pst .
.
.
.
sparrow lpi .
.
.
sparrow pst lpi .
.
.
.
table number of tested mutants per hour.
tool mutants yinyang fusion yinyang opfuzz sparrow pst sparrow lpi sparrow pst lpi sparrow lpi the variant of sparrow that only uses the predicate symbol transformation strategy .
.
sparrow pst lpi the default conguration of sparrow.
we choose yinyang fusion and yinyang opfuzz because they respectively represent the state of the arts in the oracle guided approach and the dierential testing approach .
we perform three experiments measuring the performance of the tools comparing the line coverage of the solvers and applying sparrow to reproduce the bugs detected by yinyang.
the three experiments oer a comprehensive comparison between the tools.
to study and we randomly sample seed formulas and set each tool to generate mutants per seed following the settings in .
note that since yinyang fusion supports fewer theories than yinyang opfuzz and sparrow c.f.
table we only sample seeds supported by all the tools.
the timeout for the solvers is set to seconds per mutant.
performance .first we compare the performance of the ve mutation strategies in terms of the mutation cost and the overall testing throughput.
mutation cost .
table summarizes the statistics of the time cost.
for each tool we report the average minimum maximum and standard deviation of the time for generating one mutant.
we make two observations.
first the time cost of sparrow to derive satisabilitypreserving mutants is low.
on average it takes the three variants of sparrow to milliseconds to generate one mutant.
the speed of sparrow pst lpi lies between sparrow pst and sparrow lpi .
recall that pst only mutates the predicate symbols while lpi needs to generate a new formula snippet.
thus sparrow pst is often faster than sparrow lpi .
second the mutation speed of sparrow pst lpi is similar to yinyang opfuzz and is about faster than yinyang fusion .
testing throughput .
to give a picture of the overall testing throughput table presents the number of tested mutants per hour.
as can be seen yinyang fusion yinyang opfuzz and sparrow pst lpi can test and mutants in one hour respectively.
1149esec fse august athens greece peisen yao heqing huang wensheng tang qingkai shi rongxin wu and charles zhang table line coverage by mutating seeds mutants per seed .
the baseline is the coverage of z3 and cvc4 after solving seeds .
for z3 and .
for cvc4 .
tool z3 cvc4 yinyang fusion .
.
yinyang opfuzz .
.
sparrow pst .
.
sparrow lpi .
.
sparrow pst lpi .
.
we observe that most of the cpu time is taken up by the smt solvers.
therefore the hardness of the mutant formulas is the key factor of the throughput.
for example we nd that the mutants generated by yinyang fusion are often harder to solve than other tools.
thus the throughput of yinyang fusion is smaller than yinyang opfuzz and sparrow pst lpi .
to summarize the mutation cost and testing throughput of sparrow pst lpi are competitive against that of yinyang opfuzz .
line coverage .second we compare the line coverage improvement achieved by the fuzz tools.
the baseline is the line coverage of z3 and cvc4 after solving the sampled seeds which are .
and .
respectively.
we then use the fuzz tools to mutate these seeds run z3 and cvc4 to solve the mutants and measure the solvers cumulative line coverage.
for each seed we run each tool to produce mutants.
table presents the comparison results.
as can be seen sparrow pst lpi can consistently improve the line coverage of the solvers over yinyang.
sparrow improves the coverage over the baseline by .
for z3 and .
for cvc4 while the best one between yinyang fusion and yinyang opfuzz does by .
for z3 and .
for cvc4.
reproducing bugs .finally we conduct an experiment to compare yinyang and sparrow in terms of nding correctness bugs.
in particular we rst select all the correctness bugs that are found by yinyang fusion and yinyang opfuzz in november and december and xed by the developers by the time of writing.
we then try to reproduce the bugs using sparrow.
we choose the correctness bugs because as a metamorphic testing approach sparrow s primary goal is to nd those issues.
the selected bugs cover various theories such as integers reals bit vectors and strings.
for each of the bugs we rst remove the seeds that can directly reveal the bug without being mutated .
we then use sparrow to derive mutants from all the seed formulas with the identical logic type.1we set the number of mutants per seed to and repeat the generation process times.
then the comparison proceeds as follows.
we rst check whether sparrow can generate re triggering mutants from the seeds or not.
if yes we then check whether sparrow actually re triggers the same bug.
to achieve this goal we run the bug revealing mutants against the rst solver commit id with the corresponding x. if the solver now answers correctly for the mutants we count the bug as successfully re triggered.
1to oer an apples to apples comparison we should have used the same seed for each bug.
however we cannot know which seed yinyang has used to trigger a bug.sparrow pst sparrow lpi sparrow pst lpi figure the results of running sparrow to re trigger the xed correctness bugs reported by yinyang fusion and yinyang opfuzz in november and december .
figure presents the reproduction results.
briey we make two observations.
first sparrow pst and sparrow lpi can reproduce bugs and bugs alone respectively.
but there are bugs that can only be found by sparrow pst lpi i.e.
the combination of the two strategies.
second sparrow pst lpi successfully reproduces out of the bugs.
there are bugs that cannot be reproduced because our current implementation has limited support for the theories of recursive functions and abstract data types.
in summary we nd that sparrow is competitive against or complementary to yinyang fusion and yinyang opfuzz in nding correctness bugs and both of the two mutation strategies in sparrow contribute to its eectiveness.
.
threats to validity the threat to internal validity mainly lies in the implementation of our approach.
to validate our implementation we have used several smt solvers to cross check if the mutants generated by sparrow are indeed the over or under approximations of the seed formula.
this validates the implementation to some extent.
the threat to external validity lies in the representativeness of the subjects.
the solvers we select for the evaluation are mature widely used and extensively tested by previous works .
the threat to construct validity is the selection of the seed formulas and the randomness of the mutations.
to mitigate the threat we run each experiment ten times and use the average data.
discussion limitations of sparrow .our study demonstrates sparrow s eectiveness for testing smt solvers but limitations exist in our current implementation.
first for the predicate symbol transformation strategy .
.
sparrow relies on manually given rules to transform a literal.
in the future it would be interesting to synthesize new transformation rules automatically.
for example the cvc4 developers have applied syntax guided synthesis sygus to generate term level and equivalence preserving rewriting rules .
second for the live predicate injection strategy .
.
sparrow can suer from performance issues if it attempts to generate a large formula snippet.
however this limitation does not mean that sparrow can only generate small mutants because it can mutate a seed incrementally i.e.
approximates the mutants produced in the previous rounds.
third sparrow has limited support for a few 1150skeletal approximation enumeration for smt solver testing esec fse august athens greece logics such as recursive functions and abstract data types which are recently introduced into the smt lib2.
standard.
generality of sae .beyond smt solver testing skeletal approximation enumeration suggests a general strategy for deriving semantic approximations of a problem via lightweight syntactical mutations.
specically it can be protable to transform a seed into some suitable representations and then design the mutation operators.
there are several avenues for further exploring the applicability of skeletal approximation enumeration.
first the techniques and tools can facilitate testing other smt solvers that take smtlib2 les as their input.
second the general idea could be extended to test other software systems that reason about programs logic properties such as static analyzers and program veriers.
future work on automated debugging .while the focus of this paper is bug detection it could be promising to use our techniques to ease the automatic debugging.
first a possible future work is to aid delta debugging.
specically we can trace the mutations made by sparrow and perform some backtracking of the mutations in the stage of delta debugging.
the backtracking based strategy could assist or complement existing general purpose delta debuggers.
second showing the minimal dierences to seed formulas that trigger bugs is helpful for the developers to understand the bugs.
thus providing the minimal literal level mutations and the original seed in the bug report would be another potential direction to assist debugging.
related work smt solver testing .fuzzsmt is the rst grammar based fuzzing tool for smt solvers.
stringfuzz and banditfuzz follow the idea to test string and oating points solvers respectively.
winterer et al .
present a type aware mutation strategy which mutates operators of conforming types within the seed formulas to generate well typed mutants.
falcon explores the combined formula conguration space for testing smt solvers.
all the above mentioned techniques need to combine dierential testing to nd soundness bugs.
to address the test oracle problem several recent works generate smt formulas whose satisability is known by construction which we term the oracleguided approach.
bugariu and m ller propose an approach to generating increasingly complex string formulas via satisabilitypreserving transformations.
semantic fusion fuses formula pairs that generate mutants that are by construction either satisable or unsatisable.
however their implementations only support integers reals and strings.2storm mutates the boolean structure of a seed but can only generate satisable mutants.
compared to the previous works we present a new technique for the oracleguided approach which applies to all theories and can generate satisable and unsatisable mutant formulas.
metamorphic testing .the key idea of metamorphic testing is to detect violations of domain specic metamorphic relations by comparing the outputs between a seed test and its corresponding mutant tests.
metamorphic testing has been successfully applied 2note that in theory it could be possible to extend the idea of semantic fusion to support other theories.in many application domains such as bioinformatics web services compilers debuggers databases machine learning based systems model counters and smt solvers .
our approach is an instance of metamorphic testing.
a closely related work is semantic fusion which generates equi satisable mutants from the concatenation of two seed formulas.
our approach diers in two aspects.
first semantic fusion mutates variables using the fusion functions which can only introduce new variables and function symbols in the mutants.
in comparison skeletal approximation enumeration can inject formula snippets which can contain new variables function symbols predicate symbols and boolean connectives.
second semantic fusion requires that the two seeds are both satisable or unsatisable.
in comparison our algorithm does not assume that the satisability of the seeds is known prior as it determines the mutation strategy according to the solving result of the smt solver under test.
mutation based testing .a common technique for input generation is to mutate the seed corpus.
for example american fuzzy lop afl is a well known security oriented fuzzer which employs bit level and byte level mutations to generate new test cases.
however such an ecient input generation approach cannot handle inputs with a highly formatted structure or grammar.
thus grammar aware mutation based fuzzing has been proposed.
superion aflsmart and nautulius are general grammaraware grey box fuzzers that employ ast based mutations and use code coverage to guide the mutations.
codealchemist preserves the semantic requirement e.g.
type correlation as the constraint during input generation.
zest combines the coverage feedback with property based testing to provide better guidance for seed prioritization.
in comparison our approach can be regarded as an instance of grammar aware mutation.
specically sparrow not only generates syntactically correct mutants but also guarantees their satisability results which can serve as the ground truth for nding correctness bugs.
conclusion this paper presents skeletal approximation enumeration a new methodology for testing smt solvers.
our approach helped discover conrmed bugs in z3 and cvc4 two state of the art and comprehensively tested smt solvers.
more than of the bugs have been xed and a signicant fraction of them are correctness bugs.
our technique is general and may be adapted to other constraint languages such as datalog and minizinc and settings such as static analyzers and model checkers .