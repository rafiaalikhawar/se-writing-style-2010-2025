towards neural synthesis for smt assisted proof oriented programming saikat chakraborty gabriel ebner siddharth bhat sarah fakhoury sakina fatima shuvendu lahiri nikhil swamy microsoft research redmond wa usa university of cambridge cambridge uk university of ottawa ottawa on canada saikatc gabrielebner sfakhoury shuvendu nswamy microsoft.com sb2743 cam.ac.uk sfati077 uottawa.ca abstract proof oriented programs mix computational content with proofs of program correctness.
however the human effort involved in programming and proving is still substantial despite the use of satisfiability modulo theories smt solvers to automate proofs in languages such as f .
seeking to spur research on using ai to automate the construction of proof oriented programs we curate a dataset of 600k lines of open source f programs and proofs including software used in production systems ranging from windows and linux to python and firefox.
our dataset includes around 32k top level f definitions each representing a type directed program and proof synthesis problem producing a definition given a formal specification expressed as an f type.
we provide a programfragment checker that queries f to check the correctness of candidate solutions.
we also report on an extended version of our dataset containing a total of 940k lines of programs and proofs with a total of 54k top level f definitions.
we believe this is the largest corpus of smt assisted program proofs coupled with a reproducible program fragment checker.
grounded in this dataset we investigate the use of ai to synthesize programs and their proofs in f with promising results.
our main finding in that the performance of fine tuned smaller language models such as phi or starcoder compare favorably with large language models such as gpt at a much lower computational cost.
we also identify various typebased retrieval augmentation techniques and find that they boost performance significantly.
with detailed error analysis and case studies we identify potential strengths and weaknesses of models and techniques and suggest directions for future improvements.
index terms proof oriented programming ai for proofs trustworthy ai programming i. i ntroduction the recent excitement around ai assisted programming has been tempered by concerns around the trustworthiness of aigenerated code .
languages that offer static guarantees can help reduce some of these concerns e.g.
having ai generate safe rust code rather than c eliminates the risk of ai introduced memory safety issues.
taking this line of thinking to its limit using ai to generate code in prooforiented languages which allow programs to be augmented with specification and proofs of correctness could eliminate trust in ai generated code so long as the specification can be audited to match a human s intent.
conversely proof oriented work done as interns at microsoft researchlanguages often require a high level of human expertise ai assistance could help make them easier to use.
recognizing the potential dual benefit i.e.
trustworthy ai programming easier program proof many researchers have begun investigating using ai to synthesize proofs.
however most of the prior work has focused on using ai with tacticbased proof assistants such as coq lean and isabelle including projects like coqgym which builds models based on hundreds of coq projects containing more than tactic scripts and leandojo which uses mathlib a large corpus of formalized mathematics in lean.
ai automation for proof oriented programming languages like f dafny viper verus and others has received comparatively less attention.
the prior work has been limited by the availability of data focusing instead on small hand crafted problem sets numbering in the few hundreds.
this is unfortunate since proof oriented languages may be close to the limit of symbolic automation provided by smt solvers and ai automation could open the door to further automation that has remained out of reach.
additionally to achieve the promise of trustworthy ai programming we believe it is essential to develop ai forprogram and proof synthesis rather that only on mostly mathematical tactic based proofs.
towards this end our paper makes the following three major contributions .
a new dataset of programs and proofs aiming to spur research in ai assisted proof oriented programming our first main contribution is fs tardataset a dataset of f programs and proofs extracted from source files representing about 600k lines of source code drawn from open source projects.
the dataset provides around 32k top level f definitions coupled with tooling that allows each definition to be checked in isolation.
we believe this is the largest dataset of smt assisted proof oriented programs and we envision for it to be a live evolving data set with new projects added to it over time.
indeed currently fs tardatasethas grown to include additional projects reaching 940k lines of source code see appendix a and b for details and initial results .
although we currently focus on f we hope for the dataset to also grow to include data from other proof oriented languages.arxiv .01787v3 sep 2024we describe the dataset in detail in iii.
.
a benchmark problem grounded in this data we design a straightforward benchmark given a type as a formal specification synthesize a program that has that type .
each of the 32k definitions in fs tardatasetyields its own synthesis problem where the type of the definition is the goal type and a technique is expected to synthesize a definition that the f compiler attests is goal type correct.
in f types are rich enough to capture a variety of specifications ranging from simple types as in other functional programming languages to dependently typed specifications that capture functional correctness properties of a program i.e.
types can represent arbitrary propositions.
dually programs in f contain computational content e.g.
logic for reversing a list but they can also be interpreted as proofs.
as such our benchmark can be seen as an instance of a type or specification directed program proof synthesis problem.
we present a simple and objective taxonomy to classify benchmark instances distinguishing simply typed dependently typed and fully specified proofs corresponding roughly to the precision of specifications.
.
designing and evaluating neural synthesis techniques we apply a by now standard regime of prompting large language models llms to generate solutions backed by retrieval augmentation and fine tuning techniques specific to our setting.
in particular we construct a prompt by augmenting the goal type with related types and definitions from the program context based on various embedding models.
in v we evaluate the performance of off the shelf large language models including gpt .
and gpt as well as fine tuned smaller models include phi2 .7b orca27b and starcoder 15b with the following main takeaways.
fine tuned smaller models can match or outperform large language models v a .
different classes of problems are solved with varying degrees of success with common error modes differing between pretrained and fine tuned models v b .
leveraging the contexts as well as retrieval augmentation significantly boosts the quality of results v c .
based on our results we are optimistic about for the future of ai assisted proof oriented programming.
researchers building verified systems in proof oriented languages have reported writing around lines of proof for each line of verified code a considerable overhead despite strong symbolic automation from smt solvers.
for smtassisted proof oriented programs we provide the first substantial empirical evidence that llms trained on corpora like fstardataset and prompted with retrieval augmentation can automate somewhere between a third and a half of proofs.
that said our approach focuses on synthesizing program and proof fragments given their specifications finding the right modular decomposition to prove a program correct with the right specifications and auxiliary lemmas is not yet within the scope of the techniques we explore.
viprovides further discussion and analysis.
we release fs tardatasetin microsoft fstardataset .
details of the project source code and models can be found in org popai ii.
b ackground we start by providing some general background on f adapted from its online manual.
f is a dependently typed programming language and proof assistant.
it encourages proof oriented programming a paradigm in which one codesigns programs and proofs which attest various aspects of a program s correctness including its input output behavior together with its side effects if any.
the core design philosophy of f is that the type of a program is a specification of its runtime behavior.
many terms can have the same type and the same term can have many types e.g.
e int states that the term or program fragment ereduces to an integer and e nat states that ereduces to a non negative integer where nat x int x is a refinement of type int.
when proving a program ecorrect one specifies the properties one is interested in as a type t and then tries to convince f thatehas type t i.e.
deriving e t. many dependently typed languages have the same core design however f is distinctive in that in addition to several built in type checking algorithms it uses the z3 smt solver to try to automatically prove various obligations that arise during type checking.
for example under the hypothesis that x even proving that x even where even x int x results in a query to z3 of the form x int .x x .
while in general the queries f presents to z3 are undecidable in practice z3 successfully automates a large number of the queries it receives.
however when z3 proof search fails the programmer must write additional lemmas and other proofs hints to decompose the proof into smaller pieces that can be checked by f and z3.
the concrete syntax of f is based on other languages in the ml family including ocaml and f .
shown below is a recursive implementation of quick sort together with its specification and proof of correctness.
the type of sort states that for any total order fon elements of type given an input list l list sort is a total function i.e.
it always terminates returning a list m list that is sorted according tofand where mis a permutation of l. the predicates like total order sorted is permutation etc.
are other auxiliary definitions in scope.
the implementation of sort mixes the computational behavior i.e.
partitioning the list based on a pivot recursively sorting the partitions combining and returning them with proof steps that attest to the correctnessof the code with respect to its specification.
let rec sort f total order t l list tot m list sorted f m is permutation l m decreases length l match lwith pivot tl lethi lo partition f pivot tlin letres append sort f lo pivot sort f hi in proof partition mem permutation f pivot tl append count lo hi append count hi lo sorted concat f sort f lo sort f hi pivot append count sort f lo sort f hi permutation app lemma pivot tl sort f lo sort f hi proof res for example the annotation decreases length l indicates that the recursion terminates because the length of the list input decreases at each recursive call.
additionally the source lines delimited by proof comment tags are calls to f lemmas auxiliary definitions that prove certain properties.
for instance the auxiliary lemma append count is shown below.
its type states that every call to append count l m x guarantees the postcondition described in the ensures clause or equivalently the type claims the universal property l m x .count x append l m count x l count x m .
the proof of this property is by induction on the list l expressed as a recursive function.
let rec append count l m list x lemma ensures count x append l m count x l count x m match lwith hd tl append count tl m x program and proof fragments like sort append count etc.
each constitute a top level definition in an f program.
each definition yields a type directed synthesis problem i.e.
given a goal type such as the first two lines of append count shown above can an llm generate a type correct definition.
to help the llm succeed we aim to augment the goal type with related information e.g.
the definitions of symbols such ascount append etc.
we evaluate the performance of various retrieval augmentation strategies and llms on this task.
iii.
a c orpus of proof oriented programs fstardatasetis an archive of source code build artifacts and metadata assembled from eight different f based open source projects on github summarized below with a focus on libraries that provide secure low level software and the tools that enable their proofs.
fstar the f compiler itself including its standard libraries and examples.
karamel a transpiler from a subset of f called low to c including libraries to work with a model of c types and control structures e.g.
for and while loops .
1many f examples including the ones shown here are similar to program proofs in languages like dafny or verus.
however f also allows other styles of higher order and dependently typed definitions that are not expressible in other smt assisted languages.
we refer the reader to the f manual for a full discussion of similarities and differences.
everparse a parser generator for binary formats used in various large scale systems e.g.
the windows kernel hacl a library of verified cryptographic algorithms including valecrypt a library of verified assembly code as well as evercrypt a cryptographic provider including code deployed in linux firefox and python.
mitls f a partially verified reference implementation of the tls protocol .
everquic crypto a verified implementation of header and packet protection for the quic protocol .
merkle tree a verified incremental merkle tree designed for use in azure ccf a confidential computing system .
steel a concurrent separation logic library with proofs of data structures and concurrency primitives .
the dataset will be available publicly as an open source repository referencing the other projects as sub modules including a given version of f itself.
all the projects are built with the same version of f and the z3 smt solver resulting in a single archive with all the source files and a build artifact for each of them i.e.
f s.checked files.
each checked file is accompanied by record of metadata about its contents for each top level element e.g.
the definition of a function or a type or a type signature the metadata records its dependences the compiler settings used to verify them etc.
reproducibility evolution.
we aim to strike a balance between reproducibility of the dataset while also encouraging the data set to grow and change along with projects it