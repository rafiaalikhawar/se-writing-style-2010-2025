an automatic refactoring framework forreplacing test production inheritancebymockingmechanism xiao wang xwang97 stevens.edu stevensinstitute of technology hoboken nj usaluxiao lxiao6 stevens.edu stevensinstitute of technology hoboken nj usatingting yu tingting.yu uc.edu universityof cincinnati cincinnati oh usa anne woepse anne.woepse ansys.com analyticalgraphics inc. exton pa usasunnywong sunny computer.org analyticalgraphics inc. exton pa usa abstract unittestingfocusesonverifyingthefunctionsofindividualunitsof asoftwaresystem.itischallengingduetothehighinterdependenciesamongsoftwareunits.developersaddressthisbymocking replacing the dependency by a fake object.
despite the existence of powerful dedicated mocking frameworks developers often turn to a hand rolled approach inheritance.
that is they create a subclass of the dependent class and mock its behavior through method overriding.
however this requires tedious implementation andcompromisesthedesignqualityofunittests.thisworkcontributesafullyautomatedrefactoringframeworktoidentifyand replace the usage of inheritance by using mockito a well received mockingframework.ourapproach is built upontheempiricalexperience from fiveopen source projects that use inheritance for mocking.
we evaluate our approach on fourother projects.
results showthatourframeworkisefficient generallyapplicabletonew datasets mostlypreservestestcasebehaviorsindetectingdefects intheformofmutants and decouples testcodefromproduction code.thequalitativeevaluationbyexperienceddeveloperssuggests that the auto refactoring solutions generated by our framework improvethequalityoftheunittestcasesinvariousaspects suchas makingtestconditionsmoreexplicit aswellasimprovedcohesion readability understandability andmaintainability withtest cases.
ccs concepts software and its engineering software testing and debugging softwaredesigntechniques softwaremaintenance tools maintaining software softwareevolution .
keywords software refactoring software testing permissionto make digitalor hard copies of allorpart ofthis work for personalor classroom use is granted without fee provided that copies are not made or distributed forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation on the first page.
copyrights for components of this work owned by others than acm mustbehonored.abstractingwithcreditispermitted.tocopyotherwise orrepublish topostonserversortoredistributetolists requirespriorspecificpermissionand ora fee.
request permissions from permissions acm.org.
esec fse august 23 28 athens greece associationfor computing machinery.
acm isbn ... .
format xiaowang luxiao tingtingyu annewoepse andsunnywong.
.an automatic refactoring framework for replacing test production inheritancebymockingmechanism.in proceedingsofthe29thacmjointeuropean software engineering conference and symposium on the foundations of softwareengineering esec fse august 23 28 athens greece.
acm newyork ny usa 13pages.
introduction software testing is a critical element of software quality assurance .
unit testing is an important phase of testing that focusesonindividualunitsofasoftwaresystem .auniquechallenge to unit testing is that software elements are inter dependent on each other .
that is when testing one function we have toconsideritsdependenciestootherfunctions.thishindersour ability to test easily and promptly.
for example the function under test fut maydependonanexternaldatabasethathasnotbeen deployed.this challengealso appliesto debugging ifaunittest fails it is unclear whether the failure is caused by the fault in fut orits dependent functions.
a general methodology to address this challenge is isolating the corefutfrom its dependencies throughmocking i.e.
replacing the dependencyby a fake object.
for example instead ofwaitinguntiltheexternaldatabaseisdeployed developerscreate a fake database with dummy data populated in a local file system andcontrolitsbehaviortoserveforthetestingpurposes.thereare variousdedicatedmockingframeworks suchas easymock mockito andpowermock which provide well constructed solutions to isolatefutfrom its dependencies.
specifically they provide powerfulfunctionsallowingdeveloperstoeasilycreatemockobjects control their behavior and verify the execution status of the mock objects.theseframeworksworktogetherwithclassicautomated unittestingframeworks such as junit andpyunit .
despitetheexistenceofpowerfulmockingframeworks developersoftenturntoa hand rolled approach inheritance .that is tocreatea fake object developerscreateasubclassofthedependent production class and control its behavior through method overriding.
for example in the nineopen source projects examined inthis study section .1and section .
developers already adopt an existing mocking framework for testing their systems.
however in about half of the cases when mocking is potentially needed developers still use inheritance instead of using a mocking framework.
the problem is that inheritance is not intended esec fse august athens greece xiaowang lu xiao tingting yu anne woepse sunny wong for mocking.
as such it requires tedious implementation when being used for this purpose.
in addition it may compromise the designqualityofunittestsandleadtomaintenancedifficultiesin the test cases .
more specifically as illustrated in section2 inheritance has the following drawbacks compared to usingamockingframeworksuchasmockito implicittestconditionandblurredtestlogic difficult to maintaintestcodethat coupleswiththeproductioncode and3 incohesivetestdesignthat separates the mocking behavior from the test case that leverages it.
thegoalofthisworkistodevelopafullyautomatedrefactoringframeworktoidentifyandreplacetheusageofinheritancebyusingmockitoformockinginunittesting.
wechoose mockitobecauseitisoneofthemostwellreceivedmockingframeworkforjavaprojects .itisadoptedinbothcommercialand open source projects .
the key challenge is to preserve the test behaviors before and after the refactoring.
to overcome this challenge wefirstconductanempiricalstudy section involving fivereal life open source projects as the learning dataset.
the goal is to gain empirical experience of whether it is feasible and how toperformrefactoringfollowinganautomatedprocedure.based on the empirical observations we formalize the problem definition ofauto refactoringtoreplaceinheritancebyusingmockito section4 .
next we propose a fully automated refactoring framework and implement it as an eclipse plugin section .
this framework firstidentifies allfeasible refactoringcandidates and then performs the refactoring oneachcandidate for agiven project.
we perform both quantitative and qualitative evaluation section6 of the proposed framework using another fouropen source projects.
the quantitative evaluation shows the general applicability overall reduced code complexity high test case behavior preservation and efficient run time performance of the refactoringframework.thequalitativeevaluation participatedbyexperienced full timedevelopers provesthattheauto refactoringsolutions generated by our approach are of good designqualityand providevariousbenefitsfor improvingtest code design.
in summary this work makesthe following contributions anempiricalstudyinvolving fiveopen sourceprojectsinvestigatingwhetheritisfeasibleandhowtoautomatically replace inheritancebymockitofor mocking.
a fully automated refactoring framework and its eclipsepluginimplementationtoidentifyfeasiblerefactoringcandidatesandperform the refactoring oneachcandidate.
quantitativeandqualitativeevaluationoftheproposedframework onfouropen sourceprojects.
backgroundand motivation thissectionintroducesthebasicconceptsofunittesting andan motivating example comparing the difference between mocking throughinheritanceandthroughmockito.
.
unittesting unit testing aims at validating that each unit of function performs asexpected .theunittestcodeiscomposedof testclasses test cases andtest suites .
atest class is similar to a production class.
atest class contains one or more test cases.
eachtest case focuses on verifying the behavior of a certain unit of function e.g.
method in the project.
a test caseshould follow the aaa arrange act assert pattern arrange for setting up required testenvironment actforinvocationofthefunctionbeingtested and assert for checking whether the expectations were met .
a group of test cases for testing related functions are grouped and executedtogetheras a test suite.
the interdependence among software units hinder our ability to perform unit testing.
a key for creating high quality easy tomaintain and debugunittest cases isto isolate thecore futfrom its dependencies.
in practice this is achieved through mocking replacing the dependency bya faked object.
.
a motivating example inane commercesystem customerservice definesaservice subscribecustomer tosubscribecustomersbyemail.thisservicedepends on another class emailmanager which is responsible of managing and sending emails.
its method subscribe first sends an email to the customer to confirm the address once confirmed it stores the email address in a database.
another method sendemail sends email through an external server.
we aim to test the logic ofsubscribecustomer incustomerservice .theproblemisthat its dependencyfunctions emailmanager isnotfullyimplementedyet neither the database nor the external service is available.
thus we isolatethe fut subscribecustomer fromitsdependency emailmanager by mocking the latter.
next we illustrate mocking through inheritanceandmockito .
.
mockingbyinheritance.
inheritanceisamechanismtoderive asubclassfromabaseclass.thesubclassinheritstheattributesand methodsofthebaseclass.meanwhile methodoverridingallows the subclass to replace certain method implementation of the base class.
inheritance is used as a hand rolled approach for mocking.
developersdefine a testsubclass to mock certain behaviors of the production class through method overriding or interface implementationfor testing.
in figure 1a mockemailmanager extendstheemailmanager line1 .theformermocksthebehaviors subscribe andsendemail ofthelatterthroughmethodoverriding.twonewprivateattributes subscribed line and num line are defined for tracking the executionofthetwooverriddenmethods.thatis subscribed isset to betrue line when subscribe executes while numincrements line each time sendemail executes.
of particular note since thelogicdefinedinthissubclasspreparesmockingbehaviorsfor the unittest case itispart of the arrange inthe aaa pattern.
thetestcase testsubscribecustomer followsthe aaa pattern.
first itarrangestheenvironmentfortesting.thisincludescreating aninstanceof mockemailmanager emailmanager line15 and creatinganinstanceof customerservice myservice whichisthe fut.
next it acts the fut line and line .
lastly the test case asserts the value of subscribed andnumwithmockemailmanager line and .
they confirm that subscribed istrue indicating methodsubscribed isexecuted andthat numequals2 indicating that two emails are sent one asks the customer to confirm the othersends aconfirmationof subscription .
.
.
mockingbymockito.
mockitooffersthreeaspectsofcapabilities for mocking.
first mockito allows easy creation of a mock 541anautomatic refactoring framework forreplacing test productioninheritanceby mockingmechanism esec fse august athens greece a mocking by inheritance b mocking by mockito figure amotivatingexample object as a mock or a spy .
the mock is a completely faked objectandisentirelyinstrumentedtotracktheinteractionswithit.
incomparison the spy wrapsarealinstanceofthemockedobject.
the spy should be used when the execution of real methods is necessaryintesting.second mockitoofferslight weightedmethod stubbingforcontrollingthebehaviorsofthemockobjectfortesting purposes.
mockito provides dedicated syntax for different types ofbehavior i.e.avoidmethod areturnmethod oramethodfor throwing exceptions.
third mockito provides explicit mechanism forverifyingthebehaviors statusofthemockobjects.forinstance mockito can ensure whether a mock method is being called or not check on the number of calls made on a particular method and take care ofthe order ofcalls etc.. infigure 1b mockitodirectlycreatesa mock ofthe emailmanager line since the goal is to avoid its real execution and focus on its interactionswith subscribecustomer .
in line we stub themockingbehaviorwhen subscribe isinvoked.the sendemail shoulddonothing sincewewanttoavoidsendingrealemails.thus thereisnoneedtostubit.actingthe fut line31andline32 remains thesameasusing inheritance.
finally in line 33and we directlyverifythe executionof subscribe andsendemail .
.
.
benefits of mockito over inheritance.
mockito enables explicitandeasytounderstandtestinglogic.itallowseasycreation ofmockobjectsfordifferentlevelsoffunctionisolation i.e.
mock and spy .
the verifyfunctions in mockito provide an explicit mechanism for checking the execution and status of the mock objects.incomparison inheritancerequiresthedevelopertomanually craft additional attributes features in the subclass for tracking the execution of the mock objects.
for example new attributes subscribed andnum are used to keep track of method execution in the mock object.
the logic behind the attributes is implicit and mayblurthe testinglogic.
mockito decouples test and production code to ease the maintenance of the test code.
renaming methods interfaces or reorderingparameters in the production code will not break the test code sincemockitowiresthemockobjectsatrun time.incomparison inheritance relationship increases the coupling between the test andproductioncode.thisunnecessarilycripplestheinheritancehierarchyandincreasesmaintenancedifficulty.whentheproduction code changes its subclasseshave to changeaccordingly.
mockitoimprovesthecohesionoftestdesignbyenforcingthe aaa pattern of unit test case.
method stubbing through mockito cohesively associates with the mock object when it is arranged inthetestcase.incomparison ininheritance themockbehavior which is part of the arrange is defined in a separate subclass throughmethodoverriding.itisdetachedfromwherethebehavior isusedfortesting.thisincreasesthecognitiveloadforunderstandingthe test behavior.
empirical study we first conduct an empirical study to investigate whether it is feasible andhowto automaticallyreplace inheritancebymockito.
.
dataset weselect fiveopensourceprojectsasourempiricalstudysubjects they are dubbo druid accumulo cayenne and cloudstack .
we select these projects because first they are popularopensourceprojectsfromdiverseproblemdomains.second test production inheritance is common eachproject contains cloudstack to druid test subclasses for mocking.
thirdly weareabletorunthetestcasesintheseprojects whichisimportantforverifyingthecorrectnessofthemanualrefactoring.most importantly theseprojectsalready use mockito.
.
studyprocess foreachcasewhereatestsubclassinheritsorimplementsaproduction class or interface we investigate the following questions can wemanuallyrefactor the inheritance byusing mockito basedon our understanding?ifso istherefactoringprocessautomatable?ifnot what is the reason that makes the refactoring and the automation infeasible?
oneauthor thedriver manuallyreviewsandrefactors each test subclass and the research team meets weekly to inspect anddiscuss the manual refactoring solutions if the manual refactoring is not feasible or not successful the driver recordsdetailedreasons.
for each refactored case the driver summarizes the key refactoring steps and determines whether the refactoring procedurecanbeautomated.ifautomationisnotpossible the driver recordsthe reasons.
intheweeklymeetings theteam i discussandimprovethe manual refactoring solutions and ii discuss and define the auto refactoring problem formalization.
.
findings overall ofthetest productioninheritancecasesinthe empiricalstudycanbepotentiallyrefactoredautomatically.this non trivialportionofcasesmotivatethedesignof ourautomated refactoringframework.later itisconfirmedthatthese25 cases canindeedberefactoredfullyautomaticallybyapplyingourimplementedrefactoring framework section .
542esec fse august athens greece xiaowang lu xiao tingting yu anne woepse sunny wong table manual refactoringdatasets proj.
subcl.
succ.others infeasible not auto exec.iss.
dubbo druid accumulo cayenne cloudstack sum figure illustrationofrefactoring table1shows the details.
the first column proj.
lists the projectnames.thesecondcolumn subcl.
indicatesthetotal numberoftestsubclassesinaproject.thethirdcolumn succ.
shows the total number percentage of test subclasses that can be successfully replaced by using mockito.
that is the refactoring of cases from the five projects can be automated.
the othercasesareinthreecategories therefactoringisnotfeasible column infeasible .eithercertaindesignfeaturesintheinheritancearenotsuitableforrefactoring ortherearedetailedtechnical issues that prevent the refactoring.
although manual refactoring is feasible full automation of the refactoring is not possible column not auto becauseofthecomplicateddesignoftheinheritance that requires case by case understanding for refactoring.
for example some test subclass contains an inner class definition.
refactoringrequiresin depthunderstandingoftheinnerclass.and therefactoringisnotsuccessfulduetoissueswithtestexecution column exec.iss.
.inthesecases weeitherhaveissuesexecuting related test cases or the test behavior changes after refactoring for reasons that require case by case investigation.
problem formalization based on the successful refactoring cases from the empirical study weformalizetheauto refactoringproblem.itisaconversion from the left sideto the right side refactor codeinheritance code mocking.
.
beforerefactoring arefactoringcandidate codeinheritance canbeabstractedasatriad codeinheritance testsubclass productionclass testclass here testsubclass extends the productionclass .
thetestclass leverages testsubclass to assist testing.
the left side code snippetsinfigure 2illustrates the formalizationof codeinheritance .thetestsubclass is further consisted of four key elements the convention indicates that there is zero or more of a design element .theupper leftcodesnippetillustratesanexample testsubclass.
testsubclass constructor creates a testsubclass instance.
attributeisfor trackingthe executionof testsubclass .
overriddenmethod defines dummy implementation of a functioninproductionclass .
privatemethod definesadditionalfunction in testsubclass .
atestclass leveragesthe testsubclass fortesting whichcanbe formalizedas following testclass testcase atestclass containsatleastone testcase.atestcase involves atestsubclass in two parts for fulfilling the testing goal construction whichinvokesa constructor oftestsubclass tocreatean instance and reference which accesses the attributes or call the methods of the instance.
the lower left code snippet of figure illustrates asimpleexample.
.
after refactoring theoriginal codeinheritance isrefactoredinto code mocking which eliminates testsubclass andreplaces itbyamockobject code mocking productionclass testclass thustestclass becomes testclass and each testcase in it becomestestcase testclass testcase asillustratedintheright sidecodesnippetinfigure testclass iscomposedof testcase and .the isthe movedfrom testsubclass totestclass .and each refactored testcase is consisted of to create amockobjectofthe productionclass whichreplacestheinstance created by intestcase which replaces the intestsubclass and to the mock object which replaces the respective to thetestsubclass instance in testcase.
we will explain the formal refactoring procedure insection .
.
refactoring framework theauto refactoringframework implementedasaneclipse plugin1 addresses the above formalizationwithtwocomponents identifying refactoring candidates.
after loading a project in eclipse a user first selects the scope e.g.
the entire project a package or a group of files from which refactoring candidates shouldbe identified.the identificationrelieson the ast parser of eclipse jdt to filter out cases that cannot be refactored based onthe detailedcode syntax.
543anautomatic refactoring framework forreplacing test productioninheritanceby mockingmechanism esec fse august athens greece table refactoringcandidate identification filters id filter criterion what condition to lookfor?
rationale why isit notfeasible automatable?
f .
a testsubclass implements multiple production interfaces.this indicates that the testsubclass mocks multipleproduction interfaces.
mocking multiple productionclasses isnotrecommended .
f .
a testsubclass overrides jdk apis particularly hashcode orequals .
only mock types you own avoid mocking jdk apis.
plus mocking thetwoapis will break mockitosince it isbuilt upon them .
f .
a testsubclass defines a newpublicmethod this method is notin theproductionclasses .thetestsubclass no longer mocks the productionclasses when it containsextra new behaviors.
f .
a testsubclass hasself reference e.g.declaring itselfasanattribute .self referenceimpliesself mocking amockobject cannot mockitself.
f .
a testsubclass containsa method that returns a generic type .thegeneric type indicates uncertainmocking behavior a mockobject should have certainbehavior.
f .
a testsubclass isnotinstantiated through its constructor.thetestsubclass isnotused anywhere noneedto mock or is instantiated through dynamic binding thus cannot use mockito .
f .
a testsubclass containsspecial code annotations theannotations are mostly project specific or from a speciallibrary .
mockitodoesnotsupportthem.
f .
a testsubclass hasexternal access to a protected attribute method in theproductionclass .mockitodoes not support the access to protected elements.
this requires a more powerful framework suchaspowermock f .
a testsubclass instance is passed as aparameter across multiple test cases methods in a testclass .it requires manual effort to create a good test design where a mock object and therelated variablespass alongtest casesand methods.
f .
a testcase createsand uses acollection e.g.setor map oftestsubclass instances.itrequiresmanualeffort to create a goodtest designwitha collection of mockobjects and thevariablesthat associate witheach mockobject.
f .
a testsubclass containsan inner class definition.
itrequiresmanualunderstanding to properlyrefactor theinnerclass.
refactoring each candidate.
the tool will notify users the listofidentifiedrefactoringcandidates i.e.sub classes .theuser needs to select a candidate to proceed with the refactoring.
the implementationofrefactoringreliesonthe astrewrite mechanism oftheeclipsejdt .
next we introduce the details ofeachstep.
.
refactoring candidate identification based on the empirical study we construct a taxonomy of exclusion criteria to automatically exclude test subclasses that do not match the problem formalization i.e.
those that are not feasible to refactorortherefactoringcannot beautomated.intable we list the detailed filtering conditions column as well as the rationaleofeachfilteringcondition column3 .forthesakeofclarify weorganizethe11filteringconditionsinthreegenerallayers layer1 f .1tof .5 whichexcludescasesthatarenotsuitable formocking layer2 f .1tof .3 whichexcludescasesthat cannot be refactored due to detailed implementation limitations withmockito and3 layer3 f .1tof .3 whichexcludescases withcomplicateddesignthat cannotbe refactoredautomatically.
.
auto refactoring procedure figure3showstherefactoringproceduretoconvert codeinheritance tocode mockingforeachrefactoringcandidateidentifiedfromthe previous step.our approach involves five logical parts createmockobject thisstepconstructsamockobjectusing mockito to replace the testsubclass instance and ensures that they have equivalentinitialstatus.
preservemockingbehavior thisstepextractstheoverridden methods and moves the private methods in testsubclass to ensurethatthemockobjecthasequivalentbehaviorasthe testsubclass instance.
preservereferencestothemockobject thisstepensuresthat theexecution verificationofthemockobjectisequivalent to that ofthe testsubclass instance.
infrastructure procedure translatetomocking this procedurecross cutsthethreepreviouspartstoensurethatthe refactoring followsthe mocking syntax.
createmockmethod for code reusability this applies when multiple test casescould reuse the mockobjectcreation.
in the following subsections we will explain each part in detail.
.
.
step1 createmockobject.
thisstepcreatesamockobject using mockito to replace the testsubclass instance.
to ensure that the initial status of the testsubclass instance and themock object are equivalent the following three sub steps are performed step .
replacetestsubclass instance creation by mock objectcreation.therearetwowaystodoso through spyormock asillustratedinfigure 4aandfigure 4b respectively.
spycreates a real object while mockcreates a complete mock or fake object.
based on the empirical study if the productionclass is an interface without any method definition we should use mock since an interface cannot be instantiated as a real object.
in comparison if theproductionclass hasmethodimplementation weshoulduse spy to ensure that the mock object has the same behavior as the real object except for the purposely stubbed methods.
there are other minorsyntax variations for spyandmock summarizedhere2.
step .
extract the attributes oftestsubclass totestclass .
this ensures that the status of the testsubclass instance is preservedforthemockobject.weobservedtwotypesof testsubclass attributes from the empirical study whichare treateddifferently.
thefirsttypeofattributeisthe counter checker asshowninthe motivatingexampleinfigure .theseattributesarefortracking the execution of the mock object.
we recognize the type using threeheuristics itisa booleanoranint itisonlyread written in a certain methods of the mock object and it is asserted for checkingtheexecutionoftheassociatedmethods.mockitohasa designated mechanism mockito.verify for verifying its execution.
thus thereisnoneedtopreservethistypeofattributes.instead we 544esec fse august athens greece xiaowang lu xiao tingting yu anne woepse sunny wong figure automated refactoringprocedure a spy and doanswer b mock and thenanswer figure mockobjectcreation andstubmethod justkeeparecordofthetrackedmethodsandverifytheirexecution laterusing mockito.verify to replace the assertions.
the other type of attributes are in diverse types and could be referenced anywhere in testclass.
the way that we extract such an attribute from the testsubclass totestclass depends on how testsubclass is originally used in testclass.
more specifically if thetestsubclass instance is an attribute of the testclass the attributeof testsubclass willbecomeanattributefor testclass to ensure the same access scope.
otherwise if the testsubclass instance is createdas a local variable insidea testcase the attribute oftestsubclass willbecome alocal variable in testcase .
step .
extract the constructor logic from testsubclass to .this ensures that themock objecthas equivalent initial status as the testsubclass instance.
if the testsubclass instanceiscreatedusingadefaultconstructor thisstepcanbeskipped.
iftestsubclass instance is created using a non default constructor which comes with additional settings for the created instance theconstructorlogicneedstobeextractedto .each statementintheconstructorneedstobetranslatedtofollowthesyntax after the refactoring.
here an infrastructure procedure named translatetomocking takesthecodebodyoftheconstructorasinput and translates each statement following the mocking syntax.
since translatetomocking cross cutsallthreelogicstepsoftherefactoring procedure we willintroduce its details insection .
.
.
.
.
step2 preservemockingbehavior.
thispreservesthemockingbehaviorsbytreatingthe overriddenmethods andprivate methods inthetestsubclass step .
extract the overriddenmethod intestsubclass tothe stubmethod which directly associates with the mock object created used in testcase .
there are two common ways to stub a method doanswer andthenanswer .
thethenanswer addsadditionalactions to the stubbed method .
it ensures type safety thusshouldbepreferredwheneverpossible.while doanswer entirely replacestheoriginal method behavior working similar to method overridden in inheritance.
based on empirical experience thenanswer workswithobjectscreatedusing mock whilethe spyobjectshouldworkwith doanswer topreservethe overridden behavior.
figure 4illustrates doanswer in figure 4a line to line andthenasnwer in figure 4b line to line respectively.
they are used to replace the overridden methods between line to line7infigure 4aandinfigure 4b.inaddition therearespecific methodstubbingsyntaxfordifferentkindsofbehaviors summarizedhere2.forexample doreturn andthenreturn areforstubbing methodsthat justreturn certainobjects.
note that the internal logic of the overridden methods in figure4is straightforward i.e.
without referencing attributes or methods in the testsubclass .
thus we can directly move them to thestub methodblocks.if theinternallogic hasareference tothe testsubclass attributes methods wealsoneedtouse translatetomockingprocedure to convertthe syntax before moving.
step .
moveeachprivatemethodfrom testsubclass totestclass .thesemethodmovementscannotbedirectlycopy and paste due to the overall syntax change.
similarly we use the translatetomockingprocedure toconvert the methodsyntax whenmovingit.
in addition the methodsignature mayneedtobe updatedaccordingly totakeadditionalinputparameters foraccessingthelocal variables in testcase whichwere the attributes in testsubclass .
.
.
step3 preservereferencetothemockobject.
inatestcase therecouldbereferencestotheattributesand ormethodsofthe testsubclass instance as suchthe instanceis created forfacilitatingtesting.toensurethatthebehaviorof testcase andtestcase remains consistent we need to preserve these