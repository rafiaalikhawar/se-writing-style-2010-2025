securitycodesmells in apps arewegetting better?
stevenarzt steven.arzt sit.fraunhofer.de fraunhofer sit athene nationalresearchcenter for appliedcybersecurity darmstadt hessen germany abstract usersincreasinglyrelyonmobileappsforeverydaytasks including security and privacy sensitive tasks such as online banking e health and e government.
additionally a wealth of sensors captures the movements and habits of the users for fitness tracking and convenience.
despite legal regulations imposing requirements andlimitsontheprocessingofprivacy sensitivedata usersmust still trust the app developers to apply sufficient protections.
in this paper weinvestigatethestateofsecurityinandroidappsandhow security related code smells have evolved since the introduction of the androidoperatingsystem.
with an analysis of apps per year over years between 2010and2021fromthegoogleplaystore wefindthatthenumber of code scanner findings per thousand lines of code decreases over time.
still this development is offset by the increase in code size.
apps have more and more findings suggesting that the overall securitylevel decreases.thistrendisdrivenbyflawsintheuseof cryptography insecurecompilerflags insecureusesofwebview components and insecure uses of language features such as reflection.based onour data we argue forstricter controls onapps before admission tothe store.
ccsconcepts securityandprivacy software andapplicationsecurity software and its engineering software verification and validation.
keywords android apps statistics security programanalysis acm referenceformat stevenarzt.
.securitycodesmellsinapps arewegettingbetter?.in proceedingsofthe30thacmjointeuropeansoftwareengineeringconference andsymposiumonthefoundationsofsoftwareengineering esec fse november 14 18 singapore singapore.
acm new york ny usa 11pages.
introduction mobileappshavebecomeanaturalpartofmoderneverydaylife.
more and more tasks can be performed online via an app without the need for physical contact.
users can check their bank account esec fse november 14 18 singapore singapore copyright held bytheowner author s .
acm isbn978 .
transfer money talk to a physician manage drug prescriptions find romantic partners or even vote via their phones.
at the same time a multitude of sensors provide the user with location specific personalized recommendations for restaurants or automatically display the right passes when they arrive at theaters or airports.
some devices even provide medical data for fitness trackingande health applications.
whileintegratingsuchfeaturesintoasingleextensibledevice and platform is convenient it also poses challenges for privacy andsecurity.attackersmaystealidentitiesandmoney blackmail the user or abuse profiles for judging prospective customers or employees.legalregulationssuchastheeuropeangdprimpose limitations and requirements on the processing of personal data but users must still trust the app developers to correctly apply these principles.
even in the case of benign apps programming mistakes can easily lead to security violations.
with the binary file alone assessingthequalityandsecurityofanappischallenging.
it requires tools and skills not commonly available to the end user.
therefore app developers must ensure to constantly improve their level of security to match the requirements that come with the evolving functional use cases and to retain user trust.
we stress that security updates are necessary even if the feature set of an app doesnot evolve as new attack patterns are invented.
furthermore cryptographic algorithms become outdated over time as the computational capabilities of computers and thus attackers become stronger.
app developers need to adapt key sizes and replace algorithms that are nolongerconsideredsecure.
in this paper we investigate how the level of security in mobile apps has evolved over the past years whether critical issues are prevalent andwhetherdeveloperssucceedinreducingthenumber andseverityofcriticalissuesovertime.wefocusonandroid which is the most prevalent mobile operating system with market share as of october .
its official app store the google play store contains around .
million apps2as of november .
while some of the apps are developed and maintained by large it organizations with professional development teams this is not a requirement for admission into the store.
smaller companies and individual developers also account for a significant number of apps in the store.
despite this openness the play store does not enforce an explicit code or architecture review before an app is made available tousers.
the play store applies technical level checks based on static and dynamic code analysis mainly to prevent uploads of malicious apps .thedetailsoftheseapproachesarenotdocumentedby the storeoperators tonot give attackersanadvantageinavoiding detection.
still they miss novel malware .
detecting sloppy programmingandmistakesinotherwisebenignappsthatdonot thisworkislicensedunderacreativecommonsattribution sharealike4.
internationallicense.
esec fse november14 18 singapore singapore stevenarzt exhibit common traces of obfuscation and exploitation is even harder.varioustoolsfordetectingindividualtypesofvulnerabilities orprivacy issues have beenproposed .still to thebest of our knowledge no large scale study has been conducted over the play store andits developmentover the years yet.
we therefore argue that the level of security and privacy that users can expect from an app in the store is unclear and that users must currently trust the developers and the ecosystem to evolve overtime.inthispaper weconductalarge scalestudyintowhether and how the security level in the google play store has evolved between and2021.
we download a statistically significant number of randomlypicked samplesfrom thegoogleplay store for each year between 2010and2021toinvestigatethedevelopmentofsecurity related code smells srcss throughout the store.
while srcss are not equivalent to exploitable security vulnerabilities they indicate trends on patterns best practices and paradigms that developers use.
for example developers can avoid outdated cryptographic algorithms even if the output is only used as a unique database id whichisnot security sensitive.
notethatwedonotanalyzethedevelopmentofanindividual appovertime.wefindthattheoverallnumberofsrcssperappincreases suggestinga decreaseinthesecuritylevelofappsovertime.
this increase in srcss is mainly driven by cryptographic weaknesses such as the use of insecure algorithms insecure compiler flags for native libraries insecure uses of webview components forrenderingwebapplicationsinsideapps andcodesecurityflaws suchasaccessestoprivatefieldsandmethodsusingthejavareflection api.
as we show while the number of srcss per thousand linesofcodedecreasesovertime suggestingthatcodequalityis getting better this effect is outset by the large increase in app size.
we make available an anonymized version of our data set together with the sql statements used for this evaluation.
we hope thatourdataallowsotherresearcherstovalidateourresults andto conductownlarge scaleresearchonthesecurityofandroidapps.
theremainderofthispaperisstructuredasfollows.insection we present the design of our study followed by a discussion of the limitations in section .
we present the the results of our investigation in section .
in section we discuss our results and draw conclusions.
in section we discuss related work before concluding the paper insection .
studydesign for our study we selected apps per year for the years between and from the google play store i.e.
apps intotal.the apps weretaken fromandrozoo .we selected the apps irrespective of the category i.e.
our sample set approximates thecategorydistributioninsidetheandrozoodataset andthus transitivelyinside the play store .
eachapkfilewassubmittedtothevusc4commercialvulnerability scanner in version .
.
vusc is based on soot and usesthedexpler componenttotranslatethebinaryappcode intothejimpleintermediaterepresentation .afterwards vusc findingtypespercategory category findingtypes app certificates backendcredentials backup buildparametrization code quality cryptography dynamiccode loading general inter componentcommunication java code security libraries sharedpreferences sql databases logging network permissions potentiallymalicious storage userinterface websecurity performsstaticanalysisonthejimplecodetodetectsecurityvulnerabilities.
in case the definition of a particular vulnerability is basedondataflows e.g.
forinjectionvulnerabilities vuscinvokes flowdroid .
on average vusc was able to successfully analyze 285outofthe300appspearyear.ontheremaining15apps vusc failedanddidnot deliver any results.
vuscscansfor377differenttypesoffindingsin19categories.
table1showsthenumberofvulnerabilitytypessupportedbyvusc percategory.sincethisstudyfocusesonsecurityvulnerabilities wedisabledthe codequality category.thesechecksusuallylead to many findings and increase the time required for the analysis withoutcontributingto the core research questionsof this paper.
we find the permissions category to include cases in which other apps installed on the same device can trigger android api actionsthatareguardedbypermissionsthroughthevulnerableapp without needing to have the respective permission on their own confuseddeputyattack .however thesepermissionsarealmost always non critical ones such as internet access.
in contrast to dangerous permissions normal ones are granted to all apps that request them at installation time without prompting the user5.
these permissions are requested so frequently that prompting the user is infeasible and granting the permission entails little risk.
sincethescannerreportslargeamountsofsuchissues wechoseto removethiscategory.weacceptthatwemayexcludesomerelevant confused deputyattackswiththis designdecision.
vuscusesanattackermodelinwhichotherappsonthesame device are considered potentially malicious.
therefore if an app writes sensitive data into a publicly readable file i.e.
a file that can be accessed by all apps on the device this is reported as a vulnerability.
this designdecisionofmutually distrusting apps is compatible withandroid sconcept of app isolation.
246securitycode smellsin apps are we getting better?
esec fse november14 18 singapore singapore inourstudy weuniquelyidentifyeachapp i.e.
concreteapk file of a particular version using the sha256 hash over the apk file.
we make the list of sha256 hashesof all apps in our analysis publicly available.
for identifying different versions of the same app we relyonthepackagenamefromtheandroidmanifestfile.
the play store also uses the package name to uniquely identify an app regardless ofthe version.
note that our data set consists of independent app sets for each year.wedonottrackindividualappsovertheyears i.e.
updates of the same app.
instead we approximate the security status of the overall play store using statistics on the individual year based sets andcomparethesenumbersovertheyears.wediscusshowapps evolve ingeneral andnot howaparticularapp evolves.
threats to validity for each year between and we obtained a set of apps from androzoo.
we filtered theandrozoo data set using the modification date of the dexfile in the app to build one set of apps peryear.notethatwedidnotconsidertheageoftheapps i.e.
when they were first introduced into the store or when they received their most recent update within that year.
consequently two apps fromadjacentyears e.g.
onefromdecember2014andonefrom january2015 maybetemporallycloser albeitplacedindifferent buckets than two apps from the same year e.g.
january and october2015 albeitplacedinthesamebucket.weacknowledge that years are not a fully precise measure for how recent a certain app version is.
since we analyze apps per year and since we consider12yearsintotal weassumethatsucheffectsdonotaffect the results of our study.
we further assume that the year extracted fromthe dexfiledateprovidedbyandrozooisprecise.mistakes in the metadata from the androzoo data set may affect the results ofourstudy.wefoundonecaseinwhichthesameapp identical hash wasassociatedwithtwoyears.
the findings reported byvuscrepresentsecurity relatedcode smells srcss thatneednotnecessarilybeexploitable.ifanoutdated hash algorithm such as md5 for example is used only to generate unique ids based on the data security properties such as preimage resistance are not relevant.
without a deeper analysis however thefindingisindistinguishablefrom e.g.
apasswordhash.
nevertheless we consider srcss as relevant for identifying trends as they show whether developers continue to use outdated patterns orwhethertheyswitchtoupdatedcodingpatterns.asfuture work we suggest to augment our analysis with manual reverse engineering or penetration testing or with dynamic automated approaches such as guided fuzzing to more precisely study the security implications of the srcss and to confirm whether the trend insrcssalsoimplies atrend inoverallapp security.
weonlyuseasinglevulnerabilityscannerinourstudy which makes our data inherit the false positive and false negative rate of that scanner.
we assume that such issues equivalently affectall partialdatasets i.e.
eachyear andthereforedonotaffectthetrends reported in this paper.
manual investigation showed that many identified srcss stem from simple code patterns.
cryptographic algorithms forexample areusuallyspecifiedasconstantstrings passedtofactorymethods.we therefore consider theriskoffalsepositives or false negatives to be sufficiently low.
we call upon the community to validate our results withotherscanners.
ourdatasetonlycontainsappsreleasedonthegoogleplaystore whichalsoevolvesovertime.ifacertaintypeofsrcsdecreases overtime thismaybecausedbythestorecheckingfortheissue andnotacceptinganynewappsthatcontainit .lastly weonly focus on srcss that can be found by automated code scanners and not e.g.
conceptualweaknessessuch as missingauthentication.
we use vusc to distinguish between app code and library code.
anandroidappconsistsofasingleapkfilewithalllibraryclasses compiled into the same file.
vusc contains a mapping between known libraries and the package names of all classes contained in them generated from jars crawled from maven central.
this comparisonfailsforobfuscatedapps inwhich class and package names have been changed but a manual spot check indicated that only few apps are obfuscated in our data set.
integrating a more reliable approach for library detection isfuture work.
evaluation in this section we presentthe results of our statistical analysis on the evolution ofthe security of apps inthe google play store.
.
research questions inthissection weevaluateourdatabasedonthefollowingresearch questions rq1howdoes the totalnumber of srcssdevelop over time?
rq2whichcategoriesofsrcssshowasignificanttrendandwhich are the mostrelevantsrcssinthat category?
rq3which individual types of srcss occur most frequently over allcategoriesanddo they showasignificant trend?
for rq2 we focus on the categories that exhibit clear trends cryptography build parameterization backend credentials java codesecurity andstoragesecurity.theothercategoriesfromtable1show no such trends.
the numbers increase and decrease between the years with no clear pattern.
the numbers in the potentiallymalicious categoryaregenerallylow becausethevusc scannerfocusesonsrcssinbenignappsandthereforeonlyhas limited capabilities in detecting potentially malicious behaviors such as smsmessagesto premium rate numbers.
.
baseline statistics toput therawdatafrom thesrcssintoperspective wecompute thenumberofclasses methods andunits statementsinthejimple representations ofeachapp.foreachyear wecomputetherespectiveminimum average andmaximumofallthreemetrics asshown in table2.
we observe a significant spread in the app sizes within the same year as the median numbers for classes methods and jimplestatementare muchsmallerthanthe respective averages.
we use the number of jimple units as the main measure for the code size.
it correlates with the number of instructions in the app s dalvikbytecode.ourdatashowsthattheaveragenumberofjimple units increases by a factor .
between and which is similar to the factors for method .
andclass .
increase.
wepickedthe300appsrandomlyforeachyear.still thepicks are not independent because many apps stay in the store for more thanoneyear i.e.
thesameapporanupdatedversionthereof may 247esec fse november14 18 singapore singapore stevenarzt table app sizestatistics peryear year classes methods units minavgmedian maxminavgmedian maxminavgmedian max be picked again for a later year.
to evaluate the impact of such duplicate picks on our study we compare the package names of all apps in our sample set.
recall that the play store uses the package nameto uniquelyidentify an appand that the package name does not change between two versions of the same app.
in cases wefindthatdifferentversionsofthesameappwerecollectedfor differentyears.wefind52casesinwhichayear sdatasetcontained atleasttwoversions ofa particular app .
of allapps .fromthe apk files in total this amounts to apps with the same package name .
.
with these few duplicates we consider our samples as nearly statistically independent.
we did not remove theseduplicatesfrom the data set.
.
rq1 overallsecuritytrend figure1shows the development of total number of srcss over all apps of a particularyear overthe years inthe dataset.
the red square dots show the srcss over all categories except for permissions see section .
we connected the dots to better visualize trends.
the blue dots show the average number of jimple units per appasameasureforthecodesize.asidefromtheoutlierpeakin weobservethatthenumberofsrcssgrowsovertime e.g.
appsfrom2021containmoresrcssthanonesfrom2012.atthe same time app sizesalsogrowsignificantly.
we checked the exceptionally high value for in figure by repeating the analysis with a second data set.
in addition to androzoo wealsoanalyzed300appsfromasamplethatwehad crawled ourselves from dlapk6in .
the dlapk data set leads to around more srcss and emphasizes the outlier.
we do not find this outlierto be reflectedinthe app sizes.
giventhelargespreadinthesizesofindividualapps compare the median and average code sizes in table we must verify thattheincreaseovertimeisnotcausedbyastatisticalerror.we computeavectorofsrcscounts i.e.
avectorof300elementsin which eachelement isthecount of security relatedcode smells in the respective app.
to show that our trend is significant we refute thenullhypothesisthatallofthesevectorsweredrawnfromthe sameprobabilitydistribution.however sinceourgoalistoshow year security relatedcode smells srcss avg.
jimple units sec.
relatedcode smells avg.
appsize units figure numberofsrcss overthe years atrendthatisnotnecessarilystrictlymonotonic weweakenthe nullhypothesis.
insteadof comparing the vectors of twoadjacent years we combine a rolling window of two adjacent years i.e.
we compare2010and2011with2012and2013 thencompare2011and 2012with2013and2014 etc.thisapproachacknowledgesthatit maytake twoyears to significantly changethe number of srcss.
for refuting the weakened null hypothesis we apply the mannwhitney u test which does not assume a particular probability distribution.
more precisely this test checks whether when randomlypickingavaluefromthefirstsetandonefromthesecond one the first value is equally likely to be larger or smaller than the second value.
if this hypothesis is refuted we can assume that the valuesfromonesettendtobelargerthanthevaluesfromtheother set.
for all but one pair of vectors in our rolling window approach wewereabletorefutethenullhypothesiswithanerrorprobability of0.
i.e.
thetrendisstatisticallysignificant.wewerenotable torefute thenullhypothesisfor thecombined years first vector and2016 secondvector duetotheoutlierinthenumber ofsrcssin2016.
however this does not affectthe overalltrend.
248securitycode smellsin apps are we getting better?
esec fse november14 18 singapore singapore year security relatedcode smells srcss avg.srcssper loc sec.
relatedcode smells srcssper loc figure security related codesmellsper1000 loc to better understand how the security level develops in comparisontothecodesize wedividethenumberofsrcssperappbythe number of jimple statements as a measure for the code size of that app.
we then compute the average of these fractions for each year as shown in figure .
we find that while the number of srcss per 000linesofcodehasdecreasedsharplybetween2010and2013 it has aside from outliers in and stayed almost constant at a low level since then.
still due to the large and steady increase in app size a constant code error rate still leads to significantly more srcssinthe overallapp.
developersbuildtheirappsfromexistinglibraries.sincepopular libraries are shared between multiple apps a single srcs inside such a library can affect multiple apps.
for the security of the androidecosystem itisimportanttounderstandwhetherseparate issues in individual apps must be fixed one by one or whether security improvements can focus on shared libraries.
note that librariesarecompiledintotheapponandroid insteadofplatformwide sharing of library binaries.
therefore even if a srcs in a library is fixed app developers must still update their apps which at leastrequires recompilation withthe newlibrary version.
to better understand these considerations we analyze to which degreethediscoveredsrcssstemfromthird partylibraries see figure3 .
the blue line axis on the right shows the percentage offindingsinlibrarycode.theredline squares showsthetotal numberofsrcss whereasthegreenline emptycircles showsthe sumofsrcssdiscoveredinlibraries.thecountsusethescaleon the left the percentageuses the scaleonthe right.
until2013 onlyabout7 ofallsrcsswereinlibrarycodeon average.
this number rose to in .
from this point the percentagefellslightlytoabout18 in2021.weobservethatthe increasingtrend inthe overallnumber ofsrcssis not driven by libraries andthat mostsrcssare inapp specific code.
overallyears wefindthataround52 ofallclassesinanapp are library classes without a clear trend.
since the value is alwaysbetween and61 .the lowestvaluewas19 in2011.
year security related code smells srcss in librariestotal srcss librarysrcss of lib.srcss figure effect oflibrarieson srcss thecategorieswiththemostfindingsarenetwork cryptography andjavacodesecurity .allothercategoriesare responsible for less than one percent of all findings.
when looking at the number of affected apps we find a similar list of top categories.however wenotethat13categoriesoccurinmorethanone percent of all apps.
the top ones are network cryptography java code security storage inter component communication buildparametrization .inthefollowing we focusontrends inthesetop categories.
.
rq2 trends in cryptography figure4showsthedevelopmentof cryptography srcss cf.table .
the red boxes show the total number of crypto srcss over all apps in the respective year connected for visualizing the trend.
thecryptocategoryshowsasimilartrendastheoverallfindings includingapeakinyear2016.thebluedotsshowthenumberof apps in which at least one crypto srcss was found.
recall that our datasetcontains300apps peryear.wefindthatsince2014 more than80 ofallappscontainatleastonesuchsrcsandaplateau has been reached.
this means that a randomly picked app from ismore likely to misuse cryptoapis thanone from .
we find uses of outdated cryptographic algorithms to represent between and of all findings in the cryptography category.
the trends of this srcs type almost exactly match the trends of the entire category.
figure 5shows that most uses of outdated cryptographic functions involve hashes.
since nist deprecated the useofsha 1in2011anddisalloweditsusefordigitalsignatures bytheendof2013 weconsideritsuseabadcodingpractice.
notethat we usethe same nist based catalogof outdated crypto algorithms across the entire data set.
we would therefore expect to find more outdated algorithms in older apps.
however our data indicates the contrary.
wefindthatsha bluecurve gainedincreasinguseinandroid apps after md5 grey curve albeit at a time when sha was already being phased out according to nist.
we see that uses of md5grewfrom2012onward whereassha 1gainedtractionafter .atthispoint developerswerealreadyadvisedtouseother algorithmssuchassha .wefurthernotethatthenumberof 249esec fse november14 18 singapore singapore stevenarzt year security relatedcode smells srcss appscryptosrcss apps withcryptoscrs figure numberofcryptosrcssovertheyears year algorithm usesdes tripledes blowfish md5 sha aes sha256 figure development ofcryptoalgorithmuse codelocationsthatusemd5wasstillgrowingevenafterthispoint.
therefore our data does not suggest a switch from md5 to sha butratheraco existenceofbothalgorithmswithmd5stillbeingthe most prevalent algorithm.
similarly although sha is deprecated formorethanadecadebynow wealsofailtoseeafullswitchto otheralgorithmssuchassha 256inandroidapps butfindnew uses of sha to be introduced every year.
the use of sha gained traction after .
we find that its use surpassed the use of md5 in and the use of sha in .
still the uses of sha from on grow slower than those of md5 and sha .
for the ciphers we find find aes to be the most prevalent algorithm in android apps over the entire data set.
its use increases significantly after but surpasses the use of earlier algorithms over all years.
we note that earlier encryption algorithms are almostirrelevantinandroidapps.still weobservesometrendsin thefewappsthatrelyonolderalgorithms.wefindanincreasing useoftheoutdateddesalgorithmfrom27instancesin2010to118instances in .
while the trend for the hash functions is almost monotonic the trend is more blurred for ciphers.
we attribute this tothecomparablylownumbers.theuseoftriple des 3des does not change significantly over time in in .
however wefindaslighttrendtowardsusingtheblowfishalgorithmin recentyearswithatmost14usesuntil2019 but46usesin2020and usesin .blowfish isconsidered outdatedin the successor twofish orthe more standardnist approvedalgorithm aes.
we further analyze the ratio between the number of uses of outdated crypto algorithms and the code size in jimple statements butdonotfindacleartrend.thereareindividualpeaks e.g.
for desin2014andforsha 1andmd5in2020 buttheprevalenceof individual algorithms is largely irrelevant from the overall growth ofthe app code.
whendividingtheusesofoutdatedalgorithmsbythetotalnumber ofcrypto algorithmuses i.e.
calls to cipher.getinstance and related methods we find the use of md5 to drop from its peak in2010at43 toabout21 in2021.the use ofsha drops from in to in .
however we also find a drop in sha from in to in .
we attribute these decreases to more differentalgorithms being used e.g.
ripemd160 or sha .
in we find different algorithm configurations e.g.
sha256withrsaandmgf1 with128configurationsin2021.
.
rq2 trends in build parametrization the category build parametrization contains checks for insecure buildconfigurations ofnative libraries contained inthe apps.
not activatingtheno execute nx flagordisablingaddressspacelayout randomization are such issues.
in contrast to other findings this categorycontainsmissingcountermeasuresrather thanpotential vulnerabilities.
since these countermeasures have long become standard configurations in compilers and tool chains we expect them to be universally adopted.
the nx flag was introduced to the arminstructionsetwitharmv6releasedin2002andtothex86 instruction setaround2004.we thereforeexpectthefeature tobe knownto app developers from the startof our data setin2010.
however our data shows see figure that such missing countermeasuresappearevenmorefrequentlyinrecentapps.thered line square marks show the number of findings the blue line round marks shows the number of apps with at least one affected library.wefindthat thenumberoffindingsoverallappsshowsa similar trend as the number of native libraries over all apps green line triangular marks in recent years.
a single app can contain multiplelibraries whichexplainswhythetrendofmissingcountermeasure can increase more rapidly than the number of affected apps.forthenumberoflibraries wecountall .sofilesintheapk files.
an app can contain the same library compiled for different targetplatformssuchasx86 arm mips etc.sinceallfilesmaybe built with different configurations even if the source is identical we considerallofthesebuildartifacts as individuallibraries.
misconfiguredbuildflagsareremarkablesincenewly developed libraries shouldbe built withpropersettings bydefaultandfixing theseissuesinanexistingcodebaseonlyrequireschangestothe buildconfigurationandistransparentto mostusercode.
250securitycode smellsin apps are we getting better?
esec fse november14 18 singapore singapore year srcss apps librares inside appsbuildsrcss apps withbuildsrcss native libraries figure numberofbuildsrcssovertheyears year security relatedcode smells srcss appsbackendcredentials apps withbackendcredentials figure numberofbackendcredentials overtheyears .
rq2 backend credentials in code we found credentials for backend services inside android apps especially between and see figure .
depending on theprivileges that theseaccountshave onthe respective backend systems attackers may be able to extract data from arbitrary users of the app or to misuse the computational cloud resources of the app developer .
the problem seems to have widely been resolved in recent years.
despite an increase in affected apps in thetotalnumberofcredentialsdecreased.evenin2020 there are only apps outof300 .
withthis issue.
.
rq2 trends in java codesecurity figure8shows how the number of java code security findings develops over the years.
the java code security category contains checksonaccessestoprivatefieldsandmethodsviajavareflection.
the latter may skip permission checks or input validation that would have been performed if the proper public api had been2010 year security related code smells srcss appscode securitysrcss apps with code securitysrcss figure numberofcodesecuritysrcss overthe years used.
this may not immediately be an exploitable vulnerability but is bad coding style as it breaks the principle of separation of concernandjava scodeisolation.wenotethatpluginarchitectures inwhichtargetclassesormethodsareconfiguration dependentare uncommoninandroidapps.smallerappsaremonolithic.forlarger appswithoptionalcomponentsinstalledondemand theplaystore regulationsonlyallowsuchdynamiccodeloadingviatheplaystore api.appupdatesarealsoperformedviathestore.notethatvusc only counts a reflective access if the setaccessible method is calledtoexplicitlymakeatargetfieldormethodaccessible thereby disabling java schecksonthe access flags of the field ormethod.
wefindthenumberofsrcsstoincreaseovertheyears.around of all srcss in this category are about private method and field accesses.
other checks focus on the insecure use of custom class loaders.
a class loader must verify the requested permissions in the context of the current security manager.
developers should therefore inherit from secureclassloader and invoke the getpermissions method of the superclass when overriding it in their own class.
security managers are used to separate code withdifferenttrustlevels suchasmainapplicationandplugins on traditional java vms.
android on the other hand isolates code on theapplevel.theofficialdocumentationstatesthat application developerscanassumethatthere snosecuritymanagerinstalled.
7. consequently findingsonclass loadersecurity are less relevant.
we find about of all code security srcss to stem from librarycode.thenumbersdecreasefromabout25 in2010toabout in .
we can therefore conclude thatdependency injection frameworks thatusejava reflection for invertingthecontrolflow dependencies are not responsible for the majority of thesesrcss.
.
rq2 trends in storage security inthestoragecategory weseeanincreaseinthetotalnumberof srcssandthenumberofappsaffectedbythemuntil2019anda declineafterwardsasshowninfigure .futureresearchneedsto showwhether the downwardstrend continues inthe future.
thestoragecategorycontains checkswhetherapps change file permissions to world readable orworld writable .
such a change 251esec fse november14 18 singapore singapore stevenarzt year security relatedcode smells srcss appsstorage srcss apps withstorage srcss figure numberofstorage srcssovertheyears makesthefilesaccessibletoallappsinstalledonthesamephone effectively disabling android s app isolation.
similar checks apply to the security flags for android s shared preference key value storage.bydefault thisstoreisonlyaccessiblebytherespective app.
however developers can explicitly configure the shared preferencestoreas worldreadable whichisexplicitlydiscouragedin the android documentation.
explicitlymakingdirectoriesworldexecutableandfilesworld readable chmod rankhighestasindividualfindingsinthiscategory withalmostequalcounts 530and1 425issuesrespectivelyover all years .
requesting a world readable stream from the android apioccursinonlyaboutathirdofthesecases 532issues followed bydirectorytraversalsuponwriteaccess 343cases .in190cases we found apps to attempt installing another app from insecure storage such as the sd card which is shared between all apps.
appscannotsilentlyinstallotherappsunlesstheyaresystemapps i.e.
signed with the android system key or the device is rooted.
for most apps and configurations neither is the case.
therefore installing an app on android is only possible through either the google play store or if sideloading is enabled by launching the apkinstallerwhichpromptstheuser.updatesofappsobtainedvia thestoreshouldbeperformedviathestore.enablingsideloading allowstheinstallationofarbitraryuncheckedandpotentiallyunsafe apps albeitwithuserconfirmation .appsshouldnotencourage users to enable this option.
further if the app to be installed is loaded from shared storage other apps on the same device may manipulate it before installation.
a low privileged app may abuse such a vulnerability to inject malicious code into a high privileged app before installation.
.
rq3 individual codesmells weanalyzeourdatasetforthemostprevalentsrcssoverallyears andthencheckhowthesetop10srcsshavedevelopedoverthe years ofour dataset.for this analysis we count thenumber of apps affected by a srcs not the number of srcss.
note that some srcss such as improper tls host name verification only affect a small number of statements in the app since the same customhostnameverifier implementation is re used for all connections.
a custom host name verifier requires more code and developers avoidclutteringtheirappwithrepeatingthiscode.othersrcss such as outdated crypto algorithms are usually repeated at each statement that initializes a new cipherobject.
initializing a cipher is a single statement that takes the algorithm as a string parameter.
thefollowinglistshowsthetoptensrcssintermsofaffectedapps.
the percentages are computed over the entire data set ignoring the year to whichan app belongs.
contentprovideraccessfromwebviews .
javascript codeinsideawebviewcontrolisallowedtoaccessdatafrom contentproviders.thismayallowuntrustedjavascriptcode to access ormanipulateapp data.
insecure crypto algorithm .
the app uses a cryptographic algorithm that isnolonger consideredsecure.
webviewuniversalaccess .
codeinwebview controls is granted universal access to files content providers etc.
regardless of its origin.
this effectively disables the same originpolicyinside the webview.
insecure http connection .
.
the app uses unprotected http connections for accessingremoteservices.
hard coded cryptographic keys .
the app uses hardcoded keys for encrypting or decrypting data.
attackers can reverse engineertheapp extractthekeys anddecryptall data supposedlyprotectedbythis key.
webviewmixedmodecontent .
theappallowsamixtureofcontentdownloadedusingtlsconnectionsaswellas unprotectedconnectionsinsidethesamewebviewcontrol.
this may allow an attacker to inject malicious javascript or misleadinggraphics phishing intoan otherwise benign webapplicationshowninside an app.
webview file access .
code in webview controls may access files including ones inside the app s data directory.
if untrusted code is loaded this configuration may break android sapp isolation.
private field method access .
apps access private fields or methods via the java reflection api potentially skipping importantinputvalidation orsecurity checks.
deprecatedhttpclientimplementation .
theappusesa deprecated implementation of the http s client which does not support modern tlsversions.
staticinitializationvector .
aninitializationvectormust bechosenatrandomtoprotectagainsttheuseofprecomputed tables for brute force attacks against encryption algorithms.
the sum of all percentages exceeds because one app may contain multiple srcss.
some srcss are overlapping.
an app that activates universal access also implicitly activates file access.
however only explicit calls to the respective configuration apis are counted.ifthedeveloperexplicitlyactivatesuniversalaccess one srcsiscounted.only ifthedeveloperalsoexplicitly andunnecessarily activates file access as well asecondsrcsiscounted.
figure10showsthedevelopmentofthetopfivefindingsover thetwelveyearsofourdataset.wefindthatthenumberofapps affected by the top cryptography srcss is consistent with our analysisofthe cryptography categoryinthescanner seefigure .
theuseofinsecurecryptoalgorithmsincreasesuntilabout2015 252securitycode smellsin apps are we getting better?
esec fse november14 18 singapore singapore year apps hard codedcryptokey insecure cryptoalgorithm universal access insecure http connection contentprovideraccess figure development oftopfindings apps and then arrives at a platform at about affected apps.
it does not decrease over time as discussed in section .
.
the number of apps thatcontain hard coded cryptographickeysshowsaclear increasing trend over the twelve years.
themisconfigurationofwebviewstoallowjavascriptcodeto access content providers increases until and then drops.
it remains open whether the rebound in is the beginning of a trend.wefindthecontentprovideraccesstrendlinetobeverysimilar to the trend for universal access until .
conceptually both srcss are similar as they affect the same android class webview andtheaccesspermissionsofthejavascriptcodeloadedinsidethis webview.wefindthenumberofappswithuniversalaccesssrcss todropsignificantlyafter2016toabouthalfofthevaluefrom2016.
the methodthatenables universalaccesswas deprecatedinapi level android released in september .
we note that developers stoppedusing this configurationseveral years before.
the use of insecure http connections no tls decreases over recentyearsaswell.wenotethatthisdecreasestartedbeforethe release of android with its api level .
from this version on the android operating system required apps to explicitly opt in for cleartext traffic using a network security configuration file.
the use of deprecated https client implementations also decreases over recentyearsinaratesimilartothecleartexttrafficsrcs.whilethe networksecurityconfigurationistechnicallyindependentfromthe tlsclient developersthatupdatetheirapp snetworkconnectivity mayalsoswitch the tlsimplementation.
we furtheranalyze themostfrequent srcssin appsto investigatetrends i.e.thenumberofsrcssfoundintheapps regardlessof the number of apps affected.
as explained above counts cannot be used to compare different types of srcss as some security configurationsare centralized e.g.
network securityconfiguration and others are spread across the code e.g.
encryption algorithms specified with every cipher initialization .
still we investigate whether counting the srcss shows different trends than counting the apps affectedbythesesrcssover the years.
wefindthepercentagesofindividualsrcss numberofoccurrences of a given srcs divided by the total number of srcss of all2010 year security relatedcode smells srcss insecure cryptoalgorithm private method field access deprecatedhttps client insecure http connection content provideraccess figure development oftopfindings findings types tobelow withonly6srcstypesexceeding5 .wetherefore presentonlythetopfivelist whichstillaccountsformorethan50 of all srcss.
we find the top srcss in terms of srcs count to all be contained in the top ten list of srcss when counting affected apps albeit inadifferentorder.
insecure cryptoalgorithm .
privatefield method access .
content provideraccess fromwebviews .
insecure httpconnection .
deprecated httpclientimplementation .
figure11showsthedevelopmentofthetopfivefindingsinterms of number of findings over the years.
we see an increase in almost alltypesofsrcssovertheyears.thefigureshowsaclearupwards trend on the number of code locations that access private fields ormethodusingthejavareflectionapi.similarly weseeasharp increaseinthenumberoffindingsconcerningtheuseofinsecure cryptographicalgorithms.althoughtheuseofinsecurecryptoalgorithmsandtheprivatefield methodaccessesshowsimilartrends bothtypesofsrcsarenotconnectedconceptually.cryptomethodssuchas cipher.getinstance arepartofthepublicapiof the java cryptography extension jce .
even if third party implementations such as bouncycastle are used they integrate into jce as providers which are referenced through algorithm and provider namesprovidedasstrings.
therefore noaccessto privatemethods isnecessary.we conclude that both trends are independent.
bothtypesofsrcsincreasebythehighestrateafter2018 which cannot be explained by the growth of apps in terms of code size number of jimple statements .
the sharp increase of app sizes between2012and2016isnotreflectedinthesrcss andafter2018 theappsizesonly growsubstantiallybetween2019and2020 but notovertheentireperiod asshowninfigure .weobservethat the number of findings per thousand lines of code increases i.e.
the qualityofthe code decreaseswithregardto thesesrcss.
wefindthetwomostrelevantsrcsstoberesponsibleforabout ofallfindings.thetop10findingsaccountforalmost75 ofall findings.ifwehadnotexcludedthe permissions category halfofall findings would be related to this category.
the most common case 253esec fse november14 18 singapore singapore stevenarzt isotherappsinvokingpermission protectedandroidapisviainterprocess communication confused deputy attack .
as explained in section2 most of these permissions are not sensitive e.g.
internet access.therefore thiscategorydoesnotprovideadditionalinsights intothe security ofapps.
discussion inthissection weinterpretourevaluationdatainthecontextof softwaredevelopmentbestpracticesandfutureresearchdirections.
thenotionofsecurityvulnerabilitiesand therespectivesrcss changeovertime.cryptographicalgorithms for example canbecomeoutdatedduetoincreasesincomputationalpoweroradvances in cryptanalysis.
theprincipletobuildapps andlibraries toallow for exchanging algorithms later is known as crypto agility .
we therefore expect a current scanner vulnerability patterns from todetect insecurecrypto algorithmsinolderapps although thesealgorithmswereconsideredsafewhentherespectiveappwas built.
however we findthat more modern apps are more likely to useoutdated cryptographythanolderapps.further modernapps use outdated algorithms more frequently i.e.
at more positions in the code.
in other words our data indicates that developers not only fail to replace outdated algorithms but introduce new uses of outdatedalgorithms.future researchshouldprovidebetter means for refactoring legacyapps for cryptoagility.
note that we cannot distinguish whether developers attempt tofixexistingfeaturesthatdidnotusecryptographybyintroducingoutdatedalgorithmsfromnewfeaturesbeingintroducedwith outdated algorithms.
in other words we do not know whether theintroductionof e.g.
md5isbetterthanapreviousversionof the same app with no protection at all.
further we cannot infer whetherthealgorithm isusedfor asecurity criticalpurpose.still developers should use modern algorithms in all cases to avoid vulnerabilities by avoiding insecure coding patterns entirely.
there is alreadylimitedworkonautomaticallyfixingcertaintypesofissues regardless oftheircriticality .
while our evaluation has shown that srcss can be detected in android apps our data also shows that the number of srcss increases over the years.
while not every potentially vulnerable code pattern identified by a static code scanner is necessarily exploitable itshowsthat despite alladvances inthe field developers lacksupportforin depthsecuritythatavoidssuchriskypatterns.
we therefore argue that novel approaches are required to integrate software security intothe app developmentlifecycle.
wehaveidentifiedthatmostsrcssarelocatedinapp specific codeandnotinlibrarycode.thismakesthesrcsshardertofix because each app has a separate codebase with only a very limited numberofsharedclasses.therefore developersandstoreoperators mustcheckeachindividualapp e.g.
beforeadmissiontothestore.
related work statisticsonthegoogleplaystore includingitsevolutionovertime havebeendonebefore.thesepreviousstudiesfocusedonlanguage features libraryusage andapplicationcontent .otherstudieshavefocusedontheevolutionofmalwareapps orhave derived insights into app development processes .
arzt has shown that shortcomings in security and quality are correlated .some works on app store security have focused on the trustworthinessofthird partyappstores e.g.
incountriesinwhichtheplay store isnot available .
androvul annotatesappsfromandrozoowithmetadataon dangerous permissions code smells and results from androbugs8.
the latter provides six categories and metrics.
vusc checks formorethan370typesofvulnerabilities.further androvulperforms no longitudinal analysis of their data set.
in summary to the best ofourknowledge we arethefirstto analyzetheevolution of vulnerabilitiesinbenign apps.
many works have been published on detecting individual types ofsecurityvulnerabilities e.g.
inter componentcommunication and tls misconfigurations and potential privacy violations .
further commercial and open source tools alike integrate thesechecksintoscanners.
existing work has also focused on vulnerabilities inherited from third party libraries compiled into the apps and whether app developers update theirdependencies .
ourstudy onthe other hand focuses onthe entire app includingapp specific code.
in contrast to analyzing existing app stores and their apps researchers have proposed novel app stores that only distribute apps thatarecompatiblewithsecurityandprivacypoliciesdefinedby the user orthe store operator .
conclusion in this paper we have analyzed the development of app security overtheyearsbetween2010and2021.ouranalyseshaveshown that the rate of security related code smells srcss per lines ofcode hasdecreasedovertime andhasleveledoffatalowrate.
however thisimprovementinsecurityisoutweighedbythecontinuing increase in app size.
consequently a randomly chosen app downloaded from the store in has more srcss than a randomly chosenappfrom2010.wefindthisincreasetobedriven by cryptographic weaknesses insecure compiler flags java code security flaws such as misuses of the java reflection api and insecure uses of webview components.
we argue that more work isnecessarytoimprovethesecuritylevelofandroidappsandto avoid insecure code patterns.
further developers should be trained better to better maintain their code e.g.
by replacing outdated cryptographicalgorithms.
as future work we plan to repeat the study with different code scanners and compare the results.
we will further extend the analysis to other app stores aside from google play.
we invite the communitytoconfirmourresults andtoinvestigatetherelationship between srcssandexploitablesecurity vulnerabilities.